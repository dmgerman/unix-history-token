begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|POP
end_ifndef

begin_comment
comment|/* bb_wtmail.c - write mail to a BBoard */
end_comment

begin_else
else|#
directive|else
else|POP
end_else

begin_comment
comment|/* po_wtmail.c - write mail for a POP subscriber */
end_comment

begin_endif
endif|#
directive|endif
endif|POP
end_endif

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"mmdf.h"
end_include

begin_include
include|#
directive|include
file|"bboards.h"
end_include

begin_include
include|#
directive|include
file|"cnvtdate.h"
end_include

begin_include
include|#
directive|include
file|"ch.h"
end_include

begin_include
include|#
directive|include
file|"phs.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RP_DOK
end_ifndef

begin_define
define|#
directive|define
name|submitopts
value|"vmth%s*"
end_define

begin_else
else|#
directive|else
else|RP_DOK
end_else

begin_define
define|#
directive|define
name|submitopts
value|"vkmth%s*"
end_define

begin_endif
endif|#
directive|endif
endif|RP_DOK
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|POP
end_ifndef

begin_define
define|#
directive|define
name|RP_NOPE
value|RP_AOK
end_define

begin_define
define|#
directive|define
name|MBXMODE
value|BBMODE
end_define

begin_else
else|#
directive|else
else|POP
end_else

begin_define
define|#
directive|define
name|RP_NOPE
value|RP_USER
end_define

begin_define
define|#
directive|define
name|MBXMODE
value|sentprotect
end_define

begin_decl_stmt
specifier|extern
name|int
name|sentprotect
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|POP
end_endif

begin_decl_stmt
name|int
name|err_fd
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ds_address
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bbrduid
decl_stmt|,
name|bbrdgid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|chnlname
decl_stmt|,
name|chnlinfo
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|POP
end_ifndef

begin_decl_stmt
name|char
name|bbrdaddr
index|[
name|LINESIZE
index|]
decl_stmt|,
name|bbrdfrom
index|[
name|LINESIZE
index|]
decl_stmt|,
name|bbrdheader
index|[
name|LINESIZE
index|]
decl_stmt|,
name|bbrdhome
index|[
name|LINESIZE
index|]
decl_stmt|,
name|bbrdtime
index|[
name|LINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not POP
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|qu_msgfile
decl_stmt|,
modifier|*
name|delim1
decl_stmt|,
modifier|*
name|delim2
decl_stmt|,
modifier|*
name|lckdfldir
decl_stmt|,
modifier|*
name|locname
decl_stmt|,
modifier|*
name|sitesignature
decl_stmt|,
modifier|*
name|supportaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bboard
modifier|*
name|curbb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|LLog
modifier|*
name|logptr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|lk_fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|bb_init
argument_list|(
argument|chanptr
argument_list|)
end_macro

begin_decl_stmt
name|Chan
modifier|*
name|chanptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|uid
decl_stmt|,
name|eid
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_init(chanptr=%s)"
argument_list|,
name|chanptr
operator|->
name|ch_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chnlname
operator|=
name|chanptr
operator|->
name|ch_name
expr_stmt|;
ifndef|#
directive|ifndef
name|notdef
name|sprintf
argument_list|(
name|chnlinfo
argument_list|,
name|submitopts
argument_list|,
name|chnlname
argument_list|)
expr_stmt|;
else|#
directive|else
else|notdef
comment|/* the following is probably a BAD idea */
if|if
condition|(
name|chanptr
operator|->
name|ch_host
operator|==
name|NULL
condition|)
name|chnlinfo
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* local delivery ONLY */
else|else
name|sprintf
argument_list|(
name|chnlinfo
argument_list|,
name|submitopts
argument_list|,
name|chanptr
operator|->
name|ch_host
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
ifndef|#
directive|ifndef
name|POP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|BBOARDS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err_abrt
argument_list|(
name|RP_BHST
argument_list|,
literal|"no passwd entry for '%s'"
argument_list|,
name|BBOARDS
argument_list|)
expr_stmt|;
else|#
directive|else
else|POP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|POPUID
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err_abrt
argument_list|(
name|RP_BHST
argument_list|,
literal|"no passwd entry for '%s'"
argument_list|,
name|POPUID
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|POP
name|bbrduid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|bbrdgid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
ifndef|#
directive|ifndef
name|POP
name|sprintf
argument_list|(
name|bbrdfrom
argument_list|,
literal|"%s@%s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|locname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"distributing as '%s'"
argument_list|,
name|bbrdfrom
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|bbrdhome
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not POP
ifndef|#
directive|ifndef
name|POP
if|if
condition|(
operator|!
name|setbbent
argument_list|()
condition|)
name|err_abrt
argument_list|(
name|RP_BHST
argument_list|,
literal|"setbbent() failed"
argument_list|)
expr_stmt|;
else|#
directive|else
else|POP
if|if
condition|(
operator|!
name|setpwinfo
argument_list|(
name|pw
argument_list|,
name|POPDB
argument_list|,
literal|1
argument_list|)
condition|)
name|err_abrt
argument_list|(
name|RP_BHST
argument_list|,
literal|"setbbinfo(%s, %s, 1) failed"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|POPDB
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|POP
name|getwho
argument_list|(
operator|&
name|uid
argument_list|,
operator|&
name|eid
argument_list|)
expr_stmt|;
if|if
condition|(
name|eid
operator|!=
literal|0
condition|)
name|err_abrt
argument_list|(
name|RP_BHST
argument_list|,
literal|"not running as root"
argument_list|)
expr_stmt|;
return|return
name|RP_OK
return|;
block|}
end_block

begin_macro
name|bb_end
argument_list|(
argument|result
argument_list|)
end_macro

begin_decl_stmt
name|short
name|result
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_end(result=0%o)"
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|RP_OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|bb_sbinit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_sbinit()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|RP_OK
return|;
block|}
end_block

begin_macro
name|bb_sbend
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_sbend()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|RP_OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|bb_winit
argument_list|(
argument|info
argument_list|,
argument|sender
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|info
decl_stmt|,
modifier|*
name|sender
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_winit(info='%s',sender='%s')"
argument_list|,
name|info
argument_list|,
name|sender
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|RP_OK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|bb_wtadr
argument_list|(
argument|host
argument_list|,
argument|adr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|host
decl_stmt|,
modifier|*
name|adr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|short
name|count
decl_stmt|,
name|result
decl_stmt|;
name|int
name|len
decl_stmt|,
name|md
decl_stmt|,
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|long
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|pos
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_wtadr(host=%s,adr=%s)"
argument_list|,
name|host
argument_list|,
name|adr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|adr
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|make_lower
argument_list|(
name|adr
argument_list|,
name|adr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curbb
operator|=
name|getbbnam
argument_list|(
name|adr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|RP_USER
return|;
ifndef|#
directive|ifndef
name|POP
name|sprintf
argument_list|(
name|bbrdaddr
argument_list|,
literal|"local-%s-request@%s"
argument_list|,
name|curbb
operator|->
name|bb_name
argument_list|,
name|locname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not POP
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"=> BBoard %s: file='%s' info='%s'"
argument_list|,
name|curbb
operator|->
name|bb_name
argument_list|,
name|curbb
operator|->
name|bb_file
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curbb
operator|->
name|bb_file
operator|==
name|NULL
operator|||
operator|*
name|curbb
operator|->
name|bb_file
operator|==
name|NULL
condition|)
return|return
name|RP_NOPE
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"begin local delivery..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printx
argument_list|(
literal|"\r\nperforming local delivery to file %s...\n"
argument_list|,
name|curbb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
name|qu_rtinit
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|curbb
operator|->
name|bb_file
argument_list|,
name|bbrduid
argument_list|,
name|bbrdgid
argument_list|,
name|MBXMODE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|RP_FIO
return|;
ifndef|#
directive|ifndef
name|POP
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mbx_init
argument_list|()
argument_list|)
condition|)
block|{
name|mbx_close
argument_list|(
name|curbb
operator|->
name|bb_file
argument_list|,
name|md
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
endif|#
directive|endif
endif|not POP
name|pos
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|strlen
argument_list|(
name|delim1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|delim1
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
block|{
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error writing delim1"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
name|start
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|POP
name|count
operator|=
name|strlen
argument_list|(
name|bbrdheader
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|bbrdheader
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
block|{
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error writing BBoard information"
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
for|for
control|(
name|cp
operator|=
name|bbrdheader
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
operator|,
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
endif|#
directive|endif
endif|not POP
while|while
condition|(
name|rp_gval
argument_list|(
name|result
operator|=
name|qu_rtxt
argument_list|(
name|buffer
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
operator|==
name|RP_OK
condition|)
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
operator|(
name|offset
operator|=
name|strindex
argument_list|(
name|delim1
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|offset
index|]
operator|++
control|)
continue|continue;
for|for
control|(
name|offset
operator|=
literal|0
init|;
operator|(
name|offset
operator|=
name|strindex
argument_list|(
name|delim2
argument_list|,
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|buffer
index|[
name|offset
index|]
operator|++
control|)
continue|continue;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error writing to file '%s'"
argument_list|,
name|curbb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOTOK
expr_stmt|;
goto|goto
name|clean_up
goto|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|cp
operator|=
name|buffer
init|;
name|offset
operator|<
name|len
condition|;
name|offset
operator|++
operator|,
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error reading from message file '%s'"
argument_list|,
name|qu_msgfile
argument_list|)
expr_stmt|;
name|clean_up
label|:
empty_stmt|;
name|stop
operator|=
name|lseek
argument_list|(
name|md
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|strlen
argument_list|(
name|delim2
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|md
argument_list|,
name|delim2
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error writing delim2"
argument_list|)
expr_stmt|;
name|map_write
argument_list|(
name|curbb
operator|->
name|bb_file
argument_list|,
name|md
argument_list|,
name|curbb
operator|->
name|bb_maxima
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pos
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"end local delivery..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|mbx_close
argument_list|(
name|curbb
operator|->
name|bb_file
argument_list|,
name|md
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|mbx_close
argument_list|(
name|curbb
operator|->
name|bb_file
argument_list|,
name|md
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|!=
name|NOTOK
condition|?
name|RP_OK
else|:
name|RP_FIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|bb_txtcpy
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|POP
name|short
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"bb_txtcpy()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curbb
operator|->
name|bb_dist
operator|==
name|NULL
operator|||
operator|*
name|curbb
operator|->
name|bb_dist
operator|==
name|NULL
operator|||
name|chnlinfo
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
name|RP_MOK
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"begin distribution..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|curbb
operator|->
name|bb_file
operator|==
name|NULL
operator|||
operator|*
name|curbb
operator|->
name|bb_file
operator|==
name|NULL
condition|)
name|printx
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|printx
argument_list|(
literal|"\rperforming remote distribution\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|dist_init
argument_list|()
argument_list|)
operator|||
name|rp_isbad
argument_list|(
name|result
operator|=
name|dist_adrs
argument_list|()
argument_list|)
operator|||
name|rp_isbad
argument_list|(
name|result
operator|=
name|dist_text
argument_list|()
argument_list|)
operator|||
name|rp_isbad
argument_list|(
name|result
operator|=
name|dist_end
argument_list|()
argument_list|)
condition|)
return|return
name|dist_lose
argument_list|(
name|result
argument_list|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"end distribution..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err_fd
operator|!=
name|NOTOK
condition|)
name|dist_lose
argument_list|(
name|RP_MOK
argument_list|)
expr_stmt|;
else|else
name|printx
argument_list|(
literal|"\rmessage distributed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not POP
return|return
name|RP_MOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|POP
end_ifndef

begin_comment
comment|/* **************** (dist_)  BBOARD DISTRIBUTION **************** */
end_comment

begin_macro
name|dist_init
argument_list|()
end_macro

begin_block
block|{
name|short
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|RP_NS
name|int
name|len
decl_stmt|;
name|struct
name|rp_bufstruct
name|reply
decl_stmt|;
endif|#
directive|endif
endif|RP_NS
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"dist_init()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_init
argument_list|()
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_init() failed [%s]"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_sbinit
argument_list|()
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_sbinit() failed [%s]"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_winit
argument_list|(
name|chnlname
argument_list|,
name|chnlinfo
argument_list|,
name|bbrdaddr
argument_list|)
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_winit('%s','%s','%s') failed [%s]"
argument_list|,
name|chnlname
argument_list|,
name|chnlinfo
argument_list|,
name|bbrdaddr
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|RP_NS
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_rrply
argument_list|(
operator|&
name|reply
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"problem with sender address [%s]"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
endif|RP_NS
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|dist_adrs
argument_list|()
end_macro

begin_block
block|{
name|short
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"dist_adrs()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|getbbdist
argument_list|(
name|curbb
argument_list|,
name|ds_address
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|RP_NO
argument_list|,
name|LLOGTMP
argument_list|,
literal|"getbbdist failed: %s"
argument_list|,
name|getbberr
argument_list|()
argument_list|)
return|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_waend
argument_list|()
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_waend() failed [%s]"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|ds_address
argument_list|(
argument|addr
argument_list|,
argument|host
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|addr
decl_stmt|,
comment|/* local part */
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rest */
end_comment

begin_block
block|{
name|short
name|result
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|rp_bufstruct
name|reply
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"ds_address(addr='%s',host='%s')"
argument_list|,
name|addr
argument_list|,
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printx
argument_list|(
literal|"\rperforming distribution to %s@%s...\n"
argument_list|,
name|addr
argument_list|,
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_wadr
argument_list|(
name|host
argument_list|,
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_wadr('%s','%s') failed [%s]"
argument_list|,
name|host
argument_list|,
name|addr
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_rrply
argument_list|(
operator|&
name|reply
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_rrply() failed [%s] getting status of '%s@%s'"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|,
name|addr
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
switch|switch
condition|(
name|rp_gval
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
condition|)
block|{
case|case
name|RP_AOK
case|:
ifdef|#
directive|ifdef
name|RP_DOK
case|case
name|RP_DOK
case|:
endif|#
directive|endif
endif|RP_DOK
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"address '%s@%s' [%s] -- %s"
argument_list|,
name|addr
argument_list|,
name|host
argument_list|,
name|rp_valstr
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
argument_list|,
name|reply
operator|.
name|rp_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
case|case
name|RP_NO
case|:
ifdef|#
directive|ifdef
name|RP_NS
case|case
name|RP_NS
case|:
endif|#
directive|endif
endif|RP_NS
case|case
name|RP_USER
case|:
case|case
name|RP_NDEL
case|:
case|case
name|RP_AGN
case|:
case|case
name|RP_NOOP
case|:
name|ds_log
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|,
name|LLOGTMP
argument_list|,
literal|"address '%s@%s' [%s] -- %s"
argument_list|,
name|addr
argument_list|,
name|host
argument_list|,
name|rp_valstr
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
argument_list|,
name|reply
operator|.
name|rp_line
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
comment|/* fail-soft */
default|default:
name|ds_log
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|,
name|LLOGFAT
argument_list|,
literal|"unexpected reply [%s] -- %s"
argument_list|,
name|rp_valstr
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
argument_list|,
name|reply
operator|.
name|rp_line
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|dist_text
argument_list|()
end_macro

begin_block
block|{
name|short
name|result
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"dist_text()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qu_rtinit
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
while|while
condition|(
name|rp_gval
argument_list|(
name|result
operator|=
name|qu_rtxt
argument_list|(
name|buffer
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
operator|==
name|RP_OK
condition|)
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_wtxt
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_wtxt() failed [%s]"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
return|return
name|ds_log
argument_list|(
name|RP_FIO
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error reading from message file '%s'"
argument_list|,
name|qu_msgfile
argument_list|)
return|;
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_wtend
argument_list|()
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_wtend() failed [%s]"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|dist_end
argument_list|()
end_macro

begin_block
block|{
name|short
name|result
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|rp_bufstruct
name|reply
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"dist_end()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rp_isbad
argument_list|(
name|result
operator|=
name|mm_rrply
argument_list|(
operator|&
name|reply
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
condition|)
return|return
name|ds_log
argument_list|(
name|result
argument_list|,
name|LLOGFAT
argument_list|,
literal|"mm_rrply() failed [%s] getting final status"
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
name|rp_gval
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
condition|)
block|{
case|case
name|RP_OK
case|:
case|case
name|RP_MOK
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGGEN
argument_list|,
literal|"message [%s] -- %s"
argument_list|,
name|rp_valstr
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
argument_list|,
name|reply
operator|.
name|rp_line
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mm_sbend
argument_list|()
expr_stmt|;
name|mm_end
argument_list|(
name|OK
argument_list|)
expr_stmt|;
return|return
name|result
return|;
case|case
name|RP_NO
case|:
case|case
name|RP_NDEL
case|:
case|case
name|RP_AGN
case|:
case|case
name|RP_NOOP
case|:
return|return
name|ds_log
argument_list|(
name|RP_NO
argument_list|,
name|LLOGTMP
argument_list|,
literal|"not delivered [%s] -- %s"
argument_list|,
name|rp_valstr
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
argument_list|,
name|reply
operator|.
name|rp_line
argument_list|)
return|;
default|default:
return|return
name|ds_log
argument_list|(
name|RP_RPLY
argument_list|,
name|LLOGFAT
argument_list|,
literal|"unexpected final reply [%s] -- %s"
argument_list|,
name|rp_valstr
argument_list|(
name|reply
operator|.
name|rp_val
argument_list|)
argument_list|,
name|reply
operator|.
name|rp_line
argument_list|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|dist_lose
argument_list|(
argument|result
argument_list|)
end_macro

begin_decl_stmt
name|short
name|result
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|intro
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGBTR
argument_list|,
literal|"dist_lose(result=0%o)"
argument_list|,
name|result
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|mm_end
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
name|printx
argument_list|(
literal|"\rerrors during distribution: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|domsg
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|intro
argument_list|,
literal|"bboards%d distribution for %s failed [%s]\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|curbb
operator|->
name|bb_name
argument_list|,
name|rp_valstr
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|loseaux
argument_list|(
name|bbrdaddr
argument_list|,
name|bbrdfrom
argument_list|,
name|intro
argument_list|)
operator|!=
name|OK
operator|&&
name|loseaux
argument_list|(
name|bbrdfrom
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|intro
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|printx
argument_list|(
literal|"unable to post advisory.\n"
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"unable to post failure notice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_fd
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|err_fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|err_fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"info: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loseaux
argument_list|(
name|supportaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|intro
argument_list|)
operator|!=
name|NOTOK
condition|)
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"unable to advise %s of failure!"
argument_list|,
name|supportaddr
argument_list|)
expr_stmt|;
block|}
else|else
name|printx
argument_list|(
literal|"advisory posted.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|domsg
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_fd
operator|!=
name|NOTOK
condition|)
block|{
name|close
argument_list|(
name|err_fd
argument_list|)
expr_stmt|;
name|err_fd
operator|=
name|NOTOK
expr_stmt|;
block|}
return|return
name|RP_MOK
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|int
name|loseaux
parameter_list|(
name|to
parameter_list|,
name|cc
parameter_list|,
name|intro
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|,
decl|*
name|cc
decl_stmt|,
modifier|*
name|intro
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|ml_init
argument_list|(
name|NO
argument_list|,
name|NO
argument_list|,
name|sitesignature
argument_list|,
literal|"Re-distribution Failure"
argument_list|)
operator|!=
name|OK
operator|||
name|ml_adr
argument_list|(
name|to
argument_list|)
operator|!=
name|OK
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|cc
operator|&&
operator|(
name|ml_cc
argument_list|()
operator|!=
name|OK
operator|||
name|ml_adr
argument_list|(
name|cc
argument_list|)
operator|!=
name|OK
operator|)
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|ml_aend
argument_list|()
operator|!=
name|OK
operator|||
name|ml_tinit
argument_list|()
operator|!=
name|OK
condition|)
return|return
name|NOTOK
return|;
name|ml_txt
argument_list|(
name|intro
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_fd
operator|!=
name|NOTOK
condition|)
block|{
name|lseek
argument_list|(
name|err_fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|err_fd
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ml_txt
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|encap
argument_list|()
expr_stmt|;
return|return
name|ml_end
argument_list|(
name|OK
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* very similar to sbr/cpydgst.c */
end_comment

begin_define
define|#
directive|define
name|S1
value|0
end_define

begin_define
define|#
directive|define
name|S2
value|1
end_define

begin_define
define|#
directive|define
name|output
parameter_list|(
name|c
parameter_list|)
value|if (bp>= dp) {flush (); *bp++ = c;} else *bp++ = c
end_define

begin_define
define|#
directive|define
name|flush
parameter_list|()
value|if (bp - outbuf) \ 			    *bp = NULL, ml_txt (outbuf), bp = outbuf
end_define

begin_expr_stmt
specifier|static
name|encap
argument_list|()
block|{
specifier|register
name|int
name|state
block|;
name|short
name|result
block|;
name|int
name|len
block|,
name|init
block|;
specifier|register
name|char
operator|*
name|cp
block|,
operator|*
name|ep
block|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|;
specifier|register
name|char
operator|*
name|bp
block|,
operator|*
name|dp
block|;
name|char
name|outbuf
index|[
name|BUFSIZ
index|]
block|;
name|qu_rtinit
argument_list|(
literal|0L
argument_list|)
block|;
name|dp
operator|=
operator|(
name|bp
operator|=
name|outbuf
operator|)
operator|+
sizeof|sizeof
name|outbuf
block|;
name|init
operator|=
literal|0
block|;
for|for
control|(
name|state
operator|=
name|S1
init|;
name|rp_gval
argument_list|(
name|result
operator|=
name|qu_rtxt
argument_list|(
name|buffer
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
operator|==
name|RP_OK
condition|;
control|)
for|for
control|(
name|ep
operator|=
operator|(
name|cp
operator|=
name|buffer
operator|)
operator|+
name|len
init|;
name|cp
operator|<
name|ep
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
continue|continue;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|S1
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|init
operator|==
literal|0
condition|)
block|{
name|ml_txt
argument_list|(
literal|"\n------- Forwarded Message\n\n"
argument_list|)
expr_stmt|;
name|init
operator|++
expr_stmt|;
block|}
name|output
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|output
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} 		    state
operator|=
name|S2
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* fall */
end_comment

begin_case
case|case
name|S2
case|:
end_case

begin_if
if|if
condition|(
name|init
operator|==
literal|0
condition|)
block|{
name|ml_txt
argument_list|(
literal|"\n------- Forwarded Message\n\n"
argument_list|)
expr_stmt|;
name|init
operator|++
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|output
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|state
operator|=
name|S1
expr_stmt|;
end_if

begin_break
break|break;
end_break

begin_expr_stmt
unit|} 	}
name|flush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"error reading message when noting failure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|ml_txt
argument_list|(
literal|"\n------- End of Forwarded Message\n\n"
argument_list|)
expr_stmt|;
name|ml_txt
argument_list|(
literal|"[ error reading message ]\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init
condition|)
name|ml_txt
argument_list|(
literal|"\n------- End of Forwarded Message\n\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"message empty when noting failure"
argument_list|)
expr_stmt|;
name|ml_txt
argument_list|(
literal|"[ message empty ]\n"
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS3 */
end_comment

begin_expr_stmt
unit|ds_log
operator|(
name|result
operator|,
name|level
operator|,
name|fmt
operator|,
name|a
operator|,
name|b
operator|,
name|c
operator|,
name|d
operator|,
name|e
operator|)
name|short
name|result
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|,
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|level
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buffer
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|printx
argument_list|(
literal|"\rerror: %s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_fd
operator|==
name|NOTOK
condition|)
block|{
name|unlink
argument_list|(
name|mktemp
argument_list|(
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
literal|"/tmp/bboardsXXXXXX"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err_fd
operator|=
name|creat
argument_list|(
name|tmpfil
argument_list|,
literal|0600
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|result
return|;
name|close
argument_list|(
name|err_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err_fd
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
return|return
name|result
return|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|err_fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|err_fd
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|not POP
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* mbx_	    local mailbox routines */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|POP
end_ifndef

begin_macro
name|mbx_init
argument_list|()
end_macro

begin_block
block|{
name|int
name|fd
decl_stmt|,
name|clear
decl_stmt|;
name|char
name|name
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mbx_Xopen
argument_list|(
name|curbb
operator|->
name|bb_info
argument_list|,
name|bbrduid
argument_list|,
name|bbrdgid
argument_list|,
name|MBXMODE
argument_list|,
operator|&
name|clear
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ETXTBSY
condition|)
block|{
name|printx
argument_list|(
literal|"\runable to lock %s\n"
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
name|ll_err
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"unable to lock %s"
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|RP_LOCK
return|;
block|}
name|printx
argument_list|(
literal|"\runable to open '%s'"
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
name|ll_log
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"unable to open '%s'"
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|RP_FOPN
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|printx
argument_list|(
literal|"\runable to fdopen '%s'"
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
name|ll_err
argument_list|(
name|logptr
argument_list|,
name|LLOGTMP
argument_list|,
literal|"unable to fdopen '%s'"
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
name|mbx_close
argument_list|(
name|curbb
operator|->
name|bb_info
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|RP_LIO
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|curbb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curbb
operator|=
name|getbbnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|bboard
operator|*
operator|)
name|NULL
condition|)
block|{
name|printx
argument_list|(
literal|"\runable to get information on BBoard %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ll_err
argument_list|(
name|logptr
argument_list|,
name|LLOGFAT
argument_list|,
literal|"unable to get info on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|RP_LIO
return|;
block|}
name|sprintf
argument_list|(
name|bbrdheader
argument_list|,
literal|"BBoard-ID: %d\nBB-Posted: %s\n"
argument_list|,
operator|++
name|curbb
operator|->
name|bb_maxima
argument_list|,
name|cnvtdate
argument_list|(
name|TIMREG
argument_list|,
name|bbrdtime
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n%s\n"
argument_list|,
name|curbb
operator|->
name|bb_maxima
argument_list|,
name|bbrdtime
argument_list|)
expr_stmt|;
name|lkfclose
argument_list|(
name|fp
argument_list|,
name|curbb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
return|return
name|RP_OK
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|not POP
end_endif

end_unit

