begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * header.c - header functions plus some other goodies  *  *	TAKEN FROM BNEWS 2.10 6/24/83  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|SccsId
init|=
literal|"@(#)header.c	2.20	6/24/83"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"$Header: bnewshead.c,v 1.7.0.1 85/03/06 20:03:00 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_comment
comment|/* from notes */
end_comment

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_comment
comment|/* ditto */
end_comment

begin_comment
comment|/* above maybe unused */
end_comment

begin_include
include|#
directive|include
file|"newsgate.h"
end_include

begin_function_decl
name|char
modifier|*
name|hfgets
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|seenrelay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bfr
index|[
name|PATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* header buffer */
end_comment

begin_comment
comment|/*  * Read header from file fp into *hp.  If wholething is FALSE,  * it's an incremental read, otherwise start from scratch.  * Return (FILE *) if header okay, else NULL.  */
end_comment

begin_expr_stmt
name|newsheader
argument_list|(
name|hp
argument_list|,
name|fp
argument_list|,
name|wholething
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wholething
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
name|wholething
condition|)
comment|/* from scratch */
name|bclear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|)
expr_stmt|;
name|seenrelay
operator|=
literal|0
expr_stmt|;
comment|/*  *	Check that it's a B news style header.  */
if|if
condition|(
operator|(
operator|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|PATHLEN
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|bfr
operator|>=
literal|'A'
operator|&&
operator|*
name|bfr
operator|<=
literal|'Z'
operator|)
operator|&&
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
if|if
condition|(
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
condition|)
goto|goto
name|strip
goto|;
comment|/*  * It's not.  Try A news (begins with PROTO).  */
if|if
condition|(
operator|*
name|bfr
operator|!=
name|PROTO
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	Read in an A news format article.  */
name|strncpy
argument_list|(
name|hp
operator|->
name|oident
argument_list|,
operator|&
operator|(
name|bfr
index|[
literal|1
index|]
operator|)
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
comment|/* file name */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|oident
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hfgets
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* newsgroup list */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ngcat
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
comment|/* trailing delim */
name|hfgets
argument_list|(
name|hp
operator|->
name|path
argument_list|,
name|PATHLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* source path */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|path
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hfgets
argument_list|(
name|hp
operator|->
name|subdate
argument_list|,
name|DATELEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* date */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hfgets
argument_list|(
name|hp
operator|->
name|title
argument_list|,
name|BUFLEN
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* title */
if|if
condition|(
operator|!
name|nstrip
argument_list|(
name|hp
operator|->
name|title
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  * strip off sys! from front of path.  */
name|strip
label|:
name|strcpy
argument_list|(
name|bfr
argument_list|,
name|System
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfr
argument_list|,
name|hp
operator|->
name|path
argument_list|,
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|&&
name|index
argument_list|(
name|NETCHRS
argument_list|,
name|hp
operator|->
name|path
index|[
name|len
index|]
argument_list|)
condition|)
name|strcpy
argument_list|(
name|hp
operator|->
name|path
argument_list|,
operator|&
operator|(
name|hp
operator|->
name|path
index|[
name|len
operator|+
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wholething
operator|&&
name|hp
operator|->
name|from
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* intuit the from: */
name|intuitfrom
argument_list|(
name|hp
argument_list|)
expr_stmt|;
comment|/* if wasn't there */
if|if
condition|(
name|wholething
condition|)
comment|/* Get message ID's. */
name|fixid
argument_list|(
name|hp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Get header info from mail-format file.  * Return non-zero on success.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|FROM
value|1
end_define

begin_define
define|#
directive|define
name|NEWSGROUP
value|2
end_define

begin_define
define|#
directive|define
name|TITLE
value|3
end_define

begin_define
define|#
directive|define
name|SUBMIT
value|4
end_define

begin_define
define|#
directive|define
name|RECEIVE
value|5
end_define

begin_define
define|#
directive|define
name|EXPIRE
value|6
end_define

begin_define
define|#
directive|define
name|ARTICLEID
value|7
end_define

begin_define
define|#
directive|define
name|MESSAGEID
value|8
end_define

begin_define
define|#
directive|define
name|REPLYTO
value|9
end_define

begin_define
define|#
directive|define
name|FOLLOWID
value|10
end_define

begin_define
define|#
directive|define
name|CONTROL
value|11
end_define

begin_define
define|#
directive|define
name|SENDER
value|12
end_define

begin_define
define|#
directive|define
name|FOLLOWTO
value|13
end_define

begin_define
define|#
directive|define
name|PATH
value|14
end_define

begin_define
define|#
directive|define
name|POSTVERSION
value|15
end_define

begin_define
define|#
directive|define
name|RELAYVERSION
value|16
end_define

begin_define
define|#
directive|define
name|DISTRIBUTION
value|17
end_define

begin_define
define|#
directive|define
name|ORGANIZATION
value|18
end_define

begin_define
define|#
directive|define
name|NUMLINES
value|19
end_define

begin_define
define|#
directive|define
name|KEYWORDS
value|20
end_define

begin_define
define|#
directive|define
name|APPROVED
value|21
end_define

begin_define
define|#
directive|define
name|NLINE1
value|22
end_define

begin_define
define|#
directive|define
name|NLINE2
value|23
end_define

begin_define
define|#
directive|define
name|OTHER
value|99
end_define

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|frmread
argument_list|(
name|fp
argument_list|,
name|hp
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unreccnt
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|curpos
decl_stmt|;
name|int
name|hdrlineno
init|=
literal|0
decl_stmt|;
name|int
name|iu
decl_stmt|;
for|for
control|(
name|iu
operator|=
literal|0
init|;
name|iu
operator|<
name|NUNREC
condition|;
name|iu
operator|++
control|)
name|hp
operator|->
name|unrec
index|[
name|iu
index|]
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|type
argument_list|(
name|bfr
argument_list|)
expr_stmt|;
do|do
block|{
name|curpos
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hdrlineno
operator|++
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|PATH
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|FROM
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWSGROUP
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|nbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|TITLE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBMIT
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|subdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECEIVE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|recdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXPIRE
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|expdate
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARTICLEID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
break|break;
case|case
name|MESSAGEID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
break|break;
case|case
name|REPLYTO
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|replyto
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWID
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|followid
argument_list|)
expr_stmt|;
break|break;
case|case
name|SENDER
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|sender
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOLLOWTO
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|followto
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTROL
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|ctlmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTVERSION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|postversion
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISTRIBUTION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|distribution
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORGANIZATION
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|organization
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMLINES
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
name|hp
operator|->
name|intnumlines
operator|=
name|atoi
argument_list|(
name|hp
operator|->
name|numlines
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEYWORDS
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|keywords
argument_list|)
expr_stmt|;
break|break;
case|case
name|APPROVED
case|:
name|getfield
argument_list|(
name|hp
operator|->
name|approved
argument_list|)
expr_stmt|;
break|break;
case|case
name|NLINE1
case|:
comment|/* notes-specific */
name|getfield
argument_list|(
name|hp
operator|->
name|nline1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NLINE2
case|:
comment|/* notes-specific */
name|getfield
argument_list|(
name|hp
operator|->
name|nline2
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELAYVERSION
case|:
comment|/*  		 * Only believe a relay version if it's the first 		 * line, otherwise it probably got passed through 		 * by some old neighbor. 		 */
if|if
condition|(
name|hdrlineno
operator|==
literal|1
condition|)
block|{
name|getfield
argument_list|(
name|hp
operator|->
name|relayversion
argument_list|)
expr_stmt|;
name|seenrelay
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OTHER
case|:
if|if
condition|(
name|unreccnt
operator|<
name|NUNREC
condition|)
block|{
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|bfr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|hp
operator|->
name|unrec
index|[
name|unreccnt
index|]
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
name|unreccnt
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|i
operator|=
name|type
argument_list|(
name|hfgets
argument_list|(
name|bfr
argument_list|,
name|LBUFLEN
argument_list|,
name|fp
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
operator|*
name|bfr
operator|!=
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|"Bizzaro header line: %s\n"
argument_list|,
name|bfr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *	Check to see if the REQUIRED headers are present.  If so, return  *	that we found a message. Otherwise barf.  */
if|if
condition|(
operator|(
name|hp
operator|->
name|from
index|[
literal|0
index|]
operator|||
name|hp
operator|->
name|path
index|[
literal|0
index|]
operator|)
operator|&&
name|hp
operator|->
name|subdate
index|[
literal|0
index|]
operator|&&
operator|(
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|||
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|)
condition|)
block|{
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * There was no From: line in the message (because it was generated by  * an old news program).  Guess what it should have been and create it.  */
end_comment

begin_expr_stmt
name|intuitfrom
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|host
decl_stmt|,
modifier|*
name|fullname
decl_stmt|;
name|char
modifier|*
name|tailpath
parameter_list|()
function_decl|;
name|char
modifier|*
name|at
decl_stmt|,
modifier|*
name|dot
decl_stmt|;
name|tp
operator|=
name|tailpath
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|user
operator|=
name|rindex
argument_list|(
name|tp
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|==
name|NULL
condition|)
name|user
operator|=
name|tp
expr_stmt|;
else|else
operator|*
name|user
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Check for an existing Internet address on the end. */
name|at
operator|=
name|index
argument_list|(
name|user
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
condition|)
block|{
name|dot
operator|=
name|index
argument_list|(
name|at
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* @ signs are illegal except for the biggie, so */
operator|*
name|at
operator|=
literal|'%'
expr_stmt|;
block|}
if|if
condition|(
name|tp
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|host
operator|=
name|index
argument_list|(
name|tp
argument_list|,
literal|'!'
argument_list|)
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|user
operator|==
name|tp
condition|)
name|host
operator|=
name|System
expr_stmt|;
else|else
name|host
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|index
argument_list|(
name|host
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|from
argument_list|,
literal|"%s@%s.%s"
argument_list|,
name|user
argument_list|,
name|host
argument_list|,
name|DFLTDOMAIN
argument_list|)
expr_stmt|;
name|fullname
operator|=
name|index
argument_list|(
name|hp
operator|->
name|path
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|fullname
operator|--
expr_stmt|;
name|strcat
argument_list|(
name|hp
operator|->
name|from
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
operator|*
name|fullname
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * If the message has only one of ident/oident, guess what  * the other one should be and fill them both in.  */
end_comment

begin_expr_stmt
name|fixid
argument_list|(
name|hp
argument_list|)
specifier|register
expr|struct
name|hbuf
operator|*
name|hp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|lbuf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|OLD
name|char
modifier|*
name|q
decl_stmt|;
endif|#
directive|endif
endif|OLD
if|if
condition|(
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
name|hp
operator|->
name|oident
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/*  	 * It may seem strange that we hardwire ".UUCP" in 	 * here instead of DFLTDOMAIN.  However, we are trying 	 * to guess what the domain was on the posting system, 	 * not the local system.  Since we don't really know 	 * what the posting system does, we just go with the 	 * majority - almost everyone will be a .UUCP if they 	 * didn't fill in their Message-ID. 	 */
name|sprintf
argument_list|(
name|hp
operator|->
name|ident
argument_list|,
literal|"<%s@%s%s>"
argument_list|,
name|p
argument_list|,
name|lbuf
argument_list|,
literal|".UUCP"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OLD
if|if
condition|(
name|hp
operator|->
name|oident
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|hp
operator|->
name|ident
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|lbuf
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|lbuf
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|hp
operator|->
name|oident
argument_list|,
name|hp
operator|->
name|ident
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
index|[
name|SNLN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|hp
operator|->
name|oident
argument_list|,
literal|"%s.%s"
argument_list|,
name|p
argument_list|,
name|lbuf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Get the given field of a header (char * parm) from bfr, but only  * if there's something actually there (after the colon).  Don't  * bother if we already have an entry for this field.  */
end_comment

begin_macro
name|getfield
argument_list|(
argument|hpfield
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|hpfield
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|hpfield
index|[
literal|0
index|]
condition|)
return|return;
for|for
control|(
name|ptr
operator|=
name|index
argument_list|(
name|bfr
argument_list|,
literal|':'
argument_list|)
init|;
name|isspace
argument_list|(
operator|*
operator|++
name|ptr
argument_list|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|hpfield
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|nstrip
argument_list|(
name|hpfield
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  *	Determine the type of the header  */
end_comment

begin_define
define|#
directive|define
name|its
parameter_list|(
name|type
parameter_list|)
value|(!strncmp(ptr,type,strlen(type)))
end_define

begin_macro
name|type
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|space
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|ptr
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|colon
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|space
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon
operator|||
name|colon
operator|+
literal|1
operator|!=
name|space
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"From: "
argument_list|)
condition|)
if|if
condition|(
name|index
argument_list|(
name|ptr
argument_list|,
literal|'@'
argument_list|)
operator|&&
operator|!
name|index
argument_list|(
name|ptr
argument_list|,
literal|'!'
argument_list|)
operator|&&
name|seenrelay
condition|)
return|return
name|FROM
return|;
else|else
return|return
name|PATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Path: "
argument_list|)
condition|)
return|return
name|PATH
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Newsgroups: "
argument_list|)
condition|)
return|return
name|NEWSGROUP
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Subject: "
argument_list|)
operator|||
name|its
argument_list|(
literal|"Title: "
argument_list|)
condition|)
return|return
name|TITLE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Posted: "
argument_list|)
operator|||
name|its
argument_list|(
literal|"Date: "
argument_list|)
condition|)
return|return
name|SUBMIT
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Date-Received: "
argument_list|)
operator|||
name|its
argument_list|(
literal|"Received: "
argument_list|)
condition|)
return|return
name|RECEIVE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Expires: "
argument_list|)
condition|)
return|return
name|EXPIRE
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Article-I.D.: "
argument_list|)
condition|)
return|return
name|ARTICLEID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Message-ID: "
argument_list|)
condition|)
return|return
name|MESSAGEID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Reply-To: "
argument_list|)
condition|)
return|return
name|REPLYTO
return|;
if|if
condition|(
name|its
argument_list|(
literal|"References: "
argument_list|)
condition|)
return|return
name|FOLLOWID
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Control: "
argument_list|)
condition|)
return|return
name|CONTROL
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Sender: "
argument_list|)
condition|)
return|return
name|SENDER
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Followup-To: "
argument_list|)
condition|)
return|return
name|FOLLOWTO
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Posting-Version: "
argument_list|)
condition|)
return|return
name|POSTVERSION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Relay-Version: "
argument_list|)
condition|)
return|return
name|RELAYVERSION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Distribution: "
argument_list|)
condition|)
return|return
name|DISTRIBUTION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Organization: "
argument_list|)
condition|)
return|return
name|ORGANIZATION
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Lines: "
argument_list|)
condition|)
return|return
name|NUMLINES
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Keywords: "
argument_list|)
condition|)
return|return
name|KEYWORDS
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Approved: "
argument_list|)
condition|)
return|return
name|APPROVED
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Nf-ID: "
argument_list|)
condition|)
return|return
name|NLINE1
return|;
if|if
condition|(
name|its
argument_list|(
literal|"Nf-From: "
argument_list|)
condition|)
return|return
name|NLINE2
return|;
return|return
name|OTHER
return|;
block|}
end_block

begin_comment
comment|/*  * Set nc bytes, starting at cp, to zero.  */
end_comment

begin_expr_stmt
name|bclear
argument_list|(
name|cp
argument_list|,
name|nc
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|nc
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|nc
operator|--
condition|)
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Strip trailing newlines, blanks, and tabs from 's'.  * Return TRUE if newline was found, else FALSE.  */
end_comment

begin_expr_stmt
name|nstrip
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|rc
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|s
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Append NGDELIM to string.  */
end_comment

begin_expr_stmt
name|ngcat
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|++
condition|)
empty_stmt|;
name|s
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|NGDELIM
condition|)
return|return;
block|}
operator|*
name|s
operator|++
operator|=
name|NGDELIM
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Return a compact representation of the person who posted the given  * message.  A sender or internet name will be used, otherwise  * the last part of the path is used preceeded by an optional ".."  */
end_comment

begin_function
name|char
modifier|*
name|tailpath
parameter_list|(
name|hp
parameter_list|)
name|struct
name|hbuf
modifier|*
name|hp
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|static
name|char
name|resultbuf
index|[
name|BUFLEN
index|]
decl_stmt|;
name|char
name|pathbuf
index|[
name|PATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
comment|/*       * This only happens for articles posted by old news software      * in non-internet format.      */
name|resultbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|pathbuf
argument_list|,
name|hp
operator|->
name|path
argument_list|)
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|pathbuf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Chop off trailing " (name)" */
name|r
operator|=
name|rindex
argument_list|(
name|pathbuf
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|pathbuf
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|r
operator|>
name|pathbuf
operator|&&
operator|*
operator|--
name|r
operator|!=
literal|'!'
condition|)
empty_stmt|;
if|if
condition|(
name|r
operator|>
name|pathbuf
condition|)
block|{
name|r
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|resultbuf
argument_list|,
literal|"..!"
argument_list|)
expr_stmt|;
block|}
block|}
name|strcat
argument_list|(
name|resultbuf
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|resultbuf
return|;
block|}
end_function

begin_comment
comment|/*  * hfgets is like fgets, but deals with continuation lines.  * It also ensures that even if a line that is too long is  * received, the remainder of the line is thrown away  * instead of treated like a second line.  */
end_comment

begin_function
name|char
modifier|*
name|hfgets
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/*  	 * Line too long - part read didn't fit into a newline 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
else|else
operator|*
operator|--
name|tp
operator|=
literal|'\0'
expr_stmt|;
comment|/* clobber newline */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
comment|/* continuation */
block|{
comment|/*  	 * Continuation line. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
comment|/* skip white space */
empty_stmt|;
if|if
condition|(
name|tp
operator|-
name|cp
operator|<
name|len
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
if|if
condition|(
name|tp
operator|-
name|cp
operator|<
name|len
condition|)
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|tp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* push back char */
return|return
name|cp
return|;
block|}
end_function

end_unit

