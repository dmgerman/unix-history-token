begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"parms.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSIDENT
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: acssort.c,v 1.7 85/01/18 15:40:40 notes Rel $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RCSIDENT
end_endif

begin_comment
comment|/*  *	acssort  *  *	Routines in this file are used to sort access lists.  *	Splintered off from access.c so that nfaccess.c can use  *	them.  *  *	Also contains routines to add entries to an access list  *	and to parse an ascii representation of an access right.  *  *	Ray Essick  */
end_comment

begin_macro
name|acscmp
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|perm_f
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*  *	people before groups before systems  *	Alphabetical within each class  */
if|if
condition|(
name|a
operator|->
name|ptype
operator|<
name|b
operator|->
name|ptype
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|ptype
operator|>
name|b
operator|->
name|ptype
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"Other"
argument_list|,
name|a
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|strcmp
argument_list|(
literal|"Other"
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
comment|/* put "Other" last */
if|if
condition|(
name|strcmp
argument_list|(
literal|"Other"
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is correct */
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  *	acssort  *  *	sort the access list  */
end_comment

begin_macro
name|acssort
argument_list|(
argument|alist
argument_list|,
argument|items
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|perm_f
name|alist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|items
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|qsort
argument_list|(
name|alist
argument_list|,
name|items
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perm_f
argument_list|)
argument_list|,
name|acscmp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	addmodes(io) struct io_f *io;  *  *	reads the access list and adds the modes specified in the  *	Newmodes array.  *	Checks for duplication and merely replaces with the new  *	permission in those cases.  */
end_comment

begin_macro
name|addmodes
argument_list|(
argument|io
argument_list|,
argument|nmodes
argument_list|,
argument|Newmodes
argument_list|,
argument|verbose
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|io_f
modifier|*
name|io
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|perm_f
modifier|*
name|Newmodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|perm_f
name|alist
index|[
name|NPERMS
index|]
decl_stmt|;
name|int
name|pcount
decl_stmt|;
comment|/* items in list */
name|FILE
modifier|*
name|acs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|fn
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* hold a filename */
name|sprintf
argument_list|(
name|fn
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|io
operator|->
name|basedir
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|ACCESS
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|acs
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"addmode: no access list"
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|pcount
operator|=
name|fread
argument_list|(
name|alist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perm_f
argument_list|)
argument_list|,
name|NPERMS
argument_list|,
name|acs
argument_list|)
operator|)
operator|==
literal|0
argument_list|,
literal|"addmode: empty access list"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|acs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmodes
condition|;
name|i
operator|++
control|)
comment|/* for each mode */
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pcount
condition|;
name|j
operator|++
control|)
comment|/* look for match */
if|if
condition|(
name|Newmodes
index|[
name|i
index|]
operator|.
name|ptype
operator|==
name|alist
index|[
name|j
index|]
operator|.
name|ptype
operator|&&
name|strcmp
argument_list|(
name|Newmodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|alist
index|[
name|j
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* match */
if|if
condition|(
name|j
operator|==
name|pcount
condition|)
comment|/* wasn't there */
block|{
if|if
condition|(
name|pcount
operator|==
name|NPERMS
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s: access list full\n"
argument_list|,
name|io
operator|->
name|nf
argument_list|)
expr_stmt|;
break|break;
block|}
name|alist
index|[
name|pcount
index|]
operator|.
name|ptype
operator|=
name|Newmodes
index|[
name|i
index|]
operator|.
name|ptype
expr_stmt|;
name|alist
index|[
name|pcount
index|]
operator|.
name|perms
operator|=
name|Newmodes
index|[
name|i
index|]
operator|.
name|perms
expr_stmt|;
name|strcpy
argument_list|(
name|alist
index|[
name|pcount
index|]
operator|.
name|name
argument_list|,
name|Newmodes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|pcount
operator|++
expr_stmt|;
block|}
else|else
comment|/* update existing one */
block|{
name|alist
index|[
name|j
index|]
operator|.
name|perms
operator|=
name|Newmodes
index|[
name|i
index|]
operator|.
name|perms
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s: replaced extant permission for %s\n"
argument_list|,
name|io
operator|->
name|nf
argument_list|,
name|Newmodes
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *	replace the access list  */
name|acssort
argument_list|(
name|alist
argument_list|,
name|pcount
argument_list|)
expr_stmt|;
name|x
argument_list|(
operator|(
name|acs
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
literal|"addmodes: can't write access list"
argument_list|)
expr_stmt|;
name|x
argument_list|(
name|fwrite
argument_list|(
name|alist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|perm_f
argument_list|)
argument_list|,
name|pcount
argument_list|,
name|acs
argument_list|)
operator|!=
name|pcount
argument_list|,
literal|"addmodes: writing access"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|acs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	parsemode  *  *	Parse the supplied (character string) access specification  *	into the specified perm_f structure.  *  *	Ray Essick  */
end_comment

begin_macro
name|parsemode
argument_list|(
argument|asciimode
argument_list|,
argument|pstuff
argument_list|,
argument|verbose
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|asciimode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|perm_f
modifier|*
name|pstuff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|name
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* hold the name */
name|char
name|namespec
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* entire name */
name|int
name|nametype
decl_stmt|;
comment|/* name class */
name|char
name|mode
index|[
name|WDLEN
index|]
decl_stmt|;
comment|/* and the mode */
name|char
name|imode
init|=
literal|0
decl_stmt|;
comment|/* internalized */
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|asciimode
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* find the mode */
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"No mode separator: %s\n"
argument_list|,
name|asciimode
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* split out mode */
name|strcpy
argument_list|(
name|mode
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* grab mode */
name|strcpy
argument_list|(
name|namespec
argument_list|,
name|asciimode
argument_list|)
expr_stmt|;
comment|/* and name */
operator|*
operator|--
name|p
operator|=
literal|'='
expr_stmt|;
comment|/* replace marker */
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|namespec
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* implicitly user? */
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|namespec
argument_list|)
expr_stmt|;
comment|/* user name */
name|nametype
operator|=
name|PERMUSER
expr_stmt|;
comment|/* default to user */
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* break specification */
name|strcpy
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* load name */
switch|switch
condition|(
name|namespec
index|[
literal|0
index|]
condition|)
comment|/* determine class */
block|{
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|nametype
operator|=
name|PERMUSER
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|nametype
operator|=
name|PERMGROUP
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|nametype
operator|=
name|PERMSYSTEM
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Invalid name class: %s\n"
argument_list|,
name|namespec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
block|}
comment|/*  *	Check that user/group are defined on our system. Don't  *	want to be filling our tables with bogus stuff.  */
switch|switch
condition|(
name|nametype
condition|)
block|{
case|case
name|PERMUSER
case|:
if|if
condition|(
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|==
name|NULL
condition|)
comment|/* does he exist? */
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s: no such user\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PERMGROUP
case|:
if|if
condition|(
name|getgrnam
argument_list|(
name|name
argument_list|)
operator|==
name|NULL
condition|)
comment|/* does it exist */
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s: no such group\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|PERMSYSTEM
case|:
default|default:
break|break;
block|}
comment|/*  *	Now internalize the mode  */
name|imode
operator|=
literal|0
expr_stmt|;
comment|/* initially null */
for|for
control|(
name|p
operator|=
name|mode
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
comment|/* each specifier */
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* director */
name|imode
operator|=
name|DRCTOK
operator|+
name|READOK
operator|+
name|WRITOK
operator|+
name|RESPOK
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* read */
name|imode
operator||=
name|READOK
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* write (and respond) */
name|imode
operator||=
name|WRITOK
operator|+
name|RESPOK
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* respond */
name|imode
operator||=
name|RESPOK
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* nullify */
name|imode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%c: Invalid permission mode\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|pstuff
operator|->
name|ptype
operator|=
name|nametype
expr_stmt|;
comment|/* load structure */
name|pstuff
operator|->
name|perms
operator|=
name|imode
expr_stmt|;
name|strcpy
argument_list|(
name|pstuff
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

