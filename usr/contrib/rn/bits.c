begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: bits.c,v 4.3 85/05/01 11:36:15 lwall Exp $  *  * $Log:	bits.c,v $  * Revision 4.3  85/05/01  11:36:15  lwall  * Baseline for release with 4.3bsd.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"rn.h"
end_include

begin_include
include|#
directive|include
file|"cheat.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DBM
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NULL
end_ifdef

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_endif
endif|#
directive|endif
endif|NULL
end_endif

begin_include
include|#
directive|include
file|<dbm.h>
end_include

begin_endif
endif|#
directive|endif
endif|DBM
end_endif

begin_decl_stmt
name|MEM_SIZE
name|ctlsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of bitmap in bytes */
end_comment

begin_function
name|void
name|bits_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DELAYMARK
name|dmname
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|RNDELNAME
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* checkpoint the .newsrc */
end_comment

begin_function
name|void
name|checkpoint_rc
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_CHECKPOINTING
condition|)
block|{
name|fputs
argument_list|(
literal|"(ckpt)"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|doing_ng
condition|)
name|restore_ng
argument_list|()
expr_stmt|;
comment|/* do not restore M articles */
if|if
condition|(
name|rc_changed
condition|)
name|write_rc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_CHECKPOINTING
condition|)
block|{
name|fputs
argument_list|(
literal|"(done)"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* reconstruct the .newsrc line in a human readable form */
end_comment

begin_function
name|void
name|restore_ng
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|mybuf
init|=
name|buf
decl_stmt|;
specifier|register
name|ART_NUM
name|i
decl_stmt|;
name|ART_NUM
name|count
init|=
literal|0
decl_stmt|;
name|int
name|safelen
init|=
name|LBUFLEN
operator|-
literal|16
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
comment|/* start with the newsgroup name */
name|s
operator|=
name|buf
operator|+
name|rcnums
index|[
name|ng
index|]
operator|-
literal|1
expr_stmt|;
comment|/* use s for buffer pointer */
operator|*
name|s
operator|++
operator|=
name|rcchar
index|[
name|ng
index|]
expr_stmt|;
comment|/* put the requisite : or !*/
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* put the not-so-requisite space */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each article in newsgroup */
if|if
condition|(
name|s
operator|-
name|mybuf
operator|>
name|safelen
condition|)
block|{
comment|/* running out of room? */
name|safelen
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|mybuf
operator|==
name|buf
condition|)
block|{
comment|/* currently static? */
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|mybuf
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|safelen
operator|+
literal|16
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mybuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* so we must copy it */
name|s
operator|=
name|mybuf
operator|+
operator|(
name|s
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* fix the pointer, too */
block|}
else|else
block|{
comment|/* just grow in place, if possible */
name|char
modifier|*
name|newbuf
decl_stmt|;
name|newbuf
operator|=
name|saferealloc
argument_list|(
name|mybuf
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|safelen
operator|+
literal|16
argument_list|)
expr_stmt|;
name|s
operator|=
name|newbuf
operator|+
operator|(
name|s
operator|-
name|mybuf
operator|)
expr_stmt|;
name|mybuf
operator|=
name|newbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
comment|/* still unread? */
name|count
operator|++
expr_stmt|;
comment|/* then count it */
else|else
block|{
comment|/* article was read */
name|ART_NUM
name|oldi
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* put out the min of the range */
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* keeping house */
name|oldi
operator|=
name|i
expr_stmt|;
comment|/* remember this spot */
do|do
name|i
operator|++
expr_stmt|;
do|while
condition|(
name|i
operator|<=
name|lastart
operator|&&
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
do|;
comment|/* find 1st unread article or end */
name|i
operator|--
expr_stmt|;
comment|/* backup to last read article */
if|if
condition|(
name|i
operator|>
name|oldi
condition|)
block|{
comment|/* range of more than 1? */
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"-%ld,"
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|)
expr_stmt|;
comment|/* then it out as a range */
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* and housekeep */
block|}
else|else
operator|*
name|s
operator|++
operator|=
literal|','
expr_stmt|;
comment|/* otherwise, just a comma will do */
block|}
block|}
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|','
condition|)
comment|/* is there a final ','? */
name|s
operator|--
expr_stmt|;
comment|/* take it back */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* and terminate string */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_NEWSRC_LINE
operator|&&
operator|!
name|panic
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
argument|rcline[ng]
argument_list|,
argument|rcline[ng]+rcnums[ng]
argument_list|)
name|FLUSH
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
argument|mybuf
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
comment|/* return old rc line */
if|if
condition|(
name|mybuf
operator|==
name|buf
condition|)
block|{
name|rcline
index|[
name|ng
index|]
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|s
operator|-
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* grab a new rc line */
name|strcpy
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* and load it */
block|}
else|else
block|{
name|mybuf
operator|=
name|saferealloc
argument_list|(
name|mybuf
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|s
operator|-
name|mybuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* be nice to the heap */
name|rcline
index|[
name|ng
index|]
operator|=
name|mybuf
expr_stmt|;
block|}
operator|*
operator|(
name|rcline
index|[
name|ng
index|]
operator|+
name|rcnums
index|[
name|ng
index|]
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rcchar
index|[
name|ng
index|]
operator|==
name|NEGCHAR
condition|)
block|{
comment|/* did they unsubscribe? */
name|printf
argument_list|(
argument|unsubto
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|toread
index|[
name|ng
index|]
operator|=
name|TR_UNSUB
expr_stmt|;
comment|/* make line invisible */
block|}
else|else
comment|/*NOSTRICT*/
name|toread
index|[
name|ng
index|]
operator|=
operator|(
name|ART_UNREAD
operator|)
name|count
expr_stmt|;
comment|/* remember how many unread there are */
block|}
end_function

begin_comment
comment|/* mark an article unread, keeping track of toread[] */
end_comment

begin_function
name|void
name|onemore
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&&
name|artnum
operator|<
name|firstart
condition|)
block|{
name|printf
argument_list|(
literal|"onemore: %d< %d\n"
argument_list|,
argument|artnum
argument_list|,
argument|firstart
argument_list|)
name|FLUSH
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|ctl_read
argument_list|(
name|artnum
argument_list|)
condition|)
block|{
name|ctl_clear
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
operator|++
name|toread
index|[
name|ng
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mark an article read, keeping track of toread[] */
end_comment

begin_function
name|void
name|oneless
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&&
name|artnum
operator|<
name|firstart
condition|)
block|{
name|printf
argument_list|(
literal|"oneless: %d< %d\n"
argument_list|,
argument|artnum
argument_list|,
argument|firstart
argument_list|)
name|FLUSH
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ctl_read
argument_list|(
name|artnum
argument_list|)
condition|)
block|{
name|ctl_set
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|>
name|TR_NONE
condition|)
operator|--
name|toread
index|[
name|ng
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* mark an article as unread, making sure that firstart is properly handled */
end_comment

begin_comment
comment|/* cross-references are left as read in the other newsgroups */
end_comment

begin_function
name|void
name|unmark_as_read
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
name|check_first
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
name|onemore
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MCHASE
if|if
condition|(
operator|!
name|parse_maybe
argument_list|(
name|artnum
argument_list|)
condition|)
name|chase_xrefs
argument_list|(
name|artnum
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DELAYMARK
end_ifdef

begin_comment
comment|/* temporarily mark article as read.  When newsgroup is exited, articles */
end_comment

begin_comment
comment|/* will be marked as unread.  Called via M command */
end_comment

begin_function
name|void
name|delay_unmark
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
if|if
condition|(
name|dmfp
operator|==
name|Nullfp
condition|)
block|{
name|dmfp
operator|=
name|fopen
argument_list|(
name|dmname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmfp
operator|==
name|Nullfp
condition|)
block|{
name|printf
argument_list|(
argument|cantcreate
argument_list|,
argument|dmname
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|oneless
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
comment|/* set the correct bit */
name|dmcount
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|dmfp
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* mark article as read.  If article is cross referenced to other */
end_comment

begin_comment
comment|/* newsgroups, mark them read there also. */
end_comment

begin_function
name|void
name|mark_as_read
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
name|oneless
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
comment|/* set the correct bit */
name|checkcount
operator|++
expr_stmt|;
comment|/* get more worried about crashes */
name|chase_xrefs
argument_list|(
name|artnum
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make sure we have bits set correctly down to firstart */
end_comment

begin_function
name|void
name|check_first
parameter_list|(
name|min
parameter_list|)
name|ART_NUM
name|min
decl_stmt|;
block|{
specifier|register
name|ART_NUM
name|i
init|=
name|firstart
decl_stmt|;
if|if
condition|(
name|min
operator|<
name|absfirst
condition|)
name|min
operator|=
name|absfirst
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|i
condition|)
block|{
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
name|min
condition|;
name|i
operator|--
control|)
name|ctl_set
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* mark as read */
name|firstart
operator|=
name|min
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* bring back articles marked with M */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DELAYMARK
end_ifdef

begin_function
name|void
name|yankback
parameter_list|()
block|{
specifier|register
name|ART_NUM
name|anum
decl_stmt|;
if|if
condition|(
name|dmfp
condition|)
block|{
comment|/* delayed unmarks pending? */
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"\nReturning %ld Marked article%s...\n"
argument_list|,
argument|(long)dmcount
argument_list|,
argument|dmcount ==
literal|1
argument|? nullstr :
literal|"s"
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|dmfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmfp
operator|=
name|fopen
argument_list|(
name|dmname
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|dmfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|anum
operator|=
operator|(
name|ART_NUM
operator|)
name|atol
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/*NOSTRICT*/
name|onemore
argument_list|(
name|anum
argument_list|)
expr_stmt|;
comment|/* then unmark them */
ifdef|#
directive|ifdef
name|MCHASE
name|chase_xrefs
argument_list|(
name|anum
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|fclose
argument_list|(
name|dmfp
argument_list|)
expr_stmt|;
name|dmfp
operator|=
name|Nullfp
expr_stmt|;
name|UNLINK
argument_list|(
name|dmname
argument_list|)
expr_stmt|;
comment|/* and be tidy */
block|}
else|else
block|{
name|printf
argument_list|(
argument|cantopen
argument_list|,
argument|dmname
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|dmcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* run down xref list and mark as read or unread */
end_comment

begin_function
name|int
name|chase_xrefs
parameter_list|(
name|artnum
parameter_list|,
name|markread
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
name|int
name|markread
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASYNC_PARSE
if|if
condition|(
name|parse_maybe
argument_list|(
name|artnum
argument_list|)
condition|)
comment|/* make sure we have right header */
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBM
block|{
name|datum
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|datum
name|fetch
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|idp
decl_stmt|;
name|char
modifier|*
name|ident_buf
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|hist_file
init|=
name|Nullfp
decl_stmt|;
else|#
directive|else
if|if
condition|(
ifdef|#
directive|ifdef
name|DEBUGGING
name|debug
operator|&
name|DEB_FEED_XREF
operator|||
endif|#
directive|endif
name|htype
index|[
name|XREF_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
block|{
comment|/* are there article# xrefs? */
endif|#
directive|endif
endif|DBM
name|char
modifier|*
name|xref_buf
decl_stmt|,
modifier|*
name|curxref
decl_stmt|;
specifier|register
name|char
modifier|*
name|xartnum
decl_stmt|;
name|char
modifier|*
name|rver_buf
init|=
name|Nullch
decl_stmt|;
specifier|static
name|char
modifier|*
name|inews_site
init|=
name|Nullch
decl_stmt|;
specifier|register
name|ART_NUM
name|x
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|rver_buf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|NGS_LINE
argument_list|)
expr_stmt|;
comment|/* get Newsgroups */
if|if
condition|(
operator|!
name|index
argument_list|(
name|rver_buf
argument_list|,
literal|','
argument_list|)
condition|)
comment|/* if no comma, no Xref! */
return|return
literal|0
return|;
if|if
condition|(
name|hist_file
operator|==
name|Nullfp
condition|)
block|{
comment|/* Init. file accesses */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chase_xref: opening files\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbminit
argument_list|(
name|filexp
argument_list|(
name|ARTFILE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hist_file
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|ARTFILE
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|Nullfp
condition|)
return|return
literal|0
return|;
block|}
name|xref_buf
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|BUFSIZ
argument_list|)
expr_stmt|;
name|ident_buf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|MESSID_LINE
argument_list|)
expr_stmt|;
comment|/* get Message-ID */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chase_xref: Message-ID: %s\n"
argument_list|,
name|ident_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idp
operator|=
name|ident_buf
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|idp
condition|)
comment|/* make message-id case insensitive */
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|idp
argument_list|)
condition|)
operator|*
name|idp
operator|=
name|tolower
argument_list|(
operator|*
name|idp
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|dptr
operator|=
name|ident_buf
expr_stmt|;
comment|/* look up article by id */
name|lhs
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|lhs
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rhs
operator|=
name|fetch
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* fetch the record */
if|if
condition|(
name|rhs
operator|.
name|dptr
operator|==
name|NULL
condition|)
comment|/* if null, nothing there */
goto|goto
name|wild_goose
goto|;
name|fseek
argument_list|(
name|hist_file
argument_list|,
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|rhs
operator|.
name|dptr
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* datum returned is position in hist file */
name|fgets
argument_list|(
name|xref_buf
argument_list|,
name|BUFSIZ
argument_list|,
name|hist_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Xref from history: %s\n"
argument_list|,
name|xref_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|xref_buf
argument_list|,
literal|'\t'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|curxref
argument_list|,
literal|'\t'
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"chase_xref: curxref: %s\n"
argument_list|,
name|curxref
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
else|!DBM
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|htype
index|[
name|XREF_LINE
index|]
operator|.
name|ht_minpos
operator|>=
literal|0
condition|)
endif|#
directive|endif
name|xref_buf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|XREF_LINE
argument_list|)
expr_stmt|;
comment|/* get xrefs list */
ifdef|#
directive|ifdef
name|DEBUGGING
else|else
block|{
name|xref_buf
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
literal|100
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Give Xref: "
argument_list|)
name|FLUSH
expr_stmt|;
name|gets
argument_list|(
name|xref_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_XREF_MARKER
condition|)
name|printf
argument_list|(
literal|"Xref: %s\n"
argument_list|,
argument|xref_buf
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|xref_buf
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Make sure site name on Xref matches what inews thinks site is. 	 * Check first against last inews_site.  If it matches, fine. 	 * If not, fetch inews_site from current Relay-Version line and 	 * check again.  This is so that if the new administrator decides 	 * to change the system name as known to inews, rn will still do 	 * Xrefs correctly--each article need only match itself to be valid. 	 */
if|if
condition|(
name|inews_site
operator|==
name|Nullch
operator|||
name|strNE
argument_list|(
name|tmpbuf
argument_list|,
name|inews_site
argument_list|)
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|inews_site
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|inews_site
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NORELAY
name|rver_buf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|RVER_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|instr
argument_list|(
name|rver_buf
argument_list|,
literal|"; site "
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
else|#
directive|else
else|NORELAY
comment|/* In version 2.10.3 of news or afterwards, the Relay-Version 	     * and Posting-Version header lines have been removed.  For 	     * the code below to work as intended, I have modified it to 	     * extract the first component of the Path header line.  This 	     * should give the same effect as did the old code with respect 	     * to the use of the Relay-Version site name. 	     */
name|rver_buf
operator|=
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|PATH_LINE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|instr
argument_list|(
name|rver_buf
argument_list|,
literal|"!"
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
endif|#
directive|endif
endif|NORELAY
name|inews_site
operator|=
name|savestr
argument_list|(
name|nullstr
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|new_site
index|[
literal|128
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|NORELAY
name|cpytill
argument_list|(
name|new_site
argument_list|,
name|t
operator|+
literal|7
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
else|#
directive|else
else|NORELAY
name|cpytill
argument_list|(
name|new_site
argument_list|,
name|rver_buf
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NORELAY
name|inews_site
operator|=
name|savestr
argument_list|(
name|new_site
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strNE
argument_list|(
name|tmpbuf
argument_list|,
name|inews_site
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Xref not from %s--ignoring\n"
argument_list|,
argument|inews_site
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
goto|goto
name|wild_goose
goto|;
block|}
block|}
endif|#
directive|endif
endif|DBM
while|while
condition|(
operator|*
name|curxref
condition|)
block|{
comment|/* for each newsgroup */
name|curxref
operator|=
name|cpytill
argument_list|(
name|tmpbuf
argument_list|,
name|curxref
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|xartnum
operator|=
name|index
argument_list|(
name|tmpbuf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|#
directive|else
name|xartnum
operator|=
name|index
argument_list|(
name|tmpbuf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DBM
if|if
condition|(
operator|!
name|xartnum
condition|)
comment|/* probably an old-style Xref */
break|break;
operator|*
name|xartnum
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|tmpbuf
argument_list|,
name|ngname
argument_list|)
condition|)
block|{
comment|/* not the current newsgroup? */
name|x
operator|=
name|atol
argument_list|(
name|xartnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
if|if
condition|(
name|markread
condition|)
block|{
if|if
condition|(
name|addartnum
argument_list|(
name|x
argument_list|,
name|tmpbuf
argument_list|)
condition|)
goto|goto
name|wild_goose
goto|;
block|}
ifdef|#
directive|ifdef
name|MCHASE
else|else
name|subartnum
argument_list|(
name|x
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
while|while
condition|(
operator|*
name|curxref
operator|&&
name|isspace
argument_list|(
operator|*
name|curxref
argument_list|)
condition|)
name|curxref
operator|++
expr_stmt|;
block|}
name|wild_goose
label|:
name|free
argument_list|(
name|xref_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
name|free
argument_list|(
name|ident_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DBM
if|if
condition|(
name|rver_buf
operator|!=
name|Nullch
condition|)
name|free
argument_list|(
name|rver_buf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|int
name|initctl
parameter_list|()
block|{
name|char
modifier|*
name|mybuf
init|=
name|buf
decl_stmt|;
comment|/* place to decode rc line */
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|h
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|ART_NUM
name|unread
decl_stmt|;
ifdef|#
directive|ifdef
name|DELAYMARK
name|dmcount
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|lastart
operator|=
name|getngsize
argument_list|(
name|ng
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* this cannot happen (laugh here) */
return|return
operator|-
literal|1
return|;
name|absfirst
operator|=
name|getabsfirst
argument_list|(
name|ng
argument_list|,
name|lastart
argument_list|)
expr_stmt|;
comment|/* remember first existing article */
if|if
condition|(
operator|!
name|absfirst
condition|)
comment|/* no articles at all? */
name|absfirst
operator|=
literal|1
expr_stmt|;
comment|/* pretend there is one */
ifndef|#
directive|ifndef
name|lint
name|ctlsize
operator|=
call|(
name|MEM_SIZE
call|)
argument_list|(
name|OFFSET
argument_list|(
name|lastart
argument_list|)
operator|/
name|BITSPERBYTE
operator|+
literal|20
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
name|ctlarea
operator|=
name|safemalloc
argument_list|(
name|ctlsize
argument_list|)
expr_stmt|;
comment|/* allocate control area */
comment|/* now modify ctlarea to reflect what has already been read */
for|for
control|(
name|s
operator|=
name|rcline
index|[
name|ng
index|]
operator|+
name|rcnums
index|[
name|ng
index|]
init|;
operator|*
name|s
operator|==
literal|' '
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* find numbers in rc line */
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|i
operator|>=
name|LBUFLEN
operator|-
literal|2
condition|)
comment|/* bigger than buf? */
name|mybuf
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|i
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
name|strcpy
argument_list|(
name|mybuf
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* make scratch copy of line */
name|mybuf
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
comment|/* put extra comma on the end */
name|mybuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|mybuf
expr_stmt|;
comment|/* initialize the for loop below */
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"1-"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* can we save some time here? */
name|firstart
operator|=
name|atol
argument_list|(
name|s
operator|+
literal|2
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* ignore first range thusly */
name|s
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|firstart
operator|=
literal|1
expr_stmt|;
comment|/* all the bits are valid for now */
if|if
condition|(
name|absfirst
operator|>
name|firstart
condition|)
block|{
comment|/* do we know already? */
name|firstart
operator|=
name|absfirst
expr_stmt|;
comment|/* no point calling getngmin again */
block|}
elseif|else
if|if
condition|(
name|artopen
argument_list|(
name|firstart
argument_list|)
operator|==
name|Nullfp
condition|)
block|{
comment|/* first unread article missing? */
name|i
operator|=
name|getngmin
argument_list|(
literal|"."
argument_list|,
name|firstart
argument_list|)
expr_stmt|;
comment|/* see if expire has been busy */
if|if
condition|(
name|i
condition|)
block|{
comment|/* avoid a bunch of extra opens */
name|firstart
operator|=
name|i
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PENDING
ifdef|#
directive|ifdef
name|CACHESUBJ
name|subj_to_get
operator|=
name|firstart
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|unread
operator|=
name|lastart
operator|-
name|firstart
operator|+
literal|1
expr_stmt|;
comment|/* assume this range unread */
for|for
control|(
name|i
operator|=
name|OFFSET
argument_list|(
name|firstart
argument_list|)
operator|/
name|BITSPERBYTE
init|;
name|i
operator|<
name|ctlsize
condition|;
name|i
operator|++
control|)
name|ctlarea
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* assume unread */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_CTLAREA_BITMAP
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|mybuf
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%ld "
argument_list|,
argument|(long)i
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
operator|(
name|c
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|Nullch
condition|;
name|s
operator|=
operator|++
name|c
control|)
block|{
comment|/* for each range */
name|ART_NUM
name|min
decl_stmt|,
name|max
decl_stmt|;
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* do not let index see past comma */
if|if
condition|(
operator|(
name|h
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
comment|/* is there a -? */
name|min
operator|=
name|atol
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|max
operator|=
name|atol
argument_list|(
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|<
name|firstart
condition|)
comment|/* make sure range is in range */
name|min
operator|=
name|firstart
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|lastart
condition|)
name|max
operator|=
name|lastart
expr_stmt|;
if|if
condition|(
name|min
operator|<=
name|max
condition|)
comment|/* non-null range? */
name|unread
operator|-=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
comment|/* adjust unread count */
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
comment|/* for all articles in range */
name|ctl_set
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* mark them read */
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|atol
argument_list|(
name|s
argument_list|)
operator|)
operator|>=
name|firstart
operator|&&
name|i
operator|<=
name|lastart
condition|)
block|{
comment|/* is single number reasonable? */
name|ctl_set
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* mark it read */
name|unread
operator|--
expr_stmt|;
comment|/* decrement articles to read */
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_CTLAREA_BITMAP
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|s
argument_list|)
name|FLUSH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|was_read
argument_list|(
name|i
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%ld "
argument_list|,
argument|(long)i
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
name|DEB_CTLAREA_BITMAP
condition|)
block|{
name|fputs
argument_list|(
literal|"\n(hit CR)"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|gets
argument_list|(
name|cmd_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mybuf
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
name|toread
index|[
name|ng
index|]
operator|=
name|unread
expr_stmt|;
return|return
literal|0
return|;
block|}
name|void
name|grow_ctl
parameter_list|()
block|{
name|ART_NUM
name|newlast
decl_stmt|;
name|ART_NUM
name|tmpfirst
decl_stmt|;
name|MEM_SIZE
name|newsize
decl_stmt|;
specifier|register
name|ART_NUM
name|i
decl_stmt|;
name|forcegrow
operator|=
name|FALSE
expr_stmt|;
name|newlast
operator|=
name|getngsize
argument_list|(
name|ng
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlast
operator|>
name|lastart
condition|)
block|{
name|ART_NUM
name|tmpart
init|=
name|art
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|newsize
operator|=
call|(
name|MEM_SIZE
call|)
argument_list|(
name|OFFSET
argument_list|(
name|newlast
argument_list|)
operator|/
name|BITSPERBYTE
operator|+
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|newsize
operator|=
name|Null
argument_list|(
name|MEM_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
if|if
condition|(
name|newsize
operator|>
name|ctlsize
condition|)
block|{
name|newsize
operator|+=
literal|20
expr_stmt|;
name|ctlarea
operator|=
name|saferealloc
argument_list|(
name|ctlarea
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|ctlsize
operator|=
name|newsize
expr_stmt|;
block|}
name|toread
index|[
name|ng
index|]
operator|+=
call|(
name|ART_UNREAD
call|)
argument_list|(
name|newlast
operator|-
name|lastart
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lastart
operator|+
literal|1
init|;
name|i
operator|<=
name|newlast
condition|;
name|i
operator|++
control|)
name|ctl_clear
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* these articles are unread */
ifdef|#
directive|ifdef
name|CACHESUBJ
if|if
condition|(
name|subj_list
operator|!=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
name|subj_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|saferealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subj_list
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
operator|(
name|OFFSET
argument_list|(
name|newlast
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|lint
for|for
control|(
name|i
operator|=
name|lastart
operator|+
literal|1
init|;
name|i
operator|<=
name|newlast
condition|;
name|i
operator|++
control|)
name|subj_list
index|[
name|OFFSET
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|Nullch
expr_stmt|;
block|}
endif|#
directive|endif
name|tmpfirst
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|lastart
operator|=
name|newlast
expr_stmt|;
ifdef|#
directive|ifdef
name|KILLFILES
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld more article%s arrived--looking for more to kill...\n\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lastart
operator|-
name|firstart
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
name|lastart
operator|>
name|firstart
condition|?
literal|"s have"
else|:
literal|" has"
operator|)
argument_list|)
expr_stmt|;
name|ELSE
comment|/* my, my, how clever we are */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"More news--killing...\n\n"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|kill_unwanted
argument_list|(
name|tmpfirst
argument_list|,
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|art
operator|=
name|tmpart
expr_stmt|;
block|}
block|}
end_function

end_unit

