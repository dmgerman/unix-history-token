begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1983 Regents of the University of California */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)help.c	1.2	(Berkeley)	8/14/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * help - an easy way to find and use information  *  * Usage:  see definition of error()  *  * Files:  /usr/lib/help		root help subsystem  *	   /usr/lib/help/log		log of system activity  *	   /usr/lib/help/maint		help maintenance scripts  *	   /usr/lib/help/config		defines the help system network  *	   /usr/lib/help/src		nroff sources for /usr/lib/help/cat  *	   /usr/lib/help/cat		root of system help topic files  *	   "/index_{help,man,doc}	topics created by mkhelpindex  *	   "/general			description of 'help'  *	   "/*				all other files are 'help' text files  *  * Author:  John Kunze, UCB (sorting routines based on David Wasley's originals)  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* #include<whoami.h> */
end_comment

begin_comment
comment|/* this would have defined BSD4_2 */
end_comment

begin_define
define|#
directive|define
name|BSD4_2
value|1
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* user-instruction return codes */
end_comment

begin_define
define|#
directive|define
name|LIST_I
value|1
end_define

begin_define
define|#
directive|define
name|PASS_I
value|2
end_define

begin_define
define|#
directive|define
name|SAVE_I
value|3
end_define

begin_define
define|#
directive|define
name|TYPE_I
value|4
end_define

begin_define
define|#
directive|define
name|JUNK_I
value|5
end_define

begin_define
define|#
directive|define
name|BACK_I
value|6
end_define

begin_define
define|#
directive|define
name|LPRT_I
value|7
end_define

begin_define
define|#
directive|define
name|HELP_I
value|8
end_define

begin_define
define|#
directive|define
name|ROOT_I
value|9
end_define

begin_define
define|#
directive|define
name|YELL_I
value|10
end_define

begin_define
define|#
directive|define
name|QUIT_I
value|11
end_define

begin_define
define|#
directive|define
name|FIND_I
value|12
end_define

begin_define
define|#
directive|define
name|FLAG_I
value|13
end_define

begin_define
define|#
directive|define
name|NOOP_I
value|14
end_define

begin_define
define|#
directive|define
name|GOT_ONE
value|15
end_define

begin_comment
comment|/* symbols and macros */
end_comment

begin_define
define|#
directive|define
name|HDBSIZE
value|256
end_define

begin_define
define|#
directive|define
name|HVSIZE
value|10
end_define

begin_define
define|#
directive|define
name|HELPROOT
value|"/usr/lib/help/cat"
end_define

begin_define
define|#
directive|define
name|TOPICINDEX
value|"index_help"
end_define

begin_define
define|#
directive|define
name|HELPMAINT
value|"../maint/do."
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_define
define|#
directive|define
name|MANINDEX
value|"/usr/lib/whatis"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MANINDEX
value|{ "/usr/lib/whatis", "/usr/man/whatis", NULL }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOCINDEX
value|"/usr/lib/help/cat/index_doc"
end_define

begin_define
define|#
directive|define
name|HELPSAVE
value|"helpsave"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_define
define|#
directive|define
name|MAINTAINER
value|"help@ucbopal"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAINTAINER
value|"help"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HELPLOG
value|"/usr/lib/help/log"
end_define

begin_define
define|#
directive|define
name|DEFSHELL
value|"/bin/csh"
end_define

begin_define
define|#
directive|define
name|PERROR
value|{ perror("help"); exit(1); }
end_define

begin_define
define|#
directive|define
name|PUTNL
value|{ putchar('\n'); fflush(stdout); }
end_define

begin_define
define|#
directive|define
name|EXISTS
parameter_list|(
name|s
parameter_list|)
value|(access(s, 0) == 0)
end_define

begin_define
define|#
directive|define
name|EXECABLE
parameter_list|(
name|s
parameter_list|)
value|(access(s, 1) == 0)
end_define

begin_define
define|#
directive|define
name|WRITABLE
parameter_list|(
name|s
parameter_list|)
value|(access(s, 2) == 0)
end_define

begin_define
define|#
directive|define
name|READABLE
parameter_list|(
name|s
parameter_list|)
value|(access(s, 4) == 0)
end_define

begin_define
define|#
directive|define
name|DOT
parameter_list|(
name|s
parameter_list|)
value|((s)[0]=='.'&&(s)[1]==0 ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|DOTDOT
parameter_list|(
name|s
parameter_list|)
value|((s)[0]=='.'&&(s)[1]=='.'&&(s)[2]==0 ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|ROOT
parameter_list|(
name|s
parameter_list|)
value|((s)[0]=='/'&&(s)[1]==0 ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|isspecial
parameter_list|(
name|a
parameter_list|)
value|(a == '\0' || a == '+' || a == '>' || a == '|')
end_define

begin_define
define|#
directive|define
name|lcase
parameter_list|(
name|a
parameter_list|)
value|(isupper(a) ? tolower(a) : a)
end_define

begin_comment
comment|/* signal handling interface */
end_comment

begin_if
if|#
directive|if
name|BSD4_2
end_if

begin_decl_stmt
name|struct
name|sigvec
name|vec
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GET_SIGPIPE
value|{ vec.sv_handler = onintr; sigvec(SIGPIPE,&vec, 0); }
end_define

begin_define
define|#
directive|define
name|SET_SIGPIPE
value|{ vec.sv_handler = SIG_DFL; sigvec(SIGPIPE,&vec, 0); }
end_define

begin_define
define|#
directive|define
name|NO_RUPTS
value|{ vec.sv_handler = SIG_IGN; sigvec(SIGINT,&vec, 0); }
end_define

begin_define
define|#
directive|define
name|OK_RUPTS
value|{ vec.sv_handler = SIG_DFL; sigvec(SIGINT,&vec, 0); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GET_SIGPIPE
value|signal(SIGPIPE, onintr)
end_define

begin_define
define|#
directive|define
name|SET_SIGPIPE
value|signal(SIGPIPE, SIG_DFL)
end_define

begin_define
define|#
directive|define
name|NO_RUPTS
value|signal(SIGINT, SIG_IGN)
end_define

begin_define
define|#
directive|define
name|OK_RUPTS
value|signal(SIGINT, SIG_DFL)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAXNAMLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXNAMLEN
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* miscellaneous globals */
end_comment

begin_decl_stmt
name|char
name|hdbuf
index|[
name|HDBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of top level directores */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hvec
index|[
name|HVSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to top level directories */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to topic arguments */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dirlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unparsed list of root directories */
end_comment

begin_decl_stmt
name|char
name|cwd
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current directory */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dot
decl_stmt|,
modifier|*
name|dotdot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tail parts of current and parent dirs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|subdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current subdirectory names */
end_comment

begin_decl_stmt
name|short
name|dirlevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* depth from root of current directory */
end_comment

begin_decl_stmt
name|short
name|keeppag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for the>& command to keep pagination */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shell
decl_stmt|,
name|shellprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell and its prompt */
end_comment

begin_decl_stmt
name|char
name|helpprompt
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help prompt string */
end_comment

begin_decl_stmt
name|char
name|indexprompt
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help-index prompt string */
end_comment

begin_comment
comment|/*  * Topic names at the top (zero-th) directory level are stored permanently  * as null terminated strings in the first segment of topicbuf, each of which  * is pointed to by a pointer in the first segment of tptrs.  When a subtopic  * at any directory level is under inspection, the second segment of topicbuf,  * beginning with topicbuf[rtlen], contains the subtopic names, and the second  * segment of tptrs, beginning with tptrs[subt], contains pointers to them.  * At all times, tptrs[nt] contains zero to mark the end of the active segment.  */
end_comment

begin_decl_stmt
name|char
name|topicbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* null-terminated topic names */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tptrs
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to topic names */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|topics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to topics or subtopics */
end_comment

begin_decl_stmt
name|int
name|nt
init|=
literal|0
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number and total length of topics */
end_comment

begin_decl_stmt
name|int
name|subt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subtopic index in tptrs */
end_comment

begin_decl_stmt
name|int
name|rtlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of root topics names */
end_comment

begin_decl_stmt
name|int
name|nhits
init|=
literal|0
decl_stmt|,
name|hit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number and index of matched topics */
end_comment

begin_comment
comment|/*  * Index references are stored in indexbuf, those for "help" preceding those  * for "man", which start at iptrs[mansegment] and precede those for off-line  * references starting at iptrs[docsegment].  Each iptrs[i] points to a pair  * of null-terminated strings containing the first and second halves of a line.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|indexbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of index references */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|iptrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to index references */
end_comment

begin_decl_stmt
name|int
name|ni
init|=
literal|0
decl_stmt|,
name|ilen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number and length of index refs */
end_comment

begin_decl_stmt
name|int
name|inhits
init|=
literal|0
decl_stmt|,
name|ihit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number and index of matched index refs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|isrc
decl_stmt|,
modifier|*
name|idst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* partial match of index entry */
end_comment

begin_decl_stmt
name|int
name|mansegment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beginning of UPM refs segment */
end_comment

begin_decl_stmt
name|int
name|docsegment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beginning of off-line refs segment */
end_comment

begin_decl_stmt
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw user instruction */
end_comment

begin_decl_stmt
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|dstarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source and dst parts of an instruction */
end_comment

begin_decl_stmt
name|char
name|fname
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* full path name(s) of topic file */
end_comment

begin_decl_stmt
name|short
name|fnamect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files in fname */
end_comment

begin_decl_stmt
name|short
name|interactive
decl_stmt|,
name|iflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interactive session flag */
end_comment

begin_decl_stmt
name|short
name|number
decl_stmt|,
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* numbers accepted/printed, terse prompt */
end_comment

begin_decl_stmt
name|char
modifier|*
name|more_d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to value of MORE env. variable */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name (argv[0]) of invoking program */
end_comment

begin_decl_stmt
name|char
modifier|*
name|maintkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* help maintenance key */
end_comment

begin_comment
comment|/* miscellaneous routines */
end_comment

begin_decl_stmt
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE
modifier|*
name|outpipe
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|ins
decl_stmt|;
comment|/* current user instruction */
specifier|register
name|int
name|junkcount
init|=
literal|0
decl_stmt|;
comment|/* how many times in a row bad ins. */
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
comment|/* speed up standard output */
name|setbuf
argument_list|(
name|stderr
argument_list|,
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
comment|/* speed up error output */
name|getoptions
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* parse options */
name|setgetenv
argument_list|()
expr_stmt|;
comment|/* make directory list, environment */
comment|/* 	 * main loop:  get instruction, execute 	 */
for|for
control|(
name|ins
operator|=
name|startup
argument_list|()
init|;
name|ins
operator|!=
name|QUIT_I
condition|;
name|ins
operator|=
name|nextins
argument_list|()
control|)
block|{
if|if
condition|(
name|ins
operator|!=
name|JUNK_I
condition|)
name|junkcount
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ins
condition|)
block|{
case|case
name|LIST_I
case|:
name|list
argument_list|()
expr_stmt|;
break|break;
case|case
name|TYPE_I
case|:
if|if
condition|(
name|isadir
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|chwd
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|list
argument_list|()
expr_stmt|;
block|}
else|else
name|page
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACK_I
case|:
name|chwd
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|list
argument_list|()
expr_stmt|;
break|break;
case|case
name|ROOT_I
case|:
name|chwd
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|list
argument_list|()
expr_stmt|;
break|break;
case|case
name|SAVE_I
case|:
name|save
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPRT_I
case|:
name|lprt
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
break|break;
case|case
name|PASS_I
case|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pass
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLAG_I
case|:
name|flag
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUNK_I
case|:
name|printf
argument_list|(
literal|"\nI%sdon't understand.\n"
argument_list|,
operator|(
name|junkcount
operator|++
condition|?
literal|" still "
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|junkcount
operator|==
literal|2
condition|)
name|list
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|junkcount
operator|>
literal|2
condition|)
name|comlist
argument_list|()
expr_stmt|;
break|break;
case|case
name|HELP_I
case|:
name|comlist
argument_list|()
expr_stmt|;
break|break;
case|case
name|YELL_I
case|:
name|yell
argument_list|()
expr_stmt|;
break|break;
case|case
name|FIND_I
case|:
name|find
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOOP_I
case|:
break|break;
default|default:
name|puts
argument_list|(
literal|"Unknown instruction - please report this."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|puts
argument_list|(
literal|"Bye."
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|save
argument_list|()
end_macro

begin_comment
comment|/* save a help file "src" in user file "dst" */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|destfile
decl_stmt|;
specifier|register
name|int
name|lcount
decl_stmt|;
name|char
name|c
decl_stmt|;
name|p
operator|=
operator|(
name|EXISTS
argument_list|(
name|dst
argument_list|)
condition|?
literal|"appended"
else|:
literal|"new file"
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|destfile
operator|=
name|fopen
argument_list|(
name|dst
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|lcount
operator|=
name|putfiles
argument_list|(
name|NULL
argument_list|,
name|destfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|destfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nTopic \"%s\" is saved in \"%s\" (%s:  %d lines).\n"
argument_list|,
name|topics
index|[
name|hit
index|]
argument_list|,
name|dst
argument_list|,
name|p
argument_list|,
name|lcount
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lprt
argument_list|()
end_macro

begin_comment
comment|/* lineprint (dst) all args in fname */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|fn
decl_stmt|;
name|char
modifier|*
name|ap
index|[
name|HVSIZE
index|]
decl_stmt|;
comment|/* arg pointers */
name|ap
index|[
name|i
operator|++
index|]
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dst
argument_list|,
literal|"ipr"
argument_list|)
operator|==
literal|0
condition|)
comment|/* kludge to force -p with ipr */
name|ap
index|[
name|i
operator|++
index|]
operator|=
literal|"-p"
expr_stmt|;
if|if
condition|(
name|dstarg
condition|)
comment|/* kludge to allow an option to lpr */
name|ap
index|[
name|i
operator|++
index|]
operator|=
name|dstarg
expr_stmt|;
name|fn
operator|=
name|fname
expr_stmt|;
while|while
condition|(
name|fnamect
operator|--
condition|)
block|{
name|ap
index|[
name|i
operator|++
index|]
operator|=
name|fn
expr_stmt|;
name|fn
operator|+=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|fputs
argument_list|(
literal|"\n>> Executing ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ap
index|[
name|i
index|]
condition|;
name|fputs
argument_list|(
name|ap
index|[
name|i
operator|++
index|]
argument_list|,
name|stdout
argument_list|)
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|" ] ..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|dst
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|PERROR
expr_stmt|;
block|}
name|NO_RUPTS
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|">> Done."
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
block|}
end_block

begin_macro
name|yell
argument_list|()
end_macro

begin_comment
comment|/* send complaints or other input to the MAINTAINER of help */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"\n%s\n%s\n%s\n"
argument_list|,
literal|"Please enter your remarks.  The only way I will know you're done is if"
argument_list|,
literal|"you enter a . (period) or control-d on a line by itself.  Don't forget!"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"mail"
argument_list|,
literal|"mail"
argument_list|,
name|MAINTAINER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PERROR
expr_stmt|;
block|}
name|NO_RUPTS
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\nDuly noted."
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
block|}
end_block

begin_macro
name|log
argument_list|(
argument|insc
argument_list|)
end_macro

begin_comment
comment|/* to turn logging off, deny write access of HELPLOG */
end_comment

begin_decl_stmt
name|char
name|insc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* instruction code character to be written */
end_comment

begin_block
block|{
name|long
name|logtime
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|fopen
argument_list|(
name|HELPLOG
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|time
argument_list|(
operator|&
name|logtime
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|lp
argument_list|,
literal|"%.12s  %c %s\n"
argument_list|,
name|ctime
argument_list|(
operator|&
name|logtime
argument_list|)
operator|+
literal|4
argument_list|,
name|insc
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getoptions
argument_list|(
argument|ac
argument_list|,
argument|av
argument_list|)
end_macro

begin_comment
comment|/* get command-line options */
end_comment

begin_decl_stmt
name|int
name|ac
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spaces need not separate -[dpm] from next arg */
end_comment

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|interactive
operator|=
name|isatty
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|progname
operator|=
operator|*
name|av
expr_stmt|;
for|for
control|(
name|p
operator|=
name|progname
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
name|p
operator|--
init|;
name|p
operator|>=
name|progname
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|;
name|p
operator|--
control|)
empty_stmt|;
name|progname
operator|=
operator|++
name|p
expr_stmt|;
comment|/* set progname to its tail part */
while|while
condition|(
operator|*
operator|*
operator|++
name|av
operator|==
literal|'-'
condition|)
switch|switch
condition|(
operator|*
operator|(
name|p
operator|=
operator|*
name|av
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|||
operator|*
operator|++
name|av
condition|)
name|dirlist
operator|=
operator|(
operator|*
name|p
condition|?
name|p
else|:
operator|*
name|av
operator|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Directory list must follow -d."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|||
operator|*
operator|++
name|av
condition|)
name|progname
operator|=
operator|(
operator|*
name|p
condition|?
name|p
else|:
operator|*
name|av
operator|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Prompt string must follow -p."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
operator|*
operator|++
name|p
operator|||
operator|*
operator|++
name|av
condition|)
name|maintkey
operator|=
operator|(
operator|*
name|p
condition|?
name|p
else|:
operator|*
name|av
operator|)
expr_stmt|;
else|else
block|{
name|maintkey
operator|=
literal|"default"
expr_stmt|;
name|av
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|iflag
operator|=
name|interactive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|number
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown option -%c.\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|argp
operator|=
name|av
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|msg
argument_list|)
end_macro

begin_comment
comment|/* print a message for command-line errors */
end_comment

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|msg
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:  help [ options ] [ topic [ subtopic [ subsubtopic [...] ] ] ]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Options are:\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n"
argument_list|,
literal|"-d dirlist	override the default pool of help files"
argument_list|,
literal|"-m key		do the help maintenance function given by key"
argument_list|,
literal|"-p prompt	override the default prompt"
argument_list|,
literal|"-i		force help to be interactive"
argument_list|,
literal|"-n		use numbers in topic and index listings"
argument_list|,
literal|"-q		suppress the instruction line before prompting"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"To get started just type \"help\".\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|helpmaint
argument_list|(
argument|key
argument_list|,
argument|dir
argument_list|,
argument|av
argument_list|)
end_macro

begin_comment
comment|/* invoke maintenance script */
end_comment

begin_decl_stmt
name|char
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* key specifying action */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first writable dir in HELPPOOL */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* topics, if any */
end_comment

begin_block
block|{
name|char
name|s
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vp
init|=
name|argv
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|dir
argument_list|,
name|HELPMAINT
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|READABLE
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"I don't know how to do \"%s\".\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|dir
argument_list|,
name|HELPMAINT
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
block|}
operator|*
name|vp
operator|++
operator|=
literal|"csh"
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
literal|"-f"
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|s
expr_stmt|;
operator|*
name|vp
operator|++
operator|=
name|dir
expr_stmt|;
while|while
condition|(
operator|*
name|av
condition|)
operator|*
name|vp
operator|++
operator|=
operator|*
name|av
operator|++
expr_stmt|;
operator|*
name|vp
operator|=
literal|0
expr_stmt|;
name|execv
argument_list|(
literal|"/bin/csh"
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|PERROR
expr_stmt|;
block|}
end_block

begin_macro
name|setgetenv
argument_list|()
end_macro

begin_comment
comment|/* get directory list and shell, and set more -d for man */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|dirlist
decl_stmt|,
modifier|*
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|myenv
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|moredef
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
for|for
control|(
name|vp
operator|=
name|environ
init|;
operator|*
name|vp
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|vp
argument_list|,
literal|"HELPPOOL="
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|p
condition|)
name|p
operator|=
operator|*
name|vp
operator|+
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|vp
argument_list|,
literal|"SHELL="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|shell
operator|=
operator|*
name|vp
operator|+
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|vp
argument_list|,
literal|"MORE="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|moredef
operator|++
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|t
operator|=
operator|&
name|hdbuf
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|hvec
index|[
name|i
operator|++
index|]
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|':'
operator|||
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|dirlist
condition|)
name|hvec
index|[
name|i
operator|++
index|]
operator|=
name|HELPROOT
expr_stmt|;
name|hvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|shell
condition|)
name|shell
operator|=
name|DEFSHELL
expr_stmt|;
name|shellprompt
operator|=
operator|(
name|strcmp
argument_list|(
name|shell
argument_list|,
name|DEFSHELL
argument_list|)
operator|==
literal|0
condition|?
literal|'%'
else|:
literal|'$'
operator|)
expr_stmt|;
if|if
condition|(
name|number
condition|)
name|sprintf
argument_list|(
name|helpprompt
argument_list|,
literal|"\nTo see a topic, type its name or number, and RETURN; '%c' to quit, '?' for help."
argument_list|,
name|shellprompt
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|helpprompt
argument_list|,
literal|"\nTo display a topic, type its name, and RETURN; type '%c' to quit, '?' for help."
argument_list|,
name|shellprompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
condition|)
name|sprintf
argument_list|(
name|indexprompt
argument_list|,
literal|"\nTo display a subject, type its name or number, and RETURN; type '?' for help."
argument_list|,
name|shellprompt
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|indexprompt
argument_list|,
literal|"\nTo display a subject, type its name, and RETURN; type '?' for help."
argument_list|,
name|shellprompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|moredef
condition|)
return|return;
name|myenv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|vp
operator|-
name|environ
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|myenv
condition|)
name|PERROR
expr_stmt|;
operator|*
name|myenv
operator|=
operator|(
name|quiet
condition|?
literal|"MORE=  "
else|:
literal|"MORE=-d"
operator|)
expr_stmt|;
name|more_d
operator|=
operator|*
name|myenv
operator|+
literal|5
expr_stmt|;
comment|/* points to "-d" or "  " */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|vp
operator|=
name|myenv
operator|+
literal|1
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|vp
operator|++
control|)
operator|*
name|vp
operator|=
name|environ
index|[
name|i
index|]
expr_stmt|;
name|environ
operator|=
name|myenv
expr_stmt|;
block|}
end_block

begin_macro
name|startup
argument_list|()
end_macro

begin_comment
comment|/* get topic named by args, return first instruction */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ins
decl_stmt|;
name|char
modifier|*
modifier|*
name|t
decl_stmt|,
modifier|*
modifier|*
name|u
decl_stmt|;
if|if
condition|(
name|maintkey
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hvec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|WRITABLE
argument_list|(
name|hvec
index|[
name|i
index|]
argument_list|)
operator|&&
name|isadir
argument_list|(
name|hvec
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|hvec
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You need write permission in at least one directory in HELPPOOL.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|helpmaint
argument_list|(
name|maintkey
argument_list|,
name|hvec
index|[
name|i
index|]
argument_list|,
name|argp
argument_list|)
expr_stmt|;
comment|/* no return */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hvec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
comment|/* collect first level (root) */
name|getfiles
argument_list|(
name|hvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* topics to be kept permanently */
name|rtlen
operator|=
name|tlen
expr_stmt|;
comment|/* save root topic sizes */
name|topics
operator|=
name|tptrs
expr_stmt|;
comment|/* active topic segment */
name|vsort
argument_list|(
name|tptrs
argument_list|)
expr_stmt|;
comment|/* sort -- replace dups with zero */
name|t
operator|=
name|u
operator|=
name|tptrs
expr_stmt|;
comment|/* kill off zeros */
while|while
condition|(
name|t
operator|<
name|tptrs
operator|+
name|nt
condition|)
if|if
condition|(
operator|!
operator|*
name|t
condition|)
name|t
operator|++
expr_stmt|;
else|else
operator|*
name|u
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
operator|*
name|u
operator|=
literal|0
expr_stmt|;
comment|/* mark new end of first segment */
name|nt
operator|=
name|u
operator|-
name|tptrs
expr_stmt|;
comment|/* so tptrs[nt-1] is nil */
name|subt
operator|=
name|nt
operator|+
literal|1
expr_stmt|;
comment|/* mark start of subtopic segment */
for|for
control|(
init|;
operator|*
name|argp
condition|;
name|argp
operator|++
control|)
block|{
comment|/* go through topic arguments */
if|if
condition|(
operator|!
name|match
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
comment|/* if no match, try something else */
if|if
condition|(
operator|(
name|ins
operator|=
name|whatnext
argument_list|(
operator|*
name|argp
argument_list|)
operator|)
operator|!=
name|GOT_ONE
condition|)
return|return
name|ins
return|;
comment|/* user can escape this way */
if|if
condition|(
operator|!
name|chwd
argument_list|(
name|topics
index|[
name|hit
index|]
argument_list|)
condition|)
comment|/* if match, assume it's a directory */
break|break;
comment|/* not a directory, must be a file */
block|}
if|if
condition|(
operator|!
operator|*
name|argp
condition|)
return|return
name|LIST_I
return|;
name|src
operator|=
name|topics
index|[
name|hit
index|]
expr_stmt|;
name|makefname
argument_list|(
name|dirlevel
argument_list|,
name|topics
index|[
name|hit
index|]
argument_list|)
expr_stmt|;
name|page
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iflag
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|interactive
operator|=
literal|1
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
end_block

begin_macro
name|whatnext
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* match s with a file or find out what to do */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if success, global src set from s */
end_comment

begin_block
block|{
specifier|static
name|char
name|word
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|char
name|rbuf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|wlen
decl_stmt|;
name|strcpy
argument_list|(
name|word
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|src
operator|=
name|word
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|interactive
condition|)
block|{
name|printf
argument_list|(
literal|"\nThere is no topic \"%s\".  I'm looking in the index.\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
name|FIND_I
return|;
block|}
elseif|else
if|if
condition|(
name|nhits
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nNot precise enough.  Enter more letters, or RETURN:  %s"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|wlen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|word
operator|+
name|wlen
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|QUIT_I
return|;
if|if
condition|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|<=
name|wlen
condition|)
comment|/* no new letters */
return|return
name|NOOP_I
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nThere is no topic \"%s\".  Shall I look in the index?  "
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|rbuf
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|QUIT_I
return|;
if|if
condition|(
operator|*
name|rbuf
operator|==
literal|'y'
condition|)
return|return
name|FIND_I
return|;
return|return
name|NOOP_I
return|;
block|}
block|}
do|while
condition|(
operator|!
name|match
argument_list|(
name|word
argument_list|)
condition|)
do|;
name|src
operator|=
name|topics
index|[
name|hit
index|]
expr_stmt|;
return|return
name|GOT_ONE
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|cwdend
init|=
name|cwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of current directory string */
end_comment

begin_expr_stmt
name|chwd
argument_list|(
name|s
argument_list|)
comment|/* change directory routine */
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DOT
argument_list|(
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DOTDOT
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|dirlevel
operator|==
literal|0
condition|)
return|return
operator|!
name|printf
argument_list|(
literal|"\nYou're at the top level already.\n"
argument_list|)
return|;
while|while
condition|(
operator|*
operator|--
name|cwdend
operator|!=
literal|'/'
condition|)
empty_stmt|;
operator|*
name|cwdend
operator|=
literal|0
expr_stmt|;
name|dirlevel
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ROOT
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|dirlevel
operator|==
literal|0
condition|)
return|return
operator|!
name|printf
argument_list|(
literal|"\nYou're at the top level already.\n"
argument_list|)
return|;
name|dirlevel
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirlevel
operator|>
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|strcat
argument_list|(
name|cwdend
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EXECABLE
argument_list|(
name|cwd
argument_list|)
operator|||
operator|!
name|isadir
argument_list|(
name|cwd
argument_list|)
condition|)
return|return
operator|*
name|cwdend
operator|=
literal|0
return|;
while|while
condition|(
operator|*
operator|++
name|cwdend
condition|)
empty_stmt|;
name|dirlevel
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hvec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|cwdend
operator|=
name|strcpy
argument_list|(
name|cwd
argument_list|,
name|hvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|cwdend
condition|)
empty_stmt|;
name|subdir
operator|=
name|cwdend
expr_stmt|;
name|strcat
argument_list|(
name|strcat
argument_list|(
name|cwdend
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXECABLE
argument_list|(
name|cwd
argument_list|)
operator|&&
name|isadir
argument_list|(
name|cwd
argument_list|)
condition|)
break|break;
operator|*
name|cwdend
operator|=
literal|0
expr_stmt|;
name|subdir
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hvec
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
operator|++
name|cwdend
condition|)
empty_stmt|;
name|dirlevel
operator|++
expr_stmt|;
block|}
comment|/* 	 * reclaim subtopic storage, get new topics 	 */
name|nhits
operator|=
literal|0
expr_stmt|;
name|hit
operator|=
operator|-
literal|1
expr_stmt|;
name|tlen
operator|=
name|rtlen
expr_stmt|;
if|if
condition|(
name|dirlevel
operator|>
literal|0
condition|)
block|{
name|nt
operator|=
name|subt
expr_stmt|;
name|topics
operator|=
name|tptrs
operator|+
name|subt
expr_stmt|;
name|getfiles
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
name|vsort
argument_list|(
name|topics
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nt
operator|=
name|subt
operator|-
literal|1
expr_stmt|;
name|topics
operator|=
name|tptrs
expr_stmt|;
name|subdir
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|nextins
argument_list|()
end_macro

begin_comment
comment|/* sets up globals:  src, dst, and fname */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|ins
decl_stmt|,
name|got_one
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
comment|/* 	 * initialize fname, src, dst, and keeppag; get instruction 	 */
if|if
condition|(
operator|!
name|interactive
condition|)
return|return
name|QUIT_I
return|;
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|src
operator|=
name|dst
operator|=
name|dstarg
operator|=
literal|0
expr_stmt|;
name|keeppag
operator|=
literal|0
expr_stmt|;
name|prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|line
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|QUIT_I
return|;
comment|/* 	 * trim blanks from end and beginning of line 	 */
for|for
control|(
name|p
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|p
operator|>=
name|line
condition|;
name|p
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|<
name|line
condition|)
return|return
name|NOOP_I
return|;
operator|*
operator|++
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* 	 * parse zero operand instructions 	 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'?'
condition|)
return|return
name|HELP_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
return|return
name|ROOT_I
return|;
if|if
condition|(
name|DOT
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|LIST_I
return|;
if|if
condition|(
name|DOTDOT
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|BACK_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
return|return
name|QUIT_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
return|return
name|YELL_I
return|;
comment|/* 	 * other instructions 	 */
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
name|src
operator|=
operator|++
name|p
expr_stmt|;
return|return
name|PASS_I
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|src
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|dst
operator|=
name|p
expr_stmt|;
return|return
name|FLAG_I
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
comment|/* = as topic */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|hit
operator|<
literal|0
condition|)
return|return
name|JUNK_I
return|;
block|}
elseif|else
if|if
condition|(
name|number
operator|&&
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
for|for
control|(
name|s
operator|=
name|p
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|hit
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hit
operator|<
literal|0
operator|||
name|hit
operator|>=
operator|(
name|dirlevel
operator|==
literal|0
condition|?
name|nt
else|:
name|nt
operator|-
name|subt
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nThere is no topic numbered %d.\n"
argument_list|,
name|atoi
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
name|got_one
operator|++
expr_stmt|;
name|src
operator|=
name|topics
index|[
name|hit
index|]
expr_stmt|;
name|makefname
argument_list|(
name|dirlevel
argument_list|,
name|topics
index|[
name|hit
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* put topic name in src */
name|src
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|!
name|isspecial
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* make sure it ends */
block|}
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|src
condition|)
block|{
comment|/* no topic, see if default exists */
if|if
condition|(
name|hit
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nYou need to give a topic name for that."
argument_list|)
expr_stmt|;
return|return
name|JUNK_I
return|;
block|}
name|src
operator|=
name|topics
index|[
name|hit
index|]
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
operator|||
name|c
operator|==
literal|'|'
condition|)
block|{
comment|/* more args allowed */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
name|keeppag
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|++
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
name|strcat
argument_list|(
name|p
argument_list|,
operator|(
name|c
operator|==
literal|'>'
condition|?
name|HELPSAVE
else|:
literal|"lpr"
operator|)
argument_list|)
expr_stmt|;
name|dst
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* terminate dst */
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|dstarg
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* terminate dstarg */
block|}
block|}
comment|/* 	 * instructions requiring src 	 */
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
return|return
name|FIND_I
return|;
if|if
condition|(
operator|!
name|got_one
condition|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|src
argument_list|)
operator|&&
operator|(
name|ins
operator|=
name|whatnext
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|GOT_ONE
condition|)
return|return
name|ins
return|;
name|src
operator|=
name|topics
index|[
name|hit
index|]
expr_stmt|;
name|makefname
argument_list|(
name|dirlevel
argument_list|,
name|topics
index|[
name|hit
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|TYPE_I
return|;
if|if
condition|(
name|c
operator|==
literal|'|'
condition|)
return|return
name|LPRT_I
return|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
return|return
name|SAVE_I
return|;
return|return
name|JUNK_I
return|;
block|}
end_block

begin_macro
name|prompt
argument_list|()
end_macro

begin_comment
comment|/* prompt user */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|fputs
argument_list|(
name|helpprompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n("
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|progname
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdir
condition|)
for|for
control|(
name|p
operator|=
name|subdir
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|") "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|substr
argument_list|(
name|s
argument_list|,
name|abbr
argument_list|)
comment|/* returns 1 if abbr abbreviates s */
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|abbr
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
operator|*
name|s
operator|==
operator|*
name|abbr
operator|&&
operator|*
name|abbr
condition|;
name|s
operator|++
operator|,
name|abbr
operator|++
control|)
empty_stmt|;
return|return
operator|!
operator|*
name|abbr
return|;
block|}
end_block

begin_expr_stmt
name|fsubstr
argument_list|(
name|s
argument_list|,
name|abbr
argument_list|)
comment|/* returns 1 if abbr abbreviates lcased s */
specifier|register
name|char
operator|*
name|s
operator|,
operator|*
name|abbr
expr_stmt|;
end_expr_stmt

begin_block
block|{
for|for
control|(
init|;
name|lcase
argument_list|(
operator|*
name|s
argument_list|)
operator|==
operator|*
name|abbr
operator|&&
operator|*
name|abbr
condition|;
name|s
operator|++
operator|,
name|abbr
operator|++
control|)
empty_stmt|;
return|return
operator|!
operator|*
name|abbr
return|;
block|}
end_block

begin_macro
name|getfiles
argument_list|(
argument|dname
argument_list|)
end_macro

begin_comment
comment|/* fill topicbuf and tptrs */
end_comment

begin_decl_stmt
name|char
modifier|*
name|dname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|direct
name|dbuf
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|ep
init|=
operator|&
name|dbuf
decl_stmt|;
comment|/* directory entry pointer */
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
name|BSD4_2
name|DIR
modifier|*
name|dp
decl_stmt|;
define|#
directive|define
name|OPENDIR
parameter_list|(
name|s
parameter_list|)
value|((dp = opendir(s)) != NULL)
define|#
directive|define
name|DIRLOOP
parameter_list|(
name|s
parameter_list|)
value|for (s = readdir(dp); s != NULL; s = readdir(dp))
define|#
directive|define
name|PATHSIZE
value|256
define|#
directive|define
name|PATHSIZE
value|256
define|#
directive|define
name|MAXDLEN
value|ep->d_namlen
define|#
directive|define
name|CLOSEDIR
value|closedir(dp)
else|#
directive|else
name|int
name|fd
decl_stmt|;
define|#
directive|define
name|OPENDIR
parameter_list|(
name|s
parameter_list|)
value|((fd = open(s, 0))>= 0)
define|#
directive|define
name|DIRLOOP
parameter_list|(
name|s
parameter_list|)
value|while (read(fd, s, sizeof *s) == sizeof *s)
define|#
directive|define
name|MAXDLEN
value|DIRSIZ
define|#
directive|define
name|CLOSEDIR
value|close(fd)
endif|#
directive|endif
if|if
condition|(
operator|!
name|OPENDIR
argument_list|(
name|dname
argument_list|)
condition|)
return|return
name|perror
argument_list|(
name|dname
argument_list|)
return|;
name|tptrs
index|[
name|nt
index|]
operator|=
operator|&
name|topicbuf
index|[
name|tlen
index|]
expr_stmt|;
name|DIRLOOP
argument_list|(
argument|ep
argument_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|ep
operator|->
name|d_ino
operator|==
literal|0
operator|||
name|DOT
argument_list|(
name|ep
operator|->
name|d_name
argument_list|)
operator|||
name|DOTDOT
argument_list|(
name|ep
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|tptrs
index|[
name|nt
operator|++
index|]
operator|=
operator|&
name|topicbuf
index|[
name|tlen
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXDLEN
operator|&&
name|ep
operator|->
name|d_name
index|[
name|i
index|]
condition|;
name|tlen
operator|++
operator|,
name|i
operator|++
control|)
name|topicbuf
index|[
name|tlen
index|]
operator|=
name|ep
operator|->
name|d_name
index|[
name|i
index|]
expr_stmt|;
name|topicbuf
index|[
name|tlen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|tptrs
index|[
name|nt
index|]
operator|=
literal|0
expr_stmt|;
name|CLOSEDIR
expr_stmt|;
block|}
end_block

begin_macro
name|isadir
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|buf
decl_stmt|;
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|st_mode
operator|&
name|S_IFDIR
return|;
block|}
end_block

begin_decl_stmt
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_macro
name|onintr
argument_list|()
end_macro

begin_comment
comment|/* catch broken pipe signals */
end_comment

begin_block
block|{
name|NO_RUPTS
expr_stmt|;
name|SET_SIGPIPE
expr_stmt|;
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|wrapup
argument_list|(
argument|fp
argument_list|)
end_macro

begin_comment
comment|/* close a file pointer and wait for child */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|firstime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for first topic listing */
end_comment

begin_macro
name|list
argument_list|()
end_macro

begin_comment
comment|/* list topics in 4 columns */
end_comment

begin_block
block|{
specifier|register
name|int
name|col
decl_stmt|,
name|row
decl_stmt|,
name|i
decl_stmt|,
name|last
decl_stmt|,
name|nrows
decl_stmt|;
name|FILE
modifier|*
name|more
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|NO_RUPTS
expr_stmt|;
if|if
condition|(
operator|(
name|more
operator|=
name|outpipe
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|PERROR
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
name|wrapup
argument_list|(
name|more
argument_list|)
expr_stmt|;
return|return;
block|}
name|GET_SIGPIPE
expr_stmt|;
if|if
condition|(
name|firstime
condition|)
block|{
name|fprintf
argument_list|(
name|more
argument_list|,
literal|"\n%s\n%s\n"
argument_list|,
literal|"Here is a list of topics I know about."
argument_list|,
literal|"If you don't see the topic you want, I can look for it in the index."
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
literal|"general"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|more
argument_list|,
literal|"For a general introduction, please see \"general\" below.\n"
argument_list|)
expr_stmt|;
name|firstime
operator|=
literal|0
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|last
operator|=
operator|(
name|dirlevel
operator|>
literal|0
condition|?
name|nt
operator|-
name|subt
else|:
name|nt
operator|)
expr_stmt|;
name|nrows
operator|=
name|last
operator|/
literal|4
operator|+
operator|(
name|last
operator|%
literal|4
operator|!=
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
name|row
operator|++
control|)
for|for
control|(
name|i
operator|=
name|row
operator|,
name|col
operator|=
literal|0
init|;
name|col
operator|<
literal|4
condition|;
name|i
operator|+=
name|nrows
operator|,
name|col
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|last
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|col
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|number
condition|)
name|fprintf
argument_list|(
name|more
argument_list|,
literal|"%3d%c%-14.14s %c"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|(
name|hit
operator|==
name|i
condition|?
literal|'='
else|:
literal|' '
operator|)
argument_list|,
name|topics
index|[
name|i
index|]
argument_list|,
operator|(
name|col
operator|==
literal|3
condition|?
literal|'\n'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|more
argument_list|,
literal|"%c%-17.17s %c"
argument_list|,
operator|(
name|hit
operator|==
name|i
condition|?
literal|'='
else|:
literal|' '
operator|)
argument_list|,
name|topics
index|[
name|i
index|]
argument_list|,
operator|(
name|col
operator|==
literal|3
condition|?
literal|'\n'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
block|}
name|wrapup
argument_list|(
name|more
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|IBSIZE
value|16384
end_define

begin_define
define|#
directive|define
name|IPSIZE
value|512
end_define

begin_macro
name|find
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
name|char
name|sbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|iptrs
condition|)
block|{
comment|/* malloc storage once and for all */
name|indexbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|IBSIZE
operator|+
name|BUFSIZ
argument_list|)
expr_stmt|;
name|iptrs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|IPSIZE
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iptrs
operator|==
literal|0
operator|||
name|indexbuf
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No index space.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ni
operator|=
literal|0
expr_stmt|;
name|ilen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hvec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%s/%s"
argument_list|,
name|hvec
index|[
name|i
index|]
argument_list|,
name|TOPICINDEX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|sbuf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hvec
index|[
name|i
index|]
argument_list|,
name|HELPROOT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|perror
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|getrefs
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|MANINDEX
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|MANINDEX
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mansegment
operator|=
name|ni
expr_stmt|;
name|getrefs
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
specifier|static
name|char
modifier|*
name|manindex
index|[]
init|=
name|MANINDEX
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|mi
decl_stmt|;
name|mansegment
operator|=
name|ni
expr_stmt|;
for|for
control|(
name|mi
operator|=
name|manindex
init|;
operator|*
name|mi
operator|!=
name|NULL
condition|;
name|mi
operator|++
control|)
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
name|mi
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|getrefs
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|docsegment
operator|=
name|ni
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|DOCINDEX
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|getrefs
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ni
operator|==
literal|0
condition|)
return|return
name|printf
argument_list|(
literal|"\nNo relevant material; your request has been logged.\n"
argument_list|)
return|;
name|putrefs
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|selectref
argument_list|()
operator|)
operator|!=
name|QUIT_I
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|LIST_I
case|:
name|putrefs
argument_list|()
expr_stmt|;
break|break;
case|case
name|HELP_I
case|:
name|icomlist
argument_list|()
expr_stmt|;
break|break;
case|case
name|ROOT_I
case|:
name|chwd
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
case|case
name|BACK_I
case|:
name|list
argument_list|()
expr_stmt|;
return|return;
case|case
name|YELL_I
case|:
name|yell
argument_list|()
expr_stmt|;
break|break;
case|case
name|PASS_I
case|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pass
argument_list|(
name|isrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLAG_I
case|:
name|flag
argument_list|(
name|isrc
argument_list|,
name|idst
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|puts
argument_list|(
literal|"Bye."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|icomlist
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|number
condition|)
name|puts
argument_list|(
literal|"\nTo see a subject, type its name, a unique abbreviation, or its number."
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"\nTo see a subject, type its name or a unique abbreviation."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Other commands are:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %c             quit from help and return to the shell (control-d works also)\n"
argument_list|,
name|shellprompt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  subject       display a \"subject\", whose name%syou supply\n"
argument_list|,
operator|(
name|number
condition|?
literal|" or number "
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  ?             display this command list"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  .             list subject references found"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  ..            go back to the previous list of help topics"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  /             back up to and list the top level of topics"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<             send comments or other input to the maintainer of help"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  !command      do a Unix command and then return to help"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  * flag on/off set a \"flag\" on or off to adjust the behavior of help"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"                (type * by itself for a list of flags you can use)"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"The Unix command in brackets below each subject will display the same"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"information that I do.  Sometimes information exists only off-line and I"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"have nothing to show you; try the local distributor of printed documentation."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|getrefs
argument_list|(
argument|fp
argument_list|,
argument|upm
argument_list|)
end_macro

begin_comment
comment|/* get references to src from indexes qq.v. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|upm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether looking at upm database "whatis" */
end_comment

begin_block
block|{
comment|/* 	 * indexbuf	str0\0str1\0str2\0str3\0 ... str(ni-1)\0 	 * iptrs	^     ^     ^     ^      ... ^          0 	 */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ref
decl_stmt|;
name|char
name|s
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
comment|/* lower case version of src */
name|char
name|t
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* temporary line buffer */
name|int
name|preamble
init|=
operator|!
name|upm
decl_stmt|;
if|if
condition|(
name|ilen
operator|>
name|IBSIZE
operator|||
name|ni
operator|>
name|IPSIZE
condition|)
return|return
name|puts
argument_list|(
literal|"Index space full."
argument_list|)
return|;
for|for
control|(
name|p
operator|=
name|src
operator|,
name|ref
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|ref
operator|++
control|)
comment|/* ref becomes lower case */
operator|*
name|ref
operator|=
name|lcase
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* version of src */
operator|*
name|ref
operator|=
literal|0
expr_stmt|;
name|ref
operator|=
name|s
expr_stmt|;
name|iptrs
index|[
name|ni
index|]
operator|=
operator|&
name|indexbuf
index|[
name|ilen
index|]
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|t
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|preamble
condition|)
block|{
comment|/* indexes all have preamble to skip */
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|t
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|&&
name|fsubstr
argument_list|(
name|p
argument_list|,
literal|"------"
argument_list|)
condition|)
name|preamble
operator|=
literal|0
expr_stmt|;
comment|/* preamble over */
continue|continue;
block|}
for|for
control|(
name|p
operator|=
name|t
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|lcase
argument_list|(
operator|*
name|p
argument_list|)
operator|==
operator|*
name|ref
operator|&&
name|fsubstr
argument_list|(
name|p
argument_list|,
name|ref
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
continue|continue;
name|iptrs
index|[
name|ni
operator|++
index|]
operator|=
operator|&
name|indexbuf
index|[
name|ilen
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|t
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|ilen
operator|++
operator|,
name|p
operator|++
control|)
name|indexbuf
index|[
name|ilen
index|]
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|upm
condition|)
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|;
name|ilen
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|' '
condition|)
break|break;
comment|/* cover glitches in MANINDEX */
else|else
name|indexbuf
index|[
name|ilen
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|indexbuf
index|[
name|ilen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|upm
operator|&&
operator|*
name|p
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|' '
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
name|iptrs
index|[
name|ni
operator|++
index|]
operator|=
operator|&
name|indexbuf
index|[
name|ilen
index|]
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|ilen
operator|++
operator|,
name|p
operator|++
control|)
name|indexbuf
index|[
name|ilen
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|indexbuf
index|[
name|ilen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|iptrs
index|[
name|ni
index|]
operator|=
literal|0
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putrefs
argument_list|()
end_macro

begin_comment
comment|/* list references stored in iptrs */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|format
decl_stmt|;
name|FILE
modifier|*
name|more
decl_stmt|;
name|NO_RUPTS
expr_stmt|;
if|if
condition|(
operator|(
name|more
operator|=
name|outpipe
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|PERROR
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
name|wrapup
argument_list|(
name|more
argument_list|)
expr_stmt|;
return|return;
block|}
name|GET_SIGPIPE
expr_stmt|;
name|format
operator|=
operator|(
name|number
condition|?
literal|"%3d  %s\t\t[ "
else|:
literal|"%s\t\t[ "
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|more
argument_list|,
literal|"\nThese subjects appear to be related to \"%s\".\n\n"
argument_list|,
name|src
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ni
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|number
condition|)
name|fprintf
argument_list|(
name|more
argument_list|,
name|format
argument_list|,
operator|(
name|i
operator|/
literal|2
operator|+
literal|1
operator|)
argument_list|,
name|iptrs
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|more
argument_list|,
name|format
argument_list|,
name|iptrs
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|mansegment
condition|)
block|{
name|fputs
argument_list|(
literal|"help "
argument_list|,
name|more
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|iptrs
index|[
name|i
index|]
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|putc
argument_list|(
operator|(
operator|*
name|p
operator|==
literal|'/'
condition|?
literal|' '
else|:
operator|*
name|p
operator|)
argument_list|,
name|more
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
name|docsegment
condition|)
name|fprintf
argument_list|(
name|more
argument_list|,
literal|"Off-line only document:  %s"
argument_list|,
name|iptrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs
argument_list|(
literal|"man "
argument_list|,
name|more
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|iptrs
index|[
name|i
index|]
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'('
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
name|p
operator|++
init|;
operator|*
name|p
operator|!=
literal|')'
condition|;
name|p
operator|++
control|)
name|putc
argument_list|(
name|lcase
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|more
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|iptrs
index|[
name|i
index|]
init|;
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|more
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|" ]\n"
argument_list|,
name|more
argument_list|)
expr_stmt|;
block|}
name|wrapup
argument_list|(
name|more
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|FILE
modifier|*
name|outpipe
parameter_list|()
comment|/* return a file descriptor pointing to "more" */
block|{
name|int
name|fildes
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fdopen
argument_list|()
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fildes
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
expr_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|OK_RUPTS
expr_stmt|;
name|close
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PERROR
expr_stmt|;
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"more"
argument_list|,
literal|"more"
argument_list|,
literal|"-s"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PERROR
expr_stmt|;
block|}
name|close
argument_list|(
name|fildes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|fdopen
argument_list|(
name|fildes
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
return|;
block|}
end_function

begin_macro
name|iprompt
argument_list|()
end_macro

begin_comment
comment|/* prompt user - index version */
end_comment

begin_block
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fputs
argument_list|(
name|indexprompt
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n(%s-index %s) "
argument_list|,
name|progname
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|selectref
argument_list|()
end_macro

begin_comment
comment|/* read user instruction for indexing */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|ins
decl_stmt|;
name|char
name|sbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|isrc
operator|=
name|idst
operator|=
literal|0
expr_stmt|;
name|iprompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|sbuf
argument_list|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sbuf
operator|+
name|strlen
argument_list|(
name|sbuf
argument_list|)
operator|-
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|p
operator|>=
name|sbuf
condition|;
name|p
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|<
name|sbuf
condition|)
return|return
name|NOOP_I
return|;
operator|*
operator|++
name|p
operator|=
literal|0
expr_stmt|;
comment|/* blanks now trimmed */
for|for
control|(
name|p
operator|=
name|sbuf
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
return|return
name|QUIT_I
return|;
if|if
condition|(
name|DOT
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|LIST_I
return|;
if|if
condition|(
name|DOTDOT
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|BACK_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'?'
condition|)
return|return
name|HELP_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
return|return
name|ROOT_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
return|return
name|YELL_I
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
name|isrc
operator|=
operator|++
name|p
expr_stmt|;
return|return
name|PASS_I
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|isrc
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|idst
operator|=
name|p
expr_stmt|;
return|return
name|FLAG_I
return|;
block|}
for|for
control|(
name|s
operator|=
name|p
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|s
operator|&&
name|number
condition|)
block|{
name|ihit
operator|=
literal|2
operator|*
name|atoi
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ihit
operator|<
literal|1
operator|||
name|ihit
operator|>
name|ni
condition|)
block|{
name|printf
argument_list|(
literal|"\nThere is no subject numbered %d.\n"
argument_list|,
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ins
operator|=
name|iwhatnext
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|GOT_ONE
condition|)
return|return
name|ins
return|;
if|if
condition|(
name|ihit
operator|<
name|mansegment
condition|)
block|{
name|makefname
argument_list|(
literal|0
argument_list|,
name|iptrs
index|[
name|ihit
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|page
argument_list|()
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
if|if
condition|(
name|ihit
operator|>=
name|docsegment
operator|&&
name|docsegment
operator|>
literal|0
condition|)
block|{
name|puts
argument_list|(
literal|"\nSorry, that reference is not available on the computer."
argument_list|)
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
for|for
control|(
name|s
operator|=
name|sbuf
operator|,
name|p
operator|=
name|iptrs
index|[
name|ihit
operator|-
literal|1
index|]
init|;
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|;
name|p
operator|++
control|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'('
condition|;
name|p
operator|++
control|)
empty_stmt|;
for|for
control|(
operator|*
name|s
operator|++
operator|=
literal|0
operator|,
name|p
operator|++
init|;
operator|*
name|p
operator|!=
literal|')'
condition|;
name|p
operator|++
control|)
operator|*
name|s
operator|++
operator|=
name|lcase
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
operator|*
name|s
operator|--
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|--
control|)
empty_stmt|;
name|execlp
argument_list|(
literal|"man"
argument_list|,
literal|"man"
argument_list|,
operator|++
name|s
argument_list|,
name|sbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PERROR
expr_stmt|;
block|}
name|NO_RUPTS
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
end_block

begin_macro
name|iwhatnext
argument_list|(
argument|s
argument_list|)
end_macro

begin_comment
comment|/* indexing version of whatnext */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|word
index|[
name|MAXNAMLEN
index|]
decl_stmt|;
name|int
name|wlen
decl_stmt|;
name|strcpy
argument_list|(
name|word
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|isrc
operator|=
name|word
expr_stmt|;
while|while
condition|(
operator|!
name|imatch
argument_list|(
name|word
argument_list|)
condition|)
if|if
condition|(
name|inhits
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nNot precise enough.  Enter more letters, or RETURN:  %s"
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|wlen
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|word
operator|+
name|wlen
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|QUIT_I
return|;
if|if
condition|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|<=
name|wlen
condition|)
comment|/* no new letters */
return|return
name|NOOP_I
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nThere is no subject \"%s\".\n"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|NOOP_I
return|;
block|}
name|isrc
operator|=
name|iptrs
index|[
name|ihit
index|]
expr_stmt|;
return|return
name|GOT_ONE
return|;
block|}
end_block

begin_macro
name|imatch
argument_list|(
argument|abbr
argument_list|)
end_macro

begin_comment
comment|/* indexing version of match (on unsorted list) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|abbr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|abbr
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|iptrs
operator|+
operator|(
name|docsegment
operator|<
literal|0
condition|?
name|ni
else|:
name|docsegment
operator|)
expr_stmt|;
name|inhits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|iptrs
operator|+
literal|1
init|;
name|t
operator|<
name|last
condition|;
name|t
operator|+=
literal|2
control|)
if|if
condition|(
operator|*
operator|*
name|t
operator|!=
operator|*
name|p
condition|)
comment|/* quickly check first character */
continue|continue;
elseif|else
if|if
condition|(
name|substr
argument_list|(
operator|*
name|t
argument_list|,
name|abbr
argument_list|)
condition|)
block|{
name|inhits
operator|++
expr_stmt|;
name|ihit
operator|=
name|t
operator|-
name|iptrs
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|t
argument_list|,
name|abbr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|inhits
operator|=
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|inhits
operator|==
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|makefname
argument_list|(
argument|dirlev
argument_list|,
argument|tail
argument_list|)
end_macro

begin_comment
comment|/* build fname from cwd and tail, return no. matched */
end_comment

begin_decl_stmt
name|int
name|dirlev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory level */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tail of pathname to use */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dirlev
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/%s"
argument_list|,
name|cwd
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|fnamect
operator|=
operator|(
name|EXISTS
argument_list|(
name|fname
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|fnamect
return|;
block|}
name|fnamect
operator|=
literal|0
expr_stmt|;
comment|/* count of number of dirs. where tail exists */
name|p
operator|=
name|fname
expr_stmt|;
comment|/* full names of files with tails as above */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hvec
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s/%s"
argument_list|,
name|hvec
index|[
name|i
index|]
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXISTS
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|fnamect
operator|++
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|fnamect
return|;
block|}
end_block

begin_expr_stmt
name|pass
argument_list|(
name|s
argument_list|)
comment|/* replace = with fname and send to system */
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* allow \= to pass as =, but \x passes as \x */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|PUTNL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|escaped
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|'='
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|s
expr_stmt|;
name|escaped
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
operator|&&
name|hit
operator|>=
literal|0
condition|)
block|{
name|makefname
argument_list|(
name|dirlevel
argument_list|,
name|topics
index|[
name|hit
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
literal|"-c"
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PERROR
expr_stmt|;
block|}
name|NO_RUPTS
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
block|}
end_block

begin_macro
name|flag
argument_list|(
argument|f
argument_list|,
argument|val
argument_list|)
end_macro

begin_comment
comment|/* set flag on or off; 0 in src and dst gives help */
end_comment

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|puts
argument_list|(
literal|"\nCurrent flag settings and their meanings are:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  number\t%suse numbers in topic and index listings\n"
argument_list|,
operator|(
name|number
condition|?
literal|"on\t"
else|:
literal|"off\tdo not "
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  quiet \t%ssuppress the instruction line before prompting\n"
argument_list|,
operator|(
name|quiet
condition|?
literal|"on\t"
else|:
literal|"off\tdo not "
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|substr
argument_list|(
literal|"number"
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nnumber:  was %s,"
argument_list|,
operator|(
name|number
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|number
operator|=
operator|(
name|number
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* toggle */
else|else
name|number
operator|=
operator|(
name|val
index|[
literal|1
index|]
operator|==
literal|'n'
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" is %s.\n"
argument_list|,
operator|(
name|number
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|substr
argument_list|(
literal|"quiet"
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nquiet:  was %s,"
argument_list|,
operator|(
name|quiet
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|quiet
operator|=
operator|(
name|quiet
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* toggle */
else|else
name|quiet
operator|=
operator|(
name|val
index|[
literal|1
index|]
operator|==
literal|'n'
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" is %s.\n"
argument_list|,
operator|(
name|quiet
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|more_d
condition|)
name|strcpy
argument_list|(
name|more_d
argument_list|,
operator|(
name|quiet
condition|?
literal|"  "
else|:
literal|"-d"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|puts
argument_list|(
literal|"\nThat is not a flag I know about.  Type * for a complete list."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|page
argument_list|()
end_macro

begin_comment
comment|/* print a help file with more or run program */
end_comment

begin_block
block|{
name|char
name|c
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|more
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return;
comment|/* try to continue on this error */
block|}
name|c
index|[
literal|0
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* check first 2 characters of first file */
name|c
index|[
literal|1
index|]
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* looking for magic characters and numbers */
comment|/* (should check more than just the first) */
if|if
condition|(
name|runs
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* if a program, run it and then return */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
return|return;
block|}
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|NO_RUPTS
expr_stmt|;
if|if
condition|(
operator|(
name|more
operator|=
name|outpipe
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|PERROR
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|wrapup
argument_list|(
name|more
argument_list|)
expr_stmt|;
return|return;
block|}
name|GET_SIGPIPE
expr_stmt|;
name|putfiles
argument_list|(
name|fp
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|wrapup
argument_list|(
name|more
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|s
parameter_list|)
value|(*s == '\n')
end_define

begin_define
define|#
directive|define
name|sqspace
parameter_list|(
name|s
parameter_list|)
value|{ if (!isblank(s) || !wasblank) fputs(s, out); else linect--; wasblank = isblank(s); }
end_define

begin_macro
name|putfiles
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|)
end_macro

begin_comment
comment|/* print file(s) onto out file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first of the input files */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|fn
init|=
name|fname
decl_stmt|;
specifier|register
name|int
name|linectsum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|fnamect
operator|--
condition|)
block|{
if|if
condition|(
name|in
operator|==
name|NULL
operator|&&
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|linectsum
operator|+=
name|filter
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
name|NULL
expr_stmt|;
name|fn
operator|+=
name|strlen
argument_list|(
name|fn
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|linectsum
return|;
block|}
end_block

begin_macro
name|filter
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|)
end_macro

begin_comment
comment|/* filter out multiple blank lines and page banners */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|lbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|lineno
decl_stmt|,
name|wasblank
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
init|=
name|lbuf
decl_stmt|;
name|int
name|linect
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* check page one for proper headers; if none then keep pagination */
name|wasblank
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lineno
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|s
argument_list|,
name|BUFSIZ
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|;
name|lineno
operator|++
control|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|s
argument_list|)
operator|||
name|lineno
operator|>=
literal|4
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|lineno
operator|==
literal|4
operator|&&
operator|(
operator|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'H'
argument_list|)
operator|)
operator|&&
name|substr
argument_list|(
name|p
argument_list|,
literal|"HELP"
argument_list|)
operator|)
comment|/* help */
operator|||
name|index
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
operator|!=
name|rindex
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
operator|)
operator|)
condition|)
comment|/* man */
name|keeppag
operator|=
literal|1
expr_stmt|;
comment|/* criteria not met */
if|if
condition|(
name|lineno
operator|==
literal|1
operator|&&
operator|(
operator|*
name|s
operator|=
literal|'#'
operator|||
operator|*
name|s
operator|==
literal|':'
operator|)
condition|)
block|{
name|keeppag
operator|=
literal|1
expr_stmt|;
comment|/* this is a script file */
name|lineno
operator|=
literal|0
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|lineno
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|keeppag
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
name|sqspace
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keeppag
condition|)
name|fputs
argument_list|(
name|s
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
name|sqspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|linect
operator|=
name|lineno
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|s
argument_list|,
name|BUFSIZ
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|lineno
operator|++
operator|,
name|linect
operator|++
expr_stmt|;
if|if
condition|(
name|lineno
operator|>
literal|66
condition|)
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|keeppag
condition|)
comment|/* this global overrides our page 1 analysis */
name|fputs
argument_list|(
name|s
argument_list|,
name|out
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lineno
operator|>
literal|7
operator|&&
name|lineno
operator|<
literal|60
comment|/* skip page banners */
operator|||
name|linect
operator|<
literal|8
condition|)
comment|/* let first 7 go */
name|sqspace
argument_list|(
argument|s
argument_list|)
block|}
return|return
name|linect
return|;
block|}
end_block

begin_macro
name|runs
argument_list|(
argument|c
argument_list|)
end_macro

begin_comment
comment|/* run program or script named by fname, else return 0 */
end_comment

begin_decl_stmt
name|char
name|c
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
modifier|*
name|magic
init|=
operator|(
name|int
operator|*
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|&&
name|c
index|[
literal|0
index|]
operator|!=
literal|':'
operator|&&
operator|*
name|magic
operator|!=
literal|0413
operator|&&
operator|*
name|magic
operator|!=
literal|0410
operator|&&
operator|*
name|magic
operator|!=
literal|0407
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
if|if
condition|(
operator|*
name|magic
operator|==
literal|0413
operator|||
operator|*
name|magic
operator|==
literal|0410
operator|||
operator|*
name|magic
operator|==
literal|0407
condition|)
name|execv
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|execlp
argument_list|(
literal|"csh"
argument_list|,
literal|"csh"
argument_list|,
literal|"-f"
argument_list|,
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"sh"
argument_list|,
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
name|NO_RUPTS
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|OK_RUPTS
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|comlist
argument_list|()
end_macro

begin_comment
comment|/* list help instructions available */
end_comment

begin_block
block|{
if|if
condition|(
name|number
condition|)
name|puts
argument_list|(
literal|"\nTo see a topic, type its name, a unique abbreviation, or its number."
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"\nTo see a topic, type its name or a unique abbreviation."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Here is a list of commands:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %c             quit from help and return to the shell (control-d works also)\n"
argument_list|,
name|shellprompt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  topic         display a \"topic\", whose name%syou supply\n"
argument_list|,
operator|(
name|number
condition|?
literal|" or number "
else|:
literal|" "
operator|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  topic +       see what more is known about a topic"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  topic> file  save a topic in a file (you supply the name \"file\")"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  topic | lpr   paginate and print a topic on the lineprinter"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  topic>& file save a topic in a file with pagination"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  ?             display this command list"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  .             list topics at the current level"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  ..            back up to and list the next higher level of topics"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  /             back up to and list the top level of topics"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"<             send comments or other input to the maintainer of help"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  !command      do a Unix command and then return to help"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"  * flag on/off set a \"flag\" on or off to adjust the behavior of help"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"                (type * by itself for a list of flags you can use)"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"If you enter no topic in a command or just an equals sign (=),"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"the most recent topic at this level is used."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|match
argument_list|(
argument|abbr
argument_list|)
end_macro

begin_comment
comment|/* find a match for abbr in current directory */
end_comment

begin_decl_stmt
name|char
modifier|*
name|abbr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|abbr
decl_stmt|;
name|nhits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|topics
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
comment|/* find first string beginning */
if|if
condition|(
operator|*
operator|*
name|t
operator|==
operator|*
name|p
condition|)
comment|/* with same letter */
break|break;
for|for
control|(
init|;
operator|*
name|t
operator|&&
operator|*
operator|*
name|t
operator|==
operator|*
name|p
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|substr
argument_list|(
operator|*
name|t
argument_list|,
name|abbr
argument_list|)
condition|)
block|{
name|nhits
operator|++
expr_stmt|;
name|hit
operator|=
name|t
operator|-
name|topics
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|t
argument_list|,
name|abbr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nhits
operator|=
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|nhits
operator|==
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * radix sort of an alphanumeric list, identical keys deleted  * Originally by D. Wasley, July 1980  */
end_comment

begin_define
define|#
directive|define
name|MSB
value|0100
end_define

begin_macro
name|vsort
argument_list|(
argument|list
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|list
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
modifier|*
name|endlist
init|=
name|tptrs
operator|+
name|nt
operator|-
literal|1
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|endlist
operator|>
name|list
condition|)
name|_sortb
argument_list|(
name|list
argument_list|,
name|endlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* recursive sort */
block|}
end_block

begin_macro
name|_sortb
argument_list|(
argument|list
argument_list|,
argument|endlist
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|endlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|high
decl_stmt|,
name|c
decl_stmt|;
name|_sortr
argument_list|(
name|list
argument_list|,
name|endlist
argument_list|,
name|offset
argument_list|,
name|MSB
argument_list|)
expr_stmt|;
comment|/* radix sort on this char */
while|while
condition|(
name|list
operator|<
name|endlist
condition|)
block|{
comment|/* now sort each sublist that */
name|c
operator|=
operator|(
operator|*
name|list
operator|)
index|[
name|offset
index|]
expr_stmt|;
comment|/* starts with a common char */
name|high
operator|=
name|list
expr_stmt|;
while|while
condition|(
operator|(
operator|*
operator|++
name|high
operator|)
index|[
name|offset
index|]
operator|==
name|c
operator|&&
name|high
operator|<=
name|endlist
condition|)
empty_stmt|;
if|if
condition|(
name|high
operator|-
name|list
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|c
condition|)
name|_sortb
argument_list|(
name|list
argument_list|,
name|high
operator|-
literal|1
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* kill off identical keys */
for|for
control|(
name|list
operator|++
init|;
name|list
operator|<
name|high
condition|;
name|list
operator|++
control|)
operator|*
name|list
operator|=
literal|0
expr_stmt|;
block|}
name|list
operator|=
name|high
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|_sortr
argument_list|(
argument|list
argument_list|,
argument|endlist
argument_list|,
argument|offset
argument_list|,
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|offset
decl_stmt|,
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
modifier|*
name|endlist
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|low
decl_stmt|,
modifier|*
modifier|*
name|high
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|low
operator|=
name|list
expr_stmt|;
name|high
operator|=
name|endlist
expr_stmt|;
while|while
condition|(
name|low
operator|<
name|high
condition|)
block|{
while|while
condition|(
name|low
operator|<
name|endlist
operator|&&
operator|(
operator|(
operator|*
name|low
operator|)
index|[
name|offset
index|]
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
name|low
operator|++
expr_stmt|;
while|while
condition|(
name|high
operator|>
name|list
operator|&&
operator|(
operator|(
operator|*
name|high
operator|)
index|[
name|offset
index|]
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
name|high
operator|--
expr_stmt|;
if|if
condition|(
name|high
operator|>
name|low
condition|)
block|{
name|temp
operator|=
operator|*
name|high
expr_stmt|;
operator|*
name|high
operator|=
operator|*
name|low
expr_stmt|;
operator|*
name|low
operator|=
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mask
operator|>>=
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* redefine mask and sort sublists */
if|if
condition|(
name|endlist
operator|>
name|low
condition|)
name|_sortr
argument_list|(
name|low
argument_list|,
name|endlist
argument_list|,
name|offset
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|high
operator|>
name|list
condition|)
name|_sortr
argument_list|(
name|list
argument_list|,
name|high
argument_list|,
name|offset
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

