begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"rel.h"
end_include

begin_define
define|#
directive|define
name|RP6CYL
value|815
end_define

begin_comment
comment|/*  no. RP06 cylinders/pack */
end_comment

begin_define
define|#
directive|define
name|RP6TRK
value|19
end_define

begin_comment
comment|/*  no. tracks/cyl  */
end_comment

begin_define
define|#
directive|define
name|RP6SEC
value|22
end_define

begin_comment
comment|/*  no. sectors/track  */
end_comment

begin_define
define|#
directive|define
name|RM3CYL
value|823
end_define

begin_comment
comment|/*  RM03  */
end_comment

begin_define
define|#
directive|define
name|RM3TRK
value|5
end_define

begin_define
define|#
directive|define
name|RM3SEC
value|32
end_define

begin_define
define|#
directive|define
name|RP6ST
value|(rptrk*rpsec)
end_define

begin_define
define|#
directive|define
name|MAXSEC
value|(rpcyl*rptrk*rpsec)
end_define

begin_comment
comment|/*  sectors/pack  */
end_comment

begin_define
define|#
directive|define
name|M0
value|0x20010000
end_define

begin_comment
comment|/* phys addr MBA 0  */
end_comment

begin_define
define|#
directive|define
name|M1
value|0x20012000
end_define

begin_comment
comment|/*  phys addr MBA 1  */
end_comment

begin_define
define|#
directive|define
name|M_cr
value|1
end_define

begin_comment
comment|/*  MBA 0 control reg addr , longword offset */
end_comment

begin_define
define|#
directive|define
name|M_sr
value|2
end_define

begin_comment
comment|/* MBA 0 status reg offset */
end_comment

begin_define
define|#
directive|define
name|M_map
value|0x200
end_define

begin_comment
comment|/* start MBA 0 map reg's longword offset */
end_comment

begin_define
define|#
directive|define
name|M_var
value|3
end_define

begin_comment
comment|/* MBA 0 virt addr reg offset */
end_comment

begin_define
define|#
directive|define
name|M_bc
value|4
end_define

begin_comment
comment|/*  MBA 0 byte count reg offset */
end_comment

begin_define
define|#
directive|define
name|MBAinit
value|01
end_define

begin_comment
comment|/*  MBA init bit */
end_comment

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|EXTREG
value|0x400
end_define

begin_comment
comment|/*  base for external reg's on MBA  */
end_comment

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|RP_cr
value|0
end_define

begin_comment
comment|/* RP06 control reg offset, longword */
end_comment

begin_define
define|#
directive|define
name|RP_sr
value|1
end_define

begin_comment
comment|/*  RP06 status reg offset */
end_comment

begin_define
define|#
directive|define
name|RP_stk
value|5
end_define

begin_comment
comment|/*  RP06 sector/track reg offset */
end_comment

begin_define
define|#
directive|define
name|RP_typ
value|06
end_define

begin_comment
comment|/* drive type reg */
end_comment

begin_define
define|#
directive|define
name|RP_off
value|011
end_define

begin_comment
comment|/*  RP offset reg */
end_comment

begin_define
define|#
directive|define
name|RP_cyl
value|10
end_define

begin_comment
comment|/*  RP06 cylinder reg offset */
end_comment

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|RP_GO
value|1
end_define

begin_comment
comment|/*  go bit */
end_comment

begin_define
define|#
directive|define
name|RP_RED
value|070
end_define

begin_comment
comment|/*  RP06 read function code */
end_comment

begin_define
define|#
directive|define
name|RP_DC
value|010
end_define

begin_comment
comment|/*  drive clear function code */
end_comment

begin_define
define|#
directive|define
name|RP_DRY
value|0200
end_define

begin_comment
comment|/*  drive ready, status reg */
end_comment

begin_define
define|#
directive|define
name|RP_ERR
value|040000
end_define

begin_comment
comment|/* composite error, status reg */
end_comment

begin_define
define|#
directive|define
name|RP_RIP
value|020
end_define

begin_comment
comment|/* RP readin preset function code */
end_comment

begin_define
define|#
directive|define
name|RP_FMT
value|0x1000
end_define

begin_comment
comment|/* format bit in RP offset reg */
end_comment

begin_define
define|#
directive|define
name|RP_MOL
value|0x1000
end_define

begin_comment
comment|/* medium on-line bit in RP status reg */
end_comment

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|RXCS
value|32
end_define

begin_comment
comment|/*  receiver control/staus */
end_comment

begin_define
define|#
directive|define
name|RXDB
value|33
end_define

begin_comment
comment|/*  receiver data */
end_comment

begin_define
define|#
directive|define
name|TXCS
value|34
end_define

begin_comment
comment|/*  transmitter control/status */
end_comment

begin_define
define|#
directive|define
name|TXDB
value|35
end_define

begin_comment
comment|/*  transmitter data */
end_comment

begin_define
define|#
directive|define
name|RXCS_DONE
value|0x80
end_define

begin_comment
comment|/*  receiver done */
end_comment

begin_define
define|#
directive|define
name|TXCS_RDY
value|0x80
end_define

begin_comment
comment|/*  transmitter ready */
end_comment

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|MAG410
value|0410
end_define

begin_define
define|#
directive|define
name|MAG411
value|0411
end_define

begin_define
define|#
directive|define
name|MAXUNI
value|1
end_define

begin_define
define|#
directive|define
name|NL
value|012
end_define

begin_define
define|#
directive|define
name|CR
value|015
end_define

begin_define
define|#
directive|define
name|CDEL
value|0x23
end_define

begin_define
define|#
directive|define
name|LDEL
value|0x40
end_define

begin_define
define|#
directive|define
name|BLKSIZ
value|512
end_define

begin_define
define|#
directive|define
name|HDRSIZ
value|040
end_define

begin_comment
comment|/*  task header size  */
end_comment

begin_define
define|#
directive|define
name|INOSIZ
value|64
end_define

begin_comment
comment|/*  no. bytes per inode entry */
end_comment

begin_define
define|#
directive|define
name|INOBLK
value|(BLKSIZ/INOSIZ)
end_define

begin_comment
comment|/*  no. inodes/disk block */
end_comment

begin_define
define|#
directive|define
name|NAMSIZ
value|14
end_define

begin_comment
comment|/*  no. char's in dir name field */
end_comment

begin_define
define|#
directive|define
name|DIRSIZ
value|16
end_define

begin_comment
comment|/*  no. bytes/directory entry */
end_comment

begin_define
define|#
directive|define
name|SLASH
value|057
end_define

begin_comment
comment|/* '/'  */
end_comment

begin_define
define|#
directive|define
name|NADDR
value|13
end_define

begin_comment
comment|/* no. addr blocks in inode entry */
end_comment

begin_define
define|#
directive|define
name|KSP
value|0
end_define

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|IFMT
value|0170000
end_define

begin_define
define|#
directive|define
name|IFDIR
value|040000
end_define

begin_define
define|#
directive|define
name|IFREG
value|0100000
end_define

begin_define
define|#
directive|define
name|ROOTINO
value|2
end_define

begin_comment
comment|/*  root dir inode no. */
end_comment

begin_comment
comment|/*		*/
end_comment

begin_define
define|#
directive|define
name|RP6typ
value|022
end_define

begin_comment
comment|/*  RP06 */
end_comment

begin_define
define|#
directive|define
name|RM3typ
value|024
end_define

begin_comment
comment|/*  RM03 type */
end_comment

begin_struct
struct|struct
name|dirent
block|{
name|short
name|ino
decl_stmt|;
name|char
name|dname
index|[
name|NAMSIZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|inod
block|{
name|short
name|i_mode
decl_stmt|;
name|short
name|fill1
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i_size
decl_stmt|;
name|char
name|i_addr
index|[
literal|40
index|]
decl_stmt|;
name|int
name|fill2
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|thdr
block|{
name|int
name|hmagic
decl_stmt|;
name|int
name|htsiz
decl_stmt|;
name|int
name|hdsiz
decl_stmt|;
name|int
name|hbsiz
decl_stmt|;
name|int
name|hsmsiz
decl_stmt|;
name|int
name|hentry
decl_stmt|;
name|int
name|hrelb
decl_stmt|;
name|int
name|hrflg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|filsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[
name|BLKSIZ
index|]
decl_stmt|,
modifier|*
name|namep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dbuf
index|[
name|BLKSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|addr
index|[
name|NADDR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|mbap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MBA ptr */
end_comment

begin_decl_stmt
name|int
modifier|*
name|RPptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RP06 ptr */
end_comment

begin_decl_stmt
name|int
name|rpsec
decl_stmt|,
name|rpcyl
decl_stmt|,
name|rptrk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get set up in 'init' for RP06 or RM03 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bufloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtmp1
index|[
literal|128
index|]
decl_stmt|,
name|dtmp2
index|[
literal|128
index|]
decl_stmt|,
name|dtmp3
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* *  This program, '/fboot', is always read in by code in the RP *  boot block (block 0). It boots in the file specified by the *  user. */
end_comment

begin_function
name|main
parameter_list|()
block|{
comment|/* set stack ptr and move code up to high end of core */
name|reloc
argument_list|()
expr_stmt|;
comment|/* jump to re-located code */
asm|asm("	.text") ;
asm|asm("	.globl	_main1") ;
asm|asm("	jmp	*$(_main1+2)") ;
asm|asm("	.align	2") ;
block|}
end_function

begin_comment
comment|/*		*/
end_comment

begin_macro
name|main1
argument_list|()
end_macro

begin_block
block|{
name|char
name|ntmp
index|[
literal|10
operator|*
name|NAMSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|inum
decl_stmt|;
specifier|register
name|struct
name|inod
modifier|*
name|inp
decl_stmt|;
name|struct
name|inod
modifier|*
name|getiblk
parameter_list|()
function_decl|;
name|struct
name|dirent
modifier|*
name|dsearch
argument_list|()
decl_stmt|,
modifier|*
name|pde
decl_stmt|;
name|int
name|j
decl_stmt|;
name|floop
label|:
name|putnl
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"file : "
argument_list|)
expr_stmt|;
name|getcon
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
comment|/* null-terminated filename */
name|putnl
argument_list|()
expr_stmt|;
name|namep
operator|=
name|ntmp
expr_stmt|;
name|inum
operator|=
name|ROOTINO
expr_stmt|;
comment|/* root dir inode no. */
while|while
condition|(
operator|(
operator|*
name|namep
operator|)
operator|==
name|SLASH
condition|)
name|namep
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|namep
operator|)
operator|==
literal|'\0'
condition|)
goto|goto
name|floop
goto|;
name|mbap
operator|=
name|M0
expr_stmt|;
name|RPptr
operator|=
name|M0
operator|+
name|EXTREG
expr_stmt|;
if|if
condition|(
name|init
argument_list|()
condition|)
block|{
name|putlin
argument_list|(
literal|"init error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|giblk
label|:
comment|/* get disk block that has inode entry for inode no. 'inum' */
name|inp
operator|=
name|getiblk
argument_list|(
name|inum
argument_list|)
expr_stmt|;
comment|/* 'cp' = ptr. to inode entry in 'buf[]' */
if|if
condition|(
name|inp
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
block|{
name|ioerr
label|:
name|putlin
argument_list|(
literal|"disk i/o error"
argument_list|)
expr_stmt|;
goto|goto
name|floop
goto|;
block|}
comment|/* Get 'mode' and 'addr[]' entries for selected inode& save off */
name|iexpand
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/*  inode mode is in 'mode'. *   block no.'s are in 'addr[]'. *   If inode is a directory, search all its blocks for pathname *    component pointed to by 'namep'. *   If inode is regular file, load blocks of file into core *    for execution. */
if|if
condition|(
operator|(
name|j
operator|=
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
block|{
comment|/* Directory */
if|if
condition|(
operator|*
name|namep
operator|==
literal|'\0'
condition|)
goto|goto
name|floop
goto|;
comment|/* no more pathname */
name|pde
operator|=
name|dsearch
argument_list|()
expr_stmt|;
comment|/* search all directory blocks */
if|if
condition|(
name|pde
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
goto|goto
name|ioerr
goto|;
comment|/* i/o error */
if|if
condition|(
name|pde
operator|==
literal|0
condition|)
goto|goto
name|floop
goto|;
comment|/* pathname component not found */
comment|/* Found pathname component (directory or file) - go get 	  its inode and continue search. 	*/
name|inum
operator|=
name|pde
operator|->
name|ino
expr_stmt|;
goto|goto
name|giblk
goto|;
block|}
else|else
block|{
if|if
condition|(
name|j
operator|==
name|IFREG
condition|)
block|{
comment|/* regular file */
if|if
condition|(
operator|*
name|namep
operator|!=
literal|'\0'
condition|)
goto|goto
name|floop
goto|;
comment|/* should have been 			last component in pathname */
if|if
condition|(
name|lodfil
argument_list|()
condition|)
goto|goto
name|floop
goto|;
comment|/* load file whose 		  inode 'addr' blocks are in 'addr[]' */
comment|/* *  Code to check for task header, move code down to 0, *  get task entry address, clear core, etc. */
name|fexec
argument_list|()
expr_stmt|;
goto|goto
name|floop
goto|;
comment|/* returned from execution - go to loop */
block|}
block|}
goto|goto
name|floop
goto|;
comment|/* wasn't directory or file */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_function
name|struct
name|inod
modifier|*
name|getiblk
parameter_list|(
name|in
parameter_list|)
specifier|register
name|int
name|in
decl_stmt|;
block|{
comment|/* *  Read in disk inode block which contains inode *  no. 'in' - return ptr. to start of inode entry. */
specifier|register
name|i
expr_stmt|;
name|i
operator|=
operator|(
name|in
operator|+
operator|(
name|INOBLK
operator|*
literal|2
operator|)
operator|-
literal|1
operator|)
operator|/
name|INOBLK
expr_stmt|;
if|if
condition|(
name|dread
argument_list|(
name|i
argument_list|,
name|buf
argument_list|)
condition|)
comment|/*  read block 'i' into 'buf[]' */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* i/o error */
return|return
operator|(
operator|(
name|int
operator|)
name|buf
operator|+
operator|(
operator|(
operator|(
name|in
operator|-
literal|1
operator|)
operator|&
operator|(
name|INOBLK
operator|-
literal|1
operator|)
operator|)
operator|*
name|INOSIZ
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|iexpand
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|inod
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Get mode, file size and block no.'s from disk inode and store *  away. *  'ip' = ptr. to inode entry. */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|mode
operator|=
name|ip
operator|->
name|i_mode
expr_stmt|;
name|filsiz
operator|=
name|ip
operator|->
name|i_size
expr_stmt|;
name|f
operator|=
operator|(
operator|&
name|ip
operator|->
name|i_addr
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|t
operator|=
operator|(
operator|&
name|addr
index|[
literal|0
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NADDR
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
operator|(
operator|*
name|t
operator|++
operator|)
operator|=
operator|(
operator|*
name|f
operator|++
operator|)
expr_stmt|;
operator|(
operator|*
name|t
operator|++
operator|)
operator|=
operator|(
operator|*
name|f
operator|++
operator|)
expr_stmt|;
operator|(
operator|*
name|t
operator|++
operator|)
operator|=
operator|(
operator|*
name|f
operator|++
operator|)
expr_stmt|;
operator|(
operator|*
name|t
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_function
name|struct
name|dirent
modifier|*
name|dsearch
parameter_list|()
block|{
comment|/* *  Search blocks of directory inode 'inum', whose block *  no.'s are in 'addr[]', for pathname component pointed *  to by 'namep'. *  Return (-1) for error. *  Return (0)  for no match. *  Return ptr. to directory entry for match. */
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|dirent
modifier|*
name|pfind
parameter_list|()
function_decl|;
comment|/*  direct  */
name|cp
operator|=
name|pfind
argument_list|(
name|addr
argument_list|,
name|NADDR
operator|-
literal|3
argument_list|)
expr_stmt|;
comment|/* search 'NADDR-3' blocks(in 'naddr[]') */
if|if
condition|(
name|cp
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* i/o error */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* zero block encountered - no more blocks */
if|if
condition|(
name|cp
operator|==
literal|1
condition|)
goto|goto
name|level1
goto|;
comment|/* more blocks to search */
comment|/* 'cp' must be ptr. to matched directory */
name|found
label|:
comment|/*  point to next pathname component */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|(
operator|*
name|namep
operator|)
operator|)
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\0'
operator|)
condition|)
name|namep
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
while|while
condition|(
operator|*
name|namep
operator|==
literal|'/'
condition|)
name|namep
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
comment|/* */
name|level1
label|:
comment|/*  1st level indirection */
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|NADDR
operator|-
literal|3
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|dtmp1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* i/o error */
name|cp
operator|=
name|pfind
argument_list|(
name|dtmp1
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cp
operator|==
literal|1
condition|)
goto|goto
name|level2
goto|;
goto|goto
name|found
goto|;
name|level2
label|:
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|NADDR
operator|-
literal|2
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|dtmp1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dtmp1
index|[
name|i
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|dtmp1
index|[
name|i
index|]
argument_list|,
name|dtmp2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|pfind
argument_list|(
name|dtmp2
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cp
operator|==
literal|1
condition|)
continue|continue ;
goto|goto
name|found
goto|;
block|}
name|level3
label|:
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|NADDR
operator|-
literal|1
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|dtmp1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dread
argument_list|(
name|dtmp1
index|[
name|i
index|]
argument_list|,
name|dtmp2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dread
argument_list|(
name|dtmp2
index|[
name|i
index|]
argument_list|,
name|dtmp3
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|pfind
argument_list|(
name|dtmp3
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|(
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cp
operator|==
literal|1
condition|)
continue|continue ;
goto|goto
name|found
goto|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*		*/
end_comment

begin_function
name|struct
name|dirent
modifier|*
name|pfind
parameter_list|(
name|ia
parameter_list|,
name|knt
parameter_list|)
name|int
name|ia
index|[]
decl_stmt|;
specifier|register
name|int
name|knt
decl_stmt|;
block|{
comment|/* *  'ia' :  array of integer block no.'s. *  'knt' :  no. entries in 'ia' *  A zero block in 'ia[]' -> no match -> return(0) . *  Return (-1) on i/o error. *  Return (1) if no zero blocks and all blocks searched but *    no match. *  Return ptr. to directory entry for match. */
specifier|register
name|int
modifier|*
name|bp
decl_stmt|,
name|bn
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|ix
decl_stmt|;
name|bp
operator|=
name|ia
expr_stmt|;
while|while
condition|(
name|knt
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|bn
operator|=
operator|(
operator|*
name|bp
operator|++
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|bn
argument_list|,
name|dbuf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|ix
operator|=
name|dbuf
init|;
name|ix
operator|<
operator|&
name|dbuf
index|[
name|BLKSIZ
index|]
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|dnmatch
argument_list|(
name|ix
operator|->
name|dname
argument_list|,
name|namep
argument_list|)
condition|)
return|return
operator|(
name|ix
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|dnmatch
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
name|char
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  'p1' : ptr. to directory filename field *  'p2' : ptr. to null-terminated file pathname *  Return(1) if match, *   else, return(0). */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
for|for
control|(
name|i
operator|=
name|NAMSIZ
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|c1
operator|=
operator|(
operator|*
name|p1
operator|++
operator|)
expr_stmt|;
name|c2
operator|=
operator|(
operator|*
name|p2
operator|++
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|c1
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c2
operator|==
literal|'\0'
operator|)
operator|)
operator|||
operator|(
name|c2
operator|==
name|SLASH
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|c2
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c2
operator|==
name|SLASH
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|dread
argument_list|(
argument|dbn
argument_list|,
argument|cbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Read physical block no. 'dbn' from disk and *    load into array 'cbuf[]'. *  Return (-1) for i/o error. *  Else return (0). */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_DC
operator||
name|RP_GO
expr_stmt|;
comment|/*  RP06 drive clear function code */
operator|*
operator|(
name|RPptr
operator|+
name|RP_cyl
operator|)
operator|=
name|dbn
operator|/
name|RP6ST
expr_stmt|;
comment|/* cylinder no. */
name|i
operator|=
name|dbn
operator|%
name|RP6ST
expr_stmt|;
name|j
operator|=
operator|(
name|i
operator|/
name|rpsec
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* track */
operator|*
operator|(
name|RPptr
operator|+
name|RP_stk
operator|)
operator|=
name|j
operator||
operator|(
name|i
operator|%
name|rpsec
operator|)
expr_stmt|;
comment|/* sector : track */
operator|*
operator|(
name|mbap
operator|+
name|M_bc
operator|)
operator|=
operator|(
operator|-
name|BLKSIZ
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|)
name|cbuf
operator|&
literal|0777
expr_stmt|;
operator|*
operator|(
name|mbap
operator|+
name|M_var
operator|)
operator|=
name|i
expr_stmt|;
operator|*
operator|(
name|mbap
operator|+
name|M_map
operator|)
operator|=
operator|(
name|i
operator|=
literal|0x80000000
operator||
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|int
operator|)
name|cbuf
operator|>>
literal|9
argument_list|)
operator|&
literal|07777777
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
name|mbap
operator|+
name|M_map
operator|+
literal|1
operator|)
operator|=
operator|(
operator|++
name|i
operator|)
expr_stmt|;
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_RED
operator||
name|RP_GO
expr_stmt|;
comment|/* read */
name|dwait
argument_list|()
expr_stmt|;
comment|/* wait for i/o to finish */
if|if
condition|(
name|derror
argument_list|()
condition|)
block|{
comment|/* error */
name|putlin
argument_list|(
literal|"fboot : disk read error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* normal return */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|dwait
argument_list|()
end_macro

begin_block
block|{
comment|/* * Function to wait MBA 0 RP06 disc unit to be ready. */
while|while
condition|(
operator|(
operator|*
operator|(
name|RPptr
operator|+
name|RP_sr
operator|)
operator|&
name|RP_DRY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|derror
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Function to check for MBA 0 RP06 error. */
if|if
condition|(
operator|*
operator|(
name|RPptr
operator|+
name|RP_sr
operator|)
operator|&
name|RP_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Initialization. */
specifier|register
name|int
name|i
decl_stmt|;
operator|*
operator|(
name|mbap
operator|+
name|M_cr
operator|)
operator|=
name|MBAinit
expr_stmt|;
comment|/* MBA initialize */
if|if
condition|(
operator|(
operator|*
operator|(
name|RPptr
operator|+
name|RP_sr
operator|)
operator|&
name|RP_MOL
operator|)
operator|==
literal|0
condition|)
block|{
name|putlin
argument_list|(
literal|"unit not online"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_RIP
operator||
name|RP_GO
expr_stmt|;
comment|/* readin preset */
operator|*
operator|(
name|RPptr
operator|+
name|RP_off
operator|)
operator|=
name|RP_FMT
expr_stmt|;
comment|/* format bit in offset reg */
name|bufloc
operator|=
literal|0
expr_stmt|;
name|i
operator|=
operator|*
operator|(
name|RPptr
operator|+
name|RP_typ
operator|)
operator|&
literal|0777
expr_stmt|;
comment|/* get disk type */
if|if
condition|(
name|i
operator|==
name|RP6typ
condition|)
block|{
comment|/* RP06 */
name|rpsec
operator|=
name|RP6SEC
expr_stmt|;
name|rpcyl
operator|=
name|RP6CYL
expr_stmt|;
name|rptrk
operator|=
name|RP6TRK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
name|RM3typ
condition|)
block|{
name|rpsec
operator|=
name|RM3SEC
expr_stmt|;
name|rpcyl
operator|=
name|RM3CYL
expr_stmt|;
name|rptrk
operator|=
name|RM3TRK
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|lodfil
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Function to load a file into low core - disk blocks no.'s *  which comprise file are in 'addr[]'. *  Return (-1) if i/o error, *  else return (0). */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|int
name|dtmp1
index|[
literal|128
index|]
decl_stmt|,
name|dtmp2
index|[
literal|128
index|]
decl_stmt|;
comment|/*  direct  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NADDR
operator|-
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|bufloc
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bufloc
operator|+=
name|BLKSIZ
expr_stmt|;
block|}
name|level1
label|:
comment|/*  1st level indirection */
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|NADDR
operator|-
literal|3
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  read in<=128 blocks into low core */
if|if
condition|(
operator|(
name|k
operator|=
name|r128
argument_list|(
name|j
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* i/o error */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no more blocks */
name|level2
label|:
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|NADDR
operator|-
literal|2
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|dtmp1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|dtmp1
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|k
operator|=
name|r128
argument_list|(
name|j
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|level3
label|:
if|if
condition|(
operator|(
name|j
operator|=
name|addr
index|[
name|NADDR
operator|-
literal|1
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|dtmp1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|dtmp1
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dread
argument_list|(
name|k
argument_list|,
name|dtmp2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|dtmp2
index|[
name|j
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|n
operator|=
name|r128
argument_list|(
name|k
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|r128
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|int
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Read in disk block no. 'blk' into buffer. *  Then read in the 128 disk blocks whose block no.'s are *  in the buffer into low core. *  Stop on a zero block no. - return(1). *  Return(-1) on i/o error. *  Return(0) if all 128 blocks read. */
name|int
name|btmp
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|dread
argument_list|(
name|blk
argument_list|,
name|btmp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|btmp
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* no more blocks */
if|if
condition|(
name|dread
argument_list|(
name|j
argument_list|,
name|bufloc
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* i/o error */
name|bufloc
operator|+=
name|BLKSIZ
expr_stmt|;
comment|/* next core block loc */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|halt
argument_list|()
end_macro

begin_block
block|{
asm|asm("	halt") ;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|putstr
argument_list|(
name|csp
argument_list|)
specifier|register
name|char
operator|*
name|csp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|putcon
argument_list|(
name|csp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|putlin
argument_list|(
name|sptr
argument_list|)
specifier|register
name|char
operator|*
name|sptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|putcon
argument_list|(
name|sptr
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|putnl
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|nullcon
argument_list|(
name|nn
argument_list|)
specifier|register
name|nn
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Output 'nn' nulls to console terminal - *  used for delay. */
while|while
condition|(
name|nn
operator|--
condition|)
name|putc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|putnl
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|putcon
argument_list|(
literal|"\r\n"
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|putcon
argument_list|(
name|csp
argument_list|)
specifier|register
name|char
operator|*
name|csp
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Function to output null-terminated string pointed to  *  by 'csp' to the VAX LSI terminal. */
specifier|register
name|c
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|(
operator|*
name|csp
operator|++
operator|)
condition|)
name|putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|putc
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/*  wait for LSI printer to be ready */
while|while
condition|(
operator|(
name|mfpr
argument_list|(
name|TXCS
argument_list|)
operator|&
name|TXCS_RDY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/*  output character */
name|mtpr
argument_list|(
name|TXDB
argument_list|,
name|c
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|getcon
argument_list|(
name|cs
argument_list|)
specifier|register
name|char
operator|*
name|cs
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Function to return char's from VAX LSI keyboard to *  char array 'cs' - input stops when CR or LF received - *  null char appended to end of input */
specifier|register
name|int
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|getc
parameter_list|()
function_decl|;
name|char
modifier|*
name|ocs
decl_stmt|;
name|ocs
operator|=
name|cs
expr_stmt|;
name|inloop
label|:
name|c
operator|=
name|getc
argument_list|()
expr_stmt|;
comment|/* get 1 char from terminal */
name|putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/*  echo char */
if|if
condition|(
name|c
operator|==
name|CDEL
condition|)
block|{
name|cs
operator|--
expr_stmt|;
goto|goto
name|inloop
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|LDEL
condition|)
block|{
name|putc
argument_list|(
name|CR
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|NL
argument_list|)
expr_stmt|;
name|cs
operator|=
name|ocs
expr_stmt|;
goto|goto
name|inloop
goto|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|NL
operator|)
operator|||
operator|(
name|c
operator|==
name|CR
operator|)
condition|)
block|{
name|putc
argument_list|(
name|CR
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|NL
argument_list|)
expr_stmt|;
operator|(
operator|*
name|cs
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
operator|(
operator|*
name|cs
operator|++
operator|)
operator|=
name|c
expr_stmt|;
goto|goto
name|inloop
goto|;
block|}
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|getc
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Return char from VAX LSI terminal char buffer */
name|int
name|mfpr
parameter_list|()
function_decl|;
comment|/*  Wait for receiver done (user entered char) */
while|while
condition|(
operator|(
name|mfpr
argument_list|(
name|RXCS
argument_list|)
operator|&
name|RXCS_DONE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
return|return
operator|(
name|mfpr
argument_list|(
name|RXDB
argument_list|)
operator|&
literal|0177
operator|)
return|;
comment|/* return char from receiver buffer */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|mtpr
argument_list|(
argument|regno
argument_list|,
argument|value
argument_list|)
end_macro

begin_block
block|{
asm|asm("	mtpr	8(ap),4(ap)") ;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|mfpr
argument_list|(
argument|regno
argument_list|)
end_macro

begin_block
block|{
asm|asm("	mfpr	4(ap),r0") ;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|a2l
argument_list|(
name|as
argument_list|)
specifier|register
name|char
operator|*
name|as
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Convert null-terminated ascii string to binary *  and return value. *  1st char in string : *	0 -> octal *	x -> hex *	else decimal */
specifier|register
name|value
operator|,
name|base
operator|,
name|sign
operator|,
name|digit
expr_stmt|;
name|digit
operator|=
name|value
operator|=
name|sign
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
comment|/* default base */
name|aloop
label|:
if|if
condition|(
operator|(
name|digit
operator|=
operator|(
operator|*
name|as
operator|++
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|value
operator|)
return|;
comment|/* null */
if|if
condition|(
name|digit
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|++
expr_stmt|;
goto|goto
name|aloop
goto|;
block|}
if|if
condition|(
name|digit
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
expr_stmt|;
comment|/* octal base  */
else|else
block|{
if|if
condition|(
name|digit
operator|==
literal|'x'
condition|)
name|base
operator|=
literal|16
expr_stmt|;
comment|/* hex base */
else|else
name|value
operator|=
operator|(
name|digit
operator|-
literal|060
operator|)
expr_stmt|;
comment|/* 060 = '0' */
block|}
while|while
condition|(
name|digit
operator|=
operator|(
operator|*
name|as
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|digit
operator|<
literal|'0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
block|{
if|if
condition|(
name|digit
operator|>
literal|'7'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|digit
operator|-=
literal|060
expr_stmt|;
break|break ;
block|}
case|case
literal|10
case|:
block|{
if|if
condition|(
name|digit
operator|>
literal|'9'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|digit
operator|-=
literal|060
expr_stmt|;
break|break ;
block|}
case|case
literal|16
case|:
block|{
if|if
condition|(
name|digit
operator|<=
literal|'9'
condition|)
block|{
name|digit
operator|-=
literal|060
expr_stmt|;
break|break ;
block|}
if|if
condition|(
operator|(
name|digit
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|digit
operator|<=
literal|'F'
operator|)
condition|)
block|{
name|digit
operator|=
operator|(
name|digit
operator|-
literal|0101
operator|+
literal|10
operator|)
expr_stmt|;
break|break ;
block|}
if|if
condition|(
operator|(
name|digit
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|digit
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|digit
operator|=
name|digit
operator|-
literal|0141
operator|+
literal|10
expr_stmt|;
break|break ;
block|}
return|return
operator|(
literal|0
operator|)
return|;
break|break ;
block|}
block|}
name|value
operator|=
operator|(
name|value
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
block|}
return|return
operator|(
name|sign
condition|?
operator|-
name|value
else|:
name|value
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|l2a
argument_list|(
name|val
argument_list|,
name|rptr
argument_list|)
specifier|register
name|int
name|val
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|rptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|int
name|knt
decl_stmt|;
name|char
name|tmp
index|[
literal|20
index|]
decl_stmt|,
name|sign
decl_stmt|;
name|knt
operator|=
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|sign
operator|++
expr_stmt|;
name|val
operator|=
operator|(
operator|-
name|val
operator|)
expr_stmt|;
block|}
name|tp
operator|=
name|tmp
expr_stmt|;
name|loop
label|:
name|knt
operator|++
expr_stmt|;
name|i
operator|=
name|val
operator|/
literal|10
expr_stmt|;
comment|/*  quotient& base 10 */
operator|(
operator|*
name|tp
operator|++
operator|)
operator|=
name|val
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
comment|/*  ascii remainder  */
name|val
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/*  done  dividing  */
if|if
condition|(
name|sign
condition|)
block|{
name|knt
operator|++
expr_stmt|;
operator|(
operator|*
name|tp
operator|++
operator|)
operator|=
literal|'-'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|knt
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|(
operator|*
name|rptr
operator|++
operator|)
operator|=
name|tmp
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|rptr
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|knt
operator|)
return|;
block|}
else|else
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|fexec
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Part of stand-alone programs that load programs into low core *  and execute them. *  This function : *	1) Checks if user specified file has a header - if so, *	   move start of exec. file down to 0. If file is 0410, *	   move data up to page boundary. *	2) Clear core. *	3) Jump to user task (calls). */
specifier|register
name|struct
name|thdr
modifier|*
name|hdp
decl_stmt|;
specifier|register
name|char
modifier|*
name|corep1
decl_stmt|,
modifier|*
name|corep2
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stxt
decl_stmt|,
name|sdat
decl_stmt|,
name|sbss
decl_stmt|,
name|clrmin
decl_stmt|;
specifier|register
name|char
modifier|*
name|clrmax
decl_stmt|;
name|hdp
operator|=
literal|0
expr_stmt|;
name|clrmax
operator|=
name|RELOC
operator|-
literal|0x400
expr_stmt|;
comment|/* last addr+1 to clear */
name|i
operator|=
name|hdp
operator|->
name|hmagic
expr_stmt|;
comment|/* task type code from task header */
name|entry
operator|=
literal|0
expr_stmt|;
comment|/* default entry addr if no header */
name|clrmin
operator|=
name|filsiz
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|!=
name|MAG410
operator|)
operator|&&
operator|(
name|i
operator|!=
name|MAG411
operator|)
condition|)
goto|goto
name|clrcor
goto|;
comment|/* NO HEADER */
comment|/* file has task header */
name|entry
operator|=
name|hdp
operator|->
name|hentry
operator|&
literal|017777777777
expr_stmt|;
name|stxt
operator|=
name|hdp
operator|->
name|htsiz
expr_stmt|;
comment|/* no. of text bytes in file */
name|sdat
operator|=
name|hdp
operator|->
name|hdsiz
expr_stmt|;
comment|/* no. data bytes */
name|sbss
operator|=
name|hdp
operator|->
name|hbsiz
expr_stmt|;
comment|/* no. bytes in bss area */
name|filsiz
operator|=
name|stxt
operator|+
name|sdat
expr_stmt|;
comment|/* file size = text + data */
name|clrmax
operator|=
name|filsiz
operator|+
name|sbss
expr_stmt|;
comment|/* new upper limit to clear */
comment|/*  move file down to loc 0 */
name|corep1
operator|=
literal|0
expr_stmt|;
name|corep2
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|thdr
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|filsiz
init|;
name|k
condition|;
name|k
operator|--
control|)
operator|(
operator|*
name|corep1
operator|++
operator|)
operator|=
operator|(
operator|*
name|corep2
operator|++
operator|)
expr_stmt|;
name|clrmin
operator|=
name|stxt
expr_stmt|;
comment|/* If 0410 file , move data up to page boundary */
if|if
condition|(
operator|(
name|i
operator|==
name|MAG410
operator|)
operator|&&
name|sdat
condition|)
block|{
comment|/*  0410  */
name|i
operator|=
name|corep2
operator|=
operator|(
operator|(
name|stxt
operator|+
literal|511
operator|)
operator|&
literal|017777777000
operator|)
expr_stmt|;
comment|/* page boundary */
name|corep2
operator|+=
name|sdat
expr_stmt|;
comment|/* end+1 of new data area */
name|corep1
operator|=
name|filsiz
expr_stmt|;
comment|/* end+1 of current data area */
for|for
control|(
name|k
operator|=
name|sdat
init|;
name|k
condition|;
name|k
operator|--
control|)
comment|/* move data up */
operator|*
operator|(
operator|--
name|corep2
operator|)
operator|=
operator|*
operator|(
operator|--
name|corep1
operator|)
expr_stmt|;
name|clrmax
operator|+=
operator|(
name|i
operator|-
name|stxt
operator|)
expr_stmt|;
comment|/* adjust upper limit for moved data */
name|clrmin
operator|=
name|i
operator|+
name|sdat
expr_stmt|;
block|}
comment|/*  clear  core  */
name|clrcor
label|:
for|for
control|(
name|corep1
operator|=
name|clrmin
init|;
name|corep1
operator|<
name|clrmax
condition|;
name|corep1
operator|++
control|)
operator|*
name|corep1
operator|=
literal|0
expr_stmt|;
comment|/*  execute  user  task  */
asm|asm("	.globl	_entry") ;
asm|asm("	calls	$0,*_entry") ;
comment|/*		*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|reloc
argument_list|()
end_macro

begin_block
block|{
extern|extern edata ;
specifier|register
name|int
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|,
name|i
decl_stmt|;
name|mtpr
argument_list|(
name|KSP
argument_list|,
name|RELOC
argument_list|)
expr_stmt|;
comment|/* set stack */
name|from
operator|=
literal|0
expr_stmt|;
name|to
operator|=
name|RELOC
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|edata
operator|-
name|RELOC
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
operator|(
sizeof|sizeof
expr|*
name|from
operator|)
control|)
operator|(
operator|*
name|to
operator|++
operator|)
operator|=
operator|(
operator|*
name|from
operator|++
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|l2x
argument_list|(
name|val
argument_list|,
name|rptr
argument_list|)
specifier|register
name|int
name|val
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|rptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|int
name|knt
decl_stmt|;
name|char
name|tmp
index|[
literal|20
index|]
decl_stmt|,
name|sign
decl_stmt|;
name|knt
operator|=
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|sign
operator|++
expr_stmt|;
name|val
operator|=
operator|(
operator|-
name|val
operator|)
expr_stmt|;
block|}
name|tp
operator|=
name|tmp
expr_stmt|;
name|loop
label|:
name|knt
operator|++
expr_stmt|;
name|i
operator|=
name|val
operator|/
literal|16
expr_stmt|;
comment|/*  quotient& base 16 */
name|j
operator|=
name|val
operator|%
literal|16
expr_stmt|;
operator|(
operator|*
name|tp
operator|++
operator|)
operator|=
name|j
operator|+
operator|(
name|j
operator|<
literal|10
condition|?
literal|0x30
else|:
literal|0x57
operator|)
expr_stmt|;
name|val
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
comment|/*  done  dividing  */
if|if
condition|(
name|sign
condition|)
block|{
name|knt
operator|++
expr_stmt|;
operator|(
operator|*
name|tp
operator|++
operator|)
operator|=
literal|'-'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|knt
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|(
operator|*
name|rptr
operator|++
operator|)
operator|=
name|tmp
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|rptr
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|knt
operator|)
return|;
block|}
else|else
goto|goto
name|loop
goto|;
block|}
end_block

end_unit

