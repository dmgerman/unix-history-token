begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"MBA.h"
end_include

begin_include
include|#
directive|include
file|"RP.h"
end_include

begin_include
include|#
directive|include
file|"CON.h"
end_include

begin_define
define|#
directive|define
name|LOW
parameter_list|(
name|i
parameter_list|)
value|((short)i)
end_define

begin_define
define|#
directive|define
name|HIGH
parameter_list|(
name|i
parameter_list|)
value|(i>>16)
end_define

begin_define
define|#
directive|define
name|BLKSIZ
value|512
end_define

begin_define
define|#
directive|define
name|BUFSIZ
value|((rpsec*BLKSIZ) + (rpsec*hdsiz))
end_define

begin_define
define|#
directive|define
name|MAXUNI
value|7
end_define

begin_comment
comment|/* max. no. units on MBA */
end_comment

begin_define
define|#
directive|define
name|MAXERR
value|20
end_define

begin_define
define|#
directive|define
name|MB_ERR
value|0x3080
end_define

begin_comment
comment|/*  normal error bits  */
end_comment

begin_define
define|#
directive|define
name|HDcoff
value|0
end_define

begin_define
define|#
directive|define
name|HDtoff
value|3
end_define

begin_decl_stmt
name|int
name|track
decl_stmt|,
name|cylndr
decl_stmt|,
name|dunit
decl_stmt|,
name|ecount
decl_stmt|,
name|daterr
decl_stmt|,
name|wcerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|badsec
decl_stmt|,
name|hdsiz
decl_stmt|,
name|dtype
decl_stmt|,
name|bsize
decl_stmt|,
name|bufsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|input
index|[
literal|132
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|RPptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to start of RP reg's for desired drive */
end_comment

begin_decl_stmt
name|int
modifier|*
name|Mptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to MBA reg set */
end_comment

begin_decl_stmt
name|int
name|rptrk
decl_stmt|,
name|rpcyl
decl_stmt|,
name|rpsec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|wcrflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ibuf
decl_stmt|,
modifier|*
name|obuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  buffer pointers */
end_comment

begin_decl_stmt
name|int
name|Offset
index|[]
init|=
block|{
comment|/*  Centerline offsets  */
literal|0
block|,
literal|0x08
block|,
literal|0x88
block|,
literal|0x10
block|,
literal|0x90
block|,
literal|0x18
block|,
literal|0x98
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
comment|/* *  Stand-alone program to format RP06/RM03 disk. *  User specifies disk unit. */
specifier|register
name|int
name|bb
decl_stmt|;
name|putlin
argument_list|(
literal|"format : Format RP06/RM03 Disk"
argument_list|)
expr_stmt|;
name|putnl
argument_list|()
expr_stmt|;
name|gmba
label|:
name|putstr
argument_list|(
literal|"MBA no. : "
argument_list|)
expr_stmt|;
name|getcon
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|dunit
operator|=
name|a2l
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|dunit
operator|<
literal|0
condition|)
goto|goto
name|fini
goto|;
if|if
condition|(
name|dunit
operator|>
name|MAXMBA
condition|)
goto|goto
name|gmba
goto|;
name|Mptr
operator|=
name|RPptr
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|M_BASE
operator|+
operator|(
name|dunit
operator|*
name|NEXSPC
operator|)
operator|)
expr_stmt|;
name|dun
label|:
name|putstr
argument_list|(
literal|"unit : "
argument_list|)
expr_stmt|;
name|getcon
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|dunit
operator|=
name|a2l
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|dunit
operator|<
literal|0
condition|)
goto|goto
name|fini
goto|;
if|if
condition|(
name|dunit
operator|>
name|MAXUNI
condition|)
goto|goto
name|dun
goto|;
if|if
condition|(
name|init
argument_list|()
condition|)
block|{
name|putlin
argument_list|(
literal|"init error"
argument_list|)
expr_stmt|;
goto|goto
name|dun
goto|;
block|}
name|bb
operator|=
name|bsize
operator|=
name|BUFSIZ
expr_stmt|;
for|for
control|(
name|cylndr
operator|=
literal|0
init|;
name|cylndr
operator|<
name|rpcyl
condition|;
name|cylndr
operator|++
control|)
block|{
for|for
control|(
name|track
operator|=
literal|0
init|;
name|track
operator|<
name|rptrk
condition|;
name|track
operator|++
control|)
block|{
if|if
condition|(
name|format
argument_list|(
literal|0
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|wcheck
argument_list|(
literal|0
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|trkinc
argument_list|()
expr_stmt|;
block|}
name|cylinc
argument_list|()
expr_stmt|;
name|trkclr
argument_list|()
expr_stmt|;
block|}
name|putnl
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"# Bad Sectors : "
argument_list|)
expr_stmt|;
name|l2x
argument_list|(
name|badsec
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"# Write Check errors : "
argument_list|)
expr_stmt|;
name|l2x
argument_list|(
name|wcerr
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"# Data Check errors : "
argument_list|)
expr_stmt|;
name|l2x
argument_list|(
name|daterr
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"# Other errors : "
argument_list|)
expr_stmt|;
name|l2x
argument_list|(
name|ecount
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|putnl
argument_list|()
expr_stmt|;
goto|goto
name|dun
goto|;
name|fini
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*		*/
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Initialization. *  Initialize MBA (disk) . *  Set up MBA  map register to map a  *    transfer of 'BUFSIZ' bytes. */
specifier|extern
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
modifier|*
name|mp0
decl_stmt|,
name|i
decl_stmt|,
name|page
decl_stmt|;
specifier|register
name|short
modifier|*
name|shp
decl_stmt|;
name|short
name|flg
decl_stmt|;
operator|*
operator|(
name|Mptr
operator|+
name|M_cr
operator|)
operator|=
name|MBAinit
expr_stmt|;
comment|/* MBA init */
comment|/*  start of RP reg's for drive */
comment|/*  get ptr. to RP ext reg set */
name|RPptr
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|RPptr
operator|+
operator|(
name|dunit
operator|*
name|EXTSIZ
operator|)
operator|+
name|M_extern
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|page
operator|=
operator|(
operator|*
operator|(
name|RPptr
operator|+
name|RP_sr
operator|)
operator|)
operator|)
operator|&
name|RP_MOL
operator|)
operator|==
literal|0
condition|)
block|{
name|putlin
argument_list|(
literal|"unit not online"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|page
operator|&
name|RP_WRL
condition|)
block|{
name|putlin
argument_list|(
literal|"unit write-protected"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_RIP
operator||
name|RP_GO
expr_stmt|;
comment|/* drive preset - sets vv */
name|dwait
argument_list|(
name|RPptr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|RPptr
operator|+
name|RP_off
operator|)
operator|=
name|RP_FMT
operator||
name|RP_ECI
expr_stmt|;
comment|/* set format and ECC inhibit */
name|i
operator|=
operator|*
operator|(
name|RPptr
operator|+
name|RP_dt
operator|)
operator|&
literal|0777
expr_stmt|;
comment|/* get disk type */
if|if
condition|(
name|i
operator|==
name|RP6typ
condition|)
block|{
comment|/* RP06 */
name|rpsec
operator|=
name|RP6SEC
expr_stmt|;
name|rpcyl
operator|=
name|RP6CYL
expr_stmt|;
name|rptrk
operator|=
name|RP6TRK
expr_stmt|;
name|hdsiz
operator|=
name|RP6HD
expr_stmt|;
name|dtype
operator|=
name|RP6typ
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|==
name|RM3typ
condition|)
block|{
name|rpsec
operator|=
name|RM3SEC
expr_stmt|;
name|rpcyl
operator|=
name|RM3CYL
expr_stmt|;
name|rptrk
operator|=
name|RM3TRK
expr_stmt|;
name|hdsiz
operator|=
name|RM3HD
expr_stmt|;
name|dtype
operator|=
name|RM3typ
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*  output buffer */
name|obuf
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
operator|(
name|int
operator|)
operator|&
name|end
operator|)
operator|+
literal|511
operator|)
operator|&
literal|017777777000
operator|)
expr_stmt|;
comment|/*  input buffer */
name|ibuf
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|obuf
operator|+
name|BUFSIZ
operator|+
literal|511
operator|)
operator|&
literal|017777777000
operator|)
expr_stmt|;
comment|/*  output buffer uses 1st 128 map reg's -   input buffer uses last 128 map reg's */
name|page
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|int
operator|)
name|obuf
operator|>>
literal|9
argument_list|)
operator|&
literal|017777777
expr_stmt|;
name|page
operator||=
literal|0x80000000
expr_stmt|;
name|mp0
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|Mptr
operator|+
call|(
name|int
call|)
argument_list|(
name|M_map
operator|*
literal|4
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|mp0
operator|++
operator|)
operator|=
name|page
operator|++
expr_stmt|;
name|page
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|int
operator|)
name|ibuf
operator|>>
literal|9
argument_list|)
operator|&
literal|017777777
expr_stmt|;
name|page
operator||=
literal|0x80000000
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|mp0
operator|++
operator|)
operator|=
name|page
operator|++
expr_stmt|;
comment|/*  initialize output buffer with sector header and data : 	4 sector header words : 		cylinder 		track/sector 		key word 1 (not on RM03) 		key word 2 (not on RM03) 	256 data words */
name|flg
operator|=
operator|(
name|dtype
operator|==
name|RM3typ
condition|?
name|RM_BSB
else|:
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|shp
operator|=
operator|(
name|short
operator|*
operator|)
name|obuf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rpsec
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|shp
operator|++
operator|)
operator|=
name|RP_FMT
operator||
name|flg
expr_stmt|;
operator|*
operator|(
name|shp
operator|++
operator|)
operator|=
name|i
expr_stmt|;
comment|/*  sect/trk  */
if|if
condition|(
name|dtype
operator|==
name|RP6typ
condition|)
block|{
operator|*
operator|(
name|shp
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|shp
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
literal|256
condition|;
name|page
operator|++
control|)
operator|(
operator|*
name|shp
operator|++
operator|)
operator|=
name|page
expr_stmt|;
block|}
name|ecount
operator|=
name|daterr
operator|=
name|wcerr
operator|=
name|badsec
operator|=
literal|0
expr_stmt|;
name|bufsiz
operator|=
name|BLKSIZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|rshd
argument_list|(
argument|baddr
argument_list|,
argument|nb
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|baddr
decl_stmt|,
name|nb
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Function to read 'nb' bytes into buffer pointed to *    by map and offset in 'baddr' - start at sector 's' */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
modifier|*
name|M
decl_stmt|,
modifier|*
name|R
decl_stmt|;
name|R
operator|=
name|RPptr
expr_stmt|;
name|M
operator|=
name|Mptr
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cyl
operator|)
operator|=
name|cylndr
expr_stmt|;
comment|/* cylinder no. */
operator|*
operator|(
name|R
operator|+
name|RP_stk
operator|)
operator|=
operator|(
name|track
operator|<<
literal|8
operator|)
operator||
name|s
expr_stmt|;
comment|/* track:sector */
operator|*
operator|(
name|M
operator|+
name|M_bc
operator|)
operator|=
operator|(
operator|-
name|nb
operator|)
expr_stmt|;
operator|*
operator|(
name|M
operator|+
name|M_var
operator|)
operator|=
name|baddr
expr_stmt|;
comment|/* virt addr reg = map no. + byte off */
name|rini
label|:
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_DC
operator||
name|RP_GO
expr_stmt|;
comment|/*  RP06 drive clear function code */
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_RHD
operator||
name|RP_GO
expr_stmt|;
comment|/* read sector header and data */
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
comment|/* wait for i/o to finish */
if|if
condition|(
name|i
operator|=
name|mbaerr
argument_list|(
name|M
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|=
name|derror
argument_list|(
name|R
argument_list|)
condition|)
block|{
comment|/* error */
name|putlin
argument_list|(
literal|"- - - - - - -"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"read SHD error"
argument_list|)
expr_stmt|;
name|stmes
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dadmes
argument_list|(
name|R
argument_list|)
expr_stmt|;
comment|/* return if any header errors */
if|if
condition|(
name|i
operator|&
operator|(
name|RP_HCRC
operator||
name|RP_HCE
operator||
name|RP_FER
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* error */
block|}
comment|/* normal return is to return header-error-free status */
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|hcheck
argument_list|(
name|insec
argument_list|,
name|ousec
argument_list|)
specifier|register
name|short
operator|*
name|insec
operator|,
operator|*
name|ousec
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* * Compare sector header and data info on disk against that which *  was written from output buffer */
specifier|register
name|int
name|j
decl_stmt|;
comment|/*  cyl and sect/track */
if|if
condition|(
operator|(
operator|(
operator|*
name|insec
operator|++
operator|)
operator|!=
operator|(
operator|*
name|ousec
operator|++
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|insec
operator|++
operator|)
operator|!=
operator|(
operator|*
name|ousec
operator|++
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* if RP06,  keywords */
if|if
condition|(
operator|(
name|dtype
operator|==
name|RP6typ
operator|)
operator|&&
operator|(
operator|(
operator|(
operator|*
name|insec
operator|++
operator|)
operator|!=
operator|(
operator|*
name|ousec
operator|++
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|insec
operator|++
operator|)
operator|!=
operator|(
operator|*
name|ousec
operator|++
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|insec
operator|++
operator|)
operator|!=
operator|(
operator|*
name|ousec
operator|++
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|format
argument_list|(
argument|baddr
argument_list|,
argument|nb
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|baddr
decl_stmt|,
name|nb
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Function to write 'nb' bytes worth of sector and data info *  from buffer whose map/offset is 'baddr' to disk. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
modifier|*
name|R
decl_stmt|,
modifier|*
name|M
decl_stmt|;
name|R
operator|=
name|RPptr
expr_stmt|;
name|M
operator|=
name|Mptr
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_DC
operator||
name|RP_GO
expr_stmt|;
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cyl
operator|)
operator|=
name|cylndr
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_stk
operator|)
operator|=
operator|(
name|track
operator|<<
literal|8
operator|)
operator||
name|s
expr_stmt|;
comment|/* sector : track */
operator|*
operator|(
name|M
operator|+
name|M_bc
operator|)
operator|=
operator|(
operator|-
name|nb
operator|)
expr_stmt|;
comment|/* byte count */
operator|*
operator|(
name|M
operator|+
name|M_var
operator|)
operator|=
name|baddr
expr_stmt|;
comment|/* virt addr reg = map no. + byte off */
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_WHD
operator||
name|RP_GO
expr_stmt|;
comment|/* write sector header and data */
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
comment|/* wait for i/o to finish */
if|if
condition|(
name|i
operator|=
name|mbaerr
argument_list|(
name|M
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|=
name|derror
argument_list|(
name|R
argument_list|)
condition|)
block|{
name|putlin
argument_list|(
literal|"- - - - - -"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"write SHD error"
argument_list|)
expr_stmt|;
name|stmes
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dadmes
argument_list|(
name|R
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcrflg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return if in 'write check' recovery */
if|if
condition|(
operator|++
name|ecount
operator|>
name|MAXERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* normal return */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|trkinc
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Increment track no. in output buffer sector headers. */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|hdsiz
operator|+
literal|512
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|obuf
init|;
name|i
operator|<
name|rpsec
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
name|j
control|)
name|sp
index|[
name|HDtoff
index|]
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|cylinc
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Increment cylinder no. in output buffer sector headers. */
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|hdsiz
operator|+
literal|512
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
name|obuf
init|;
name|i
operator|<
name|rpsec
condition|;
name|i
operator|++
operator|,
name|sp
operator|=
operator|(
name|short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|sp
operator|+
name|j
operator|)
control|)
name|sp
index|[
name|HDcoff
index|]
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|trkclr
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Clear track no. in output buffer sector headers. */
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|hdsiz
operator|+
literal|512
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|obuf
init|;
name|i
operator|<
name|rpsec
condition|;
name|i
operator|++
operator|,
name|sp
operator|+=
name|j
control|)
operator|*
operator|(
name|sp
operator|+
name|HDtoff
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|wcheck
argument_list|(
argument|baddr
argument_list|,
argument|nb
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|baddr
decl_stmt|,
name|nb
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Function to write check 'nb' bytes worth of sector and data info *  from buffer whose map reg is 'baddr' - start at sector 's'. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
modifier|*
name|R
decl_stmt|,
modifier|*
name|M
decl_stmt|;
name|R
operator|=
name|RPptr
expr_stmt|;
name|M
operator|=
name|Mptr
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_DC
operator||
name|RP_GO
expr_stmt|;
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cyl
operator|)
operator|=
name|cylndr
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_stk
operator|)
operator|=
operator|(
name|track
operator|<<
literal|8
operator|)
operator||
name|s
expr_stmt|;
comment|/* sector : track */
operator|*
operator|(
name|M
operator|+
name|M_bc
operator|)
operator|=
operator|(
operator|-
name|nb
operator|)
expr_stmt|;
comment|/* byte count */
operator|*
operator|(
name|M
operator|+
name|M_var
operator|)
operator|=
name|baddr
expr_stmt|;
comment|/* virt addr reg = map no. + byte off */
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_WCH
operator||
name|RP_GO
expr_stmt|;
comment|/* write check sector header and data */
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
comment|/* wait for i/o to finish */
if|if
condition|(
name|i
operator|=
name|mbaerr
argument_list|(
name|M
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|&
operator|(
name|M_WCKU
operator||
name|M_WCKL
operator|)
condition|)
block|{
comment|/* Write Check Error */
name|wcerr
operator|++
expr_stmt|;
name|putlin
argument_list|(
literal|"* Write Check Error *"
argument_list|)
expr_stmt|;
name|dadmes
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
operator|(
name|M
operator|+
name|M_bc
operator|)
operator||
literal|0xffff0000
expr_stmt|;
name|l2x
argument_list|(
name|nb
operator|+
name|i
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"no. bytes read : "
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcrflg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|wckrcv
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|=
name|derror
argument_list|(
name|R
argument_list|)
condition|)
block|{
name|putlin
argument_list|(
literal|"- - - - - -"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"write error"
argument_list|)
expr_stmt|;
name|stmes
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dadmes
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|ecount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ecount
operator|>
name|MAXERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* normal return */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|wckrcv
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Try to recover from a 'write check' error during a *  'Write Check Header and Data' function. *  'RPptr' is ptr to RP register set. *  'Mptr' is ptr to MBA reg set. *  MBA byte count reg has neg. no. bytes remaining - transfer stops *  on error, even in middle of a sector. *  Loop with a 'Write Sector Header and Data' followed by a 'Read *  Sector Header and Data' - each loop iteration uses a different head  *  centerline offset. *  If all fails, report irrecoverable error and finish off the *  'write check data and header' on the rest of the track. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|,
name|m
decl_stmt|;
name|wcrflg
operator|++
expr_stmt|;
comment|/*  flag says 'write check' recovery i-o is in progress */
comment|/* If no. bytes read thus far is a multiple of 'BLKSIZ+RPHEAD', then *  error was in last byte of sector and sector has to be backed up *  by 1. */
name|j
operator|=
name|curpos
argument_list|()
expr_stmt|;
comment|/* return current cyl , trk ,sector */
name|i
operator|=
operator|(
operator|(
operator|*
operator|(
name|Mptr
operator|+
name|M_bc
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|+
name|bsize
expr_stmt|;
comment|/*  no. bytes read by 'write check' */
if|if
condition|(
operator|(
name|i
operator|%
operator|(
name|BLKSIZ
operator|+
name|hdsiz
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|putlin
argument_list|(
literal|"wckrcv : backup 1 sector"
argument_list|)
expr_stmt|;
name|j
operator|=
name|backup
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|j
operator|&
literal|0x1f
expr_stmt|;
comment|/* sector only */
name|m
operator|=
name|j
operator|*
operator|(
name|BLKSIZ
operator|+
name|hdsiz
operator|)
expr_stmt|;
comment|/* page no. and offset */
comment|/* *  Loop with a 'Write Sector Header and Data' followed by a *  'Read Sector Header and Data' - each iteration uses a *  different centerline offset - 1st offset is 0. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|l
operator|=
name|Offset
index|[
name|i
index|]
operator|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
operator|*
operator|(
name|RPptr
operator|+
name|RP_off
operator|)
operator|&
literal|0xff00
expr_stmt|;
operator|*
operator|(
name|RPptr
operator|+
name|RP_off
operator|)
operator|=
name|k
operator||
name|l
expr_stmt|;
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_DC
operator||
name|RP_GO
expr_stmt|;
name|dwait
argument_list|(
name|RPptr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_OFF
operator||
name|RP_GO
expr_stmt|;
name|dwait
argument_list|(
name|RPptr
argument_list|)
expr_stmt|;
comment|/*  Format 1 sector */
if|if
condition|(
name|format
argument_list|(
name|m
argument_list|,
name|BLKSIZ
operator|+
name|hdsiz
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|putlin
argument_list|(
literal|"wckrcv: format error"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  Format was successful 	    Read sector. */
if|if
condition|(
name|rshd
argument_list|(
literal|128
operator|<<
literal|9
argument_list|,
name|BLKSIZ
operator|+
name|hdsiz
argument_list|,
name|j
argument_list|)
operator|<
literal|0
condition|)
block|{
name|putlin
argument_list|(
literal|"wckrcv: rshd() error"
argument_list|)
expr_stmt|;
continue|continue ;
block|}
comment|/*  successful 'Read Sector Header and Data' */
comment|/*  Compare sector written from output buffer 		against sector just read */
if|if
condition|(
name|hcheck
argument_list|(
name|ibuf
argument_list|,
name|obuf
operator|+
name|m
argument_list|)
condition|)
block|{
name|putlin
argument_list|(
literal|"wckrcv : sector compare failure"
argument_list|)
expr_stmt|;
continue|continue ;
block|}
comment|/*  good read and good compare */
name|putstr
argument_list|(
literal|"    head offset : "
argument_list|)
expr_stmt|;
name|l2x
argument_list|(
name|l
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|input
argument_list|)
expr_stmt|;
goto|goto
name|wckfin
goto|;
block|}
name|putlin
argument_list|(
literal|"wckrcv : bad sector"
argument_list|)
expr_stmt|;
name|badsec
operator|++
expr_stmt|;
name|wckfin
label|:
operator|*
operator|(
name|RPptr
operator|+
name|RP_cr
operator|)
operator|=
name|RP_RTC
operator||
name|RP_GO
expr_stmt|;
comment|/* return to centerline */
name|dwait
argument_list|(
name|RPptr
argument_list|)
expr_stmt|;
comment|/*  Cyl , trk and sector are set to values to continue where *  original 'Write Check Header and Data' left off */
name|j
operator|=
name|curpos
argument_list|()
operator|&
literal|0xff
expr_stmt|;
comment|/*  sector  */
name|wcrflg
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|*
operator|(
name|BLKSIZ
operator|+
name|hdsiz
operator|)
expr_stmt|;
comment|/* offset */
comment|/*  continue rest of 'wcheck89' */
name|wcheck
argument_list|(
name|i
argument_list|,
operator|(
name|rpsec
operator|-
name|j
operator|)
operator|*
operator|(
name|BLKSIZ
operator|+
name|hdsiz
operator|)
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|curpos
argument_list|()
end_macro

begin_block
block|{
comment|/* *  Function to return current cyl, trk and sector for RP whose *  register set is pointed to by 'RPptr'. */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|i
operator|=
operator|*
operator|(
name|RPptr
operator|+
name|RP_cyl
operator|)
operator|<<
literal|16
expr_stmt|;
name|j
operator|=
operator|*
operator|(
name|RPptr
operator|+
name|RP_stk
operator|)
operator|&
literal|0x1f1f
expr_stmt|;
return|return
operator|(
name|i
operator||
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|backup
argument_list|(
name|cts
argument_list|)
specifier|register
name|int
name|cts
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Function to backup 1 sector. *  Cyl, track and sector are in 'cts' . */
specifier|register
name|int
name|trk
decl_stmt|,
name|sec
decl_stmt|;
name|sec
operator|=
name|cts
operator|&
literal|0x1f
expr_stmt|;
comment|/*  sector */
if|if
condition|(
name|sec
operator|>
literal|0
condition|)
return|return
operator|(
operator|--
name|cts
operator|)
return|;
name|cts
operator|=
name|cts
operator|&
literal|0xffffff00
expr_stmt|;
name|cts
operator|=
name|cts
operator||
operator|(
name|rpsec
operator|-
literal|1
operator|)
expr_stmt|;
name|trk
operator|=
operator|(
name|cts
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
comment|/*  track */
if|if
condition|(
name|trk
operator|>
literal|0
condition|)
return|return
operator|(
name|cts
operator|-
literal|0x100
operator|)
return|;
comment|/*  dec track */
name|cts
operator|=
name|cts
operator|&
literal|0xffff00ff
expr_stmt|;
name|cts
operator|=
name|cts
operator||
operator|(
operator|(
name|rptrk
operator|-
literal|1
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|cts
operator|-
literal|0x10000
operator|)
return|;
comment|/*  dec cyl no.  */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_macro
name|dread
argument_list|(
argument|baddr
argument_list|,
argument|nb
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|baddr
decl_stmt|,
name|nb
decl_stmt|,
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* *  Function to read 'nb' bytes into buffer pointed to *    by map 'baddr' - start at sector 's'. */
specifier|register
name|int
name|i
decl_stmt|,
modifier|*
name|R
decl_stmt|,
modifier|*
name|M
decl_stmt|,
name|j
decl_stmt|;
name|R
operator|=
name|RPptr
expr_stmt|;
name|M
operator|=
name|Mptr
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cyl
operator|)
operator|=
name|cylndr
expr_stmt|;
comment|/* cylinder no. */
operator|*
operator|(
name|R
operator|+
name|RP_stk
operator|)
operator|=
operator|(
name|track
operator|<<
literal|8
operator|)
operator||
name|s
expr_stmt|;
comment|/* track:sector */
operator|*
operator|(
name|M
operator|+
name|M_bc
operator|)
operator|=
operator|(
operator|-
name|nb
operator|)
expr_stmt|;
operator|*
operator|(
name|M
operator|+
name|M_var
operator|)
operator|=
name|baddr
expr_stmt|;
comment|/* virt addr reg = map no. + byte off */
name|rini
label|:
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_DC
operator||
name|RP_GO
expr_stmt|;
comment|/*  RP06 drive clear function code */
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
operator|(
name|R
operator|+
name|RP_off
operator|)
operator|&
operator|(
operator|~
operator|(
name|RP_ECI
operator|)
operator|)
expr_stmt|;
comment|/* enable ECC */
operator|*
operator|(
name|R
operator|+
name|RP_off
operator|)
operator|=
name|i
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_cr
operator|)
operator|=
name|RP_RED
operator||
name|RP_GO
expr_stmt|;
comment|/* read */
name|dwait
argument_list|(
name|R
argument_list|)
expr_stmt|;
comment|/* wait for i/o to finish */
operator|*
operator|(
name|R
operator|+
name|RP_off
operator|)
operator|=
operator|*
operator|(
name|R
operator|+
name|RP_off
operator|)
operator||
name|RP_ECI
expr_stmt|;
comment|/* ECC inhibit on */
if|if
condition|(
name|i
operator|=
name|mbaerr
argument_list|(
name|M
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|=
name|derror
argument_list|(
name|R
argument_list|)
condition|)
block|{
comment|/* error */
name|putlin
argument_list|(
literal|"- - - - - - -"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"read error"
argument_list|)
expr_stmt|;
name|stmes
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|dadmes
argument_list|(
name|R
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcrflg
condition|)
if|if
condition|(
name|i
operator|&
operator|(
name|RP_HCE
operator||
name|RP_HCRC
operator||
name|RP_FER
operator||
name|RP_PAR
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|i
operator|&
operator|(
operator|~
operator|(
name|RP_DCK
operator|)
operator|)
condition|)
block|{
name|ecount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|RP_DCK
condition|)
block|{
comment|/* Data Check Error */
name|daterr
operator|++
expr_stmt|;
name|putlin
argument_list|(
literal|"* Data Check *"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|RP_ECH
condition|)
block|{
comment|/* ECC Hard Error */
name|putlin
argument_list|(
literal|"ECC non-recov"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcrflg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ecount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* ECC recoverable */
name|ECCrcv
argument_list|(
name|R
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|M
operator|+
name|M_bc
operator|)
condition|)
block|{
comment|/* more i-o to complete */
name|j
operator|=
operator|(
operator|*
operator|(
name|R
operator|+
name|RP_stk
operator|)
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|j
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|j
operator|=
name|j
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|rpsec
condition|)
comment|/*sector */
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|rptrk
condition|)
comment|/* track */
name|i
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|R
operator|+
name|RP_stk
operator|)
operator|=
operator|(
name|i
operator|<<
literal|8
operator|)
operator||
name|j
expr_stmt|;
goto|goto
name|rini
goto|;
comment|/* status reg cleared by Drive Clear */
block|}
block|}
if|if
condition|(
name|wcrflg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ecount
operator|>
name|MAXERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* normal return */
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|ECCrcv
argument_list|(
name|dptr
argument_list|)
specifier|register
name|int
operator|*
name|dptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* *  Do ECC error recovery on disk whose register set is pointed *  to by 'dptr'. *  'mbaerr()' has cleared MBA status reg. *  With ECC enabled, disk read has stopped after sector with bad *  data. After correction of data, return to read routine which will *  continue read of track if more sectors to do. *  Return 0. */
specifier|register
name|unsigned
name|int
name|pos
decl_stmt|,
name|pat
decl_stmt|,
name|ll
decl_stmt|;
specifier|register
name|unsigned
name|short
modifier|*
name|wordp
decl_stmt|;
struct|struct
name|www
block|{
union|union
block|{
name|int
name|x123
decl_stmt|;
name|short
name|wlo
decl_stmt|,
name|whi
decl_stmt|;
block|}
name|sss
union|;
block|}
struct|;
name|char
name|tmp
index|[
literal|50
index|]
decl_stmt|;
name|pat
operator|=
operator|(
operator|*
operator|(
name|dptr
operator|+
name|RP_Epat
operator|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* ECC pattern reg */
name|pos
operator|=
operator|(
operator|*
operator|(
name|dptr
operator|+
name|RP_Epos
operator|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* ECC position reg */
name|putstr
argument_list|(
literal|"pat : "
argument_list|)
expr_stmt|;
name|ul2x
argument_list|(
name|pat
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"pos : "
argument_list|)
expr_stmt|;
name|ul2x
argument_list|(
name|pos
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|wordp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|ibuf
expr_stmt|;
comment|/* ptr to input buffer */
comment|/* *  'bufsiz' bytes are read on each read into buffer pointed to *  by 'ibuf'. MBA byte count reg has neg. no. of bytes remaining *  in read if this read error was not in the last sector to be *  read. */
comment|/* calculate buffer location of faulty data */
name|wordp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|wordp
operator|+
operator|(
name|bufsiz
operator|+
operator|(
operator|(
operator|*
operator|(
name|Mptr
operator|+
name|M_bc
operator|)
operator|)
operator|>>
literal|16
operator|)
operator|-
name|BLKSIZ
operator|)
operator|)
expr_stmt|;
comment|/* sector in buffer */
name|wordp
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|wordp
operator|+
operator|(
operator|(
name|pos
operator|-
literal|1
operator|)
operator|>>
literal|4
operator|)
operator|)
expr_stmt|;
comment|/* word within sector */
comment|/* burst pattern may be across word boundary */
name|ll
operator|=
operator|(
operator|*
name|wordp
operator|)
operator|+
operator|(
operator|(
operator|*
operator|(
name|wordp
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|putstr
argument_list|(
literal|"bad data  : "
argument_list|)
expr_stmt|;
name|ul2x
argument_list|(
name|ll
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|pat
operator|=
name|pat
operator|<<
operator|(
operator|(
name|pos
operator|%
literal|16
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|ll
operator|=
name|ll
operator|^
name|pat
expr_stmt|;
comment|/* correction */
name|putstr
argument_list|(
literal|"good data : "
argument_list|)
expr_stmt|;
name|ul2x
argument_list|(
name|ll
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|putlin
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* put good data back in buffer */
operator|*
name|wordp
operator|=
name|LOW
argument_list|(
name|ll
argument_list|)
expr_stmt|;
operator|*
operator|(
name|wordp
operator|+
literal|1
operator|)
operator|=
name|HIGH
argument_list|(
name|ll
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		*/
end_comment

begin_expr_stmt
name|mbaerr
argument_list|(
name|mba
argument_list|)
specifier|register
name|int
operator|*
name|mba
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|=
operator|(
operator|*
operator|(
name|mba
operator|+
name|M_sr
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0x2000
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|i
operator|!=
name|MB_ERR
condition|)
block|{
name|putlin
argument_list|(
literal|"- - - - - -"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"MBA error"
argument_list|)
expr_stmt|;
name|stmes
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mba
operator|+
name|M_sr
operator|)
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

