begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"%W% (Berkeley/CCI) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * C object code improver-- third part  */
end_comment

begin_include
include|#
directive|include
file|"c2.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_macro
name|rmove
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|r1
decl_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"Regs: "
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<=
name|NREG
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
condition|)
block|{
name|r1
operator|=
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%d: %d%d %s\n"
argument_list|,
name|r
argument_list|,
name|r1
operator|&
literal|0xF
argument_list|,
name|r1
operator|>>
literal|4
argument_list|,
name|regs
index|[
name|r
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"-\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|CVT
case|:
case|case
name|MOVZ
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
expr_stmt|;
name|r1
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
name|r1
operator|>=
literal|0
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|MOV
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
goto|goto
name|case_mov
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CVT
condition|)
block|{
if|if
condition|(
name|r1
operator|>=
literal|0
condition|)
name|savereg
argument_list|(
name|r1
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
block|}
else|else
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MOV
case|:
name|case_mov
label|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|findrand
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|TST
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|->
name|code
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|redunm
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
goto|goto
name|case_tst
goto|;
block|}
block|}
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|)
expr_stmt|;
name|r1
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
operator|)
operator|&&
name|equstr
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|regs
index|[
name|ACC
index|]
operator|+
literal|1
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|ACC
index|]
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|r1
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|r1
operator|&&
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|redunm
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
condition|)
name|savereg
argument_list|(
name|r1
argument_list|,
name|regs
index|[
name|r
index|]
operator|+
literal|1
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
block|}
else|else
name|savereg
argument_list|(
name|r
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r1
operator|>=
literal|0
condition|)
name|savereg
argument_list|(
name|r1
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
else|else
name|setcon
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
break|break;
comment|/* .rx,.wx or .rx,.rx,.wx */
case|case
name|ADD
case|:
case|case
name|SUB
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|XOR
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
ifdef|#
directive|ifdef
name|EMOD
case|case
name|EDIV
case|:
case|case
name|EMOD
case|:
endif|#
directive|endif
endif|EMOD
case|case
name|SHAL
case|:
case|case
name|SHAR
case|:
case|case
name|SHL
case|:
case|case
name|SHR
case|:
case|case
name|ADDA
case|:
case|case
name|SUBA
case|:
comment|/* .rx,.wx */
case|case
name|MFPR
case|:
case|case
name|COM
case|:
case|case
name|NEG
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|lastrand
argument_list|,
name|p
operator|->
name|subop
argument_list|,
name|p
operator|->
name|op
operator|!=
name|ADDA
operator|&&
name|p
operator|->
name|op
operator|!=
name|SUBA
argument_list|)
expr_stmt|;
break|break;
comment|/* .mx or .wx */
case|case
name|STF
case|:
if|if
condition|(
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|regs
index|[
name|ACC
index|]
operator|+
literal|1
argument_list|)
operator|&&
name|p
operator|->
name|subop
operator|==
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nst
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
break|break;
block|}
name|savereg
argument_list|(
name|ACC
argument_list|,
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
case|case
name|INC
case|:
case|case
name|DEC
case|:
case|case
name|CVFL
case|:
name|dest
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|subop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLR
case|:
name|dest
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|subop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
operator|)
operator|&&
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|regs
index|[
name|ACC
index|]
operator|+
literal|1
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|ACC
index|]
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|p
operator|->
name|code
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|setcon
argument_list|(
literal|"$0"
argument_list|,
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
else|else
name|savereg
argument_list|(
name|r
argument_list|,
literal|"$0"
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
break|break;
comment|/* .rx */
case|case
name|LDF
case|:
if|if
condition|(
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|regs
index|[
name|ACC
index|]
operator|+
literal|1
argument_list|)
operator|&&
name|p
operator|->
name|subop
operator|==
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nld
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
break|break;
block|}
name|savereg
argument_list|(
name|ACC
argument_list|,
name|p
operator|->
name|code
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
goto|goto
name|case_tst
goto|;
case|case
name|LNF
case|:
if|if
condition|(
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|regs
index|[
name|ACC
index|]
operator|+
literal|1
argument_list|)
operator|&&
name|p
operator|->
name|subop
operator|==
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|NEGF
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|CVLF
case|:
case|case
name|LDFD
case|:
case|case
name|ADDF
case|:
case|case
name|SUBF
case|:
case|case
name|MULF
case|:
case|case
name|DIVF
case|:
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
case|case
name|TST
case|:
name|case_tst
label|:
case|case
name|PUSH
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT1
operator|+
literal|1
index|]
expr_stmt|;
comment|/* fool repladdr into doing 1 operand */
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|TST
operator|&&
name|equstr
argument_list|(
name|lastrand
argument_list|,
name|ccloc
operator|+
literal|1
argument_list|)
operator|&&
operator|(
operator|(
literal|0xf
operator|&
operator|(
name|ccloc
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|)
operator|==
name|p
operator|->
name|subop
operator|||
name|equtype
argument_list|(
name|ccloc
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|)
operator|)
condition|)
block|{
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nrtst
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PUSH
operator|&&
name|p
operator|->
name|subop
operator|!=
name|LONG
operator|&&
operator|(
name|isreg
argument_list|(
name|lastrand
argument_list|)
operator|>=
literal|0
operator|||
operator|*
name|lastrand
operator|==
literal|'$'
operator|)
condition|)
block|{
name|p
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|TST
operator|||
name|p
operator|->
name|op
operator|==
name|PUSH
condition|)
name|setcc
argument_list|(
name|lastrand
argument_list|,
name|p
operator|->
name|subop
argument_list|)
expr_stmt|;
break|break;
comment|/* .rx,.rx,.rx */
case|case
name|PROBE
case|:
case|case
name|CASE
case|:
comment|/* .rx,.rx */
case|case
name|MTPR
case|:
case|case
name|CALLS
case|:
case|case
name|CALLF
case|:
case|case
name|CMP
case|:
case|case
name|BIT
case|:
case|case
name|CMPF
case|:
case|case
name|CMPF2
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* fool repladdr into doing right number of operands */
name|lastrand
operator|=
name|byondrd
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CALLF
operator|||
name|p
operator|->
name|op
operator|==
name|CALLS
condition|)
name|clearreg
argument_list|()
expr_stmt|;
else|else
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
case|case
name|TSTF
case|:
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
case|case
name|PUSHD
case|:
break|break;
comment|/* acc only */
case|case
name|CVDF
case|:
case|case
name|NEGF
case|:
case|case
name|SINF
case|:
case|case
name|COSF
case|:
case|case
name|ATANF
case|:
case|case
name|LOGF
case|:
case|case
name|SQRTF
case|:
case|case
name|EXPF
case|:
name|regs
index|[
name|ACC
index|]
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|EMOD
comment|/* .rx,.rx,.wx,.wx */
case|case
name|EDIV
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|regs
index|[
name|RT4
index|]
argument_list|,
name|p
operator|->
name|subop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|EMOD
comment|/* .rx,.rx,.rx,wx */
case|case
name|EMUL
case|:
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT4
index|]
expr_stmt|;
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dest
argument_list|(
name|regs
index|[
name|RT4
index|]
argument_list|,
name|QUAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* fourth operand is a quad */
break|break;
case|case
name|CBR
case|:
if|if
condition|(
name|p
operator|->
name|subop
operator|>=
name|JBC
condition|)
block|{
name|splitrand
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lastrand
operator|=
name|regs
index|[
name|RT3
index|]
expr_stmt|;
comment|/* 2 operands can be optimized */
name|repladdr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|reduncbr
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|JBR
case|:
name|redunbr
argument_list|(
name|p
argument_list|)
expr_stmt|;
default|default:
name|clearreg
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|jumpsw
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|,
name|nj
decl_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
name|nj
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
name|p
operator|->
name|seq
operator|=
operator|++
name|t
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p1
control|)
block|{
name|p1
operator|=
name|p
operator|->
name|forw
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CBR
operator|&&
name|p1
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p
operator|->
name|ref
operator|&&
name|p1
operator|->
name|ref
operator|&&
name|abs
argument_list|(
name|p
operator|->
name|seq
operator|-
name|p
operator|->
name|ref
operator|->
name|seq
argument_list|)
operator|>
name|abs
argument_list|(
name|p1
operator|->
name|seq
operator|-
name|p1
operator|->
name|ref
operator|->
name|seq
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|p1
operator|->
name|ref
condition|)
continue|continue;
name|p
operator|->
name|subop
operator|=
name|revbr
index|[
name|p
operator|->
name|subop
index|]
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|pt
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p1
operator|->
name|ref
operator|=
name|p
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|pt
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|labno
operator|=
name|p
operator|->
name|labno
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|t
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
if|if
condition|(
name|p
operator|->
name|labno
operator|==
literal|0
condition|)
block|{
name|pt
operator|=
operator|(
expr|struct
name|node
operator|*
operator|)
name|p1
operator|->
name|code
expr_stmt|;
name|p1
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|p
operator|->
name|code
operator|=
operator|(
name|char
operator|*
operator|)
name|pt
expr_stmt|;
block|}
endif|#
directive|endif
name|nrevbr
operator|++
expr_stmt|;
name|nj
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nj
operator|)
return|;
block|}
end_block

begin_macro
name|addaob
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|first
init|;
operator|(
name|p1
operator|=
name|p
operator|->
name|forw
operator|)
operator|!=
literal|0
condition|;
name|p
operator|=
name|p1
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|INC
operator|&&
name|p
operator|->
name|subop
operator|==
name|LONG
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p1
operator|->
name|refc
operator|==
literal|1
operator|&&
name|p1
operator|->
name|forw
operator|->
name|op
operator|==
name|CMP
operator|&&
name|p1
operator|->
name|forw
operator|->
name|subop
operator|==
name|LONG
operator|&&
operator|(
name|p2
operator|=
name|p1
operator|->
name|forw
operator|->
name|forw
operator|)
operator|->
name|op
operator|==
name|CBR
operator|&&
name|p2
operator|->
name|subop
operator|==
name|JLE
operator|&&
operator|(
name|p3
operator|=
name|p2
operator|->
name|ref
operator|->
name|back
operator|)
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p3
operator|->
name|subop
operator|==
literal|0
operator|&&
name|p3
operator|->
name|ref
operator|==
name|p1
operator|&&
name|p3
operator|->
name|forw
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p3
operator|->
name|forw
operator|==
name|p2
operator|->
name|ref
condition|)
block|{
comment|/* change	INC LAB: CMP	to	LAB: INC CMP */
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|forw
expr_stmt|;
comment|/* adjust beginning value by 1 */
name|p2
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p2
operator|->
name|op
operator|=
name|DEC
expr_stmt|;
name|p2
operator|->
name|subop
operator|=
name|LONG
expr_stmt|;
name|p2
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p2
operator|->
name|forw
operator|=
name|p3
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|p3
operator|->
name|back
expr_stmt|;
name|p3
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p3
operator|->
name|back
operator|=
name|p2
expr_stmt|;
name|p2
operator|->
name|code
operator|=
name|p
operator|->
name|code
expr_stmt|;
name|p2
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|CMP
operator|&&
name|p1
operator|->
name|subop
operator|==
name|LONG
operator|&&
operator|(
name|p2
operator|=
name|p1
operator|->
name|forw
operator|)
operator|->
name|op
operator|==
name|CBR
operator|&&
name|p2
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equstr
argument_list|(
name|p
operator|->
name|code
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p2
operator|->
name|subop
operator|==
name|JLE
operator|||
name|p2
operator|->
name|subop
operator|==
name|JLT
operator|)
operator|&&
name|checkaobdisp
argument_list|(
name|p2
argument_list|)
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|subop
operator|==
name|JLE
condition|)
name|p
operator|->
name|op
operator|=
name|AOBLEQ
expr_stmt|;
else|else
name|p
operator|->
name|op
operator|=
name|AOBLSS
expr_stmt|;
name|p
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
name|cp2
operator|=
name|regs
index|[
name|RT1
index|]
expr_stmt|;
name|cp1
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* limit */
name|cp2
operator|=
name|regs
index|[
name|RT2
index|]
expr_stmt|;
name|cp1
operator|=
name|p
operator|->
name|code
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
comment|/* index */
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p2
operator|->
name|labno
expr_stmt|;
name|delnode
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|delnode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|naob
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
name|ispow2
argument_list|(
name|n
argument_list|)
specifier|register
name|long
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* -1 -> no; else -> log to base 2 */
specifier|register
name|int
name|log
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|log
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|log
operator|)
return|;
operator|++
name|log
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|log
operator|)
return|;
block|}
block|}
end_block

begin_expr_stmt
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|p2
operator|->
name|op
operator|||
name|p1
operator|->
name|subop
operator|!=
name|p2
operator|->
name|subop
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|NIL
operator|&&
name|ord
argument_list|(
name|p1
operator|->
name|op
argument_list|)
operator|<
name|ord
argument_list|(
name|MOV
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|p1
operator|->
name|labno
operator|!=
name|p2
operator|->
name|labno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp1
operator|=
name|p1
operator|->
name|code
expr_stmt|;
name|cp2
operator|=
name|p2
operator|->
name|code
expr_stmt|;
if|if
condition|(
name|cp1
operator|==
literal|0
operator|&&
name|cp2
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cp1
operator|==
literal|0
operator|||
name|cp2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|cp1
operator|==
operator|*
name|cp2
operator|++
condition|)
if|if
condition|(
operator|*
name|cp1
operator|++
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|delnode
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|decref
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|&&
operator|--
name|p
operator|->
name|refc
operator|<=
literal|0
condition|)
block|{
name|nrlab
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|node
modifier|*
name|nonlab
parameter_list|(
name|ap
parameter_list|)
name|struct
name|node
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|->
name|op
operator|==
name|LABEL
condition|)
name|p
operator|=
name|p
operator|->
name|forw
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|clearuse
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
modifier|*
name|i
decl_stmt|;
specifier|register
name|short
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
name|uses
operator|+
name|NREG
init|;
name|i
operator|>
name|uses
condition|;
control|)
operator|*
operator|--
name|i
operator|=
literal|0
expr_stmt|;
name|useacc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|usecnt
operator|+
name|NUSE
init|;
name|p
operator|>
name|usecnt
condition|;
control|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|clearreg
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regs
operator|+
name|NREG
operator|+
literal|1
init|;
name|i
operator|>
name|regs
condition|;
control|)
block|{
operator|*
operator|*
operator|--
name|i
operator|=
literal|0
expr_stmt|;
operator|*
operator|*
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|conloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|savereg
argument_list|(
name|ai
argument_list|,
name|s
argument_list|,
name|type
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|p
operator|=
name|regs
index|[
name|ai
index|]
expr_stmt|;
comment|/* if any indexing, must be parameter or local */
comment|/* indirection (as in "*-4(fp)") is ok, however */
operator|*
name|p
operator|++
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
operator|||
operator|*
name|s
operator|==
literal|'$'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|natural
argument_list|(
name|s
argument_list|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|dest
argument_list|(
name|s
argument_list|,
name|type
argument_list|,
name|ccflg
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|isreg
argument_list|(
name|s
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* if register destination, that reg is a goner */
if|if
condition|(
name|DOUBLE
operator|==
operator|(
name|type
operator|&
literal|0xF
operator|)
operator|||
name|DOUBLE
operator|==
operator|(
operator|(
name|type
operator|>>
literal|4
operator|)
operator|&
literal|0xF
operator|)
operator|||
name|type
operator|==
name|QUAD
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|NREG
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|equstr
argument_list|(
name|s
argument_list|,
name|regs
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* previous indirection through destination is invalid */
while|while
condition|(
operator|(
name|i
operator|=
name|findrand
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
comment|/* previous values of destination are invalid */
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|natural
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* wild store, everything except constants vanishes */
for|for
control|(
name|i
operator|=
name|NREG
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|regs
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|'$'
condition|)
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|regs
index|[
name|i
index|]
operator|)
operator|=
literal|0
expr_stmt|;
name|conloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ccflg
condition|)
name|setcc
argument_list|(
name|s
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* natural destinations set condition codes */
if|if
condition|(
name|equstr
argument_list|(
name|s
argument_list|,
name|conloc
argument_list|)
condition|)
name|conloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|splitrand
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* separate operands at commas, set up 'regs' and 'lastrand' */
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|preg
decl_stmt|;
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
if|if
condition|(
name|p1
operator|=
name|p
operator|->
name|code
condition|)
while|while
condition|(
operator|*
name|p1
condition|)
block|{
name|lastrand
operator|=
name|p2
operator|=
operator|*
name|preg
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p1
condition|)
if|if
condition|(
literal|','
operator|==
operator|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
operator|)
condition|)
block|{
operator|--
name|p2
expr_stmt|;
break|break;
block|}
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|preg
operator|<
operator|(
name|regs
operator|+
name|RT1
operator|+
literal|5
operator|)
condition|)
operator|*
operator|(
operator|*
name|preg
operator|++
operator|)
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|compat
argument_list|(
name|have
argument_list|,
name|want
argument_list|)
specifier|register
name|int
name|have
operator|,
name|want
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|hsrc
decl_stmt|,
name|hdst
decl_stmt|;
specifier|extern
name|int
name|bitsize
index|[]
decl_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|want
operator|&=
literal|0xF
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* anything satisfies a wildcard want */
name|hsrc
operator|=
name|have
operator|&
literal|0xF
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|hdst
operator|=
operator|(
operator|(
name|have
operator|>>
literal|4
operator|)
operator|&
literal|0xF
operator|)
operator|)
operator|||
name|hdst
operator|>=
name|OP2
condition|)
name|hdst
operator|=
name|hsrc
expr_stmt|;
if|if
condition|(
name|want
operator|>=
name|QUAD
condition|)
return|return
operator|(
name|bitsize
index|[
name|hdst
index|]
operator|==
name|bitsize
index|[
name|want
index|]
operator|&&
name|bitsize
index|[
name|hsrc
index|]
operator|==
name|bitsize
index|[
name|want
index|]
operator|)
return|;
return|return
operator|(
name|hsrc
operator|==
name|want
operator|&&
name|hdst
operator|>=
name|want
operator|&&
name|hdst
operator|<
name|QUAD
operator|)
return|;
block|}
end_block

begin_macro
name|equtype
argument_list|(
argument|t1
argument_list|,
argument|t2
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|compat
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|&&
name|compat
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|findrand
argument_list|(
argument|as
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|as
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regs
operator|+
name|NREG
init|;
operator|--
name|i
operator|>=
name|regs
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|i
operator|&&
name|equstr
argument_list|(
operator|*
name|i
operator|+
literal|1
argument_list|,
name|as
argument_list|)
operator|&&
name|compat
argument_list|(
operator|*
operator|*
name|i
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|i
operator|-
name|regs
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|isreg
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'r'
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
return|return
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'1'
operator|&&
name|isdigit
argument_list|(
operator|*
name|s
operator|++
argument_list|)
operator|&&
operator|*
name|s
operator|==
literal|0
condition|)
return|return
operator|(
literal|10
operator|+
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* check() { 	register struct node *p, *lp;  	lp =&first; 	for (p=first.forw; p!=0; p = p->forw) { 		if (p->back != lp) 			abort(-1); 		lp = p; 	} } */
end_comment

begin_macro
name|newcode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
modifier|*
name|preg
decl_stmt|;
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
name|p2
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|p1
operator|=
operator|*
name|preg
operator|++
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
operator|*
operator|(
name|p2
operator|-
literal|1
operator|)
operator|=
literal|','
expr_stmt|;
block|}
operator|*
operator|--
name|p2
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|repladdr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|preg
decl_stmt|;
specifier|register
name|int
name|nrepl
decl_stmt|;
name|preg
operator|=
name|regs
operator|+
name|RT1
expr_stmt|;
name|nrepl
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lastrand
operator|!=
operator|(
name|p1
operator|=
operator|*
name|preg
operator|++
operator|)
condition|)
if|if
condition|(
literal|0
operator|<=
operator|(
name|r
operator|=
name|findrand
argument_list|(
name|p1
argument_list|,
name|p
operator|->
name|subop
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p1
operator|++
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|9
condition|)
block|{
operator|*
name|p1
operator|++
operator|=
literal|'1'
expr_stmt|;
name|r
operator|-=
literal|10
expr_stmt|;
block|}
operator|*
name|p1
operator|++
operator|=
name|r
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p1
operator|=
literal|0
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|nrepl
operator|++
expr_stmt|;
name|nsaddr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nrepl
condition|)
name|newcode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* conditional branches which are never/always taken */
end_comment

begin_expr_stmt
name|reduncbr
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap1
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
name|p1
operator|=
name|p
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|CMP
condition|)
block|{
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|ap1
operator|=
name|findcon
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
name|ap2
operator|=
name|findcon
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ccloc
index|[
literal|0
index|]
condition|)
return|return;
name|ap1
operator|=
name|findcon
argument_list|(
name|ccloc
operator|+
literal|1
argument_list|,
name|ccloc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ap2
operator|=
literal|"$0"
expr_stmt|;
block|}
switch|switch
condition|(
name|compare
argument_list|(
name|p
operator|->
name|subop
argument_list|,
name|ap1
argument_list|,
name|ap2
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* branch never taken */
name|delnode
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nredunj
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|forw
operator|->
name|op
operator|!=
name|CBR
operator|&&
operator|(
name|p1
operator|->
name|op
operator|==
name|TST
operator|||
name|p1
operator|->
name|op
operator|==
name|CMP
operator|)
condition|)
block|{
name|delnode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nrtst
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* branch always taken */
name|p
operator|->
name|op
operator|=
name|JBR
expr_stmt|;
name|p
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
if|if
condition|(
name|nonlab
argument_list|(
name|p
operator|->
name|ref
argument_list|)
operator|->
name|op
operator|!=
name|CBR
operator|&&
operator|(
name|p1
operator|->
name|op
operator|==
name|TST
operator|||
name|p1
operator|->
name|op
operator|==
name|CMP
operator|)
condition|)
block|{
name|delnode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|nrtst
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* a jump to a redundant compare (start of a 'for') */
end_comment

begin_expr_stmt
name|redunbr
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap1
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
name|p
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return;
name|p1
operator|=
name|nonlab
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|TST
operator|||
name|p1
operator|->
name|op
operator|==
name|CMP
condition|)
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|p1
operator|->
name|forw
operator|->
name|op
operator|==
name|CBR
condition|)
block|{
name|ap1
operator|=
name|findcon
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|TST
condition|)
name|ap2
operator|=
literal|"$0"
expr_stmt|;
else|else
name|ap2
operator|=
name|findcon
argument_list|(
name|regs
index|[
name|RT2
index|]
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|p1
operator|->
name|subop
argument_list|,
name|ap1
argument_list|,
name|ap2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|nredunj
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
if|if
condition|(
name|p
operator|->
name|labno
operator|==
literal|0
condition|)
name|p
operator|->
name|code
operator|=
name|p1
operator|->
name|code
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ref
condition|)
endif|#
directive|endif
name|p
operator|->
name|ref
operator|->
name|refc
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|TST
operator|&&
name|equstr
argument_list|(
name|regs
index|[
name|RT1
index|]
argument_list|,
name|ccloc
operator|+
literal|1
argument_list|)
operator|&&
name|equtype
argument_list|(
name|ccloc
index|[
literal|0
index|]
argument_list|,
name|p1
operator|->
name|subop
argument_list|)
condition|)
block|{
name|p1
operator|=
name|insertl
argument_list|(
name|p1
operator|->
name|forw
argument_list|)
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
expr_stmt|;
name|nrtst
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|findcon
parameter_list|(
name|p
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|p
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|compat
argument_list|(
name|regs
index|[
name|r
index|]
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|regs
index|[
name|r
index|]
operator|+
literal|1
operator|)
return|;
if|if
condition|(
name|equstr
argument_list|(
name|p
argument_list|,
name|conloc
argument_list|)
operator|&&
name|equtype
argument_list|(
name|conloc
index|[
literal|0
index|]
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|(
name|conval
operator|+
literal|1
operator|)
return|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare constants: 0 - branch taken; 1 - not taken; -1 - don't know */
end_comment

begin_macro
name|compare
argument_list|(
argument|op
argument_list|,
argument|acp1
argument_list|,
argument|acp2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp1
decl_stmt|,
modifier|*
name|acp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|sign
decl_stmt|;
name|cp1
operator|=
name|acp1
expr_stmt|;
name|cp2
operator|=
name|acp2
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|'$'
operator|||
operator|*
name|cp2
operator|++
operator|!=
literal|'$'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n1
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'-'
condition|)
block|{
operator|++
name|cp1
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp1
argument_list|)
condition|)
block|{
name|n1
operator|*=
literal|10
expr_stmt|;
name|n1
operator|+=
operator|*
name|cp1
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
name|n1
operator|*=
name|sign
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'-'
condition|)
block|{
operator|++
name|cp2
expr_stmt|;
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp2
argument_list|)
condition|)
block|{
name|n2
operator|*=
literal|10
expr_stmt|;
name|n2
operator|+=
operator|*
name|cp2
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
name|n2
operator|*=
name|sign
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'+'
condition|)
name|cp1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'+'
condition|)
name|cp2
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|cp2
operator|++
condition|)
do|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|JEQ
case|:
return|return
operator|(
name|n1
operator|==
name|n2
operator|)
return|;
case|case
name|JNE
case|:
return|return
operator|(
name|n1
operator|!=
name|n2
operator|)
return|;
case|case
name|JLE
case|:
return|return
operator|(
name|n1
operator|<=
name|n2
operator|)
return|;
case|case
name|JGE
case|:
return|return
operator|(
name|n1
operator|>=
name|n2
operator|)
return|;
case|case
name|JLT
case|:
return|return
operator|(
name|n1
operator|<
name|n2
operator|)
return|;
case|case
name|JGT
case|:
return|return
operator|(
name|n1
operator|>
name|n2
operator|)
return|;
case|case
name|JLO
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|<
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
case|case
name|JHI
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|>
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
case|case
name|JLOS
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|<=
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
case|case
name|JHIS
case|:
return|return
operator|(
operator|(
name|unsigned
operator|)
name|n1
operator|>=
operator|(
name|unsigned
operator|)
name|n2
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setcon
argument_list|(
name|cv
argument_list|,
name|cl
argument_list|,
name|type
argument_list|)
specifier|register
name|char
operator|*
name|cv
operator|,
operator|*
name|cl
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|cv
operator|!=
literal|'$'
condition|)
return|return;
if|if
condition|(
operator|!
name|natural
argument_list|(
name|cl
argument_list|)
condition|)
return|return;
name|p
operator|=
name|conloc
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|cl
operator|++
condition|)
empty_stmt|;
name|p
operator|=
name|conval
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|cv
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_macro
name|setcc
argument_list|(
argument|ap
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|!
name|natural
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|ccloc
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|p1
operator|=
name|ccloc
expr_stmt|;
operator|*
name|p1
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
block|}
end_block

begin_expr_stmt
name|indexa
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 1-> uses [r] addressing mode; 0->doesn't */
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'['
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|natural
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 1->simple local, parameter, global, or register; 0->otherwise */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'$'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|']'
operator|||
operator|*
name|p
operator|==
literal|')'
operator|&&
operator|!
operator|(
operator|*
operator|(
name|p
operator|-
literal|2
operator|)
operator|==
literal|'f'
operator|||
name|fortflg
operator|&&
operator|(
operator|*
operator|--
name|p
operator|==
literal|'1'
operator|||
operator|*
name|p
operator|==
literal|'2'
operator|)
operator|&&
operator|*
operator|--
name|p
operator|==
literal|'1'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Tell if an argument is most likely static. */
end_comment

begin_expr_stmt
name|isstatic
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'_'
operator|||
operator|*
name|cp
operator|==
literal|'L'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|checkaobdisp
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|aobflag
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*  backward search */
name|i
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
name|MAXAOBDISP
operator|&&
operator|(
operator|(
name|q
operator|=
name|q
operator|->
name|back
operator|)
operator|!=
operator|&
name|first
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|q
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  forward search */
name|i
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|i
operator|++
operator|<
name|MAXAOBDISP
operator|&&
operator|(
operator|(
name|q
operator|=
name|q
operator|->
name|forw
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|q
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|struct
name|intleavetab
name|intltab
index|[]
init|=
block|{
name|ADDF
block|,
name|FLOAT
block|,
literal|1
block|,
name|ADDF
block|,
name|DOUBLE
block|,
literal|1
block|,
name|SUBF
block|,
name|FLOAT
block|,
literal|1
block|,
name|SUBF
block|,
name|DOUBLE
block|,
literal|1
block|,
name|MULF
block|,
name|FLOAT
block|,
literal|1
block|,
name|MULF
block|,
name|DOUBLE
block|,
literal|1
block|,
name|DIVF
block|,
name|FLOAT
block|,
literal|1
block|,
name|DIVF
block|,
name|DOUBLE
block|,
literal|1
block|,
name|SINF
block|,
name|FLOAT
block|,
literal|1
block|,
name|COSF
block|,
name|FLOAT
block|,
literal|1
block|,
name|ATANF
block|,
name|FLOAT
block|,
literal|1
block|,
name|LOGF
block|,
name|FLOAT
block|,
literal|1
block|,
name|SQRTF
block|,
name|FLOAT
block|,
literal|1
block|,
name|EXPF
block|,
name|FLOAT
block|,
literal|1
block|,
name|LDF
block|,
name|FLOAT
block|,
literal|0
block|,
name|LDF
block|,
name|DOUBLE
block|,
literal|0
block|,
name|LNF
block|,
name|FLOAT
block|,
literal|0
block|,
name|LNF
block|,
name|DOUBLE
block|,
literal|0
block|,
name|STF
block|,
name|FLOAT
block|,
literal|0
block|,
name|CMPF
block|,
name|FLOAT
block|,
literal|0
block|,
name|CMPF
block|,
name|DOUBLE
block|,
literal|0
block|,
name|CMPF2
block|,
name|FLOAT
block|,
literal|0
block|,
name|TSTF
block|,
name|FLOAT
block|,
literal|0
block|,
name|TSTF
block|,
name|DOUBLE
block|,
literal|0
block|,
name|PUSHD
block|,
name|DOUBLE
block|,
literal|0
block|,
name|CVLF
block|,
name|U
argument_list|(
name|LONG
argument_list|,
name|FLOAT
argument_list|)
block|,
literal|0
block|,
name|CVFL
block|,
name|U
argument_list|(
name|FLOAT
argument_list|,
name|LONG
argument_list|)
block|,
literal|0
block|,
name|LDFD
block|,
name|U
argument_list|(
name|FLOAT
argument_list|,
name|DOUBLE
argument_list|)
block|,
literal|0
block|,
name|CVDF
block|,
name|U
argument_list|(
name|DOUBLE
argument_list|,
name|FLOAT
argument_list|)
block|,
literal|0
block|,
name|NEGF
block|,
name|FLOAT
block|,
literal|0
block|,
name|NIL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|interleave
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|intleavetab
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|intltab
init|;
name|t
operator|->
name|op
operator|!=
name|NIL
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|op
operator|==
name|p
operator|->
name|op
operator|&&
name|t
operator|->
name|subop
operator|==
name|p
operator|->
name|subop
condition|)
block|{
name|count
operator|=
name|t
operator|->
name|intleavect
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|count
operator|<
literal|1
condition|)
continue|continue;
name|p1
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|clearuse
argument_list|()
expr_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|p1
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|p1
operator|->
name|op
operator|!=
name|CBR
operator|)
operator|&&
operator|(
name|p1
operator|->
name|subop
operator|==
name|FLOAT
operator|||
name|p1
operator|->
name|subop
operator|==
name|DOUBLE
operator|||
operator|(
operator|(
name|p1
operator|->
name|subop
operator|&
literal|0xF0
operator|)
operator|==
name|DOUBLE
operator|<<
literal|4
operator|)
operator|||
operator|(
operator|(
name|p1
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|DOUBLE
operator|)
operator|||
operator|(
operator|(
name|p1
operator|->
name|subop
operator|&
literal|0xF0
operator|)
operator|==
name|FLOAT
operator|<<
literal|4
operator|)
operator|||
operator|(
name|p1
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|FLOAT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|p1
operator|->
name|code
argument_list|)
operator|)
operator|>=
literal|0
operator|)
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|(
name|p1
operator|->
name|subop
operator|==
name|DOUBLE
operator|)
operator|||
operator|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF0
operator|)
operator|==
name|DOUBLE
operator|<<
literal|4
operator|)
operator|||
operator|(
operator|(
name|p
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|DOUBLE
operator|)
condition|)
name|uses
index|[
name|r
operator|+
literal|1
index|]
operator|=
name|p1
expr_stmt|;
block|}
else|else
name|checkreg
argument_list|(
name|p1
argument_list|,
name|p1
operator|->
name|code
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|sideeffect
argument_list|(
name|p
argument_list|,
name|p1
argument_list|)
operator|)
condition|)
name|insertblk
argument_list|(
name|p
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|insertblk
argument_list|(
argument|p
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p1
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p1
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|back
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|OpCode
name|termop
index|[]
init|=
block|{
name|JBR
block|,
name|CBR
block|,
name|JMP
block|,
name|LABEL
block|,
name|DLABEL
block|,
name|EROU
block|,
name|JSW
block|,
name|TST
block|,
name|CMP
block|,
name|BIT
block|,
name|CALLF
block|,
name|CALLS
block|,
name|CASE
block|,
name|AOBLEQ
block|,
name|AOBLSS
block|,
name|CMPF
block|,
name|CMPF2
block|,
name|TSTF
block|,
name|MOVBLK
block|,
name|MFPR
block|,
name|MTPR
block|,
name|PROBE
block|,
name|MOVO
block|,
name|TEXT
block|,
name|DATA
block|,
name|BSS
block|,
name|ALIGN
block|,
name|END
block|,
name|LGEN
block|,
name|SET
block|,
name|LCOMM
block|,
name|COMM
block|,
name|NIL
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|sideeffect
argument_list|(
argument|p
argument_list|,
argument|p1
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
specifier|register
name|OpCode
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|NIL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*  special instructions */
for|for
control|(
name|t
operator|=
name|termop
init|;
operator|*
name|t
operator|!=
name|NIL
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
name|p1
operator|->
name|op
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p1
operator|->
name|forw
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p1
operator|->
name|forw
operator|->
name|op
operator|==
name|CBR
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|splitrand
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|r
operator|=
name|isreg
argument_list|(
name|lastrand
argument_list|)
expr_stmt|;
if|if
condition|(
name|uses
index|[
name|r
index|]
operator|&&
name|r
operator|>=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p1
operator|->
name|op
operator|==
name|EDIV
operator|)
operator|&&
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|regs
index|[
name|RT3
index|]
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|uses
index|[
name|r
index|]
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|q
operator|=
name|p1
operator|->
name|back
init|;
name|q
operator|!=
name|p
condition|;
name|q
operator|=
name|q
operator|->
name|back
control|)
block|{
if|if
condition|(
operator|(
name|p1
operator|->
name|op
operator|==
name|PUSH
operator|||
name|p1
operator|->
name|op
operator|==
name|PUSHA
operator|)
operator|&&
operator|(
name|q
operator|->
name|op
operator|==
name|PUSHD
operator|||
name|q
operator|->
name|op
operator|==
name|PUSH
operator|||
name|q
operator|->
name|op
operator|==
name|PUSHA
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* keep args in order */
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|q
operator|->
name|code
argument_list|)
operator|)
operator|>=
literal|5
operator|&&
comment|/* cvdl -(sp); pushl r0*/
operator|(
name|strcmp
argument_list|(
name|q
operator|->
name|code
operator|+
name|i
operator|-
literal|5
argument_list|,
literal|"-(sp)"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|lastrand
argument_list|,
literal|"-(sp)"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|equstr
argument_list|(
name|q
operator|->
name|code
argument_list|,
name|lastrand
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|STF
operator|||
name|q
operator|->
name|op
operator|==
name|CVFL
operator|||
name|q
operator|->
name|op
operator|==
name|CVLF
condition|)
block|{
if|if
condition|(
name|equstr
argument_list|(
name|q
operator|->
name|code
argument_list|,
name|regs
index|[
name|RT1
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|has3ops
argument_list|(
name|p1
argument_list|)
operator|||
name|p1
operator|->
name|op
operator|==
name|EMUL
operator|||
name|p1
operator|->
name|op
operator|==
name|EDIV
condition|)
if|if
condition|(
name|equstr
argument_list|(
name|q
operator|->
name|code
argument_list|,
name|regs
index|[
name|RT2
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*  handle the case  std -56(fp) pushl -60(fp) pushl 		    -56(fp); 		*/
if|if
condition|(
operator|(
name|p1
operator|->
name|forw
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|q
operator|->
name|op
operator|==
name|STF
operator|)
operator|&&
operator|(
name|q
operator|->
name|subop
operator|==
name|DOUBLE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|q
operator|->
name|code
argument_list|,
name|p1
operator|->
name|forw
operator|->
name|code
argument_list|,
name|strlen
argument_list|(
name|q
operator|->
name|code
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|checkreg
argument_list|(
argument|p
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp2
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
comment|/* check for (r),[r] */
do|do
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
operator|||
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
comment|/* get register number */
name|char
name|t
decl_stmt|;
name|cp2
operator|=
operator|++
name|s
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|!=
literal|')'
operator|&&
operator|*
name|s
operator|!=
literal|']'
condition|)
empty_stmt|;
name|t
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|isreg
argument_list|(
name|cp2
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|uses
index|[
name|r
index|]
operator|=
name|p
expr_stmt|;
block|}
operator|*
name|s
operator|=
name|t
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|s
condition|)
do|;
block|}
end_block

end_unit

