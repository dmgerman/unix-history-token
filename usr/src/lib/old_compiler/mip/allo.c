begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)allo.c	4.9 (Berkeley) 10/15/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_decl_stmt
name|NODE
name|resc
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|busy
index|[
name|REGSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxa
decl_stmt|,
name|mina
decl_stmt|,
name|maxb
decl_stmt|,
name|minb
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ALLO0
end_ifndef

begin_macro
name|allo0
argument_list|()
end_macro

begin_block
block|{
comment|/* free everything */
specifier|register
name|i
expr_stmt|;
name|maxa
operator|=
name|maxb
operator|=
operator|-
literal|1
expr_stmt|;
name|mina
operator|=
name|minb
operator|=
literal|0
expr_stmt|;
name|REGLOOP
argument_list|(
argument|i
argument_list|)
block|{
name|busy
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rstatus
index|[
name|i
index|]
operator|&
name|STAREG
condition|)
block|{
if|if
condition|(
name|maxa
operator|<
literal|0
condition|)
name|mina
operator|=
name|i
expr_stmt|;
name|maxa
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|rstatus
index|[
name|i
index|]
operator|&
name|STBREG
condition|)
block|{
if|if
condition|(
name|maxb
operator|<
literal|0
condition|)
name|minb
operator|=
name|i
expr_stmt|;
name|maxb
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ALLO
end_ifndef

begin_macro
name|allo
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|optab
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
operator|,
name|i
operator|,
name|j
expr_stmt|;
name|int
name|either
decl_stmt|;
name|n
operator|=
name|q
operator|->
name|needs
expr_stmt|;
name|either
operator|=
operator|(
name|EITHER
operator|&
name|n
operator|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|&
name|NACOUNT
condition|)
block|{
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|rval
operator|=
name|freereg
argument_list|(
name|p
argument_list|,
name|n
operator|&
operator|(
name|NAMASK
operator||
name|NEVEN
operator|)
argument_list|)
expr_stmt|;
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|n
operator|&=
operator|~
name|NEVEN
expr_stmt|;
comment|/* only used for first need */
name|n
operator|-=
name|NAREG
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|either
condition|)
block|{
comment|/* all or nothing at all */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|resc
index|[
name|j
index|]
operator|.
name|tn
operator|.
name|rval
operator|<
literal|0
condition|)
block|{
comment|/* nothing */
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
goto|goto
name|ok
goto|;
comment|/* all */
block|}
while|while
condition|(
name|n
operator|&
name|NBCOUNT
condition|)
block|{
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|rval
operator|=
name|freereg
argument_list|(
name|p
argument_list|,
name|n
operator|&
name|NBMASK
argument_list|)
expr_stmt|;
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|n
operator|-=
name|NBREG
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|either
condition|)
block|{
comment|/* all or nothing at all */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|resc
index|[
name|j
index|]
operator|.
name|tn
operator|.
name|rval
operator|<
literal|0
condition|)
block|{
comment|/* nothing */
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
goto|goto
name|ok
goto|;
comment|/* all */
block|}
if|if
condition|(
name|n
operator|&
name|NTMASK
condition|)
block|{
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|rval
operator|=
name|TMPREG
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STASG
condition|)
block|{
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|lval
operator|=
name|freetemp
argument_list|(
operator|(
name|SZCHAR
operator|*
name|p
operator|->
name|stn
operator|.
name|stsize
operator|+
operator|(
name|SZINT
operator|-
literal|1
operator|)
operator|)
operator|/
name|SZINT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|lval
operator|=
name|freetemp
argument_list|(
operator|(
name|n
operator|&
name|NTMASK
operator|)
operator|/
name|NTEMP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FLEXNAMES
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|resc
index|[
name|i
index|]
operator|.
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|lval
operator|=
name|BITOOR
argument_list|(
name|resc
index|[
name|i
index|]
operator|.
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
comment|/* turn off "temporarily busy" bit */
name|ok
label|:
name|REGLOOP
argument_list|(
argument|j
argument_list|)
block|{
name|busy
index|[
name|j
index|]
operator|&=
operator|~
name|TBUSY
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|resc
index|[
name|j
index|]
operator|.
name|tn
operator|.
name|rval
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|offsz
decl_stmt|;
end_decl_stmt

begin_macro
name|freetemp
argument_list|(
argument|k
argument_list|)
end_macro

begin_block
block|{
comment|/* allocate k integers worth of temp space */
comment|/* we also make the convention that, if the number of words is more than 1, 	/* it must be aligned for storing doubles... */
ifndef|#
directive|ifndef
name|BACKTEMP
name|int
name|t
decl_stmt|;
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
name|SETOFF
argument_list|(
name|tmpoff
argument_list|,
name|ALDOUBLE
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|tmpoff
expr_stmt|;
name|tmpoff
operator|+=
name|k
operator|*
name|SZINT
expr_stmt|;
if|if
condition|(
name|tmpoff
operator|>
name|maxoff
condition|)
name|maxoff
operator|=
name|tmpoff
expr_stmt|;
if|if
condition|(
name|tmpoff
operator|>=
name|offsz
condition|)
name|cerror
argument_list|(
literal|"stack overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpoff
operator|-
name|baseoff
operator|>
name|maxtemp
condition|)
name|maxtemp
operator|=
name|tmpoff
operator|-
name|baseoff
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
else|#
directive|else
name|tmpoff
operator|+=
name|k
operator|*
name|SZINT
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|1
condition|)
block|{
name|SETOFF
argument_list|(
name|tmpoff
argument_list|,
name|ALDOUBLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpoff
operator|>
name|maxoff
condition|)
name|maxoff
operator|=
name|tmpoff
expr_stmt|;
if|if
condition|(
name|tmpoff
operator|>=
name|offsz
condition|)
name|cerror
argument_list|(
literal|"stack overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpoff
operator|-
name|baseoff
operator|>
name|maxtemp
condition|)
name|maxtemp
operator|=
name|tmpoff
operator|-
name|baseoff
expr_stmt|;
return|return
operator|(
operator|-
name|tmpoff
operator|)
return|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|freereg
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* allocate a register of type n */
comment|/* p gives the type, if floating */
specifier|register
name|j
expr_stmt|;
comment|/* not general; means that only one register (the result) OK for call */
if|if
condition|(
name|callop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
block|{
name|j
operator|=
name|callreg
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|usable
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
condition|)
return|return
operator|(
name|j
operator|)
return|;
comment|/* have allocated callreg first */
block|}
name|j
operator|=
name|p
operator|->
name|in
operator|.
name|rall
operator|&
operator|~
name|MUSTDO
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|NOPREF
operator|&&
name|usable
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
condition|)
block|{
comment|/* needed and not allocated */
return|return
operator|(
name|j
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|&
name|NAMASK
condition|)
block|{
for|for
control|(
name|j
operator|=
name|mina
init|;
name|j
operator|<=
name|maxa
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|rstatus
index|[
name|j
index|]
operator|&
name|STAREG
condition|)
block|{
if|if
condition|(
name|usable
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
condition|)
block|{
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|&
name|NBMASK
condition|)
block|{
for|for
control|(
name|j
operator|=
name|minb
init|;
name|j
operator|<=
name|maxb
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|rstatus
index|[
name|j
index|]
operator|&
name|STBREG
condition|)
block|{
if|if
condition|(
name|usable
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|j
argument_list|)
condition|)
block|{
return|return
operator|(
name|j
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|USABLE
end_ifndef

begin_macro
name|usable
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* decide if register r is usable in tree p to satisfy need n */
comment|/* checks, for the moment */
if|if
condition|(
operator|!
name|istreg
argument_list|(
name|r
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"usable asked about nontemp register"
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy
index|[
name|r
index|]
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isbreg
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|&
name|NAMASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|n
operator|&
name|NBMASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Some special cases that require register pairs... 	 * Have to check for ==,<=, etc. because the result is type int 	 * but need a register pair temp if either side is wide. 	 * For +=, *= etc. where lhs is narrow and rhs is wide, the temp 	 * register must be wide. 	 */
if|if
condition|(
operator|(
name|n
operator|&
name|NAMASK
operator|)
operator|&&
operator|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|||
operator|(
name|n
operator|&
name|NEVEN
operator|)
operator|||
operator|(
name|logop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
operator|&&
operator|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|||
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|)
operator|)
operator|||
operator|(
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
operator|&&
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|&&
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NOEVENODD
if|if
condition|(
name|r
operator|&
literal|01
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|istreg
argument_list|(
name|r
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|busy
index|[
name|r
operator|+
literal|1
index|]
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|busy
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|busy
index|[
name|r
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|busy
index|[
name|r
operator|+
literal|1
index|]
operator|==
literal|0
operator|&&
name|shareit
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|n
argument_list|)
operator|||
name|busy
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|shareit
argument_list|(
name|p
argument_list|,
name|r
operator|+
literal|1
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|busy
index|[
name|r
index|]
operator||=
name|TBUSY
expr_stmt|;
name|busy
index|[
name|r
operator|+
literal|1
index|]
operator||=
name|TBUSY
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|busy
index|[
name|r
index|]
operator|==
literal|0
condition|)
block|{
name|busy
index|[
name|r
index|]
operator||=
name|TBUSY
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* busy[r] is 1: is there chance for sharing */
return|return
operator|(
name|shareit
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|shareit
argument_list|(
argument|p
argument_list|,
argument|r
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* can we make register r available by sharing from p 	   given that the need is n */
if|if
condition|(
operator|(
name|n
operator|&
operator|(
name|NASL
operator||
name|NBSL
operator|)
operator|)
operator|&&
name|ushare
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|n
operator|&
operator|(
name|NASR
operator||
name|NBSR
operator|)
operator|)
operator|&&
name|ushare
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|ushare
argument_list|(
argument|p
argument_list|,
argument|f
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* can we find a register r to share on the left or right 		(as f=='L' or 'R', respectively) of p */
name|p
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
block|{
if|if
condition|(
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
block|{
return|return
operator|(
name|r
operator|==
name|R2UPK1
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|||
name|r
operator|==
name|R2UPK2
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|r
operator|==
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
return|return
operator|(
name|r
operator|==
name|p
operator|->
name|tn
operator|.
name|rval
operator|||
operator|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|&&
name|r
operator|==
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|1
operator|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|recl2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
ifndef|#
directive|ifndef
name|OLD
name|int
name|op
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|REG
operator|&&
name|r
operator|>=
name|REGSZ
condition|)
name|op
operator|=
name|OREG
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|REG
condition|)
name|rfree
argument_list|(
name|r
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
name|OREG
condition|)
block|{
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|rfree
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|,
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
name|rfree
argument_list|(
name|R2UPK2
argument_list|(
name|r
argument_list|)
argument_list|,
name|INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rfree
argument_list|(
name|r
argument_list|,
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
name|rfree
argument_list|(
name|r
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
block|{
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|rfree
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|,
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
name|rfree
argument_list|(
name|R2UPK2
argument_list|(
name|r
argument_list|)
argument_list|,
name|INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rfree
argument_list|(
name|r
argument_list|,
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|int
name|rdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|RFREE
end_ifndef

begin_macro
name|rfree
argument_list|(
argument|r
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* mark register r free, if it is legal to do so */
comment|/* t is the type */
ifndef|#
directive|ifndef
name|BUG3
if|if
condition|(
name|rdebug
condition|)
block|{
name|printf
argument_list|(
literal|"rfree( %s ), size %d\n"
argument_list|,
name|rnames
index|[
name|r
index|]
argument_list|,
name|szty
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|istreg
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
operator|--
name|busy
index|[
name|r
index|]
operator|<
literal|0
condition|)
name|cerror
argument_list|(
literal|"register overfreed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|szty
argument_list|(
name|t
argument_list|)
operator|==
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|NOEVENODD
if|if
condition|(
name|istreg
argument_list|(
name|r
argument_list|)
operator|^
name|istreg
argument_list|(
name|r
operator|+
literal|1
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"illegal free"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|r
operator|&
literal|01
operator|)
operator|||
operator|(
name|istreg
argument_list|(
name|r
argument_list|)
operator|^
name|istreg
argument_list|(
name|r
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|cerror
argument_list|(
literal|"illegal free"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|busy
index|[
name|r
operator|+
literal|1
index|]
operator|<
literal|0
condition|)
name|cerror
argument_list|(
literal|"register overfreed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RBUSY
end_ifndef

begin_macro
name|rbusy
argument_list|(
argument|r
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* mark register r busy */
comment|/* t is the type */
ifndef|#
directive|ifndef
name|BUG3
if|if
condition|(
name|rdebug
condition|)
block|{
name|printf
argument_list|(
literal|"rbusy( %s ), size %d\n"
argument_list|,
name|rnames
index|[
name|r
index|]
argument_list|,
name|szty
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|istreg
argument_list|(
name|r
argument_list|)
condition|)
operator|++
name|busy
index|[
name|r
index|]
expr_stmt|;
if|if
condition|(
name|szty
argument_list|(
name|t
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|istreg
argument_list|(
name|r
operator|+
literal|1
argument_list|)
condition|)
operator|++
name|busy
index|[
name|r
operator|+
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|NOEVENODD
if|if
condition|(
name|istreg
argument_list|(
name|r
argument_list|)
operator|^
name|istreg
argument_list|(
name|r
operator|+
literal|1
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"illegal register pair freed"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|r
operator|&
literal|01
operator|)
operator|||
operator|(
name|istreg
argument_list|(
name|r
argument_list|)
operator|^
name|istreg
argument_list|(
name|r
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|cerror
argument_list|(
literal|"illegal register pair freed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BUG3
end_ifndef

begin_macro
name|rwprint
argument_list|(
argument|rw
argument_list|)
end_macro

begin_block
block|{
comment|/* print rewriting rule */
specifier|register
name|i
operator|,
name|flag
expr_stmt|;
specifier|static
name|char
modifier|*
name|rwnames
index|[]
init|=
block|{
literal|"RLEFT"
block|,
literal|"RRIGHT"
block|,
literal|"RESC1"
block|,
literal|"RESC2"
block|,
literal|"RESC3"
block|,
literal|0
block|, 		}
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|RNULL
condition|)
block|{
name|printf
argument_list|(
literal|"RNULL"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rw
operator|==
name|RNOP
condition|)
block|{
name|printf
argument_list|(
literal|"RNOP"
argument_list|)
expr_stmt|;
return|return;
block|}
name|flag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rwnames
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rw
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
operator|++
name|flag
expr_stmt|;
name|printf
argument_list|(
name|rwnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|reclaim
argument_list|(
argument|p
argument_list|,
argument|rw
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
modifier|*
name|qq
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|NODE
modifier|*
name|recres
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|respref
modifier|*
name|r
decl_stmt|;
comment|/* get back stuff */
ifndef|#
directive|ifndef
name|BUG3
if|if
condition|(
name|rdebug
condition|)
block|{
name|printf
argument_list|(
literal|"reclaim( %o, "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|rwprint
argument_list|(
name|rw
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|prcook
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rw
operator|==
name|RNOP
operator|||
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FREE
operator|&&
name|rw
operator|==
name|RNULL
operator|)
condition|)
return|return;
comment|/* do nothing */
name|walkf
argument_list|(
name|p
argument_list|,
name|recl2
argument_list|)
expr_stmt|;
if|if
condition|(
name|callop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
block|{
comment|/* check that all scratch regs are free */
name|callchk
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* ordinarily, this is the same as allchk() */
block|}
if|if
condition|(
name|rw
operator|==
name|RNULL
operator|||
operator|(
name|cookie
operator|&
name|FOREFF
operator|)
condition|)
block|{
comment|/* totally clobber, leaving nothing */
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* handle condition codes specially */
if|if
condition|(
operator|(
name|cookie
operator|&
name|FORCC
operator|)
operator|&&
operator|(
name|rw
operator|&
name|RESCC
operator|)
condition|)
block|{
comment|/* result is CC register */
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|CCODES
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* locate results */
name|qq
operator|=
name|recres
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|RLEFT
condition|)
operator|*
name|qq
operator|++
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|rw
operator|&
name|RRIGHT
condition|)
operator|*
name|qq
operator|++
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|RESC1
condition|)
operator|*
name|qq
operator|++
operator|=
operator|&
name|resc
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|RESC2
condition|)
operator|*
name|qq
operator|++
operator|=
operator|&
name|resc
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|RESC3
condition|)
operator|*
name|qq
operator|++
operator|=
operator|&
name|resc
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|qq
operator|==
name|recres
condition|)
block|{
name|cerror
argument_list|(
literal|"illegal reclaim"
argument_list|)
expr_stmt|;
block|}
operator|*
name|qq
operator|=
name|NIL
expr_stmt|;
comment|/* now, select the best result, based on the cookie */
for|for
control|(
name|r
operator|=
name|respref
init|;
name|r
operator|->
name|cform
condition|;
operator|++
name|r
control|)
block|{
if|if
condition|(
name|cookie
operator|&
name|r
operator|->
name|cform
condition|)
block|{
for|for
control|(
name|qq
operator|=
name|recres
init|;
operator|(
name|q
operator|=
operator|*
name|qq
operator|)
operator|!=
name|NIL
condition|;
operator|++
name|qq
control|)
block|{
if|if
condition|(
name|tshape
argument_list|(
name|q
argument_list|,
name|r
operator|->
name|mform
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
block|}
block|}
block|}
comment|/* we can't do it; die */
name|cerror
argument_list|(
literal|"cannot reclaim"
argument_list|)
expr_stmt|;
name|gotit
label|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* STARGs are still STARGS */
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
comment|/* to make multi-register allocations work */
comment|/* maybe there is a better way! */
name|q
operator|=
name|tcopy
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|q
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|q
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|q
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|q
operator|->
name|in
operator|.
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|ONEPASS
name|p
operator|->
name|in
operator|.
name|stalign
operator|=
name|q
operator|->
name|in
operator|.
name|stalign
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
name|q
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
comment|/* if the thing is in a register, adjust the type */
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
operator|!
name|rtyflg
condition|)
block|{
comment|/* the C language requires intermediate results to change type */
comment|/* this is inefficient or impossible on some machines */
comment|/* the "T" command in match supresses this type changing */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|CHAR
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|SHORT
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UCHAR
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|USHORT
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|UNSIGNED
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FORT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SPRECC
argument_list|)
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|DOUBLE
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|in
operator|.
name|rall
operator|&
name|MUSTDO
operator|)
condition|)
return|return;
comment|/* unless necessary, ignore it */
name|i
operator|=
name|p
operator|->
name|in
operator|.
name|rall
operator|&
operator|~
name|MUSTDO
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|NOPREF
condition|)
return|return;
if|if
condition|(
name|i
operator|!=
name|p
operator|->
name|tn
operator|.
name|rval
condition|)
block|{
if|if
condition|(
name|busy
index|[
name|i
index|]
operator|||
operator|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|&&
name|busy
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
name|cerror
argument_list|(
literal|"faulty register move"
argument_list|)
expr_stmt|;
block|}
name|rbusy
argument_list|(
name|i
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|rfree
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|rmove
argument_list|(
name|i
argument_list|,
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|i
expr_stmt|;
block|}
case|case
name|OREG
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|||
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|busy
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
operator|>
literal|1
operator|&&
name|istreg
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"potential register overwrite"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|R2UPK1
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|!=
literal|100
operator|&&
name|busy
index|[
name|R2UPK1
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
index|]
operator|>
literal|1
operator|&&
name|istreg
argument_list|(
name|R2UPK1
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|busy
index|[
name|R2UPK2
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
index|]
operator|>
literal|1
operator|&&
name|istreg
argument_list|(
name|R2UPK2
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
operator|)
condition|)
name|cerror
argument_list|(
literal|"potential register overwrite"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|ncopy
end_ifndef

begin_macro
name|ncopy
argument_list|(
argument|q
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* copy the contents of p into q, without any feeling for 	   the contents */
comment|/* this code assume that copying rval and lval does the job; 	   in general, it might be necessary to special case the 	   operator types */
specifier|register
name|i
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|p
operator|->
name|in
operator|.
name|rall
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|lval
operator|=
name|p
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|rval
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|q
operator|->
name|in
operator|.
name|name
operator|=
name|p
operator|->
name|in
operator|.
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|ONEPASS
name|q
operator|->
name|in
operator|.
name|stalign
operator|=
name|p
operator|->
name|in
operator|.
name|stalign
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|q
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NODE
modifier|*
name|tcopy
parameter_list|(
name|p
parameter_list|)
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
block|{
comment|/* make a fresh copy of p */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|r
expr_stmt|;
name|ncopy
argument_list|(
name|q
operator|=
name|talloc
argument_list|()
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
name|rbusy
argument_list|(
name|r
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
block|{
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|rbusy
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|,
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
name|rbusy
argument_list|(
name|R2UPK2
argument_list|(
name|r
argument_list|)
argument_list|,
name|INT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rbusy
argument_list|(
name|r
argument_list|,
name|PTR
operator|+
name|INT
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|optype
argument_list|(
name|q
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
block|{
case|case
name|BITYPE
case|:
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|tcopy
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
case|case
name|UTYPE
case|:
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|tcopy
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_macro
name|allchk
argument_list|()
end_macro

begin_block
block|{
comment|/* check to ensure that all register are free */
specifier|register
name|i
expr_stmt|;
name|REGLOOP
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|istreg
argument_list|(
name|i
argument_list|)
operator|&&
name|busy
index|[
name|i
index|]
condition|)
block|{
name|cerror
argument_list|(
literal|"register allocation error"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

