begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)reader.c	4.8 (Berkeley) 12/10/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_comment
comment|/*	some storage declarations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_decl_stmt
name|NODE
name|node
index|[
name|TREESZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|filename
index|[
literal|100
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the name of the file */
end_comment

begin_decl_stmt
name|int
name|ftnno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of current function */
end_comment

begin_decl_stmt
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NOMAIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nrecur
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lflag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FORT
end_ifdef

begin_decl_stmt
name|int
name|Oflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|Wflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|edebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|udebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OFFSZ
name|tmpoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset for first temporary, in bits for current block */
end_comment

begin_decl_stmt
name|OFFSZ
name|maxoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum temporary offset over all blocks in current ftn, in bits */
end_comment

begin_decl_stmt
name|int
name|maxtreg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|stotree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|stocook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OFFSZ
name|baseoff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OFFSZ
name|maxtemp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|p2init
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* set the values of the pass 2 arguments */
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|files
expr_stmt|;
name|allo0
argument_list|()
expr_stmt|;
comment|/* free all regs */
name|files
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
operator|++
name|c
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|argv
index|[
name|c
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'X'
case|:
comment|/* pass1 flags */
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
comment|/* VOID */
block|}
operator|--
name|cp
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* linenos */
operator|++
name|lflag
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* expressions */
operator|++
name|edebug
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* orders */
operator|++
name|odebug
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* register allocation */
operator|++
name|rdebug
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* rallo */
operator|++
name|radebug
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|vdebug
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* ttype calls */
operator|++
name|tdebug
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* shapes */
operator|++
name|sdebug
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Sethi-Ullman testing (machine dependent) */
operator|++
name|udebug
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* general machine-dependent debugging flag */
operator|++
name|xdebug
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
comment|/* shut up warnings */
operator|++
name|Wflag
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FORT
case|case
literal|'O'
case|:
comment|/* optimizing */
operator|++
name|Oflag
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|cerror
argument_list|(
literal|"bad option: %c"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|files
operator|=
literal|1
expr_stmt|;
comment|/* assumed to be a filename */
block|}
name|mkdope
argument_list|()
expr_stmt|;
name|setrew
argument_list|()
expr_stmt|;
return|return
operator|(
name|files
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|NOMAIN
end_ifndef

begin_function_decl
name|unsigned
name|int
name|caloff
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|int
name|offsz
decl_stmt|;
end_decl_stmt

begin_macro
name|mainp2
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|files
expr_stmt|;
specifier|register
name|temp
expr_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|offsz
operator|=
name|caloff
argument_list|()
expr_stmt|;
name|files
operator|=
name|p2init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|tinit
argument_list|()
expr_stmt|;
name|reread
label|:
if|if
condition|(
name|files
condition|)
block|{
while|while
condition|(
name|files
operator|<
name|argc
operator|&&
name|argv
index|[
name|files
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
operator|++
name|files
expr_stmt|;
block|}
if|if
condition|(
name|files
operator|>
name|argc
condition|)
return|return
operator|(
name|nerrors
operator|)
return|;
name|freopen
argument_list|(
name|argv
index|[
name|files
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>
literal|0
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|')'
case|:
default|default:
comment|/* copy line unchanged */
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|PUTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/*  initial tab  */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|PUTCHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
continue|continue;
case|case
name|BBEG
case|:
comment|/* beginning of a block */
name|temp
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* ftnno */
name|tmpoff
operator|=
name|baseoff
operator|=
operator|(
name|unsigned
name|int
operator|)
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* autooff for block gives max offset of autos in block */
name|maxtreg
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
name|cerror
argument_list|(
literal|"intermediate file format error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|ftnno
condition|)
block|{
comment|/* beginning of function */
name|maxoff
operator|=
name|baseoff
expr_stmt|;
name|ftnno
operator|=
name|temp
expr_stmt|;
name|maxtemp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|baseoff
operator|>
name|maxoff
condition|)
name|maxoff
operator|=
name|baseoff
expr_stmt|;
comment|/* maxoff at end of ftn is max of autos and temps 			   over all blocks in the function */
block|}
name|setregs
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|BEND
case|:
comment|/* end of block */
name|SETOFF
argument_list|(
name|maxoff
argument_list|,
name|ALSTACK
argument_list|)
expr_stmt|;
name|eobl2
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
name|cerror
argument_list|(
literal|"intermediate file format eof"
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|EXPR
case|:
comment|/* compile code for an expression */
name|lineno
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|filename
init|;
operator|(
operator|*
name|cp
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
operator|++
name|cp
control|)
empty_stmt|;
comment|/* VOID, reads filename */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
name|lineid
argument_list|(
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|tmpoff
operator|=
name|baseoff
expr_stmt|;
comment|/* expression at top level reuses temps */
name|p
operator|=
name|eread
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|BUG4
if|if
condition|(
name|edebug
condition|)
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MYREADER
name|MYREADER
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* do your own laundering of the input */
endif|#
directive|endif
name|nrecur
operator|=
literal|0
expr_stmt|;
name|delay
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expression statement  throws out results */
name|reclaim
argument_list|(
name|p
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allchk
argument_list|()
expr_stmt|;
name|tcheck
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* EOF */
if|if
condition|(
name|files
condition|)
goto|goto
name|reread
goto|;
return|return
operator|(
name|nerrors
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ONEPASS
end_ifdef

begin_macro
name|p2compile
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lflag
condition|)
name|lineid
argument_list|(
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|tmpoff
operator|=
name|baseoff
expr_stmt|;
comment|/* expression at top level reuses temps */
comment|/* generate code for the tree p */
ifndef|#
directive|ifndef
name|BUG4
if|if
condition|(
name|edebug
condition|)
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MYREADER
name|MYREADER
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* do your own laundering of the input */
endif|#
directive|endif
name|nrecur
operator|=
literal|0
expr_stmt|;
name|delay
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* do the code generation */
name|reclaim
argument_list|(
name|p
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|allchk
argument_list|()
expr_stmt|;
comment|/* can't do tcheck here; some stuff (e.g., attributes) may be around from first pass */
comment|/* first pass will do it... */
block|}
end_block

begin_macro
name|p2bbeg
argument_list|(
argument|aoff
argument_list|,
argument|myreg
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|int
name|myftn
init|=
operator|-
literal|1
decl_stmt|;
name|tmpoff
operator|=
name|baseoff
operator|=
operator|(
name|unsigned
name|int
operator|)
name|aoff
expr_stmt|;
name|maxtreg
operator|=
name|myreg
expr_stmt|;
if|if
condition|(
name|myftn
operator|!=
name|ftnno
condition|)
block|{
comment|/* beginning of function */
name|maxoff
operator|=
name|baseoff
expr_stmt|;
name|myftn
operator|=
name|ftnno
expr_stmt|;
name|maxtemp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|baseoff
operator|>
name|maxoff
condition|)
name|maxoff
operator|=
name|baseoff
expr_stmt|;
comment|/* maxoff at end of ftn is max of autos and temps over all blocks */
block|}
name|setregs
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|p2bend
argument_list|()
end_macro

begin_block
block|{
name|SETOFF
argument_list|(
name|maxoff
argument_list|,
name|ALSTACK
argument_list|)
expr_stmt|;
name|eobl2
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|NODE
modifier|*
name|deltrees
index|[
name|DELAYS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|deli
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|delay
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* look in all legal places for COMOP's and ++ and -- ops to delay */
comment|/* note; don't delay ++ and -- within calls or things like 	/* getchar (in their macro forms) will start behaving strangely */
specifier|register
name|i
expr_stmt|;
comment|/* look for visible COMOPS, and rewrite repeatedly */
while|while
condition|(
name|delay1
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* VOID */
block|}
comment|/* look for visible, delayable ++ and -- */
name|deli
operator|=
literal|0
expr_stmt|;
name|delay2
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|codgen
argument_list|(
name|p
argument_list|,
name|FOREFF
argument_list|)
expr_stmt|;
comment|/* do what is left */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|deli
condition|;
operator|++
name|i
control|)
name|codgen
argument_list|(
name|deltrees
index|[
name|i
index|]
argument_list|,
name|FOREFF
argument_list|)
expr_stmt|;
comment|/* do the rest */
block|}
end_block

begin_expr_stmt
name|delay1
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* look for COMOPS */
specifier|register
name|o
operator|,
name|ty
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|ty
operator|==
name|UTYPE
condition|)
return|return
operator|(
name|delay1
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|QUEST
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
comment|/* don't look on RHS */
return|return
operator|(
name|delay1
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
return|;
case|case
name|COMOP
case|:
comment|/* the meat of the routine */
name|delay
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* completely evaluate the LHS */
comment|/* rewrite the COMOP */
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|delay1
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|||
name|delay1
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|delay2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* look for delayable ++ and -- operators */
specifier|register
name|o
operator|,
name|ty
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|NOT
case|:
case|case
name|QUEST
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|CALL
case|:
case|case
name|UNARY
name|CALL
case|:
case|case
name|STCALL
case|:
case|case
name|UNARY
name|STCALL
case|:
case|case
name|FORTCALL
case|:
case|case
name|UNARY
name|FORTCALL
case|:
case|case
name|COMOP
case|:
case|case
name|CBRANCH
case|:
comment|/* for the moment, don't delay past a conditional context, or 		/* inside of a call */
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* if *p++, do not rewrite */
if|if
condition|(
name|autoincr
argument_list|(
name|p
argument_list|)
condition|)
return|return;
break|break;
case|case
name|INCR
case|:
case|case
name|DECR
case|:
if|if
condition|(
name|deltest
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|deli
operator|<
name|DELAYS
condition|)
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|deltrees
index|[
name|deli
operator|++
index|]
operator|=
name|tcopy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
comment|/* zap constant */
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|delay2
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|delay2
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|codgen
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* generate the code for p; 	   order may call codgen recursively */
comment|/* cookie is used to describe the context */
for|for
control|(
init|;
condition|;
control|)
block|{
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* creats OREG from * if possible and does sucomp */
name|stotree
operator|=
name|NIL
expr_stmt|;
ifndef|#
directive|ifndef
name|BUG4
if|if
condition|(
name|edebug
condition|)
block|{
name|printf
argument_list|(
literal|"store called on:\n"
argument_list|)
expr_stmt|;
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|store
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stotree
operator|==
name|NIL
condition|)
break|break;
comment|/* because it's minimal, can do w.o. stores */
name|order
argument_list|(
name|stotree
argument_list|,
name|stocook
argument_list|)
expr_stmt|;
block|}
name|order
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|BUG4
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|cnames
index|[]
init|=
block|{
literal|"SANY"
block|,
literal|"SAREG"
block|,
literal|"STAREG"
block|,
literal|"SBREG"
block|,
literal|"STBREG"
block|,
literal|"SCC"
block|,
literal|"SNAME"
block|,
literal|"SCON"
block|,
literal|"SFLD"
block|,
literal|"SOREG"
block|,
ifdef|#
directive|ifdef
name|WCARD1
literal|"WCARD1"
block|,
else|#
directive|else
literal|"STARNM"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WCARD2
literal|"WCARD2"
block|,
else|#
directive|else
literal|"STARREG"
block|,
endif|#
directive|endif
literal|"INTEMP"
block|,
literal|"FORARG"
block|,
literal|"SWADD"
block|,
literal|0
block|, 	}
decl_stmt|;
end_decl_stmt

begin_macro
name|prcook
argument_list|(
argument|cookie
argument_list|)
end_macro

begin_block
block|{
comment|/* print a nice-looking description of cookie */
name|int
name|i
decl_stmt|,
name|flag
decl_stmt|;
if|if
condition|(
name|cookie
operator|&
name|SPECIAL
condition|)
block|{
if|if
condition|(
name|cookie
operator|==
name|SZERO
condition|)
name|printf
argument_list|(
literal|"SZERO"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cookie
operator|==
name|SONE
condition|)
name|printf
argument_list|(
literal|"SONE"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cookie
operator|==
name|SMONE
condition|)
name|printf
argument_list|(
literal|"SMONE"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cookie
operator|==
name|SCCON
condition|)
name|printf
argument_list|(
literal|"SCCON"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cookie
operator|==
name|SSCON
condition|)
name|printf
argument_list|(
literal|"SSCON"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cookie
operator|==
name|SSOREG
condition|)
name|printf
argument_list|(
literal|"SSOREG"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"SPECIAL+%d"
argument_list|,
name|cookie
operator|&
operator|~
name|SPECIAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|flag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cnames
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|cookie
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|flag
condition|)
name|printf
argument_list|(
literal|"|"
argument_list|)
expr_stmt|;
operator|++
name|flag
expr_stmt|;
name|printf
argument_list|(
name|cnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|odebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|order
argument_list|(
name|p
argument_list|,
name|cook
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|o
operator|,
name|ty
operator|,
name|m
expr_stmt|;
name|int
name|m1
decl_stmt|;
name|int
name|cookie
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|cookie
operator|=
name|cook
expr_stmt|;
name|rcount
argument_list|()
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rallo
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|in
operator|.
name|rall
argument_list|)
expr_stmt|;
goto|goto
name|first
goto|;
comment|/* by this time, p should be able to be generated without stores; 	   the only question is how */
name|again
label|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FREE
condition|)
return|return;
comment|/* whole tree was done */
name|cookie
operator|=
name|cook
expr_stmt|;
name|rcount
argument_list|()
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rallo
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|in
operator|.
name|rall
argument_list|)
expr_stmt|;
comment|/* if any rewriting and canonicalization has put 	 * the tree (p) into a shape that cook is happy 	 * with (exclusive of FOREFF, FORREW, and INTEMP) 	 * then we are done. 	 * this allows us to call order with shapes in 	 * addition to cookies and stop short if possible. 	 */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|cook
operator|&
operator|(
operator|~
operator|(
name|FOREFF
operator||
name|FORREW
operator||
name|INTEMP
operator|)
operator|)
argument_list|)
condition|)
return|return;
name|first
label|:
ifndef|#
directive|ifndef
name|BUG4
if|if
condition|(
name|odebug
condition|)
block|{
name|printf
argument_list|(
literal|"order( %o, "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|prcook
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" )\n"
argument_list|)
expr_stmt|;
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* first of all, for most ops, see if it is in the table */
comment|/* look for ops */
switch|switch
condition|(
name|m
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
default|default:
comment|/* look for op in table */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
operator|==
name|MDONE
condition|)
goto|goto
name|cleanup
goto|;
elseif|else
if|if
condition|(
name|m
operator|==
name|MNOPE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cookie
operator|=
name|nextcook
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
condition|)
goto|goto
name|nomat
goto|;
continue|continue;
block|}
else|else
break|break;
block|}
break|break;
case|case
name|COMOP
case|:
case|case
name|FORCE
case|:
case|case
name|CBRANCH
case|:
case|case
name|QUEST
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|NOT
case|:
case|case
name|UNARY
name|CALL
case|:
case|case
name|CALL
case|:
case|case
name|UNARY
name|STCALL
case|:
case|case
name|STCALL
case|:
case|case
name|UNARY
name|FORTCALL
case|:
case|case
name|FORTCALL
case|:
comment|/* don't even go near the table... */
empty_stmt|;
block|}
comment|/* get here to do rewriting if no match or 	   fall through from above for hard ops */
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|p2
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
else|else
name|p2
operator|=
name|NIL
expr_stmt|;
ifndef|#
directive|ifndef
name|BUG4
if|if
condition|(
name|odebug
condition|)
block|{
name|printf
argument_list|(
literal|"order( %o, "
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|prcook
argument_list|(
name|cook
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ), cookie "
argument_list|)
expr_stmt|;
name|prcook
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", rewrite %s\n"
argument_list|,
name|opst
index|[
name|m
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|m
condition|)
block|{
default|default:
name|nomat
label|:
name|cerror
argument_list|(
literal|"no table entry for op %s"
argument_list|,
name|opst
index|[
name|p
operator|->
name|in
operator|.
name|op
index|]
argument_list|)
expr_stmt|;
case|case
name|COMOP
case|:
name|codgen
argument_list|(
name|p1
argument_list|,
name|FOREFF
argument_list|)
expr_stmt|;
name|p2
operator|->
name|in
operator|.
name|rall
operator|=
name|p
operator|->
name|in
operator|.
name|rall
expr_stmt|;
name|codgen
argument_list|(
name|p2
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|p2
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|FORCE
case|:
comment|/* recurse, letting the work be done by rallo */
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|cook
operator|=
name|INTAREG
operator||
name|INTBREG
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|CBRANCH
case|:
name|o
operator|=
name|p2
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|cbranch
argument_list|(
name|p1
argument_list|,
operator|-
literal|1
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|p2
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
case|case
name|QUEST
case|:
name|cbranch
argument_list|(
name|p1
argument_list|,
operator|-
literal|1
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|p2
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|rall
operator|=
name|p
operator|->
name|in
operator|.
name|rall
expr_stmt|;
name|codgen
argument_list|(
name|p2
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
comment|/* force right to compute result into same reg used by left */
name|p2
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|rall
operator|=
name|p2
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator||
name|MUSTDO
expr_stmt|;
name|reclaim
argument_list|(
name|p2
operator|->
name|in
operator|.
name|left
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m1
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|codgen
argument_list|(
name|p2
operator|->
name|in
operator|.
name|right
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
comment|/* set up node describing result */
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|p2
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|p2
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|tfree
argument_list|(
name|p2
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|p2
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|NOT
case|:
comment|/* logical operators */
comment|/* if here, must be a logical operator for 0-1 value */
name|cbranch
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|CCODES
expr_stmt|;
name|p
operator|->
name|bn
operator|.
name|label
operator|=
name|m
expr_stmt|;
name|order
argument_list|(
name|p
argument_list|,
name|INTAREG
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|FLD
case|:
comment|/* fields of funny type */
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p1
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
case|case
name|UNARY
name|MINUS
case|:
name|order
argument_list|(
name|p1
argument_list|,
name|INBREG
operator||
name|INAREG
operator||
name|SOREG
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|NAME
case|:
comment|/* all leaves end up here ... */
if|if
condition|(
name|o
operator|==
name|REG
condition|)
goto|goto
name|nomat
goto|;
name|order
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|INIT
case|:
name|uerror
argument_list|(
literal|"illegal initialization"
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|FORTCALL
case|:
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|NIL
expr_stmt|;
case|case
name|FORTCALL
case|:
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|FORTCALL
expr_stmt|;
if|if
condition|(
name|genfcall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
condition|)
goto|goto
name|nomat
goto|;
goto|goto
name|cleanup
goto|;
case|case
name|UNARY
name|CALL
case|:
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|NIL
expr_stmt|;
case|case
name|CALL
case|:
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
if|if
condition|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
condition|)
goto|goto
name|nomat
goto|;
goto|goto
name|cleanup
goto|;
case|case
name|UNARY
name|STCALL
case|:
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|NIL
expr_stmt|;
case|case
name|STCALL
case|:
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|STCALL
expr_stmt|;
if|if
condition|(
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
condition|)
goto|goto
name|nomat
goto|;
goto|goto
name|cleanup
goto|;
comment|/* if arguments are passed in register, care must be taken that reclaim 		/* not throw away the register which now has the result... */
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|cook
operator|==
name|FOREFF
condition|)
block|{
comment|/* do nothing */
name|order
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|FOREFF
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|R2REGS
comment|/* try to coax a tree into a doubly indexed OREG */
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|ISPTR
argument_list|(
name|p1
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
name|offset
argument_list|(
name|p1
operator|->
name|in
operator|.
name|right
argument_list|,
name|tlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|order
argument_list|(
name|p1
operator|->
name|in
operator|.
name|left
argument_list|,
name|INAREG
operator||
name|INTAREG
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|ISPTR
argument_list|(
name|p1
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
name|offset
argument_list|(
name|p1
operator|->
name|in
operator|.
name|left
argument_list|,
name|tlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|order
argument_list|(
name|p1
operator|->
name|in
operator|.
name|right
argument_list|,
name|INAREG
operator||
name|INTAREG
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
endif|#
directive|endif
name|offstar
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|INCR
case|:
comment|/* INCR and DECR */
if|if
condition|(
name|setincr
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|again
goto|;
comment|/* x++ becomes (x += 1) -1; */
if|if
condition|(
name|cook
operator|&
name|FOREFF
condition|)
block|{
comment|/* result not needed so inc or dec and be done with it */
comment|/* x++ => x += 1 */
name|p
operator|->
name|in
operator|.
name|op
operator|=
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
operator|)
condition|?
name|ASG
name|PLUS
else|:
name|ASG
name|MINUS
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|p1
operator|=
name|tcopy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|reclaim
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|in
operator|.
name|op
operator|=
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
operator|)
condition|?
name|ASG
name|PLUS
else|:
name|ASG
name|MINUS
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
operator|)
condition|?
name|MINUS
else|:
name|PLUS
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|STASG
case|:
if|if
condition|(
name|setstr
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|again
goto|;
goto|goto
name|nomat
goto|;
case|case
name|ASG
name|PLUS
case|:
comment|/* and other assignment ops */
if|if
condition|(
name|setasop
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|again
goto|;
comment|/* there are assumed to be no side effects in LHS */
name|p2
operator|=
name|tcopy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|reclaim
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|p2
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rallo
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|in
operator|.
name|rall
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BUG4
if|if
condition|(
name|odebug
condition|)
name|fwalk
argument_list|(
name|p
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|order
argument_list|(
name|p2
operator|->
name|in
operator|.
name|left
argument_list|,
name|INTBREG
operator||
name|INTAREG
argument_list|)
expr_stmt|;
name|order
argument_list|(
name|p2
argument_list|,
name|INTBREG
operator||
name|INTAREG
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|ASSIGN
case|:
if|if
condition|(
name|setasg
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|again
goto|;
goto|goto
name|nomat
goto|;
case|case
name|BITYPE
case|:
if|if
condition|(
name|setbin
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|again
goto|;
comment|/* try to replace binary ops by =ops */
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MUL
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|AND
case|:
case|case
name|OR
case|:
case|case
name|ER
case|:
case|case
name|LS
case|:
case|case
name|RS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASG
name|o
expr_stmt|;
goto|goto
name|again
goto|;
block|}
goto|goto
name|nomat
goto|;
block|}
name|cleanup
label|:
comment|/* if it is not yet in the right state, put it there */
if|if
condition|(
name|cook
operator|&
name|FOREFF
condition|)
block|{
name|reclaim
argument_list|(
name|p
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FREE
condition|)
return|return;
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|cook
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|cook
argument_list|)
operator|)
operator|==
name|MDONE
condition|)
return|return;
comment|/* we are in bad shape, try one last chance */
if|if
condition|(
name|lastchance
argument_list|(
name|p
argument_list|,
name|cook
argument_list|)
condition|)
goto|goto
name|again
goto|;
goto|goto
name|nomat
goto|;
block|}
end_block

begin_decl_stmt
name|int
name|callflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fregs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|store
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* find a subtree of p which should be stored */
specifier|register
name|o
operator|,
name|ty
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
return|return;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|UNARY
name|CALL
case|:
case|case
name|UNARY
name|FORTCALL
case|:
case|case
name|UNARY
name|STCALL
case|:
operator|++
name|callflag
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
name|stoasg
argument_list|(
argument|p->in.left
argument_list|,
argument|UNARY MUL
argument_list|)
empty_stmt|;
break|break;
case|case
name|CALL
case|:
case|case
name|FORTCALL
case|:
case|case
name|STCALL
case|:
name|store
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|stoarg
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|o
argument_list|)
expr_stmt|;
operator|++
name|callflag
expr_stmt|;
return|return;
case|case
name|COMOP
case|:
name|markcall
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
operator|>
name|fregs
condition|)
name|SETSTO
argument_list|(
name|p
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|QUEST
case|:
name|markcall
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|su
operator|>
name|fregs
condition|)
name|SETSTO
argument_list|(
name|p
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
case|case
name|CBRANCH
case|:
comment|/* to prevent complicated expressions on the LHS from being stored */
case|case
name|NOT
case|:
name|constore
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ty
operator|==
name|UTYPE
condition|)
block|{
name|store
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
name|stoasg
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|su
operator|>
name|fregs
condition|)
block|{
comment|/* must store */
name|mkadrs
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* set up stotree and stocook to subtree 				 that must be stored */
block|}
name|store
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|constore
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* store conditional expressions */
comment|/* the point is, avoid storing expressions in conditional 	   conditional context, since the evaluation order is predetermined */
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|QUEST
case|:
name|markcall
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
case|case
name|NOT
case|:
name|constore
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
name|store
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|markcall
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* mark off calls below the current node */
name|again
label|:
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|UNARY
name|CALL
case|:
case|case
name|UNARY
name|STCALL
case|:
case|case
name|UNARY
name|FORTCALL
case|:
case|case
name|CALL
case|:
case|case
name|STCALL
case|:
case|case
name|FORTCALL
case|:
operator|++
name|callflag
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|optype
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
block|{
case|case
name|BITYPE
case|:
name|markcall
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
case|case
name|UTYPE
case|:
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* eliminate recursion (aren't I clever...) */
goto|goto
name|again
goto|;
case|case
name|LTYPE
case|:
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|stoarg
argument_list|(
name|p
argument_list|,
name|calltype
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* arrange to store the args */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|CM
condition|)
block|{
name|stoarg
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|calltype
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|calltype
operator|==
name|CALL
condition|)
block|{
name|STOARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|calltype
operator|==
name|STCALL
condition|)
block|{
name|STOSTARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STOFARG
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|callflag
operator|=
literal|0
expr_stmt|;
name|store
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NESTCALLS
if|if
condition|(
name|callflag
condition|)
block|{
comment|/* prevent two calls from being active at once  */
name|SETSTO
argument_list|(
name|p
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* do again to preserve bottom up nature....  */
block|}
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|int
name|negrel
index|[]
init|=
block|{
name|NE
block|,
name|EQ
block|,
name|GT
block|,
name|GE
block|,
name|LT
block|,
name|LE
block|,
name|UGT
block|,
name|UGE
block|,
name|ULT
block|,
name|ULE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* negatives of relationals */
end_comment

begin_macro
name|cbranch
argument_list|(
argument|p
argument_list|,
argument|true
argument_list|,
argument|false
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* evaluate p for truth value, and branch to true or false 	/* accordingly: label<0 means fall through */
specifier|register
name|o
operator|,
name|lab
operator|,
name|flab
operator|,
name|tlab
expr_stmt|;
name|lab
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ULE
case|:
case|case
name|ULT
case|:
case|case
name|UGE
case|:
case|case
name|UGT
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|true
operator|<
literal|0
condition|)
block|{
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|negrel
index|[
name|o
operator|-
name|EQ
index|]
expr_stmt|;
name|true
operator|=
name|false
expr_stmt|;
name|false
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NOOPT
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|UGT
case|:
case|case
name|ULE
case|:
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
operator|=
operator|(
name|o
operator|==
name|UGT
operator|)
condition|?
name|NE
else|:
name|EQ
expr_stmt|;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|logop
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
block|{
comment|/* strange situation: e.g., (a!=0) == 0 */
comment|/* must prevent reference to p->in.left->lable, so get 0/1 */
comment|/* we could optimize, but why bother */
name|codgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|INAREG
operator||
name|INBREG
argument_list|)
expr_stmt|;
block|}
name|codgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|FORCC
argument_list|)
expr_stmt|;
name|cbgen
argument_list|(
name|o
argument_list|,
name|true
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
break|break;
case|case
name|UGE
case|:
name|codgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|FORCC
argument_list|)
expr_stmt|;
name|cbgen
argument_list|(
literal|0
argument_list|,
name|true
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
comment|/* unconditional branch */
break|break;
case|case
name|ULT
case|:
name|codgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|FORCC
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|p
operator|->
name|bn
operator|.
name|label
operator|=
name|true
expr_stmt|;
name|codgen
argument_list|(
name|p
argument_list|,
name|FORCC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|false
operator|>=
literal|0
condition|)
name|cbgen
argument_list|(
literal|0
argument_list|,
name|false
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|reclaim
argument_list|(
name|p
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|ANDAND
case|:
name|lab
operator|=
name|false
operator|<
literal|0
condition|?
name|getlab
argument_list|()
else|:
name|false
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
operator|-
literal|1
argument_list|,
name|lab
argument_list|)
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|false
operator|<
literal|0
condition|)
name|deflab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
case|case
name|OROR
case|:
name|lab
operator|=
name|true
operator|<
literal|0
condition|?
name|getlab
argument_list|()
else|:
name|true
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|lab
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|true
operator|<
literal|0
condition|)
name|deflab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
case|case
name|NOT
case|:
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
case|case
name|COMOP
case|:
name|codgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
name|FOREFF
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return;
case|case
name|QUEST
case|:
name|flab
operator|=
name|false
operator|<
literal|0
condition|?
name|getlab
argument_list|()
else|:
name|false
expr_stmt|;
name|tlab
operator|=
name|true
operator|<
literal|0
condition|?
name|getlab
argument_list|()
else|:
name|true
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
operator|-
literal|1
argument_list|,
name|lab
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|left
argument_list|,
name|tlab
argument_list|,
name|flab
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|lab
argument_list|)
expr_stmt|;
name|cbranch
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|right
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|true
operator|<
literal|0
condition|)
name|deflab
argument_list|(
name|tlab
argument_list|)
expr_stmt|;
if|if
condition|(
name|false
operator|<
literal|0
condition|)
name|deflab
argument_list|(
name|flab
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
case|case
name|ICON
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
operator|&&
name|p
operator|->
name|in
operator|.
name|type
operator|!=
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
condition|)
block|{
comment|/* addresses of C objects are never 0 */
if|if
condition|(
name|true
operator|>=
literal|0
condition|)
name|cbgen
argument_list|(
literal|0
argument_list|,
name|true
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|false
operator|>=
literal|0
condition|)
name|cbgen
argument_list|(
literal|0
argument_list|,
name|false
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
comment|/* fall through to default with other strange constants */
default|default:
comment|/* get condition codes */
name|codgen
argument_list|(
name|p
argument_list|,
name|FORCC
argument_list|)
expr_stmt|;
if|if
condition|(
name|true
operator|>=
literal|0
condition|)
name|cbgen
argument_list|(
name|NE
argument_list|,
name|true
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
if|if
condition|(
name|false
operator|>=
literal|0
condition|)
name|cbgen
argument_list|(
name|true
operator|>=
literal|0
condition|?
literal|0
else|:
name|EQ
argument_list|,
name|false
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|reclaim
argument_list|(
name|p
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_macro
name|rcount
argument_list|()
end_macro

begin_block
block|{
comment|/* count recursions */
if|if
condition|(
operator|++
name|nrecur
operator|>
name|NRECUR
condition|)
block|{
name|cerror
argument_list|(
literal|"expression causes compiler loop: try simplifying"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|BUG4
end_ifndef

begin_macro
name|eprint
argument_list|(
argument|p
argument_list|,
argument|down
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|a
operator|=
operator|*
name|b
operator|=
name|down
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|down
operator|>=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|down
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|down
operator|--
condition|)
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%o) %s"
argument_list|,
name|p
argument_list|,
name|opst
index|[
name|p
operator|->
name|in
operator|.
name|op
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
comment|/* special cases */
case|case
name|REG
case|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICON
case|:
case|case
name|NAME
case|:
case|case
name|OREG
case|:
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|STCALL
case|:
case|case
name|UNARY
name|STCALL
case|:
case|case
name|STARG
case|:
case|case
name|STASG
case|:
name|printf
argument_list|(
literal|" size=%d"
argument_list|,
name|p
operator|->
name|stn
operator|.
name|stsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" align=%d"
argument_list|,
name|p
operator|->
name|stn
operator|.
name|stalign
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|rall
operator|==
name|NOPREF
condition|)
name|printf
argument_list|(
literal|"NOPREF"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|rall
operator|&
name|MUSTDO
condition|)
name|printf
argument_list|(
literal|"MUSTDO "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"PREF "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|in
operator|.
name|rall
operator|&
operator|~
name|MUSTDO
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|", SU= %d\n"
argument_list|,
name|p
operator|->
name|in
operator|.
name|su
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOMAIN
end_ifndef

begin_function
name|NODE
modifier|*
name|eread
parameter_list|()
block|{
comment|/* call eread recursively to get subtrees, if any */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
operator|,
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|pc
decl_stmt|;
specifier|register
name|j
expr_stmt|;
name|i
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|optype
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|LTYPE
condition|)
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|BITYPE
condition|)
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|rdin
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
comment|/* register allocation information */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STASG
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|STCALL
condition|)
block|{
name|p
operator|->
name|stn
operator|.
name|stsize
operator|=
operator|(
name|rdin
argument_list|(
literal|10
argument_list|)
operator|+
operator|(
name|SZCHAR
operator|-
literal|1
operator|)
operator|)
operator|/
name|SZCHAR
expr_stmt|;
name|p
operator|->
name|stn
operator|.
name|stalign
operator|=
name|rdin
argument_list|(
literal|10
argument_list|)
operator|/
name|SZCHAR
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'\n'
condition|)
name|cerror
argument_list|(
literal|"illegal \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* usual case */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
name|rbusy
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|,
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* non usually, but sometimes justified */
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|pc
operator|=
name|p
operator|->
name|in
operator|.
name|name
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|<
name|NCHNAM
condition|)
operator|*
name|pc
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|NCHNAM
condition|)
operator|*
name|pc
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
for|for
control|(
name|pc
operator|=
name|buf
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|<
name|BUFSIZ
condition|)
operator|*
name|pc
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|BUFSIZ
condition|)
operator|*
name|pc
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|tstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* now, recursively read descendents, if any */
if|if
condition|(
name|i
operator|!=
name|LTYPE
condition|)
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|eread
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BITYPE
condition|)
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|eread
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|CONSZ
name|rdin
parameter_list|(
name|base
parameter_list|)
block|{
specifier|register
name|sign
operator|,
name|c
expr_stmt|;
name|CONSZ
name|val
decl_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|cerror
argument_list|(
literal|"illegal -"
argument_list|)
expr_stmt|;
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
break|break;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|val
operator|*=
name|base
expr_stmt|;
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
name|val
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
else|else
name|val
operator|-=
name|c
operator|-
literal|'0'
expr_stmt|;
continue|continue;
block|}
name|cerror
argument_list|(
literal|"illegal character `%c' on intermediate file"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
name|cerror
argument_list|(
literal|"unexpected EOF"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FIELDOPS
end_ifndef

begin_comment
comment|/* do this if there is no special hardware support for fields */
end_comment

begin_macro
name|ffld
argument_list|(
argument|p
argument_list|,
argument|down
argument_list|,
argument|down1
argument_list|,
argument|down2
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|down1
decl_stmt|,
modifier|*
name|down2
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* look for fields that are not in an lvalue context, and rewrite them... */
specifier|register
name|NODE
modifier|*
name|shp
decl_stmt|;
specifier|register
name|s
operator|,
name|o
operator|,
name|v
operator|,
name|ty
expr_stmt|;
operator|*
name|down1
operator|=
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
operator|*
name|down2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|down
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
block|{
comment|/* rewrite the node */
if|if
condition|(
operator|!
name|rewfld
argument_list|(
name|p
argument_list|)
condition|)
return|return;
name|ty
operator|=
operator|(
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|2
operator|)
condition|?
name|LONG
else|:
name|INT
expr_stmt|;
name|v
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|s
operator|=
name|UPKFSZ
argument_list|(
name|v
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RTOLBYTES
name|o
operator|=
name|UPKFOFF
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* amount to shift */
else|#
directive|else
name|o
operator|=
name|szty
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|*
name|SZINT
operator|-
name|s
operator|-
name|UPKFOFF
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* amount to shift */
endif|#
directive|endif
comment|/* make& mask part */
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|=
name|ty
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|AND
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|=
name|ty
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|<<=
name|s
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|--
expr_stmt|;
comment|/* now, if a shift is needed, do it */
if|if
condition|(
name|o
operator|!=
literal|0
condition|)
block|{
name|shp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|op
operator|=
name|RS
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|type
operator|=
name|ty
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|right
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
operator|=
name|ty
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|=
name|o
expr_stmt|;
comment|/* amount to shift */
ifndef|#
directive|ifndef
name|FLEXNAMES
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|shp
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|shp
expr_stmt|;
comment|/* whew! */
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|oreg2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* look for situations where we can turn * into OREG */
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|register
name|r
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|ql
decl_stmt|,
modifier|*
name|qr
decl_stmt|;
name|CONSZ
name|temp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
name|temp
operator|=
name|q
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|r
operator|=
name|q
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|cp
operator|=
name|q
operator|->
name|in
operator|.
name|name
expr_stmt|;
goto|goto
name|ormake
goto|;
block|}
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|!=
name|PLUS
operator|&&
name|q
operator|->
name|in
operator|.
name|op
operator|!=
name|MINUS
condition|)
return|return;
name|ql
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|qr
operator|=
name|q
operator|->
name|in
operator|.
name|right
expr_stmt|;
ifdef|#
directive|ifdef
name|R2REGS
comment|/* look for doubly indexed expressions */
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|base
argument_list|(
name|ql
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|i
operator|=
name|offset
argument_list|(
name|qr
argument_list|,
name|tlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|makeor2
argument_list|(
name|p
argument_list|,
name|ql
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|=
name|base
argument_list|(
name|qr
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|i
operator|=
name|offset
argument_list|(
name|ql
argument_list|,
name|tlen
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|makeor2
argument_list|(
name|p
argument_list|,
name|qr
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|||
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|MINUS
operator|)
operator|&&
name|qr
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|ql
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|szty
argument_list|(
name|qr
operator|->
name|in
operator|.
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|temp
operator|=
name|qr
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|MINUS
condition|)
name|temp
operator|=
operator|-
name|temp
expr_stmt|;
name|r
operator|=
name|ql
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|temp
operator|+=
name|ql
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|cp
operator|=
name|qr
operator|->
name|in
operator|.
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|&&
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|MINUS
operator|||
operator|*
name|ql
operator|->
name|in
operator|.
name|name
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
name|cp
operator|=
name|ql
operator|->
name|in
operator|.
name|name
expr_stmt|;
name|ormake
label|:
if|if
condition|(
name|notoff
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|,
name|r
argument_list|,
name|temp
argument_list|,
name|cp
argument_list|)
condition|)
return|return;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|temp
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|cp
expr_stmt|;
endif|#
directive|endif
name|tfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_macro
name|canon
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* put p in canonical form */
name|int
name|oreg2
argument_list|()
decl_stmt|,
name|sucomp
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|FIELDOPS
name|int
name|ffld
parameter_list|()
function_decl|;
name|fwalk
argument_list|(
name|p
argument_list|,
name|ffld
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* look for field operators */
endif|#
directive|endif
name|walkf
argument_list|(
name|p
argument_list|,
name|oreg2
argument_list|)
expr_stmt|;
comment|/* look for and create OREG nodes */
ifdef|#
directive|ifdef
name|MYCANON
name|MYCANON
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* your own canonicalization routine(s) */
endif|#
directive|endif
name|walkf
argument_list|(
name|p
argument_list|,
name|sucomp
argument_list|)
expr_stmt|;
comment|/* do the Sethi-Ullman computation */
block|}
end_block

end_unit

