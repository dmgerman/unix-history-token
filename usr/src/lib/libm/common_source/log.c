begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)log.c	5.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"log_table.h"
end_include

begin_include
include|#
directive|include
file|"mathimpl.h"
end_include

begin_comment
comment|/* Table-driven natural logarithm.  *  * This code was derived, with minor modifications, from:  *	Peter Tang, "Table-Driven Implementation of the  *	Logarithm in IEEE Floating-Point arithmetic." ACM Trans.  *	Math Software, vol 16. no 4, pp 378-400, Dec 1990).  *  * Calculates log(2^m*F*(1+f/F)), |f/j|<= 1/256,  * where F = j/128 for j an integer in [0, 128].  *  * log(2^m) = log2_hi*m + log2_tail*m  * since m is an integer, the dominant term is exact.  * m has at most 10 digits (for subnormal numbers),  * and log2_hi has 11 trailing zero bits.  *  * log(F) = logF_hi[j] + logF_lo[j] is in tabular form in log_table.h  * logF_hi[] + 512 is exact.  *  * log(1+f/F) = 2*f/(2*F + f) + 1/12 * (2*f/(2*F + f))**3 + ...  * the leading term is calculated to extra precision in two  * parts, the larger of which adds exactly to the dominant  * m and F terms.  * There are two cases:  *	1. when m, j are non-zero (m | j), use absolute  *	   precision for the leading term.  *	2. when m = j = 0, |1-x|< 1/256, and log(x) ~= (x-1).  *	   In this case, use a relative precision of 24 bits.  * (This is done differently in the original paper)  *  * Special cases:  *	0	return signalling -Inf  *	neg	return signalling NaN  *	+Inf	return +Inf */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|_IEEE
value|0
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|x = (double) (float) (x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IEEE
value|1
end_define

begin_define
define|#
directive|define
name|endian
value|(((*(int *)&one)) ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|*(((int *)&x) + endian)&= 0xf8000000
end_define

begin_define
define|#
directive|define
name|infnan
parameter_list|(
name|x
parameter_list|)
value|0.0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
ifdef|#
directive|ifdef
name|_ANSI_SOURCE
name|log
parameter_list|(
name|double
name|x
parameter_list|)
else|#
directive|else
function|log
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|m
decl_stmt|,
name|j
decl_stmt|;
name|double
name|F
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|q
decl_stmt|,
name|u
decl_stmt|,
name|u2
decl_stmt|,
name|v
decl_stmt|,
name|zero
init|=
literal|0.0
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|;
name|double
name|logb
argument_list|()
decl_stmt|,
name|ldexp
argument_list|()
decl_stmt|;
specifier|volatile
name|double
name|u1
decl_stmt|;
comment|/* Catch special cases */
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|==
name|zero
condition|)
comment|/* log(0) = -Inf */
return|return
operator|(
operator|-
name|one
operator|/
name|zero
operator|)
return|;
elseif|else
if|if
condition|(
name|_IEEE
condition|)
comment|/* log(neg) = NaN */
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|==
name|zero
condition|)
comment|/* NOT REACHED IF _IEEE */
return|return
operator|(
name|infnan
argument_list|(
operator|-
name|ERANGE
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
name|_IEEE
condition|)
comment|/* x = NaN, Inf */
return|return
operator|(
name|x
operator|+
name|x
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
comment|/* Argument reduction: 1<= g< 2; x/2^m = g;	*/
comment|/* y = F*(1 + f/F) for |f|<= 2^-8		*/
name|m
operator|=
name|logb
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|x
argument_list|,
operator|-
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IEEE
operator|&&
name|m
operator|==
operator|-
literal|1022
condition|)
block|{
name|j
operator|=
name|logb
argument_list|(
name|g
argument_list|)
operator|,
name|m
operator|+=
name|j
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|g
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|N
operator|*
operator|(
name|g
operator|-
literal|1
operator|)
operator|+
literal|.5
expr_stmt|;
name|F
operator|=
operator|(
literal|1.0
operator|/
name|N
operator|)
operator|*
name|j
operator|+
literal|1
expr_stmt|;
comment|/* F*128 is an integer in [128, 512] */
name|f
operator|=
name|g
operator|-
name|F
expr_stmt|;
comment|/* Approximate expansion for log(1+f/F) ~= u + q */
name|g
operator|=
literal|1
operator|/
operator|(
literal|2
operator|*
name|F
operator|+
name|f
operator|)
expr_stmt|;
name|u
operator|=
literal|2
operator|*
name|f
operator|*
name|g
expr_stmt|;
name|v
operator|=
name|u
operator|*
name|u
expr_stmt|;
name|q
operator|=
name|u
operator|*
name|v
operator|*
operator|(
name|A1
operator|+
name|v
operator|*
operator|(
name|A2
operator|+
name|v
operator|*
operator|(
name|A3
operator|+
name|v
operator|*
name|A4
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* case 1: u1 = u rounded to 2^-43 absolute.  Since u< 2^-8,      * 	       u1 has at most 35 bits, and F*u1 is exact, as F has< 8 bits.      *         It also adds exactly to |m*log2_hi + log_F_head[j] |< 750     */
if|if
condition|(
name|m
operator||
name|j
condition|)
name|u1
operator|=
name|u
operator|+
literal|513
operator|,
name|u1
operator|-=
literal|513
expr_stmt|;
comment|/* case 2:	|1-x|< 1/256. The m- and j- dependent terms are zero;      * 		u1 = u to 24 bits.     */
else|else
name|u1
operator|=
name|u
operator|,
name|TRUNC
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|u2
operator|=
operator|(
literal|2.0
operator|*
operator|(
name|f
operator|-
name|F
operator|*
name|u1
operator|)
operator|-
name|u1
operator|*
name|f
operator|)
operator|*
name|g
expr_stmt|;
comment|/* u1 + u2 = 2f/(2F+f) to extra precision.	*/
comment|/* log(x) = log(2^m*F*(1+f/F)) =				*/
comment|/* (m*log2_hi+logF_head[j]+u1) + (m*log2_lo+logF_tail[j]+q);	*/
comment|/* (exact) + (tiny)						*/
name|u1
operator|+=
name|m
operator|*
name|logF_head
index|[
name|N
index|]
operator|+
name|logF_head
index|[
name|j
index|]
expr_stmt|;
comment|/* exact */
name|u2
operator|=
operator|(
name|u2
operator|+
name|logF_tail
index|[
name|j
index|]
operator|)
operator|+
name|q
expr_stmt|;
comment|/* tiny */
name|u2
operator|+=
name|logF_tail
index|[
name|N
index|]
operator|*
name|m
expr_stmt|;
return|return
operator|(
name|u1
operator|+
name|u2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Extra precision variant, returning  * struct {double a, b;}; log(x) = a+b to 63 bits, with  * a is rounded to 26 bits.  */
end_comment

begin_function
name|struct
name|Double
ifdef|#
directive|ifdef
name|_ANSI_SOURCE
name|log__D
parameter_list|(
name|double
name|x
parameter_list|)
else|#
directive|else
function|log__D
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|m
decl_stmt|,
name|j
decl_stmt|;
name|double
name|F
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|q
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|u2
decl_stmt|;
name|double
name|logb
argument_list|()
decl_stmt|,
name|ldexp
argument_list|()
decl_stmt|;
specifier|volatile
name|double
name|u1
decl_stmt|;
name|struct
name|Double
name|r
decl_stmt|;
comment|/* Argument reduction: 1<= g< 2; x/2^m = g;	*/
comment|/* y = F*(1 + f/F) for |f|<= 2^-8		*/
name|m
operator|=
name|logb
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|x
argument_list|,
operator|-
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IEEE
operator|&&
name|m
operator|==
operator|-
literal|1022
condition|)
block|{
name|j
operator|=
name|logb
argument_list|(
name|g
argument_list|)
operator|,
name|m
operator|+=
name|j
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|g
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|N
operator|*
operator|(
name|g
operator|-
literal|1
operator|)
operator|+
literal|.5
expr_stmt|;
name|F
operator|=
operator|(
literal|1.0
operator|/
name|N
operator|)
operator|*
name|j
operator|+
literal|1
expr_stmt|;
name|f
operator|=
name|g
operator|-
name|F
expr_stmt|;
name|g
operator|=
literal|1
operator|/
operator|(
literal|2
operator|*
name|F
operator|+
name|f
operator|)
expr_stmt|;
name|u
operator|=
literal|2
operator|*
name|f
operator|*
name|g
expr_stmt|;
name|v
operator|=
name|u
operator|*
name|u
expr_stmt|;
name|q
operator|=
name|u
operator|*
name|v
operator|*
operator|(
name|A1
operator|+
name|v
operator|*
operator|(
name|A2
operator|+
name|v
operator|*
operator|(
name|A3
operator|+
name|v
operator|*
name|A4
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator||
name|j
condition|)
name|u1
operator|=
name|u
operator|+
literal|513
operator|,
name|u1
operator|-=
literal|513
expr_stmt|;
else|else
name|u1
operator|=
name|u
operator|,
name|TRUNC
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|u2
operator|=
operator|(
literal|2.0
operator|*
operator|(
name|f
operator|-
name|F
operator|*
name|u1
operator|)
operator|-
name|u1
operator|*
name|f
operator|)
operator|*
name|g
expr_stmt|;
name|u1
operator|+=
name|m
operator|*
name|logF_head
index|[
name|N
index|]
operator|+
name|logF_head
index|[
name|j
index|]
expr_stmt|;
name|u2
operator|+=
name|logF_tail
index|[
name|j
index|]
expr_stmt|;
name|u2
operator|+=
name|q
expr_stmt|;
name|u2
operator|+=
name|logF_tail
index|[
name|N
index|]
operator|*
name|m
expr_stmt|;
name|r
operator|.
name|a
operator|=
name|u1
operator|+
name|u2
expr_stmt|;
comment|/* Only difference is here */
name|TRUNC
argument_list|(
name|r
operator|.
name|a
argument_list|)
expr_stmt|;
name|r
operator|.
name|b
operator|=
operator|(
name|u1
operator|-
name|r
operator|.
name|a
operator|)
operator|+
name|u2
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

