begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)jn.c	1.1 (ELEFUNT) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/* 	floating point Bessel's function of 	the first and second kinds and of 	integer order.  	int n; 	double x; 	jn(n,x);  	returns the value of Jn(x) for all 	integer values of n and all real values 	of x.  	There are no error returns. 	Calls j0, j1.  	For n=0, j0(x) is called, 	for n=1, j1(x) is called, 	for n<x, forward recursion us used starting 	from values of j0(x) and j1(x). 	for n>x, a continued fraction approximation to 	j(n,x)/j(n-1,x) is evaluated and then backward 	recursion is used starting from a supposed value 	for j(n,x). The resulting value of j(0,x) is 	compared with the actual value to correct the 	supposed value of j(n,x).  	yn(n,x) is similar in all respects, except 	that forward recursion is used for all 	values of n>1. */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IEEE double */
end_comment

begin_decl_stmt
specifier|static
name|double
name|zero
init|=
literal|0.e0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|jn
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|double
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|temp
decl_stmt|;
name|double
name|xsq
decl_stmt|,
name|t
decl_stmt|;
name|double
name|j0
argument_list|()
decl_stmt|,
name|j1
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|j0
argument_list|(
name|x
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
operator|(
name|j1
argument_list|(
name|x
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|0.
condition|)
return|return
operator|(
literal|0.
operator|)
return|;
if|if
condition|(
name|n
operator|>
name|x
condition|)
goto|goto
name|recurs
goto|;
name|a
operator|=
name|j0
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|b
operator|=
name|j1
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
literal|2.
operator|*
name|i
operator|/
name|x
operator|)
operator|*
name|b
operator|-
name|a
expr_stmt|;
name|a
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
name|recurs
label|:
name|xsq
operator|=
name|x
operator|*
name|x
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
operator|,
name|i
operator|=
name|n
operator|+
literal|16
init|;
name|i
operator|>
name|n
condition|;
name|i
operator|--
control|)
block|{
name|t
operator|=
name|xsq
operator|/
operator|(
literal|2.
operator|*
name|i
operator|-
name|t
operator|)
expr_stmt|;
block|}
name|t
operator|=
name|x
operator|/
operator|(
literal|2.
operator|*
name|n
operator|-
name|t
operator|)
expr_stmt|;
name|a
operator|=
name|t
expr_stmt|;
name|b
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|temp
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
literal|2.
operator|*
name|i
operator|/
name|x
operator|)
operator|*
name|b
operator|-
name|a
expr_stmt|;
name|a
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|*
name|j0
argument_list|(
name|x
argument_list|)
operator|/
name|b
operator|)
return|;
block|}
end_function

begin_function
name|double
name|yn
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|double
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|double
name|a
decl_stmt|,
name|b
decl_stmt|,
name|temp
decl_stmt|;
name|double
name|y0
argument_list|()
decl_stmt|,
name|y1
argument_list|()
decl_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
specifier|extern
name|double
name|infnan
parameter_list|()
function_decl|;
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
comment|/* NaN */
else|#
directive|else
comment|/* IEEE double */
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
comment|/* IEEE machines: invalid operation */
endif|#
directive|endif
block|}
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
operator|==
literal|1
condition|)
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|y0
argument_list|(
name|x
argument_list|)
operator|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
operator|(
name|sign
operator|*
name|y1
argument_list|(
name|x
argument_list|)
operator|)
return|;
name|a
operator|=
name|y0
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|b
operator|=
name|y1
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|b
expr_stmt|;
name|b
operator|=
operator|(
literal|2.
operator|*
name|i
operator|/
name|x
operator|)
operator|*
name|b
operator|-
name|a
expr_stmt|;
name|a
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|sign
operator|*
name|b
operator|)
return|;
block|}
end_function

end_unit

