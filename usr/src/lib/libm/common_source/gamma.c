begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)gamma.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* METHOD:  * x< 0: Use reflection formula, G(x) = pi/(sin(pi*x)*x*G(x))  * 	At negative integers, return +Inf, and set errno.  *  * x< 6.5: use one of two rational approximation,  *	to log(G(x)), expanded around 2 for x near integral;  *	around the minimum for x near half-integral.  The two  *	regions overlap.  *	In the range [2.0, 2.5], it is necessary to expand around 2.  *	In the range ~[1.462-.22, 1.462+.25], the expansion around  *	the minimum is necessary to get<1ulp accuracy.  *  * x>= 6.5: Use the asymptotic approximation (Stirling's formula.)  *  *	log(G(x)) ~= (x-.5)*(log(x)-1) + .5(log(2*pi)-1) + 1/x*P(1/(x*x))  *  *	Keep extra precision in multiplying (x-.5)(log(x)-1), to  *	avoid premature round-off.  *  * Special values:  NaN, +/-Inf, 0, Negative Integers.  *	Neg integer: Set overflow trap; return +Inf; errno = EDOM  *	+Inf: Return +Inf; errno = ERANGE;  *	-Inf: Return +Inf; errno = EDOM;  *	NaN:  Return NaN; errno = EDOM; */
end_comment

begin_define
define|#
directive|define
name|x0
value|.461632144968362356785
end_define

begin_define
define|#
directive|define
name|LEFT
value|-.3955078125
end_define

begin_define
define|#
directive|define
name|a0_hi
value|0.88560319441088874992
end_define

begin_define
define|#
directive|define
name|a0_lo
value|-.00000000000000004996427036469019695
end_define

begin_define
define|#
directive|define
name|lns2pi_hi
value|0.418945312500000
end_define

begin_define
define|#
directive|define
name|lns2pi_lo
value|-.000006779295327258219670263595
end_define

begin_define
define|#
directive|define
name|UNDERFL
value|(1e-1020 * 1e-1020)
end_define

begin_function_decl
name|double
name|small_gam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|smaller_gam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|Double
name|large_gam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|double
name|neg_gam
parameter_list|(
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|Double
name|ratfun_gam
parameter_list|(
name|double
parameter_list|,
name|double
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/** #define NP 5 static double P[] = { 	0.57410538218150719558252603747, 	0.24541366696467897812183878159, 	0.00513973619299223308948265654, 	0.00129391688253677823901288679, 	0.00222188711638167000692045683 }; #define NQ 9 static double Q[] = { 	1.33984375, 	0.981446340605471312379393111769, 	-0.19172028764767945485658628968, 	-0.13543838178180836462338731962, 	0.028432780865671299780350622655, 	0.004720852857293747484312973484, 	-0.00162320758342873413572482466, 	8.63879091186865255905247274e-05, 	5.67776543645974456238616906e-06, 	-1.1130244665113561369974706e-08 }; /**/
end_comment

begin_define
define|#
directive|define
name|P0
value|.621389571821820863029017800727g
end_define

begin_define
define|#
directive|define
name|P1
value|.265757198651533466104979197553,
end_define

begin_define
define|#
directive|define
name|P2
value|.00553859446429917461063308081748,
end_define

begin_define
define|#
directive|define
name|P3
value|.00138456698304096573887145282811,
end_define

begin_define
define|#
directive|define
name|P4
value|.00240659950032711365819348969808
end_define

begin_define
define|#
directive|define
name|Q0
value|1.4501953125
end_define

begin_define
define|#
directive|define
name|Q1
value|1.06258521948016171343454061571
end_define

begin_define
define|#
directive|define
name|Q2
value|-.207474561943859936441469926649
end_define

begin_define
define|#
directive|define
name|Q3
value|-.146734131782005422506287573015
end_define

begin_define
define|#
directive|define
name|Q4
value|.0307878176156175520361557573779
end_define

begin_define
define|#
directive|define
name|Q5
value|.00512449347980666221336054633184
end_define

begin_define
define|#
directive|define
name|Q6
value|-.00176012741431666995019222898833
end_define

begin_define
define|#
directive|define
name|Q7
value|.0000935021023573788935372153030556
end_define

begin_define
define|#
directive|define
name|Q8
value|.00000613275507472443958924745652239
end_define

begin_define
define|#
directive|define
name|Pa0
value|.0833333333333333148296162562474
end_define

begin_define
define|#
directive|define
name|Pa1
value|-.00277777777774548123579378966497
end_define

begin_define
define|#
directive|define
name|Pa2
value|.000793650778754435631476282786423
end_define

begin_define
define|#
directive|define
name|Pa3
value|-.000595235082566672847950717262222
end_define

begin_define
define|#
directive|define
name|Pa4
value|.000841428560346653702135821806252
end_define

begin_define
define|#
directive|define
name|Pa5
value|-.00189773526463879200348872089421
end_define

begin_define
define|#
directive|define
name|Pa6
value|.00569394463439411649408050664078
end_define

begin_define
define|#
directive|define
name|Pa7
value|-.0144705562421428915453880392761
end_define

begin_decl_stmt
specifier|static
name|struct
name|Double
name|large_gam
name|__P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|neg_gam
name|__P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Double
name|ratfun_gam
name|__P
argument_list|(
operator|(
name|double
operator|,
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|small_gam
name|__P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|smaller_gam
name|__P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|gamma
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|zero
init|=
literal|0
decl_stmt|;
name|struct
name|Double
name|u
decl_stmt|;
if|if
condition|(
name|x
operator|>
literal|6
operator|+
name|x0
operator|+
name|LEFT
condition|)
block|{
if|if
condition|(
name|x
operator|>
literal|171.63
condition|)
return|return
operator|(
literal|1.0
operator|/
name|zero
operator|)
return|;
name|u
operator|=
name|large_gam
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|exp__D
argument_list|(
name|u
operator|.
name|a
argument_list|,
name|u
operator|.
name|b
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|1.0
operator|+
name|LEFT
operator|+
name|x0
condition|)
return|return
operator|(
name|small_gam
argument_list|(
name|x
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|>
literal|1e-18
condition|)
return|return
operator|(
name|smaller_gam
argument_list|(
name|x
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
literal|1
operator|+
literal|1e-20
expr_stmt|;
comment|/* raise inexact flag */
return|return
operator|(
literal|1
operator|/
name|x
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
return|return
operator|(
name|neg_gam
argument_list|(
name|x
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* x = NaN */
name|errno
operator|=
name|EDOM
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* TRUNC sets trailing bits in a floating-point number to zero.  * is a temporary variable. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|_IEEE
value|0
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|(double) (float) (x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IEEE
value|1
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|*(((int *)&x) + 1)&= 0xf8000000
end_define

begin_define
define|#
directive|define
name|infnan
parameter_list|(
name|x
parameter_list|)
value|0.0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Accurate to max(ulp(1/128) absolute, 2^-75 relative) error. */
end_comment

begin_function
specifier|static
name|struct
name|Double
name|large_gam
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|z
decl_stmt|,
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|Double
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|pua
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|u
operator|.
name|a
operator|,
name|pua
operator|++
expr_stmt|;
name|pva
operator|=
operator|(
name|long
operator|*
operator|)
operator|&
name|v
operator|.
name|a
operator|,
name|pva
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|infinity
argument_list|()
condition|)
block|{
name|u
operator|.
name|b
operator|=
literal|0
operator|,
name|u
operator|.
name|a
operator|=
name|x
expr_stmt|;
return|return
name|u
return|;
block|}
name|z
operator|=
literal|1.0
operator|/
operator|(
name|x
operator|*
name|x
operator|)
expr_stmt|;
name|p
operator|=
name|Pa0
operator|+
name|z
operator|*
operator|(
name|Pa1
operator|+
name|z
operator|*
operator|(
name|Pa2
operator|+
name|z
operator|*
operator|(
name|Pa3
operator|+
name|z
operator|*
operator|(
name|Pa4
operator|+
name|z
operator|*
name|Pa5
operator|+
name|z
operator|*
operator|(
name|Pa6
operator|+
name|z
operator|*
name|Pa7
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|p
operator|/
name|x
expr_stmt|;
comment|/* |e|< 2.8e-18 */
comment|/* 0< p< 1/64 (at x = 5.5) */
name|u
operator|=
name|log__D
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|u
operator|.
name|a
operator|-=
literal|1.0
expr_stmt|;
name|v
operator|.
name|a
operator|=
operator|(
name|x
operator|-=
literal|.5
operator|)
expr_stmt|;
name|TRUNC
argument_list|(
name|v
operator|.
name|a
argument_list|)
expr_stmt|;
name|v
operator|.
name|b
operator|=
name|x
operator|-
name|v
operator|.
name|a
expr_stmt|;
name|t
operator|.
name|a
operator|=
name|v
operator|.
name|a
operator|*
name|u
operator|.
name|a
expr_stmt|;
comment|/* t = (x-.5)*(log(x)-1) */
name|t
operator|.
name|b
operator|=
name|v
operator|.
name|b
operator|*
name|u
operator|.
name|a
operator|+
name|x
operator|*
name|u
operator|.
name|b
expr_stmt|;
comment|/* return t.a + t.b + lns2pi_hi + lns2pi_lo + p */
name|t
operator|.
name|b
operator|+=
name|lns2pi_lo
expr_stmt|;
name|t
operator|.
name|b
operator|+=
name|p
expr_stmt|;
comment|/* small pieces (< 1/64, assuming t< 1e14) */
name|u
operator|.
name|a
operator|=
name|lns2pi_hi
operator|+
name|t
operator|.
name|b
expr_stmt|;
name|u
operator|.
name|a
operator|+=
name|t
operator|.
name|a
expr_stmt|;
name|u
operator|.
name|b
operator|=
name|t
operator|.
name|a
operator|-
name|u
operator|.
name|a
expr_stmt|;
name|u
operator|.
name|b
operator|+=
name|lns2pi_hi
expr_stmt|;
name|u
operator|.
name|b
operator|+=
name|t
operator|.
name|b
expr_stmt|;
return|return
operator|(
name|u
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Good to< 1 ulp.  (provably .90 ulp; .87 ulp on 1,000,000 runs.)    It also has correct monotonicity.  */
end_comment

begin_function
specifier|static
name|double
name|small_gam
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|y
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|Double
name|yy
decl_stmt|,
name|r
decl_stmt|;
name|pt
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|t
operator|)
operator|+
literal|1
expr_stmt|;
name|pra
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|r
operator|.
name|a
operator|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|<=
literal|1.0
operator|+
operator|(
name|LEFT
operator|+
name|x0
operator|)
condition|)
block|{
name|yy
operator|=
name|ratfun_gam
argument_list|(
name|y
operator|-
name|x0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|yy
operator|.
name|a
operator|+
name|yy
operator|.
name|b
operator|)
return|;
block|}
name|r
operator|.
name|a
operator|=
name|y
operator|--
expr_stmt|;
name|TRUNC
argument_list|(
name|r
operator|.
name|a
argument_list|)
expr_stmt|;
name|yy
operator|.
name|a
operator|=
name|r
operator|.
name|a
operator|-
literal|1.0
expr_stmt|;
name|yy
operator|.
name|b
operator|=
name|r
operator|.
name|b
operator|=
name|y
operator|-
name|yy
operator|.
name|a
expr_stmt|;
for|for
control|(
init|;
operator|--
name|y
operator|>
literal|1.0
operator|+
operator|(
name|LEFT
operator|+
name|x0
operator|)
condition|;
name|yy
operator|.
name|a
operator|--
control|)
block|{
name|t
operator|=
name|r
operator|.
name|a
operator|*
name|yy
operator|.
name|a
expr_stmt|;
name|r
operator|.
name|b
operator|=
name|r
operator|.
name|a
operator|*
name|yy
operator|.
name|b
operator|+
name|y
operator|*
name|r
operator|.
name|b
expr_stmt|;
name|r
operator|.
name|a
operator|=
name|t
operator|+
name|r
operator|.
name|b
expr_stmt|;
name|TRUNC
argument_list|(
name|r
operator|.
name|a
argument_list|)
expr_stmt|;
name|t
operator|-=
name|r
operator|.
name|a
expr_stmt|;
name|r
operator|.
name|b
operator|+=
name|t
expr_stmt|;
block|}
comment|/* now want r * gamma(y); */
name|yy
operator|=
name|ratfun_gam
argument_list|(
name|y
operator|-
name|x0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|y
operator|=
name|r
operator|.
name|b
operator|*
operator|(
name|yy
operator|.
name|a
operator|+
name|yy
operator|.
name|b
operator|)
operator|+
name|r
operator|.
name|a
operator|*
name|yy
operator|.
name|b
expr_stmt|;
name|y
operator|+=
name|yy
operator|.
name|a
operator|*
name|r
operator|.
name|a
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Good on (0, 1+x0+LEFT].  Accurate to 1ulp on [.25+x0+LEFT, 1+x0+LEFT].  * Below this, x+LEFT-x0 introduces additional rounding errror of .5ulp.  */
end_comment

begin_function
specifier|static
name|double
name|smaller_gam
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|t
decl_stmt|,
name|d
decl_stmt|;
name|struct
name|Double
name|r
decl_stmt|,
name|xx
decl_stmt|;
if|if
condition|(
name|x
operator|<
name|x0
operator|+
name|LEFT
condition|)
block|{
name|t
operator|=
name|x
operator|,
name|TRUNC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|t
operator|+
name|x
operator|)
operator|*
operator|(
name|x
operator|-
name|t
operator|)
expr_stmt|;
name|t
operator|*=
name|t
expr_stmt|;
name|xx
operator|.
name|a
operator|=
operator|(
operator|(
name|d
operator|+
name|t
operator|)
operator|+
name|x
operator|)
operator|,
name|TRUNC
argument_list|(
name|xx
operator|.
name|a
argument_list|)
expr_stmt|;
name|xx
operator|.
name|b
operator|=
name|x
operator|-
name|xx
operator|.
name|a
expr_stmt|;
name|xx
operator|.
name|b
operator|+=
name|t
expr_stmt|;
name|xx
operator|.
name|b
operator|+=
name|d
expr_stmt|;
name|t
operator|=
operator|(
literal|1.0
operator|-
name|x0
operator|)
expr_stmt|;
name|t
operator|+=
name|x
expr_stmt|;
name|d
operator|=
operator|(
literal|1.0
operator|-
name|x0
operator|)
expr_stmt|;
name|d
operator|-=
name|t
expr_stmt|;
name|d
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|xx
operator|.
name|a
operator|+
name|xx
operator|.
name|b
expr_stmt|;
block|}
else|else
block|{
name|xx
operator|.
name|a
operator|=
name|x
operator|,
name|TRUNC
argument_list|(
name|xx
operator|.
name|a
argument_list|)
expr_stmt|;
name|xx
operator|.
name|b
operator|=
name|x
operator|-
name|xx
operator|.
name|a
expr_stmt|;
name|t
operator|=
name|x
operator|-
name|x0
expr_stmt|;
name|d
operator|=
operator|(
operator|-
name|x0
operator|-
name|t
operator|)
expr_stmt|;
name|d
operator|+=
name|x
expr_stmt|;
block|}
name|r
operator|=
name|ratfun_gam
argument_list|(
name|t
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|r
operator|.
name|a
operator|/
name|x
operator|,
name|TRUNC
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|r
operator|.
name|a
operator|-=
name|d
operator|*
name|xx
operator|.
name|a
expr_stmt|;
name|r
operator|.
name|a
operator|-=
name|d
operator|*
name|xx
operator|.
name|b
expr_stmt|;
name|r
operator|.
name|a
operator|+=
name|r
operator|.
name|b
expr_stmt|;
return|return
operator|(
name|d
operator|+
name|r
operator|.
name|a
operator|/
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns (z+c)^2 * P(z)/Q(z) + a0 */
end_comment

begin_function
specifier|static
name|struct
name|Double
name|ratfun_gam
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|)
name|double
name|z
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|double
name|p
decl_stmt|,
name|q
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|struct
name|Double
name|r
decl_stmt|;
name|q
operator|=
name|Q0
operator|+
name|z
operator|*
operator|(
name|Q1
operator|+
name|z
operator|*
operator|(
name|Q2
operator|+
name|z
operator|*
operator|(
name|Q3
operator|+
name|z
operator|*
operator|(
name|Q4
operator|+
name|z
operator|*
operator|(
name|Q5
operator|+
name|z
operator|*
operator|(
name|Q6
operator|+
name|z
operator|*
operator|(
name|Q7
operator|+
name|z
operator|*
name|Q8
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|P0
operator|+
name|z
operator|*
operator|(
name|P1
operator|+
name|z
operator|*
operator|(
name|P2
operator|+
name|z
operator|*
operator|(
name|P3
operator|+
name|z
operator|*
name|P4
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* return r.a + r.b = a0 + (z+c)^2 * p/q, with r.a truncated to 26 bits. */
name|p
operator|=
name|p
operator|/
name|q
expr_stmt|;
name|hi
operator|=
name|z
operator|,
name|TRUNC
argument_list|(
name|hi
argument_list|)
expr_stmt|;
comment|/* hi+lo ~= z + c */
name|lo
operator|=
name|z
operator|-
name|hi
expr_stmt|;
name|lo
operator|+=
name|c
expr_stmt|;
name|lo
operator|*=
operator|(
name|hi
operator|+
name|z
operator|)
expr_stmt|;
comment|/* q+lo = (z+c)*(z+c) */
name|q
operator|=
name|hi
operator|*
name|hi
expr_stmt|;
name|hi
operator|=
operator|(
name|q
operator|+
name|lo
operator|)
operator|,
name|TRUNC
argument_list|(
name|hi
argument_list|)
expr_stmt|;
comment|/* hi+lo = q+lo */
name|q
operator|-=
name|hi
expr_stmt|;
name|lo
operator|+=
name|q
expr_stmt|;
name|z
operator|=
name|p
operator|,
name|TRUNC
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* z+q = p */
name|q
operator|=
name|p
operator|-
name|z
expr_stmt|;
name|lo
operator|=
name|lo
operator|*
name|p
operator|+
name|hi
operator|*
name|q
operator|+
name|a0_lo
expr_stmt|;
name|hi
operator|*=
name|z
expr_stmt|;
name|r
operator|.
name|a
operator|=
name|hi
operator|+
name|a0_hi
operator|,
name|TRUNC
argument_list|(
name|r
operator|.
name|a
argument_list|)
expr_stmt|;
name|r
operator|.
name|b
operator|=
operator|(
operator|(
name|a0_hi
operator|-
name|r
operator|.
name|a
operator|)
operator|+
name|hi
operator|)
operator|+
name|lo
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|lpi_hi
value|1.1447298858494001638
end_define

begin_define
define|#
directive|define
name|lpi_lo
value|.0000000000000000102659511627078262
end_define

begin_comment
comment|/* Error: within 3.5 ulp for x< 171.  For large x, see lgamma. */
end_comment

begin_function
specifier|static
name|double
name|neg_gam
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|int
name|sgn
init|=
literal|1
decl_stmt|;
name|struct
name|Double
name|lg
decl_stmt|,
name|lsine
decl_stmt|;
name|double
name|y
decl_stmt|,
name|z
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|,
name|zero
init|=
literal|0.0
decl_stmt|;
name|y
operator|=
name|floor
argument_list|(
name|x
operator|+
literal|.5
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|x
condition|)
block|{
if|if
condition|(
operator|-
name|x
operator|==
name|infinity
argument_list|()
condition|)
block|{
comment|/* G(-inf) = NaN */
name|errno
operator|=
name|EDOM
expr_stmt|;
return|return
operator|(
name|signaling_nan
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
operator|(
name|one
operator|/
name|zero
operator|)
return|;
comment|/* G(-(integer) -> oo */
block|}
name|z
operator|=
name|fabs
argument_list|(
name|x
operator|-
name|y
argument_list|)
expr_stmt|;
name|y
operator|=
name|ceil
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|*
literal|.5
operator|==
name|ceil
argument_list|(
literal|.5
operator|*
name|y
argument_list|)
condition|)
block|{
name|sgn
operator|=
operator|-
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"neg\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|1
operator|-
operator|(
literal|6
operator|+
name|x0
operator|+
name|LEFT
operator|)
condition|)
block|{
if|if
condition|(
name|x
operator|<
operator|-
literal|190
condition|)
block|{
name|UNDERFL
expr_stmt|;
name|z
operator|=
literal|.5
operator|*
name|ceil
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|==
name|ceil
argument_list|(
name|z
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|y
operator|=
literal|1
operator|-
name|x
expr_stmt|;
if|if
condition|(
literal|1
operator|-
name|y
operator|==
name|x
condition|)
block|{
name|lg
operator|=
name|large_gam
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|lsine
operator|=
name|log__D
argument_list|(
name|sin
argument_list|(
name|M_PI
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|-
name|x
expr_stmt|;
name|lg
operator|=
name|large_gam
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|lsine
operator|=
name|log__D
argument_list|(
name|x
operator|*
name|sin
argument_list|(
name|M_PI
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lg
operator|.
name|b
operator|+=
name|lsine
operator|.
name|b
operator|-
name|lpi_lo
expr_stmt|;
name|y
operator|=
operator|(
operator|-
operator|(
name|lg
operator|.
name|b
operator|+
name|lsine
operator|.
name|a
operator|)
operator|+
name|lpi_hi
operator|)
operator|-
name|lg
operator|.
name|a
expr_stmt|;
name|z
operator|=
operator|-
name|lg
operator|.
name|a
operator|-
name|y
expr_stmt|;
name|z
operator|+=
name|lpi_hi
expr_stmt|;
name|z
operator|-=
name|lsine
operator|.
name|a
expr_stmt|;
name|z
operator|-=
name|lg
operator|.
name|b
expr_stmt|;
name|y
operator|=
name|exp__D
argument_list|(
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgn
operator|<
literal|0
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
name|y
operator|=
literal|1
operator|-
name|x
expr_stmt|;
if|if
condition|(
literal|1
operator|-
name|y
operator|==
name|x
condition|)
name|y
operator|=
name|ngamma
argument_list|(
name|y
argument_list|)
expr_stmt|;
else|else
comment|/* 1-x is inexact */
name|y
operator|=
operator|-
name|x
operator|*
name|ngamma
argument_list|(
operator|-
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgn
operator|<
literal|0
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
return|return
operator|(
name|M_PI
operator|/
operator|(
name|y
operator|*
name|sin
argument_list|(
name|M_PI
operator|*
name|z
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

end_unit

