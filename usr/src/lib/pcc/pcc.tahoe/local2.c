begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)local2.c	1.32 (Berkeley) 2/29/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|putstr
parameter_list|(
name|s
parameter_list|)
value|fputs((s), stdout)
end_define

begin_define
define|#
directive|define
name|ISCHAR
parameter_list|(
name|p
parameter_list|)
value|(p->in.type == UCHAR || p->in.type == CHAR)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FORT
end_ifdef

begin_decl_stmt
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a lot of the machine dependent parts of the second pass */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|n
parameter_list|)
value|((1L<<n)-1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|lineid
argument_list|(
argument|l
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* identify line l and file fn */
name|printf
argument_list|(
literal|"#	line %d, file %s\n"
argument_list|,
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|ent_mask
decl_stmt|;
end_decl_stmt

begin_macro
name|eobl2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|OFFSZ
name|spoff
decl_stmt|;
comment|/* offset from stack pointer */
ifndef|#
directive|ifndef
name|FORT
specifier|extern
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
endif|#
directive|endif
name|spoff
operator|=
name|maxoff
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORT
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"	.set	.F%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SHOULD BE L%d ... ftnno but must change pc/f77 */
name|printf
argument_list|(
literal|"	.set	LF%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"	.set	LWM%d,0x%x\n"
argument_list|,
name|ftnno
argument_list|,
name|ent_mask
operator|&
literal|0x1ffc
operator||
literal|0x1000
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"	.set	L%d,0x%x\n"
argument_list|,
name|ftnno
argument_list|,
name|ent_mask
operator|&
literal|0x1ffc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|ftlab1
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoff
operator|>
name|AUTOINIT
condition|)
name|printf
argument_list|(
literal|"	subl3	$%ld,fp,sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|ftlab2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ent_mask
operator|=
literal|0
expr_stmt|;
name|maxargs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|hoptab
block|{
name|int
name|opmask
decl_stmt|;
name|char
modifier|*
name|opstring
decl_stmt|;
block|}
name|ioptab
index|[]
init|=
block|{
name|PLUS
block|,
literal|"add"
block|,
name|MINUS
block|,
literal|"sub"
block|,
name|MUL
block|,
literal|"mul"
block|,
name|DIV
block|,
literal|"div"
block|,
name|MOD
block|,
literal|"div"
block|,
name|OR
block|,
literal|"or"
block|,
name|ER
block|,
literal|"xor"
block|,
name|AND
block|,
literal|"and"
block|,
operator|-
literal|1
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|hopcode
argument_list|(
argument|f
argument_list|,
argument|o
argument_list|)
end_macro

begin_block
block|{
comment|/* output the appropriate string from the above table */
specifier|register
name|struct
name|hoptab
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
name|o
operator|=
name|NOASG
name|o
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ioptab
init|;
name|q
operator|->
name|opmask
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|opmask
operator|==
name|o
condition|)
block|{
if|if
condition|(
name|f
operator|==
literal|'E'
condition|)
name|printf
argument_list|(
literal|"e%s"
argument_list|,
name|q
operator|->
name|opstring
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|q
operator|->
name|opstring
argument_list|,
name|tolower
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cerror
argument_list|(
literal|"no hoptab for %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
comment|/* keyed to register number tokens */
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"fp"
block|,
literal|"sp"
block|,
literal|"pc"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output register name and update entry mask */
end_comment

begin_function
name|char
modifier|*
name|rname
parameter_list|(
name|r
parameter_list|)
specifier|register
name|int
name|r
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|istreg
argument_list|(
name|r
argument_list|)
condition|)
name|ent_mask
operator||=
literal|1
operator|<<
name|r
expr_stmt|;
return|return
operator|(
name|rnames
index|[
name|r
index|]
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|rstatus
index|[]
init|=
block|{
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|, 	}
decl_stmt|;
end_decl_stmt

begin_macro
name|tlen
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
name|SZSHORT
operator|/
name|SZCHAR
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
name|SZDOUBLE
operator|/
name|SZCHAR
operator|)
return|;
default|default:
return|return
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|mixtypes
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TWORD
name|tp
decl_stmt|,
name|tq
decl_stmt|;
name|tp
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|tq
operator|=
name|q
operator|->
name|in
operator|.
name|type
expr_stmt|;
return|return
operator|(
operator|(
name|tp
operator|==
name|FLOAT
operator|||
name|tp
operator|==
name|DOUBLE
operator|)
operator|!=
operator|(
name|tq
operator|==
name|FLOAT
operator|||
name|tq
operator|==
name|DOUBLE
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|prtype
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|n
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLOAT
case|:
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
return|return;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
name|putchar
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"zzzcode- bad type"
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|zzzcode
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* logical ops, turned into 0-1 */
comment|/* use register given by register 1 */
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|bn
operator|.
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	clrl	%s\n"
argument_list|,
name|rname
argument_list|(
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
name|cbgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|bn
operator|.
name|label
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
comment|/* i *= f; asgops with int lhs and float rhs */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|lt
decl_stmt|,
name|rt
decl_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|s
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|rt
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|lt
operator|=
name|l
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
name|INT
operator|&&
name|lt
operator|!=
name|UNSIGNED
condition|)
block|{
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|ISUNSIGNED
argument_list|(
name|lt
argument_list|)
condition|?
name|UNSIGNED
else|:
name|INT
expr_stmt|;
name|zzzcode
argument_list|(
name|s
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|lt
argument_list|)
condition|)
block|{
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|lt
operator|==
name|UNSIGNED
condition|?
name|l
else|:
name|resc
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|rt
expr_stmt|;
name|unsigned_to_float
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putstr
argument_list|(
literal|"cvl"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|lt
operator|==
name|INT
condition|?
name|l
else|:
name|resc
argument_list|)
expr_stmt|;
block|}
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|hopcode
argument_list|(
name|rt
operator|==
name|FLOAT
condition|?
literal|'F'
else|:
literal|'D'
argument_list|,
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|lt
argument_list|)
condition|)
block|{
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
comment|/* we need only the type */
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|UNSIGNED
expr_stmt|;
name|float_to_unsigned
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putstr
argument_list|(
literal|"\n\tcv"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|INT
condition|)
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
else|else
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lt
operator|!=
name|INT
condition|)
block|{
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|right
operator|=
name|resc
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|lt
expr_stmt|;
name|zzzcode
argument_list|(
name|s
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
case|case
literal|'J'
case|:
comment|/* unsigned DIV/MOD with constant divisors */
block|{
specifier|register
name|int
name|ck
init|=
name|INAREG
decl_stmt|;
name|int
name|label1
decl_stmt|,
name|label2
decl_stmt|;
comment|/* case constant<= 1 is handled by optim() in pass 1 */
comment|/* case constant< 0x80000000 is handled in table */
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
comment|/* case DIV: handled in optim2() */
case|case
name|MOD
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|==
name|resc
operator|->
name|tn
operator|.
name|rval
condition|)
goto|goto
name|asgmod
goto|;
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"movl\tAL,A1\n\tcmpl\tA1,AR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjlssu\tL%d\n"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tsubl2\tAR,A1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASG
name|DIV
case|:
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|label2
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"cmpl\tAL,AR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjgequ\tL%d\n"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tmovl\t$1,AL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjbr\tL%d\nL%d:\n"
argument_list|,
name|label2
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tclrl\tAL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|label2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASG
name|MOD
case|:
name|asgmod
label|:
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"cmpl\tAL,AR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjlssu\tL%d\n"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tsubl2\tAR,AL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
case|case
literal|'B'
case|:
comment|/* get oreg value in temp register for shift */
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|r
argument_list|)
operator|==
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
condition|)
name|putstr
argument_list|(
literal|"movl"
argument_list|)
expr_stmt|;
else|else
block|{
name|putstr
argument_list|(
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
literal|"movz"
else|:
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'C'
case|:
comment|/* generate 'call[fs] $bytes' */
block|{
specifier|extern
name|int
name|gc_numbytes
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|gc_numbytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"call%c	$%d"
argument_list|,
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|gc_numbytes
operator|<
literal|60
operator|)
condition|?
literal|'f'
else|:
literal|'s'
argument_list|,
name|gc_numbytes
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* don't change to double (here's the only place to catch it) */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|rtyflg
operator|=
literal|1
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
comment|/* INCR and DECR */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|expand
argument_list|(
name|p
argument_list|,
name|INAREG
argument_list|,
literal|"movl\tAL,A1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|expand
argument_list|(
name|p
argument_list|,
name|INAREG
argument_list|,
literal|"ldd\tAL\n\tstd\tA1"
argument_list|)
expr_stmt|;
else|else
name|zzzcode
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
literal|'U'
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n	"
argument_list|)
expr_stmt|;
case|case
literal|'E'
case|:
comment|/* INCR and DECR, FOREFF */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
literal|1
condition|)
block|{
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"inc"
else|:
literal|"dec"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'E'
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|expand
argument_list|(
name|p
argument_list|,
name|INAREG
argument_list|,
literal|"ldZL\tAL\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|)
name|expand
argument_list|(
name|p
argument_list|,
name|INAREG
argument_list|,
literal|"addZL\tAR\n\tstZL\tAL"
argument_list|)
expr_stmt|;
else|else
comment|/* DECR */
name|expand
argument_list|(
name|p
argument_list|,
name|INAREG
argument_list|,
literal|"subZL\tAR\n\tstZL\tAL"
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"add"
else|:
literal|"sub"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2	"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* masked constant for fields */
name|printf
argument_list|(
name|ACONFMT
argument_list|,
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|fldsz
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|fldshf
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
comment|/* produce value of bitfield assignment */
comment|/* avoid shifts -- shifts are SLOW on this machine */
comment|/* XXX this wouldn't be necessary if we were smarter 			       and masked BEFORE shifting XXX */
block|{
specifier|register
name|NODE
modifier|*
name|r
init|=
name|p
operator|->
name|in
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|putstr
argument_list|(
literal|"movl\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|ACONFMT
argument_list|,
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|fldsz
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putstr
argument_list|(
literal|"andl3\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|ACONFMT
argument_list|,
operator|(
literal|1
operator|<<
name|fldsz
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'H'
case|:
comment|/* opcode for shift */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ASG
name|LS
condition|)
name|putstr
argument_list|(
literal|"shll"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"shrl"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"shar"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
comment|/* type of left operand */
case|case
literal|'R'
case|:
comment|/* type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'M'
case|:
block|{
comment|/* initiate ediv for mod and unsigned div */
name|putstr
argument_list|(
literal|"clrl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tmovl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|upput
argument_list|(
name|resc
argument_list|,
name|SZLONG
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tjgeq\tL%d\n\tmnegl\t$1,"
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'T'
case|:
block|{
comment|/* rounded structure length for arguments */
name|int
name|size
init|=
name|p
operator|->
name|stn
operator|.
name|stsize
decl_stmt|;
name|SETOFF
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"movab	-%d(sp),sp"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'S'
case|:
comment|/* structure assignment */
name|stasg
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|I_don_t_understand_this
case|case
literal|'X'
case|:
comment|/* multiplication for short and char */
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tmovz"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tcvt"
argument_list|)
expr_stmt|;
name|zzzcode
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
operator|&
name|resc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\tmovz"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tcvt"
argument_list|)
expr_stmt|;
name|zzzcode
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
operator|&
name|resc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'U'
case|:
comment|/* SCONV */
case|case
literal|'V'
case|:
comment|/* SCONV with FORCC */
name|sconv
argument_list|(
name|p
argument_list|,
name|c
operator|==
literal|'V'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
block|{
comment|/* SCONV or ASSIGN float/double => unsigned */
name|NODE
modifier|*
name|src
init|=
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|?
name|p
operator|->
name|in
operator|.
name|left
else|:
name|p
operator|->
name|in
operator|.
name|right
decl_stmt|;
name|putstr
argument_list|(
literal|"ld"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|float_to_unsigned
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'Y'
case|:
comment|/* SCONV or ASSIGN unsigned => float/double */
name|unsigned_to_float
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* stores into accumulator */
name|putstr
argument_list|(
literal|"\n\tst"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
else|else
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|rtyflg
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|I_don_t_understand_this
case|case
literal|'Z'
case|:
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|SHORT
case|:
block|{
name|short
name|w
init|=
name|p
operator|->
name|tn
operator|.
name|lval
decl_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|w
expr_stmt|;
break|break;
block|}
case|case
name|CHAR
case|:
block|{
name|char
name|c
init|=
name|p
operator|->
name|tn
operator|.
name|lval
decl_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|cerror
argument_list|(
literal|"illegal zzzcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MOVB
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|off
parameter_list|)
value|{ \ 	putstr("\tmovb\t"); upput(src, off); putchar(','); \ 	upput(dst, off); putchar('\n'); \ }
end_define

begin_define
define|#
directive|define
name|MOVW
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|off
parameter_list|)
value|{ \ 	putstr("\tmovw\t"); upput(src, off); putchar(','); \ 	upput(dst, off); putchar('\n'); \ }
end_define

begin_define
define|#
directive|define
name|MOVL
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|off
parameter_list|)
value|{ \ 	putstr("\tmovl\t"); upput(src, off); putchar(','); \ 	upput(dst, off); putchar('\n'); \ }
end_define

begin_comment
comment|/*  * Generate code for a structure assignment.  */
end_comment

begin_expr_stmt
name|stasg
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|STASG
case|:
comment|/* regular assignment */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
break|break;
case|case
name|STARG
case|:
comment|/* place arg on the stack */
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"STASG bad"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * Pun source for use in code generation. 	 */
switch|switch
condition|(
name|r
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|NAME
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"STASG-r"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|65535
condition|)
name|cerror
argument_list|(
literal|"structure size out of range"
argument_list|)
expr_stmt|;
comment|/* 	 * Generate optimized code based on structure size 	 * and alignment properties.... 	 */
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|putstr
argument_list|(
literal|"\tmovb\t"
argument_list|)
expr_stmt|;
name|optimized
label|:
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|2
condition|)
block|{
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
name|SZCHAR
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovb\t"
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|"\tmovw\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
case|case
literal|4
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|4
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|2
condition|)
block|{
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|3
operator|*
name|SZCHAR
argument_list|)
expr_stmt|;
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|2
operator|*
name|SZCHAR
argument_list|)
expr_stmt|;
name|MOVB
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|1
operator|*
name|SZCHAR
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovb\t"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MOVW
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
name|SZSHORT
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovw\t"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|putstr
argument_list|(
literal|"\tmovl\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
case|case
literal|6
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|!=
literal|2
condition|)
goto|goto
name|movblk
goto|;
name|MOVW
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|2
operator|*
name|SZSHORT
argument_list|)
expr_stmt|;
name|MOVW
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
literal|1
operator|*
name|SZSHORT
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovw\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
case|case
literal|8
case|:
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stalign
operator|==
literal|4
condition|)
block|{
name|MOVL
argument_list|(
name|l
argument_list|,
name|r
argument_list|,
name|SZLONG
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\tmovl\t"
argument_list|)
expr_stmt|;
goto|goto
name|optimized
goto|;
block|}
comment|/* fall thru...*/
default|default:
name|movblk
label|:
comment|/* 		 * Can we ever get a register conflict with R1 here? 		 */
name|putstr
argument_list|(
literal|"\tmovab\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
name|r
operator|->
name|tn
operator|.
name|rval
operator|==
name|R1
condition|)
block|{
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",r0\n\tmovab\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|",r1\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|",r1\n\tmovab\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",r0\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\tmovl\t$%d,r2\n\tmovblk\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|rname
argument_list|(
name|R2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Reverse above pun for reclaim. 	 */
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert a float or double in the accumulator into an unsigned int.  * Unlike the vax, the tahoe stores 0 into the destination  *	on a conversion of> 2 ** 31, so we compensate.  */
end_comment

begin_macro
name|float_to_unsigned
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|l
init|=
name|p
operator|->
name|in
operator|.
name|left
decl_stmt|;
name|int
name|label1
init|=
name|getlab
argument_list|()
decl_stmt|;
name|int
name|label2
init|=
name|getlab
argument_list|()
decl_stmt|;
name|int
name|label3
init|=
name|getlab
argument_list|()
decl_stmt|;
name|NODE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|src
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|dst
operator|=
name|resc
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|dst
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".data\n\t.align\t2\nL%d:\n\t.long\t0x50000000"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|putstr
argument_list|(
literal|", 0x00000000 # .double"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|" # .float"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|" 2147483648\n\t.text\n\tcmp"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tL%d\n\tjlss\tL%d\n\tsub"
argument_list|,
name|label1
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tL%d\n\tcv"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\taddl2\t$-2147483648,"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tjbr\tL%d\nL%d:\n\tcv"
argument_list|,
name|label3
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nL%d:"
argument_list|,
name|label3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Convert an unsigned int into a float or double, leaving the result  *	in the accumulator.  */
end_comment

begin_expr_stmt
name|unsigned_to_float
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|label1
init|=
name|getlab
argument_list|()
decl_stmt|;
name|int
name|label2
init|=
name|getlab
argument_list|()
decl_stmt|;
name|NODE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|src
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|dst
operator|=
name|resc
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|dst
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".data\n\t.align\t2\nL%d:\n\t.long\t0x50800000"
argument_list|,
name|label2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|putstr
argument_list|(
literal|", 0x00000000 # .double"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|" # .float"
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|" 4294967296\n\t.text\n\tmovl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tcvl"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tjgeq\tL%d\n\tadd"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tL%d\nL%d:"
argument_list|,
name|label2
argument_list|,
name|label1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Prlen() is a cheap prtype()...  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|convtab
index|[
name|SZINT
operator|/
name|SZCHAR
operator|+
literal|1
index|]
init|=
block|{
literal|'?'
block|,
literal|'b'
block|,
literal|'w'
block|,
literal|'?'
block|,
literal|'l'
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|prlen
parameter_list|(
name|len
parameter_list|)
value|putchar(convtab[len])
end_define

begin_comment
comment|/*  * Generate code for integral scalar conversions.  * Some of this code is designed to work around a tahoe misfeature  *	that causes sign- and zero- extension to be defeated in  *	certain circumstances.  * Basically if the source operand of a CVT or MOVZ instruction is  *	shorter than the destination, and the source is a register  *	or an immediate constant, sign- and zero- extension are  *	ignored and the high bits of the source are copied.  (Note  *	that zero-extension is not a problem for immediate  *	constants.)  * Another problem -- condition codes for a conversion with a  *	register source reflect the source rather than the destination.  */
end_comment

begin_macro
name|sconv
argument_list|(
argument|p
argument_list|,
argument|forcc
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forcc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|tmp
decl_stmt|;
specifier|register
name|int
name|srclen
decl_stmt|,
name|dstlen
decl_stmt|;
name|int
name|srctype
decl_stmt|,
name|dsttype
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|neg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ASSIGN
condition|)
block|{
name|src
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|dst
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|dstlen
operator|=
name|tlen
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|dsttype
operator|=
name|dst
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|src
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|dst
operator|=
name|resc
expr_stmt|;
name|dstlen
operator|=
name|tlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dsttype
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
else|else
comment|/* if (p->in.op == OPLEAF) */
block|{
name|src
operator|=
name|p
expr_stmt|;
name|dst
operator|=
name|resc
expr_stmt|;
name|dstlen
operator|=
name|SZINT
operator|/
name|SZCHAR
expr_stmt|;
name|dsttype
operator|=
name|ISUNSIGNED
argument_list|(
name|src
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
name|UNSIGNED
else|:
name|INT
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
name|srclen
operator|=
name|SZINT
operator|/
name|SZCHAR
expr_stmt|;
name|srctype
operator|=
name|ISUNSIGNED
argument_list|(
name|src
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
name|UNSIGNED
else|:
name|INT
expr_stmt|;
block|}
else|else
block|{
name|srclen
operator|=
name|tlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|srctype
operator|=
name|src
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
if|if
condition|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|src
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|src
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
condition|)
block|{
name|putstr
argument_list|(
literal|"clr"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dstlen
operator|<
name|srclen
condition|)
block|{
switch|switch
condition|(
name|dsttype
condition|)
block|{
case|case
name|CHAR
case|:
name|src
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|char
operator|)
name|src
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|src
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|unsigned
name|char
operator|)
name|src
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|src
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|short
operator|)
name|src
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|src
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|unsigned
name|short
operator|)
name|src
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dst
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
name|dsttype
operator|=
name|INT
expr_stmt|;
name|dstlen
operator|=
name|SZINT
operator|/
name|SZCHAR
expr_stmt|;
block|}
name|srctype
operator|=
name|dsttype
expr_stmt|;
name|srclen
operator|=
name|dstlen
expr_stmt|;
name|val
operator|=
operator|-
name|src
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
operator|(
literal|1
operator|<<
name|dstlen
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|val
operator|<
literal|64
condition|)
block|{
name|src
operator|->
name|tn
operator|.
name|lval
operator|=
name|val
expr_stmt|;
operator|++
name|neg
expr_stmt|;
comment|/* MNEGx may be shorter */
block|}
block|}
if|if
condition|(
name|srclen
operator|<
name|dstlen
condition|)
block|{
if|if
condition|(
name|srctype
operator|==
name|CHAR
operator|&&
name|dsttype
operator|==
name|USHORT
operator|&&
name|dst
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
comment|/* (unsigned short) c; => sign extend to 16 bits */
name|putstr
argument_list|(
literal|"cvtbl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|",-(sp)\n\tmovzwl\t2(sp),"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tmovab\t4(sp),sp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forcc
condition|)
block|{
name|putstr
argument_list|(
literal|"\n\ttstl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|genconv
argument_list|(
name|ISUNSIGNED
argument_list|(
name|srctype
argument_list|)
argument_list|,
name|srclen
argument_list|,
name|dst
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|?
name|SZINT
operator|/
name|SZCHAR
else|:
name|dstlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|forcc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|srclen
operator|>
name|dstlen
operator|&&
name|dst
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
comment|/* if dst is a register, the result must look like an int */
if|if
condition|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|ISUNSIGNED
argument_list|(
name|dsttype
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
literal|1
operator|<<
name|dstlen
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|tn
operator|.
name|rval
operator|==
name|dst
operator|->
name|tn
operator|.
name|rval
condition|)
comment|/* conversion in place */
name|printf
argument_list|(
literal|"andl2\t$%ld,"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"andl3\t$%ld,"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Sign extension in register can also be 			 * accomplished by shifts, but unfortunately 			 * shifts are extremely slow, due to the lack 			 * of a barrel shifter. 			 */
name|putstr
argument_list|(
literal|"pushl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tcvt"
argument_list|)
expr_stmt|;
name|prlen
argument_list|(
name|dstlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"l\t%d(sp),"
argument_list|,
name|SZINT
operator|/
name|SZCHAR
operator|-
name|dstlen
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\tmovab\t4(sp),sp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forcc
condition|)
block|{
name|putstr
argument_list|(
literal|"\n\ttstl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|tmp
operator|=
name|talloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
operator|)
operator|||
operator|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|src
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|)
operator|||
operator|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|src
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
condition|)
block|{
comment|/* we can increment src's address& pun it */
operator|*
name|tmp
operator|=
operator|*
name|src
expr_stmt|;
name|tmp
operator|->
name|tn
operator|.
name|lval
operator|+=
name|srclen
operator|-
name|dstlen
expr_stmt|;
block|}
else|else
block|{
comment|/* we must store src's address */
operator|*
name|tmp
operator|=
operator|*
name|dst
expr_stmt|;
name|putstr
argument_list|(
literal|"mova"
argument_list|)
expr_stmt|;
name|prlen
argument_list|(
name|srclen
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tn
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|tmp
operator|->
name|tn
operator|.
name|lval
operator|=
name|srclen
operator|-
name|dstlen
expr_stmt|;
block|}
name|genconv
argument_list|(
name|ISUNSIGNED
argument_list|(
name|dsttype
argument_list|)
argument_list|,
name|dstlen
argument_list|,
name|SZINT
operator|/
name|SZCHAR
argument_list|,
name|tmp
argument_list|,
name|dst
argument_list|,
name|forcc
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
name|genconv
argument_list|(
name|neg
condition|?
operator|-
literal|1
else|:
name|ISUNSIGNED
argument_list|(
name|dsttype
argument_list|)
argument_list|,
name|srclen
argument_list|,
name|dst
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|?
name|SZINT
operator|/
name|SZCHAR
else|:
name|dstlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|forcc
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|genconv
argument_list|(
argument|srcflag
argument_list|,
argument|srclen
argument_list|,
argument|dstlen
argument_list|,
argument|src
argument_list|,
argument|dst
argument_list|,
argument|forcc
argument_list|)
end_macro

begin_decl_stmt
name|int
name|srcflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|srclen
decl_stmt|,
name|dstlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forcc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|srclen
operator|!=
name|dstlen
condition|)
block|{
if|if
condition|(
name|srcflag
operator|>
literal|0
operator|&&
name|srclen
operator|<
name|dstlen
condition|)
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prlen
argument_list|(
name|srclen
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srcflag
operator|<
literal|0
condition|)
name|putstr
argument_list|(
literal|"mneg"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"mov"
argument_list|)
expr_stmt|;
name|prlen
argument_list|(
name|dstlen
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
comment|/* 	 * This hack is made necessary by architecture problems 	 *	described above 	 */
if|if
condition|(
name|forcc
operator|&&
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|srclen
operator|>
name|dstlen
condition|)
block|{
name|putstr
argument_list|(
literal|"\n\ttst"
argument_list|)
expr_stmt|;
name|prlen
argument_list|(
name|dstlen
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|rmove
argument_list|(
argument|rt
argument_list|,
argument|rs
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"	movl	%s,%s\n"
argument_list|,
name|rname
argument_list|(
name|rs
argument_list|)
argument_list|,
name|rname
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|DOUBLE
condition|)
name|printf
argument_list|(
literal|"	movl	%s,%s\n"
argument_list|,
name|rname
argument_list|(
name|rs
operator|+
literal|1
argument_list|)
argument_list|,
name|rname
argument_list|(
name|rt
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|respref
name|respref
index|[]
init|=
block|{
name|INTAREG
operator||
name|INTBREG
block|,
name|INTAREG
operator||
name|INTBREG
block|,
name|INAREG
operator||
name|INBREG
block|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
operator||
name|SNAME
operator||
name|SCON
block|,
name|INTEMP
block|,
name|INTEMP
block|,
name|FORARG
block|,
name|FORARG
block|,
name|INTEMP
block|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setregs
argument_list|()
end_macro

begin_block
block|{
comment|/* set up temporary registers */
name|fregs
operator|=
literal|6
expr_stmt|;
comment|/* tbl- 6 free regs on Tahoe (0-5) */
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|szty
end_ifndef

begin_macro
name|szty
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* size, in registers, needed to hold thing of type t */
return|return
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|2
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rewfld
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|callreg
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|R0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|base
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|100
operator|)
return|;
comment|/* ie no base reg */
if|if
condition|(
name|o
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MINUS
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|NAME
condition|)
return|return
operator|(
literal|100
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|offset
argument_list|(
name|p
argument_list|,
name|tyl
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tyl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tyl
operator|==
literal|1
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
literal|1
operator|<<
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|)
operator|==
name|tyl
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|tyl
operator|==
literal|2
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|==
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|rval
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|makeor2
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
specifier|register
name|NODE
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|,
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|t
decl_stmt|;
name|NODE
modifier|*
name|f
decl_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* have to free this subtree later */
comment|/* init base */
switch|switch
condition|(
name|q
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
case|case
name|REG
case|:
case|case
name|OREG
case|:
case|case
name|NAME
case|:
name|t
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
case|case
name|PLUS
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|right
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal makeor2"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|t
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
name|t
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
block|}
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|t
operator|->
name|in
operator|.
name|name
expr_stmt|;
endif|#
directive|endif
comment|/* init offset */
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|R2PACK
argument_list|(
operator|(
name|b
operator|&
literal|0177
operator|)
argument_list|,
name|o
argument_list|,
operator|(
name|b
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|canaddr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|shltype
end_ifndef

begin_expr_stmt
name|shltype
argument_list|(
name|o
argument_list|,
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|flshape
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* INTEMP shapes must not contain any temporary registers */
end_comment

begin_expr_stmt
name|shtemp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|REG
case|:
return|return
operator|(
operator|!
name|istreg
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
return|;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|istreg
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|R2UPK2
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|istreg
argument_list|(
name|r
argument_list|)
operator|)
return|;
case|case
name|UNARY
name|MUL
case|:
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|UNARY
name|MUL
operator|&&
name|shtemp
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|optype
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
operator|!=
name|LTYPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shumul
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
block|{
name|printf
argument_list|(
literal|"\nshumul:op=%d,lop=%d,rop=%d"
argument_list|,
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" prname=%s,plty=%d, prlval=%D\n"
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
argument_list|,
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|,
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|NAME
operator|||
operator|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
operator|||
name|o
operator|==
name|ICON
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|type
operator|!=
name|PTR
operator|+
name|DOUBLE
condition|)
return|return
operator|(
name|STARNM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|special
argument_list|(
name|p
argument_list|,
name|shape
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|shape
operator|==
name|SIREG
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|adrcon
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|ACONFMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal conput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|insput
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"insput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Output the address of the second item in the  * pair pointed to by p.  */
end_comment

begin_expr_stmt
name|upput
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|CONSZ
name|save
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
case|case
name|OREG
case|:
name|save
operator|=
name|p
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|+=
name|size
operator|/
name|SZCHAR
expr_stmt|;
name|adrput
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|save
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|size
operator|==
name|SZLONG
condition|)
block|{
name|putstr
argument_list|(
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall thru... */
default|default:
name|cerror
argument_list|(
literal|"illegal upper address op %s size %d"
argument_list|,
name|opst
index|[
name|p
operator|->
name|tn
operator|.
name|op
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
end_block

begin_expr_stmt
name|adrput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|;
comment|/* output an address, with offsets, from p */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
comment|/* for entry mask */
operator|(
name|void
operator|)
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* double indexing */
specifier|register
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|R2UPK3
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rname
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|rname
argument_list|(
name|R2UPK2
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|==
name|FP
operator|&&
name|p
operator|->
name|tn
operator|.
name|lval
operator|>
literal|0
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"(fp)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rname
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* STARNM or STARREG found */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|STARNM
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal address"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|acon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* print out a constant */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure valued call */
return|return
operator|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|genfcall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|static
name|char
modifier|*
name|funcops
index|[
literal|6
index|]
init|=
block|{
literal|"sin"
block|,
literal|"cos"
block|,
literal|"sqrt"
block|,
literal|"exp"
block|,
literal|"log"
block|,
literal|"atan"
block|}
decl_stmt|;
comment|/* generate function opcodes */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|FORTCALL
operator|&&
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|&&
operator|(
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p1
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
operator|&&
name|p1
operator|->
name|in
operator|.
name|type
operator|==
name|INCREF
argument_list|(
name|FTN
operator||
name|FLOAT
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FLEXNAMES
name|p1
operator|->
name|in
operator|.
name|name
operator|++
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|p1
operator|->
name|in
operator|.
name|name
argument_list|,
name|p1
operator|->
name|in
operator|.
name|name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
literal|6
condition|;
name|m
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p1
operator|->
name|in
operator|.
name|name
argument_list|,
name|funcops
index|[
name|m
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|m
operator|>=
literal|6
condition|)
name|uerror
argument_list|(
literal|"no opcode for fortarn function %s"
argument_list|,
name|p1
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|uerror
argument_list|(
literal|"illegal type of fortarn function"
argument_list|)
expr_stmt|;
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FORTCALL
expr_stmt|;
if|if
condition|(
operator|!
name|canaddr
argument_list|(
name|p1
argument_list|)
condition|)
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
argument_list|)
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|int
name|gc_numbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate the call given by p */
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|,
modifier|*
name|ptemp
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
name|temp
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|STCALL
condition|)
block|{
comment|/* set aside room for structure return */
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stsize
operator|>
name|temp
condition|)
name|temp1
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
else|else
name|temp1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|>
name|maxargs
condition|)
name|maxargs
operator|=
name|temp
expr_stmt|;
name|SETOFF
argument_list|(
name|temp1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
block|{
comment|/* make temp node, put offset in, and generate args */
name|ptemp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|ptemp
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|ptemp
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
literal|1
expr_stmt|;
name|ptemp
operator|->
name|tn
operator|.
name|rval
operator|=
name|SP
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|ptemp
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|ptemp
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|ptemp
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|ptemp
operator|->
name|in
operator|.
name|su
operator|=
literal|0
expr_stmt|;
name|genargs
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|,
name|ptemp
argument_list|)
expr_stmt|;
name|ptemp
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
operator|||
name|R2TEST
argument_list|(
name|p1
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|NAME
condition|)
block|{
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* tbl 	setup gc_numbytes so reference to ZC works */
name|gc_numbytes
operator|=
name|temp
operator|&
operator|(
literal|0x3ff
operator|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ccbranches
index|[]
init|=
block|{
literal|"eql"
block|,
literal|"neq"
block|,
literal|"leq"
block|,
literal|"lss"
block|,
literal|"geq"
block|,
literal|"gtr"
block|,
literal|"lequ"
block|,
literal|"lssu"
block|,
literal|"gequ"
block|,
literal|"gtru"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cbgen
argument_list|(
argument|o
argument_list|,
argument|lab
argument_list|,
argument|mode
argument_list|)
end_macro

begin_block
block|{
comment|/*   printf conditional and unconditional branches */
if|if
condition|(
name|o
operator|!=
literal|0
operator|&&
operator|(
name|o
operator|<
name|EQ
operator|||
name|o
operator|>
name|UGT
operator|)
condition|)
name|cerror
argument_list|(
literal|"bad conditional branch: %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	j%s	L%d\n"
argument_list|,
name|o
operator|==
literal|0
condition|?
literal|"br"
else|:
name|ccbranches
index|[
name|o
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nextcook
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* we have failed to match p with cookie; try another */
if|if
condition|(
name|cookie
operator|==
name|FORREW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hopeless! */
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
operator|)
condition|)
return|return
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
name|INTEMP
operator|)
operator|&&
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
return|return
operator|(
name|INTEMP
operator||
name|INAREG
operator||
name|INTAREG
operator||
name|INTBREG
operator||
name|INBREG
operator|)
return|;
return|return
operator|(
name|FORREW
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|lastchance
argument_list|(
argument|p
argument_list|,
argument|cook
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* forget it! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|optim2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* do local tree transformations and optimizations */
name|int
name|o
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
case|case
name|ASG
name|MINUS
case|:
case|case
name|ASG
name|MUL
case|:
case|case
name|ASG
name|OR
case|:
comment|/* simple ASG OPSIMP -- reduce range of constant rhs */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
name|mask
operator|&
operator|~
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
condition|)
name|r
operator|->
name|tn
operator|.
name|lval
operator||=
operator|~
name|mask
expr_stmt|;
else|else
name|r
operator|->
name|tn
operator|.
name|lval
operator|&=
name|mask
expr_stmt|;
block|}
break|break;
case|case
name|AND
case|:
case|case
name|ASG
name|AND
case|:
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* check for degenerate operations */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|ASG
name|AND
operator|||
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
name|i
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|mask
condition|)
block|{
comment|/* redundant mask */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* all bits masked off */
goto|goto
name|zero
goto|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
comment|/* sign extend */
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
name|mask
operator|&
operator|~
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
condition|)
name|r
operator|->
name|tn
operator|.
name|lval
operator||=
operator|~
name|mask
expr_stmt|;
else|else
name|r
operator|->
name|tn
operator|.
name|lval
operator|&=
name|mask
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|==
name|mask
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
comment|/* use movz instead of and */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|ENUNSIGN
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|su
operator|=
name|l
operator|->
name|in
operator|.
name|su
operator|>
literal|1
condition|?
name|l
operator|->
name|in
operator|.
name|su
else|:
literal|1
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCONV
case|:
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
return|return;
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|PCONV
condition|)
return|return;
if|if
condition|(
operator|(
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|CALL
operator|||
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|CALL
operator|)
operator|&&
name|l
operator|->
name|in
operator|.
name|type
operator|!=
name|INT
operator|&&
name|l
operator|->
name|in
operator|.
name|type
operator|!=
name|UNSIGNED
condition|)
return|return;
comment|/* Only trust it to get it right if the size is the same */
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|!=
name|tlen
argument_list|(
name|l
argument_list|)
condition|)
return|return;
comment|/* clobber conversion */
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|!=
name|FLD
condition|)
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
case|case
name|ASSIGN
case|:
comment|/* 		 * Conversions are equivalent to assignments; 		 * when the two operations are combined, 		 * we can sometimes zap the conversion. 		 */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
operator|&&
name|l
operator|->
name|in
operator|.
name|op
operator|!=
name|FLD
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
name|ULE
case|:
case|case
name|ULT
case|:
case|case
name|UGE
case|:
case|case
name|UGT
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|-=
operator|(
name|UGE
operator|-
name|GE
operator|)
expr_stmt|;
if|if
condition|(
name|degenerate
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|p
operator|->
name|in
operator|.
name|op
operator|+=
operator|(
name|UGE
operator|-
name|GE
operator|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|&&
name|l
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|&&
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
block|{
comment|/* nuke the conversions */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|l
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
comment|/* more? */
block|}
operator|(
name|void
operator|)
name|degenerate
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
operator|(
name|unsigned
operator|)
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|>=
literal|0x80000000
condition|)
block|{
comment|/* easy to do here, harder to do in zzzcode() */
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UGE
expr_stmt|;
break|break;
block|}
case|case
name|MOD
case|:
case|case
name|ASG
name|DIV
case|:
case|case
name|ASG
name|MOD
case|:
comment|/* 		 * optimize DIV and MOD 		 * 		 * basically we spot UCHAR and USHORT and try to do them 		 * as signed ints...  this may need tuning for the tahoe. 		 */
if|if
condition|(
name|degenerate
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|tlen
argument_list|(
name|l
argument_list|)
operator|>=
name|SZINT
operator|/
name|SZCHAR
operator|||
operator|!
operator|(
name|tlen
argument_list|(
name|r
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|||
operator|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
name|r
operator|->
name|tn
operator|.
name|type
operator|=
name|INT
expr_stmt|;
else|else
block|{
name|NODE
modifier|*
name|t
init|=
name|talloc
argument_list|()
decl_stmt|;
name|t
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|DIV
operator|||
name|o
operator|==
name|MOD
condition|)
block|{
name|NODE
modifier|*
name|t
init|=
name|talloc
argument_list|()
decl_stmt|;
name|t
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|t
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
block|}
comment|/* handle asgops in table */
break|break;
case|case
name|RS
case|:
case|case
name|ASG
name|RS
case|:
case|case
name|LS
case|:
case|case
name|ASG
name|LS
case|:
comment|/* pick up degenerate shifts */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
name|i
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
comment|/* front end 'fixes' this? */
if|if
condition|(
name|o
operator|==
name|LS
operator|||
name|o
operator|==
name|ASG
name|LS
condition|)
name|o
operator|+=
operator|(
name|RS
operator|-
name|LS
operator|)
expr_stmt|;
else|else
name|o
operator|+=
operator|(
name|LS
operator|-
name|RS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|RS
operator|||
name|o
operator|==
name|ASG
name|RS
operator|)
operator|&&
operator|!
name|ISUNSIGNED
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
comment|/* can't optimize signed right shifts */
break|break;
if|if
condition|(
name|o
operator|==
name|LS
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|SZINT
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
condition|)
break|break;
block|}
name|zero
label|:
if|if
condition|(
operator|!
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
if|if
condition|(
name|tshape
argument_list|(
name|l
argument_list|,
name|SAREG
operator||
name|SNAME
operator||
name|SCON
operator||
name|SOREG
operator||
name|STARNM
argument_list|)
condition|)
block|{
comment|/* no side effects */
name|tfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|COMOP
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|degenerate
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|o
decl_stmt|;
name|int
name|result
decl_stmt|,
name|i
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/* 	 * try to keep degenerate comparisons with constants 	 * out of the table. 	 */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
operator|||
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|tlen
argument_list|(
name|l
argument_list|)
operator|>=
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|l
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
name|lower
operator|=
operator|-
operator|(
literal|1
operator|<<
name|SZCHAR
operator|-
literal|1
operator|)
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZCHAR
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|lower
operator|=
operator|-
operator|(
literal|1
operator|<<
name|SZSHORT
operator|-
literal|1
operator|)
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZSHORT
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZSHORT
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"unsupported type in degenerate()"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|ASG
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|ASG
name|MOD
case|:
comment|/* DIV and MOD work like EQ */
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|lower
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|NE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|lower
operator|||
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|NE
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|LT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|lower
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
name|lower
condition|)
name|result
operator|=
name|o
operator|!=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LT
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|LE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|lower
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|>=
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|lower
condition|)
name|result
operator|=
name|o
operator|!=
name|LE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LE
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"unknown op in degenerate()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|MOD
operator|||
name|o
operator|==
name|ASG
name|MOD
condition|)
block|{
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|!=
name|ASG
name|DIV
operator|&&
name|tshape
argument_list|(
name|l
argument_list|,
name|SAREG
operator||
name|SNAME
operator||
name|SCON
operator||
name|SOREG
operator||
name|STARNM
argument_list|)
condition|)
block|{
comment|/* no side effects */
name|tfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|o
operator|==
name|ASG
name|DIV
condition|)
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
else|else
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|COMOP
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
name|logop
argument_list|(
name|o
argument_list|)
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|functbl
block|{
name|int
name|fop
decl_stmt|;
name|TWORD
name|ftype
decl_stmt|;
name|char
modifier|*
name|func
decl_stmt|;
block|}
name|opfunc
index|[]
init|=
block|{
name|DIV
block|,
name|TANY
block|,
literal|"udiv"
block|,
name|MOD
block|,
name|TANY
block|,
literal|"urem"
block|,
name|ASG
name|DIV
block|,
name|TANY
block|,
literal|"audiv"
block|,
name|ASG
name|MOD
block|,
name|TANY
block|,
literal|"aurem"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_expr_stmt
name|hardops
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change hard to do operators into function calls.  */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|functbl
modifier|*
name|f
decl_stmt|;
specifier|register
name|o
expr_stmt|;
name|NODE
modifier|*
name|old
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
operator|&&
operator|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
operator|)
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|opfunc
init|;
name|f
operator|->
name|fop
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|==
name|f
operator|->
name|fop
condition|)
goto|goto
name|convert
goto|;
block|}
return|return;
name|convert
label|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* 'J' in zzzcode() -- assumes DIV or MOD operations */
comment|/* save a subroutine call -- use at most 5 instructions */
return|return;
if|if
condition|(
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
condition|)
comment|/* optim2() will modify the op into an ordinary int op */
return|return;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|old
operator|=
name|NIL
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|FLD
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* 			 * rewrite (lval.fld /= rval); as 			 *  ((*temp).fld = udiv((*(temp =&lval)).fld,rval)); 			 * else the compiler will evaluate lval twice. 			 */
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
comment|/* first allocate a temp storage */
name|temp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|temp
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|temp
operator|->
name|tn
operator|.
name|rval
operator|=
name|TMPREG
expr_stmt|;
name|temp
operator|->
name|tn
operator|.
name|lval
operator|=
name|BITOOR
argument_list|(
name|freetemp
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|temp
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|temp
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|temp
expr_stmt|;
block|}
comment|/* fall thru ... */
case|case
name|REG
case|:
case|case
name|NAME
case|:
case|case
name|OREG
case|:
comment|/* change ASG OP to a simple OP */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|NOASG
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|tcopy
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|f
operator|-=
literal|2
expr_stmt|;
comment|/* Note: this depends on the table order */
comment|/* on the right side only - replace *temp with 			 *(temp =&lval), build the assignment node */
if|if
condition|(
name|old
condition|)
block|{
name|temp
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* the "*" node */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|temp
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|old
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|old
operator|->
name|in
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|q
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|temp
operator|->
name|in
operator|.
name|left
operator|=
name|q
expr_stmt|;
block|}
break|break;
case|case
name|UNARY
name|MUL
case|:
comment|/* avoid doing side effects twice */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"hardops: can't compute& LHS"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* build comma op for args to function */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|CM
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|CALL
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
comment|/* put function name in left node of call */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|FTN
operator|+
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|strcpy
argument_list|(
name|q
operator|->
name|in
operator|.
name|name
argument_list|,
name|f
operator|->
name|func
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
operator|=
name|f
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|zappost
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* look for ++ and -- operators and remove them */
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|INCR
case|:
case|case
name|DECR
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
comment|/* zap constant */
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixpre
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|PLUS
expr_stmt|;
break|break;
case|case
name|ASG
name|MINUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|MINUS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|NODE
modifier|*
name|addroreg
parameter_list|(
name|l
parameter_list|)
name|NODE
modifier|*
name|l
decl_stmt|;
comment|/* OREG was built in clocal() 				 * for an auto or formal parameter 				 * now its address is being taken 				 * local code must unwind it 				 * back to PLUS/MINUS REG ICON 				 * according to local conventions 				 */
block|{
name|cerror
argument_list|(
literal|"address of OREG taken"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
return|return
operator|(
name|mainp2
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|strip
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|NODE
modifier|*
name|q
decl_stmt|;
comment|/* strip nodes off the top when no side effects occur */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|SCONV
case|:
comment|/* remove lint tidbits */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
comment|/* could probably add a few more here */
default|default:
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|myreader
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|strip
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* strip off operations with no side effects */
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expands r-vals for fields */
name|walkf
argument_list|(
name|p
argument_list|,
name|hardops
argument_list|)
expr_stmt|;
comment|/* convert ops to function calls */
name|walkf
argument_list|(
name|p
argument_list|,
name|optim2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

