begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)c20.c	1.5 (Berkeley/CCI) 6/6/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	 C object code improver  */
end_comment

begin_include
include|#
directive|include
file|"c2.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|char
name|_sibuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|_sobuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ioflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|isn
init|=
literal|2000000
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|optab
modifier|*
name|oplook
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|optab
modifier|*
name|getline
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|long
name|lgensym
index|[
literal|10
index|]
init|=
block|{
literal|100000L
block|,
literal|200000L
block|,
literal|300000L
block|,
literal|400000L
block|,
literal|500000L
block|,
literal|600000L
block|,
literal|700000L
block|,
literal|800000L
block|,
literal|900000L
block|,
literal|1000000L
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|node
modifier|*
name|alloc
parameter_list|(
name|an
parameter_list|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|n
operator|=
name|an
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
expr_stmt|;
name|n
operator|&=
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lasta
operator|+
name|n
operator|>=
name|lastr
condition|)
block|{
if|if
condition|(
name|sbrk
argument_list|(
literal|2000
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Optimizer: out of space\n"
argument_list|)
expr_stmt|;
name|lastr
operator|+=
literal|2000
expr_stmt|;
block|}
name|p
operator|=
name|lasta
expr_stmt|;
name|lasta
operator|+=
name|n
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|node
operator|*
operator|)
name|p
operator|)
return|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|niter
decl_stmt|,
name|maxiter
decl_stmt|,
name|isend
decl_stmt|;
name|int
name|nflag
decl_stmt|,
name|infound
decl_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
name|infound
operator|=
literal|0
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
comment|/* get flags */
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|aobflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fortflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|infound
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|freopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"C2: can't find %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
operator|++
name|infound
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|freopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"C2: can't create %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|_sibuf
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
name|lasta
operator|=
name|lastr
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|opsetup
argument_list|()
expr_stmt|;
name|lasta
operator|=
name|firstr
operator|=
name|lastr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|maxiter
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|isend
operator|=
name|input
argument_list|()
expr_stmt|;
name|niter
operator|=
literal|0
expr_stmt|;
name|bmove
argument_list|()
expr_stmt|;
do|do
block|{
name|refcount
argument_list|()
expr_stmt|;
do|do
block|{
name|iterate
argument_list|()
expr_stmt|;
name|clearreg
argument_list|()
expr_stmt|;
name|niter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|nchange
condition|)
do|;
name|comjump
argument_list|()
expr_stmt|;
name|rmove
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|nchange
operator|||
name|jumpsw
argument_list|()
condition|)
do|;
name|addaob
argument_list|()
expr_stmt|;
name|interleave
argument_list|()
expr_stmt|;
name|output
argument_list|()
expr_stmt|;
if|if
condition|(
name|niter
operator|>
name|maxiter
condition|)
name|maxiter
operator|=
name|niter
expr_stmt|;
name|lasta
operator|=
name|firstr
expr_stmt|;
block|}
do|while
condition|(
name|isend
condition|)
do|;
if|if
condition|(
name|nflag
condition|)
block|{
name|score
argument_list|(
literal|"iterations"
argument_list|,
name|maxiter
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"jumps to jumps"
argument_list|,
name|nbrbr
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"inst. after jumps"
argument_list|,
name|iaftbr
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"jumps to .+1"
argument_list|,
name|njp1
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"redundant labels"
argument_list|,
name|nrlab
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"cross-jumps"
argument_list|,
name|nxjump
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"code motions"
argument_list|,
name|ncmot
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"branches reversed"
argument_list|,
name|nrevbr
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"redundant moves"
argument_list|,
name|redunm
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"simplified addresses"
argument_list|,
name|nsaddr
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"loops inverted"
argument_list|,
name|loopiv
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"redundant jumps"
argument_list|,
name|nredunj
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"common seqs before jmp's"
argument_list|,
name|ncomj
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"skips over jumps"
argument_list|,
name|nskip
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"aob's added"
argument_list|,
name|naob
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"redundant tst's"
argument_list|,
name|nrtst
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"jump on bit"
argument_list|,
name|nbj
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"redundant accumulator stores"
argument_list|,
name|nst
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"redundant accumulator loads"
argument_list|,
name|nld
argument_list|)
expr_stmt|;
name|score
argument_list|(
literal|"K core"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
name|lastr
operator|+
literal|01777
operator|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|score
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %s\n"
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|input
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|;
specifier|register
name|struct
name|optab
modifier|*
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|;
specifier|static
name|struct
name|optab
name|F77JSW
init|=
block|{
literal|".long"
block|,
name|JSW
block|,
literal|1
block|}
decl_stmt|;
name|lastp
operator|=
operator|&
name|first
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|top
label|:
name|op
operator|=
name|getline
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
operator|&&
name|op
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"? %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|opcod
condition|)
block|{
case|case
name|LABEL
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|labno
operator|=
name|locdef
argument_list|(
name|line
argument_list|)
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
operator|&&
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|line
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
name|p
operator|->
name|op
operator|=
name|LABEL
expr_stmt|;
name|p
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|labno
operator|<
literal|100000L
operator|&&
name|isn
operator|<=
name|p
operator|->
name|labno
condition|)
name|isn
operator|=
literal|1
operator|+
name|p
operator|->
name|labno
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|op
operator|=
name|DLABEL
expr_stmt|;
name|p
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LGEN
case|:
if|if
condition|(
operator|*
name|curlp
operator|!=
literal|'L'
operator|&&
operator|!
name|locuse
argument_list|(
name|curlp
argument_list|)
condition|)
goto|goto
name|std
goto|;
name|op
operator|=
operator|&
name|F77JSW
expr_stmt|;
case|case
name|JBR
case|:
if|if
condition|(
name|op
operator|->
name|opcod
operator|==
name|JBR
operator|&&
operator|(
name|op
operator|->
name|subopcod
operator|&
literal|0xF
operator|)
operator|==
name|RET
condition|)
goto|goto
name|std
goto|;
case|case
name|CBR
case|:
case|case
name|JMP
case|:
case|case
name|JSW
case|:
case|case
name|AOBLEQ
case|:
case|case
name|AOBLSS
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
operator|->
name|opcod
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|op
operator|->
name|subopcod
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|curlp
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp1
argument_list|)
operator|||
literal|0
operator|==
operator|(
name|p
operator|->
name|labno
operator|=
name|locuse
argument_list|(
name|cp1
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|*
name|cp1
operator|!=
literal|'L'
operator|||
literal|0
operator|==
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|cp1
operator|+
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* jbs, etc.? */
while|while
condition|(
operator|*
name|cp1
operator|++
condition|)
empty_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp1
operator|!=
literal|','
operator|&&
name|cp1
operator|!=
name|curlp
condition|)
empty_stmt|;
if|if
condition|(
name|cp1
operator|==
name|curlp
operator|||
operator|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|++
name|cp1
argument_list|)
operator|||
literal|0
operator|==
operator|(
name|p
operator|->
name|labno
operator|=
name|locuse
argument_list|(
name|cp1
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|*
name|cp1
operator|!=
literal|'L'
operator|||
literal|0
operator|==
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|cp1
operator|+
literal|1
argument_list|)
operator|)
operator|)
condition|)
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|--
name|cp1
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isn
operator|<=
name|p
operator|->
name|labno
condition|)
name|isn
operator|=
literal|1
operator|+
name|p
operator|->
name|labno
expr_stmt|;
break|break;
case|case
name|MOVA
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
operator|->
name|opcod
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|op
operator|->
name|subopcod
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|curlp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cp1
index|[
operator|-
literal|1
index|]
operator|==
literal|'L'
operator|||
name|isdigit
argument_list|(
name|cp1
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|p
operator|->
name|labno
operator|=
name|locuse
argument_list|(
name|curlp
argument_list|)
operator|)
operator|||
literal|0
operator|!=
operator|(
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|curlp
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|cp1
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|cp1
operator|=
literal|','
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
operator|--
name|cp1
argument_list|)
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|MOV
case|:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
operator|->
name|opcod
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|op
operator|->
name|subopcod
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|cp1
operator|=
name|curlp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cp1
index|[
operator|-
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|cp1
index|[
literal|0
index|]
operator|==
literal|'L'
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|cp1
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
operator|*
operator|--
name|cp1
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|curlp
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOVBLK
case|:
comment|/* used implicitly */
name|curlp
operator|=
literal|"(r0),(r1),(r2)"
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|SET
case|:
case|case
name|COMM
case|:
case|case
name|LCOMM
case|:
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
case|case
name|BSS
case|:
case|case
name|DATA
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|line
argument_list|,
operator|(
name|op
operator|->
name|opcod
operator|==
name|LABEL
condition|?
literal|':'
else|:
literal|'\n'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|opcod
operator|==
name|TEXT
condition|)
goto|goto
name|top
goto|;
if|if
condition|(
name|END
operator|==
operator|(
name|op
operator|=
name|getline
argument_list|()
operator|)
operator|->
name|opcod
condition|)
block|{
comment|/* dangling .data is bad for you */
name|printf
argument_list|(
literal|".text\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|std
label|:
default|default:
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
operator|->
name|opcod
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|op
operator|->
name|subopcod
expr_stmt|;
name|p
operator|->
name|labno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
name|copy
argument_list|(
name|curlp
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|forw
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|lastp
expr_stmt|;
name|p
operator|->
name|pop
operator|=
name|op
expr_stmt|;
name|lastp
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CASE
condition|)
block|{
name|char
modifier|*
name|lp
decl_stmt|;
name|int
name|ncase
decl_stmt|;
name|lp
operator|=
name|curlp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
empty_stmt|;
while|while
condition|(
operator|*
operator|--
name|lp
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|ncase
operator|=
name|getnum
argument_list|(
name|lp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ALIGN
operator|!=
operator|(
name|getline
argument_list|()
operator|)
operator|->
name|opcod
operator|||
name|LABEL
operator|!=
operator|(
name|getline
argument_list|()
operator|)
operator|->
name|opcod
condition|)
name|caserr
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|WGEN
operator|!=
operator|(
name|getline
argument_list|()
operator|)
operator|->
name|opcod
condition|)
name|caserr
argument_list|()
expr_stmt|;
name|p
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|JSW
expr_stmt|;
name|p
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|curlp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|!=
literal|'-'
condition|)
empty_stmt|;
operator|*
operator|--
name|lp
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|getnum
argument_list|(
name|curlp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isn
operator|<=
name|p
operator|->
name|labno
condition|)
name|isn
operator|=
literal|1
operator|+
name|p
operator|->
name|labno
expr_stmt|;
name|p
operator|->
name|forw
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|back
operator|=
name|lastp
expr_stmt|;
name|lastp
operator|->
name|forw
operator|=
name|p
expr_stmt|;
name|lastp
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ncase
operator|>=
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|op
operator|->
name|opcod
operator|==
name|EROU
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|op
operator|->
name|opcod
operator|==
name|END
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|caserr
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"C2: improper casel instruction\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|optab
modifier|*
name|getline
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|static
name|struct
name|optab
name|OPLABEL
init|=
block|{
literal|""
block|,
name|LABEL
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|optab
name|OPEND
init|=
block|{
literal|""
block|,
name|END
block|,
literal|0
block|}
decl_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
name|again
label|:
while|while
condition|(
name|EOF
operator|!=
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|again
goto|;
block|}
while|while
condition|(
name|EOF
operator|!=
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|OPLABEL
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oplook
argument_list|()
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'"'
condition|)
do|;
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|OPEND
operator|)
return|;
block|}
end_function

begin_function
name|long
name|getnum
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|neg
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|neg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
operator|++
name|neg
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
name|n
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|neg
condition|)
name|n
operator|-=
name|c
expr_stmt|;
else|else
name|n
operator|+=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|--
name|p
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|locuse
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'f'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'b'
operator|||
name|p
index|[
literal|2
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|lgensym
index|[
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
index|]
operator|-
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|locdef
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|||
name|p
index|[
literal|1
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|lgensym
index|[
name|p
index|[
literal|0
index|]
operator|-
literal|'0'
index|]
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|output
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|t
decl_stmt|;
name|int
name|casebas
decl_stmt|;
name|t
operator|=
operator|&
name|first
expr_stmt|;
while|while
condition|(
name|t
operator|=
name|t
operator|->
name|forw
condition|)
switch|switch
condition|(
name|t
operator|->
name|op
condition|)
block|{
case|case
name|END
case|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL
case|:
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DLABEL
case|:
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CASE
case|:
name|casebas
operator|=
literal|0
expr_stmt|;
default|default:
name|std
label|:
if|if
condition|(
name|t
operator|->
name|pop
operator|==
literal|0
condition|)
block|{
comment|/* must find it */
specifier|register
name|struct
name|optab
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|optab
init|;
name|p
operator|->
name|opstring
index|[
literal|0
index|]
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|opcod
operator|==
name|t
operator|->
name|op
operator|&&
name|p
operator|->
name|subopcod
operator|==
name|t
operator|->
name|subop
condition|)
block|{
name|t
operator|->
name|pop
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|t
operator|->
name|pop
operator|->
name|opstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|code
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|op
operator|!=
name|MOV
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|labno
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%cL%d\n"
argument_list|,
operator|(
name|t
operator|->
name|code
condition|?
literal|','
else|:
literal|'\t'
operator|)
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MOVA
case|:
if|if
condition|(
name|t
operator|->
name|labno
operator|==
literal|0
condition|)
goto|goto
name|std
goto|;
name|printf
argument_list|(
literal|"mova%c\tL%d,%s\n"
argument_list|,
literal|"bwlq"
index|[
name|t
operator|->
name|subop
operator|-
name|BYTE
index|]
argument_list|,
name|t
operator|->
name|labno
argument_list|,
name|t
operator|->
name|code
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|MOVBLK
case|:
name|t
operator|->
name|code
operator|=
literal|0
expr_stmt|;
goto|goto
name|std
goto|;
case|case
name|JSW
case|:
if|if
condition|(
name|t
operator|->
name|subop
operator|!=
literal|0
condition|)
block|{
comment|/* F77JSW */
name|printf
argument_list|(
literal|".long\tL%d\n"
argument_list|,
name|t
operator|->
name|labno
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|casebas
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|".align 1\nL%d:\n"
argument_list|,
name|casebas
operator|=
name|isn
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".word	L%d-L%d\n"
argument_list|,
name|t
operator|->
name|labno
argument_list|,
name|casebas
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|copy
parameter_list|(
name|ap
parameter_list|)
name|char
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|,
modifier|*
name|onp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
name|n
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|++
condition|)
do|;
name|onp
operator|=
name|np
operator|=
operator|(
name|char
operator|*
operator|)
name|alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
while|while
condition|(
operator|*
name|np
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|onp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|OPHS
value|560
end_define

begin_decl_stmt
name|struct
name|optab
modifier|*
name|ophash
index|[
name|OPHS
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|opsetup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|optab
modifier|*
name|optp
decl_stmt|,
modifier|*
modifier|*
name|ophp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
for|for
control|(
name|i
operator|=
name|RT1
operator|+
literal|5
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|regs
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|alloc
argument_list|(
name|C2_ASIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|optp
operator|=
name|optab
init|;
name|optp
operator|->
name|opstring
index|[
literal|0
index|]
condition|;
name|optp
operator|++
control|)
block|{
name|t
operator|=
literal|7
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|t
operator|>=
literal|0
condition|)
name|i
operator|+=
name|i
operator|+
name|optp
operator|->
name|opstring
index|[
name|t
index|]
expr_stmt|;
name|ophp
operator|=
operator|&
name|ophash
index|[
name|i
operator|%
name|OPHS
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|ophp
operator|++
condition|)
block|{
comment|/*			fprintf(stderr,"\ncollision: %d %s %s", /*				ophp-1-ophash,optp->opstring,(*(ophp-1))->opstring); */
if|if
condition|(
name|ophp
operator|>
operator|&
name|ophash
index|[
name|OPHS
index|]
condition|)
name|ophp
operator|=
name|ophash
expr_stmt|;
block|}
operator|*
operator|--
name|ophp
operator|=
name|optp
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|optab
modifier|*
name|oplook
parameter_list|()
block|{
specifier|register
name|struct
name|optab
modifier|*
name|optp
decl_stmt|,
modifier|*
modifier|*
name|ophp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|char
name|tempop
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|struct
name|optab
name|OPNULL
init|=
block|{
literal|""
block|,
name|NIL
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|p
operator|=
name|line
operator|,
name|p2
operator|=
name|tempop
init|;
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|*
name|p2
operator|++
operator|=
operator|*
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p2
argument_list|)
condition|)
operator|++
name|p2
expr_stmt|;
name|curlp
operator|=
name|p2
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
name|line
condition|)
name|t
operator|+=
name|t
operator|+
operator|*
name|p
expr_stmt|;
name|ophp
operator|=
operator|&
name|ophash
index|[
name|t
operator|%
name|OPHS
index|]
expr_stmt|;
while|while
condition|(
name|optp
operator|=
operator|*
name|ophp
condition|)
block|{
if|if
condition|(
name|equstr
argument_list|(
name|tempop
argument_list|,
name|optp
operator|->
name|opstring
argument_list|)
condition|)
return|return
operator|(
name|optp
operator|)
return|;
if|if
condition|(
operator|(
operator|++
name|ophp
operator|)
operator|>=
operator|&
name|ophash
index|[
name|OPHS
index|]
condition|)
name|ophp
operator|=
name|ophash
expr_stmt|;
block|}
name|curlp
operator|=
name|line
expr_stmt|;
return|return
operator|(
operator|&
name|OPNULL
operator|)
return|;
block|}
end_function

begin_macro
name|refcount
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|node
modifier|*
name|labhash
index|[
name|LABHS
index|]
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|labhash
init|;
name|hp
operator|<
operator|&
name|labhash
index|[
name|LABHS
index|]
condition|;
control|)
operator|*
name|hp
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|labhash
index|[
name|p
operator|->
name|labno
operator|%
name|LABHS
index|]
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|refc
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p
operator|->
name|subop
operator|==
literal|0
operator|||
name|p
operator|->
name|op
operator|==
name|CBR
operator|||
name|p
operator|->
name|op
operator|==
name|JSW
operator|||
name|p
operator|->
name|op
operator|==
name|JMP
operator|||
name|p
operator|->
name|op
operator|==
name|AOBLEQ
operator|||
name|p
operator|->
name|op
operator|==
name|AOBLSS
operator|||
operator|(
name|p
operator|->
name|op
operator|==
name|MOVA
operator|&&
name|p
operator|->
name|labno
operator|!=
literal|0
operator|)
operator|||
operator|(
name|p
operator|->
name|op
operator|==
name|MOV
operator|&&
name|p
operator|->
name|labno
operator|!=
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|labhash
index|[
name|p
operator|->
name|labno
operator|%
name|LABHS
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
operator|||
name|p
operator|->
name|labno
operator|!=
name|lp
operator|->
name|labno
condition|)
for|for
control|(
name|lp
operator|=
name|first
operator|.
name|forw
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|forw
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p
operator|->
name|labno
operator|==
name|lp
operator|->
name|labno
condition|)
break|break;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|np
operator|=
name|nonlab
argument_list|(
name|lp
argument_list|)
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|lp
condition|)
block|{
name|p
operator|->
name|labno
operator|=
name|np
operator|->
name|labno
expr_stmt|;
name|lp
operator|=
name|np
expr_stmt|;
block|}
name|p
operator|->
name|ref
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|refc
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|LABEL
operator|&&
name|p
operator|->
name|refc
operator|==
literal|0
operator|&&
operator|(
name|lp
operator|=
name|nonlab
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|op
operator|&&
name|lp
operator|->
name|op
operator|!=
name|JSW
condition|)
name|decref
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|iterate
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p
decl_stmt|,
modifier|*
name|rp
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|nchange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first
operator|.
name|forw
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|forw
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|CBR
operator|||
name|p
operator|->
name|op
operator|==
name|JSW
operator|)
operator|&&
name|p
operator|->
name|ref
condition|)
block|{
name|rp
operator|=
name|nonlab
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|op
operator|==
name|JBR
operator|&&
name|rp
operator|->
name|labno
operator|&&
name|p
operator|->
name|labno
operator|!=
name|rp
operator|->
name|labno
condition|)
block|{
name|nbrbr
operator|++
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|rp
operator|->
name|labno
expr_stmt|;
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|rp
operator|->
name|ref
operator|->
name|refc
operator|++
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|rp
operator|->
name|ref
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CBR
operator|&&
operator|(
name|p1
operator|=
name|p
operator|->
name|forw
operator|)
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p1
operator|->
name|subop
operator|==
literal|0
ifdef|#
directive|ifdef
name|COPYCODE
operator|&&
name|p
operator|->
name|ref
endif|#
directive|endif
condition|)
block|{
comment|/* RET problems */
name|rp
operator|=
name|p
operator|->
name|ref
expr_stmt|;
do|do
name|rp
operator|=
name|rp
operator|->
name|back
expr_stmt|;
do|while
condition|(
name|rp
operator|->
name|op
operator|==
name|LABEL
condition|)
do|;
if|if
condition|(
name|rp
operator|==
name|p1
condition|)
block|{
name|decref
argument_list|(
name|p
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|ref
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
name|p
operator|->
name|labno
operator|=
name|p1
operator|->
name|labno
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
if|if
condition|(
name|p
operator|->
name|labno
operator|==
literal|0
condition|)
name|p
operator|->
name|code
operator|=
name|p1
operator|->
name|code
expr_stmt|;
endif|#
directive|endif
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|subop
operator|=
name|revbr
index|[
name|p
operator|->
name|subop
index|]
expr_stmt|;
name|p
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|nskip
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|JBR
operator|||
name|p
operator|->
name|op
operator|==
name|JMP
condition|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p
operator|->
name|forw
operator|)
operator|!=
literal|0
operator|&&
name|p1
operator|->
name|op
operator|!=
name|LABEL
operator|&&
name|p1
operator|->
name|op
operator|!=
name|DLABEL
operator|&&
name|p1
operator|->
name|op
operator|!=
name|EROU
operator|&&
name|p1
operator|->
name|op
operator|!=
name|END
operator|&&
name|p1
operator|->
name|op
operator|!=
name|ALIGN
operator|&&
name|p1
operator|->
name|op
operator|!=
name|NIL
operator|&&
name|p1
operator|->
name|op
operator|!=
name|DATA
condition|)
block|{
name|nchange
operator|++
expr_stmt|;
name|iaftbr
operator|++
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|ref
condition|)
name|decref
argument_list|(
name|p1
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
expr_stmt|;
block|}
name|rp
operator|=
name|p
operator|->
name|forw
expr_stmt|;
while|while
condition|(
name|rp
operator|&&
name|rp
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ref
operator|==
name|rp
condition|)
block|{
name|p
operator|->
name|back
operator|->
name|forw
operator|=
name|p
operator|->
name|forw
expr_stmt|;
name|p
operator|->
name|forw
operator|->
name|back
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|back
expr_stmt|;
name|decref
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|njp1
operator|++
expr_stmt|;
break|break;
block|}
name|rp
operator|=
name|rp
operator|->
name|forw
expr_stmt|;
block|}
name|xjump
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|codemove
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|xjump
argument_list|(
name|p1
argument_list|)
specifier|register
expr|struct
name|node
operator|*
name|p1
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
if|if
condition|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|p2
operator|=
name|p2
operator|->
name|back
operator|)
operator|&&
name|p2
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|||
name|p1
operator|==
name|p2
condition|)
return|return;
name|p3
operator|=
name|insertl
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|p1
operator|->
name|op
operator|=
name|JBR
expr_stmt|;
name|p1
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p1
operator|->
name|ref
operator|=
name|p3
expr_stmt|;
name|p1
operator|->
name|labno
operator|=
name|p3
operator|->
name|labno
expr_stmt|;
name|p1
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|nxjump
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|node
modifier|*
name|insertl
parameter_list|(
name|op
parameter_list|)
specifier|register
name|struct
name|node
modifier|*
name|op
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|op
operator|->
name|refc
operator|++
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
if|if
condition|(
name|op
operator|->
name|back
operator|->
name|op
operator|==
name|LABEL
condition|)
block|{
name|op
operator|=
name|op
operator|->
name|back
expr_stmt|;
name|op
operator|->
name|refc
operator|++
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
name|lp
operator|=
name|alloc
argument_list|(
sizeof|sizeof
name|first
argument_list|)
expr_stmt|;
name|lp
operator|->
name|op
operator|=
name|LABEL
expr_stmt|;
name|lp
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|labno
operator|=
name|isn
operator|++
expr_stmt|;
name|lp
operator|->
name|ref
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|refc
operator|=
literal|1
expr_stmt|;
name|lp
operator|->
name|back
operator|=
name|op
operator|->
name|back
expr_stmt|;
name|lp
operator|->
name|forw
operator|=
name|op
expr_stmt|;
name|op
operator|->
name|back
operator|->
name|forw
operator|=
name|lp
expr_stmt|;
name|op
operator|->
name|back
operator|=
name|lp
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|codemove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|node
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
specifier|register
name|struct
name|node
modifier|*
name|t
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|p1
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|op
operator|!=
name|JBR
operator|||
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|==
literal|0
operator|||
name|p2
operator|==
name|p1
operator|->
name|forw
condition|)
return|return
operator|(
name|p1
operator|)
return|;
while|while
condition|(
name|p2
operator|->
name|op
operator|==
name|LABEL
condition|)
if|if
condition|(
operator|(
name|p2
operator|=
name|p2
operator|->
name|back
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|op
operator|!=
name|JBR
operator|&&
name|p2
operator|->
name|op
operator|!=
name|JMP
condition|)
goto|goto
name|ivloop
goto|;
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|p3
operator|=
name|p1
operator|->
name|ref
expr_stmt|;
while|while
condition|(
name|p3
condition|)
block|{
if|if
condition|(
name|p3
operator|->
name|op
operator|==
name|JBR
operator|||
name|p3
operator|->
name|op
operator|==
name|JMP
condition|)
block|{
if|if
condition|(
name|p1
operator|==
name|p3
condition|)
return|return
operator|(
name|p1
operator|)
return|;
name|ncmot
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p3
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
name|p3
operator|->
name|forw
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p3
operator|->
name|forw
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|decref
argument_list|(
name|p1
operator|->
name|ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|p2
operator|)
return|;
block|}
else|else
name|p3
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
block|}
return|return
operator|(
name|p1
operator|)
return|;
name|ivloop
label|:
if|if
condition|(
name|p1
operator|->
name|forw
operator|->
name|op
operator|!=
name|LABEL
condition|)
return|return
operator|(
name|p1
operator|)
return|;
name|p3
operator|=
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|n
operator|=
literal|16
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|p3
operator|=
name|p3
operator|->
name|forw
operator|)
operator|==
literal|0
operator|||
name|p3
operator|==
name|p1
operator|||
operator|--
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|p1
operator|)
return|;
block|}
do|while
condition|(
name|p3
operator|->
name|op
operator|!=
name|CBR
operator|||
name|p3
operator|->
name|labno
operator|!=
name|p1
operator|->
name|forw
operator|->
name|labno
condition|)
do|;
do|do
if|if
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ap
operator|)
return|;
do|while
condition|(
name|p1
operator|!=
name|p3
condition|)
do|;
name|p1
operator|=
name|ap
expr_stmt|;
name|tl
operator|=
name|insertl
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p3
operator|->
name|subop
operator|=
name|revbr
index|[
name|p3
operator|->
name|subop
index|]
expr_stmt|;
name|p3
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|decref
argument_list|(
name|p3
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p1
expr_stmt|;
name|p3
operator|->
name|forw
operator|->
name|back
operator|=
name|p1
expr_stmt|;
name|p1
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
expr_stmt|;
name|p1
operator|->
name|forw
operator|->
name|back
operator|=
name|p3
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|back
expr_stmt|;
name|p1
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|->
name|back
operator|=
name|t
expr_stmt|;
name|t
operator|=
name|p1
operator|->
name|forw
expr_stmt|;
name|p1
operator|->
name|forw
operator|=
name|p3
operator|->
name|forw
expr_stmt|;
name|p3
operator|->
name|forw
operator|=
name|t
expr_stmt|;
name|p2
operator|=
name|insertl
argument_list|(
name|p1
operator|->
name|forw
argument_list|)
expr_stmt|;
name|p3
operator|->
name|labno
operator|=
name|p2
operator|->
name|labno
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
if|if
condition|(
name|p3
operator|->
name|labno
operator|==
literal|0
condition|)
name|p3
operator|->
name|code
operator|=
name|p2
operator|->
name|code
expr_stmt|;
endif|#
directive|endif
name|p3
operator|->
name|ref
operator|=
name|p2
expr_stmt|;
name|decref
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|->
name|refc
operator|<=
literal|0
condition|)
name|nrlab
operator|--
expr_stmt|;
name|loopiv
operator|++
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
return|return
operator|(
name|p3
operator|)
return|;
block|}
end_function

begin_macro
name|comjump
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|first
operator|.
name|forw
init|;
name|p1
operator|!=
literal|0
condition|;
name|p1
operator|=
name|p1
operator|->
name|forw
control|)
if|if
condition|(
name|p1
operator|->
name|op
operator|==
name|JBR
operator|&&
operator|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|ref
operator|)
operator|&&
name|p2
operator|->
name|refc
operator|>
literal|1
operator|||
operator|(
name|p1
operator|->
name|subop
operator|&
literal|0xF
operator|)
operator|==
name|RET
operator|)
condition|)
for|for
control|(
name|p3
operator|=
name|p1
operator|->
name|forw
init|;
name|p3
operator|!=
literal|0
condition|;
name|p3
operator|=
name|p3
operator|->
name|forw
control|)
if|if
condition|(
name|p3
operator|->
name|op
operator|==
name|JBR
operator|&&
name|p3
operator|->
name|ref
operator|==
name|p2
condition|)
name|backjmp
argument_list|(
name|p1
argument_list|,
name|p3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|backjmp
argument_list|(
argument|ap1
argument_list|,
argument|ap2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|node
modifier|*
name|ap1
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|node
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|p3
decl_stmt|;
name|p1
operator|=
name|ap1
expr_stmt|;
name|p2
operator|=
name|ap2
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p1
operator|=
name|p1
operator|->
name|back
operator|)
operator|&&
name|p1
operator|->
name|op
operator|==
name|LABEL
condition|)
empty_stmt|;
name|p2
operator|=
name|p2
operator|->
name|back
expr_stmt|;
if|if
condition|(
name|equop
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
block|{
name|p3
operator|=
name|insertl
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|p2
operator|->
name|back
operator|->
name|forw
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|p2
operator|->
name|forw
operator|->
name|back
operator|=
name|p2
operator|->
name|back
expr_stmt|;
name|p2
operator|=
name|p2
operator|->
name|forw
expr_stmt|;
name|decref
argument_list|(
name|p2
operator|->
name|ref
argument_list|)
expr_stmt|;
name|p2
operator|->
name|op
operator|=
name|JBR
expr_stmt|;
name|p2
operator|->
name|subop
operator|=
literal|0
expr_stmt|;
comment|/* to handle RET */
name|p2
operator|->
name|pop
operator|=
literal|0
expr_stmt|;
name|p2
operator|->
name|labno
operator|=
name|p3
operator|->
name|labno
expr_stmt|;
ifdef|#
directive|ifdef
name|COPYCODE
name|p2
operator|->
name|code
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|p2
operator|->
name|ref
operator|=
name|p3
expr_stmt|;
name|nchange
operator|++
expr_stmt|;
name|ncomj
operator|++
expr_stmt|;
block|}
else|else
return|return;
block|}
block|}
end_block

end_unit

