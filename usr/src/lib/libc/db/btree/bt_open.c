begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_open.c	5.7 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/*  *  btree.c -- implementation of btree access method for 4.4BSD.  *  *	The design here is based on that of the btree access method used  *	in the Postgres database system at UC Berkeley.  The implementation  *	is wholly independent of the Postgres code.  *  *	This implementation supports btrees on disk (supply a filename) or  *	in memory (don't).  Public interfaces defined here are:  *  *		btree_open()	-- wrapper; returns a filled DB struct for  *				   a btree.  *  *		bt_open()	-- open a new or existing btree.  *		bt_get()	-- fetch data from a tree by key.  *		bt_seq()	-- do a sequential scan on a tree.  *		bt_put()	-- add data to a tree by key.  *		bt_delete()	-- remove data from a tree by key.  *		bt_close()	-- close a btree.  *		bt_sync()	-- force btree pages to disk (disk trees only).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"btree.h"
end_include

begin_decl_stmt
name|BTREEINFO
name|_DefaultBTInfo
init|=
block|{
literal|0
block|,
comment|/* flags */
literal|0
block|,
comment|/* cachesize */
literal|0
block|,
comment|/* psize */
name|strcmp
block|,
comment|/* compare */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  BTREE_OPEN -- Wrapper routine to open a btree.  *  *	Creates and fills a DB struct, and calls the routine that actually  *	opens the btree.  *  *	Parameters:  *		f:  filename to open  *		flags:  flag bits passed to open  *		mode:  permission bits, used if O_CREAT specified  *		b:  BTREEINFO pointer  *  *	Returns:  *		Filled-in DBT on success; NULL on failure, with errno  *		set as appropriate.  *  *	Side Effects:  *		Allocates memory for the DB struct.  */
end_comment

begin_function
name|DB
modifier|*
name|btree_open
parameter_list|(
name|f
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|b
parameter_list|)
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
specifier|const
name|BTREEINFO
modifier|*
name|b
decl_stmt|;
block|{
name|DB
modifier|*
name|db
decl_stmt|;
name|BTREE
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
operator|(
name|DB
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|DB
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|DB
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|DB
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|=
name|bt_open
argument_list|(
name|f
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|b
argument_list|)
operator|)
operator|==
operator|(
name|BTREE
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|DB
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|db
operator|->
name|internal
operator|=
operator|(
name|char
operator|*
operator|)
name|t
expr_stmt|;
name|db
operator|->
name|close
operator|=
name|bt_close
expr_stmt|;
name|db
operator|->
name|del
operator|=
name|bt_delete
expr_stmt|;
name|db
operator|->
name|get
operator|=
name|bt_get
expr_stmt|;
name|db
operator|->
name|put
operator|=
name|bt_put
expr_stmt|;
name|db
operator|->
name|seq
operator|=
name|bt_seq
expr_stmt|;
name|db
operator|->
name|sync
operator|=
name|bt_sync
expr_stmt|;
return|return
operator|(
name|db
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_OPEN -- Open a btree.  *  *	This routine creates the correct kind (disk or in-memory) of  *	btree and initializes it as required.  *  *	Parameters:  *		f -- name of btree (NULL for in-memory btrees)  *		flags -- flags passed to open()  *		mode -- mode passed to open ()  *		b -- BTREEINFO structure, describing btree  *  *	Returns:  *		(Opaque) pointer to the btree.  On failure, returns NULL  *		with errno set as appropriate.  *  *	Side Effects:  *		Allocates memory, opens files.  */
end_comment

begin_function
name|BTREE
name|bt_open
parameter_list|(
name|f
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|BTREEINFO
modifier|*
name|b
decl_stmt|;
block|{
name|BTREE_P
name|t
decl_stmt|;
name|HTABLE
name|ht
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|BTMETA
name|m
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
comment|/* use the default info if none was provided */
if|if
condition|(
name|b
operator|==
operator|(
name|BTREEINFO
operator|*
operator|)
name|NULL
condition|)
name|b
operator|=
operator|&
name|_DefaultBTInfo
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|BTREE_P
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTREE_P
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|compare
condition|)
name|t
operator|->
name|bt_compare
operator|=
name|b
operator|->
name|compare
expr_stmt|;
else|else
name|t
operator|->
name|bt_compare
operator|=
name|strcmp
expr_stmt|;
name|t
operator|->
name|bt_fname
operator|=
name|f
expr_stmt|;
name|t
operator|->
name|bt_curpage
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
expr_stmt|;
name|t
operator|->
name|bt_free
operator|=
name|P_NONE
expr_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|P_NONE
expr_stmt|;
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|c_flags
operator|=
operator|(
name|u_char
operator|)
name|NULL
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|t
operator|->
name|bt_stack
operator|=
operator|(
name|BTSTACK
operator|*
operator|)
name|NULL
expr_stmt|;
name|t
operator|->
name|bt_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  If no file name was supplied, this is an in-memory btree. 	 *  Otherwise, it's a disk-based btree. 	 */
if|if
condition|(
name|f
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* in memory */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_psize
operator|=
name|b
operator|->
name|psize
operator|)
operator|<
name|MINPSIZE
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|bt_psize
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_psize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
block|}
name|nbytes
operator|=
name|HTSIZE
operator|*
sizeof|sizeof
argument_list|(
name|HTBUCKET
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ht
operator|=
operator|(
name|HTABLE
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|HTABLE
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ht
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
operator|=
name|ht
expr_stmt|;
name|t
operator|->
name|bt_npages
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|bt_lorder
operator|=
name|BYTE_ORDER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|R_DUP
operator|)
condition|)
name|t
operator|->
name|bt_flags
operator||=
name|BTF_NODUPS
expr_stmt|;
block|}
else|else
block|{
comment|/* on disk */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* doesn't exist yet, be sure page is big enough */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_psize
operator|=
name|b
operator|->
name|psize
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|BTHEADER
argument_list|)
operator|&&
name|b
operator|->
name|psize
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|->
name|lorder
operator|==
literal|0
condition|)
name|b
operator|->
name|lorder
operator|=
name|BYTE_ORDER
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|lorder
operator|!=
name|BIG_ENDIAN
operator|&&
name|b
operator|->
name|lorder
operator|!=
name|LITTLE_ENDIAN
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_lorder
operator|=
name|b
operator|->
name|lorder
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|R_DUP
operator|)
condition|)
name|t
operator|->
name|bt_flags
operator||=
name|BTF_NODUPS
expr_stmt|;
block|}
else|else
block|{
comment|/* exists, get page size from file */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* lorder always stored in host-independent format */
name|NTOHL
argument_list|(
name|m
operator|.
name|m_lorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|m_lorder
operator|!=
name|BIG_ENDIAN
operator|&&
name|m
operator|.
name|m_lorder
operator|!=
name|LITTLE_ENDIAN
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_lorder
operator|=
name|m
operator|.
name|m_lorder
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_lorder
operator|!=
name|BYTE_ORDER
condition|)
block|{
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_magic
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_version
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_psize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_free
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|.
name|m_magic
operator|!=
name|BTREEMAGIC
operator|||
name|m
operator|.
name|m_version
operator|!=
name|BTREEVERSION
operator|||
name|m
operator|.
name|m_psize
operator|<
name|MINPSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EFTYPE
define|#
directive|define
name|EFTYPE
value|-100
endif|#
directive|endif
name|errno
operator|=
name|EFTYPE
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_psize
operator|=
name|m
operator|.
name|m_psize
expr_stmt|;
name|t
operator|->
name|bt_free
operator|=
name|m
operator|.
name|m_free
expr_stmt|;
name|t
operator|->
name|bt_flags
operator||=
operator|(
name|m
operator|.
name|m_flags
operator|&
name|BTF_NODUPS
operator|)
operator||
name|BTF_METAOK
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* now open the file the way the user wanted it */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* access method files are always close-on-exec */
if|if
condition|(
name|fcntl
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
name|F_SETFL
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* get number of pages, page size if necessary */
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_psize
operator|==
literal|0
condition|)
name|t
operator|->
name|bt_psize
operator|=
name|buf
operator|.
name|st_blksize
expr_stmt|;
name|t
operator|->
name|bt_npages
operator|=
call|(
name|pgno_t
call|)
argument_list|(
name|buf
operator|.
name|st_size
operator|/
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
comment|/* page zero is metadata, doesn't count */
if|if
condition|(
name|t
operator|->
name|bt_npages
operator|>
literal|0
condition|)
operator|--
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cachesize
operator|==
literal|0
condition|)
name|b
operator|->
name|cachesize
operator|=
name|DEFCACHE
expr_stmt|;
comment|/* get an lru buffer cache, if the user asked for one */
if|if
condition|(
operator|(
name|b
operator|->
name|cachesize
operator|/
name|t
operator|->
name|bt_psize
operator|)
operator|>
literal|0
condition|)
block|{
name|BTDISK
modifier|*
name|d
init|=
operator|&
operator|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|)
decl_stmt|;
name|d
operator|->
name|d_cache
operator|=
name|lruinit
argument_list|(
name|d
operator|->
name|d_fd
argument_list|,
call|(
name|int
call|)
argument_list|(
name|b
operator|->
name|cachesize
operator|/
name|t
operator|->
name|bt_psize
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|bt_psize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_lorder
argument_list|,
name|_bt_pgin
argument_list|,
name|_bt_pgout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_cache
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/* remember if tree was opened for write */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|O_WRONLY
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|O_RDWR
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|t
operator|->
name|bt_flags
operator||=
name|BTF_ISWRITE
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_GET -- Get an entry from a btree.  *  *	Does a key lookup in the tree to find the specified key, and returns  *	the key/data pair found.  *  *	Parameters:  *		tree -- btree in which to do lookup  *		key -- key to find  *		data -- pointer to DBT in which to return data  *		flag -- ignored  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if the key is not  *		found.  If key is not found, nothing is stored in the  *		return DBT 'data'.  *  *	Side Effects:  *		None.  *  *	Warnings:  *		Return data is statically allocated, and will be overwritten  *		at the next call.  */
end_comment

begin_function
name|int
name|bt_get
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|u_long
name|flag
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|flag
operator|=
name|flag
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
comment|/* lookup */
name|item
operator|=
name|_bt_search
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* clear parent pointer stack */
while|while
condition|(
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|!=
name|P_NONE
condition|)
continue|continue;
if|if
condition|(
name|item
operator|==
operator|(
name|BTITEM
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* match? */
if|if
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
literal|0
condition|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|_bt_buildret
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
comment|/* nope */
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_PUT -- Add an entry to a btree.  *  *	The specified (key, data) pair is added to the tree.  If the tree  *	was created for unique keys only, then duplicates will not be  *	entered.  If the requested key exists in the tree, it will be over-  *	written unless the flags parameter is R_NOOVERWRITE, in which case  *	the update will not be done.  If duplicate keys are permitted in the  *	tree, duplicates will be inserted and will not overwrite existing  *	keys.  Nodes are split as required.  *  *	Parameters:  *		tree -- btree in which to put the new entry  *		key -- key component to add  *		data -- data corresponding to key  *		flag -- R_NOOVERWRITE or zero.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if the  *		NOOVERWRITE flag was set and the specified key exists  *		in the database.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|bt_put
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|u_long
name|flag
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
comment|/* look for this key in the tree */
name|item
operator|=
name|_bt_search
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* 	 *  If this tree was originally created without R_DUP, then duplicate 	 *  keys are not allowed.  We need to check this at insertion time. 	 */
if|if
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_NODUPS
operator|)
operator|&&
name|flag
operator|==
name|R_NOOVERWRITE
condition|)
block|{
if|if
condition|(
name|_bt_delone
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
name|RET_ERROR
condition|)
block|{
while|while
condition|(
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|!=
name|P_NONE
condition|)
continue|continue;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|_bt_insert
argument_list|(
name|t
argument_list|,
name|item
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_DELETE -- delete a key from the tree.  *  *	Deletes all keys (and their associated data items) matching the  *	supplied key from the tree.  If the flags entry is R_CURSOR, then  *	the current item in the active scan is deleted.  *  *	Parameters:  *		tree -- btree from which to delete key  *		key -- key to delete  *		flags -- R_CURSOR or zero  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if the specified  *		key was not in the tree.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|bt_delete
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|flags
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
name|int
name|ndel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_CURSOR
condition|)
return|return
operator|(
name|_bt_crsrdel
argument_list|(
name|t
argument_list|)
operator|)
return|;
comment|/* find the first matching key in the tree */
name|item
operator|=
name|_bt_first
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* don't need the descent stack for deletes */
while|while
condition|(
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|!=
name|P_NONE
condition|)
continue|continue;
comment|/* delete all matching keys */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|&&
operator|(
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|_bt_delone
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ndel
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|||
name|h
operator|->
name|h_nextpg
operator|==
name|P_NONE
condition|)
break|break;
comment|/* next page, if necessary */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
name|item
operator|->
name|bti_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
name|item
operator|->
name|bti_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|||
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* flush changes to disk */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_DIRTY
condition|)
block|{
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|bt_curpage
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ndel
operator|==
literal|0
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_SYNC -- sync the btree to disk.  *  *	Parameters:  *		tree -- btree to sync.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  */
end_comment

begin_macro
name|bt_sync
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|BTREE
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
comment|/* if this is an in-memory btree, syncing is a no-op */
if|if
condition|(
operator|!
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|F_DIRTY
expr_stmt|;
if|if
condition|(
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pgno
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|lrusync
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
argument_list|)
operator|<
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|fsync
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  BT_SEQ -- Sequential scan interface.  *  *	This routine supports sequential scans on the btree.  If called with  *	flags set to R_CURSOR, or if no seq scan has been initialized in the  *	current tree, we initialize the scan.  Otherwise, we advance the scan  *	and return the next item.  *  *	Scans can be either keyed or non-keyed.  Keyed scans basically have  *	a starting point somewhere in the middle of the tree.  Non-keyed  *	scans start at an endpoint.  Also, scans can be backward (descending  *	order), forward (ascending order), or no movement (keep returning  *	the same item).  *  *	Flags is checked every time we enter the routine, so the user can  *	change directions on an active scan if desired.  The key argument  *	is examined only when we initialize the scan, in order to position  *	it properly.  *  *	Items are returned via the key and data arguments passed in.  *  *	Parameters:  *		tree -- btree in which to do scan  *		key -- key, used to position scan on initialization, and  *		       used to return key components to the user.  *		data -- used to return data components to the user.  *		flags -- specify R_CURSOR, R_FIRST, R_LAST, R_NEXT, or  *			 R_PREV.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if no more data  *		exists in the tree in the specified direction.  *  *	Side Effects:  *		Changes the btree's notion of the current position in the  *		scan.  *  *	Warnings:  *		The key and data items returned are static and will be  *		overwritten by the next bt_get or bt_seq.  */
end_comment

begin_function
name|int
name|bt_seq
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flags
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* do we need to initialize the scan? */
if|if
condition|(
name|flags
operator|==
name|R_CURSOR
operator|||
name|flags
operator|==
name|R_LAST
operator|||
name|flags
operator|==
name|R_FIRST
operator|||
operator|!
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|)
condition|)
block|{
comment|/* initialize it */
name|status
operator|=
name|_bt_seqinit
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just advance the current scan pointer */
name|status
operator|=
name|_bt_seqadvance
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|size
operator|=
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|data
operator|=
name|data
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|NULL
expr_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* is there a valid item at the current scan location? */
if|if
condition|(
name|status
operator|==
name|RET_SPECIAL
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|R_NEXT
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|>
literal|0
condition|)
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* okay, return the data */
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|_bt_buildret
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_CLOSE -- Close a btree  *  *	Parameters:  *		tree -- tree to close  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Frees space occupied by the tree.  */
end_comment

begin_function
name|int
name|bt_close
parameter_list|(
name|tree
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|cache
decl_stmt|;
name|struct
name|HTBUCKET
modifier|*
name|b
decl_stmt|,
modifier|*
name|sb
decl_stmt|;
name|HTABLE
name|ht
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_cursor
operator|.
name|c_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|t
operator|->
name|bt_cursor
operator|.
name|c_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* in-memory tree, release hash table memory */
name|ht
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HTSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|b
operator|=
name|ht
index|[
name|i
index|]
operator|)
operator|==
operator|(
expr|struct
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|)
break|break;
do|do
block|{
name|sb
operator|=
name|b
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|ht_page
argument_list|)
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|ht_next
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|b
operator|!=
operator|(
expr|struct
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|)
do|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ht
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_ISWRITE
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_METAOK
operator|)
condition|)
block|{
if|if
condition|(
name|_bt_wrtmeta
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|!=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_DIRTY
condition|)
block|{
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|h
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* flush and free the cache, if there is one */
if|if
condition|(
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cache
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
expr_stmt|;
if|if
condition|(
name|lrusync
argument_list|(
name|cache
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|lrufree
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

