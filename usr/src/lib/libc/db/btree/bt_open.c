begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_open.c	5.2 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/*  *  btree.c -- implementation of btree access method for 4.4BSD.  *  *	The design here is based on that of the btree access method used  *	in the Postgres database system at UC Berkeley.  The implementation  *	is wholly independent of the Postgres code.  *  *	This implementation supports btrees on disk (supply a filename) or  *	in memory (don't).  Public interfaces defined here are:  *  *		btree_open()	-- wrapper; returns a filled DB struct for  *				   a btree.  *  *		bt_open()	-- open a new or existing btree.  *		bt_get()	-- fetch data from a tree by key.  *		bt_seq()	-- do a sequential scan on a tree.  *		bt_put()	-- add data to a tree by key.  *		bt_delete()	-- remove data from a tree by key.  *		bt_close()	-- close a btree.  *		bt_sync()	-- force btree pages to disk (disk trees only).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BLSWAP
end_ifndef

begin_define
define|#
directive|define
name|BLSWAP
parameter_list|(
name|a
parameter_list|)
value|{ \         register unsigned long _t; \         _t = (a); \         (a)>>= 24; \         (a) |= (_t& 0x00ff0000)>>  8; \         (a) |= (_t& 0x0000ff00)<<  8; \         (a) |= (_t& 0x000000ff)<< 24; \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef BLSWAP */
end_comment

begin_typedef
typedef|typedef
name|char
modifier|*
name|BTREE
typedef|;
end_typedef

begin_comment
comment|/* should really be (void *) */
end_comment

begin_comment
comment|/* #define	DEBUG */
end_comment

begin_define
define|#
directive|define
name|RET_ERROR
value|-1
end_define

begin_define
define|#
directive|define
name|RET_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|RET_SPECIAL
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef TRUE */
end_comment

begin_comment
comment|/* libc */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* these are defined in lrucache.c */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|lruinit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|lruget
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|lrugetnew
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|lrusync
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|lruwrite
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|lrurelease
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|lrufree
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* these are defined here */
end_comment

begin_function_decl
name|BTREE
name|bt_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bt_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bt_delete
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bt_get
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bt_put
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bt_seq
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bt_sync
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Private types.  What you choose for these depends on how big you  *  want to let files get, and how big you want to let pages get.  */
end_comment

begin_typedef
typedef|typedef
name|u_long
name|index_t
typedef|;
end_typedef

begin_comment
comment|/* so # bytes on a page fits in a long */
end_comment

begin_typedef
typedef|typedef
name|u_long
name|pgno_t
typedef|;
end_typedef

begin_comment
comment|/* so # of pages in a btree fits in a long */
end_comment

begin_comment
comment|/*  *  When we do searches, we push the parent page numbers onto a stack  *  as we descend the tree.  This is so that for insertions, we can  *  find our way back up to do internal page insertions and splits.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BTSTACK
block|{
name|pgno_t
name|bts_pgno
decl_stmt|;
name|struct
name|BTSTACK
modifier|*
name|bts_next
decl_stmt|;
block|}
name|BTSTACK
typedef|;
end_typedef

begin_comment
comment|/*  *  Every btree page has a header that looks like this.  Flags are given  *  in the #define's for the F_ flags (see below).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BTHEADER
block|{
name|pgno_t
name|h_pgno
decl_stmt|;
comment|/* page number of this page */
name|pgno_t
name|h_prevpg
decl_stmt|;
comment|/* left sibling */
name|pgno_t
name|h_nextpg
decl_stmt|;
comment|/* right sibling */
define|#
directive|define
name|F_LEAF
value|0x01
comment|/* leaf page, contains user data */
define|#
directive|define
name|F_CONT
value|0x02
comment|/* continuation page (large items) */
define|#
directive|define
name|F_DIRTY
value|0x04
comment|/* need to write to disk */
define|#
directive|define
name|F_PRESERVE
value|0x08
comment|/* never delete this chain of pages */
name|u_long
name|h_flags
decl_stmt|;
comment|/* page state */
name|index_t
name|h_lower
decl_stmt|;
comment|/* lower bound of free space on page */
name|index_t
name|h_upper
decl_stmt|;
comment|/* upper bound of free space on page */
name|index_t
name|h_linp
index|[
literal|1
index|]
decl_stmt|;
comment|/* VARIABLE LENGTH DATA AT END OF STRUCT */
block|}
name|BTHEADER
typedef|;
end_typedef

begin_comment
comment|/*  *  HTBUCKETs are hash table buckets for looking up pages of in-memory  *  btrees by page number.  We use this indirection, rather than direct  *  pointers, so that the code for manipulating in-memory trees is the  *  same as that for manipulating on-disk trees.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|HTBUCKET
block|{
name|pgno_t
name|ht_pgno
decl_stmt|;
name|BTHEADER
modifier|*
name|ht_page
decl_stmt|;
name|struct
name|HTBUCKET
modifier|*
name|ht_next
decl_stmt|;
block|}
name|HTBUCKET
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|HTBUCKET
modifier|*
modifier|*
name|HTABLE
typedef|;
end_typedef

begin_comment
comment|/* minimum size we'll let a page be */
end_comment

begin_define
define|#
directive|define
name|MINPSIZE
value|512
end_define

begin_comment
comment|/* default cache size, in bytes */
end_comment

begin_define
define|#
directive|define
name|DEFCACHE
value|(20 * 1024)
end_define

begin_comment
comment|/* hash table size for in-memory trees */
end_comment

begin_define
define|#
directive|define
name|HTSIZE
value|128
end_define

begin_comment
comment|/* generate a hash key from a page number */
end_comment

begin_define
define|#
directive|define
name|HASHKEY
parameter_list|(
name|pgno
parameter_list|)
value|((pgno - 1) % HTSIZE)
end_define

begin_comment
comment|/*  *  Disk btrees have a file descriptor, and may also have an lru buffer  *  cache, if the user asked for one.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BTDISK
block|{
name|int
name|d_fd
decl_stmt|;
name|char
modifier|*
name|d_cache
decl_stmt|;
block|}
name|BTDISK
typedef|;
end_typedef

begin_comment
comment|/*  *  Cursors keep track of the current location in a sequential scan of  *  the database.  Since btrees impose a total ordering on keys, we can  *  walk forward or backward through the database from any point.  Cursors  *  survive updates to the tree, and can be used to delete a particular  *  record.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|CURSOR
block|{
name|pgno_t
name|c_pgno
decl_stmt|;
comment|/* pgno of current item in scan */
name|index_t
name|c_index
decl_stmt|;
comment|/* index of current item in scan */
name|char
modifier|*
name|c_key
decl_stmt|;
comment|/* current key, used for updates */
define|#
directive|define
name|CRSR_BEFORE
value|0x01
name|u_char
name|c_flags
decl_stmt|;
comment|/* to handle updates properly */
block|}
name|CURSOR
typedef|;
end_typedef

begin_comment
comment|/*  *  The private btree data structure.  The user passes a pointer to one of  *  these when we are to manipulate a tree, but the BTREE type is opaque  *  to him.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BTREEDATA_P
block|{
name|char
modifier|*
name|bt_fname
decl_stmt|;
comment|/* NULL for in-memory trees */
union|union
block|{
name|BTDISK
name|bt_d
decl_stmt|;
comment|/* for on-disk btrees */
name|HTABLE
name|bt_ht
decl_stmt|;
comment|/* hash table for mem trees */
block|}
name|bt_s
union|;
name|size_t
name|bt_psize
decl_stmt|;
comment|/* page size for btree pages */
name|int
function_decl|(
modifier|*
name|bt_compare
function_decl|)
parameter_list|()
function_decl|;
comment|/* key comparison function */
name|pgno_t
name|bt_npages
decl_stmt|;
comment|/* number of pages in tree */
name|BTHEADER
modifier|*
name|bt_curpage
decl_stmt|;
comment|/* current page contents */
name|pgno_t
name|bt_free
decl_stmt|;
comment|/* free pg list for big data */
name|CURSOR
name|bt_cursor
decl_stmt|;
comment|/* cursor for scans */
name|BTSTACK
modifier|*
name|bt_stack
decl_stmt|;
comment|/* parent stack for inserts */
name|u_long
name|bt_lorder
decl_stmt|;
comment|/* byte order (endian.h) */
define|#
directive|define
name|BTF_METAOK
value|0x01
comment|/* meta-data written to start of file */
define|#
directive|define
name|BTF_SEQINIT
value|0x02
comment|/* we have called bt_seq */
define|#
directive|define
name|BTF_ISWRITE
value|0x04
comment|/* tree was opened for write */
define|#
directive|define
name|BTF_NODUPS
value|0x08
comment|/* tree created for unique keys */
name|u_long
name|bt_flags
decl_stmt|;
comment|/* btree state */
block|}
name|BTREEDATA_P
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|BTREEDATA_P
modifier|*
name|BTREE_P
typedef|;
end_typedef

begin_comment
comment|/*  *  The first thing in a btree file is a BTMETA structure.  The rest of  *  the first page is empty, so that all disk operations are page-aligned.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BTMETA
block|{
name|u_long
name|m_magic
decl_stmt|;
name|u_long
name|m_version
decl_stmt|;
name|size_t
name|m_psize
decl_stmt|;
name|pgno_t
name|m_free
decl_stmt|;
name|u_long
name|m_flags
decl_stmt|;
name|u_long
name|m_lorder
decl_stmt|;
block|}
name|BTMETA
typedef|;
end_typedef

begin_define
define|#
directive|define
name|P_NONE
value|0
end_define

begin_comment
comment|/* invalid page number in tree */
end_comment

begin_define
define|#
directive|define
name|P_ROOT
value|1
end_define

begin_comment
comment|/* page number of root pg in btree */
end_comment

begin_define
define|#
directive|define
name|NORELEASE
value|0
end_define

begin_comment
comment|/* don't release a page during write */
end_comment

begin_define
define|#
directive|define
name|RELEASE
value|1
end_define

begin_comment
comment|/* release a page during write */
end_comment

begin_define
define|#
directive|define
name|INSERT
value|0
end_define

begin_comment
comment|/* doing an insert operation */
end_comment

begin_define
define|#
directive|define
name|DELETE
value|1
end_define

begin_comment
comment|/* doing a delete operation */
end_comment

begin_comment
comment|/* get the next free index on a btree page */
end_comment

begin_define
define|#
directive|define
name|NEXTINDEX
parameter_list|(
name|p
parameter_list|)
value|((((int)(p)->h_lower) - ((int)((((char *)(&(p)->h_linp[0]))) - ((char *) (p)))))/(sizeof(index_t)))
end_define

begin_comment
comment|/* is a BTITEM actually on the btree page? */
end_comment

begin_define
define|#
directive|define
name|VALIDITEM
parameter_list|(
name|t
parameter_list|,
name|i
parameter_list|)
value|((i)->bti_index< NEXTINDEX((t)->bt_curpage))
end_define

begin_comment
comment|/* guarantee longword alignment so structure refs work */
end_comment

begin_define
define|#
directive|define
name|LONGALIGN
parameter_list|(
name|p
parameter_list|)
value|(((long)(p) + 3)& ~ 0x03)
end_define

begin_comment
comment|/* get a particular datum (or idatum) off a page */
end_comment

begin_define
define|#
directive|define
name|GETDATUM
parameter_list|(
name|h
parameter_list|,
name|i
parameter_list|)
value|(((char *) h) + h->h_linp[i])
end_define

begin_comment
comment|/* is a {key,datum} too big to put on a single page? */
end_comment

begin_define
define|#
directive|define
name|TOOBIG
parameter_list|(
name|t
parameter_list|,
name|sz
parameter_list|)
value|(sz>= t->bt_psize / 5)
end_define

begin_comment
comment|/* is this a disk tree or a memory tree? */
end_comment

begin_define
define|#
directive|define
name|ISDISK
parameter_list|(
name|t
parameter_list|)
value|(t->bt_fname != (char *) NULL)
end_define

begin_comment
comment|/* does the disk tree use a cache? */
end_comment

begin_define
define|#
directive|define
name|ISCACHE
parameter_list|(
name|t
parameter_list|)
value|(t->bt_s.bt_d.d_cache != (char *) NULL)
end_define

begin_comment
comment|/*  *  DATUMs are for user data -- one appears on leaf pages for every  *  tree entry.  The d_bytes[] array contains the key first, then the data.  *  *  If either the key or the datum is too big to store on a single page,  *  a bit is set in the flags entry, and the d_bytes[] array contains a  *  pgno pointing to the page at which the data is actually stored.  *  *  Note on alignment:  every DATUM is guaranteed to be longword aligned  *  on the disk page.  In order to force longword alignment of user key  *  and data values, we must guarantee that the d_bytes[] array starts  *  on a longword boundary.  This is the reason that d_flags is a u_long,  *  rather than a u_char (it really only needs to be two bits big).  This  *  is necessary because we call the user's comparison function with a  *  pointer to the start of the d_bytes array.  We don't need to force  *  longword alignment of the data following the key, since that is copied  *  to a longword-aligned buffer before being returned to the user.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|DATUM
block|{
name|size_t
name|d_ksize
decl_stmt|;
comment|/* size of key */
name|size_t
name|d_dsize
decl_stmt|;
comment|/* size of data */
define|#
directive|define
name|D_BIGDATA
value|0x01
comment|/* indirect datum ptr flag */
define|#
directive|define
name|D_BIGKEY
value|0x02
comment|/* indirect key ptr flag */
name|u_long
name|d_flags
decl_stmt|;
comment|/* flags (indirect bit) */
name|char
name|d_bytes
index|[
literal|1
index|]
decl_stmt|;
comment|/* VARIABLE LENGTH DATA AT END OF STRUCT */
block|}
name|DATUM
typedef|;
end_typedef

begin_comment
comment|/* BTITEMs are used to return (page, index, datum) tuples from searches */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BTITEM
block|{
name|pgno_t
name|bti_pgno
decl_stmt|;
name|index_t
name|bti_index
decl_stmt|;
name|DATUM
modifier|*
name|bti_datum
decl_stmt|;
block|}
name|BTITEM
typedef|;
end_typedef

begin_comment
comment|/*  *  IDATUMs are for data stored on internal pages.  This is the (key, pgno)  *  pair, such that key 'key' is the first entry on page 'pgno'.  If our  *  internal page contains keys (a) and (b) next to each other, then all  *  items>= to (a) and< (b) go on the same page as (a).  There are some  *  gotchas with duplicate keys, however.  See the split code for details.  *  *  If a key is too big to fit on a single page, then the i_bytes[] array  *  contains a pgno pointing to the start of a chain that actually stores  *  the bytes.  Since items on internal pages are never deleted from the  *  tree, these indirect chains are marked as special, so that they won't  *  be deleted if the corresponding leaf item is deleted.  *  *  As for DATUMs, IDATUMs have a u_long flag entry (rather than u_char)  *  in order to guarantee that user keys are longword aligned on the disk  *  page.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|IDATUM
block|{
name|size_t
name|i_size
decl_stmt|;
name|pgno_t
name|i_pgno
decl_stmt|;
name|u_long
name|i_flags
decl_stmt|;
comment|/* see DATUM.d_flags, above */
name|char
name|i_bytes
index|[
literal|1
index|]
decl_stmt|;
comment|/* VARIABLE LENGTH DATA AT END OF STRUCT */
block|}
name|IDATUM
typedef|;
end_typedef

begin_comment
comment|/* all private interfaces have a leading _ in their names */
end_comment

begin_function_decl
specifier|static
name|BTITEM
modifier|*
name|_bt_search
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BTITEM
modifier|*
name|_bt_searchr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BTHEADER
modifier|*
name|_bt_allocpg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|index_t
name|_bt_binsrch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_isonpage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BTITEM
modifier|*
name|_bt_first
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_release
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_wrtmeta
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_delindir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_pgout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_pgin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_fixscan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_indirect
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_bt_crsrdel
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strcmp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|BTREEINFO
name|_DefaultBTInfo
init|=
block|{
literal|0
block|,
comment|/* flags */
literal|0
block|,
comment|/* cachesize */
literal|0
block|,
comment|/* psize */
name|strcmp
block|,
comment|/* compare */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  BTREE_OPEN -- Wrapper routine to open a btree.  *  *	Creates and fills a DB struct, and calls the routine that actually  *	opens the btree.  *  *	Parameters:  *		f:  filename to open  *		flags:  flag bits passed to open  *		mode:  permission bits, used if O_CREAT specified  *		b:  BTREEINFO pointer  *  *	Returns:  *		Filled-in DBT on success; NULL on failure, with errno  *		set as appropriate.  *  *	Side Effects:  *		Allocates memory for the DB struct.  */
end_comment

begin_function
name|DB
modifier|*
name|btree_open
parameter_list|(
name|f
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|BTREEINFO
modifier|*
name|b
decl_stmt|;
block|{
name|DB
modifier|*
name|db
decl_stmt|;
name|BTREE
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
operator|(
name|DB
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|DB
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|DB
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|DB
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|=
name|bt_open
argument_list|(
name|f
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|b
argument_list|)
operator|)
operator|==
operator|(
name|BTREE
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|DB
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|db
operator|->
name|internal
operator|=
operator|(
name|char
operator|*
operator|)
name|t
expr_stmt|;
name|db
operator|->
name|close
operator|=
name|bt_close
expr_stmt|;
name|db
operator|->
name|delete
operator|=
name|bt_delete
expr_stmt|;
name|db
operator|->
name|get
operator|=
name|bt_get
expr_stmt|;
name|db
operator|->
name|put
operator|=
name|bt_put
expr_stmt|;
name|db
operator|->
name|seq
operator|=
name|bt_seq
expr_stmt|;
name|db
operator|->
name|sync
operator|=
name|bt_sync
expr_stmt|;
return|return
operator|(
name|db
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_OPEN -- Open a btree.  *  *	This routine creates the correct kind (disk or in-memory) of  *	btree and initializes it as required.  *  *	Parameters:  *		f -- name of btree (NULL for in-memory btrees)  *		flags -- flags passed to open()  *		mode -- mode passed to open ()  *		b -- BTREEINFO structure, describing btree  *  *	Returns:  *		(Opaque) pointer to the btree.  On failure, returns NULL  *		with errno set as appropriate.  *  *	Side Effects:  *		Allocates memory, opens files.  */
end_comment

begin_function
name|BTREE
name|bt_open
parameter_list|(
name|f
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|BTREEINFO
modifier|*
name|b
decl_stmt|;
block|{
name|BTREE_P
name|t
decl_stmt|;
name|HTABLE
name|ht
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|BTMETA
name|m
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
comment|/* use the default info if none was provided */
if|if
condition|(
name|b
operator|==
operator|(
name|BTREEINFO
operator|*
operator|)
name|NULL
condition|)
name|b
operator|=
operator|&
name|_DefaultBTInfo
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|BTREE_P
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
expr|*
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTREE_P
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|b
operator|->
name|compare
condition|)
name|t
operator|->
name|bt_compare
operator|=
name|b
operator|->
name|compare
expr_stmt|;
else|else
name|t
operator|->
name|bt_compare
operator|=
name|strcmp
expr_stmt|;
name|t
operator|->
name|bt_fname
operator|=
name|f
expr_stmt|;
name|t
operator|->
name|bt_curpage
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
expr_stmt|;
name|t
operator|->
name|bt_free
operator|=
name|P_NONE
expr_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|P_NONE
expr_stmt|;
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|c_flags
operator|=
operator|(
name|u_char
operator|)
name|NULL
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|t
operator|->
name|bt_stack
operator|=
operator|(
name|BTSTACK
operator|*
operator|)
name|NULL
expr_stmt|;
name|t
operator|->
name|bt_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  If no file name was supplied, this is an in-memory btree. 	 *  Otherwise, it's a disk-based btree. 	 */
if|if
condition|(
name|f
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* in memory */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_psize
operator|=
name|b
operator|->
name|psize
operator|)
operator|<
name|MINPSIZE
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|bt_psize
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_psize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
block|}
name|nbytes
operator|=
name|HTSIZE
operator|*
sizeof|sizeof
argument_list|(
name|HTBUCKET
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ht
operator|=
operator|(
name|HTABLE
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|HTABLE
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ht
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
operator|=
name|ht
expr_stmt|;
name|t
operator|->
name|bt_npages
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|bt_lorder
operator|=
name|BYTE_ORDER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|R_DUP
operator|)
condition|)
name|t
operator|->
name|bt_flags
operator||=
name|BTF_NODUPS
expr_stmt|;
block|}
else|else
block|{
comment|/* on disk */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* doesn't exist yet, be sure page is big enough */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_psize
operator|=
name|b
operator|->
name|psize
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|BTHEADER
argument_list|)
operator|&&
name|b
operator|->
name|psize
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|->
name|lorder
operator|==
literal|0
condition|)
name|b
operator|->
name|lorder
operator|=
name|BYTE_ORDER
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|lorder
operator|!=
name|BIG_ENDIAN
operator|&&
name|b
operator|->
name|lorder
operator|!=
name|LITTLE_ENDIAN
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_lorder
operator|=
name|b
operator|->
name|lorder
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|->
name|flags
operator|&
name|R_DUP
operator|)
condition|)
name|t
operator|->
name|bt_flags
operator||=
name|BTF_NODUPS
expr_stmt|;
block|}
else|else
block|{
comment|/* exists, get page size from file */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* lorder always stored in host-independent format */
name|NTOHL
argument_list|(
name|m
operator|.
name|m_lorder
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|m_lorder
operator|!=
name|BIG_ENDIAN
operator|&&
name|m
operator|.
name|m_lorder
operator|!=
name|LITTLE_ENDIAN
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_lorder
operator|=
name|m
operator|.
name|m_lorder
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_lorder
operator|!=
name|BYTE_ORDER
condition|)
block|{
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_magic
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_version
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_psize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_free
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|.
name|m_magic
operator|!=
name|BTREEMAGIC
operator|||
name|m
operator|.
name|m_version
operator|!=
name|BTREEVERSION
operator|||
name|m
operator|.
name|m_psize
operator|<
name|MINPSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|EFTYPE
define|#
directive|define
name|EFTYPE
value|-100
endif|#
directive|endif
name|errno
operator|=
name|EFTYPE
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
name|t
operator|->
name|bt_psize
operator|=
name|m
operator|.
name|m_psize
expr_stmt|;
name|t
operator|->
name|bt_free
operator|=
name|m
operator|.
name|m_free
expr_stmt|;
name|t
operator|->
name|bt_flags
operator||=
operator|(
name|m
operator|.
name|m_flags
operator|&
name|BTF_NODUPS
operator|)
operator||
name|BTF_METAOK
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* now open the file the way the user wanted it */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
operator|=
name|open
argument_list|(
name|f
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* get number of pages, page size if necessary */
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_psize
operator|==
literal|0
condition|)
name|t
operator|->
name|bt_psize
operator|=
name|buf
operator|.
name|st_blksize
expr_stmt|;
name|t
operator|->
name|bt_npages
operator|=
call|(
name|pgno_t
call|)
argument_list|(
name|buf
operator|.
name|st_size
operator|/
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
comment|/* page zero is metadata, doesn't count */
if|if
condition|(
name|t
operator|->
name|bt_npages
operator|>
literal|0
condition|)
operator|--
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cachesize
operator|==
literal|0
condition|)
name|b
operator|->
name|cachesize
operator|=
name|DEFCACHE
expr_stmt|;
comment|/* get an lru buffer cache, if the user asked for one */
if|if
condition|(
operator|(
name|b
operator|->
name|cachesize
operator|/
name|t
operator|->
name|bt_psize
operator|)
operator|>
literal|0
condition|)
block|{
name|BTDISK
modifier|*
name|d
init|=
operator|&
operator|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|)
decl_stmt|;
name|d
operator|->
name|d_cache
operator|=
name|lruinit
argument_list|(
name|d
operator|->
name|d_fd
argument_list|,
name|b
operator|->
name|cachesize
operator|/
name|t
operator|->
name|bt_psize
argument_list|,
name|t
operator|->
name|bt_psize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_lorder
argument_list|,
name|_bt_pgin
argument_list|,
name|_bt_pgout
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_cache
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/* remember if tree was opened for write */
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|O_WRONLY
operator|)
operator|==
name|O_WRONLY
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|O_RDWR
operator|)
operator|==
name|O_RDWR
operator|)
condition|)
name|t
operator|->
name|bt_flags
operator||=
name|BTF_ISWRITE
expr_stmt|;
return|return
operator|(
operator|(
name|BTREE
operator|)
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_GET -- Get an entry from a btree.  *  *	Does a key lookup in the tree to find the specified key, and returns  *	the key/data pair found.  *  *	Parameters:  *		tree -- btree in which to do lookup  *		key -- key to find  *		data -- pointer to DBT in which to return data  *		flag -- ignored  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if the key is not  *		found.  If key is not found, nothing is stored in the  *		return DBT 'data'.  *  *	Side Effects:  *		None.  *  *	Warnings:  *		Return data is statically allocated, and will be overwritten  *		at the next call.  */
end_comment

begin_function
name|int
name|bt_get
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
comment|/* lookup */
name|item
operator|=
name|_bt_search
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
operator|(
name|BTITEM
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* clear parent pointer stack */
while|while
condition|(
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|!=
name|P_NONE
condition|)
continue|continue;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* match? */
if|if
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
literal|0
condition|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|_bt_buildret
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
comment|/* nope */
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_PUT -- Add an entry to a btree.  *  *	The specified (key, data) pair is added to the tree.  If the tree  *	was created for unique keys only, then duplicates will not be  *	entered.  If the requested key exists in the tree, it will be over-  *	written unless the flags parameter is R_NOOVERWRITE, in which case  *	the update will not be done.  If duplicate keys are permitted in the  *	tree, duplicates will be inserted and will not overwrite existing  *	keys.  Nodes are split as required.  *  *	Parameters:  *		tree -- btree in which to put the new entry  *		key -- key component to add  *		data -- data corresponding to key  *		flag -- R_NOOVERWRITE or zero.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if the  *		NOOVERWRITE flag was set and the specified key exists  *		in the database.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|bt_put
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
comment|/* look for this key in the tree */
name|item
operator|=
name|_bt_search
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* 	 *  If this tree was originally created without R_DUP, then duplicate 	 *  keys are not allowed.  We need to check this at insertion time. 	 */
if|if
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_NODUPS
operator|)
operator|&&
name|flag
operator|==
name|R_NOOVERWRITE
condition|)
block|{
if|if
condition|(
name|_bt_delone
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
return|return
operator|(
name|_bt_insert
argument_list|(
name|t
argument_list|,
name|item
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_DELETE -- delete a key from the tree.  *  *	Deletes all keys (and their associated data items) matching the  *	supplied key from the tree.  If the flags entry is R_CURSOR, then  *	the current item in the active scan is deleted.  *  *	Parameters:  *		tree -- btree from which to delete key  *		key -- key to delete  *		flags -- R_CURSOR or zero  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if the specified  *		key was not in the tree.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
name|int
name|bt_delete
parameter_list|(
name|tree
parameter_list|,
name|key
parameter_list|,
name|flags
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
name|int
name|ndel
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_CURSOR
condition|)
return|return
operator|(
name|_bt_crsrdel
argument_list|(
name|t
argument_list|)
operator|)
return|;
comment|/* find the first matching key in the tree */
name|item
operator|=
name|_bt_first
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* delete all matching keys */
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|&&
operator|(
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|_bt_delone
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ndel
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|||
name|h
operator|->
name|h_nextpg
operator|==
name|P_NONE
condition|)
break|break;
comment|/* next page, if necessary */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
name|item
operator|->
name|bti_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
name|item
operator|->
name|bti_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|VALIDITEM
argument_list|(
name|t
argument_list|,
name|item
argument_list|)
operator|||
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* clean up the parent stack */
while|while
condition|(
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|!=
name|P_NONE
condition|)
continue|continue;
comment|/* flush changes to disk */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_DIRTY
condition|)
block|{
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|bt_curpage
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ndel
operator|==
literal|0
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_CRSRDEL -- Delete the item pointed to by the cursor.  *  *	This routine deletes the item most recently returned by a scan  *	through the tree.  Since it only makes sense to delete the current  *	record once, we make sure that we don't try to delete twice without  *	advancing the scan.  *  *	Parameters:  *		t -- tree in which to do deletion  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		The call to _bt_delone marks the cursor, so we can tell that  *		the current record has been deleted.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_crsrdel
parameter_list|(
name|t
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
block|{
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
comment|/* a cursor must exist, and can't have deleted the current key yet */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|)
operator|||
operator|(
name|c
operator|->
name|c_flags
operator|&
name|CRSR_BEFORE
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|c
operator|->
name|c_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|c
operator|->
name|c_index
operator|>=
name|NEXTINDEX
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|_bt_delone
argument_list|(
name|t
argument_list|,
name|c
operator|->
name|c_index
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_DELONE -- Delete a single entry from a btree.  *  *	This routine physically removes a btree entry from a leaf page.  *	IDATUM items are *never* removed from internal nodes, regardless  *	of whether the entries that originally caused them to be added  *	are removed from the tree or not.  In addition, pages made empty  *	by element deletion are not actually reclaimed.  They are,  *	however, made available for reuse.  *  *	To delete an item from a page, we pack the remaining items at  *	the end of the page, overwriting the deleted item's entry.  We  *	move the line pointers backward on the page, overwriting the  *	original item's line pointer.  This guarantees that the space in  *	the middle of the page is free -- a property that our insertion  *	strategy relies on.  *  *	This routine doesn't reclaim pages all of whose entries have  *	been deleted.  These pages are available for reuse, however.  *	If an item is deleted that was too big to fit on a page, then  *	the blocks that it occupies are put on a free list for reuse.  *  *	Parameters:  *		t -- btree from which to delete item  *		index -- index of entry on current page to delete  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Physically changes page layout, adjusts internal page  *		state to reflect the deletion of the item, and updates  *		the list of free pages for this tree.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_delone
parameter_list|(
name|t
parameter_list|,
name|index
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|index_t
name|index
decl_stmt|;
block|{
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|nmoved
decl_stmt|;
name|index_t
name|off
decl_stmt|;
name|index_t
name|top
decl_stmt|;
name|index_t
name|i
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
comment|/* deletion may confuse an active scan.  fix it.  */
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|&&
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
operator|==
name|c
operator|->
name|c_pgno
condition|)
if|if
condition|(
name|_bt_fixscan
argument_list|(
name|t
argument_list|,
name|index
argument_list|,
operator|(
name|DATUM
operator|*
operator|)
name|NULL
argument_list|,
name|DELETE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|off
operator|=
name|h
operator|->
name|h_linp
index|[
name|index
index|]
expr_stmt|;
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* if this is a big item, reclaim the space it occupies */
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_delindir
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGDATA
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_delindir
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* move the data down on the page */
name|nbytes
operator|=
name|d
operator|->
name|d_ksize
operator|+
name|d
operator|->
name|d_dsize
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|DATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|nbytes
operator|=
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|h
operator|->
name|h_upper
expr_stmt|;
name|dest
operator|=
name|src
operator|+
name|nbytes
expr_stmt|;
name|nmoved
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|)
operator|-
name|src
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|nmoved
argument_list|)
expr_stmt|;
comment|/* next move the line pointers up */
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
name|index
operator|+
literal|1
index|]
operator|)
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
name|index
index|]
operator|)
expr_stmt|;
name|nmoved
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
index|]
operator|)
operator|)
operator|-
name|src
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|nmoved
argument_list|)
expr_stmt|;
comment|/* remember that we freed up some space */
name|h
operator|->
name|h_upper
operator|+=
name|nbytes
expr_stmt|;
name|h
operator|->
name|h_lower
operator|-=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* adjust offsets in line pointers affected by moving the data */
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|h_linp
index|[
name|i
index|]
operator|<
name|off
condition|)
name|h
operator|->
name|h_linp
index|[
name|i
index|]
operator|+=
name|nbytes
expr_stmt|;
block|}
comment|/* it's gone */
name|h
operator|->
name|h_flags
operator||=
name|F_DIRTY
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_FIXSCAN -- Adjust a scan to cope with a change in tree structure.  *  *	If the user has an active scan on the database, and we delete an  *	item from the page the cursor is pointing at, we need to figure  *	out what to do about it.  Basically, the solution is to point  *	"between" keys in the tree, using the CRSR_BEFORE flag.  The  *	requirement is that the user should not miss any data in the  *	tree during a scan, just because he happened to do some deletions  *	or insertions while it was active.  *  *	In order to guarantee that the scan progresses properly, we need  *	to save the key of any deleted item we were pointing at, so that  *	we can check later insertions against it.  *  *	Parameters:  *		t -- tree to adjust  *		index -- index of item at which change was made  *		newd -- new datum (for insertions only)  *		op -- operation (DELETE or INSERT) causing change  *  *	Returns:  *		RET_SUCCESS, RET_ERROR (errno is set).  *  *	Side Effects:  *		None.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_fixscan
parameter_list|(
name|t
parameter_list|,
name|index
parameter_list|,
name|newd
parameter_list|,
name|op
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|index_t
name|index
decl_stmt|;
name|DATUM
modifier|*
name|newd
decl_stmt|;
name|int
name|op
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|DELETE
condition|)
block|{
if|if
condition|(
name|index
operator|<
name|c
operator|->
name|c_index
condition|)
name|c
operator|->
name|c_index
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
name|c
operator|->
name|c_index
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|c_flags
operator|&
name|CRSR_BEFORE
operator|)
condition|)
block|{
if|if
condition|(
name|_bt_crsrkey
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|c
operator|->
name|c_flags
operator||=
name|CRSR_BEFORE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 *  If we previously deleted the object at this location, 		 *  and now we're inserting a new one, we need to do the 		 *  right thing -- the cursor should come either before 		 *  or after the new item, depending on the key that was 		 *  here, and the new one. 		 */
if|if
condition|(
name|c
operator|->
name|c_flags
operator|&
name|CRSR_BEFORE
condition|)
block|{
if|if
condition|(
name|index
operator|<=
name|c
operator|->
name|c_index
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|itmp
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|int
name|r
decl_stmt|;
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|newd
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|itmp
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
name|tmp
operator|=
operator|&
operator|(
name|newd
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|r
operator|=
operator|(
operator|*
operator|(
name|t
operator|->
name|bt_compare
operator|)
operator|)
operator|(
name|tmp
operator|,
name|c
operator|->
name|c_key
operator|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|c
operator|->
name|c_index
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|index
operator|<=
name|c
operator|->
name|c_index
condition|)
name|c
operator|->
name|c_index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_CRSRKEY -- Save a copy of the key of the record that the cursor  *		   is pointing to.  The record is about to be deleted.  *  *	Parameters:  *		t -- btree  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Allocates memory for the copy which should be released when  *		it is no longer needed.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_crsrkey
parameter_list|(
name|t
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
block|{
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|,
name|c
operator|->
name|c_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pgno
argument_list|,
sizeof|sizeof
argument_list|(
name|pgno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|,
operator|&
operator|(
name|c
operator|->
name|c_key
operator|)
argument_list|,
operator|&
name|ignore
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|c_key
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|d_ksize
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|c
operator|->
name|c_key
argument_list|,
name|d
operator|->
name|d_ksize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_GETBIG -- Get big data from indirect pages.  *  *	This routine chases indirect blocks for the big object at the   *	specified page to a buffer, and return the address of the buffer.  *  *	Parameters:  *		t -- btree with the indirect blocks  *		pgno -- page number that starts the chain  *		p -- (char **) to get the address of the buffer containing  *		     the key or datum.  *		sz -- pointer to an int to get the size of the instantiated  *		      object.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_getbig
parameter_list|(
name|t
parameter_list|,
name|pgno
parameter_list|,
name|p
parameter_list|,
name|sz
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|sz
decl_stmt|;
block|{
name|pgno_t
name|save
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|size_t
name|nhere
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|top
decl_stmt|,
modifier|*
name|from
decl_stmt|,
modifier|*
name|where
decl_stmt|;
name|save
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
operator|*
name|sz
operator|=
name|nbytes
expr_stmt|;
name|from
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|t
operator|->
name|bt_psize
expr_stmt|;
comment|/* need more space for data? */
name|where
operator|=
operator|*
name|p
expr_stmt|;
while|while
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
name|nhere
operator|=
call|(
name|int
call|)
argument_list|(
name|top
operator|-
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhere
operator|>
name|nbytes
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
name|nhere
argument_list|)
expr_stmt|;
name|where
operator|+=
name|nhere
expr_stmt|;
name|nbytes
operator|-=
name|nhere
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|top
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|t
operator|->
name|bt_psize
expr_stmt|;
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_DELINDIR -- Delete a chain of indirect blocks from the btree.  *  *	When a large item is deleted from the tree, this routine puts the  *	space that it occupied onto the free list for later reuse.  The  *	bt_free entry in the btree structure points at the head of this list.  *	This value is also stored on disk in the btree's metadata.  *  *	Parameters:  *		t -- btree from which to delete pages  *		chain -- page number that starts the chain.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Invalidates the current on-disk version of the btree's  *		metadata (if any), and updates the free list appropriately.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_delindir
parameter_list|(
name|t
parameter_list|,
name|chain
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|pgno_t
name|save
decl_stmt|;
name|pgno_t
name|oldfree
decl_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|save
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 *  If some internal node is pointing at this chain, don't 	 *  delete it. 	 */
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
operator|&
name|F_PRESERVE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
comment|/* if there's nothing on the free list, this is easy... */
if|if
condition|(
name|t
operator|->
name|bt_free
operator|==
name|P_NONE
condition|)
block|{
name|t
operator|->
name|bt_free
operator|=
name|chain
expr_stmt|;
block|}
else|else
block|{
name|oldfree
operator|=
name|t
operator|->
name|bt_free
expr_stmt|;
comment|/* find the end of the data chain for the deleted datum */
name|t
operator|->
name|bt_free
operator|=
name|chain
expr_stmt|;
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
name|chain
operator|=
name|h
operator|->
name|h_nextpg
expr_stmt|;
block|}
do|while
condition|(
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
comment|/* link freed pages into free list */
name|h
operator|->
name|h_nextpg
operator|=
name|oldfree
expr_stmt|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|oldfree
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* restore the tree's current page pointer */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* we have trashed the tree metadata; rewrite it later */
name|t
operator|->
name|bt_flags
operator|&=
operator|~
name|BTF_METAOK
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_FIRST -- Find the first item in the tree that matches the supplied  *		 key.  *  *	This routine supports deletion.  When the user supplies a key to  *	be deleted, we find the first one, and iteratively delete all the  *	matching ones that follow it.  *  *	Parameters:  *		t -- btree in which to find first occurrence  *		key -- key to find  *  *	Returns:  *		The BTITEM for the matching item.  If there's no match,  *		this may point to the first item> than the supplied key,  *		or off the end of the page.  *  *	Warnings:  *		The BTITEM returned is in static space and will be overwritten  *		by the next search of any kind in any btree.  */
end_comment

begin_function
specifier|static
name|BTITEM
modifier|*
name|_bt_first
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
name|index_t
name|next
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* find any matching item */
name|item
operator|=
name|_bt_search
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|next
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* if we're off the end of the page, search failed and we're done */
if|if
condition|(
name|item
operator|->
name|bti_index
operator|>=
name|next
condition|)
return|return
operator|(
name|item
operator|)
return|;
comment|/* as long as we have an exact match, walk backwards */
while|while
condition|(
operator|(
name|r
operator|=
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|item
operator|->
name|bti_index
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* at start of page? */
if|if
condition|(
name|item
operator|->
name|bti_index
operator|==
literal|0
condition|)
block|{
comment|/* if no prev page, we're done */
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
condition|)
return|return
operator|(
name|item
operator|)
return|;
comment|/* walk backward, skipping empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
operator|(
name|BTITEM
operator|*
operator|)
name|NULL
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_prevpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|!=
literal|0
condition|)
name|item
operator|->
name|bti_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|item
operator|->
name|bti_index
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|bti_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|bti_index
operator|--
expr_stmt|;
block|}
block|}
comment|/* if we went too far backwards, step forward one entry */
if|if
condition|(
name|r
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|++
operator|(
name|item
operator|->
name|bti_index
operator|)
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
block|{
comment|/* walk forward, skipping empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
operator|(
name|BTITEM
operator|*
operator|)
name|NULL
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
do|while
condition|(
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
operator|&&
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
do|;
name|item
operator|->
name|bti_index
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|bti_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
block|}
comment|/* got it */
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SEARCH, _BT_SEARCHR -- Search for a particular key in the tree.  *  *	Parameters:  *		t -- btree in which to search  *		key -- key to find  *  *	Returns:  *		BTITEM for matching item, if any, or the BTITEM for the  *		location of the key, if it were in the tree.  *  *	Warnings:  *		The BTITEM returned is in static memory, and will be  *		overwritten by the next search of any kind in any tree.  */
end_comment

begin_function
specifier|static
name|BTITEM
modifier|*
name|_bt_search
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
block|{
comment|/* we want to start all of our searches at the root */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|P_ROOT
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
operator|(
name|BTITEM
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|_bt_searchr
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|BTITEM
modifier|*
name|_bt_searchr
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|index_t
name|index
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
specifier|static
name|BTITEM
name|item
decl_stmt|;
comment|/* do a binary search on the current page */
name|index
operator|=
name|_bt_binsrch
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|key
operator|->
name|data
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  At this point, the binary search terminated because the endpoints 	 *  got too close together, or we have a match.  Figure out which 	 *  case applies and decide what to do based on the page type. 	 */
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|item
operator|.
name|bti_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
name|item
operator|.
name|bti_index
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|NULL
expr_stmt|;
name|item
operator|.
name|bti_datum
operator|=
name|d
expr_stmt|;
return|return
operator|(
operator|&
name|item
operator|)
return|;
block|}
else|else
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|_bt_push
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_pgno
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|id
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
operator|(
name|BTITEM
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|_bt_searchr
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  BT_GETPAGE -- Make pgno the current page of the btree.  *  *	This routine is just a wrapper that decides whether to call the  *	memory or disk-based routine to do the work.  *  *	Parameters:  *		t -- btree in which to get page  *		pgno -- page number to get  *  *	Returns:  *		RET_SUCCESS or RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_getpage
parameter_list|(
name|t
parameter_list|,
name|pgno
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pgno
operator|==
name|P_NONE
condition|)
name|_punt
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* see if we can get away without doing any work */
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|!=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
operator|==
name|pgno
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|->
name|bt_fname
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|_bt_getmpage
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|_bt_getdpage
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_GETMPAGE -- Make pgno the current page of the btree.  *  *	This routine gets pages for in-memory btrees.  *  *	Parameters:  *		t -- btree in which to get page  *		pgno -- page number to get  *  *	Returns:  *		RET_SUCCESS or RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_getmpage
parameter_list|(
name|t
parameter_list|,
name|pgno
parameter_list|)
specifier|register
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
block|{
name|int
name|htindex
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|HTBUCKET
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|pgno
operator|!=
name|P_ROOT
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|t
operator|->
name|bt_npages
operator|++
expr_stmt|;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|->
name|h_pgno
operator|=
name|P_ROOT
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|F_LEAF
expr_stmt|;
name|h
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|h
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
name|t
operator|->
name|bt_curpage
operator|=
name|h
expr_stmt|;
comment|/* get the root page into the hash table */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|htindex
operator|=
name|HASHKEY
argument_list|(
name|pgno
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
index|[
name|htindex
index|]
init|;
name|b
operator|!=
operator|(
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|ht_next
control|)
block|{
if|if
condition|(
name|b
operator|->
name|ht_pgno
operator|==
name|pgno
condition|)
block|{
name|t
operator|->
name|bt_curpage
operator|=
name|b
operator|->
name|ht_page
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_GETDPAGE -- Make pgno the current page of the btree.  *  *	This routine gets pages for disk btrees.  *  *	Because disk btree pages must be readable across machine architectures,  *	the btree code writes integers out in network format.  This routine  *	converts them back to host format before returning the page.  *  *	Parameters:  *		t -- btree in which to get page  *		pgno -- page number to get  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_getdpage
parameter_list|(
name|t
parameter_list|,
name|pgno
parameter_list|)
specifier|register
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|cache
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
comment|/* if we have an lru cache, let the cache code do the work */
if|if
condition|(
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cache
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
expr_stmt|;
comment|/* release the old page */
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|!=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
name|pgno_t
name|opgno
init|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
decl_stmt|;
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
operator|&=
operator|~
name|F_DIRTY
expr_stmt|;
if|if
condition|(
name|lruwrite
argument_list|(
name|cache
argument_list|,
name|opgno
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|lrurelease
argument_list|(
name|cache
argument_list|,
name|opgno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pgno
operator|>
name|t
operator|->
name|bt_npages
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|lrugetnew
argument_list|(
name|cache
argument_list|,
name|pgno
argument_list|,
operator|&
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|t
operator|->
name|bt_npages
operator|=
name|pgno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|lruget
argument_list|(
name|cache
argument_list|,
name|pgno
argument_list|,
operator|&
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* init this page, if necessary */
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|h_pgno
operator|=
name|pgno
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|F_LEAF
expr_stmt|;
name|h
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|h
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
block|}
name|t
operator|->
name|bt_curpage
operator|=
name|h
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
comment|/* sync the current page, if necessary */
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|!=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
operator|&
name|F_DIRTY
condition|)
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|bt_curpage
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|->
name|bt_npages
operator|==
literal|0
condition|)
name|t
operator|->
name|bt_npages
operator|=
literal|1
expr_stmt|;
comment|/* if no current page, get space for one */
if|if
condition|(
operator|(
name|t
operator|->
name|bt_curpage
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
name|n
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|pos
operator|=
call|(
name|long
call|)
argument_list|(
name|pgno
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* seek to correct location in file */
if|if
condition|(
name|lseek
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
block|{
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* read the page */
if|if
condition|(
operator|(
name|nbytes
operator|=
name|read
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
name|t
operator|->
name|bt_curpage
argument_list|,
name|n
argument_list|)
operator|)
operator|<
name|n
condition|)
block|{
comment|/* 		 *  If we didn't get a full page, we must have gotten no 		 *  data at all -- in which case we're trying to read a 		 *  root page that doesn't exist yet.  This is the only 		 *  case in which this is okay.  If this happens, construct 		 *  an empty root page by hand. 		 */
if|if
condition|(
name|nbytes
operator|!=
literal|0
operator|||
name|pgno
operator|!=
name|P_ROOT
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_pgno
operator|=
name|pgno
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|F_LEAF
expr_stmt|;
name|h
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|h
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|_bt_pgin
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_lorder
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_PGOUT, _BT_PGIN -- Convert host-specific number layout to/from  *			   the host-independent format stored on disk.  *  *	Parameters:  *		h -- page to convert  *		_lorder -- byte order for pages (stored as a char * in the  *			   cache, and passed around as a magic cookie).  *  *	Returns:  *		RET_SUCCESS (lru code requires a return value).  *  *	Side Effects:  *		Layout of tree metadata on the page is changed in place.  *  *	Warnings:  *		Everywhere else in the code, the types pgno_t and index_t  *		are opaque.  These two routines know what they really  *		are.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_pgout
parameter_list|(
name|h
parameter_list|,
name|_lorder
parameter_list|)
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|_lorder
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|lorder
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|size_t
name|chain
decl_stmt|;
name|lorder
operator|=
operator|(
name|int
operator|)
name|_lorder
expr_stmt|;
if|if
condition|(
name|lorder
operator|==
name|BYTE_ORDER
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_CONT
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
condition|)
block|{
name|size_t
name|longsz
decl_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|longsz
argument_list|,
sizeof|sizeof
argument_list|(
name|longsz
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|longsz
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|longsz
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|longsz
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGDATA
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BLSWAP
argument_list|(
name|d
operator|->
name|d_dsize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|d
operator|->
name|d_ksize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|d
operator|->
name|d_flags
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_linp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|id
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|id
operator|->
name|i_pgno
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|id
operator|->
name|i_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_linp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_flags
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_pgno
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_prevpg
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_nextpg
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_lower
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_upper
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_bt_pgin
parameter_list|(
name|h
parameter_list|,
name|_lorder
parameter_list|)
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|_lorder
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|lorder
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|size_t
name|chain
decl_stmt|;
comment|/* 	 *  If btree pages are to be stored in the host byte order, don't 	 *  bother swapping. 	 */
name|lorder
operator|=
operator|(
name|int
operator|)
name|_lorder
expr_stmt|;
if|if
condition|(
name|lorder
operator|==
name|BYTE_ORDER
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_upper
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_lower
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_nextpg
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_prevpg
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_pgno
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_CONT
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
condition|)
block|{
name|size_t
name|longsz
decl_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|longsz
argument_list|,
sizeof|sizeof
argument_list|(
name|longsz
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|longsz
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|longsz
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|longsz
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_linp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|d
operator|->
name|d_dsize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|d
operator|->
name|d_ksize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|d
operator|->
name|d_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGDATA
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
name|BLSWAP
argument_list|(
name|h
operator|->
name|h_linp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|id
operator|->
name|i_size
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|id
operator|->
name|i_pgno
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|id
operator|->
name|i_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|chain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_SYNC -- sync the btree to disk.  *  *	Parameters:  *		tree -- btree to sync.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  */
end_comment

begin_macro
name|bt_sync
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|BTREE
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
comment|/* if this is an in-memory btree, syncing is a no-op */
if|if
condition|(
operator|!
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|F_DIRTY
expr_stmt|;
if|if
condition|(
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pgno
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|lrusync
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
argument_list|)
operator|<
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|fsync
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  _BT_INSERT -- Insert a new user datum in the btree.  *  *	This routine is called by bt_put, the public interface, once the  *	location for the new item is known.  We do the work here, and  *	handle splits if necessary.  *  *	Parameters:  *		t -- btree in which to do the insertion.  *		item -- BTITEM describing location of new datum  *		key -- key to insert  *		data -- data associated with key  *		flag -- magic cookie passed recursively to bt_put if we  *			have to do a split  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_insert
parameter_list|(
name|t
parameter_list|,
name|item
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|BTITEM
modifier|*
name|item
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|index_t
name|index
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|status
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
name|int
name|keysize
decl_stmt|,
name|datasize
decl_stmt|;
name|int
name|bigkey
decl_stmt|,
name|bigdata
decl_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|TOOBIG
argument_list|(
name|t
argument_list|,
name|data
operator|->
name|size
argument_list|)
condition|)
block|{
name|bigdata
operator|=
name|TRUE
expr_stmt|;
name|datasize
operator|=
sizeof|sizeof
argument_list|(
name|pgno_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bigdata
operator|=
name|FALSE
expr_stmt|;
name|datasize
operator|=
name|data
operator|->
name|size
expr_stmt|;
block|}
if|if
condition|(
name|TOOBIG
argument_list|(
name|t
argument_list|,
name|key
operator|->
name|size
argument_list|)
condition|)
block|{
name|bigkey
operator|=
name|TRUE
expr_stmt|;
name|keysize
operator|=
sizeof|sizeof
argument_list|(
name|pgno_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bigkey
operator|=
name|FALSE
expr_stmt|;
name|keysize
operator|=
name|key
operator|->
name|size
expr_stmt|;
block|}
name|nbytes
operator|=
name|keysize
operator|+
name|datasize
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|DATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|nbytes
operator|=
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* if there's not enough room here, split the page */
if|if
condition|(
operator|(
name|h
operator|->
name|h_upper
operator|-
name|h
operator|->
name|h_lower
operator|)
operator|<
name|nbytes
condition|)
block|{
if|if
condition|(
name|_bt_split
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* okay, try again */
return|return
operator|(
name|bt_put
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
comment|/* put together a leaf page datum from the key/data pair */
name|index
operator|=
name|item
operator|->
name|bti_index
expr_stmt|;
name|nbytes
operator|=
name|keysize
operator|+
name|datasize
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|DATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
operator|)
operator|==
operator|(
name|DATUM
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|d
operator|->
name|d_ksize
operator|=
name|keysize
expr_stmt|;
name|d
operator|->
name|d_dsize
operator|=
name|datasize
expr_stmt|;
name|d
operator|->
name|d_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigkey
condition|)
block|{
if|if
condition|(
name|_bt_indirect
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
operator|&
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pgno
argument_list|,
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pgno
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_flags
operator||=
name|D_BIGKEY
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|d_ksize
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
operator|->
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|d_ksize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bigdata
condition|)
block|{
if|if
condition|(
name|_bt_indirect
argument_list|(
name|t
argument_list|,
name|data
argument_list|,
operator|&
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pgno
argument_list|,
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|keysize
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pgno
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|d_flags
operator||=
name|D_BIGDATA
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|item
operator|->
name|bti_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|d_dsize
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|keysize
index|]
operator|)
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|d_dsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do the insertion */
name|status
operator|=
name|_bt_insertat
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_INDIRECT -- Write a series of indirect pages for big objects.  *  *	A chain of indirect pages looks like  *  *	   +-------------------+   +---------------------+  *	   |hdr|size|	       |   |hdr|		 |  *	   +---+----+	       |   +---+		 |  *	   |   ... data ...    |   |   ... data ...	 |    ...  *	   |		       |   |			 |  *	   +-------------------+   +---------------------+  *  *	where hdr is a standard btree page header (with the indirect bit  *	set), size on the first page is the real size of the datum, and  *	data are bytes of the datum, split across as many pages as necessary.  *	Indirect pages are chained together with the h_prevpg and h_nextpg  *	entries of the page header struct.  *  *	A single DBT is written per chain, so space on the last page is  *	wasted.  *  *	We return the page number of the start of the chain.  *  *	When a big object is deleted from a tree, the space that it occupied  *	is placed on a free list for later reuse.  This routine checks that  *	free list before allocating new pages to the big datum being inserted.  *  *	Parameters:  *		t -- btree in which to store indirect blocks  *		data -- DBT with the big datum in it  *		pgno -- place to put the starting page number of the chain  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Current page is changed on return.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_indirect
parameter_list|(
name|t
parameter_list|,
name|data
parameter_list|,
name|pgno
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|pgno_t
modifier|*
name|pgno
decl_stmt|;
block|{
name|pgno_t
name|save
decl_stmt|;
name|pgno_t
name|prev
decl_stmt|;
name|char
modifier|*
name|top
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|size_t
name|dsize
decl_stmt|;
name|pgno_t
name|nextchn
decl_stmt|;
name|int
name|ischain
decl_stmt|;
name|BTHEADER
modifier|*
name|cur
decl_stmt|;
comment|/* get set for first page in chain */
name|prev
operator|=
name|P_NONE
expr_stmt|;
name|dsize
operator|=
name|data
operator|->
name|size
expr_stmt|;
name|from
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|->
name|data
expr_stmt|;
comment|/* if there are blocks on the free list, use them first */
if|if
condition|(
operator|(
operator|*
name|pgno
operator|=
name|t
operator|->
name|bt_free
operator|)
operator|==
name|P_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|0
expr_stmt|;
operator|*
name|pgno
operator|=
name|cur
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
operator|*
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|1
expr_stmt|;
name|cur
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|cur
operator|->
name|h_flags
operator|=
name|F_CONT
operator||
name|F_LEAF
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cur
operator|->
name|h_linp
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|cur
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
comment|/* fill and write pages in the chain */
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nhere
decl_stmt|;
name|top
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|cur
operator|)
operator|+
name|t
operator|->
name|bt_psize
expr_stmt|;
name|cur
operator|->
name|h_prevpg
operator|=
name|prev
expr_stmt|;
name|nextchn
operator|=
name|cur
operator|->
name|h_nextpg
expr_stmt|;
name|nhere
operator|=
call|(
name|int
call|)
argument_list|(
name|top
operator|-
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhere
operator|>=
name|dsize
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|dsize
argument_list|)
expr_stmt|;
name|cur
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
name|dsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|from
argument_list|,
name|where
argument_list|,
operator|(
name|int
operator|)
name|nhere
argument_list|)
expr_stmt|;
name|dsize
operator|-=
name|nhere
expr_stmt|;
name|from
operator|+=
name|nhere
expr_stmt|;
if|if
condition|(
name|nextchn
operator|==
name|P_NONE
condition|)
name|cur
operator|->
name|h_nextpg
operator|=
name|t
operator|->
name|bt_npages
operator|+
literal|1
expr_stmt|;
name|prev
operator|=
name|cur
operator|->
name|h_pgno
expr_stmt|;
block|}
comment|/* current page is ready to go; write it out */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|cur
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* free the current page, if appropriate */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ISCACHE
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ischain
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|)
expr_stmt|;
block|}
comment|/* done? */
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
break|break;
comment|/* allocate another page */
if|if
condition|(
name|nextchn
operator|==
name|P_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|nextchn
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|ischain
operator|=
literal|1
expr_stmt|;
name|cur
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|cur
operator|->
name|h_flags
operator|=
name|F_LEAF
operator||
name|F_CONT
expr_stmt|;
name|where
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|cur
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
comment|/* if we used pages from the free list, record changes to it */
if|if
condition|(
operator|*
name|pgno
operator|==
name|t
operator|->
name|bt_free
condition|)
block|{
name|t
operator|->
name|bt_free
operator|=
name|nextchn
expr_stmt|;
name|t
operator|->
name|bt_flags
operator|&=
operator|~
name|BTF_METAOK
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SPLIT -- Split a page into two pages.  *  *	Splits are caused by insertions, and propogate up the tree in  *	the usual way.  The root page is always page 1 in the file on  *	disk, so root splits are handled specially.  On entry to this  *	routine, t->bt_curpage is the page to be split.  *  *	Parameters:  *		t -- btree in which to do split.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Changes the notion of the current page.  */
end_comment

begin_expr_stmt
specifier|static
name|_bt_split
argument_list|(
argument|t
argument_list|)
name|BTREE_P
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|BTHEADER
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|BTHEADER
modifier|*
name|next
decl_stmt|;
name|pgno_t
name|nextpgno
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|len
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|IDATUM
modifier|*
name|new
decl_stmt|;
name|pgno_t
name|oldchain
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* split root page specially, since it must remain page 1 */
if|if
condition|(
name|h
operator|->
name|h_pgno
operator|==
name|P_ROOT
condition|)
block|{
return|return
operator|(
name|_bt_splitroot
argument_list|(
name|t
argument_list|)
operator|)
return|;
block|}
comment|/* 	 *  This is a little complicated.  We go to some trouble to 	 *  figure out which of the three possible cases -- in-memory tree, 	 *  disk tree (no cache), and disk tree (cache) -- we have, in order 	 *  to avoid unnecessary copying.  If we have a disk cache, then we 	 *  have to do some extra copying, though, since the cache code 	 *  manages buffers externally to this code. 	 */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|left
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|left
operator|->
name|h_pgno
operator|=
name|left
operator|->
name|h_prevpg
operator|=
name|left
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
name|left
operator|->
name|h_flags
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
expr_stmt|;
name|left
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|left
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|left
operator|)
argument_list|)
expr_stmt|;
name|left
operator|->
name|h_upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|left
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|left
operator|->
name|h_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
operator|(
name|right
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|right
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
comment|/* now do the split */
if|if
condition|(
name|_bt_dopsplit
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|right
operator|->
name|h_prevpg
operator|=
name|left
operator|->
name|h_pgno
expr_stmt|;
name|nextpgno
operator|=
name|right
operator|->
name|h_nextpg
operator|=
name|h
operator|->
name|h_nextpg
expr_stmt|;
name|left
operator|->
name|h_nextpg
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
name|left
operator|->
name|h_prevpg
operator|=
name|h
operator|->
name|h_prevpg
expr_stmt|;
comment|/* okay, now use the left half of the page as the new page */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|left
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_curpage
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|left
argument_list|)
expr_stmt|;
name|left
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_curpage
argument_list|)
expr_stmt|;
name|t
operator|->
name|bt_curpage
operator|=
name|left
expr_stmt|;
block|}
comment|/* 	 *  Write the new pages out.  We need them to stay where they are 	 *  until we're done updating the parent pages. 	 */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|right
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* update 'prev' pointer of old neighbor of left */
if|if
condition|(
name|nextpgno
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|nextpgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|h
operator|->
name|h_prevpg
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|F_DIRTY
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parent
operator|=
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|right
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|d
operator|->
name|d_ksize
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
argument_list|,
sizeof|sizeof
argument_list|(
name|oldchain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_markchain
argument_list|(
name|t
argument_list|,
name|oldchain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
expr_stmt|;
name|flags
operator|=
name|D_BIGKEY
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|id
operator|->
name|i_size
expr_stmt|;
name|flags
operator|=
name|id
operator|->
name|i_flags
expr_stmt|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
name|nbytes
operator|=
name|len
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|new
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|(
name|IDATUM
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|new
operator|->
name|i_size
operator|=
name|len
expr_stmt|;
name|new
operator|->
name|i_pgno
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
name|new
operator|->
name|i_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* 		 *  Split the parent if we need to, then reposition the 		 *  tree's current page pointer for the new datum. 		 */
if|if
condition|(
operator|(
name|h
operator|->
name|h_upper
operator|-
name|h
operator|->
name|h_lower
operator|)
operator|<
name|nbytes
condition|)
block|{
if|if
condition|(
name|_bt_split
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_reposition
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|parent
argument_list|,
name|right
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* okay, now insert the new idatum */
if|if
condition|(
name|_bt_inserti
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|right
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* 	 *  Okay, split is done; don't need right page stapled down anymore. 	 *  The page we call 'left' above is the new version of the old 	 *  (split) page, so we can't release it. 	 */
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  _BT_MARKCHAIN -- Mark a chain of pages as used by an internal node.  *  *	Chains of indirect blocks pointed to by leaf nodes get reclaimed  *	when the item that points to them gets deleted.  Chains pointed  *	to by internal nodes never get deleted.  This routine marks a  *	chain as pointed to by an internal node.  *  *	Parameters:  *		t -- tree in which to mark  *		chain -- number of first page in chain  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_markchain
parameter_list|(
name|t
parameter_list|,
name|chain
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
block|{
name|pgno_t
name|save
decl_stmt|;
name|save
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|chain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|t
operator|->
name|bt_curpage
operator|->
name|h_flags
operator||=
operator|(
name|F_DIRTY
operator||
name|F_PRESERVE
operator|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|save
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_REPOSITION -- Reposition the current page pointer of a btree.  *  *	After splitting a node in the tree in order to make room for  *	an insertion, we need to figure out which page after the split  *	should get the item we want to insert.  This routine positions  *	the tree's current page pointer appropriately.  *  *	Parameters:  *		t -- tree to position  *		new -- the item we want to insert  *		parent -- parent of the node that we just split  *		prev -- page number of item directly to the left of  *			new's position in the tree.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_reposition
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|parent
parameter_list|,
name|prev
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|IDATUM
modifier|*
name|new
decl_stmt|;
name|pgno_t
name|parent
decl_stmt|;
name|pgno_t
name|prev
decl_stmt|;
block|{
name|index_t
name|i
decl_stmt|,
name|next
decl_stmt|;
name|IDATUM
modifier|*
name|idx
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|P_ROOT
condition|)
block|{
comment|/* 		 *  If we just split the root page, then there are guaranteed 		 *  to be exactly two IDATUMs on it.  Look at both of them 		 *  to see if they point to the page that we want. 		 */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|next
operator|=
name|NEXTINDEX
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|next
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|idx
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_isonpage
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|prev
argument_list|)
operator|==
name|RET_SUCCESS
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 *  Get the parent page -- which is where the new item would 		 *  have gone -- and figure out whether the new item now goes 		 *  on the parent, or the page immediately to the right of 		 *  the parent. 		 */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|parent
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_isonpage
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|prev
argument_list|)
operator|==
name|RET_SUCCESS
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|bt_curpage
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_isonpage
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
name|prev
argument_list|)
operator|==
name|RET_SUCCESS
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_ISONPAGE -- Is the IDATUM for a given page number on the current page?  *  *	This routine is used by _bt_reposition to decide whether the current  *	page is the correct one on which to insert a new item.  *  *	Parameters:  *		t -- tree to check  *		new -- the item that will be inserted (used for binary search)  *		prev -- page number of page whose IDATUM is immediately to  *			the left of new's position in the tree.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR (corresponding to TRUE, FALSE).  */
end_comment

begin_function
specifier|static
name|int
name|_bt_isonpage
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|prev
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|IDATUM
modifier|*
name|new
decl_stmt|;
name|pgno_t
name|prev
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
operator|(
name|BTHEADER
operator|*
operator|)
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|index_t
name|i
decl_stmt|,
name|next
decl_stmt|;
name|IDATUM
modifier|*
name|idx
decl_stmt|;
name|i
operator|=
name|_bt_binsrch
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|new
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
operator|&
operator|(
name|new
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
operator|--
name|i
expr_stmt|;
name|next
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|next
operator|&&
name|idx
operator|->
name|i_pgno
operator|!=
name|prev
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|->
name|i_pgno
operator|==
name|prev
condition|)
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
else|else
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SPLITROOT -- Split the root of a btree.  *  *	The root page for a btree is always page one.  This means that in  *	order to split the root, we need to do extra work.  *  *	Parameters:  *		t -- tree to split  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Splits root upward in the usual way, adding two new pages  *		to the tree (rather than just one, as in usual splits).  */
end_comment

begin_expr_stmt
specifier|static
name|_bt_splitroot
argument_list|(
argument|t
argument_list|)
name|BTREE_P
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|BTHEADER
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|BTHEADER
modifier|*
name|where_h
decl_stmt|;
name|pgno_t
name|lastpg
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nbytes
decl_stmt|;
name|u_long
name|was_leaf
decl_stmt|;
name|pgno_t
name|oldchain
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
comment|/* get two new pages for the split */
if|if
condition|(
operator|(
name|left
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|left
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|right
operator|=
name|_bt_allocpg
argument_list|(
name|t
argument_list|)
operator|)
operator|==
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|right
operator|->
name|h_pgno
operator|=
operator|++
operator|(
name|t
operator|->
name|bt_npages
operator|)
expr_stmt|;
comment|/* do the split */
if|if
condition|(
name|_bt_dopsplit
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* connect the new pages correctly */
name|right
operator|->
name|h_prevpg
operator|=
name|left
operator|->
name|h_pgno
expr_stmt|;
name|left
operator|->
name|h_nextpg
operator|=
name|right
operator|->
name|h_pgno
expr_stmt|;
comment|/* 	 *  Write the child pages out now.  We need them to remain 	 *  where they are until we finish updating parent pages, 	 *  however. 	 */
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|left
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|right
argument_list|,
name|NORELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* now change the root page into an internal page */
name|was_leaf
operator|=
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|F_LEAF
expr_stmt|;
name|h
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
operator|(
name|index_t
operator|)
name|t
operator|->
name|bt_psize
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|h
operator|->
name|h_upper
operator|-
name|h
operator|->
name|h_lower
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put two new keys on root page */
name|where_h
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|where_h
condition|)
block|{
name|DATUM
modifier|*
name|data
decl_stmt|;
name|IDATUM
modifier|*
name|idata
decl_stmt|;
if|if
condition|(
name|was_leaf
condition|)
block|{
name|data
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|where_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|where_h
operator|==
name|left
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
comment|/* first key in tree is null */
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|data
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
argument_list|,
sizeof|sizeof
argument_list|(
name|oldchain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_markchain
argument_list|(
name|t
argument_list|,
name|oldchain
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|oldchain
expr_stmt|;
name|flags
operator|=
name|D_BIGKEY
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|data
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|=
name|data
operator|->
name|d_ksize
expr_stmt|;
block|}
block|}
else|else
block|{
name|idata
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|where_h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|idata
operator|->
name|i_size
expr_stmt|;
name|flags
operator|=
name|idata
operator|->
name|i_flags
expr_stmt|;
name|src
operator|=
operator|&
operator|(
name|idata
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
name|dest
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|h
operator|->
name|h_upper
expr_stmt|;
name|nbytes
operator|=
name|len
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|dest
operator|-=
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|dest
expr_stmt|;
name|id
operator|->
name|i_size
operator|=
name|len
expr_stmt|;
name|id
operator|->
name|i_pgno
operator|=
name|where_h
operator|->
name|h_pgno
expr_stmt|;
name|id
operator|->
name|i_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dest
operator|-=
operator|(
operator|(
name|int
operator|)
name|h
operator|)
expr_stmt|;
name|h
operator|->
name|h_linp
index|[
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
index|]
operator|=
operator|(
name|index_t
operator|)
name|dest
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
operator|(
name|index_t
operator|)
name|dest
expr_stmt|;
name|h
operator|->
name|h_lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* next page */
if|if
condition|(
name|where_h
operator|==
name|left
condition|)
name|where_h
operator|=
name|right
expr_stmt|;
else|else
name|where_h
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|left
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|right
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 *  That's it, split is done.  If we're doing a non-cached disk 	 *  btree, we can free up the pages we allocated, as they're on 	 *  disk, now. 	 */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|left
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|right
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|h_flags
operator||=
name|F_DIRTY
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  _BT_DOPSPLIT -- Do the work of splitting a page  *  *	This routine takes two page pointers and splits the data on the  *	current page of the btree between them.  *  *	We do a lot of work here to handle duplicate keys on a page; we  *	have to place these keys carefully to guarantee that later searches  *	will find them correctly.  See comments in the code below for details.  *  *	Parameters:  *		t -- tree to split  *		left -- pointer to page to get left half of the data  *		right -- pointer to page to get right half of the data  *  *	Returns:  *		None.  */
end_comment

begin_expr_stmt
specifier|static
name|_bt_dopsplit
argument_list|(
argument|t
argument_list|,
argument|left
argument_list|,
argument|right
argument_list|)
name|BTREE_P
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|BTHEADER
modifier|*
name|left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|BTHEADER
modifier|*
name|right
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
name|BTHEADER
modifier|*
name|where_h
decl_stmt|;
name|index_t
name|where_i
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|dsize
decl_stmt|,
name|fixedsize
decl_stmt|,
name|freespc
decl_stmt|;
name|index_t
name|i
decl_stmt|;
name|index_t
name|save_lower
decl_stmt|,
name|save_upper
decl_stmt|,
name|save_i
decl_stmt|;
name|index_t
name|switch_i
decl_stmt|;
name|char
modifier|*
name|save_key
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|index_t
name|top
decl_stmt|;
name|int
name|free_save
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|int
name|ignore
decl_stmt|;
comment|/* 	 *  Our strategy is to put half the bytes on each page.  We figure 	 *  out how many bytes we have total, and then move items until 	 *  the last item moved put at least 50% of the data on the left 	 *  page. 	 */
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|psize
operator|=
operator|(
name|int
operator|)
name|t
operator|->
name|bt_psize
expr_stmt|;
name|where
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|left
operator|)
operator|+
name|psize
expr_stmt|;
name|where_h
operator|=
name|left
expr_stmt|;
name|where_i
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|=
name|psize
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
argument_list|)
expr_stmt|;
name|freespc
operator|=
name|nbytes
expr_stmt|;
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
name|fixedsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
else|else
name|fixedsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* move data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|top
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 *  Internal and leaf pages have different layouts for 		 *  data items, but in both cases the first entry in the 		 *  data item is a size_t. 		 */
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|dsize
operator|=
name|d
operator|->
name|d_ksize
operator|+
name|d
operator|->
name|d_dsize
operator|+
name|fixedsize
expr_stmt|;
block|}
else|else
block|{
name|dsize
operator|=
name|d
operator|->
name|d_ksize
operator|+
name|fixedsize
expr_stmt|;
block|}
comment|/* 		 *  If a page contains duplicate keys, we have to be 		 *  careful about splits.  A sequence of duplicate keys 		 *  may not begin in the middle of one page and end in 		 *  the middle of another; it must begin on a page boundary, 		 *  in order for searches on the internal nodes to work 		 *  correctly. 		 */
if|if
condition|(
name|where_h
operator|==
name|left
condition|)
block|{
if|if
condition|(
name|save_key
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IDATUM
modifier|*
name|id
init|=
operator|(
name|IDATUM
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
name|save_i
operator|=
literal|0
expr_stmt|;
name|save_lower
operator|=
name|where_h
operator|->
name|h_lower
expr_stmt|;
name|save_upper
operator|=
name|where_h
operator|->
name|h_upper
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|save_key
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|save_lower
operator|=
name|where_h
operator|->
name|h_lower
expr_stmt|;
name|save_upper
operator|=
name|where_h
operator|->
name|h_upper
expr_stmt|;
name|save_i
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|free_save
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|save_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IDATUM
modifier|*
name|id
init|=
operator|(
name|IDATUM
operator|*
operator|)
name|d
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_save
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|save_key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_save
operator|=
name|FALSE
expr_stmt|;
name|save_key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* copy data and update page state */
name|where
operator|-=
name|LONGALIGN
argument_list|(
name|dsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
operator|(
name|char
operator|*
operator|)
name|where
argument_list|,
name|dsize
argument_list|)
expr_stmt|;
name|where_h
operator|->
name|h_upper
operator|=
name|where_h
operator|->
name|h_linp
index|[
name|where_i
index|]
operator|=
call|(
name|index_t
call|)
argument_list|(
name|where
operator|-
operator|(
name|int
operator|)
name|where_h
argument_list|)
expr_stmt|;
name|where_h
operator|->
name|h_lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
name|where_i
operator|++
expr_stmt|;
comment|/* if we've moved half, switch to the right-hand page */
name|nbytes
operator|-=
name|LONGALIGN
argument_list|(
name|dsize
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|freespc
operator|-
name|nbytes
operator|)
operator|>
name|nbytes
condition|)
block|{
name|nbytes
operator|=
literal|2
operator|*
name|freespc
expr_stmt|;
comment|/* identical keys go on the same page */
if|if
condition|(
name|save_i
operator|>
literal|0
condition|)
block|{
comment|/* i gets incremented at loop bottom... */
name|i
operator|=
name|save_i
operator|-
literal|1
expr_stmt|;
name|where_h
operator|->
name|h_lower
operator|=
name|save_lower
expr_stmt|;
name|where_h
operator|->
name|h_upper
operator|=
name|save_upper
expr_stmt|;
block|}
name|where
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|right
operator|)
operator|+
name|psize
expr_stmt|;
name|where_h
operator|=
name|right
expr_stmt|;
name|switch_i
operator|=
name|where_i
expr_stmt|;
name|where_i
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 *  If there was an active scan on the database, and we just 	 *  split the page that the cursor was on, we may need to 	 *  adjust the cursor to point to the same entry as before the 	 *  split. 	 */
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|)
operator|&&
operator|(
name|c
operator|->
name|c_pgno
operator|==
name|h
operator|->
name|h_pgno
operator|)
operator|&&
operator|(
name|c
operator|->
name|c_index
operator|>=
name|switch_i
operator|)
condition|)
block|{
name|c
operator|->
name|c_pgno
operator|=
name|where_h
operator|->
name|h_pgno
expr_stmt|;
name|c
operator|->
name|c_index
operator|-=
name|where_i
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  _BT_INSERTI -- Insert IDATUM on current page in the btree.  *  *	This routine handles insertions to internal pages after splits  *	lower in the tree.  On entry, t->bt_curpage is the page to get  *	the new IDATUM.  We are also given pgno, the page number of the  *	IDATUM that is immediately left of the new IDATUM's position.  *	This guarantees that the IDATUM for the right half of the page  *	after a split goes next to the IDATUM for its left half.  *  *	Parameters:  *		t -- tree in which to do insertion.  *		id -- new IDATUM to insert  *		pgno -- page number of IDATUM left of id's position  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_inserti
parameter_list|(
name|t
parameter_list|,
name|id
parameter_list|,
name|pgno
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|index_t
name|next
decl_stmt|,
name|i
decl_stmt|;
name|IDATUM
modifier|*
name|idx
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|int
name|free_key
decl_stmt|;
name|int
name|ignore
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_key
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_key
operator|=
name|FALSE
expr_stmt|;
name|key
operator|=
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
name|i
operator|=
name|_bt_binsrch
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|next
operator|&&
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|i
argument_list|)
operator|>=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|free_key
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* okay, now we're close; find adjacent IDATUM */
for|for
control|(
init|;
condition|;
control|)
block|{
name|idx
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|->
name|i_pgno
operator|==
name|pgno
condition|)
block|{
name|i
operator|++
expr_stmt|;
break|break;
block|}
operator|--
name|i
expr_stmt|;
block|}
comment|/* correctly positioned, do the insertion */
return|return
operator|(
name|_bt_insertat
argument_list|(
name|t
argument_list|,
name|id
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_INSERTAT -- Insert a datum at a given location on the current page.  *  *	This routine does insertions on both leaf and internal pages.  *  *	Parameters:  *		t -- tree in which to do insertion.  *		p -- DATUM or IDATUM to insert.  *		index -- index in line pointer array to put this item.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Will rearrange line pointers to make space for the new  *		entry.  This means that any scans currently active are  *		invalid after this.  *  *	Warnings:  *		There must be sufficient room for the new item on the page.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_insertat
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|,
name|index
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|index_t
name|index
decl_stmt|;
block|{
name|IDATUM
modifier|*
name|id
init|=
operator|(
name|IDATUM
operator|*
operator|)
name|p
decl_stmt|;
name|DATUM
modifier|*
name|d
init|=
operator|(
name|DATUM
operator|*
operator|)
name|p
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|index_t
name|nxtindex
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* insertion may confuse an active scan.  fix it. */
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|&&
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
operator|==
name|c
operator|->
name|c_pgno
condition|)
if|if
condition|(
name|_bt_fixscan
argument_list|(
name|t
argument_list|,
name|index
argument_list|,
name|d
argument_list|,
name|INSERT
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|nxtindex
operator|=
operator|(
name|index_t
operator|)
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* 	 *  If we're inserting at the middle of the line pointer array, 	 *  copy pointers that will follow the new one up on the page. 	 */
if|if
condition|(
name|index
operator|<
name|nxtindex
condition|)
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
name|index
index|]
operator|)
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
name|index
operator|+
literal|1
index|]
operator|)
expr_stmt|;
name|nbytes
operator|=
operator|(
name|h
operator|->
name|h_lower
operator|-
operator|(
name|src
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* compute size and copy data to page */
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|nbytes
operator|=
name|d
operator|->
name|d_ksize
operator|+
name|d
operator|->
name|d_dsize
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|DATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|id
operator|->
name|i_size
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|IDATUM
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
block|}
name|dest
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|h
operator|)
operator|+
name|h
operator|->
name|h_upper
operator|)
operator|-
name|LONGALIGN
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|dest
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* update statistics */
name|dest
operator|-=
operator|(
name|int
operator|)
name|h
expr_stmt|;
name|h
operator|->
name|h_linp
index|[
name|index
index|]
operator|=
operator|(
name|index_t
operator|)
name|dest
expr_stmt|;
name|h
operator|->
name|h_upper
operator|=
operator|(
name|index_t
operator|)
name|dest
expr_stmt|;
name|h
operator|->
name|h_lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* we're done */
name|h
operator|->
name|h_flags
operator||=
name|F_DIRTY
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_BINSRCH -- Do a binary search for a given key on the current page.  *  *	Searches on internal pages are handled slightly differently from  *	searches on leaf pages.  This is because internal page searches  *	find the largest item<= key in the tree, and leaf searches find  *	the smallest item>= key.  This guarantees that leaf page searches  *	leave us pointing at the item's correct position, and internal  *	searches descend the tree correctly.  *  *	Parameters:  *		t -- tree to search  *		key -- key we're looking for  *  *	Returns:  *		Index of the line pointer array entry for the (closest)  *		match to key on the current page, with "closest" as defined  *		above.  */
end_comment

begin_function
specifier|static
name|index_t
name|_bt_binsrch
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|index_t
name|lbound
decl_stmt|,
name|ubound
decl_stmt|,
name|cur
decl_stmt|;
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|lbound
operator|=
literal|0
expr_stmt|;
name|ubound
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubound
operator|>
literal|0
condition|)
operator|--
name|ubound
expr_stmt|;
comment|/* do a binary search on the current page */
while|while
condition|(
operator|(
name|ubound
operator|-
name|lbound
operator|)
operator|>
literal|1
condition|)
block|{
name|cur
operator|=
name|lbound
operator|+
operator|(
operator|(
name|ubound
operator|-
name|lbound
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
name|r
operator|=
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|lbound
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|ubound
operator|=
name|cur
expr_stmt|;
else|else
block|{
name|match
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 *  At this point, the binary search terminated because the endpoints 	 *  got too close together, or we have a match.  Figure out which 	 *  case applies, decide what to do based on the page type (leaf or 	 *  internal), and do the right thing. 	 */
if|if
condition|(
name|match
condition|)
block|{
return|return
operator|(
name|cur
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ubound
operator|!=
name|lbound
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|r
operator|=
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|lbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|lbound
operator|)
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|ubound
argument_list|)
expr_stmt|;
comment|/* for internal nodes, move as far left as possible */
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|r
operator|=
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|lbound
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
operator|&&
name|lbound
operator|>
literal|0
condition|)
operator|--
name|lbound
expr_stmt|;
return|return
operator|(
name|lbound
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ubound
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
if|if
condition|(
name|ubound
operator|<
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
name|r
operator|=
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|ubound
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>
literal|0
condition|)
name|ubound
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* for internal pages, move as far left as possible */
if|if
condition|(
name|ubound
operator|==
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
name|ubound
operator|--
expr_stmt|;
while|while
condition|(
name|_bt_cmp
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|ubound
argument_list|)
operator|<
literal|0
condition|)
name|ubound
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ubound
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_SEQ -- Sequential scan interface.  *  *	This routine supports sequential scans on the btree.  If called with  *	flags set to R_CURSOR, or if no seq scan has been initialized in the  *	current tree, we initialize the scan.  Otherwise, we advance the scan  *	and return the next item.  *  *	Scans can be either keyed or non-keyed.  Keyed scans basically have  *	a starting point somewhere in the middle of the tree.  Non-keyed  *	scans start at an endpoint.  Also, scans can be backward (descending  *	order), forward (ascending order), or no movement (keep returning  *	the same item).  *  *	Flags is checked every time we enter the routine, so the user can  *	change directions on an active scan if desired.  The key argument  *	is examined only when we initialize the scan, in order to position  *	it properly.  *  *	Items are returned via the key and data arguments passed in.  *  *	Parameters:  *		tree -- btree in which to do scan  *		key -- key, used to position scan on initialization, and  *		       used to return key components to the user.  *		data -- used to return data components to the user.  *		flags -- specify R_CURSOR, R_FIRST, R_LAST, R_NEXT, or  *			 R_PREV.  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if no more data  *		exists in the tree in the specified direction.  *  *	Side Effects:  *		Changes the btree's notion of the current position in the  *		scan.  *  *	Warnings:  *		The key and data items returned are static and will be  *		overwritten by the next bt_get or bt_seq.  */
end_comment

begin_macro
name|bt_seq
argument_list|(
argument|tree
argument_list|,
argument|key
argument_list|,
argument|data
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|BTREE
name|tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DBT
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DBT
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* do we need to initialize the scan? */
if|if
condition|(
name|flags
operator|==
name|R_CURSOR
operator|||
name|flags
operator|==
name|R_LAST
operator|||
name|flags
operator|==
name|R_FIRST
operator|||
operator|!
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
operator|)
condition|)
block|{
comment|/* initialize it */
name|status
operator|=
name|_bt_seqinit
argument_list|(
name|t
argument_list|,
name|key
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just advance the current scan pointer */
name|status
operator|=
name|_bt_seqadvance
argument_list|(
name|t
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|key
operator|->
name|size
operator|=
name|data
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|data
operator|=
name|data
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* is there a valid item at the current scan location? */
if|if
condition|(
name|status
operator|==
name|RET_SPECIAL
condition|)
block|{
if|if
condition|(
name|flags
operator|==
name|R_NEXT
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|>
literal|0
condition|)
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* okay, return the data */
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|t
operator|->
name|bt_cursor
operator|.
name|c_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|_bt_buildret
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|data
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  _BT_BUILDRET -- Build return key/data pair as a result of search or scan.  *  *	This routine manages the statically allocated buffers in which we  *	return data to the user.  *  *	Parameters:  *		t -- btree from which to return datum  *		d -- DATUM to be returned to the user.  *		data -- data argument supplied by user for return  *		key -- key argument supplied by user for return  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		May free and reallocate static buffers, if the data  *		we want to return is bigger than the space we have to  *		do so.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_buildret
parameter_list|(
name|t
parameter_list|,
name|d
parameter_list|,
name|data
parameter_list|,
name|key
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
block|{
specifier|static
name|int
name|_data_s
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|_key_s
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|_data
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|_key
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|where
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|pgno_t
name|save
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|size_t
name|nhere
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
if|if
condition|(
name|_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|_key
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|_key
argument_list|,
operator|&
name|_key_s
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|key
operator|->
name|data
operator|=
name|_key
expr_stmt|;
name|key
operator|->
name|size
operator|=
name|_key_s
expr_stmt|;
block|}
else|else
block|{
comment|/* need more space for key? */
if|if
condition|(
name|d
operator|->
name|d_ksize
operator|>
name|_key_s
condition|)
block|{
if|if
condition|(
name|_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_key
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|d
operator|->
name|d_ksize
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|_key_s
operator|=
name|d
operator|->
name|d_ksize
expr_stmt|;
block|}
name|key
operator|->
name|data
operator|=
name|_key
expr_stmt|;
if|if
condition|(
operator|(
name|key
operator|->
name|size
operator|=
name|d
operator|->
name|d_ksize
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
name|_key
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|d_ksize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGDATA
condition|)
block|{
if|if
condition|(
name|_data
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|_data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|_data
argument_list|,
operator|&
name|_data_s
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|data
operator|->
name|data
operator|=
name|_data
expr_stmt|;
name|data
operator|->
name|size
operator|=
name|_data_s
expr_stmt|;
block|}
else|else
block|{
comment|/* need more space for data? */
if|if
condition|(
name|d
operator|->
name|d_dsize
operator|>
name|_data_s
condition|)
block|{
if|if
condition|(
name|_data
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_data
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|d
operator|->
name|d_dsize
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|_data_s
operator|=
name|d
operator|->
name|d_dsize
expr_stmt|;
block|}
name|data
operator|->
name|data
operator|=
name|_data
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|->
name|size
operator|=
name|d
operator|->
name|d_dsize
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
name|d
operator|->
name|d_ksize
index|]
operator|)
argument_list|,
name|_data
argument_list|,
name|d
operator|->
name|d_dsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SEQINIT -- Initialize a sequential scan on the btree.  *  *	Sets the tree's notion of the current scan location correctly  *	given a key and a direction.  *  *	Parameters:  *		t -- tree in which to initialize scan  *		key -- key for initial scan position  *		flags -- R_NEXT, R_PREV  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if there's no data  *		in the tree to scan.  *  *	Side Effects:  *		Changes current scan position for the tree.  Almost certainly  *		changes current page, as well.  Sets BTF_SEQINIT bit in tree  *		flags, so that we know we've initialized a scan.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_seqinit
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|,
name|flags
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|BTITEM
modifier|*
name|item
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
name|index_t
name|index
decl_stmt|;
name|index_t
name|last
decl_stmt|;
comment|/* 	 *  Figure out if we really have to search for the key that the 	 *  user supplied.  If key is null, then this is an unkeyed scan 	 *  and we can just start from an endpoint. 	 */
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_CURSOR
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|data
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* key supplied, find it */
name|item
operator|=
name|_bt_search
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_index
operator|=
name|item
operator|->
name|bti_index
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 *  Unkeyed scan.  For backward scans, find the last item 		 *  in the tree; for forward scans, find the first item. 		 */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|P_ROOT
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_LAST
operator|||
name|flags
operator|==
name|R_PREV
condition|)
block|{
comment|/* backward scan */
while|while
condition|(
operator|!
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
condition|)
block|{
name|last
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|id
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
comment|/* skip empty pages */
while|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_prevpg
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|>
literal|0
condition|)
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|R_FIRST
operator|||
name|flags
operator|==
name|R_NEXT
condition|)
block|{
comment|/* forward scan */
while|while
condition|(
operator|!
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
condition|)
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|id
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
comment|/* skip empty pages */
while|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* no flags passed in */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
comment|/* okay, scan is initialized */
name|t
operator|->
name|bt_flags
operator||=
name|BTF_SEQINIT
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_index
operator|==
name|NEXTINDEX
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|)
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SEQADVANCE -- Advance the sequential scan on this tree.  *  *	Moves the current location pointer for the scan on this tree one  *	spot in the requested direction.  *  *	Parameters:  *		t -- btree being scanned  *		flags -- for R_NEXT, R_PREV  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if there is no  *		more data in the specified direction.  *  *	Side Effects:  *		May change current page.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_seqadvance
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|index_t
name|index
decl_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
name|index
operator|=
name|c
operator|->
name|c_index
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|c
operator|->
name|c_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* by the time we get here, don't need the cursor key anymore */
if|if
condition|(
name|c
operator|->
name|c_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|c
operator|->
name|c_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_NEXT
condition|)
block|{
comment|/* 		 *  This is a forward scan.  If the cursor is pointing 		 *  at a virtual record (that is, it was pointing at 		 *  a record that got deleted), then we should return 		 *  the record it's pointing at now.  Otherwise, we 		 *  should advance the scan.  In either case, we need 		 *  to be careful not to run off the end of the current 		 *  page. 		 */
if|if
condition|(
name|c
operator|->
name|c_flags
operator|&
name|CRSR_BEFORE
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
comment|/* out of items on this page, get next page */
if|if
condition|(
name|h
operator|->
name|h_nextpg
operator|==
name|P_NONE
condition|)
block|{
comment|/* tell caller we're done... */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
comment|/* skip empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
block|{
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* tell caller we're done */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|->
name|c_flags
operator|&=
operator|~
name|CRSR_BEFORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|index
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
comment|/* out of items on this page, get next page */
if|if
condition|(
name|h
operator|->
name|h_nextpg
operator|==
name|P_NONE
condition|)
block|{
comment|/* tell caller we're done... */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
comment|/* skip empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
block|{
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* tell caller we're done */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|R_PREV
condition|)
block|{
comment|/* for backward scans, life is substantially easier */
name|c
operator|->
name|c_flags
operator|&=
operator|~
name|CRSR_BEFORE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
name|c
operator|->
name|c_key
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
comment|/* we may be done */
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
comment|/* out of items on this page, get next page */
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
comment|/* skip empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_prevpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
name|index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|--
name|index
expr_stmt|;
block|}
else|else
block|{
comment|/* must specify a direction */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|c
operator|->
name|c_index
operator|=
name|index
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  BT_CLOSE -- Close a btree  *  *	Parameters:  *		tree -- tree to close  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Frees space occupied by the tree.  */
end_comment

begin_function
name|int
name|bt_close
parameter_list|(
name|tree
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|cache
decl_stmt|;
name|struct
name|HTBUCKET
modifier|*
name|b
decl_stmt|,
modifier|*
name|sb
decl_stmt|;
name|HTABLE
name|ht
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_cursor
operator|.
name|c_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|t
operator|->
name|bt_cursor
operator|.
name|c_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* in-memory tree, release hash table memory */
name|ht
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HTSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|b
operator|=
name|ht
index|[
name|i
index|]
operator|)
operator|==
operator|(
expr|struct
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|)
break|break;
do|do
block|{
name|sb
operator|=
name|b
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|ht_page
argument_list|)
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|ht_next
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|b
operator|!=
operator|(
expr|struct
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|)
do|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ht
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_ISWRITE
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_METAOK
operator|)
condition|)
block|{
if|if
condition|(
name|_bt_wrtmeta
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|t
operator|->
name|bt_curpage
operator|!=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_DIRTY
condition|)
block|{
if|if
condition|(
name|_bt_write
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|RELEASE
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|_bt_release
argument_list|(
name|t
argument_list|,
name|h
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
comment|/* flush and free the cache, if there is one */
if|if
condition|(
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cache
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
expr_stmt|;
name|lrusync
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|lrufree
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_ALLOCPG -- allocate a new page in the btree.  *  *	This is called when we split a page, to get space to do the split.  *	For disk btrees, these pages are released when the split is done.  *	For memory btrees, they are not.  *  *	Parameters:  *		t -- tree in which to do split  *  *	Returns:  *		Pointer to the newly-allocated page  */
end_comment

begin_function
specifier|static
name|BTHEADER
modifier|*
name|_bt_allocpg
parameter_list|(
name|t
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
init|=
name|t
operator|->
name|bt_curpage
decl_stmt|;
name|BTHEADER
modifier|*
name|nh
decl_stmt|;
name|char
modifier|*
name|cache
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* if we have a cache, let the cache code do the work */
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|nh
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|lrugetnew
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
argument_list|,
name|t
operator|->
name|bt_npages
operator|+
literal|1
argument_list|,
operator|&
name|nbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nh
operator|=
operator|(
name|BTHEADER
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nh
operator|!=
operator|(
name|BTHEADER
operator|*
operator|)
name|NULL
condition|)
block|{
name|nh
operator|->
name|h_pgno
operator|=
name|nh
operator|->
name|h_prevpg
operator|=
name|nh
operator|->
name|h_nextpg
operator|=
name|P_NONE
expr_stmt|;
name|nh
operator|->
name|h_flags
operator|=
name|h
operator|->
name|h_flags
expr_stmt|;
name|nh
operator|->
name|h_lower
operator|=
call|(
name|index_t
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|nh
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
operator|)
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|nh
operator|)
argument_list|)
expr_stmt|;
name|nh
operator|->
name|h_upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
block|}
return|return
operator|(
name|nh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_WRITE -- Write a specific page to a btree file.  *  *	Parameters:  *		t -- btree to get the page  *		h -- page to write  *		relflag -- (int) this page may/may not be released  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		Writes a metadata page if none has been written yet.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_write
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|relflag
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|int
name|relflag
decl_stmt|;
block|{
name|long
name|pos
decl_stmt|;
name|int
name|htindex
decl_stmt|;
name|HTBUCKET
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|cache
decl_stmt|;
name|BTMETA
name|m
decl_stmt|;
name|pgno_t
name|pgno
decl_stmt|;
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|F_DIRTY
expr_stmt|;
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* if we haven't done so yet, write the metadata */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_METAOK
operator|)
condition|)
block|{
if|if
condition|(
name|_bt_wrtmeta
argument_list|(
name|t
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
comment|/* if we have a cache, let the cache code do the work */
if|if
condition|(
operator|(
name|cache
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|lruwrite
argument_list|(
name|cache
argument_list|,
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|relflag
operator|&&
name|lrurelease
argument_list|(
name|cache
argument_list|,
name|pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|_bt_pgout
argument_list|(
name|h
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_lorder
argument_list|)
expr_stmt|;
comment|/* now write the current page */
name|pos
operator|=
call|(
name|long
call|)
argument_list|(
name|pgno
operator|*
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
operator|!=
name|pos
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
name|write
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
name|h
argument_list|,
name|t
operator|->
name|bt_psize
argument_list|)
operator|<
name|t
operator|->
name|bt_psize
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
if|if
condition|(
operator|!
name|relflag
condition|)
operator|(
name|void
operator|)
name|_bt_pgin
argument_list|(
name|h
argument_list|,
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|bt_lorder
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* in-memory btree */
name|htindex
operator|=
name|HASHKEY
argument_list|(
name|h
operator|->
name|h_pgno
argument_list|)
expr_stmt|;
comment|/* see if we need to overwrite existing entry */
for|for
control|(
name|b
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
index|[
name|htindex
index|]
init|;
name|b
operator|!=
operator|(
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|ht_next
control|)
block|{
if|if
condition|(
name|b
operator|->
name|ht_pgno
operator|==
name|h
operator|->
name|h_pgno
condition|)
block|{
name|b
operator|->
name|ht_page
operator|=
name|h
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
block|}
comment|/* new entry, write it */
name|b
operator|=
operator|(
name|HTBUCKET
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|HTBUCKET
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
operator|(
name|HTBUCKET
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|b
operator|->
name|ht_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
name|b
operator|->
name|ht_page
operator|=
name|h
expr_stmt|;
name|b
operator|->
name|ht_next
operator|=
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
index|[
name|htindex
index|]
expr_stmt|;
name|t
operator|->
name|bt_s
operator|.
name|bt_ht
index|[
name|htindex
index|]
operator|=
name|b
expr_stmt|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_RELEASE -- Release a locked-down cache page  *  *	During page splits, we want to force pages out to the cache  *	before we actually release them, in some cases.  This routine  *	releases such a page when it is no longer needed.  *  *	Parameters:  *		t -- btree in which to release page  *		h -- page to release  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  *  *	Side Effects:  *		None.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_release
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
block|{
if|if
condition|(
name|ISDISK
argument_list|(
name|t
argument_list|)
operator|&&
name|ISCACHE
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|lrurelease
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_cache
argument_list|,
name|h
operator|->
name|h_pgno
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_WRTMETA -- Write metadata to the btree.  *  *	Parameters:  *		t -- tree to which to write  *  *	Returns:  *		RET_SUCCESS, RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|_bt_wrtmeta
parameter_list|(
name|t
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
block|{
name|BTMETA
name|m
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
literal|0l
argument_list|,
name|L_SET
argument_list|)
operator|!=
literal|0l
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* lorder has to be in host-independent format */
name|m
operator|.
name|m_lorder
operator|=
operator|(
name|u_long
operator|)
name|htonl
argument_list|(
operator|(
name|long
operator|)
name|t
operator|->
name|bt_lorder
argument_list|)
expr_stmt|;
name|m
operator|.
name|m_magic
operator|=
name|BTREEMAGIC
expr_stmt|;
name|m
operator|.
name|m_version
operator|=
name|BTREEVERSION
expr_stmt|;
name|m
operator|.
name|m_psize
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|m
operator|.
name|m_free
operator|=
name|t
operator|->
name|bt_free
expr_stmt|;
name|m
operator|.
name|m_flags
operator|=
name|t
operator|->
name|bt_flags
operator|&
name|BTF_NODUPS
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_lorder
operator|!=
name|BYTE_ORDER
condition|)
block|{
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_magic
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_version
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_psize
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_free
argument_list|)
expr_stmt|;
name|BLSWAP
argument_list|(
name|m
operator|.
name|m_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|m
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|m
argument_list|)
condition|)
block|{
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|t
operator|->
name|bt_flags
operator||=
name|BTF_METAOK
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|_btdump
parameter_list|(
name|tree
parameter_list|)
name|BTREE
name|tree
decl_stmt|;
block|{
name|BTREE_P
name|t
init|=
operator|(
name|BTREE_P
operator|)
name|tree
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|pgno_t
name|npages
decl_stmt|;
name|pgno_t
name|i
decl_stmt|;
name|index_t
name|cur
decl_stmt|,
name|top
decl_stmt|;
name|npages
operator|=
name|t
operator|->
name|bt_npages
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\"%s\" fd %d pgsz %d curpg %d @ 0x%lx"
argument_list|,
name|t
operator|->
name|bt_fname
argument_list|,
name|t
operator|->
name|bt_s
operator|.
name|bt_d
operator|.
name|d_fd
argument_list|,
name|t
operator|->
name|bt_psize
argument_list|,
name|t
operator|->
name|bt_curpage
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"npg %d cmp 0x%lx flags=("
argument_list|,
name|npages
argument_list|,
name|t
operator|->
name|bt_compare
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_flags
operator|&
name|BTF_SEQINIT
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"BTF_SEQINIT"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|P_ROOT
init|;
name|i
operator|<=
name|npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|==
name|RET_ERROR
condition|)
name|_punt
argument_list|()
expr_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"    page %d:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tpgno %d prev %d next %d\n"
argument_list|,
name|h
operator|->
name|h_pgno
argument_list|,
name|h
operator|->
name|h_prevpg
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tlower %d upper %d nextind %d flags ("
argument_list|,
name|h
operator|->
name|h_lower
argument_list|,
name|h
operator|->
name|h_upper
argument_list|,
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"F_LEAF"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"<internal>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_DIRTY
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"|F_DIRTY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_PRESERVE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"|F_PRESERVE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_CONT
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"|F_CONT)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
condition|)
block|{
name|size_t
name|longsz
decl_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|h
operator|->
name|h_linp
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|longsz
argument_list|,
sizeof|sizeof
argument_list|(
name|longsz
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\t(chain start, data length %ld)"
argument_list|,
name|longsz
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
literal|0
init|;
name|cur
operator|<
name|top
condition|;
name|cur
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t  [%d] off %d "
argument_list|,
name|cur
argument_list|,
name|h
operator|->
name|h_linp
index|[
name|cur
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|cur
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"ksize %d"
argument_list|,
name|d
operator|->
name|d_ksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" (indirect)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"; dsize %d"
argument_list|,
name|d
operator|->
name|d_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGDATA
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" (indirect)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|cur
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"size %d pgno %d"
argument_list|,
name|id
operator|->
name|i_size
argument_list|,
name|id
operator|->
name|i_pgno
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" (indirect)"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  *  _BT_CMP -- Compare a key to a given item on the current page.  *  *	This routine is a wrapper for the user's comparison function.  *  *	Parameters:  *		t -- tree in which to do comparison  *		p -- pointer to one argument for the comparison function  *		n -- index of item to supply second arg to comparison function  *  *	Returns:  *< 0 if p is< item at n  *		= 0 if p is = item at n  *> 0 if p is> item at n  */
end_comment

begin_function
specifier|static
name|int
name|_bt_cmp
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|index_t
name|n
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|DATUM
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|int
name|free_arg
decl_stmt|;
name|pgno_t
name|chain
decl_stmt|;
name|int
name|r
decl_stmt|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* 	 *  The left-most key at any level of the tree on internal pages 	 *  is guaranteed (artificially, by the code here) to be less than 	 *  any user key.  This saves us from having to update the leftmost 	 *  key when the user inserts a new key in the tree smaller than 	 *  anything we've seen yet. 	 */
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
operator|&&
operator|!
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
operator|&&
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
condition|)
block|{
name|d
operator|=
operator|(
name|DATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|d_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_arg
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_arg
operator|=
name|FALSE
expr_stmt|;
name|arg
operator|=
operator|&
operator|(
name|d
operator|->
name|d_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|i_flags
operator|&
name|D_BIGKEY
condition|)
block|{
name|free_arg
operator|=
name|TRUE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|chain
argument_list|,
sizeof|sizeof
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getbig
argument_list|(
name|t
argument_list|,
name|chain
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|ignore
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
else|else
block|{
name|free_arg
operator|=
name|FALSE
expr_stmt|;
name|arg
operator|=
operator|&
operator|(
name|id
operator|->
name|i_bytes
index|[
literal|0
index|]
operator|)
expr_stmt|;
block|}
block|}
name|r
operator|=
operator|(
operator|*
operator|(
name|t
operator|->
name|bt_compare
operator|)
operator|)
operator|(
name|p
operator|,
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|free_arg
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_PUSH/_BT_POP -- Push/pop a parent page number on the parent stack.  *  *	When we descend the tree, we keep track of parent pages in order  *	to handle splits on insertions.  *  *	Parameters:  *		t -- tree for which to push parent  *		pgno -- page number to push (_bt_push only)  *  *	Returns:  *		None.  */
end_comment

begin_expr_stmt
specifier|static
name|_bt_push
argument_list|(
argument|t
argument_list|,
argument|pgno
argument_list|)
name|BTREE_P
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|pgno_t
name|pgno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BTSTACK
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|BTSTACK
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
name|BTSTACK
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|bts_pgno
operator|=
name|pgno
expr_stmt|;
name|new
operator|->
name|bts_next
operator|=
name|t
operator|->
name|bt_stack
expr_stmt|;
name|t
operator|->
name|bt_stack
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|_bt_pop
argument_list|(
argument|t
argument_list|)
name|BTREE_P
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|BTSTACK
modifier|*
name|s
decl_stmt|;
name|pgno_t
name|p
init|=
name|P_NONE
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|t
operator|->
name|bt_stack
operator|)
operator|!=
operator|(
name|BTSTACK
operator|*
operator|)
name|NULL
condition|)
block|{
name|p
operator|=
name|s
operator|->
name|bts_pgno
expr_stmt|;
name|t
operator|->
name|bt_stack
operator|=
name|s
operator|->
name|bts_next
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|_punt
argument_list|()
end_macro

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

