begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_split.c	5.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_define
define|#
directive|define
name|__DBINTERFACE_PRIVATE
end_define

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"btree.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|bt_broot
name|__P
argument_list|(
operator|(
name|BTREE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PAGE
modifier|*
name|bt_page
name|__P
argument_list|(
operator|(
name|BTREE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|*
operator|,
name|PAGE
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt_preserve
name|__P
argument_list|(
operator|(
name|BTREE
operator|*
operator|,
name|pgno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PAGE
modifier|*
name|bt_psplit
name|__P
argument_list|(
operator|(
name|BTREE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PAGE
modifier|*
name|bt_root
name|__P
argument_list|(
operator|(
name|BTREE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|*
operator|,
name|PAGE
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt_rroot
name|__P
argument_list|(
operator|(
name|BTREE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|,
name|PAGE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|recno_t
name|rec_total
name|__P
argument_list|(
operator|(
name|PAGE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STATISTICS
end_ifdef

begin_decl_stmt
name|u_long
name|bt_rootsplit
decl_stmt|,
name|bt_split
decl_stmt|,
name|bt_sortsplit
decl_stmt|,
name|bt_pfxsaved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * __BT_SPLIT -- Split the tree.  *  * Parameters:  *	t:	tree  *	sp:	page to split  *	key:	key to insert  *	data:	data to insert  *	flags:	BIGKEY/BIGDATA flags  *	nbytes:	length of insertion  *	skip:	index to leave open  *  * Returns:  *	RET_ERROR, RET_SUCCESS  */
end_comment

begin_function
name|int
name|__bt_split
parameter_list|(
name|t
parameter_list|,
name|sp
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flags
parameter_list|,
name|nbytes
parameter_list|,
name|skip
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|sp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|data
decl_stmt|;
end_function

begin_decl_stmt
name|u_long
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|nbytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BINTERNAL
modifier|*
name|bi
decl_stmt|;
name|BLEAF
modifier|*
name|bl
decl_stmt|;
name|DBT
name|a
decl_stmt|,
name|b
decl_stmt|;
name|EPGNO
modifier|*
name|parent
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|lchild
decl_stmt|,
modifier|*
name|rchild
decl_stmt|;
name|index_t
name|nxtindex
decl_stmt|;
name|size_t
name|nksize
decl_stmt|;
name|int
name|nosplit
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* 	 * Split the page into two pages, l and r.  The split routines return 	 * a pointer to the page into which the key should be inserted and with 	 * skip set to the offset which should be used.  Additionally, l and r 	 * are pinned. 	 */
name|h
operator|=
name|sp
operator|->
name|pgno
operator|==
name|P_ROOT
condition|?
name|bt_root
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|)
else|:
name|bt_page
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 * Insert the new key/data pair into the leaf page.  (Key inserts 	 * always cause a leaf page to split first.) 	 */
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|t
argument_list|,
name|BTF_RECNO
argument_list|)
condition|)
name|WR_RLEAF
argument_list|(
argument|dest
argument_list|,
argument|data
argument_list|,
argument|flags
argument_list|)
else|else
name|WR_BLEAF
argument_list|(
argument|dest
argument_list|,
argument|key
argument_list|,
argument|data
argument_list|,
argument|flags
argument_list|)
comment|/* If the root page was split, make it look right. */
if|if
condition|(
name|sp
operator|->
name|pgno
operator|==
name|P_ROOT
operator|&&
operator|(
name|ISSET
argument_list|(
name|t
argument_list|,
name|BTF_RECNO
argument_list|)
condition|?
name|bt_rroot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
else|:
name|bt_broot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
operator|)
operator|==
name|RET_ERROR
condition|)
goto|goto
name|err2
goto|;
comment|/* 	 * Now we walk the parent page stack -- a LIFO stack of the pages that 	 * were traversed when we searched for the page that split.  Each stack 	 * entry is a page number and a page index offset.  The offset is for 	 * the page traversed on the search.  We've just split a page, so we 	 * have to insert a new key into the parent page. 	 * 	 * If the insert into the parent page causes it to split, may have to 	 * continue splitting all the way up the tree.  We stop if the root 	 * splits or the page inserted into didn't have to split to hold the 	 * new key.  Some algorithms replace the key for the old page as well 	 * as the new page.  We don't, as there's no reason to believe that the 	 * first key on the old page is any better than the key we have, and, 	 * in the case of a key being placed at index 0 causing the split, the 	 * key is unavailable. 	 * 	 * There are a maximum of 5 pages pinned at any time.  We keep the left 	 * and right pages pinned while working on the parent.   The 5 are the 	 * two children, left parent and right parent (when the parent splits) 	 * and the root page or the overflow key page when calling bt_preserve. 	 * This code must make sure that all pins are released other than the 	 * root page or overflow page which is unlocked elsewhere. 	 */
for|for
control|(
name|nosplit
operator|=
literal|0
init|;
operator|(
name|parent
operator|=
name|BT_POP
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|lchild
operator|=
name|l
expr_stmt|;
name|rchild
operator|=
name|r
expr_stmt|;
comment|/* Get the parent page. */
if|if
condition|(
operator|(
name|h
operator|=
name|mpool_get
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|parent
operator|->
name|pgno
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err2
goto|;
comment|/* The new key goes ONE AFTER the index. */
name|skip
operator|=
name|parent
operator|->
name|index
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Calculate the space needed on the parent page. 		 * 		 * Space hack when inserting into BINTERNAL pages.  Only need to 		 * retain the number of bytes that will distinguish between the 		 * new entry and the LAST entry on the page to its left.  If the 		 * keys compare equal, retain the entire key.  Note, we don't 		 * touch overflow keys and the entire key must be retained for 		 * the next-to-leftmost key on the leftmost page of each level, 		 * or the search will fail. 		 */
switch|switch
condition|(
name|rchild
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|rchild
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_pfx
operator|&&
operator|(
name|h
operator|->
name|prevpg
operator|!=
name|P_INVALID
operator|||
name|skip
operator|>
literal|1
operator|)
operator|&&
operator|!
operator|(
name|bi
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|)
condition|)
block|{
name|BINTERNAL
modifier|*
name|tbi
decl_stmt|;
name|tbi
operator|=
name|GETBINTERNAL
argument_list|(
name|lchild
argument_list|,
name|NEXTINDEX
argument_list|(
name|lchild
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|a
operator|.
name|size
operator|=
name|tbi
operator|->
name|ksize
expr_stmt|;
name|a
operator|.
name|data
operator|=
name|tbi
operator|->
name|bytes
expr_stmt|;
name|b
operator|.
name|size
operator|=
name|bi
operator|->
name|ksize
expr_stmt|;
name|b
operator|.
name|data
operator|=
name|bi
operator|->
name|bytes
expr_stmt|;
goto|goto
name|prefix
goto|;
block|}
else|else
name|nksize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|rchild
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_pfx
operator|&&
operator|(
name|h
operator|->
name|prevpg
operator|!=
name|P_INVALID
operator|||
name|skip
operator|>
literal|1
operator|)
operator|&&
operator|!
operator|(
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|)
condition|)
block|{
name|BLEAF
modifier|*
name|tbl
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|tbl
operator|=
name|GETBLEAF
argument_list|(
name|lchild
argument_list|,
name|NEXTINDEX
argument_list|(
name|lchild
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|a
operator|.
name|size
operator|=
name|tbl
operator|->
name|ksize
expr_stmt|;
name|a
operator|.
name|data
operator|=
name|tbl
operator|->
name|bytes
expr_stmt|;
name|b
operator|.
name|size
operator|=
name|bl
operator|->
name|ksize
expr_stmt|;
name|b
operator|.
name|data
operator|=
name|bl
operator|->
name|bytes
expr_stmt|;
name|prefix
label|:
name|nksize
operator|=
name|t
operator|->
name|bt_pfx
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|n
operator|=
name|NBINTERNAL
argument_list|(
name|nksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|nbytes
condition|)
block|{
ifdef|#
directive|ifdef
name|STATISTICS
name|bt_pfxsaved
operator|+=
name|nbytes
operator|-
name|n
expr_stmt|;
endif|#
directive|endif
name|nbytes
operator|=
name|n
expr_stmt|;
block|}
else|else
name|nksize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nksize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P_RINTERNAL
case|:
case|case
name|P_RLEAF
case|:
name|nbytes
operator|=
name|NRINTERNAL
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Split the parent page if necessary or shift the indices. */
if|if
condition|(
name|h
operator|->
name|upper
operator|-
name|h
operator|->
name|lower
operator|<
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
condition|)
block|{
name|sp
operator|=
name|h
expr_stmt|;
name|h
operator|=
name|h
operator|->
name|pgno
operator|==
name|P_ROOT
condition|?
name|bt_root
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|)
else|:
name|bt_page
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|err1
goto|;
block|}
else|else
block|{
if|if
condition|(
name|skip
operator|<
operator|(
name|nxtindex
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|)
condition|)
name|bcopy
argument_list|(
name|h
operator|->
name|linp
operator|+
name|skip
argument_list|,
name|h
operator|->
name|linp
operator|+
name|skip
operator|+
literal|1
argument_list|,
operator|(
name|nxtindex
operator|-
name|skip
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
name|nosplit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Insert the key into the parent page. */
switch|switch
condition|(
name|rchild
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|bi
argument_list|,
name|dest
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nksize
condition|)
operator|(
operator|(
name|BINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|ksize
operator|=
name|nksize
expr_stmt|;
operator|(
operator|(
name|BINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|rchild
operator|->
name|pgno
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
name|WR_BINTERNAL
argument_list|(
name|dest
argument_list|,
name|nksize
condition|?
name|nksize
else|:
name|bl
operator|->
name|ksize
argument_list|,
name|rchild
operator|->
name|pgno
argument_list|,
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bl
operator|->
name|bytes
argument_list|,
name|dest
argument_list|,
name|nksize
condition|?
name|nksize
else|:
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|&&
name|bt_preserve
argument_list|(
name|t
argument_list|,
operator|*
operator|(
name|pgno_t
operator|*
operator|)
name|bl
operator|->
name|bytes
argument_list|)
operator|==
name|RET_ERROR
condition|)
goto|goto
name|err1
goto|;
break|break;
case|case
name|P_RINTERNAL
case|:
comment|/* Update both left and right page counts. */
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|rec_total
argument_list|(
name|rchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|rchild
operator|->
name|pgno
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
operator|-
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|rec_total
argument_list|(
name|lchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|lchild
operator|->
name|pgno
expr_stmt|;
break|break;
case|case
name|P_RLEAF
case|:
comment|/* Update both left and right page counts. */
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|NEXTINDEX
argument_list|(
name|rchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|rchild
operator|->
name|pgno
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
operator|-
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|NEXTINDEX
argument_list|(
name|lchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|lchild
operator|->
name|pgno
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Unpin the held pages. */
if|if
condition|(
name|nosplit
condition|)
block|{
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the root page was split, make it look right. */
if|if
condition|(
name|sp
operator|->
name|pgno
operator|==
name|P_ROOT
operator|&&
operator|(
name|ISSET
argument_list|(
name|t
argument_list|,
name|BTF_RECNO
argument_list|)
condition|?
name|bt_rroot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
else|:
name|bt_broot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
operator|)
operator|==
name|RET_ERROR
condition|)
goto|goto
name|err1
goto|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|lchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|rchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
block|}
comment|/* Unpin the held pages. */
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|l
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|r
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
comment|/* Clear any pages left on the stack. */
name|BT_CLR
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
comment|/* 	 * If something fails in the above loop we were already walking back 	 * up the tree and the tree is now inconsistent.  Nothing much we can 	 * do about it but release any memory we're holding. 	 */
name|err1
label|:
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|lchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|rchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|err2
label|:
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__dbpanic
argument_list|(
name|t
operator|->
name|bt_dbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_PAGE -- Split a non-root page of a btree.  *  * Parameters:  *	t:	tree  *	h:	root page  *	lp:	pointer to left page pointer  *	rp:	pointer to right page pointer  *	skip:	pointer to index to leave open  *  * Returns:  *	Pointer to page in which to insert or NULL on error.  */
end_comment

begin_function
specifier|static
name|PAGE
modifier|*
name|bt_page
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|lp
parameter_list|,
name|rp
parameter_list|,
name|skip
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
modifier|*
name|lp
decl_stmt|,
modifier|*
modifier|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|skip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PAGE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|pgno_t
name|npg
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|bt_split
expr_stmt|;
endif|#
directive|endif
comment|/* Put the new right page for the split into place. */
if|if
condition|(
operator|(
name|r
operator|=
name|__bt_new
argument_list|(
name|t
argument_list|,
operator|&
name|npg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|r
operator|->
name|pgno
operator|=
name|npg
expr_stmt|;
name|r
operator|->
name|lower
operator|=
name|BTDATAOFF
expr_stmt|;
name|r
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|r
operator|->
name|nextpg
operator|=
name|h
operator|->
name|nextpg
expr_stmt|;
name|r
operator|->
name|prevpg
operator|=
name|h
operator|->
name|pgno
expr_stmt|;
name|r
operator|->
name|flags
operator|=
name|h
operator|->
name|flags
operator|&
name|P_TYPE
expr_stmt|;
comment|/* 	 * If we're splitting the last page on a level because we're appending 	 * a key to it (skip is NEXTINDEX()), it's likely that the data is 	 * sorted.  Adding an empty page on the side of the level is less work 	 * and can push the fill factor much higher than normal.  If we're 	 * wrong it's no big deal, we'll just do the split the right way next 	 * time.  It may look like it's equally easy to do a similar hack for 	 * reverse sorted data, that is, split the tree left, but it's not. 	 * Don't even try. 	 */
if|if
condition|(
name|h
operator|->
name|nextpg
operator|==
name|P_INVALID
operator|&&
operator|*
name|skip
operator|==
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|bt_sortsplit
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|nextpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|r
operator|->
name|lower
operator|=
name|BTDATAOFF
operator|+
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
operator|*
name|skip
operator|=
literal|0
expr_stmt|;
operator|*
name|lp
operator|=
name|h
expr_stmt|;
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Put the new left page for the split into place. */
if|if
condition|(
operator|(
name|l
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|bt_psize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l
operator|->
name|pgno
operator|=
name|h
operator|->
name|pgno
expr_stmt|;
name|l
operator|->
name|nextpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|l
operator|->
name|prevpg
operator|=
name|h
operator|->
name|prevpg
expr_stmt|;
name|l
operator|->
name|lower
operator|=
name|BTDATAOFF
expr_stmt|;
name|l
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|l
operator|->
name|flags
operator|=
name|h
operator|->
name|flags
operator|&
name|P_TYPE
expr_stmt|;
comment|/* Fix up the previous pointer of the page after the split page. */
if|if
condition|(
name|h
operator|->
name|nextpg
operator|!=
name|P_INVALID
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|mpool_get
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
operator|->
name|nextpg
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* XXX mpool_free(t->bt_mp, r->pgno); */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tp
operator|->
name|prevpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Split right.  The key/data pairs aren't sorted in the btree page so 	 * it's simpler to copy the data from the split page onto two new pages 	 * instead of copying half the data to the right page and compacting 	 * the left page in place.  Since the left page can't change, we have 	 * to swap the original and the allocated left page after the split. 	 */
name|tp
operator|=
name|bt_psplit
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|skip
argument_list|)
expr_stmt|;
comment|/* Move the new left page onto the old left page. */
name|memmove
argument_list|(
name|h
argument_list|,
name|l
argument_list|,
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|l
condition|)
name|tp
operator|=
name|h
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|h
expr_stmt|;
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_ROOT -- Split the root page of a btree.  *  * Parameters:  *	t:	tree  *	h:	root page  *	lp:	pointer to left page pointer  *	rp:	pointer to right page pointer  *	skip:	pointer to index to leave open  *  * Returns:  *	Pointer to page in which to insert or NULL on error.  */
end_comment

begin_function
specifier|static
name|PAGE
modifier|*
name|bt_root
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|lp
parameter_list|,
name|rp
parameter_list|,
name|skip
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
modifier|*
name|lp
decl_stmt|,
modifier|*
modifier|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|skip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PAGE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|pgno_t
name|lnpg
decl_stmt|,
name|rnpg
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|bt_split
expr_stmt|;
operator|++
name|bt_rootsplit
expr_stmt|;
endif|#
directive|endif
comment|/* Put the new left and right pages for the split into place. */
if|if
condition|(
operator|(
name|l
operator|=
name|__bt_new
argument_list|(
name|t
argument_list|,
operator|&
name|lnpg
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|__bt_new
argument_list|(
name|t
argument_list|,
operator|&
name|rnpg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l
operator|->
name|pgno
operator|=
name|lnpg
expr_stmt|;
name|r
operator|->
name|pgno
operator|=
name|rnpg
expr_stmt|;
name|l
operator|->
name|nextpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|r
operator|->
name|prevpg
operator|=
name|l
operator|->
name|pgno
expr_stmt|;
name|l
operator|->
name|prevpg
operator|=
name|r
operator|->
name|nextpg
operator|=
name|P_INVALID
expr_stmt|;
name|l
operator|->
name|lower
operator|=
name|r
operator|->
name|lower
operator|=
name|BTDATAOFF
expr_stmt|;
name|l
operator|->
name|upper
operator|=
name|r
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|l
operator|->
name|flags
operator|=
name|r
operator|->
name|flags
operator|=
name|h
operator|->
name|flags
operator|&
name|P_TYPE
expr_stmt|;
comment|/* Split the root page. */
name|tp
operator|=
name|bt_psplit
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|skip
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|l
expr_stmt|;
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_RROOT -- Fix up the recno root page after it has been split.  *  * Parameters:  *	t:	tree  *	h:	root page  *	l:	left page  *	r:	right page  *  * Returns:  *	RET_ERROR, RET_SUCCESS  */
end_comment

begin_function
specifier|static
name|int
name|bt_rroot
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* Insert the left and right keys, set the header information. */
name|h
operator|->
name|linp
index|[
literal|0
index|]
operator|=
name|h
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
operator|-
name|NRINTERNAL
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_RINTERNAL
argument_list|(
name|dest
argument_list|,
name|l
operator|->
name|flags
operator|&
name|P_RLEAF
condition|?
name|NEXTINDEX
argument_list|(
name|l
argument_list|)
else|:
name|rec_total
argument_list|(
name|l
argument_list|)
argument_list|,
name|l
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|1
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|NRINTERNAL
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_RINTERNAL
argument_list|(
name|dest
argument_list|,
name|r
operator|->
name|flags
operator|&
name|P_RLEAF
condition|?
name|NEXTINDEX
argument_list|(
name|r
argument_list|)
else|:
name|rec_total
argument_list|(
name|r
argument_list|)
argument_list|,
name|r
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|h
operator|->
name|lower
operator|=
name|BTDATAOFF
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* Unpin the root page, set to recno internal page. */
name|h
operator|->
name|flags
operator|&=
operator|~
name|P_TYPE
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|P_RINTERNAL
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_BROOT -- Fix up the btree root page after it has been split.  *  * Parameters:  *	t:	tree  *	h:	root page  *	l:	left page  *	r:	right page  *  * Returns:  *	RET_ERROR, RET_SUCCESS  */
end_comment

begin_function
specifier|static
name|int
name|bt_broot
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_function

begin_block
block|{
name|BINTERNAL
modifier|*
name|bi
decl_stmt|;
name|BLEAF
modifier|*
name|bl
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* 	 * If the root page was a leaf page, change it into an internal page. 	 * We copy the key we split on (but not the key's data, in the case of 	 * a leaf page) to the new root page. 	 * 	 * The btree comparison code guarantees that the left-most key on any 	 * level of the tree is never used, so it doesn't need to be filled in. 	 */
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|0
index|]
operator|=
name|h
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
operator|-
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_BINTERNAL
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|l
operator|->
name|pgno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BLEAF
case|:
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|1
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_BINTERNAL
argument_list|(
name|dest
argument_list|,
name|bl
operator|->
name|ksize
argument_list|,
name|r
operator|->
name|pgno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bl
operator|->
name|bytes
argument_list|,
name|dest
argument_list|,
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
comment|/* 		 * If the key is on an overflow page, mark the overflow chain 		 * so it isn't deleted when the leaf copy of the key is deleted. 		 */
if|if
condition|(
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|&&
name|bt_preserve
argument_list|(
name|t
argument_list|,
operator|*
operator|(
name|pgno_t
operator|*
operator|)
name|bl
operator|->
name|bytes
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
break|break;
case|case
name|P_BINTERNAL
case|:
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|1
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|bcopy
argument_list|(
name|bi
argument_list|,
name|dest
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|(
operator|(
name|BINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* There are two keys on the page. */
name|h
operator|->
name|lower
operator|=
name|BTDATAOFF
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* Unpin the root page, set to btree internal page. */
name|h
operator|->
name|flags
operator|&=
operator|~
name|P_TYPE
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|P_BINTERNAL
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_PSPLIT -- Do the real work of splitting the page.  *  * Parameters:  *	t:	tree  *	h:	page to be split  *	l:	page to put lower half of data  *	r:	page to put upper half of data  *	pskip:	pointer to index to leave open  *  * Returns:  *	Pointer to page in which to insert.  */
end_comment

begin_function
specifier|static
name|PAGE
modifier|*
name|bt_psplit
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|,
name|pskip
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|pskip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BINTERNAL
modifier|*
name|bi
decl_stmt|;
name|BLEAF
modifier|*
name|bl
decl_stmt|;
name|RLEAF
modifier|*
name|rl
decl_stmt|;
name|EPGNO
modifier|*
name|c
decl_stmt|;
name|PAGE
modifier|*
name|rval
decl_stmt|;
name|index_t
name|half
decl_stmt|,
name|skip
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|void
modifier|*
name|src
decl_stmt|;
name|int
name|bigkeycnt
decl_stmt|,
name|isbigkey
decl_stmt|,
name|nxt
decl_stmt|,
name|off
decl_stmt|,
name|top
decl_stmt|;
comment|/* 	 * Split the data to the left and right pages. Leave the skip index 	 * open.  Additionally, 	 * make some effort not to split on an overflow key.  This makes it 	 * faster to process internal pages and can save space since overflow 	 * keys used by internal pages are never deleted. 	 */
name|bigkeycnt
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
operator|*
name|pskip
expr_stmt|;
name|half
operator|=
operator|(
name|t
operator|->
name|bt_psize
operator|-
name|BTDATAOFF
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|nxt
operator|=
name|off
operator|=
literal|0
operator|,
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
init|;
name|nxt
operator|<
name|top
condition|;
operator|++
name|off
control|)
block|{
if|if
condition|(
name|skip
operator|==
name|off
condition|)
continue|continue;
switch|switch
condition|(
name|h
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|src
operator|=
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|isbigkey
operator|=
name|bi
operator|->
name|flags
operator|&
name|P_BIGKEY
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|src
operator|=
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBLEAF
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|isbigkey
operator|=
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
expr_stmt|;
break|break;
case|case
name|P_RINTERNAL
case|:
name|src
operator|=
name|GETRINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRINTERNAL
expr_stmt|;
name|isbigkey
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P_RLEAF
case|:
name|src
operator|=
name|rl
operator|=
name|GETRLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRLEAF
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|isbigkey
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|++
name|nxt
expr_stmt|;
name|l
operator|->
name|linp
index|[
name|off
index|]
operator|=
name|l
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
name|l
operator|+
name|l
operator|->
name|upper
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* There's no empirical justification for the '3'. */
if|if
condition|(
name|half
operator|<
name|nbytes
condition|)
block|{
if|if
condition|(
operator|!
name|isbigkey
operator|||
name|bigkeycnt
operator|==
literal|3
condition|)
break|break;
else|else
operator|++
name|bigkeycnt
expr_stmt|;
block|}
else|else
name|half
operator|-=
name|nbytes
expr_stmt|;
block|}
name|l
operator|->
name|lower
operator|+=
operator|(
name|off
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* 	 * If splitting the page that the cursor was on, the cursor has to be 	 * adjusted to point to the same record as before the split.  If the 	 * skipped slot and the cursor are both on the left page and the cursor 	 * is on or past the skipped slot, the cursor is incremented by one. 	 * If the skipped slot and the cursor are both on the right page and 	 * the cursor is on or past the skipped slot, the cursor is incremented 	 * by one.  If the skipped slot and the cursor aren't on the same page, 	 * the cursor isn't changed.  Regardless of the relationship of the 	 * skipped slot and the cursor, if the cursor is on the right page it 	 * is decremented by the number of records split to the left page. 	 * 	 * Don't bother checking for the BTF_SEQINIT flag, the page number will 	 * be P_INVALID. 	 */
name|c
operator|=
operator|&
name|t
operator|->
name|bt_bcursor
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|pgno
operator|==
name|h
operator|->
name|pgno
condition|)
if|if
condition|(
name|c
operator|->
name|index
operator|<
name|off
condition|)
block|{
comment|/* left page */
name|c
operator|->
name|pgno
operator|=
name|l
operator|->
name|pgno
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|index
operator|>=
name|skip
condition|)
operator|++
name|c
operator|->
name|index
expr_stmt|;
block|}
else|else
block|{
comment|/* right page */
name|c
operator|->
name|pgno
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|index
operator|>=
name|skip
operator|&&
name|skip
operator|>
name|off
condition|)
operator|++
name|c
operator|->
name|index
expr_stmt|;
name|c
operator|->
name|index
operator|-=
name|off
expr_stmt|;
block|}
comment|/* 	 * Decide which page to return, and adjust the skip index if the 	 * to-be-inserted-upon page has changed. 	 */
if|if
condition|(
name|skip
operator|>
name|off
condition|)
block|{
name|rval
operator|=
name|r
expr_stmt|;
operator|*
name|pskip
operator|-=
name|off
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|rval
operator|=
name|l
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|nxt
operator|<
name|top
condition|;
operator|++
name|off
control|)
block|{
if|if
condition|(
name|skip
operator|==
name|nxt
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|h
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|src
operator|=
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|src
operator|=
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBLEAF
argument_list|(
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_RINTERNAL
case|:
name|src
operator|=
name|GETRINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRINTERNAL
expr_stmt|;
break|break;
case|case
name|P_RLEAF
case|:
name|src
operator|=
name|rl
operator|=
name|GETRLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRLEAF
argument_list|(
name|rl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|++
name|nxt
expr_stmt|;
name|r
operator|->
name|linp
index|[
name|off
index|]
operator|=
name|r
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r
operator|+
name|r
operator|->
name|upper
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|lower
operator|+=
name|off
operator|*
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
comment|/* If the key is being appended to the page, adjust the index. */
if|if
condition|(
name|skip
operator|==
name|top
condition|)
name|r
operator|->
name|lower
operator|+=
sizeof|sizeof
argument_list|(
name|index_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_PRESERVE -- Mark a chain of pages as used by an internal node.  *  * Chains of indirect blocks pointed to by leaf nodes get reclaimed when the  * record that references them gets deleted.  Chains pointed to by internal  * pages never get deleted.  This routine marks a chain as pointed to by an  * internal page.  *  * Parameters:  *	t:	tree  *	pg:	page number of first page in the chain.  *  * Returns:  *	RET_SUCCESS, RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|bt_preserve
parameter_list|(
name|t
parameter_list|,
name|pg
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|pgno_t
name|pg
decl_stmt|;
block|{
name|PAGE
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|mpool_get
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|pg
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|->
name|flags
operator||=
name|P_PRESERVE
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * REC_TOTAL -- Return the number of recno entries below a page.  *  * Parameters:  *	h:	page  *  * Returns:  *	The number of recno entries below a page.  *  * XXX  * These values could be set by the bt_psplit routine.  The problem is that the  * entry has to be popped off of the stack etc. or the values have to be passed  * all the way back to bt_split/bt_rroot and it's not very clean.  */
end_comment

begin_function
specifier|static
name|recno_t
name|rec_total
parameter_list|(
name|h
parameter_list|)
name|PAGE
modifier|*
name|h
decl_stmt|;
block|{
name|recno_t
name|recs
decl_stmt|;
name|index_t
name|nxt
decl_stmt|,
name|top
decl_stmt|;
for|for
control|(
name|recs
operator|=
literal|0
operator|,
name|nxt
operator|=
literal|0
operator|,
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
init|;
name|nxt
operator|<
name|top
condition|;
operator|++
name|nxt
control|)
name|recs
operator|+=
name|GETRINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
operator|->
name|nrecs
expr_stmt|;
return|return
operator|(
name|recs
operator|)
return|;
block|}
end_function

end_unit

