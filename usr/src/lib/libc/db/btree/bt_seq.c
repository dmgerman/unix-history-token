begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_seq.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"btree.h"
end_include

begin_comment
comment|/*  *  _BT_SEQINIT -- Initialize a sequential scan on the btree.  *  *	Sets the tree's notion of the current scan location correctly  *	given a key and a direction.  *  *	Parameters:  *		t -- tree in which to initialize scan  *		key -- key for initial scan position  *		flags -- R_NEXT, R_PREV  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if there's no data  *		in the tree to scan.  *  *	Side Effects:  *		Changes current scan position for the tree.  Almost certainly  *		changes current page, as well.  Sets BTF_SEQINIT bit in tree  *		flags, so that we know we've initialized a scan.  */
end_comment

begin_function
name|int
name|_bt_seqinit
parameter_list|(
name|t
parameter_list|,
name|key
parameter_list|,
name|flags
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|BTITEM
modifier|*
name|item
decl_stmt|;
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|IDATUM
modifier|*
name|id
decl_stmt|;
name|index_t
name|last
decl_stmt|;
comment|/* 	 *  Figure out if we really have to search for the key that the 	 *  user supplied.  If key is null, then this is an unkeyed scan 	 *  and we can just start from an endpoint. 	 */
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_CURSOR
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|data
operator|!=
operator|(
name|u_char
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* key supplied, find first instance of it */
name|item
operator|=
name|_bt_first
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_index
operator|=
name|item
operator|->
name|bti_index
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|t
operator|->
name|bt_curpage
operator|->
name|h_pgno
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 *  Unkeyed scan.  For backward scans, find the last item 		 *  in the tree; for forward scans, find the first item. 		 */
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
operator|(
name|pgno_t
operator|)
name|P_ROOT
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_LAST
operator|||
name|flags
operator|==
name|R_PREV
condition|)
block|{
comment|/* backward scan */
while|while
condition|(
operator|!
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
condition|)
block|{
name|last
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|id
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
comment|/* skip empty pages */
while|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_prevpg
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|>
literal|0
condition|)
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|R_FIRST
operator|||
name|flags
operator|==
name|R_NEXT
condition|)
block|{
comment|/* forward scan */
while|while
condition|(
operator|!
operator|(
name|h
operator|->
name|h_flags
operator|&
name|F_LEAF
operator|)
condition|)
block|{
name|id
operator|=
operator|(
name|IDATUM
operator|*
operator|)
name|GETDATUM
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|id
operator|->
name|i_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
comment|/* skip empty pages */
while|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
block|}
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* no flags passed in */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
block|}
comment|/* okay, scan is initialized */
name|t
operator|->
name|bt_flags
operator||=
name|BTF_SEQINIT
expr_stmt|;
comment|/* don't need the descent stack anymore */
while|while
condition|(
name|_bt_pop
argument_list|(
name|t
argument_list|)
operator|!=
name|P_NONE
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|c_index
operator|==
name|NEXTINDEX
argument_list|(
name|t
operator|->
name|bt_curpage
argument_list|)
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  _BT_SEQADVANCE -- Advance the sequential scan on this tree.  *  *	Moves the current location pointer for the scan on this tree one  *	spot in the requested direction.  *  *	Parameters:  *		t -- btree being scanned  *		flags -- for R_NEXT, R_PREV  *  *	Returns:  *		RET_SUCCESS, RET_ERROR, or RET_SPECIAL if there is no  *		more data in the specified direction.  *  *	Side Effects:  *		May change current page.  */
end_comment

begin_function
name|int
name|_bt_seqadvance
parameter_list|(
name|t
parameter_list|,
name|flags
parameter_list|)
name|BTREE_P
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|BTHEADER
modifier|*
name|h
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|index_t
name|index
decl_stmt|;
name|c
operator|=
operator|&
operator|(
name|t
operator|->
name|bt_cursor
operator|)
expr_stmt|;
name|index
operator|=
name|c
operator|->
name|c_index
expr_stmt|;
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|c
operator|->
name|c_pgno
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
comment|/* by the time we get here, don't need the cursor key anymore */
if|if
condition|(
name|c
operator|->
name|c_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|c
operator|->
name|c_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|R_NEXT
condition|)
block|{
comment|/* 		 *  This is a forward scan.  If the cursor is pointing 		 *  at a virtual record (that is, it was pointing at 		 *  a record that got deleted), then we should return 		 *  the record it's pointing at now.  Otherwise, we 		 *  should advance the scan.  In either case, we need 		 *  to be careful not to run off the end of the current 		 *  page. 		 */
if|if
condition|(
name|c
operator|->
name|c_flags
operator|&
name|CRSR_BEFORE
condition|)
block|{
if|if
condition|(
name|index
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
comment|/* out of items on this page, get next page */
if|if
condition|(
name|h
operator|->
name|h_nextpg
operator|==
name|P_NONE
condition|)
block|{
comment|/* tell caller we're done... */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
comment|/* skip empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
block|{
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* tell caller we're done */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|->
name|c_flags
operator|&=
operator|~
name|CRSR_BEFORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|index
operator|>=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
comment|/* out of items on this page, get next page */
if|if
condition|(
name|h
operator|->
name|h_nextpg
operator|==
name|P_NONE
condition|)
block|{
comment|/* tell caller we're done... */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
comment|/* skip empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_nextpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
block|{
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_nextpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* tell caller we're done */
name|c
operator|->
name|c_index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
block|}
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|R_PREV
condition|)
block|{
comment|/* for backward scans, life is substantially easier */
name|c
operator|->
name|c_flags
operator|&=
operator|~
name|CRSR_BEFORE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_key
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
name|c
operator|->
name|c_key
argument_list|)
expr_stmt|;
name|c
operator|->
name|c_key
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
comment|/* we may be done */
name|c
operator|->
name|c_index
operator|=
literal|0
expr_stmt|;
comment|/* out of items on this page, get next page */
if|if
condition|(
name|h
operator|->
name|h_prevpg
operator|==
name|P_NONE
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
comment|/* skip empty pages */
do|do
block|{
if|if
condition|(
name|_bt_getpage
argument_list|(
name|t
argument_list|,
name|h
operator|->
name|h_prevpg
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|=
name|t
operator|->
name|bt_curpage
expr_stmt|;
name|c
operator|->
name|c_pgno
operator|=
name|h
operator|->
name|h_pgno
expr_stmt|;
block|}
do|while
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|h_prevpg
operator|!=
name|P_NONE
condition|)
do|;
if|if
condition|(
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|RET_SPECIAL
operator|)
return|;
name|index
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
operator|--
name|index
expr_stmt|;
block|}
else|else
block|{
comment|/* must specify a direction */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
name|c
operator|->
name|c_index
operator|=
name|index
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

