begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fts.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|fts_alloc
argument_list|()
decl_stmt|,
modifier|*
name|fts_build
argument_list|()
decl_stmt|,
modifier|*
name|fts_cycle
argument_list|()
decl_stmt|,
modifier|*
name|fts_sort
argument_list|()
decl_stmt|,
modifier|*
name|fts_root
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|short
name|fts_stat
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special case a root of "/" so that slashes aren't appended causing  * paths to be written as "//foo".  */
end_comment

begin_define
define|#
directive|define
name|NAPPEND
parameter_list|(
name|p
parameter_list|)
define|\
value|(p->level == ROOTLEVEL&& p->pathlen == 1&& \ 	    p->path[0] == '/' ? 0 : p->pathlen)
end_define

begin_define
define|#
directive|define
name|CHDIR
parameter_list|(
name|sp
parameter_list|,
name|path
parameter_list|)
value|(!(sp->options& FTS_NOCHDIR)&& chdir(path))
end_define

begin_define
define|#
directive|define
name|ROOTLEVEL
value|0
end_define

begin_define
define|#
directive|define
name|ROOTPARENTLEVEL
value|-1
end_define

begin_decl_stmt
specifier|static
name|FTS
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current stream pointer */
end_comment

begin_decl_stmt
name|FTS
modifier|*
name|ftsopen
argument_list|(
name|argv
argument_list|,
name|options
argument_list|,
name|compar
argument_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|FTS
modifier|*
name|sp
decl_stmt|;
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|,
modifier|*
name|root
decl_stmt|;
specifier|register
name|int
name|nitems
decl_stmt|,
name|maxlen
decl_stmt|;
name|FTSENT
modifier|*
name|parent
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|char
name|wd
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
modifier|*
name|getwd
argument_list|()
decl_stmt|,
modifier|*
name|strdup
argument_list|()
decl_stmt|;
comment|/* allocate/initialize the stream */
if|if
condition|(
operator|!
operator|(
name|stream
operator|=
name|sp
operator|=
operator|(
name|FTS
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
name|FTS
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|FTS
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|compar
operator|=
name|compar
expr_stmt|;
name|sp
operator|->
name|options
operator|=
name|options
expr_stmt|;
comment|/* allocate/initialize root's parent */
if|if
condition|(
operator|!
operator|(
name|parent
operator|=
name|fts_alloc
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|mem1
goto|;
name|parent
operator|->
name|level
operator|=
name|ROOTPARENTLEVEL
expr_stmt|;
comment|/* allocate/initialize root(s) */
if|if
condition|(
name|options
operator|&
name|FTS_MULTIPLE
condition|)
block|{
name|maxlen
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|root
operator|=
name|NULL
operator|,
name|nitems
operator|=
literal|0
init|;
operator|*
name|argv
condition|;
operator|++
name|argv
operator|,
operator|++
name|nitems
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|fts_root
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
condition|)
goto|goto
name|mem2
goto|;
if|if
condition|(
name|maxlen
operator|<
name|p
operator|->
name|namelen
condition|)
name|maxlen
operator|=
name|p
operator|->
name|namelen
expr_stmt|;
comment|/* 			 * if comparison routine supplied, traverse in sorted 			 * order; otherwise traverse in the order specified. 			 */
if|if
condition|(
name|compar
condition|)
block|{
name|p
operator|->
name|link
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|accpath
operator|=
name|p
operator|->
name|name
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|fts_stat
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
name|tmp
operator|=
name|root
operator|=
name|p
expr_stmt|;
else|else
block|{
name|tmp
operator|->
name|link
operator|=
name|p
expr_stmt|;
name|tmp
operator|=
name|p
expr_stmt|;
block|}
block|}
name|p
operator|->
name|level
operator|=
name|ROOTLEVEL
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|compar
operator|&&
name|nitems
operator|>
literal|1
condition|)
name|root
operator|=
name|fts_sort
argument_list|(
name|root
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|root
operator|=
name|fts_root
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
operator|)
condition|)
goto|goto
name|mem2
goto|;
name|maxlen
operator|=
name|root
operator|->
name|namelen
expr_stmt|;
name|root
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
name|root
operator|->
name|level
operator|=
name|ROOTLEVEL
expr_stmt|;
name|root
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
block|}
comment|/* start out with at least 1K+ of path space */
if|if
condition|(
operator|!
name|fts_path
argument_list|(
name|MAX
argument_list|(
name|maxlen
argument_list|,
name|MAXPATHLEN
argument_list|)
argument_list|)
condition|)
goto|goto
name|mem2
goto|;
comment|/* 	 * some minor trickiness.  Set the pointers so that ftsread thinks 	 * we've just finished the node before the root(s); set p->info to 	 * FTS_NS so that everything about the "current" node is ignored. 	 * Rather than allocate a dummy node use the root's parent's link 	 * pointer.  This is handled specially in ftsclose() as well. 	 */
name|sp
operator|->
name|cur
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|link
operator|=
name|root
expr_stmt|;
name|parent
operator|->
name|info
operator|=
name|FTS_NS
expr_stmt|;
comment|/* 	 * if using chdir(2), do a getwd() to insure that we can get back 	 * here; this could be avoided for some paths, but probably not 	 * worth the effort.  Slashes, symbolic links, and ".." are all 	 * fairly nasty problems.  Note, if we can't get the current 	 * working directory we run anyway, just more slowly. 	 */
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|FTS_NOCHDIR
operator|)
operator|&&
operator|(
operator|!
name|getwd
argument_list|(
name|wd
argument_list|)
operator|||
operator|!
operator|(
name|sp
operator|->
name|wd
operator|=
name|strdup
argument_list|(
name|wd
argument_list|)
operator|)
operator|)
condition|)
name|sp
operator|->
name|options
operator||=
name|FTS_NOCHDIR
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
name|mem2
label|:
name|fts_lfree
argument_list|(
name|root
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|parent
argument_list|)
expr_stmt|;
name|mem1
label|:
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|fts_load
argument_list|(
name|p
argument_list|)
specifier|register
name|FTSENT
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * load the stream structure for the next traversal; set the 	 * accpath field specially so the chdir gets done to the right 	 * place and the user can access the first node. 	 */
name|len
operator|=
name|p
operator|->
name|pathlen
operator|=
name|p
operator|->
name|namelen
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|stream
operator|->
name|path
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|&&
operator|(
name|cp
operator|!=
name|p
operator|->
name|name
operator|||
name|cp
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|namelen
operator|=
name|len
expr_stmt|;
block|}
name|p
operator|->
name|accpath
operator|=
name|p
operator|->
name|path
operator|=
name|stream
operator|->
name|path
expr_stmt|;
block|}
end_block

begin_macro
name|ftsclose
argument_list|(
argument|sp
argument_list|)
end_macro

begin_decl_stmt
name|FTS
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FTSENT
modifier|*
name|freep
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|cur
condition|)
comment|/* check for never having read anything */
if|if
condition|(
name|sp
operator|->
name|cur
operator|->
name|level
operator|==
name|ROOTPARENTLEVEL
condition|)
name|fts_lfree
argument_list|(
name|sp
operator|->
name|cur
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|p
operator|=
name|sp
operator|->
name|cur
init|;
name|p
operator|->
name|level
operator|>
name|ROOTPARENTLEVEL
condition|;
control|)
block|{
name|freep
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
condition|?
name|p
operator|->
name|link
else|:
name|p
operator|->
name|parent
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|freep
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* free up child linked list, sort array, path buffer */
if|if
condition|(
name|sp
operator|->
name|child
condition|)
name|fts_lfree
argument_list|(
name|sp
operator|->
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|array
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|array
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * return to original directory, save errno if necessary; 	 * free up the directory buffer 	 */
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|options
operator|&
name|FTS_NOCHDIR
operator|)
condition|)
block|{
name|saved_errno
operator|=
name|chdir
argument_list|(
name|sp
operator|->
name|wd
argument_list|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|sp
operator|->
name|wd
argument_list|)
expr_stmt|;
block|}
comment|/* free up the stream pointer */
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
comment|/* set errno and return */
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|options
operator|&
name|FTS_NOCHDIR
operator|)
operator|&&
name|saved_errno
condition|)
block|{
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|FTSENT
modifier|*
name|ftsread
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|FTS
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|instr
decl_stmt|;
specifier|static
name|int
name|cd
decl_stmt|;
name|FTSENT
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* if finished or unrecoverable error, return NULL */
if|if
condition|(
operator|!
name|sp
operator|->
name|cur
operator|||
name|sp
operator|->
name|options
operator|&
name|FTS__STOP
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* set global stream pointer, and current node pointer */
name|stream
operator|=
name|sp
expr_stmt|;
name|p
operator|=
name|sp
operator|->
name|cur
expr_stmt|;
comment|/* save and zero out user instructions */
name|instr
operator|=
name|p
operator|->
name|instr
expr_stmt|;
name|p
operator|->
name|instr
operator|=
literal|0
expr_stmt|;
comment|/* if used link pointer for cycle detection, restore it */
if|if
condition|(
name|sp
operator|->
name|savelink
condition|)
block|{
name|p
operator|->
name|link
operator|=
name|sp
operator|->
name|savelink
expr_stmt|;
name|sp
operator|->
name|savelink
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* any type of file may be re-visited; re-stat and return */
if|if
condition|(
name|instr
operator|==
name|FTS_AGAIN
condition|)
block|{
name|p
operator|->
name|info
operator|=
name|fts_stat
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|info
operator|==
name|FTS_D
condition|)
if|if
condition|(
name|instr
operator|==
name|FTS_SKIP
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|child
condition|)
block|{
name|fts_lfree
argument_list|(
name|sp
operator|->
name|child
argument_list|)
expr_stmt|;
name|sp
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|child
condition|)
block|{
comment|/* cd into child directory */
if|if
condition|(
name|CHDIR
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|accpath
argument_list|)
condition|)
block|{
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|FTS_ERR
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|child
operator|=
name|fts_build
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|=
name|sp
operator|->
name|child
expr_stmt|;
name|sp
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|sp
operator|->
name|path
operator|+
name|NAPPEND
argument_list|(
name|p
operator|->
name|parent
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|p
operator|->
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|cur
operator|=
name|p
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|info
operator|==
name|FTS_SL
operator|&&
name|instr
operator|==
name|FTS_FOLLOW
condition|)
block|{
name|p
operator|->
name|info
operator|=
name|fts_stat
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* 	 * user may have called ftsset on pointer returned by 	 * ftschildren; handle it here. 	 */
for|for
control|(
name|p
operator|=
name|p
operator|->
name|link
init|;
name|p
condition|;
control|)
block|{
name|instr
operator|=
name|p
operator|->
name|instr
expr_stmt|;
if|if
condition|(
name|instr
operator|==
name|FTS_FOLLOW
condition|)
block|{
name|p
operator|->
name|info
operator|=
name|fts_stat
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|instr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|instr
operator|==
name|FTS_SKIP
condition|)
block|{
name|tmp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|link
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p
operator|->
name|instr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* go to next node on this level */
if|if
condition|(
name|p
condition|)
block|{
comment|/* 		 * if root level node, set up paths and return.  If not the 		 * first time, and it's not an absolute pathname, get back 		 * to wherever we started from. 		 */
if|if
condition|(
name|p
operator|->
name|level
operator|==
name|ROOTLEVEL
condition|)
block|{
name|fts_load
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|CHDIR
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|wd
argument_list|)
condition|)
block|{
comment|/* return target path for error msg */
name|p
operator|->
name|path
operator|=
name|sp
operator|->
name|wd
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|FTS_ERR
expr_stmt|;
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|cur
operator|=
name|p
operator|)
return|;
block|}
block|}
else|else
name|cd
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|fts_stat
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|cur
argument_list|)
expr_stmt|;
name|cp
operator|=
name|sp
operator|->
name|path
operator|+
name|NAPPEND
argument_list|(
name|p
operator|->
name|parent
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|p
operator|->
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|info
operator|==
name|FTS_D
operator|&&
operator|(
name|tmp
operator|=
name|fts_cycle
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
name|sp
operator|->
name|savelink
operator|=
name|p
operator|->
name|link
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|tmp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|sp
operator|->
name|cur
operator|=
name|p
operator|)
return|;
block|}
comment|/* go to parent */
name|p
operator|=
name|sp
operator|->
name|cur
operator|->
name|parent
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|level
operator|==
name|ROOTPARENTLEVEL
condition|)
block|{
comment|/* 		 * done; free everything up and set errno to 0 so the user 		 * can distinguish between error and EOF. 		 */
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|cur
operator|=
name|NULL
operator|)
return|;
block|}
name|sp
operator|->
name|path
index|[
name|p
operator|->
name|pathlen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|CHDIR
argument_list|(
name|sp
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|FTS_ERR
expr_stmt|;
block|}
else|else
name|p
operator|->
name|info
operator|=
name|FTS_DP
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|cur
operator|=
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ftsset takes the stream as an argument although it's not used in this  * implementation; it would be necessary if anyone wanted to add global  * semantics to fts using ftsset.  A possible error return is allowed for  * similar reasons.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|ftsset
argument_list|(
argument|sp
argument_list|,
argument|p
argument_list|,
argument|instr
argument_list|)
end_macro

begin_decl_stmt
name|FTS
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTSENT
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|instr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|->
name|instr
operator|=
name|instr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|FTSENT
modifier|*
name|ftschildren
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|FTS
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* 	 * set errno to 0 so that user can tell the difference between an 	 * error and a directory without entries. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cur
operator|->
name|info
operator|!=
name|FTS_D
operator|||
name|sp
operator|->
name|options
operator|&
name|FTS__STOP
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|child
condition|)
name|fts_lfree
argument_list|(
name|sp
operator|->
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|child
operator|=
name|fts_build
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * have to cd up so that the fields of the current node 		 * as returned from readfts will be correct. 		 */
if|if
condition|(
name|CHDIR
argument_list|(
name|sp
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|sp
operator|->
name|child
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ISDOT
parameter_list|(
name|a
parameter_list|)
value|(a[0] == '.'&& (!a[1] || a[1] == '.'&& !a[2]))
end_define

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_build
parameter_list|(
name|sp
parameter_list|,
name|set_node_errors
parameter_list|)
specifier|register
name|FTS
modifier|*
name|sp
decl_stmt|;
name|int
name|set_node_errors
decl_stmt|;
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|;
specifier|register
name|int
name|nitems
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|level
decl_stmt|,
name|maxlen
decl_stmt|,
name|nlinks
decl_stmt|,
name|saved_errno
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|p
operator|=
name|sp
operator|->
name|cur
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|p
operator|->
name|accpath
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|set_node_errors
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|FTS_DNR
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|CHDIR
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|accpath
argument_list|)
condition|)
block|{
if|if
condition|(
name|set_node_errors
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|FTS_DNX
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * the real slowdown in walking the tree is the stat calls.  If 	 * FTS_NOSTAT is set and it's a physical walk (so that symbolic 	 * links can't be directories), fts assumes that the number of 	 * subdirectories in a node is equal to the number of links to 	 * the parent.  This allows stat calls to be skipped in any leaf 	 * directories and for any nodes after the directories in the 	 * parent node have been found.  This empirically cuts the stat 	 * calls by about 2/3. 	 */
name|nlinks
operator|=
name|sp
operator|->
name|options
operator|&
name|FTS_NOSTAT
operator|&&
name|sp
operator|->
name|options
operator|&
name|FTS_PHYSICAL
condition|?
name|p
operator|->
name|statb
operator|.
name|st_nlink
operator|-
operator|(
name|sp
operator|->
name|options
operator|&
name|FTS_SEEDOT
condition|?
literal|0
else|:
literal|2
operator|)
else|:
operator|-
literal|1
expr_stmt|;
comment|/* get max file name length that can be stored in current path */
name|maxlen
operator|=
name|sp
operator|->
name|pathlen
operator|-
name|p
operator|->
name|pathlen
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
name|sp
operator|->
name|path
operator|+
operator|(
name|len
operator|=
name|NAPPEND
argument_list|(
name|p
argument_list|)
operator|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|level
operator|=
name|p
operator|->
name|level
operator|+
literal|1
expr_stmt|;
comment|/* read the directory, attching each new entry to the `link' pointer */
for|for
control|(
name|head
operator|=
name|NULL
operator|,
name|nitems
operator|=
literal|0
init|;
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|ISDOT
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|&&
operator|!
operator|(
name|sp
operator|->
name|options
operator|&
name|FTS_SEEDOT
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|fts_alloc
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
operator|)
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
goto|goto
name|mem1
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|>
name|maxlen
condition|)
block|{
if|if
condition|(
operator|!
name|fts_path
argument_list|(
operator|(
name|int
operator|)
name|dp
operator|->
name|d_namlen
argument_list|)
condition|)
block|{
comment|/* quit: this stream no longer has a path */
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
name|saved_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|mem1
label|:
name|fts_lfree
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_node_errors
condition|)
name|p
operator|->
name|info
operator|=
name|FTS_ERR
expr_stmt|;
if|if
condition|(
name|CHDIR
argument_list|(
name|sp
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
block|}
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|maxlen
operator|=
name|sp
operator|->
name|pathlen
operator|-
name|sp
operator|->
name|cur
operator|->
name|pathlen
operator|-
literal|1
expr_stmt|;
block|}
name|p
operator|->
name|pathlen
operator|=
name|len
operator|+
name|dp
operator|->
name|d_namlen
operator|+
literal|1
expr_stmt|;
name|p
operator|->
name|accpath
operator|=
name|sp
operator|->
name|options
operator|&
name|FTS_NOCHDIR
condition|?
name|p
operator|->
name|path
else|:
name|p
operator|->
name|name
expr_stmt|;
name|p
operator|->
name|parent
operator|=
name|sp
operator|->
name|cur
expr_stmt|;
name|p
operator|->
name|level
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|nlinks
condition|)
block|{
comment|/* make sure fts_stat has a filename to stat */
if|if
condition|(
name|sp
operator|->
name|options
operator|&
name|FTS_NOCHDIR
condition|)
name|bcopy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|p
operator|->
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|fts_stat
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlinks
operator|>
literal|0
operator|&&
operator|(
name|p
operator|->
name|info
operator|==
name|FTS_D
operator|||
name|p
operator|->
name|info
operator|==
name|FTS_DNR
operator|||
name|p
operator|->
name|info
operator|==
name|FTS_DNX
operator|)
condition|)
operator|--
name|nlinks
expr_stmt|;
block|}
else|else
name|p
operator|->
name|info
operator|=
name|FTS_NS
expr_stmt|;
name|p
operator|->
name|link
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|p
expr_stmt|;
operator|++
name|nitems
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nitems
condition|)
block|{
if|if
condition|(
name|CHDIR
argument_list|(
name|sp
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|sp
operator|->
name|options
operator||=
name|FTS__STOP
expr_stmt|;
name|p
operator|->
name|info
operator|=
name|FTS_ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_node_errors
condition|)
name|p
operator|->
name|info
operator|=
name|FTS_DP
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|compar
operator|&&
name|nitems
operator|>
literal|1
condition|)
name|head
operator|=
name|fts_sort
argument_list|(
name|head
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_node_errors
condition|)
name|bcopy
argument_list|(
name|head
operator|->
name|name
argument_list|,
name|cp
argument_list|,
name|head
operator|->
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|short
name|fts_stat
parameter_list|(
name|p
parameter_list|,
name|symflag
parameter_list|)
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|int
name|symflag
decl_stmt|;
block|{
specifier|register
name|int
name|ngroups
decl_stmt|,
modifier|*
name|gp
decl_stmt|;
name|int
name|gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
comment|/* 	 * detection of symbolic links w/o targets.  If FTS_FOLLOW is set, 	 * the symlink structure is overwritten with the stat structure of 	 * the target. 	 */
if|if
condition|(
name|stream
operator|->
name|options
operator|&
name|FTS_LOGICAL
operator|||
name|symflag
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|p
operator|->
name|accpath
argument_list|,
operator|&
name|p
operator|->
name|statb
argument_list|)
condition|)
return|return
operator|(
name|symflag
operator|||
operator|!
name|lstat
argument_list|(
name|p
operator|->
name|accpath
argument_list|,
operator|&
name|p
operator|->
name|statb
argument_list|)
condition|?
name|FTS_SLNONE
else|:
name|FTS_ERR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lstat
argument_list|(
name|p
operator|->
name|accpath
argument_list|,
operator|&
name|p
operator|->
name|statb
argument_list|)
condition|)
return|return
operator|(
name|FTS_ERR
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
comment|/* get new uid/groups each time, they may have changed */
if|if
condition|(
name|getuid
argument_list|()
operator|==
name|p
operator|->
name|statb
operator|.
name|st_uid
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IRUSR
operator|)
condition|)
return|return
operator|(
name|FTS_DNR
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IXUSR
operator|)
condition|)
return|return
operator|(
name|FTS_DNX
operator|)
return|;
return|return
operator|(
name|FTS_D
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ngroups
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gidset
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|FTS_ERR
operator|)
return|;
for|for
control|(
name|gp
operator|=
name|gidset
init|;
name|ngroups
operator|--
condition|;
control|)
if|if
condition|(
operator|*
name|gp
operator|++
operator|==
name|p
operator|->
name|statb
operator|.
name|st_gid
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IRGRP
operator|)
condition|)
return|return
operator|(
name|FTS_DNR
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IXGRP
operator|)
condition|)
return|return
operator|(
name|FTS_DNX
operator|)
return|;
return|return
operator|(
name|FTS_D
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IROTH
operator|)
condition|)
return|return
operator|(
name|FTS_DNR
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|statb
operator|.
name|st_mode
operator|&
name|S_IXOTH
operator|)
condition|)
return|return
operator|(
name|FTS_DNX
operator|)
return|;
return|return
operator|(
name|FTS_D
operator|)
return|;
case|case
name|S_IFLNK
case|:
return|return
operator|(
name|FTS_SL
operator|)
return|;
case|case
name|S_IFREG
case|:
return|return
operator|(
name|FTS_F
operator|)
return|;
default|default:
return|return
operator|(
name|FTS_DEFAULT
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_cycle
parameter_list|(
name|p
parameter_list|)
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|ino_t
name|ino
decl_stmt|;
comment|/* 	 * cycle detection is brute force; if the tree gets deep enough or 	 * the number of symbolic links to directories is really high 	 * something faster might be worthwhile. 	 */
name|dev
operator|=
name|p
operator|->
name|statb
operator|.
name|st_dev
expr_stmt|;
name|ino
operator|=
name|p
operator|->
name|statb
operator|.
name|st_ino
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|parent
init|;
name|p
operator|->
name|level
operator|>
name|ROOTLEVEL
condition|;
name|p
operator|=
name|p
operator|->
name|parent
control|)
if|if
condition|(
name|ino
operator|==
name|p
operator|->
name|statb
operator|.
name|st_ino
operator|&&
name|dev
operator|==
name|p
operator|->
name|statb
operator|.
name|st_dev
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|R
parameter_list|(
name|type
parameter_list|,
name|nelem
parameter_list|,
name|ptr
parameter_list|)
define|\
value|(type *)realloc((char *)ptr, (u_int)((nelem) * sizeof(type)))
end_define

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_sort
parameter_list|(
name|head
parameter_list|,
name|nitems
parameter_list|)
name|FTSENT
modifier|*
name|head
decl_stmt|;
specifier|register
name|int
name|nitems
decl_stmt|;
block|{
specifier|register
name|FTSENT
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* 	 * construct an array of pointers to the structures and call qsort(3). 	 * Reassemble the array in the order returned by qsort.  If unable to 	 * sort for memory reasons, return the directory entries in their 	 * current order.  Allocate enough space for the current needs plus 	 * 40 so we don't realloc one entry at a time. 	 */
if|if
condition|(
name|nitems
operator|>
name|stream
operator|->
name|nitems
condition|)
block|{
name|stream
operator|->
name|nitems
operator|=
name|nitems
operator|+
literal|40
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stream
operator|->
name|array
operator|=
name|R
argument_list|(
name|FTSENT
operator|*
argument_list|,
name|stream
operator|->
name|nitems
argument_list|,
name|stream
operator|->
name|array
argument_list|)
operator|)
condition|)
block|{
name|stream
operator|->
name|nitems
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
block|}
for|for
control|(
name|ap
operator|=
name|stream
operator|->
name|array
operator|,
name|p
operator|=
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|link
control|)
operator|*
name|ap
operator|++
operator|=
name|p
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stream
operator|->
name|array
argument_list|,
name|nitems
argument_list|,
sizeof|sizeof
argument_list|(
name|FTSENT
operator|*
argument_list|)
argument_list|,
name|stream
operator|->
name|compar
argument_list|)
expr_stmt|;
for|for
control|(
name|head
operator|=
operator|*
operator|(
name|ap
operator|=
name|stream
operator|->
name|array
operator|)
init|;
operator|--
name|nitems
condition|;
operator|++
name|ap
control|)
name|ap
index|[
literal|0
index|]
operator|->
name|link
operator|=
name|ap
index|[
literal|1
index|]
expr_stmt|;
name|ap
index|[
literal|0
index|]
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_alloc
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|;
comment|/* 	 * variable sized structures; the name is the last element so 	 * allocate enough extra space after the structure to hold it. 	 */
if|if
condition|(
operator|!
operator|(
name|p
operator|=
operator|(
name|FTSENT
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|u_int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|FTSENT
argument_list|)
operator|+
name|len
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|namelen
operator|=
name|len
expr_stmt|;
name|p
operator|->
name|path
operator|=
name|stream
operator|->
name|path
expr_stmt|;
name|p
operator|->
name|instr
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|local
operator|.
name|number
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|local
operator|.
name|pointer
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|fts_lfree
argument_list|(
name|head
argument_list|)
specifier|register
name|FTSENT
operator|*
name|head
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|FTSENT
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|head
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|link
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * allow essentially unlimited paths; certain programs (find, remove, ls)  * need to work on any tree.  Most systems will allow creation of paths  * much longer than MAXPATHLEN, even though the kernel won't resolve them.  * Add an extra 128 bytes to the requested size so that we don't realloc  * the path 2 bytes at a time.  */
end_comment

begin_expr_stmt
specifier|static
name|fts_path
argument_list|(
argument|size
argument_list|)
name|int
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|stream
operator|->
name|pathlen
operator|+=
name|size
operator|+
literal|128
expr_stmt|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|stream
operator|->
name|path
operator|=
name|R
argument_list|(
name|char
argument_list|,
name|stream
operator|->
name|pathlen
argument_list|,
name|stream
operator|->
name|path
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_root
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * rip trailing slashes; it's somewhat unclear in POSIX 1003.1 what 	 * /a/b/ really is, they don't talk about what a null path component 	 * resolves to.  This hopefully does what the user intended.  Don't 	 * allow null pathnames. 	 */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
operator|++
name|cp
control|)
empty_stmt|;
if|if
condition|(
name|cp
operator|==
name|name
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|--
name|cp
operator|>
name|name
operator|&&
operator|*
name|cp
operator|==
literal|'/'
condition|)
empty_stmt|;
operator|*
operator|++
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|fts_alloc
argument_list|(
name|name
argument_list|,
name|cp
operator|-
name|name
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

