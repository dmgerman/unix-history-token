begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Tom Truscott.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)crypt.c	8.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/*  * UNIX password, and DES, encryption.  * By Tom Truscott, trt@rti.rti.org,  * from algorithms by Robert W. Baldwin and James Gillogly.  *  * References:  * "Mathematical Cryptology for Computer Scientists and Mathematicians,"  * by Wayne Patterson, 1987, ISBN 0-8476-7438-X.  *  * "Password Security: A Case History," R. Morris and Ken Thompson,  * Communications of the ACM, vol. 22, pp. 594-597, Nov. 1979.  *  * "DES will be Totally Insecure within Ten Years," M.E. Hellman,  * IEEE Spectrum, vol. 16, pp. 32-39, July 1979.  */
end_comment

begin_comment
comment|/* =====  Configuration ==================== */
end_comment

begin_comment
comment|/*  * define "MUST_ALIGN" if your compiler cannot load/store  * long integers at arbitrary (e.g. odd) memory locations.  * (Either that or never pass unaligned addresses to des_cipher!)  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|vax
argument_list|)
end_if

begin_define
define|#
directive|define
name|MUST_ALIGN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CHAR_BITS
end_ifdef

begin_if
if|#
directive|if
name|CHAR_BITS
operator|!=
literal|8
end_if

begin_error
error|#
directive|error
error|C_block structure assumes 8 bit characters
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * define "LONG_IS_32_BITS" only if sizeof(long)==4.  * This avoids use of bit fields (your compiler may be sloppy with them).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|cray
argument_list|)
end_if

begin_define
define|#
directive|define
name|LONG_IS_32_BITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * define "B64" to be the declaration for a 64 bit integer.  * XXX this feature is currently unused, see "endian" comment below.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|cray
argument_list|)
end_if

begin_define
define|#
directive|define
name|B64
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|convex
argument_list|)
end_if

begin_define
define|#
directive|define
name|B64
value|long long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * define "LARGEDATA" to get faster permutations, by using about 72 kilobytes  * of lookup tables.  This speeds up des_setkey() and des_cipher(), but has  * little effect on crypt().  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|notdef
argument_list|)
end_if

begin_define
define|#
directive|define
name|LARGEDATA
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* compile with "-DSTATIC=int" when profiling */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|STATIC
name|init_des
argument_list|()
decl_stmt|,
name|init_perm
argument_list|()
decl_stmt|,
name|permute
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|STATIC
name|prtab
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ==================================== */
end_comment

begin_comment
comment|/*  * Cipher-block representation (Bob Baldwin):  *  * DES operates on groups of 64 bits, numbered 1..64 (sigh).  One  * representation is to store one bit per byte in an array of bytes.  Bit N of  * the NBS spec is stored as the LSB of the Nth byte (index N-1) in the array.  * Another representation stores the 64 bits in 8 bytes, with bits 1..8 in the  * first byte, 9..16 in the second, and so on.  The DES spec apparently has  * bit 1 in the MSB of the first byte, but that is particularly noxious so we  * bit-reverse each byte so that bit 1 is the LSB of the first byte, bit 8 is  * the MSB of the first byte.  Specifically, the 64-bit input data and key are  * converted to LSB format, and the output 64-bit block is converted back into  * MSB format.  *  * DES operates internally on groups of 32 bits which are expanded to 48 bits  * by permutation E and shrunk back to 32 bits by the S boxes.  To speed up  * the computation, the expansion is applied only once, the expanded  * representation is maintained during the encryption, and a compression  * permutation is applied only at the end.  To speed up the S-box lookups,  * the 48 bits are maintained as eight 6 bit groups, one per byte, which  * directly feed the eight S-boxes.  Within each byte, the 6 bits are the  * most significant ones.  The low two bits of each byte are zero.  (Thus,  * bit 1 of the 48 bit E expansion is stored as the "4"-valued bit of the  * first byte in the eight byte representation, bit 2 of the 48 bit value is  * the "8"-valued bit, and so on.)  In fact, a combined "SPE"-box lookup is  * used, in which the output is the 64 bit result of an S-box lookup which  * has been permuted by P and expanded by E, and is ready for use in the next  * iteration.  Two 32-bit wide tables, SPE[0] and SPE[1], are used for this  * lookup.  Since each byte in the 48 bit path is a multiple of four, indexed  * lookup of SPE[0] and SPE[1] is simple and fast.  The key schedule and  * "salt" are also converted to this 8*(6+2) format.  The SPE table size is  * 8*64*8 = 4K bytes.  *  * To speed up bit-parallel operations (such as XOR), the 8 byte  * representation is "union"ed with 32 bit values "i0" and "i1", and, on  * machines which support it, a 64 bit value "b64".  This data structure,  * "C_block", has two problems.  First, alignment restrictions must be  * honored.  Second, the byte-order (e.g. little-endian or big-endian) of  * the architecture becomes visible.  *  * The byte-order problem is unfortunate, since on the one hand it is good  * to have a machine-independent C_block representation (bits 1..8 in the  * first byte, etc.), and on the other hand it is good for the LSB of the  * first byte to be the LSB of i0.  We cannot have both these things, so we  * currently use the "little-endian" representation and avoid any multi-byte  * operations that depend on byte order.  This largely precludes use of the  * 64-bit datatype since the relative order of i0 and i1 are unknown.  It  * also inhibits grouping the SPE table to look up 12 bits at a time.  (The  * 12 bits can be stored in a 16-bit field with 3 low-order zeroes and 1  * high-order zero, providing fast indexing into a 64-bit wide SPE.)  On the  * other hand, 64-bit datatypes are currently rare, and a 12-bit SPE lookup  * requires a 128 kilobyte table, so perhaps this is not a big loss.  *  * Permutation representation (Jim Gillogly):  *  * A transformation is defined by its effect on each of the 8 bytes of the  * 64-bit input.  For each byte we give a 64-bit output that has the bits in  * the input distributed appropriately.  The transformation is then the OR  * of the 8 sets of 64-bits.  This uses 8*256*8 = 16K bytes of storage for  * each transformation.  Unless LARGEDATA is defined, however, a more compact  * table is used which looks up 16 4-bit "chunks" rather than 8 8-bit chunks.  * The smaller table uses 16*16*8 = 2K bytes for each transformation.  This  * is slower but tolerable, particularly for password encryption in which  * the SPE transformation is iterated many times.  The small tables total 9K  * bytes, the large tables total 72K bytes.  *  * The transformations used are:  * IE3264: MSB->LSB conversion, initial permutation, and expansion.  *	This is done by collecting the 32 even-numbered bits and applying  *	a 32->64 bit transformation, and then collecting the 32 odd-numbered  *	bits and applying the same transformation.  Since there are only  *	32 input bits, the IE3264 transformation table is half the size of  *	the usual table.  * CF6464: Compression, final permutation, and LSB->MSB conversion.  *	This is done by two trivial 48->32 bit compressions to obtain  *	a 64-bit block (the bit numbering is given in the "CIFP" table)  *	followed by a 64->64 bit "cleanup" transformation.  (It would  *	be possible to group the bits in the 64-bit block so that 2  *	identical 32->32 bit transformations could be used instead,  *	saving a factor of 4 in space and possibly 2 in time, but  *	byte-ordering and other complications rear their ugly head.  *	Similar opportunities/problems arise in the key schedule  *	transforms.)  * PC1ROT: MSB->LSB, PC1 permutation, rotate, and PC2 permutation.  *	This admittedly baroque 64->64 bit transformation is used to  *	produce the first code (in 8*(6+2) format) of the key schedule.  * PC2ROT[0]: Inverse PC2 permutation, rotate, and PC2 permutation.  *	It would be possible to define 15 more transformations, each  *	with a different rotation, to generate the entire key schedule.  *	To save space, however, we instead permute each code into the  *	next by using a transformation that "undoes" the PC2 permutation,  *	rotates the code, and then applies PC2.  Unfortunately, PC2  *	transforms 56 bits into 48 bits, dropping 8 bits, so PC2 is not  *	invertible.  We get around that problem by using a modified PC2  *	which retains the 8 otherwise-lost bits in the unused low-order  *	bits of each byte.  The low-order bits are cleared when the  *	codes are stored into the key schedule.  * PC2ROT[1]: Same as PC2ROT[0], but with two rotations.  *	This is faster than applying PC2ROT[0] twice,  *  * The Bell Labs "salt" (Bob Baldwin):  *  * The salting is a simple permutation applied to the 48-bit result of E.  * Specifically, if bit i (1<= i<= 24) of the salt is set then bits i and  * i+24 of the result are swapped.  The salt is thus a 24 bit number, with  * 16777216 possible values.  (The original salt was 12 bits and could not  * swap bits 13..24 with 36..48.)  *  * It is possible, but ugly, to warp the SPE table to account for the salt  * permutation.  Fortunately, the conditional bit swapping requires only  * about four machine instructions and can be done on-the-fly with about an  * 8% performance penalty.  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|unsigned
name|char
name|b
index|[
literal|8
index|]
decl_stmt|;
struct|struct
block|{
if|#
directive|if
name|defined
argument_list|(
name|LONG_IS_32_BITS
argument_list|)
comment|/* long is often faster than a 32-bit bit field */
name|long
name|i0
decl_stmt|;
name|long
name|i1
decl_stmt|;
else|#
directive|else
name|long
name|i0
range|:
literal|32
decl_stmt|;
name|long
name|i1
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|b32
struct|;
if|#
directive|if
name|defined
argument_list|(
name|B64
argument_list|)
name|B64
name|b64
decl_stmt|;
endif|#
directive|endif
block|}
name|C_block
typedef|;
end_typedef

begin_comment
comment|/*  * Convert twenty-four-bit long in host-order  * to six bits (and 2 low-order zeroes) per char little-endian format.  */
end_comment

begin_define
define|#
directive|define
name|TO_SIX_BIT
parameter_list|(
name|rslt
parameter_list|,
name|src
parameter_list|)
value|{				\ 		C_block cvt;				\ 		cvt.b[0] = src; src>>= 6;		\ 		cvt.b[1] = src; src>>= 6;		\ 		cvt.b[2] = src; src>>= 6;		\ 		cvt.b[3] = src;				\ 		rslt = (cvt.b32.i0& 0x3f3f3f3fL)<< 2;	\ 	}
end_define

begin_comment
comment|/*  * These macros may someday permit efficient use of 64-bit integers.  */
end_comment

begin_define
define|#
directive|define
name|ZERO
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|)
value|d0 = 0, d1 = 0
end_define

begin_define
define|#
directive|define
name|LOAD
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|bl
parameter_list|)
value|d0 = (bl).b32.i0, d1 = (bl).b32.i1
end_define

begin_define
define|#
directive|define
name|LOADREG
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|s
parameter_list|,
name|s0
parameter_list|,
name|s1
parameter_list|)
value|d0 = s0, d1 = s1
end_define

begin_define
define|#
directive|define
name|OR
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|bl
parameter_list|)
value|d0 |= (bl).b32.i0, d1 |= (bl).b32.i1
end_define

begin_define
define|#
directive|define
name|STORE
parameter_list|(
name|s
parameter_list|,
name|s0
parameter_list|,
name|s1
parameter_list|,
name|bl
parameter_list|)
value|(bl).b32.i0 = s0, (bl).b32.i1 = s1
end_define

begin_define
define|#
directive|define
name|DCL_BLOCK
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|)
value|long d0, d1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LARGEDATA
argument_list|)
end_if

begin_comment
comment|/* Waste memory like crazy.  Also, do permutations in line */
end_comment

begin_define
define|#
directive|define
name|LGCHUNKBITS
value|3
end_define

begin_define
define|#
directive|define
name|CHUNKBITS
value|(1<<LGCHUNKBITS)
end_define

begin_define
define|#
directive|define
name|PERM6464
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|cpp
parameter_list|,
name|p
parameter_list|)
define|\
value|LOAD(d,d0,d1,(p)[(0<<CHUNKBITS)+(cpp)[0]]);		\ 	OR (d,d0,d1,(p)[(1<<CHUNKBITS)+(cpp)[1]]);		\ 	OR (d,d0,d1,(p)[(2<<CHUNKBITS)+(cpp)[2]]);		\ 	OR (d,d0,d1,(p)[(3<<CHUNKBITS)+(cpp)[3]]);		\ 	OR (d,d0,d1,(p)[(4<<CHUNKBITS)+(cpp)[4]]);		\ 	OR (d,d0,d1,(p)[(5<<CHUNKBITS)+(cpp)[5]]);		\ 	OR (d,d0,d1,(p)[(6<<CHUNKBITS)+(cpp)[6]]);		\ 	OR (d,d0,d1,(p)[(7<<CHUNKBITS)+(cpp)[7]]);
end_define

begin_define
define|#
directive|define
name|PERM3264
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|cpp
parameter_list|,
name|p
parameter_list|)
define|\
value|LOAD(d,d0,d1,(p)[(0<<CHUNKBITS)+(cpp)[0]]);		\ 	OR (d,d0,d1,(p)[(1<<CHUNKBITS)+(cpp)[1]]);		\ 	OR (d,d0,d1,(p)[(2<<CHUNKBITS)+(cpp)[2]]);		\ 	OR (d,d0,d1,(p)[(3<<CHUNKBITS)+(cpp)[3]]);
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* "small data" */
end_comment

begin_define
define|#
directive|define
name|LGCHUNKBITS
value|2
end_define

begin_define
define|#
directive|define
name|CHUNKBITS
value|(1<<LGCHUNKBITS)
end_define

begin_define
define|#
directive|define
name|PERM6464
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|cpp
parameter_list|,
name|p
parameter_list|)
define|\
value|{ C_block tblk; permute(cpp,&tblk,p,8); LOAD (d,d0,d1,tblk); }
end_define

begin_define
define|#
directive|define
name|PERM3264
parameter_list|(
name|d
parameter_list|,
name|d0
parameter_list|,
name|d1
parameter_list|,
name|cpp
parameter_list|,
name|p
parameter_list|)
define|\
value|{ C_block tblk; permute(cpp,&tblk,p,4); LOAD (d,d0,d1,tblk); }
end_define

begin_function
name|STATIC
name|permute
parameter_list|(
name|cp
parameter_list|,
name|out
parameter_list|,
name|p
parameter_list|,
name|chars_in
parameter_list|)
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
name|C_block
modifier|*
name|out
decl_stmt|;
specifier|register
name|C_block
modifier|*
name|p
decl_stmt|;
name|int
name|chars_in
decl_stmt|;
block|{
specifier|register
name|DCL_BLOCK
argument_list|(
name|D
argument_list|,
name|D0
argument_list|,
name|D1
argument_list|)
expr_stmt|;
specifier|register
name|C_block
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|ZERO
argument_list|(
name|D
argument_list|,
name|D0
argument_list|,
name|D1
argument_list|)
expr_stmt|;
do|do
block|{
name|t
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|=
operator|&
name|p
index|[
name|t
operator|&
literal|0xf
index|]
expr_stmt|;
name|OR
argument_list|(
name|D
argument_list|,
name|D0
argument_list|,
name|D1
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
literal|1
operator|<<
name|CHUNKBITS
operator|)
expr_stmt|;
name|tp
operator|=
operator|&
name|p
index|[
name|t
operator|>>
literal|4
index|]
expr_stmt|;
name|OR
argument_list|(
name|D
argument_list|,
name|D0
argument_list|,
name|D1
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
literal|1
operator|<<
name|CHUNKBITS
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|chars_in
operator|>
literal|0
condition|)
do|;
name|STORE
argument_list|(
name|D
argument_list|,
name|D0
argument_list|,
name|D1
argument_list|,
operator|*
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LARGEDATA */
end_comment

begin_comment
comment|/* =====  (mostly) Standard DES Tables ==================== */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|IP
index|[]
init|=
block|{
comment|/* initial permutation */
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|64
block|,
literal|56
block|,
literal|48
block|,
literal|40
block|,
literal|32
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The final permutation is the inverse of IP - no table is necessary */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ExpandTr
index|[]
init|=
block|{
comment|/* expansion operation */
literal|32
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|PC1
index|[]
init|=
block|{
comment|/* permuted choice table 1 */
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|Rotates
index|[]
init|=
block|{
comment|/* PC1 rotation schedule */
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note: each "row" of PC2 is left-padded with bits that make it invertible */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|PC2
index|[]
init|=
block|{
comment|/* permuted choice table 2 */
literal|9
block|,
literal|18
block|,
literal|14
block|,
literal|17
block|,
literal|11
block|,
literal|24
block|,
literal|1
block|,
literal|5
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|28
block|,
literal|15
block|,
literal|6
block|,
literal|21
block|,
literal|10
block|,
literal|35
block|,
literal|38
block|,
literal|23
block|,
literal|19
block|,
literal|12
block|,
literal|4
block|,
literal|26
block|,
literal|8
block|,
literal|43
block|,
literal|54
block|,
literal|16
block|,
literal|7
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|41
block|,
literal|52
block|,
literal|31
block|,
literal|37
block|,
literal|47
block|,
literal|55
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|40
block|,
literal|51
block|,
literal|45
block|,
literal|33
block|,
literal|48
block|,
literal|0
block|,
literal|0
block|,
literal|44
block|,
literal|49
block|,
literal|39
block|,
literal|56
block|,
literal|34
block|,
literal|53
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|42
block|,
literal|50
block|,
literal|36
block|,
literal|29
block|,
literal|32
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|S
index|[
literal|8
index|]
index|[
literal|64
index|]
init|=
block|{
comment|/* 48->32 bit substitution tables */
comment|/* S[1]			*/
literal|14
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|2
block|,
literal|15
block|,
literal|11
block|,
literal|8
block|,
literal|3
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|5
block|,
literal|9
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|15
block|,
literal|7
block|,
literal|4
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|11
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|14
block|,
literal|8
block|,
literal|13
block|,
literal|6
block|,
literal|2
block|,
literal|11
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|12
block|,
literal|8
block|,
literal|2
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|3
block|,
literal|14
block|,
literal|10
block|,
literal|0
block|,
literal|6
block|,
literal|13
block|,
comment|/* S[2]			*/
literal|15
block|,
literal|1
block|,
literal|8
block|,
literal|14
block|,
literal|6
block|,
literal|11
block|,
literal|3
block|,
literal|4
block|,
literal|9
block|,
literal|7
block|,
literal|2
block|,
literal|13
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|13
block|,
literal|4
block|,
literal|7
block|,
literal|15
block|,
literal|2
block|,
literal|8
block|,
literal|14
block|,
literal|12
block|,
literal|0
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|11
block|,
literal|5
block|,
literal|0
block|,
literal|14
block|,
literal|7
block|,
literal|11
block|,
literal|10
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|8
block|,
literal|12
block|,
literal|6
block|,
literal|9
block|,
literal|3
block|,
literal|2
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|1
block|,
literal|3
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|14
block|,
literal|9
block|,
comment|/* S[3]			*/
literal|10
block|,
literal|0
block|,
literal|9
block|,
literal|14
block|,
literal|6
block|,
literal|3
block|,
literal|15
block|,
literal|5
block|,
literal|1
block|,
literal|13
block|,
literal|12
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|2
block|,
literal|8
block|,
literal|13
block|,
literal|7
block|,
literal|0
block|,
literal|9
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|14
block|,
literal|12
block|,
literal|11
block|,
literal|15
block|,
literal|1
block|,
literal|13
block|,
literal|6
block|,
literal|4
block|,
literal|9
block|,
literal|8
block|,
literal|15
block|,
literal|3
block|,
literal|0
block|,
literal|11
block|,
literal|1
block|,
literal|2
block|,
literal|12
block|,
literal|5
block|,
literal|10
block|,
literal|14
block|,
literal|7
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|4
block|,
literal|15
block|,
literal|14
block|,
literal|3
block|,
literal|11
block|,
literal|5
block|,
literal|2
block|,
literal|12
block|,
comment|/* S[4]			*/
literal|7
block|,
literal|13
block|,
literal|14
block|,
literal|3
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|10
block|,
literal|1
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|4
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|11
block|,
literal|5
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|2
block|,
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|7
block|,
literal|13
block|,
literal|15
block|,
literal|1
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|3
block|,
literal|15
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|8
block|,
literal|9
block|,
literal|4
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|7
block|,
literal|2
block|,
literal|14
block|,
comment|/* S[5]			*/
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|1
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|8
block|,
literal|5
block|,
literal|3
block|,
literal|15
block|,
literal|13
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|14
block|,
literal|11
block|,
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|10
block|,
literal|3
block|,
literal|9
block|,
literal|8
block|,
literal|6
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|,
literal|11
block|,
literal|10
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|9
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|0
block|,
literal|14
block|,
literal|11
block|,
literal|8
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|9
block|,
literal|10
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
comment|/* S[6]			*/
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|15
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|14
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|10
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|0
block|,
literal|11
block|,
literal|3
block|,
literal|8
block|,
literal|9
block|,
literal|14
block|,
literal|15
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|0
block|,
literal|4
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|11
block|,
literal|6
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|15
block|,
literal|10
block|,
literal|11
block|,
literal|14
block|,
literal|1
block|,
literal|7
block|,
literal|6
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
comment|/* S[7]			*/
literal|4
block|,
literal|11
block|,
literal|2
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
literal|3
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|10
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|0
block|,
literal|11
block|,
literal|7
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|3
block|,
literal|5
block|,
literal|12
block|,
literal|2
block|,
literal|15
block|,
literal|8
block|,
literal|6
block|,
literal|1
block|,
literal|4
block|,
literal|11
block|,
literal|13
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|14
block|,
literal|10
block|,
literal|15
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|5
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|11
block|,
literal|13
block|,
literal|8
block|,
literal|1
block|,
literal|4
block|,
literal|10
block|,
literal|7
block|,
literal|9
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|14
block|,
literal|2
block|,
literal|3
block|,
literal|12
block|,
comment|/* S[8]			*/
literal|13
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|6
block|,
literal|15
block|,
literal|11
block|,
literal|1
block|,
literal|10
block|,
literal|9
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|0
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|2
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|1
block|,
literal|9
block|,
literal|12
block|,
literal|14
block|,
literal|2
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|15
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|14
block|,
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|8
block|,
literal|13
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|P32Tr
index|[]
init|=
block|{
comment|/* 32-bit permutation function */
literal|16
block|,
literal|7
block|,
literal|20
block|,
literal|21
block|,
literal|29
block|,
literal|12
block|,
literal|28
block|,
literal|17
block|,
literal|1
block|,
literal|15
block|,
literal|23
block|,
literal|26
block|,
literal|5
block|,
literal|18
block|,
literal|31
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|24
block|,
literal|14
block|,
literal|32
block|,
literal|27
block|,
literal|3
block|,
literal|9
block|,
literal|19
block|,
literal|13
block|,
literal|30
block|,
literal|6
block|,
literal|22
block|,
literal|11
block|,
literal|4
block|,
literal|25
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|CIFP
index|[]
init|=
block|{
comment|/* compressed/interleaved permutation */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|itoa64
index|[]
init|=
comment|/* 0..63 => ascii-64 */
literal|"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* =====  Tables that are initialized at run time  ==================== */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|a64toi
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ascii-64 => 0..63 */
end_comment

begin_comment
comment|/* Initial key schedule permutation */
end_comment

begin_decl_stmt
specifier|static
name|C_block
name|PC1ROT
index|[
literal|64
operator|/
name|CHUNKBITS
index|]
index|[
literal|1
operator|<<
name|CHUNKBITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subsequent key schedule rotation permutations */
end_comment

begin_decl_stmt
specifier|static
name|C_block
name|PC2ROT
index|[
literal|2
index|]
index|[
literal|64
operator|/
name|CHUNKBITS
index|]
index|[
literal|1
operator|<<
name|CHUNKBITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial permutation/expansion table */
end_comment

begin_decl_stmt
specifier|static
name|C_block
name|IE3264
index|[
literal|32
operator|/
name|CHUNKBITS
index|]
index|[
literal|1
operator|<<
name|CHUNKBITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table that combines the S, P, and E operations.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|SPE
index|[
literal|2
index|]
index|[
literal|8
index|]
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compressed/interleaved => final permutation table */
end_comment

begin_decl_stmt
specifier|static
name|C_block
name|CF6464
index|[
literal|64
operator|/
name|CHUNKBITS
index|]
index|[
literal|1
operator|<<
name|CHUNKBITS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ==================================== */
end_comment

begin_decl_stmt
specifier|static
name|C_block
name|constdatablock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* encryption constant */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cryptresult
index|[
literal|1
operator|+
literal|4
operator|+
literal|4
operator|+
literal|11
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* encrypted result */
end_comment

begin_comment
comment|/*  * Return a pointer to static data consisting of the "setting"  * followed by an encryption produced by the "key" and "setting".  */
end_comment

begin_function
name|char
modifier|*
name|crypt
parameter_list|(
name|key
parameter_list|,
name|setting
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|setting
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|encp
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|long
name|salt
decl_stmt|;
name|int
name|num_iter
decl_stmt|,
name|salt_size
decl_stmt|;
name|C_block
name|keyblock
decl_stmt|,
name|rsltblock
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
literal|2
operator|*
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|key
operator|++
expr_stmt|;
name|keyblock
operator|.
name|b
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|des_setkey
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyblock
operator|.
name|b
argument_list|)
condition|)
comment|/* also initializes "a64toi" */
return|return
operator|(
name|NULL
operator|)
return|;
name|encp
operator|=
operator|&
name|cryptresult
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|setting
condition|)
block|{
case|case
name|_PASSWORD_EFMT1
case|:
comment|/* 		 * Involve the rest of the password 8 characters at a time. 		 */
while|while
condition|(
operator|*
name|key
condition|)
block|{
if|if
condition|(
name|des_cipher
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyblock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|keyblock
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
literal|2
operator|*
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|*
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|key
operator|++
expr_stmt|;
name|keyblock
operator|.
name|b
index|[
name|i
index|]
operator|^=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|des_setkey
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyblock
operator|.
name|b
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|encp
operator|++
operator|=
operator|*
name|setting
operator|++
expr_stmt|;
comment|/* get iteration count */
name|num_iter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|unsigned
name|char
operator|)
name|setting
index|[
name|i
index|]
operator|)
operator|==
literal|'\0'
condition|)
name|t
operator|=
literal|'.'
expr_stmt|;
name|encp
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|num_iter
operator|=
operator|(
name|num_iter
operator|<<
literal|6
operator|)
operator||
name|a64toi
index|[
name|t
index|]
expr_stmt|;
block|}
name|setting
operator|+=
literal|4
expr_stmt|;
name|encp
operator|+=
literal|4
expr_stmt|;
name|salt_size
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|num_iter
operator|=
literal|25
expr_stmt|;
name|salt_size
operator|=
literal|2
expr_stmt|;
block|}
name|salt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|salt_size
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|unsigned
name|char
operator|)
name|setting
index|[
name|i
index|]
operator|)
operator|==
literal|'\0'
condition|)
name|t
operator|=
literal|'.'
expr_stmt|;
name|encp
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|salt
operator|=
operator|(
name|salt
operator|<<
literal|6
operator|)
operator||
name|a64toi
index|[
name|t
index|]
expr_stmt|;
block|}
name|encp
operator|+=
name|salt_size
expr_stmt|;
if|if
condition|(
name|des_cipher
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|constdatablock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rsltblock
argument_list|,
name|salt
argument_list|,
name|num_iter
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Encode the 64 cipher bits as 11 ascii characters. 	 */
name|i
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|rsltblock
operator|.
name|b
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|rsltblock
operator|.
name|b
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|rsltblock
operator|.
name|b
index|[
literal|2
index|]
expr_stmt|;
name|encp
index|[
literal|3
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|2
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|1
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|0
index|]
operator|=
name|itoa64
index|[
name|i
index|]
expr_stmt|;
name|encp
operator|+=
literal|4
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|rsltblock
operator|.
name|b
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|rsltblock
operator|.
name|b
index|[
literal|4
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|rsltblock
operator|.
name|b
index|[
literal|5
index|]
expr_stmt|;
name|encp
index|[
literal|3
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|2
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|1
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|0
index|]
operator|=
name|itoa64
index|[
name|i
index|]
expr_stmt|;
name|encp
operator|+=
literal|4
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|rsltblock
operator|.
name|b
index|[
literal|6
index|]
operator|)
operator|<<
literal|8
argument_list|)
operator||
name|rsltblock
operator|.
name|b
index|[
literal|7
index|]
operator|)
operator|<<
literal|2
expr_stmt|;
name|encp
index|[
literal|2
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|1
index|]
operator|=
name|itoa64
index|[
name|i
operator|&
literal|0x3f
index|]
expr_stmt|;
name|i
operator|>>=
literal|6
expr_stmt|;
name|encp
index|[
literal|0
index|]
operator|=
name|itoa64
index|[
name|i
index|]
expr_stmt|;
name|encp
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cryptresult
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The Key Schedule, filled in by des_setkey() or setkey().  */
end_comment

begin_define
define|#
directive|define
name|KS_SIZE
value|16
end_define

begin_decl_stmt
specifier|static
name|C_block
name|KS
index|[
name|KS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up the key schedule from the key.  */
end_comment

begin_expr_stmt
name|des_setkey
argument_list|(
name|key
argument_list|)
specifier|register
specifier|const
name|char
operator|*
name|key
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|DCL_BLOCK
argument_list|(
name|K
argument_list|,
name|K0
argument_list|,
name|K1
argument_list|)
expr_stmt|;
specifier|register
name|C_block
modifier|*
name|ptabp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|des_ready
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|des_ready
condition|)
block|{
name|init_des
argument_list|()
expr_stmt|;
name|des_ready
operator|=
literal|1
expr_stmt|;
block|}
name|PERM6464
argument_list|(
name|K
argument_list|,
name|K0
argument_list|,
name|K1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
argument_list|,
operator|(
name|C_block
operator|*
operator|)
name|PC1ROT
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|KS
index|[
literal|0
index|]
expr_stmt|;
name|STORE
argument_list|(
name|K
operator|&
operator|~
literal|0x03030303L
argument_list|,
name|K0
operator|&
operator|~
literal|0x03030303L
argument_list|,
name|K1
argument_list|,
operator|*
operator|(
name|C_block
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|key
operator|+=
sizeof|sizeof
argument_list|(
name|C_block
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
name|K
argument_list|,
name|K0
argument_list|,
name|K1
argument_list|,
operator|*
operator|(
name|C_block
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
name|ptabp
operator|=
operator|(
name|C_block
operator|*
operator|)
name|PC2ROT
index|[
name|Rotates
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|PERM6464
argument_list|(
name|K
argument_list|,
name|K0
argument_list|,
name|K1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
argument_list|,
name|ptabp
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
name|K
operator|&
operator|~
literal|0x03030303L
argument_list|,
name|K0
operator|&
operator|~
literal|0x03030303L
argument_list|,
name|K1
argument_list|,
operator|*
operator|(
name|C_block
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Encrypt (or decrypt if num_iter< 0) the 8 chars at "in" with abs(num_iter)  * iterations of DES, using the the given 24-bit salt and the pre-computed key  * schedule, and store the resulting 8 chars at "out" (in == out is permitted).  *  * NOTE: the performance of this routine is critically dependent on your  * compiler and machine architecture.  */
end_comment

begin_macro
name|des_cipher
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|salt
argument_list|,
argument|num_iter
argument_list|)
end_macro

begin_decl_stmt
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|salt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_iter
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* variables that we want in registers, most important first */
if|#
directive|if
name|defined
argument_list|(
name|pdp11
argument_list|)
specifier|register
name|int
name|j
decl_stmt|;
endif|#
directive|endif
specifier|register
name|long
name|L0
decl_stmt|,
name|L1
decl_stmt|,
name|R0
decl_stmt|,
name|R1
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|C_block
modifier|*
name|kp
decl_stmt|;
specifier|register
name|int
name|ks_inc
decl_stmt|,
name|loop_count
decl_stmt|;
name|C_block
name|B
decl_stmt|;
name|L0
operator|=
name|salt
expr_stmt|;
name|TO_SIX_BIT
argument_list|(
name|salt
argument_list|,
name|L0
argument_list|)
expr_stmt|;
comment|/* convert to 4*(6+2) format */
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|pdp11
argument_list|)
name|salt
operator|=
operator|~
name|salt
expr_stmt|;
comment|/* "x&~ y" is faster than "x& y". */
define|#
directive|define
name|SALT
value|(~salt)
else|#
directive|else
define|#
directive|define
name|SALT
value|salt
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|MUST_ALIGN
argument_list|)
name|B
operator|.
name|b
index|[
literal|0
index|]
operator|=
name|in
index|[
literal|0
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|1
index|]
operator|=
name|in
index|[
literal|1
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|2
index|]
operator|=
name|in
index|[
literal|2
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|3
index|]
operator|=
name|in
index|[
literal|3
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|4
index|]
operator|=
name|in
index|[
literal|4
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|5
index|]
operator|=
name|in
index|[
literal|5
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|6
index|]
operator|=
name|in
index|[
literal|6
index|]
expr_stmt|;
name|B
operator|.
name|b
index|[
literal|7
index|]
operator|=
name|in
index|[
literal|7
index|]
expr_stmt|;
name|LOAD
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
name|B
argument_list|)
expr_stmt|;
else|#
directive|else
name|LOAD
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
operator|*
operator|(
name|C_block
operator|*
operator|)
name|in
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LOADREG
argument_list|(
name|R
argument_list|,
name|R0
argument_list|,
name|R1
argument_list|,
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|)
expr_stmt|;
name|L0
operator|&=
literal|0x55555555L
expr_stmt|;
name|L1
operator|&=
literal|0x55555555L
expr_stmt|;
name|L0
operator|=
operator|(
name|L0
operator|<<
literal|1
operator|)
operator||
name|L1
expr_stmt|;
comment|/* L0 is the even-numbered input bits */
name|R0
operator|&=
literal|0xaaaaaaaaL
expr_stmt|;
name|R1
operator|=
operator|(
name|R1
operator|>>
literal|1
operator|)
operator|&
literal|0x55555555L
expr_stmt|;
name|L1
operator|=
name|R0
operator||
name|R1
expr_stmt|;
comment|/* L1 is the odd-numbered input bits */
name|STORE
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|PERM3264
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
name|B
operator|.
name|b
argument_list|,
operator|(
name|C_block
operator|*
operator|)
name|IE3264
argument_list|)
expr_stmt|;
comment|/* even bits */
name|PERM3264
argument_list|(
name|R
argument_list|,
name|R0
argument_list|,
name|R1
argument_list|,
name|B
operator|.
name|b
operator|+
literal|4
argument_list|,
operator|(
name|C_block
operator|*
operator|)
name|IE3264
argument_list|)
expr_stmt|;
comment|/* odd bits */
if|if
condition|(
name|num_iter
operator|>=
literal|0
condition|)
block|{
comment|/* encryption */
name|kp
operator|=
operator|&
name|KS
index|[
literal|0
index|]
expr_stmt|;
name|ks_inc
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|kp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* decryption */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* always fail */
block|}
while|while
condition|(
operator|--
name|num_iter
operator|>=
literal|0
condition|)
block|{
name|loop_count
operator|=
literal|8
expr_stmt|;
do|do
block|{
define|#
directive|define
name|SPTAB
parameter_list|(
name|t
parameter_list|,
name|i
parameter_list|)
value|(*(long *)((unsigned char *)t + i*(sizeof(long)/4)))
if|#
directive|if
name|defined
argument_list|(
name|gould
argument_list|)
comment|/* use this if B.b[i] is evaluated just once ... */
define|#
directive|define
name|DOXOR
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|i
parameter_list|)
value|x^=SPTAB(SPE[0][i],B.b[i]); y^=SPTAB(SPE[1][i],B.b[i]);
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|pdp11
argument_list|)
comment|/* use this if your "long" int indexing is slow */
define|#
directive|define
name|DOXOR
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|i
parameter_list|)
value|j=B.b[i]; x^=SPTAB(SPE[0][i],j); y^=SPTAB(SPE[1][i],j);
else|#
directive|else
comment|/* use this if "k" is allocated to a register ... */
define|#
directive|define
name|DOXOR
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|i
parameter_list|)
value|k=B.b[i]; x^=SPTAB(SPE[0][i],k); y^=SPTAB(SPE[1][i],k);
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|CRUNCH
parameter_list|(
name|p0
parameter_list|,
name|p1
parameter_list|,
name|q0
parameter_list|,
name|q1
parameter_list|)
define|\
value|k = (q0 ^ q1)& SALT;	\ 			B.b32.i0 = k ^ q0 ^ kp->b32.i0;		\ 			B.b32.i1 = k ^ q1 ^ kp->b32.i1;		\ 			kp = (C_block *)((char *)kp+ks_inc);	\ 							\ 			DOXOR(p0, p1, 0);		\ 			DOXOR(p0, p1, 1);		\ 			DOXOR(p0, p1, 2);		\ 			DOXOR(p0, p1, 3);		\ 			DOXOR(p0, p1, 4);		\ 			DOXOR(p0, p1, 5);		\ 			DOXOR(p0, p1, 6);		\ 			DOXOR(p0, p1, 7);
name|CRUNCH
argument_list|(
name|L0
argument_list|,
name|L1
argument_list|,
name|R0
argument_list|,
name|R1
argument_list|)
expr_stmt|;
name|CRUNCH
argument_list|(
name|R0
argument_list|,
name|R1
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|loop_count
operator|!=
literal|0
condition|)
do|;
name|kp
operator|=
operator|(
name|C_block
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|kp
operator|-
operator|(
name|ks_inc
operator|*
name|KS_SIZE
operator|)
operator|)
expr_stmt|;
comment|/* swap L and R */
name|L0
operator|^=
name|R0
expr_stmt|;
name|L1
operator|^=
name|R1
expr_stmt|;
name|R0
operator|^=
name|L0
expr_stmt|;
name|R1
operator|^=
name|L1
expr_stmt|;
name|L0
operator|^=
name|R0
expr_stmt|;
name|L1
operator|^=
name|R1
expr_stmt|;
block|}
comment|/* store the encrypted (or decrypted) result */
name|L0
operator|=
operator|(
operator|(
name|L0
operator|>>
literal|3
operator|)
operator|&
literal|0x0f0f0f0fL
operator|)
operator||
operator|(
operator|(
name|L1
operator|<<
literal|1
operator|)
operator|&
literal|0xf0f0f0f0L
operator|)
expr_stmt|;
name|L1
operator|=
operator|(
operator|(
name|R0
operator|>>
literal|3
operator|)
operator|&
literal|0x0f0f0f0fL
operator|)
operator||
operator|(
operator|(
name|R1
operator|<<
literal|1
operator|)
operator|&
literal|0xf0f0f0f0L
operator|)
expr_stmt|;
name|STORE
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|PERM6464
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
name|B
operator|.
name|b
argument_list|,
operator|(
name|C_block
operator|*
operator|)
name|CF6464
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MUST_ALIGN
argument_list|)
name|STORE
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
name|B
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|0
index|]
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|1
index|]
expr_stmt|;
name|out
index|[
literal|2
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|2
index|]
expr_stmt|;
name|out
index|[
literal|3
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|3
index|]
expr_stmt|;
name|out
index|[
literal|4
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|4
index|]
expr_stmt|;
name|out
index|[
literal|5
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|5
index|]
expr_stmt|;
name|out
index|[
literal|6
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|6
index|]
expr_stmt|;
name|out
index|[
literal|7
index|]
operator|=
name|B
operator|.
name|b
index|[
literal|7
index|]
expr_stmt|;
else|#
directive|else
name|STORE
argument_list|(
name|L
argument_list|,
name|L0
argument_list|,
name|L1
argument_list|,
operator|*
operator|(
name|C_block
operator|*
operator|)
name|out
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Initialize various tables.  This need only be done once.  It could even be  * done at compile time, if the compiler were capable of that sort of thing.  */
end_comment

begin_function
name|STATIC
name|init_des
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|long
name|k
decl_stmt|;
specifier|register
name|int
name|tableno
decl_stmt|;
specifier|static
name|unsigned
name|char
name|perm
index|[
literal|64
index|]
decl_stmt|,
name|tmp32
index|[
literal|32
index|]
decl_stmt|;
comment|/* "static" for speed */
comment|/* 	 * table that converts chars "./0-9A-Za-z"to integers 0-63. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|a64toi
index|[
name|itoa64
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
comment|/* 	 * PC1ROT - bit reverse, then PC1, then Rotate, then PC2. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|perm
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|PC2
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|k
operator|+=
name|Rotates
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|%
literal|28
operator|)
operator|<
name|Rotates
index|[
literal|0
index|]
condition|)
name|k
operator|-=
literal|28
expr_stmt|;
name|k
operator|=
name|PC1
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator||
literal|07
operator|)
operator|-
operator|(
name|k
operator|&
literal|07
operator|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|perm
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|prtab
argument_list|(
literal|"pc1tab"
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_perm
argument_list|(
name|PC1ROT
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * PC2ROT - PC2 inverse, then Rotate (once or twice), then PC2. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|char
name|pc2inv
index|[
literal|64
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|perm
index|[
name|i
index|]
operator|=
name|pc2inv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|PC2
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pc2inv
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|PC2
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|k
operator|+=
name|j
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|%
literal|28
operator|)
operator|<=
name|j
condition|)
name|k
operator|-=
literal|28
expr_stmt|;
name|perm
index|[
name|i
index|]
operator|=
name|pc2inv
index|[
name|k
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|prtab
argument_list|(
literal|"pc2tab"
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_perm
argument_list|(
name|PC2ROT
index|[
name|j
index|]
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Bit reverse, then initial permutation, then expansion. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
operator|(
name|j
operator|<
literal|2
operator|)
condition|?
literal|0
else|:
name|IP
index|[
name|ExpandTr
index|[
name|i
operator|*
literal|6
operator|+
name|j
operator|-
literal|2
index|]
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|32
condition|)
name|k
operator|-=
literal|32
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|k
operator|--
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator||
literal|07
operator|)
operator|-
operator|(
name|k
operator|&
literal|07
operator|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|perm
index|[
name|i
operator|*
literal|8
operator|+
name|j
index|]
operator|=
name|k
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|prtab
argument_list|(
literal|"ietab"
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_perm
argument_list|(
name|IE3264
argument_list|,
name|perm
argument_list|,
literal|4
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Compression, then final permutation, then bit reverse. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
name|IP
index|[
name|CIFP
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator||
literal|07
operator|)
operator|-
operator|(
name|k
operator|&
literal|07
operator|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
name|perm
index|[
name|k
operator|-
literal|1
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|prtab
argument_list|(
literal|"cftab"
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|init_perm
argument_list|(
name|CF6464
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * SPE table 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|48
condition|;
name|i
operator|++
control|)
name|perm
index|[
name|i
index|]
operator|=
name|P32Tr
index|[
name|ExpandTr
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|tableno
operator|=
literal|0
init|;
name|tableno
operator|<
literal|8
condition|;
name|tableno
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
operator|(
operator|(
operator|(
name|j
operator|>>
literal|0
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
operator|(
name|j
operator|>>
literal|1
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
operator|(
name|j
operator|>>
literal|2
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|j
operator|>>
literal|3
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|j
operator|>>
literal|4
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
operator|(
name|j
operator|>>
literal|5
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|k
operator|=
name|S
index|[
name|tableno
index|]
index|[
name|k
index|]
expr_stmt|;
name|k
operator|=
operator|(
operator|(
operator|(
name|k
operator|>>
literal|3
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|0
operator|)
operator||
operator|(
operator|(
operator|(
name|k
operator|>>
literal|2
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|k
operator|>>
literal|1
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
operator|(
name|k
operator|>>
literal|0
operator|)
operator|&
literal|01
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|tmp32
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|tmp32
index|[
literal|4
operator|*
name|tableno
operator|+
name|i
index|]
operator|=
operator|(
name|k
operator|>>
name|i
operator|)
operator|&
literal|01
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|k
operator|=
operator|(
name|k
operator|<<
literal|1
operator|)
operator||
name|tmp32
index|[
name|perm
index|[
name|i
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|TO_SIX_BIT
argument_list|(
name|SPE
index|[
literal|0
index|]
index|[
name|tableno
index|]
index|[
name|j
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|24
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|k
operator|=
operator|(
name|k
operator|<<
literal|1
operator|)
operator||
name|tmp32
index|[
name|perm
index|[
name|i
operator|+
literal|24
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|TO_SIX_BIT
argument_list|(
name|SPE
index|[
literal|1
index|]
index|[
name|tableno
index|]
index|[
name|j
index|]
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize "perm" to represent transformation "p", which rearranges  * (perhaps with expansion and/or contraction) one packed array of bits  * (of size "chars_in" characters) into another array (of size "chars_out"  * characters).  *  * "perm" must be all-zeroes on entry to this routine.  */
end_comment

begin_function
name|STATIC
name|init_perm
parameter_list|(
name|perm
parameter_list|,
name|p
parameter_list|,
name|chars_in
parameter_list|,
name|chars_out
parameter_list|)
name|C_block
name|perm
index|[
literal|64
operator|/
name|CHUNKBITS
index|]
index|[
literal|1
operator|<<
name|CHUNKBITS
index|]
decl_stmt|;
name|unsigned
name|char
name|p
index|[
literal|64
index|]
decl_stmt|;
name|int
name|chars_in
decl_stmt|,
name|chars_out
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|chars_out
operator|*
literal|8
condition|;
name|k
operator|++
control|)
block|{
comment|/* each output bit position */
name|l
operator|=
name|p
index|[
name|k
index|]
operator|-
literal|1
expr_stmt|;
comment|/* where this bit comes from */
if|if
condition|(
name|l
operator|<
literal|0
condition|)
continue|continue;
comment|/* output bit is always 0 */
name|i
operator|=
name|l
operator|>>
name|LGCHUNKBITS
expr_stmt|;
comment|/* which chunk this bit comes from */
name|l
operator|=
literal|1
operator|<<
operator|(
name|l
operator|&
operator|(
name|CHUNKBITS
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* mask for this bit */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1
operator|<<
name|CHUNKBITS
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* each chunk value */
if|if
condition|(
operator|(
name|j
operator|&
name|l
operator|)
operator|!=
literal|0
condition|)
name|perm
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|b
index|[
name|k
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|k
operator|&
literal|07
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * "setkey" routine (for backwards compatibility)  */
end_comment

begin_expr_stmt
name|setkey
argument_list|(
name|key
argument_list|)
specifier|register
specifier|const
name|char
operator|*
name|key
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|C_block
name|keyblock
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|<<=
literal|1
expr_stmt|;
name|k
operator||=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|key
operator|++
expr_stmt|;
block|}
name|keyblock
operator|.
name|b
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
block|}
return|return
operator|(
name|des_setkey
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyblock
operator|.
name|b
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * "encrypt" routine (for backwards compatibility)  */
end_comment

begin_expr_stmt
name|encrypt
argument_list|(
name|block
argument_list|,
name|flag
argument_list|)
specifier|register
name|char
operator|*
name|block
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|C_block
name|cblock
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|<<=
literal|1
expr_stmt|;
name|k
operator||=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|block
operator|++
expr_stmt|;
block|}
name|cblock
operator|.
name|b
index|[
name|i
index|]
operator|=
name|k
expr_stmt|;
block|}
if|if
condition|(
name|des_cipher
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cblock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cblock
argument_list|,
literal|0L
argument_list|,
operator|(
name|flag
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|k
operator|=
name|cblock
operator|.
name|b
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|7
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
operator|*
operator|--
name|block
operator|=
name|k
operator|&
literal|01
expr_stmt|;
name|k
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|STATIC
name|prtab
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|num_rows
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|num_rows
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%3d"
argument_list|,
name|t
index|[
name|i
operator|*
literal|8
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

