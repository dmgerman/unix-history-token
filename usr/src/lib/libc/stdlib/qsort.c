begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)qsort.c	5.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/*  * qsort.c:  * Our own version of the system qsort routine which is faster by an average  * of 25%, with lows and highs of 10% and 50%.  * The THRESHold below is the insertion sort threshold, and has been adjusted  * for records of size 48 bytes.  * The MTHREShold is where we stop finding a better median.  */
end_comment

begin_define
define|#
directive|define
name|THRESH
value|4
end_define

begin_comment
comment|/* threshold for insertion */
end_comment

begin_define
define|#
directive|define
name|MTHRESH
value|6
end_define

begin_comment
comment|/* threshold for median */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|qcmp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* the comparison routine */
end_comment

begin_decl_stmt
specifier|static
name|int
name|qsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of each record */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thresh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* THRESHold in chars */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mthresh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MTHRESHold in chars */
end_comment

begin_comment
comment|/*  * qsort:  * First, set up some global parameters for qst to share.  Then, quicksort  * with qst(), and then a cleanup insertion sort ourselves.  Sound simple?  * It's not...  */
end_comment

begin_macro
name|qsort
argument_list|(
argument|base
argument_list|,
argument|n
argument_list|,
argument|size
argument_list|,
argument|compar
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|lo
decl_stmt|,
modifier|*
name|hi
decl_stmt|;
name|char
modifier|*
name|min
decl_stmt|,
modifier|*
name|max
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return;
name|qsz
operator|=
name|size
expr_stmt|;
name|qcmp
operator|=
name|compar
expr_stmt|;
name|thresh
operator|=
name|qsz
operator|*
name|THRESH
expr_stmt|;
name|mthresh
operator|=
name|qsz
operator|*
name|MTHRESH
expr_stmt|;
name|max
operator|=
name|base
operator|+
name|n
operator|*
name|qsz
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|THRESH
condition|)
block|{
name|qst
argument_list|(
name|base
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|hi
operator|=
name|base
operator|+
name|thresh
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|max
expr_stmt|;
block|}
comment|/* 	 * First put smallest element, which must be in the first THRESH, in 	 * the first position as a sentinel.  This is done just by searching 	 * the first THRESH elements (or the first n if n< THRESH), finding 	 * the min, and swapping it into the first position. 	 */
for|for
control|(
name|j
operator|=
name|lo
operator|=
name|base
init|;
operator|(
name|lo
operator|+=
name|qsz
operator|)
operator|<
name|hi
condition|;
control|)
if|if
condition|(
name|qcmp
argument_list|(
name|j
argument_list|,
name|lo
argument_list|)
operator|>
literal|0
condition|)
name|j
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|base
condition|)
block|{
comment|/* swap j into place */
for|for
control|(
name|i
operator|=
name|base
operator|,
name|hi
operator|=
name|base
operator|+
name|qsz
init|;
name|i
operator|<
name|hi
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|j
expr_stmt|;
operator|*
name|j
operator|++
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|i
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
comment|/* 	 * With our sentinel in place, we now run the following hyper-fast 	 * insertion sort.  For each remaining element, min, from [1] to [n-1], 	 * set hi to the index of the element AFTER which this one goes. 	 * Then, do the standard insertion sort shift on a character at a time 	 * basis for each element in the frob. 	 */
for|for
control|(
name|min
operator|=
name|base
init|;
operator|(
name|hi
operator|=
name|min
operator|+=
name|qsz
operator|)
operator|<
name|max
condition|;
control|)
block|{
while|while
condition|(
name|qcmp
argument_list|(
name|hi
operator|-=
name|qsz
argument_list|,
name|min
argument_list|)
operator|>
literal|0
condition|)
comment|/* void */
empty_stmt|;
if|if
condition|(
operator|(
name|hi
operator|+=
name|qsz
operator|)
operator|!=
name|min
condition|)
block|{
for|for
control|(
name|lo
operator|=
name|min
operator|+
name|qsz
init|;
operator|--
name|lo
operator|>=
name|min
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|lo
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
name|lo
init|;
operator|(
name|j
operator|-=
name|qsz
operator|)
operator|>=
name|hi
condition|;
name|i
operator|=
name|j
control|)
operator|*
name|i
operator|=
operator|*
name|j
expr_stmt|;
operator|*
name|i
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * qst:  * Do a quicksort  * First, find the median element, and put that one in the first place as the  * discriminator.  (This "median" is just the median of the first, last and  * middle elements).  (Using this median instead of the first element is a big  * win).  Then, the usual partitioning/swapping, followed by moving the  * discriminator into the right place.  Then, figure out the sizes of the two  * partions, do the smaller one recursively and the larger one via a repeat of  * this code.  Stopping when there are less than THRESH elements in a partition  * and cleaning up with an insertion sort (in our caller) is a huge win.  * All data swaps are done in-line, which is space-losing but time-saving.  * (And there are only three places where this is done).  */
end_comment

begin_expr_stmt
specifier|static
name|qst
argument_list|(
argument|base
argument_list|,
argument|max
argument_list|)
name|char
operator|*
name|base
operator|,
operator|*
name|max
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|i
decl_stmt|,
modifier|*
name|j
decl_stmt|,
modifier|*
name|jj
decl_stmt|;
specifier|register
name|int
name|ii
decl_stmt|;
name|char
modifier|*
name|mid
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
comment|/* 	 * At the top here, lo is the number of characters of elements in the 	 * current partition.  (Which should be max - base). 	 * Find the median of the first, last, and middle element and make 	 * that the middle element.  Set j to largest of first and middle. 	 * If max is larger than that guy, then it's that guy, else compare 	 * max with loser of first and take larger.  Things are set up to 	 * prefer the middle, then the first in case of ties. 	 */
name|lo
operator|=
name|max
operator|-
name|base
expr_stmt|;
comment|/* number of elements as chars */
do|do
block|{
name|mid
operator|=
name|i
operator|=
name|base
operator|+
name|qsz
operator|*
operator|(
operator|(
name|lo
operator|/
name|qsz
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lo
operator|>=
name|mthresh
condition|)
block|{
name|j
operator|=
operator|(
name|qcmp
argument_list|(
operator|(
name|jj
operator|=
name|base
operator|)
argument_list|,
name|i
argument_list|)
operator|>
literal|0
condition|?
name|jj
else|:
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|qcmp
argument_list|(
name|j
argument_list|,
operator|(
name|tmp
operator|=
name|max
operator|-
name|qsz
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* switch to first loser */
name|j
operator|=
operator|(
name|j
operator|==
name|jj
condition|?
name|i
else|:
name|jj
operator|)
expr_stmt|;
if|if
condition|(
name|qcmp
argument_list|(
name|j
argument_list|,
name|tmp
argument_list|)
operator|<
literal|0
condition|)
name|j
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
name|ii
operator|=
name|qsz
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|i
operator|++
operator|=
operator|*
name|j
expr_stmt|;
operator|*
name|j
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ii
condition|)
do|;
block|}
block|}
comment|/* 		 * Semi-standard quicksort partitioning/swapping 		 */
for|for
control|(
name|i
operator|=
name|base
operator|,
name|j
operator|=
name|max
operator|-
name|qsz
init|;
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|<
name|mid
operator|&&
name|qcmp
argument_list|(
name|i
argument_list|,
name|mid
argument_list|)
operator|<=
literal|0
condition|)
name|i
operator|+=
name|qsz
expr_stmt|;
while|while
condition|(
name|j
operator|>
name|mid
condition|)
block|{
if|if
condition|(
name|qcmp
argument_list|(
name|mid
argument_list|,
name|j
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|j
operator|-=
name|qsz
expr_stmt|;
continue|continue;
block|}
name|tmp
operator|=
name|i
operator|+
name|qsz
expr_stmt|;
comment|/* value of i after swap */
if|if
condition|(
name|i
operator|==
name|mid
condition|)
block|{
comment|/* j<-> mid, new mid is j */
name|mid
operator|=
name|jj
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
comment|/* i<-> j */
name|jj
operator|=
name|j
expr_stmt|;
name|j
operator|-=
name|qsz
expr_stmt|;
block|}
goto|goto
name|swap
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|mid
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/* i<-> mid, new mid is i */
name|jj
operator|=
name|mid
expr_stmt|;
name|tmp
operator|=
name|mid
operator|=
name|i
expr_stmt|;
comment|/* value of i after swap */
name|j
operator|-=
name|qsz
expr_stmt|;
block|}
name|swap
label|:
name|ii
operator|=
name|qsz
expr_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|i
expr_stmt|;
operator|*
name|i
operator|++
operator|=
operator|*
name|jj
expr_stmt|;
operator|*
name|jj
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ii
condition|)
do|;
name|i
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 		 * Look at sizes of the two partitions, do the smaller 		 * one first by recursion, then do the larger one by 		 * making sure lo is its size, base and max are update 		 * correctly, and branching back.  But only repeat 		 * (recursively or by branching) if the partition is 		 * of at least size THRESH. 		 */
name|i
operator|=
operator|(
name|j
operator|=
name|mid
operator|)
operator|+
name|qsz
expr_stmt|;
if|if
condition|(
operator|(
name|lo
operator|=
name|j
operator|-
name|base
operator|)
operator|<=
operator|(
name|hi
operator|=
name|max
operator|-
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|lo
operator|>=
name|thresh
condition|)
name|qst
argument_list|(
name|base
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|base
operator|=
name|i
expr_stmt|;
name|lo
operator|=
name|hi
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hi
operator|>=
name|thresh
condition|)
name|qst
argument_list|(
name|i
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|max
operator|=
name|j
expr_stmt|;
block|}
block|}
do|while
condition|(
name|lo
operator|>=
name|thresh
condition|)
do|;
block|}
end_block

end_unit

