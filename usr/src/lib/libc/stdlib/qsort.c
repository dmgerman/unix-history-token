begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1980, 1983, 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)qsort.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/*  * MTHRESH is the smallest partition for which we compare for a median  * value instead of using the middle value.  */
end_comment

begin_define
define|#
directive|define
name|MTHRESH
value|6
end_define

begin_comment
comment|/*  * THRESH is the minimum number of entries in a partition for continued  * partitioning.  */
end_comment

begin_define
define|#
directive|define
name|THRESH
value|4
end_define

begin_decl_stmt
name|void
name|qsort
argument_list|(
name|bot
argument_list|,
name|nmemb
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
name|char
modifier|*
name|bot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmemb
decl_stmt|,
name|size
decl_stmt|,
argument_list|(
operator|*
name|compar
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|void
name|insertion_sort
argument_list|()
decl_stmt|,
name|quick_sort
argument_list|()
decl_stmt|;
if|if
condition|(
name|nmemb
operator|<=
literal|1
condition|)
return|return;
if|if
condition|(
name|nmemb
operator|>=
name|THRESH
condition|)
name|quick_sort
argument_list|(
name|bot
argument_list|,
name|nmemb
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
expr_stmt|;
else|else
name|insertion_sort
argument_list|(
name|bot
argument_list|,
name|nmemb
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Swap two areas of size number of bytes.  Although qsort(3) permits random  * blocks of memory to be sorted, sorting pointers is almost certainly the  * common case (and, were it not, could easily be made so).  Regardless, it  * isn't worth optimizing; the SWAP's get sped up by the cache, and pointer  * arithmetic gets lost in the time required for comparison function calls.  */
end_comment

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{ \ 	cnt = size; \ 	do { \ 		ch = *a; \ 		*a++ = *b; \ 		*b++ = ch; \ 	} while (--cnt); \ }
end_define

begin_comment
comment|/*  * Knuth, Vol. 3, page 116, Algorithm Q, step b, argues that a single pass  * of straight insertion sort after partitioning is complete is better than  * sorting each small partition as it is created.  This isn't correct in this  * implementation because comparisons require at least one (and often two)  * function calls and are likely to be the dominating expense of the sort.  * Doing a final insertion sort does more comparisons than are necessary  * because it compares the "edges" and medians of the partitions which are  * known to be already sorted.  *  * This is also the reasoning behind selecting a small THRESH value (see  * Knuth, page 122, equation 26), since the quicksort algorithm does less  * comparisons than the insertion sort.  */
end_comment

begin_define
define|#
directive|define
name|SORT
parameter_list|(
name|bot
parameter_list|,
name|n
parameter_list|)
value|{ \ 	if (n> 1) \ 		if (n == 2) { \ 			t1 = bot + size; \ 			if (compar(t1, bot)< 0) \ 				SWAP(t1, bot); \ 		} else \ 			insertion_sort(bot, n, size, compar); \ }
end_define

begin_decl_stmt
specifier|static
name|void
name|quick_sort
argument_list|(
name|bot
argument_list|,
name|nmemb
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
decl|register
name|char
modifier|*
name|bot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmemb
decl_stmt|,
argument_list|(
operator|*
name|compar
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|u_char
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|top
decl_stmt|,
modifier|*
name|mid
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|char
modifier|*
name|bsv
decl_stmt|;
comment|/* bot and nmemb must already be set. */
name|partition
label|:
comment|/* find mid and top elements */
name|mid
operator|=
name|bot
operator|+
name|size
operator|*
operator|(
name|nmemb
operator|>>
literal|1
operator|)
expr_stmt|;
name|top
operator|=
name|bot
operator|+
operator|(
name|nmemb
operator|-
literal|1
operator|)
operator|*
name|size
expr_stmt|;
comment|/* 	 * Find the median of the first, last and middle element (see Knuth, 	 * Vol. 3, page 123, Eq. 28).  This test order gets the equalities 	 * right. 	 */
if|if
condition|(
name|nmemb
operator|>=
name|MTHRESH
condition|)
block|{
name|n1
operator|=
name|compar
argument_list|(
name|bot
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|n2
operator|=
name|compar
argument_list|(
name|mid
argument_list|,
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|<
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
name|t1
operator|=
name|compar
argument_list|(
name|bot
argument_list|,
name|top
argument_list|)
operator|<
literal|0
condition|?
name|top
else|:
name|bot
expr_stmt|;
elseif|else
if|if
condition|(
name|n1
operator|>
literal|0
operator|&&
name|n2
operator|<
literal|0
condition|)
name|t1
operator|=
name|compar
argument_list|(
name|bot
argument_list|,
name|top
argument_list|)
operator|>
literal|0
condition|?
name|top
else|:
name|bot
expr_stmt|;
else|else
name|t1
operator|=
name|mid
expr_stmt|;
comment|/* if mid element not selected, swap selection there */
if|if
condition|(
name|t1
operator|!=
name|mid
condition|)
block|{
name|SWAP
argument_list|(
name|t1
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|mid
operator|-=
name|size
expr_stmt|;
block|}
block|}
comment|/* Standard quicksort, Knuth, Vol. 3, page 116, Algorithm Q. */
define|#
directive|define
name|didswap
value|n1
define|#
directive|define
name|newbot
value|t1
define|#
directive|define
name|replace
value|t2
name|didswap
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bsv
operator|=
name|bot
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|bot
operator|<
name|mid
operator|&&
name|compar
argument_list|(
name|bot
argument_list|,
name|mid
argument_list|)
operator|<=
literal|0
condition|;
name|bot
operator|+=
name|size
control|)
empty_stmt|;
while|while
condition|(
name|top
operator|>
name|mid
condition|)
block|{
if|if
condition|(
name|compar
argument_list|(
name|mid
argument_list|,
name|top
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|top
operator|-=
name|size
expr_stmt|;
continue|continue;
block|}
name|newbot
operator|=
name|bot
operator|+
name|size
expr_stmt|;
comment|/* value of bot after swap */
if|if
condition|(
name|bot
operator|==
name|mid
condition|)
comment|/* top<-> mid, mid == top */
name|replace
operator|=
name|mid
operator|=
name|top
expr_stmt|;
else|else
block|{
comment|/* bot<-> top */
name|replace
operator|=
name|top
expr_stmt|;
name|top
operator|-=
name|size
expr_stmt|;
block|}
goto|goto
name|swap
goto|;
block|}
if|if
condition|(
name|bot
operator|==
name|mid
condition|)
break|break;
comment|/* bot<-> mid, mid == bot */
name|replace
operator|=
name|mid
expr_stmt|;
name|newbot
operator|=
name|mid
operator|=
name|bot
expr_stmt|;
comment|/* value of bot after swap */
name|top
operator|-=
name|size
expr_stmt|;
name|swap
label|:
name|SWAP
argument_list|(
name|bot
argument_list|,
name|replace
argument_list|)
expr_stmt|;
name|bot
operator|=
name|newbot
expr_stmt|;
name|didswap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Quicksort behaves badly in the presence of data which is already 	 * sorted (see Knuth, Vol. 3, page 119) going from O N lg N to O N^2. 	 * To avoid this worst case behavior, if a re-partitioning occurs 	 * without swapping any elements, it is not further partitioned and 	 * is insert sorted.  This wins big with almost sorted data sets and 	 * only loses if the data set is very strangely partitioned.  A fix 	 * for those data sets would be to return prematurely if the insertion 	 * sort routine is forced to make an excessive number of swaps, and 	 * continue the partitioning. 	 */
if|if
condition|(
operator|!
name|didswap
condition|)
block|{
name|insertion_sort
argument_list|(
name|bsv
argument_list|,
name|nmemb
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Re-partition or sort as necessary.  Note that the mid element 	 * itself is correctly positioned and can be ignored. 	 */
define|#
directive|define
name|nlower
value|n1
define|#
directive|define
name|nupper
value|n2
name|bot
operator|=
name|bsv
expr_stmt|;
name|nlower
operator|=
operator|(
name|mid
operator|-
name|bot
operator|)
operator|/
name|size
expr_stmt|;
comment|/* size of lower partition */
name|mid
operator|+=
name|size
expr_stmt|;
name|nupper
operator|=
name|nmemb
operator|-
name|nlower
operator|-
literal|1
expr_stmt|;
comment|/* size of upper partition */
comment|/* 	 * If must call recursively, do it on the smaller partition; this 	 * bounds the stack to lg N entries. 	 */
if|if
condition|(
name|nlower
operator|>
name|nupper
condition|)
block|{
if|if
condition|(
name|nupper
operator|>=
name|THRESH
condition|)
name|quick_sort
argument_list|(
name|mid
argument_list|,
name|nupper
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
expr_stmt|;
else|else
block|{
name|SORT
argument_list|(
name|mid
argument_list|,
name|nupper
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlower
operator|<
name|THRESH
condition|)
block|{
name|SORT
argument_list|(
name|bot
argument_list|,
name|nlower
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|nmemb
operator|=
name|nlower
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nlower
operator|>=
name|THRESH
condition|)
name|quick_sort
argument_list|(
name|bot
argument_list|,
name|nlower
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
expr_stmt|;
else|else
block|{
name|SORT
argument_list|(
name|bot
argument_list|,
name|nlower
argument_list|)
expr_stmt|;
if|if
condition|(
name|nupper
operator|<
name|THRESH
condition|)
block|{
name|SORT
argument_list|(
name|mid
argument_list|,
name|nupper
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|bot
operator|=
name|mid
expr_stmt|;
name|nmemb
operator|=
name|nupper
expr_stmt|;
block|}
goto|goto
name|partition
goto|;
comment|/* NOTREACHED */
block|}
end_block

begin_decl_stmt
specifier|static
name|void
name|insertion_sort
argument_list|(
name|bot
argument_list|,
name|nmemb
argument_list|,
name|size
argument_list|,
name|compar
argument_list|)
name|char
modifier|*
name|bot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmemb
decl_stmt|,
argument_list|(
operator|*
name|compar
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|u_char
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|top
decl_stmt|;
comment|/* 	 * A simple insertion sort (see Knuth, Vol. 3, page 81, Algorithm 	 * S).  Insertion sort has the same worst case as most simple sorts 	 * (O N^2).  It gets used here because it is (O N) in the case of 	 * sorted data. 	 */
name|top
operator|=
name|bot
operator|+
name|nmemb
operator|*
name|size
expr_stmt|;
for|for
control|(
name|t1
operator|=
name|bot
operator|+
name|size
init|;
name|t1
operator|<
name|top
condition|;
control|)
block|{
for|for
control|(
name|t2
operator|=
name|t1
init|;
operator|(
name|t2
operator|-=
name|size
operator|)
operator|>=
name|bot
operator|&&
name|compar
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|<
literal|0
condition|;
control|)
empty_stmt|;
if|if
condition|(
name|t1
operator|!=
operator|(
name|t2
operator|+=
name|size
operator|)
condition|)
block|{
comment|/* Bubble bytes up through each element. */
for|for
control|(
name|cnt
operator|=
name|size
init|;
name|cnt
operator|--
condition|;
operator|++
name|t1
control|)
block|{
name|ch
operator|=
operator|*
name|t1
expr_stmt|;
for|for
control|(
name|s1
operator|=
name|s2
operator|=
name|t1
init|;
operator|(
name|s2
operator|-=
name|size
operator|)
operator|>=
name|t2
condition|;
name|s1
operator|=
name|s2
control|)
operator|*
name|s1
operator|=
operator|*
name|s2
expr_stmt|;
operator|*
name|s1
operator|=
name|ch
expr_stmt|;
block|}
block|}
else|else
name|t1
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_block

end_unit

