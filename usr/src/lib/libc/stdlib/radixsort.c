begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Dan Bernstein at New York University.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)radixsort.c	5.11 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|shellsort
name|__P
argument_list|(
operator|(
specifier|const
name|u_char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * __rspartition is the cutoff point for a further partitioning instead  * of a shellsort.  If it changes check __rsshell_increments.  Both of  * these are exported, as the best values are data dependent.  */
end_comment

begin_define
define|#
directive|define
name|NPARTITION
value|30
end_define

begin_decl_stmt
name|int
name|__rspartition
init|=
name|NPARTITION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Stackp points to context structures, where each structure schedules a  * partitioning.  Radixsort exits when the stack is empty.  *  * If the buckets are placed on the stack randomly, the worst case is when  * all the buckets but one contain (__rspartition + 1) elements and the bucket  * pushed on the stack last contains the rest of the elements.  In this case,  * stack growth is bounded by:  *  *	limit = (nelements / (__rspartitions + 1)) - 1;  *  * This is a very large number, 102,261,125 for the maximum 32-bit signed  * integer if NPARTITION is 20.  *  * By forcing the largest bucket to be pushed on the stack first, the worst  * case is when all but two buckets each contain (__rspartition + 1) elements,  * with the remaining elements split equally between the first and last  * buckets pushed on the stack.  In this case, stack growth is bounded by  * the recurrence relation:  *  * nelements_max[1] = (NBINS-1) * (__rspartition + 1);  * nelements_max[i] = (NBINS-3) * (__rspartition + 1) + 2 * npartitions[i-1];  * which resolves to:  * nelements_max[i] = ((NBINS-2) * (2^i - 1) + 1) * (__rspartitions + 1),  *  * which yields, for a given nelements,  *  * i = ceil(log2((((nelements / (__rspartition + 1)) - 1) / (NBINS - 2)) + 1));  *  * The bound is:  *  *	limit = i * (NBINS - 1);  *  * This is a much smaller number, 4845 for the maximum 32-bit signed int.  */
end_comment

begin_define
define|#
directive|define
name|NBUCKETS
value|(UCHAR_MAX + 1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|_stack
block|{
specifier|const
name|u_char
modifier|*
modifier|*
name|bot
decl_stmt|;
name|int
name|indx
decl_stmt|,
name|nmemb
decl_stmt|;
block|}
name|CONTEXT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|STACKPUSH
value|{ \ 	stackp->bot = p; \ 	stackp->nmemb = nmemb; \ 	stackp->indx = indx; \ 	++stackp; \ }
end_define

begin_define
define|#
directive|define
name|STACKPOP
value|{ \ 	if (stackp == stack) \ 		break; \ 	--stackp; \ 	bot = stackp->bot; \ 	nmemb = stackp->nmemb; \ 	indx = stackp->indx; \ }
end_define

begin_comment
comment|/*  * A variant of MSD radix sorting; see Knuth Vol. 3, page 177, and 5.2.5,  * Ex. 10 and 12.  Also, "Three Partition Refinement Algorithms, Paige  * and Tarjan, SIAM J. Comput. Vol. 16, No. 6, December 1987.  *  * This uses a simple sort as soon as a bucket crosses a cutoff point,  * rather than sorting the entire list after partitioning is finished.  * This should be an advantage.  *  * This is pure MSD instead of LSD of some number of MSD, switching to  * the simple sort as soon as possible.  Takes linear time relative to  * the number of bytes in the strings.  */
end_comment

begin_function
name|int
name|radixsort
parameter_list|(
name|l1
parameter_list|,
name|nmemb
parameter_list|,
name|tab
parameter_list|,
name|endbyte
parameter_list|)
specifier|const
name|u_char
modifier|*
modifier|*
name|l1
decl_stmt|;
specifier|register
name|int
name|nmemb
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|tab
decl_stmt|;
name|u_int
name|endbyte
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|cpos
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
name|i
decl_stmt|,
name|indx
decl_stmt|;
specifier|register
specifier|const
name|u_char
modifier|*
modifier|*
name|bot
decl_stmt|,
modifier|*
modifier|*
name|l2
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|tr
decl_stmt|;
name|CONTEXT
modifier|*
name|stack
decl_stmt|,
modifier|*
name|stackp
decl_stmt|;
name|int
name|c
index|[
name|NBUCKETS
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|max
decl_stmt|,
modifier|*
name|recd
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|u_char
name|ltab
index|[
name|NBUCKETS
index|]
decl_stmt|;
if|if
condition|(
name|nmemb
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * T1 is the constant part of the equation, the number of elements 	 * represented on the stack between the top and bottom entries. 	 */
if|if
condition|(
name|nmemb
operator|>
name|__rspartition
condition|)
name|t1
operator|=
operator|(
name|nmemb
operator|/
operator|(
name|__rspartition
operator|+
literal|1
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|NBUCKETS
operator|-
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
else|else
name|t1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t1
condition|;
operator|++
name|i
control|)
name|t1
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|i
operator|*=
name|NBUCKETS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|stack
operator|=
name|stackp
operator|=
name|malloc
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|CONTEXT
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|stack
operator|=
name|stackp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * There are two arrays, l1 and l2.  The data is sorted into the temp 	 * stack, and then copied back.  The speedup of using the index to 	 * determine which stack the data is on and simply swapping stacks back 	 * and forth, thus avoiding the copy every iteration, turns out to not 	 * be any faster than the current implementation. 	 */
if|if
condition|(
operator|(
name|l2
operator|=
name|malloc
argument_list|(
name|nmemb
operator|*
sizeof|sizeof
argument_list|(
name|u_char
operator|*
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Tr references a table of sort weights; multiple entries may 	 * map to the same weight; EOS char must have the lowest weight. 	 */
if|if
condition|(
name|tab
condition|)
block|{
name|tr
operator|=
name|tab
expr_stmt|;
name|recd
operator|=
name|c
operator|+
name|tr
index|[
name|endbyte
index|]
expr_stmt|;
if|if
condition|(
name|recd
operator|!=
name|c
operator|&&
name|recd
operator|!=
name|c
operator|+
name|NBUCKETS
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|t1
operator|=
literal|0
operator|,
name|t2
operator|=
name|endbyte
init|;
name|t1
operator|<
name|t2
condition|;
operator|++
name|t1
control|)
name|ltab
index|[
name|t1
index|]
operator|=
name|t1
operator|+
literal|1
expr_stmt|;
name|ltab
index|[
name|t2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t1
operator|=
name|endbyte
operator|+
literal|1
init|;
name|t1
operator|<
name|NBUCKETS
condition|;
operator|++
name|t1
control|)
name|ltab
index|[
name|t1
index|]
operator|=
name|t1
expr_stmt|;
name|tr
operator|=
name|ltab
expr_stmt|;
block|}
name|last
operator|=
name|c
operator|+
name|NBUCKETS
expr_stmt|;
name|first
operator|=
name|c
expr_stmt|;
name|endbyte
operator|=
name|tr
index|[
name|endbyte
index|]
expr_stmt|;
comment|/* First sort is entire stack. */
name|bot
operator|=
name|l1
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Clear bucket count array */
name|bzero
argument_list|(
name|first
argument_list|,
sizeof|sizeof
argument_list|(
name|c
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|last
operator|-
name|first
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|recd
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Compute number of items that sort to the same bucket 		 * for this index. 		 */
name|first
operator|=
name|c
operator|+
name|NBUCKETS
operator|-
literal|1
expr_stmt|;
name|last
operator|=
name|c
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bot
operator|,
name|i
operator|=
name|nmemb
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
operator|++
operator|*
operator|(
name|cpos
operator|=
name|c
operator|+
name|tr
index|[
operator|(
operator|*
name|p
operator|++
operator|)
index|[
name|indx
index|]
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|cpos
operator|>
name|last
operator|&&
name|cpos
operator|!=
name|recd
condition|)
name|last
operator|=
name|cpos
expr_stmt|;
if|if
condition|(
name|cpos
operator|<
name|first
operator|&&
name|cpos
operator|!=
name|recd
condition|)
name|first
operator|=
name|cpos
expr_stmt|;
block|}
operator|++
name|last
expr_stmt|;
comment|/* 		 * Sum the number of characters into c, dividing the temp 		 * stack into the right number of buckets for this bucket, 		 * this index.  C contains the cumulative total of keys 		 * before and included in this bucket, and will later be used 		 * as an index to the bucket.  c[NBUCKETS] (or *last) contains 		 * the total number of elements, for determining how many 		 * elements the last bucket contains.  At the same time 		 * find the largest bucket so it gets pushed first. 		 */
name|t1
operator|=
operator|(
name|c
operator|==
name|recd
operator|)
condition|?
name|c
index|[
literal|0
index|]
else|:
literal|0
expr_stmt|;
name|t2
operator|=
name|__rspartition
expr_stmt|;
for|for
control|(
name|i
operator|=
name|last
operator|-
operator|(
name|cpos
operator|=
name|max
operator|=
name|first
operator|)
init|;
name|i
operator|--
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|cpos
operator|>
name|t2
condition|)
block|{
name|t2
operator|=
operator|*
name|cpos
expr_stmt|;
name|max
operator|=
name|cpos
expr_stmt|;
block|}
name|t1
operator|=
operator|*
name|cpos
operator|++
operator|+=
name|t1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|recd
condition|)
operator|*
name|recd
operator|+=
name|t1
expr_stmt|;
comment|/* 		 * Partition the elements into buckets; c decrements through 		 * the bucket, and ends up pointing to the first element of 		 * the bucket. 		 */
for|for
control|(
name|i
operator|=
name|nmemb
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
operator|--
name|p
expr_stmt|;
name|l2
index|[
operator|--
name|c
index|[
name|tr
index|[
operator|(
operator|*
name|p
operator|)
index|[
name|indx
index|]
index|]
index|]
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
comment|/* Copy the partitioned elements back to user stack */
name|bcopy
argument_list|(
name|l2
argument_list|,
name|bot
argument_list|,
name|nmemb
operator|*
sizeof|sizeof
argument_list|(
name|u_char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|indx
expr_stmt|;
comment|/* 		 * Sort buckets as necessary; don't sort the EOS character 		 * bucket c[endbyte] since it is already sorted.  *max is 		 * pushed first. 		 */
for|for
control|(
name|i
operator|=
name|last
operator|-
operator|(
name|cpos
operator|=
name|max
operator|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|nmemb
operator|=
operator|*
operator|(
name|cpos
operator|+
literal|1
operator|)
operator|-
operator|(
name|t1
operator|=
operator|*
name|cpos
operator|++
operator|)
operator|)
operator|<
literal|2
condition|)
continue|continue;
name|p
operator|=
name|bot
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|nmemb
operator|>
name|__rspartition
condition|)
name|STACKPUSH
else|else
name|shellsort
argument_list|(
name|p
argument_list|,
name|indx
argument_list|,
name|nmemb
argument_list|,
name|tr
argument_list|,
name|endbyte
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|max
operator|-
operator|(
name|cpos
operator|=
name|first
operator|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|nmemb
operator|=
operator|*
operator|(
name|cpos
operator|+
literal|1
operator|)
operator|-
operator|(
name|t1
operator|=
operator|*
name|cpos
operator|++
operator|)
operator|)
operator|<
literal|2
condition|)
continue|continue;
name|p
operator|=
name|bot
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|nmemb
operator|>
name|__rspartition
condition|)
name|STACKPUSH
else|else
name|shellsort
argument_list|(
name|p
argument_list|,
name|indx
argument_list|,
name|nmemb
argument_list|,
name|tr
argument_list|,
name|endbyte
argument_list|)
expr_stmt|;
block|}
comment|/* Break out when stack is empty. */
name|STACKPOP
block|}
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|l2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  */
end_comment

begin_function
specifier|static
name|void
name|shellsort
parameter_list|(
name|p
parameter_list|,
name|indx
parameter_list|,
name|nmemb
parameter_list|,
name|tr
parameter_list|,
name|recd
parameter_list|)
specifier|register
specifier|const
name|u_char
modifier|*
modifier|*
name|p
decl_stmt|,
decl|*
name|tr
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|indx
decl_stmt|,
name|nmemb
decl_stmt|,
name|recd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
specifier|const
name|u_char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|u_char
name|ch
decl_stmt|;
specifier|register
name|int
name|incr
decl_stmt|,
modifier|*
name|incrp
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|incrp
operator|=
name|__rsshell_increments
init|;
name|incr
operator|=
operator|*
name|incrp
operator|++
condition|;
control|)
for|for
control|(
name|t1
operator|=
name|incr
init|;
name|t1
operator|<
name|nmemb
condition|;
operator|++
name|t1
control|)
for|for
control|(
name|t2
operator|=
name|t1
operator|-
name|incr
init|;
name|t2
operator|>=
literal|0
condition|;
control|)
block|{
name|s1
operator|=
name|p
index|[
name|t2
index|]
operator|+
name|indx
expr_stmt|;
name|s2
operator|=
name|p
index|[
name|t2
operator|+
name|incr
index|]
operator|+
name|indx
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|tr
index|[
operator|*
name|s1
operator|++
index|]
operator|)
operator|==
name|tr
index|[
operator|*
name|s2
index|]
operator|&&
operator|(
name|ch
operator|!=
name|recd
operator|)
condition|)
operator|++
name|s2
expr_stmt|;
if|if
condition|(
name|ch
operator|>
name|tr
index|[
operator|*
name|s2
index|]
condition|)
block|{
name|s1
operator|=
name|p
index|[
name|t2
index|]
expr_stmt|;
name|p
index|[
name|t2
index|]
operator|=
name|p
index|[
name|t2
operator|+
name|incr
index|]
expr_stmt|;
name|p
index|[
name|t2
operator|+
name|incr
index|]
operator|=
name|s1
expr_stmt|;
name|t2
operator|-=
name|incr
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_block

end_unit

