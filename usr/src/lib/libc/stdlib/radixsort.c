begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)radixsort.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_define
define|#
directive|define
name|NCHARS
value|(UCHAR_MAX + 1)
end_define

begin_comment
comment|/*  * shellsort (diminishing increment sort) from Data Structures and  * Algorithms, Aho, Hopcraft and Ullman, 1983 Edition, page 290;  * see also Knuth Vol. 3, page 84.  The increments are selected from  * formula (8), page 95.  Roughly O(N^3/2).  *  * __rspartition is the cutoff point for a further partitioning instead  * of a shellsort.  If it changes check __rsshell_increments.  Both of  * these are exported, as the best values are data dependent.  Unrolling  * this loop has not proven worthwhile.  */
end_comment

begin_define
define|#
directive|define
name|NPARTITION
value|40
end_define

begin_decl_stmt
name|int
name|__rspartition
init|=
name|NPARTITION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|__rsshell_increments
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SHELLSORT
value|{ \ 	register u_char ch, *s1, *s2; \ 	register int incr, *incrp; \ 	for (incrp = __rsshell_increments; incr = *incrp++;) \ 		for (t1 = incr; t1< nmemb; ++t1) \ 			for (t2 = t1 - incr; t2>= 0;) { \ 				s1 = p[t2] + indx; \ 				s2 = p[t2 + incr] + indx; \ 				while ((ch = tr[*s1++]) == tr[*s2]&& ch) \ 					++s2; \ 				if (ch> tr[*s2]) { \ 					s1 = p[t2]; \ 					p[t2] = p[t2 + incr]; \ 					p[t2 + incr] = s1; \ 					t2 -= incr; \ 				} else \ 					break; \ 			} \ }
end_define

begin_comment
comment|/*  * stack points to context structures.  Each structure defines a  * scheduled partitioning.  Radixsort exits when the stack is empty.  *  * The stack size is data dependent, and guessing is probably not  * worthwhile.  The initial stack fits in 1K with four bytes left over  * for malloc.  The initial size is exported, as the best value is  * data, and possibly, system, dependent.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_stack
block|{
name|u_char
modifier|*
modifier|*
name|bot
decl_stmt|;
name|int
name|indx
decl_stmt|,
name|nmemb
decl_stmt|;
block|}
name|CONTEXT
typedef|;
end_typedef

begin_decl_stmt
name|int
name|__radix_stacksize
init|=
operator|(
literal|1024
operator|-
literal|4
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|CONTEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STACKPUSH
value|{ \ 	if (stackp == estack) { \ 		t1 = stackp - stack; \ 		stackp = stack; \ 		if (!(stack = (CONTEXT *)realloc((char *)stack, \ 		    (__radix_stacksize *= 2) * sizeof(CONTEXT)))) { \ 			t1 = errno; \ 			free((char *)l2); \ 			if (stackp) \ 				free((char *)stackp); \ 			errno = t1; \ 			return(-1); \ 		} \ 		stackp = stack + t1; \ 		estack = stack + __radix_stacksize; \ 	} \ 	stackp->bot = p; \ 	stackp->nmemb = nmemb; \ 	stackp->indx = indx; \ 	++stackp; \ }
end_define

begin_define
define|#
directive|define
name|STACKPOP
value|{ \ 	if (stackp == stack) \ 		break; \ 	--stackp; \ 	bot = stackp->bot; \ 	nmemb = stackp->nmemb; \ 	indx = stackp->indx; \ }
end_define

begin_comment
comment|/*  * A variant of MSD radix sorting; see Knuth Vol. 3, page 177, and 5.2.5,  * Ex. 10 and 12.  Also, "Three Partition Refinement Algorithms, Paige and  * Tarjan, SIAM J. Comput. Vol. 16, No. 6, December 1987.  *  * This uses a simple sort as soon as a bucket crosses a cutoff point, rather  * than sorting the entire list after partitioning is finished.  *  * This is pure MSD instead of LSD of some number of MSD, switching to the  * simple sort as soon as possible.  Takes linear time relative to the number  * of bytes in the strings.  */
end_comment

begin_macro
name|radixsort
argument_list|(
argument|l1
argument_list|,
argument|nmemb
argument_list|,
argument|tab
argument_list|,
argument|endbyte
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
modifier|*
name|l1
decl_stmt|,
modifier|*
name|tab
decl_stmt|,
name|endbyte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|nmemb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|indx
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|u_char
modifier|*
modifier|*
name|l2
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|bot
decl_stmt|,
modifier|*
name|tr
decl_stmt|;
name|CONTEXT
modifier|*
name|estack
decl_stmt|,
modifier|*
name|stack
decl_stmt|,
modifier|*
name|stackp
decl_stmt|;
name|int
name|c
index|[
name|NCHARS
operator|+
literal|1
index|]
decl_stmt|;
name|u_char
name|ltab
index|[
name|NCHARS
index|]
decl_stmt|;
if|if
condition|(
name|nmemb
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * there are two arrays, one provided by the user (l1), and the 	 * temporary one (l2).  The data is sorted to the temporary stack, 	 * and then copied back.  The speedup of using index to determine 	 * which stack the data is on and simply swapping stacks back and 	 * forth, thus avoiding the copy every iteration, turns out to not 	 * be any faster than the current implementation. 	 */
if|if
condition|(
operator|!
operator|(
name|l2
operator|=
operator|(
name|u_char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u_char
operator|*
argument_list|)
operator|*
name|nmemb
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* initialize stack */
name|stack
operator|=
name|stackp
operator|=
name|estack
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * tr references a table of sort weights; multiple entries may 	 * map to the same weight; EOS char must have the lowest weight. 	 */
if|if
condition|(
name|tab
condition|)
name|tr
operator|=
name|tab
expr_stmt|;
else|else
block|{
name|tr
operator|=
name|ltab
expr_stmt|;
for|for
control|(
name|t1
operator|=
literal|0
operator|,
name|t2
operator|=
name|endbyte
init|;
name|t1
operator|<
name|t2
condition|;
operator|++
name|t1
control|)
name|tr
index|[
name|t1
index|]
operator|=
name|t1
operator|+
literal|1
expr_stmt|;
name|tr
index|[
name|t2
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t1
operator|=
name|endbyte
operator|+
literal|1
init|;
name|t1
operator|<
name|NCHARS
condition|;
operator|++
name|t1
control|)
name|tr
index|[
name|t1
index|]
operator|=
name|t1
expr_stmt|;
block|}
comment|/* first sort is entire stack */
name|bot
operator|=
name|l1
expr_stmt|;
name|indx
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* clear bucket count array */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * compute number of items that sort to the same bucket 		 * for this index. 		 */
for|for
control|(
name|p
operator|=
name|bot
operator|,
name|i
operator|=
name|nmemb
init|;
name|i
operator|--
condition|;
control|)
operator|++
name|c
index|[
name|tr
index|[
operator|(
operator|*
name|p
operator|++
operator|)
index|[
name|indx
index|]
index|]
index|]
expr_stmt|;
comment|/* 		 * sum the number of characters into c, dividing the temp 		 * stack into the right number of buckets for this bucket, 		 * this index.  C contains the cumulative total of keys 		 * before and included in this bucket, and will later be 		 * used as an index to the bucket.  c[NCHARS] contains 		 * the total number of elements, for determining how many 		 * elements the last bucket contains. 		 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|NCHARS
condition|;
operator|++
name|i
control|)
name|c
index|[
name|i
index|]
operator|+=
name|c
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 		 * partition the elements into buckets; c decrements 		 * through the bucket, and ends up pointing to the 		 * first element of the bucket. 		 */
for|for
control|(
name|i
operator|=
name|nmemb
init|;
name|i
operator|--
condition|;
control|)
block|{
operator|--
name|p
expr_stmt|;
name|l2
index|[
operator|--
name|c
index|[
name|tr
index|[
operator|(
operator|*
name|p
operator|)
index|[
name|indx
index|]
index|]
index|]
index|]
operator|=
operator|*
name|p
expr_stmt|;
block|}
comment|/* copy the partitioned elements back to user stack */
name|bcopy
argument_list|(
name|l2
argument_list|,
name|bot
argument_list|,
name|nmemb
operator|*
sizeof|sizeof
argument_list|(
name|u_char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|indx
expr_stmt|;
comment|/* 		 * sort buckets as necessary; don't sort c[0], it's the 		 * EOS character bucket, and nothing can follow EOS. 		 */
for|for
control|(
name|i
operator|=
name|NCHARS
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|nmemb
operator|=
name|c
index|[
name|i
operator|+
literal|1
index|]
operator|-
operator|(
name|t1
operator|=
name|c
index|[
name|i
index|]
operator|)
operator|)
operator|<
literal|2
condition|)
continue|continue;
name|p
operator|=
name|bot
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|nmemb
operator|>
name|__rspartition
condition|)
name|STACKPUSH
else|else
name|SHELLSORT
block|}
comment|/* break out when stack is empty */
name|STACKPOP
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|l2
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|stack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max stack %u.\n"
argument_list|,
name|__radix_stacksize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

