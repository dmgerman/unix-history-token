begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)muldi3.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|"quad.h"
end_include

begin_comment
comment|/*  * Multiply two quads.  *  * Our algorithm is based on the following.  Split incoming quad values  * u and v (where u,v>= 0) into  *  *	u = 2^n u1  *  u0	(n = number of bits in `u_long', usu. 32)  *  * and   *  *	v = 2^n v1  *  v0  *  * Then  *  *	uv = 2^2n u1 v1  +  2^n u1 v0  +  2^n v1 u0  +  u0 v0  *	   = 2^2n u1 v1  +     2^n (u1 v0 + v1 u0)   +  u0 v0  *  * Now add 2^n u1 v1 to the first term and subtract it from the middle,  * and add 2^n u0 v0 to the last term and subtract it from the middle.  * This gives:  *  *	uv = (2^2n + 2^n) (u1 v1)  +  *	         (2^n)    (u1 v0 - u1 v1 + u0 v1 - u0 v0)  +  *	       (2^n + 1)  (u0 v0)  *  * Factoring the middle a bit gives us:  *  *	uv = (2^2n + 2^n) (u1 v1)  +			[u1v1 = high]  *		 (2^n)    (u1 - u0) (v0 - v1)  +	[(u1-u0)... = mid]  *	       (2^n + 1)  (u0 v0)			[u0v0 = low]  *  * The terms (u1 v1), (u1 - u0) (v0 - v1), and (u0 v0) can all be done  * in just half the precision of the original.  (Note that either or both  * of (u1 - u0) or (v0 - v1) may be negative.)  *  * This algorithm is from Knuth vol. 2 (2nd ed), section 4.3.3, p. 278.  *  * Since C does not give us a `long * long = quad' operator, we split  * our input quads into two longs, then split the two longs into two  * shorts.  We can then calculate `short * short = long' in native  * arithmetic.  *  * Our product should, strictly speaking, be a `long quad', with 128  * bits, but we are going to discard the upper 64.  In other words,  * we are not interested in uv, but rather in (uv mod 2^2n).  This  * makes some of the terms above vanish, and we get:  *  *	(2^n)(high) + (2^n)(mid) + (2^n + 1)(low)  *  * or  *  *	(2^n)(high + mid + low) + low  *  * Furthermore, `high' and `mid' can be computed mod 2^n, as any factor  * of 2^n in either one will also vanish.  Only `low' need be computed  * mod 2^2n, and only because of the final term above.  */
end_comment

begin_function_decl
specifier|static
name|quad_t
name|__lmulq
parameter_list|(
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|quad_t
name|__muldi3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|quad_t
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|union
name|uu
name|u
decl_stmt|,
name|v
decl_stmt|,
name|low
decl_stmt|,
name|prod
decl_stmt|;
specifier|register
name|u_long
name|high
decl_stmt|,
name|mid
decl_stmt|,
name|udiff
decl_stmt|,
name|vdiff
decl_stmt|;
specifier|register
name|int
name|negall
decl_stmt|,
name|negmid
decl_stmt|;
define|#
directive|define
name|u1
value|u.ul[H]
define|#
directive|define
name|u0
value|u.ul[L]
define|#
directive|define
name|v1
value|v.ul[H]
define|#
directive|define
name|v0
value|v.ul[L]
comment|/* 	 * Get u and v such that u, v>= 0.  When this is finished, 	 * u1, u0, v1, and v0 will be directly accessible through the 	 * longword fields. 	 */
if|if
condition|(
name|a
operator|>=
literal|0
condition|)
name|u
operator|.
name|q
operator|=
name|a
operator|,
name|negall
operator|=
literal|0
expr_stmt|;
else|else
name|u
operator|.
name|q
operator|=
operator|-
name|a
operator|,
name|negall
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|0
condition|)
name|v
operator|.
name|q
operator|=
name|b
expr_stmt|;
else|else
name|v
operator|.
name|q
operator|=
operator|-
name|b
operator|,
name|negall
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|u1
operator|==
literal|0
operator|&&
name|v1
operator|==
literal|0
condition|)
block|{
comment|/* 		 * An (I hope) important optimization occurs when u1 and v1 		 * are both 0.  This should be common since most numbers 		 * are small.  Here the product is just u0*v0. 		 */
name|prod
operator|.
name|q
operator|=
name|__lmulq
argument_list|(
name|u0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Compute the three intermediate products, remembering 		 * whether the middle term is negative.  We can discard 		 * any upper bits in high and mid, so we can use native 		 * u_long * u_long => u_long arithmetic. 		 */
name|low
operator|.
name|q
operator|=
name|__lmulq
argument_list|(
name|u0
argument_list|,
name|v0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u1
operator|>=
name|u0
condition|)
name|negmid
operator|=
literal|0
operator|,
name|udiff
operator|=
name|u1
operator|-
name|u0
expr_stmt|;
else|else
name|negmid
operator|=
literal|1
operator|,
name|udiff
operator|=
name|u0
operator|-
name|u1
expr_stmt|;
if|if
condition|(
name|v0
operator|>=
name|v1
condition|)
name|vdiff
operator|=
name|v0
operator|-
name|v1
expr_stmt|;
else|else
name|vdiff
operator|=
name|v1
operator|-
name|v0
operator|,
name|negmid
operator|^=
literal|1
expr_stmt|;
name|mid
operator|=
name|udiff
operator|*
name|vdiff
expr_stmt|;
name|high
operator|=
name|u1
operator|*
name|v1
expr_stmt|;
comment|/* 		 * Assemble the final product. 		 */
name|prod
operator|.
name|ul
index|[
name|H
index|]
operator|=
name|high
operator|+
operator|(
name|negmid
condition|?
operator|-
name|mid
else|:
name|mid
operator|)
operator|+
name|low
operator|.
name|ul
index|[
name|L
index|]
operator|+
name|low
operator|.
name|ul
index|[
name|H
index|]
expr_stmt|;
name|prod
operator|.
name|ul
index|[
name|L
index|]
operator|=
name|low
operator|.
name|ul
index|[
name|L
index|]
expr_stmt|;
block|}
return|return
operator|(
name|negall
condition|?
operator|-
name|prod
operator|.
name|q
else|:
name|prod
operator|.
name|q
operator|)
return|;
undef|#
directive|undef
name|u1
undef|#
directive|undef
name|u0
undef|#
directive|undef
name|v1
undef|#
directive|undef
name|v0
block|}
end_function

begin_comment
comment|/*  * Multiply two 2N-bit longs to produce a 4N-bit quad, where N is half  * the number of bits in a long (whatever that is---the code below  * does not care as long as quad.h does its part of the bargain---but  * typically N==16).  *  * We use the same algorithm from Knuth, but this time the modulo refinement  * does not apply.  On the other hand, since N is half the size of a long,  * we can get away with native multiplication---none of our input terms  * exceeds (ULONG_MAX>> 1).  *  * Note that, for u_long l, the quad-precision result  *  *	l<< N  *  * splits into high and low longs as HHALF(l) and LHUP(l) respectively.  */
end_comment

begin_function
specifier|static
name|quad_t
name|__lmulq
parameter_list|(
name|u_long
name|u
parameter_list|,
name|u_long
name|v
parameter_list|)
block|{
name|u_long
name|u1
decl_stmt|,
name|u0
decl_stmt|,
name|v1
decl_stmt|,
name|v0
decl_stmt|,
name|udiff
decl_stmt|,
name|vdiff
decl_stmt|,
name|high
decl_stmt|,
name|mid
decl_stmt|,
name|low
decl_stmt|;
name|u_long
name|prodh
decl_stmt|,
name|prodl
decl_stmt|,
name|was
decl_stmt|;
name|union
name|uu
name|prod
decl_stmt|;
name|int
name|neg
decl_stmt|;
name|u1
operator|=
name|HHALF
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|u0
operator|=
name|LHALF
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|v1
operator|=
name|HHALF
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|v0
operator|=
name|LHALF
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|low
operator|=
name|u0
operator|*
name|v0
expr_stmt|;
comment|/* This is the same small-number optimization as before. */
if|if
condition|(
name|u1
operator|==
literal|0
operator|&&
name|v1
operator|==
literal|0
condition|)
return|return
operator|(
name|low
operator|)
return|;
if|if
condition|(
name|u1
operator|>=
name|u0
condition|)
name|udiff
operator|=
name|u1
operator|-
name|u0
operator|,
name|neg
operator|=
literal|0
expr_stmt|;
else|else
name|udiff
operator|=
name|u0
operator|-
name|u1
operator|,
name|neg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|v0
operator|>=
name|v1
condition|)
name|vdiff
operator|=
name|v0
operator|-
name|v1
expr_stmt|;
else|else
name|vdiff
operator|=
name|v1
operator|-
name|v0
operator|,
name|neg
operator|^=
literal|1
expr_stmt|;
name|mid
operator|=
name|udiff
operator|*
name|vdiff
expr_stmt|;
name|high
operator|=
name|u1
operator|*
name|v1
expr_stmt|;
comment|/* prod = (high<< 2N) + (high<< N); */
name|prodh
operator|=
name|high
operator|+
name|HHALF
argument_list|(
name|high
argument_list|)
expr_stmt|;
name|prodl
operator|=
name|LHUP
argument_list|(
name|high
argument_list|)
expr_stmt|;
comment|/* if (neg) prod -= mid<< N; else prod += mid<< N; */
if|if
condition|(
name|neg
condition|)
block|{
name|was
operator|=
name|prodl
expr_stmt|;
name|prodl
operator|-=
name|LHUP
argument_list|(
name|mid
argument_list|)
expr_stmt|;
name|prodh
operator|-=
name|HHALF
argument_list|(
name|mid
argument_list|)
operator|+
operator|(
name|prodl
operator|>
name|was
operator|)
expr_stmt|;
block|}
else|else
block|{
name|was
operator|=
name|prodl
expr_stmt|;
name|prodl
operator|+=
name|LHUP
argument_list|(
name|mid
argument_list|)
expr_stmt|;
name|prodh
operator|+=
name|HHALF
argument_list|(
name|mid
argument_list|)
operator|+
operator|(
name|prodl
operator|<
name|was
operator|)
expr_stmt|;
block|}
comment|/* prod += low<< N */
name|was
operator|=
name|prodl
expr_stmt|;
name|prodl
operator|+=
name|LHUP
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|prodh
operator|+=
name|HHALF
argument_list|(
name|low
argument_list|)
operator|+
operator|(
name|prodl
operator|<
name|was
operator|)
expr_stmt|;
comment|/* ... + low; */
if|if
condition|(
operator|(
name|prodl
operator|+=
name|low
operator|)
operator|<
name|low
condition|)
name|prodh
operator|++
expr_stmt|;
comment|/* return 4N-bit product */
name|prod
operator|.
name|ul
index|[
name|H
index|]
operator|=
name|prodh
expr_stmt|;
name|prod
operator|.
name|ul
index|[
name|L
index|]
operator|=
name|prodl
expr_stmt|;
return|return
operator|(
name|prod
operator|.
name|q
operator|)
return|;
block|}
end_function

end_unit

