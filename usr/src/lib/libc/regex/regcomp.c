begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Henry Spencer.  * Copyright (c) 1992 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Henry Spencer of the University of Toronto.  *  * %sccs.include.redist.c%  *  *	@(#)regcomp.c	5.3 (Berkeley) %G%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)regcomp.c	5.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"regex2.h"
end_include

begin_include
include|#
directive|include
file|"cclass.h"
end_include

begin_include
include|#
directive|include
file|"cname.h"
end_include

begin_comment
comment|/*  * parse structure, passed up and down to avoid global variables and  * other clumsinesses  */
end_comment

begin_struct
struct|struct
name|parse
block|{
name|uchar
modifier|*
name|next
decl_stmt|;
comment|/* next character in RE */
name|int
name|error
decl_stmt|;
comment|/* has an error been seen? */
name|sop
modifier|*
name|strip
decl_stmt|;
comment|/* malloced strip */
name|sopno
name|ssize
decl_stmt|;
comment|/* malloced strip size (allocated) */
name|sopno
name|slen
decl_stmt|;
comment|/* malloced strip length (used) */
name|int
name|ncsalloc
decl_stmt|;
comment|/* number of csets allocated */
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
define|#
directive|define
name|NPAREN
value|10
comment|/* we need to remember () 1-9 for back refs */
name|sopno
name|pbegin
index|[
name|NPAREN
index|]
decl_stmt|;
comment|/* -> ( ([0] unused) */
name|sopno
name|pend
index|[
name|NPAREN
index|]
decl_stmt|;
comment|/* -> ) ([0] unused) */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|uchar
name|nuls
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to point scanner in event of error */
end_comment

begin_comment
comment|/*  * macros for use with parse structure  * BEWARE:  these know that the parse structure is named `p' !!!  */
end_comment

begin_define
define|#
directive|define
name|PEEK
parameter_list|()
value|((uchar)*p->next)
end_define

begin_define
define|#
directive|define
name|PEEK2
parameter_list|()
value|((uchar)*(p->next+1))
end_define

begin_define
define|#
directive|define
name|SEE
parameter_list|(
name|c
parameter_list|)
value|(PEEK() == (c))
end_define

begin_define
define|#
directive|define
name|SEETWO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(PEEK() == (a)&& PEEK2() == (b))
end_define

begin_define
define|#
directive|define
name|EAT
parameter_list|(
name|c
parameter_list|)
value|((SEE(c)) ? (NEXT(), 1) : 0)
end_define

begin_define
define|#
directive|define
name|EATTWO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
end_define

begin_define
define|#
directive|define
name|NEXT
parameter_list|()
value|(p->next++)
end_define

begin_define
define|#
directive|define
name|NEXT2
parameter_list|()
value|(p->next += 2)
end_define

begin_define
define|#
directive|define
name|NEXTn
parameter_list|(
name|n
parameter_list|)
value|(p->next += (n))
end_define

begin_define
define|#
directive|define
name|GETNEXT
parameter_list|()
value|((uchar)*p->next++)
end_define

begin_define
define|#
directive|define
name|SETERROR
parameter_list|(
name|e
parameter_list|)
value|seterr(p, (e))
end_define

begin_define
define|#
directive|define
name|REQUIRE
parameter_list|(
name|co
parameter_list|,
name|e
parameter_list|)
value|((co) || SETERROR(e))
end_define

begin_define
define|#
directive|define
name|MUSTSEE
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(PEEK() == (c), e))
end_define

begin_define
define|#
directive|define
name|MUSTEAT
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(GETNEXT() == (c), e))
end_define

begin_define
define|#
directive|define
name|MUSTNOTSEE
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(PEEK() != (c), e))
end_define

begin_define
define|#
directive|define
name|EMIT
parameter_list|(
name|sop
parameter_list|,
name|sopnd
parameter_list|)
value|doemit(p, sop, (size_t)(sopnd))
end_define

begin_define
define|#
directive|define
name|INSERT
parameter_list|(
name|sop
parameter_list|,
name|pos
parameter_list|)
value|doinsert(p, sop, HERE()-(pos)+1, pos)
end_define

begin_define
define|#
directive|define
name|FWD
parameter_list|(
name|pos
parameter_list|)
value|dofwd(p, pos, HERE()-(pos))
end_define

begin_define
define|#
directive|define
name|BACK
parameter_list|(
name|sop
parameter_list|,
name|pos
parameter_list|)
value|EMIT(sop, HERE()-pos)
end_define

begin_define
define|#
directive|define
name|HERE
parameter_list|()
value|(p->slen)
end_define

begin_define
define|#
directive|define
name|THERE
parameter_list|()
value|(p->slen - 1)
end_define

begin_define
define|#
directive|define
name|DROP
parameter_list|(
name|n
parameter_list|)
value|(p->slen -= (n))
end_define

begin_decl_stmt
specifier|static
name|cset
modifier|*
name|allocset
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bothcases
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|categorize
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
expr|struct
name|re_guts
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doemit
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|sop
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dofwd
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|sopno
operator|,
name|sop
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doinsert
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|sop
operator|,
name|size_t
operator|,
name|sopno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sopno
name|dupl
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|sopno
operator|,
name|sopno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enlarge
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|sopno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|findmust
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
expr|struct
name|re_guts
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|freezeset
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isinsets
name|__P
argument_list|(
operator|(
expr|struct
name|re_guts
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcadd
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|,
name|uchar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uchar
modifier|*
name|mcfind
name|__P
argument_list|(
operator|(
name|cset
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mcin
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcinvert
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mcsub
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|,
name|u_int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nonnewline
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ordinary
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uchar
name|othercase
name|__P
argument_list|(
operator|(
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_b_cclass
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uchar
name|p_b_coll_elem
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_b_eclass
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uchar
name|p_b_symbol
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_b_term
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|cset
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_bracket
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_bre
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|u_int
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p_count
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_ere
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|p_ere_exp
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|p_simp_re
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sopno
name|pluscount
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
expr|struct
name|re_guts
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|repeat
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|sopno
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|samesets
name|__P
argument_list|(
operator|(
expr|struct
name|re_guts
operator|*
operator|,
name|u_int
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|seterr
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stripsnug
name|__P
argument_list|(
operator|(
expr|struct
name|parse
operator|*
operator|,
expr|struct
name|re_guts
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  - regcomp - interface for parser and compilation  */
end_comment

begin_function
name|int
comment|/* 0 success, otherwise REG_something */
name|regcomp
parameter_list|(
name|preg
parameter_list|,
name|pattern
parameter_list|,
name|cflags
parameter_list|)
name|regex_t
modifier|*
name|preg
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|cflags
decl_stmt|;
block|{
name|struct
name|parse
name|pa
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
specifier|register
name|struct
name|parse
modifier|*
name|p
init|=
operator|&
name|pa
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* do the mallocs early so failure handling is easy */
comment|/* the +NUC here is for the category table */
name|g
operator|=
operator|(
expr|struct
name|re_guts
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_guts
argument_list|)
operator|+
name|NUC
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
name|p
operator|->
name|ssize
operator|=
name|strlen
argument_list|(
name|pattern
argument_list|)
operator|/
literal|2
operator|*
literal|3
operator|+
literal|1
expr_stmt|;
name|p
operator|->
name|strip
operator|=
operator|(
name|sop
operator|*
operator|)
name|malloc
argument_list|(
name|p
operator|->
name|ssize
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|slen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|strip
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|g
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
block|}
comment|/* set things up */
name|p
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|uchar
operator|*
operator|)
name|pattern
expr_stmt|;
name|p
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ncsalloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPAREN
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|g
operator|->
name|csetsize
operator|=
name|NUC
expr_stmt|;
name|g
operator|->
name|sets
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|setbits
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|ncsets
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|cflags
operator|=
name|cflags
expr_stmt|;
name|g
operator|->
name|iflags
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|must
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|nsub
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|ncategories
operator|=
literal|1
expr_stmt|;
comment|/* category 0 is "everything else" */
name|g
operator|->
name|categories
operator|=
operator|(
name|uchar
operator|*
operator|)
name|g
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|re_guts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|g
operator|->
name|categories
argument_list|,
literal|0
argument_list|,
name|NUC
argument_list|)
expr_stmt|;
name|g
operator|->
name|backrefs
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|nplus
operator|=
literal|0
expr_stmt|;
comment|/* do it */
name|EMIT
argument_list|(
name|OEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|firststate
operator|=
name|THERE
argument_list|()
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|REG_EXTENDED
condition|)
name|p_ere
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
else|else
name|p_bre
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|laststate
operator|=
name|THERE
argument_list|()
expr_stmt|;
comment|/* tidy up loose ends and fill things in */
name|categorize
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|stripsnug
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|findmust
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|nplus
operator|=
name|pluscount
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|magic
operator|=
name|MAGIC2
expr_stmt|;
name|preg
operator|->
name|re_nsub
operator|=
name|g
operator|->
name|nsub
expr_stmt|;
name|preg
operator|->
name|re_g
operator|=
name|g
expr_stmt|;
name|preg
operator|->
name|re_magic
operator|=
name|MAGIC1
expr_stmt|;
ifndef|#
directive|ifndef
name|REDEBUG
comment|/* not debugging, so can't rely on the assert() in regexec() */
if|if
condition|(
name|g
operator|->
name|iflags
operator|&
name|BAD
condition|)
name|SETERROR
argument_list|(
name|REG_ASSERT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* win or lose, we're done */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* lose */
name|regfree
argument_list|(
name|preg
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_ere - ERE parser top level, concatenation and alternation  */
end_comment

begin_function
specifier|static
name|void
name|p_ere
parameter_list|(
name|p
parameter_list|,
name|stop
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|u_int
name|stop
decl_stmt|;
comment|/* character this ERE should end at */
block|{
specifier|register
name|uchar
name|c
decl_stmt|;
specifier|register
name|sopno
name|prevback
decl_stmt|;
specifier|register
name|sopno
name|prevfwd
decl_stmt|;
specifier|register
name|sopno
name|conc
decl_stmt|;
specifier|register
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* is this the first alternative? */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* do a bunch of concatenated expressions */
name|conc
operator|=
name|HERE
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|PEEK
argument_list|()
operator|)
operator|!=
literal|'|'
operator|&&
name|c
operator|!=
name|stop
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|p_ere_exp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|HERE
argument_list|()
operator|!=
name|conc
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
comment|/* require nonempty */
if|if
condition|(
operator|!
name|EAT
argument_list|(
literal|'|'
argument_list|)
condition|)
break|break;
comment|/* NOTE BREAK OUT */
if|if
condition|(
name|first
condition|)
block|{
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|conc
argument_list|)
expr_stmt|;
comment|/* offset is wrong */
name|prevfwd
operator|=
name|conc
expr_stmt|;
name|prevback
operator|=
name|conc
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|BACK
argument_list|(
name|OOR1
argument_list|,
name|prevback
argument_list|)
expr_stmt|;
name|prevback
operator|=
name|THERE
argument_list|()
expr_stmt|;
name|FWD
argument_list|(
name|prevfwd
argument_list|)
expr_stmt|;
comment|/* fix previous offset */
name|prevfwd
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset is very wrong */
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|/* tail-end fixups */
name|FWD
argument_list|(
name|prevfwd
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_CH
argument_list|,
name|prevback
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|SEE
argument_list|(
name|stop
argument_list|)
operator|||
name|SEE
argument_list|(
literal|'\0'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op  */
end_comment

begin_function
specifier|static
name|void
name|p_ere_exp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|uchar
name|c
decl_stmt|;
specifier|register
name|sopno
name|pos
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|count2
decl_stmt|;
specifier|register
name|sopno
name|subno
decl_stmt|;
name|int
name|wascaret
init|=
literal|0
decl_stmt|;
comment|/* we call { a repetition if followed by a digit */
define|#
directive|define
name|ISRPT
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
value|(c1 == '*' || c1 == '+' || c1 == '?' || \ 						(c1 == '{'&& isdigit(c2)))
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|c
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* caller should have ensured this */
name|pos
operator|=
name|HERE
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
name|MUSTNOTSEE
argument_list|(
literal|'\0'
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nsub
operator|++
expr_stmt|;
name|subno
operator|=
name|p
operator|->
name|g
operator|->
name|nsub
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
name|p
operator|->
name|pbegin
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OLPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SEE
argument_list|(
literal|')'
argument_list|)
condition|)
name|p_ere
argument_list|(
name|p
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT
argument_list|(
name|ORPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
name|MUSTEAT
argument_list|(
literal|')'
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|POSIX_MISTAKE
case|case
literal|')'
case|:
comment|/* happens only if no current unmatched ( */
comment|/* 		 * You may ask, why the ifndef?  Because I didn't notice 		 * this until slightly too late for 1003.2, and none of the 		 * other 1003.2 regular-expression reviewers noticed it at 		 * all.  So an unmatched ) is legal POSIX, at least until 		 * we can get it fixed. 		 */
name|SETERROR
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'^'
case|:
name|EMIT
argument_list|(
name|OBOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEBOL
expr_stmt|;
name|wascaret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|EMIT
argument_list|(
name|OEOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEEOL
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|SETERROR
argument_list|(
name|REG_EMPTY
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|nonnewline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|EMIT
argument_list|(
name|OANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|xxx
if|if
condition|(
name|c
operator|==
literal|'^'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'|'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'\\'
condition|)
else|#
directive|else
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
endif|#
directive|endif
name|ordinary
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|SETERROR
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* okay as ordinary except if digit follows */
name|REQUIRE
argument_list|(
operator|!
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ordinary
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ISRPT
argument_list|(
name|c
argument_list|,
name|PEEK2
argument_list|()
argument_list|)
condition|)
return|return;
comment|/* no repetition, we're done */
name|NEXT
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|wascaret
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* implemented as +? */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|count
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|','
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
condition|)
block|{
name|count2
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|count
operator|<=
name|count2
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single number with comma */
name|count2
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* just a single number */
name|count2
operator|=
name|count
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EAT
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
comment|/* error heuristics */
while|while
condition|(
operator|(
name|c
operator|=
name|PEEK
argument_list|()
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|'}'
condition|)
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|SETERROR
argument_list|(
name|REG_EBRACE
argument_list|)
expr_stmt|;
else|else
name|SETERROR
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISRPT
argument_list|(
name|c
argument_list|,
name|PEEK2
argument_list|()
argument_list|)
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_bre - BRE parser top level, anchoring and concatenation  * Giving end1 as '\0' essentially eliminates the end1/end2 check.  *  * This implementation is a bit of a kludge, in that a trailing $ is first  * taken as an ordinary character and then revised to be an anchor.  The  * only undesirable side effect is that '$' gets included as a character  * category in such cases.  This is fairly harmless; not worth fixing.  * The amount of lookahead needed to avoid this kludge is excessive,  * especially since things like "$*" appear to be legal. xxx  */
end_comment

begin_function
specifier|static
name|void
name|p_bre
parameter_list|(
name|p
parameter_list|,
name|end1
parameter_list|,
name|end2
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|u_int
name|end1
decl_stmt|;
comment|/* first terminating character */
specifier|register
name|u_int
name|end2
decl_stmt|;
comment|/* second terminating character */
block|{
specifier|register
name|sopno
name|start
init|=
name|HERE
argument_list|()
decl_stmt|;
specifier|register
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* first subexpression? */
specifier|register
name|int
name|wasdollar
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'^'
argument_list|)
condition|)
block|{
name|EMIT
argument_list|(
name|OBOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEBOL
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|SEE
argument_list|(
literal|'\0'
argument_list|)
operator|&&
operator|!
name|SEETWO
argument_list|(
name|end1
argument_list|,
name|end2
argument_list|)
condition|)
block|{
name|wasdollar
operator|=
name|p_simp_re
argument_list|(
name|p
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wasdollar
condition|)
block|{
comment|/* oops, that was a trailing anchor */
name|DROP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OEOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEEOL
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|HERE
argument_list|()
operator|!=
name|start
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
comment|/* require nonempty */
block|}
end_function

begin_comment
comment|/*  - p_simp_re - parse a simple RE, an atom possibly followed by a repetition  */
end_comment

begin_function
specifier|static
name|int
comment|/* was the simple RE an unbackslashed $? */
name|p_simp_re
parameter_list|(
name|p
parameter_list|,
name|starordinary
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|starordinary
decl_stmt|;
comment|/* is a leading * an ordinary character? */
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|count2
decl_stmt|;
specifier|register
name|sopno
name|pos
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|sopno
name|subno
decl_stmt|;
define|#
directive|define
name|BACKSL
value|(1<<CHAR_BIT)
name|pos
operator|=
name|HERE
argument_list|()
expr_stmt|;
comment|/* repetion op, if any, covers from here */
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|c
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* caller should have ensured this */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
name|BACKSL
operator||
name|PEEK
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|nonnewline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|EMIT
argument_list|(
name|OANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'{'
case|:
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'('
case|:
name|NEXT
argument_list|()
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nsub
operator|++
expr_stmt|;
name|subno
operator|=
name|p
operator|->
name|g
operator|->
name|nsub
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
name|p
operator|->
name|pbegin
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OLPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
comment|/* the SEE here is an error heuristic */
if|if
condition|(
operator|!
name|SEE
argument_list|(
literal|'\0'
argument_list|)
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'\\'
argument_list|,
literal|')'
argument_list|)
condition|)
name|p_bre
argument_list|(
name|p
argument_list|,
literal|'\\'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT
argument_list|(
name|ORPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|')'
argument_list|)
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|')'
case|:
comment|/* should not get here -- must be user */
case|case
name|BACKSL
operator||
literal|'}'
case|:
name|SETERROR
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'1'
case|:
case|case
name|BACKSL
operator||
literal|'2'
case|:
case|case
name|BACKSL
operator||
literal|'3'
case|:
case|case
name|BACKSL
operator||
literal|'4'
case|:
case|case
name|BACKSL
operator||
literal|'5'
case|:
case|case
name|BACKSL
operator||
literal|'6'
case|:
case|case
name|BACKSL
operator||
literal|'7'
case|:
case|case
name|BACKSL
operator||
literal|'8'
case|:
case|case
name|BACKSL
operator||
literal|'9'
case|:
name|i
operator|=
operator|(
name|c
operator|&
operator|~
name|BACKSL
operator|)
operator|-
literal|'0'
expr_stmt|;
name|assert
argument_list|(
name|i
operator|<
name|NPAREN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|i
operator|<=
name|p
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OBACK_
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|pbegin
index|[
name|i
index|]
index|]
argument_list|)
operator|==
name|OLPAREN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|pend
index|[
name|i
index|]
index|]
argument_list|)
operator|==
name|ORPAREN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dupl
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
name|p
operator|->
name|pend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|O_BACK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|SETERROR
argument_list|(
name|REG_ESUBREG
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|backrefs
operator|=
literal|1
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'\0'
case|:
name|SETERROR
argument_list|(
name|REG_EESCAPE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|REQUIRE
argument_list|(
name|starordinary
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|c
operator|&
name|BACKSL
condition|)
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
name|ordinary
argument_list|(
name|p
argument_list|,
operator|(
name|uchar
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EAT
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
comment|/* implemented as +? */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|'{'
argument_list|)
condition|)
block|{
name|count
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|','
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
condition|)
block|{
name|count2
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|count
operator|<=
name|count2
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single number with comma */
name|count2
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* just a single number */
name|count2
operator|=
name|count
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|'}'
argument_list|)
condition|)
block|{
comment|/* error heuristics */
while|while
condition|(
operator|!
name|SEE
argument_list|(
literal|'\0'
argument_list|)
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'\\'
argument_list|,
literal|'}'
argument_list|)
condition|)
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|SEE
argument_list|(
literal|'\0'
argument_list|)
condition|)
name|SETERROR
argument_list|(
name|REG_EBRACE
argument_list|)
expr_stmt|;
else|else
name|SETERROR
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
comment|/* unbackslashed $ not followed by reptn */
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_count - parse a repetition count  */
end_comment

begin_function
specifier|static
name|int
comment|/* the value */
name|p_count
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|PEEK
argument_list|()
argument_list|)
operator|&&
name|count
operator|<=
name|DUPMAX
condition|)
block|{
name|count
operator|=
name|count
operator|*
literal|10
operator|+
operator|(
name|GETNEXT
argument_list|()
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ndigits
operator|++
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
name|ndigits
operator|>
literal|0
operator|&&
name|count
operator|<=
name|DUPMAX
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_bracket - parse a bracketed character list  *  * Note a significant property of this code:  if the allocset() did SETERROR,  * no set operations are done.  */
end_comment

begin_function
specifier|static
name|void
name|p_bracket
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|uchar
name|c
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
init|=
name|allocset
argument_list|(
name|p
argument_list|)
decl_stmt|;
specifier|register
name|int
name|invert
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'^'
argument_list|)
condition|)
name|invert
operator|++
expr_stmt|;
comment|/* make note to invert set at end */
if|if
condition|(
name|EAT
argument_list|(
literal|']'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|PEEK
argument_list|()
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|']'
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'-'
argument_list|,
literal|']'
argument_list|)
condition|)
name|p_b_term
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|MUSTEAT
argument_list|(
literal|']'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert
operator|&&
name|p
operator|->
name|error
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|p
operator|->
name|g
operator|->
name|csetsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
name|CHsub
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|CHadd
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|CHsub
argument_list|(
name|cs
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|!=
name|NULL
condition|)
name|mcinvert
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|cs
operator|->
name|multis
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
name|EMIT
argument_list|(
name|OANYOF
argument_list|,
name|freezeset
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_term - parse one term of a bracketed character list  */
end_comment

begin_function
specifier|static
name|void
name|p_b_term
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|uchar
name|c
decl_stmt|;
specifier|register
name|uchar
name|start
decl_stmt|,
name|finish
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* classify what we've got */
switch|switch
condition|(
name|PEEK
argument_list|()
condition|)
block|{
case|case
literal|'['
case|:
name|c
operator|=
name|PEEK2
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|SETERROR
argument_list|(
name|REG_ERANGE
argument_list|)
expr_stmt|;
return|return;
comment|/* NOTE RETURN */
break|break;
default|default:
name|c
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
comment|/* character class */
name|NEXT2
argument_list|()
expr_stmt|;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'\0'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|']'
argument_list|,
name|REG_ECTYPE
argument_list|)
expr_stmt|;
name|p_b_cclass
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|MUSTNOTSEE
argument_list|(
literal|'\0'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|':'
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECTYPE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* equivalence class */
name|NEXT2
argument_list|()
expr_stmt|;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'\0'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|']'
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
name|p_b_eclass
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|MUSTNOTSEE
argument_list|(
literal|'\0'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'='
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* symbol, ordinary character, or range */
comment|/* xxx revision needed for multichar stuff */
name|start
operator|=
name|p_b_symbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEK
argument_list|()
operator|==
literal|'-'
operator|&&
operator|(
name|c
operator|=
name|PEEK2
argument_list|()
operator|)
operator|!=
literal|']'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
block|{
comment|/* range */
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|finish
operator|=
literal|'-'
expr_stmt|;
else|else
name|finish
operator|=
name|p_b_symbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|finish
operator|=
name|start
expr_stmt|;
name|REQUIRE
argument_list|(
name|start
operator|<=
name|finish
argument_list|,
name|REG_ERANGE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|finish
condition|;
name|i
operator|++
control|)
block|{
name|CHadd
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_ICASE
operator|)
operator|&&
name|isalpha
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|c
operator|=
name|othercase
argument_list|(
operator|(
name|uchar
operator|)
name|i
argument_list|)
expr_stmt|;
name|CHadd
argument_list|(
name|cs
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  - p_b_cclass - parse a character-class name and deal with it  */
end_comment

begin_function
specifier|static
name|void
name|p_b_cclass
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|sb
init|=
name|p
operator|->
name|next
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|se
init|=
name|sb
decl_stmt|;
specifier|register
name|struct
name|cclass
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|u
decl_stmt|;
specifier|register
name|uchar
name|c
decl_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|se
argument_list|)
condition|)
name|se
operator|++
expr_stmt|;
name|len
operator|=
name|se
operator|-
name|sb
expr_stmt|;
name|NEXTn
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cclasses
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sb
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|cp
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* oops, didn't find it */
name|SETERROR
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
return|return;
block|}
name|u
operator|=
operator|(
name|uchar
operator|*
operator|)
name|cp
operator|->
name|chars
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|u
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|CHadd
argument_list|(
name|cs
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
operator|(
name|uchar
operator|*
operator|)
name|cp
operator|->
name|multis
init|;
operator|*
name|u
operator|!=
literal|'\0'
condition|;
name|u
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|u
argument_list|)
operator|+
literal|1
control|)
name|MCadd
argument_list|(
name|cs
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_eclass - parse an equivalence-class name and deal with it  *  * This implementation is incomplete. xxx  */
end_comment

begin_function
specifier|static
name|void
name|p_b_eclass
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|uchar
name|c
decl_stmt|;
name|c
operator|=
name|p_b_coll_elem
argument_list|(
name|p
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|CHadd
argument_list|(
name|cs
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_symbol - parse a character or [..]ed multicharacter collating symbol  */
end_comment

begin_function
specifier|static
name|uchar
comment|/* value of symbol */
name|p_b_symbol
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|uchar
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|EATTWO
argument_list|(
literal|'['
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|MUSTNOTSEE
argument_list|(
literal|'\0'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
return|return
operator|(
name|GETNEXT
argument_list|()
operator|)
return|;
block|}
comment|/* collating symbol */
name|MUSTNOTSEE
argument_list|(
literal|'\0'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|value
operator|=
name|p_b_coll_elem
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'.'
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_b_coll_elem - parse a collating-element name and look it up  */
end_comment

begin_function
specifier|static
name|uchar
comment|/* value of collating element */
name|p_b_coll_elem
parameter_list|(
name|p
parameter_list|,
name|endc
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|u_int
name|endc
decl_stmt|;
comment|/* name ended by endc,']' */
block|{
specifier|register
name|uchar
modifier|*
name|sp
init|=
name|p
operator|->
name|next
decl_stmt|;
specifier|register
name|struct
name|cname
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|uchar
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|PEEK
argument_list|()
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|SEETWO
argument_list|(
name|endc
argument_list|,
literal|']'
argument_list|)
condition|)
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|p
operator|->
name|next
operator|-
name|sp
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cnames
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|cp
operator|->
name|code
operator|)
return|;
comment|/* known name */
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
operator|(
operator|*
name|sp
operator|)
return|;
comment|/* single character */
name|SETERROR
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* neither */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - othercase - return the case counterpart of an alphabetic  */
end_comment

begin_function
specifier|static
name|uchar
name|othercase
parameter_list|(
name|ch
parameter_list|)
name|u_int
name|ch
decl_stmt|;
block|{
name|assert
argument_list|(
name|isalpha
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|tolower
argument_list|(
name|ch
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|islower
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|toupper
argument_list|(
name|ch
argument_list|)
operator|)
return|;
else|else
comment|/* peculiar, but could happen */
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - bothcases - emit a dualcase version of a character  *  * Boy, is this implementation ever a kludge...  */
end_comment

begin_function
specifier|static
name|void
name|bothcases
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|u_int
name|ch
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|oldnext
decl_stmt|;
name|uchar
name|bracket
index|[
literal|3
index|]
decl_stmt|;
name|oldnext
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|bracket
expr_stmt|;
name|bracket
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|bracket
index|[
literal|1
index|]
operator|=
literal|']'
expr_stmt|;
name|bracket
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|next
operator|==
name|bracket
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|oldnext
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - ordinary - emit an ordinary character  */
end_comment

begin_function
specifier|static
name|void
name|ordinary
parameter_list|(
name|p
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|u_int
name|ch
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|cap
init|=
name|p
operator|->
name|g
operator|->
name|categories
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_ICASE
operator|)
operator|&&
name|isalpha
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|bothcases
argument_list|(
name|p
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|EMIT
argument_list|(
name|OCHAR
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
index|[
name|ch
index|]
operator|==
literal|0
condition|)
name|cap
index|[
name|ch
index|]
operator|=
name|p
operator|->
name|g
operator|->
name|ncategories
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - nonnewline - emit REG_NEWLINE version of OANY  *  * Boy, is this implementation ever a kludge...  */
end_comment

begin_function
specifier|static
name|void
name|nonnewline
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|oldnext
decl_stmt|;
name|uchar
name|bracket
index|[
literal|4
index|]
decl_stmt|;
name|oldnext
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|bracket
expr_stmt|;
name|bracket
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|bracket
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bracket
index|[
literal|2
index|]
operator|=
literal|']'
expr_stmt|;
name|bracket
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|next
operator|==
name|bracket
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|oldnext
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - repeat - generate code for a bounded repetition, recursively if needed  */
end_comment

begin_function
specifier|static
name|void
name|repeat
parameter_list|(
name|p
parameter_list|,
name|start
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sopno
name|start
decl_stmt|;
comment|/* operand from here to end of strip */
name|int
name|from
decl_stmt|;
comment|/* repeated from this number */
name|int
name|to
decl_stmt|;
comment|/* to this number of times (maybe INFINITY) */
block|{
specifier|register
name|sopno
name|finish
init|=
name|HERE
argument_list|()
decl_stmt|;
define|#
directive|define
name|N
value|2
define|#
directive|define
name|INF
value|3
define|#
directive|define
name|REP
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|((f)*8 + (t))
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|(((n)<= 1) ? (n) : ((n) == INFINITY) ? INF : N)
specifier|register
name|sopno
name|copy
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* head off possible runaway recursion */
return|return;
name|assert
argument_list|(
name|from
operator|<=
name|to
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REP
argument_list|(
name|MAP
argument_list|(
name|from
argument_list|)
argument_list|,
name|MAP
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
case|:
comment|/* must be user doing this */
name|DROP
argument_list|(
name|finish
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* drop the operand */
break|break;
case|case
name|REP
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
case|:
comment|/* as x{1,1}? */
case|case
name|REP
argument_list|(
literal|0
argument_list|,
name|N
argument_list|)
case|:
comment|/* as x{1,n}? */
case|case
name|REP
argument_list|(
literal|0
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as x{1,}? */
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* offset is wrong... */
name|repeat
argument_list|(
name|p
argument_list|,
name|start
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|FWD
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* ... fix it */
name|BACK
argument_list|(
name|O_QUEST
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
case|:
comment|/* trivial case */
comment|/* done */
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
name|N
argument_list|)
case|:
comment|/* as x?x{1,n-1} */
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_QUEST
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
operator|+
literal|1
argument_list|,
name|finish
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|copy
operator|==
name|finish
operator|+
literal|2
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
literal|1
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as x+ */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|BACK
argument_list|(
name|O_PLUS
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
name|N
argument_list|,
name|N
argument_list|)
case|:
comment|/* as xx{m-1,n-1} */
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
name|from
operator|-
literal|1
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
name|N
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as xx{n-1,INF} */
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
name|from
operator|-
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* "can't happen" */
name|SETERROR
argument_list|(
name|REG_ASSERT
argument_list|)
expr_stmt|;
comment|/* just in case */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  - seterr - set an error condition  */
end_comment

begin_function
specifier|static
name|int
comment|/* useless but makes type checking happy */
name|seterr
parameter_list|(
name|p
parameter_list|,
name|e
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|int
name|e
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|error
operator|==
literal|0
condition|)
comment|/* keep earliest error condition */
name|p
operator|->
name|error
operator|=
name|e
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nuls
expr_stmt|;
comment|/* try to bring things to a halt */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make the return value well-defined */
block|}
end_function

begin_comment
comment|/*  - allocset - allocate a set of characters for []  */
end_comment

begin_function
specifier|static
name|cset
modifier|*
name|allocset
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|no
init|=
name|p
operator|->
name|g
operator|->
name|ncsets
operator|++
decl_stmt|;
specifier|register
name|size_t
name|nc
decl_stmt|;
specifier|register
name|size_t
name|nbytes
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
if|if
condition|(
name|no
operator|>=
name|p
operator|->
name|ncsalloc
condition|)
block|{
comment|/* need another column of space */
name|p
operator|->
name|ncsalloc
operator|+=
name|CHAR_BIT
expr_stmt|;
name|nc
operator|=
name|p
operator|->
name|ncsalloc
expr_stmt|;
name|assert
argument_list|(
name|nc
operator|%
name|CHAR_BIT
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|nc
operator|/
name|CHAR_BIT
operator|*
name|css
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|sets
operator|==
name|NULL
condition|)
name|p
operator|->
name|g
operator|->
name|sets
operator|=
operator|(
name|cset
operator|*
operator|)
name|malloc
argument_list|(
name|nc
operator|*
sizeof|sizeof
argument_list|(
name|cset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|g
operator|->
name|sets
operator|=
operator|(
name|cset
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|g
operator|->
name|sets
argument_list|,
name|nc
operator|*
sizeof|sizeof
argument_list|(
name|cset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|setbits
operator|==
name|NULL
condition|)
name|p
operator|->
name|g
operator|->
name|setbits
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|g
operator|->
name|setbits
operator|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|g
operator|->
name|setbits
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|sets
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|g
operator|->
name|setbits
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|g
operator|->
name|setbits
operator|+
operator|(
name|nbytes
operator|-
name|css
operator|)
argument_list|,
literal|0
argument_list|,
name|css
argument_list|)
expr_stmt|;
else|else
block|{
name|no
operator|=
literal|0
expr_stmt|;
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
comment|/* caller's responsibility not to do set ops */
block|}
block|}
name|assert
argument_list|(
name|p
operator|->
name|g
operator|->
name|sets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
name|cs
operator|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|no
index|]
expr_stmt|;
name|cs
operator|->
name|ptr
operator|=
name|p
operator|->
name|g
operator|->
name|setbits
operator|+
name|css
operator|*
operator|(
operator|(
name|no
operator|)
operator|/
name|CHAR_BIT
operator|)
expr_stmt|;
name|cs
operator|->
name|mask
operator|=
literal|1
operator|<<
operator|(
operator|(
name|no
operator|)
operator|%
name|CHAR_BIT
operator|)
expr_stmt|;
name|cs
operator|->
name|hash
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|smultis
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|multis
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|cs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - freezeset - final processing on a set of characters  *  * The main task here is merging identical sets.  This is usually a waste  * of time (although the hash code minimizes the overhead), but can win  * big if REG_ICASE is being used.  REG_ICASE, by the way, is why the hash  * is done using addition rather than xor -- all ASCII [aA] sets xor to  * the same value!  */
end_comment

begin_function
specifier|static
name|int
comment|/* set number */
name|freezeset
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
specifier|register
name|uchar
name|h
init|=
name|cs
operator|->
name|hash
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|cset
modifier|*
name|top
init|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|p
operator|->
name|g
operator|->
name|ncsets
index|]
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs2
decl_stmt|;
specifier|register
name|size_t
name|css
init|=
operator|(
name|size_t
operator|)
name|p
operator|->
name|g
operator|->
name|csetsize
decl_stmt|;
comment|/* look for an earlier one which is the same */
for|for
control|(
name|cs2
operator|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
literal|0
index|]
init|;
name|cs2
operator|<
name|top
condition|;
name|cs2
operator|++
control|)
if|if
condition|(
name|cs2
operator|->
name|hash
operator|==
name|h
operator|&&
name|cs2
operator|!=
name|cs
condition|)
block|{
comment|/* maybe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|css
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|!
name|CHIN
argument_list|(
name|cs2
argument_list|,
name|i
argument_list|)
operator|!=
operator|!
operator|!
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
break|break;
comment|/* no */
if|if
condition|(
name|i
operator|==
name|css
condition|)
break|break;
comment|/* yes */
block|}
if|if
condition|(
name|cs2
operator|<
name|top
condition|)
block|{
comment|/* found one */
name|assert
argument_list|(
name|cs
operator|==
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|ncsets
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|css
condition|;
name|i
operator|++
control|)
name|CHsub
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cs
operator|=
name|cs2
expr_stmt|;
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|cs
operator|-
name|p
operator|->
name|g
operator|->
name|sets
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - mcadd - add a collating element to a cset  */
end_comment

begin_function
specifier|static
name|void
name|mcadd
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|size_t
name|oldend
init|=
name|cs
operator|->
name|smultis
decl_stmt|;
name|cs
operator|->
name|smultis
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|==
name|NULL
condition|)
name|cs
operator|->
name|multis
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|cs
operator|->
name|smultis
argument_list|)
expr_stmt|;
else|else
name|cs
operator|->
name|multis
operator|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
name|cs
operator|->
name|multis
argument_list|,
name|cs
operator|->
name|smultis
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|cs
operator|->
name|multis
operator|+
name|oldend
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
name|cs
operator|->
name|multis
index|[
name|cs
operator|->
name|smultis
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - mcsub - subtract a collating element from a cset  */
end_comment

begin_function
specifier|static
name|void
name|mcsub
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|u_int
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|fp
init|=
name|mcfind
argument_list|(
name|cs
argument_list|,
name|cp
argument_list|)
decl_stmt|;
specifier|register
name|size_t
name|len
init|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|fp
operator|+
name|len
operator|+
literal|1
operator|)
argument_list|,
name|cs
operator|->
name|smultis
operator|-
operator|(
name|fp
operator|+
name|len
operator|+
literal|1
operator|-
name|cs
operator|->
name|multis
operator|)
argument_list|)
expr_stmt|;
name|cs
operator|->
name|smultis
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|smultis
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cs
operator|->
name|multis
argument_list|)
expr_stmt|;
name|cs
operator|->
name|multis
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|cs
operator|->
name|multis
operator|=
operator|(
name|uchar
operator|*
operator|)
name|realloc
argument_list|(
name|cs
operator|->
name|multis
argument_list|,
name|cs
operator|->
name|smultis
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cs
operator|->
name|multis
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - mcin - is a collating element in a cset?  */
end_comment

begin_function
specifier|static
name|int
name|mcin
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|u_int
modifier|*
name|cp
decl_stmt|;
block|{
return|return
operator|(
name|mcfind
argument_list|(
name|cs
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - mcfind - find a collating element in a cset  */
end_comment

begin_function
specifier|static
name|uchar
modifier|*
name|mcfind
parameter_list|(
name|cs
parameter_list|,
name|cp
parameter_list|)
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
specifier|register
name|u_int
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cs
operator|->
name|multis
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|cs
operator|->
name|multis
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|+
literal|1
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - mcinvert - invert the list of collating elements in a cset  *  * This would have to know the set of possibilities.  Implementation  * is deferred.  */
end_comment

begin_function
specifier|static
name|void
name|mcinvert
parameter_list|(
name|p
parameter_list|,
name|cs
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|cset
modifier|*
name|cs
decl_stmt|;
block|{
name|assert
argument_list|(
name|cs
operator|->
name|multis
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* xxx */
block|}
end_function

begin_comment
comment|/*  - isinsets - is this character in any sets?  */
end_comment

begin_function
specifier|static
name|int
comment|/* predicate */
name|isinsets
parameter_list|(
name|g
parameter_list|,
name|c
parameter_list|)
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
name|u_int
name|c
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|col
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ncols
init|=
operator|(
name|g
operator|->
name|ncsets
operator|+
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|/
name|CHAR_BIT
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|col
operator|=
name|g
operator|->
name|setbits
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
operator|,
name|col
operator|+=
name|g
operator|->
name|csetsize
control|)
if|if
condition|(
name|col
index|[
name|c
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - samesets - are these two characters in exactly the same sets?  */
end_comment

begin_function
specifier|static
name|int
comment|/* predicate */
name|samesets
parameter_list|(
name|g
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|)
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
specifier|register
name|u_int
name|c1
decl_stmt|;
specifier|register
name|u_int
name|c2
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|col
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|ncols
init|=
operator|(
name|g
operator|->
name|ncsets
operator|+
operator|(
name|CHAR_BIT
operator|-
literal|1
operator|)
operator|)
operator|/
name|CHAR_BIT
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|col
operator|=
name|g
operator|->
name|setbits
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
operator|,
name|col
operator|+=
name|g
operator|->
name|csetsize
control|)
if|if
condition|(
name|col
index|[
name|c1
index|]
operator|!=
name|col
index|[
name|c2
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - categorize - sort out character categories  */
end_comment

begin_function
specifier|static
name|void
name|categorize
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|cats
init|=
name|g
operator|->
name|categories
decl_stmt|;
specifier|register
name|unsigned
name|c
decl_stmt|;
specifier|register
name|unsigned
name|c2
decl_stmt|;
specifier|register
name|uchar
name|cat
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|g
operator|->
name|csetsize
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|cats
index|[
name|c
index|]
operator|==
literal|0
operator|&&
name|isinsets
argument_list|(
name|g
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|cat
operator|=
name|g
operator|->
name|ncategories
operator|++
expr_stmt|;
name|cats
index|[
name|c
index|]
operator|=
name|cat
expr_stmt|;
for|for
control|(
name|c2
operator|=
name|c
operator|+
literal|1
init|;
name|c2
operator|<
name|g
operator|->
name|csetsize
condition|;
name|c2
operator|++
control|)
if|if
condition|(
name|cats
index|[
name|c2
index|]
operator|==
literal|0
operator|&&
name|samesets
argument_list|(
name|g
argument_list|,
name|c
argument_list|,
name|c2
argument_list|)
condition|)
name|cats
index|[
name|c2
index|]
operator|=
name|cat
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - dupl - emit a duplicate of a bunch of sops  */
end_comment

begin_function
specifier|static
name|sopno
comment|/* start of duplicate */
name|dupl
parameter_list|(
name|p
parameter_list|,
name|start
parameter_list|,
name|finish
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sopno
name|start
decl_stmt|;
comment|/* from here */
name|sopno
name|finish
decl_stmt|;
comment|/* to this less one */
block|{
specifier|register
name|sopno
name|ret
init|=
name|HERE
argument_list|()
decl_stmt|;
specifier|register
name|sopno
name|len
init|=
name|finish
operator|-
name|start
decl_stmt|;
name|assert
argument_list|(
name|finish
operator|>=
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|enlarge
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ssize
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* this many unexpected additions */
name|assert
argument_list|(
name|p
operator|->
name|ssize
operator|>=
name|p
operator|->
name|slen
operator|+
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|strip
operator|+
name|p
operator|->
name|slen
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|strip
operator|+
name|start
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|len
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|slen
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - doemit - emit a strip operator  *  * It might seem better to implement this as a macro with a function as  * hard-case backup, but it's just too big and messy unless there are  * some changes to the data structures.  Maybe later.  */
end_comment

begin_function
specifier|static
name|void
name|doemit
parameter_list|(
name|p
parameter_list|,
name|op
parameter_list|,
name|opnd
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sop
name|op
decl_stmt|;
name|size_t
name|opnd
decl_stmt|;
block|{
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* deal with oversize operands ("can't happen", more or less) */
name|assert
argument_list|(
name|opnd
operator|<
literal|1
operator|<<
name|OPSHIFT
argument_list|)
expr_stmt|;
comment|/* deal with undersized strip */
if|if
condition|(
name|p
operator|->
name|slen
operator|>=
name|p
operator|->
name|ssize
condition|)
name|enlarge
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|ssize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* +50% */
name|assert
argument_list|(
name|p
operator|->
name|slen
operator|<
name|p
operator|->
name|ssize
argument_list|)
expr_stmt|;
comment|/* finally, it's all reduced to the easy case */
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|slen
operator|++
index|]
operator|=
name|SOP
argument_list|(
name|op
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - doinsert - insert a sop into the strip  */
end_comment

begin_function
specifier|static
name|void
name|doinsert
parameter_list|(
name|p
parameter_list|,
name|op
parameter_list|,
name|opnd
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
name|sop
name|op
decl_stmt|;
name|size_t
name|opnd
decl_stmt|;
name|sopno
name|pos
decl_stmt|;
block|{
specifier|register
name|sopno
name|sn
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|sn
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|op
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
comment|/* do checks, ensure space */
name|assert
argument_list|(
name|HERE
argument_list|()
operator|==
name|sn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|strip
index|[
name|sn
index|]
expr_stmt|;
comment|/* adjust paren pointers */
name|assert
argument_list|(
name|pos
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NPAREN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|>=
name|pos
condition|)
block|{
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|>=
name|pos
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|strip
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|strip
index|[
name|pos
index|]
argument_list|,
operator|(
name|HERE
argument_list|()
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|strip
index|[
name|pos
index|]
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - dofwd - complete a forward reference  */
end_comment

begin_function
specifier|static
name|void
name|dofwd
parameter_list|(
name|p
parameter_list|,
name|pos
parameter_list|,
name|value
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|sopno
name|pos
decl_stmt|;
name|sop
name|value
decl_stmt|;
block|{
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|value
operator|<
literal|1
operator|<<
name|OPSHIFT
argument_list|)
expr_stmt|;
name|p
operator|->
name|strip
index|[
name|pos
index|]
operator|=
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|pos
index|]
argument_list|)
operator||
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - enlarge - enlarge the strip  */
end_comment

begin_function
specifier|static
name|void
name|enlarge
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|sopno
name|size
decl_stmt|;
block|{
specifier|register
name|sop
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|ssize
operator|>=
name|size
condition|)
return|return;
name|sp
operator|=
operator|(
name|sop
operator|*
operator|)
name|realloc
argument_list|(
name|p
operator|->
name|strip
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|strip
operator|=
name|sp
expr_stmt|;
name|p
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - stripsnug - compact the strip  */
end_comment

begin_function
specifier|static
name|void
name|stripsnug
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
specifier|register
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
name|g
operator|->
name|nstates
operator|=
name|p
operator|->
name|slen
expr_stmt|;
name|g
operator|->
name|strip
operator|=
operator|(
name|sop
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|sop
operator|*
operator|)
name|p
operator|->
name|strip
argument_list|,
name|p
operator|->
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|strip
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
name|g
operator|->
name|strip
operator|=
name|p
operator|->
name|strip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - findmust - fill in must and mlen with longest mandatory literal string  *  * This algorithm could do fancy things like analyzing the operands of |  * for common subsequences.  Someday.  This code is simple and finds most  * of the interesting cases.  *  * Note that must and mlen got initialized during setup.  */
end_comment

begin_function
specifier|static
name|void
name|findmust
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
specifier|register
name|sop
modifier|*
name|scan
decl_stmt|;
name|sop
modifier|*
name|start
decl_stmt|;
specifier|register
name|sop
modifier|*
name|newstart
decl_stmt|;
specifier|register
name|sopno
name|newlen
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|sopno
name|i
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* find the longest OCHAR sequence in strip */
name|newlen
operator|=
literal|0
expr_stmt|;
name|scan
operator|=
name|g
operator|->
name|strip
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OCHAR
case|:
comment|/* sequence member */
if|if
condition|(
name|newlen
operator|==
literal|0
condition|)
comment|/* new sequence */
name|newstart
operator|=
name|scan
operator|-
literal|1
expr_stmt|;
name|newlen
operator|++
expr_stmt|;
break|break;
case|case
name|OPLUS_
case|:
comment|/* things that don't break one */
case|case
name|OLPAREN
case|:
case|case
name|ORPAREN
case|:
break|break;
case|case
name|OQUEST_
case|:
comment|/* things that must be skipped */
case|case
name|OCH_
case|:
name|scan
operator|--
expr_stmt|;
do|do
block|{
name|scan
operator|+=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|scan
expr_stmt|;
comment|/* assert() interferes w debug printouts */
if|if
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OOR2
condition|)
block|{
name|g
operator|->
name|iflags
operator||=
name|BAD
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
condition|)
do|;
comment|/* fallthrough */
default|default:
comment|/* things that break a sequence */
if|if
condition|(
name|newlen
operator|>
name|g
operator|->
name|mlen
condition|)
block|{
comment|/* ends one */
name|start
operator|=
name|newstart
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
name|newlen
expr_stmt|;
block|}
name|newlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OEND
condition|)
do|;
if|if
condition|(
name|g
operator|->
name|mlen
operator|==
literal|0
condition|)
comment|/* there isn't one */
return|return;
comment|/* turn it into a character string */
name|g
operator|->
name|must
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|g
operator|->
name|mlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|must
operator|==
name|NULL
condition|)
block|{
comment|/* argh; just forget it */
name|g
operator|->
name|mlen
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|g
operator|->
name|must
expr_stmt|;
name|scan
operator|=
name|start
expr_stmt|;
for|for
control|(
name|i
operator|=
name|g
operator|->
name|mlen
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
name|OP
argument_list|(
name|s
operator|=
operator|*
name|scan
operator|++
argument_list|)
operator|!=
name|OCHAR
condition|)
continue|continue;
operator|*
name|cp
operator|++
operator|=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* just on general principles */
block|}
end_function

begin_comment
comment|/*  - pluscount - count + nesting  */
end_comment

begin_function
specifier|static
name|sopno
comment|/* nesting depth */
name|pluscount
parameter_list|(
name|p
parameter_list|,
name|g
parameter_list|)
name|struct
name|parse
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
block|{
specifier|register
name|sop
modifier|*
name|scan
decl_stmt|;
specifier|register
name|sop
name|s
decl_stmt|;
specifier|register
name|sopno
name|plusnest
init|=
literal|0
decl_stmt|;
specifier|register
name|sopno
name|maxnest
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* there may not be an OEND */
name|scan
operator|=
name|g
operator|->
name|strip
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OPLUS_
case|:
name|plusnest
operator|++
expr_stmt|;
break|break;
case|case
name|O_PLUS
case|:
if|if
condition|(
name|plusnest
operator|>
name|maxnest
condition|)
name|maxnest
operator|=
name|plusnest
expr_stmt|;
name|plusnest
operator|--
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OEND
condition|)
do|;
if|if
condition|(
name|plusnest
operator|!=
literal|0
condition|)
name|g
operator|->
name|iflags
operator||=
name|BAD
expr_stmt|;
return|return
operator|(
name|maxnest
operator|)
return|;
block|}
end_function

end_unit

