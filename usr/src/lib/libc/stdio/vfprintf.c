begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_expr_stmt
name|From
name|stevesu
expr|@
name|copper
operator|.
name|UUCP
name|Wed
name|Mar
literal|25
literal|23
operator|:
literal|35
operator|:
literal|32
literal|1987
name|Path
operator|:
name|seismo
operator|!
name|ut
operator|-
name|sally
operator|!
name|husc6
operator|!
name|bacchus
operator|!
name|mit
operator|-
name|eddie
operator|!
name|genrad
operator|!
name|decvax
operator|!
name|tektronix
operator|!
name|teklds
operator|!
name|copper
operator|!
name|stevesu
name|From
operator|:
name|stevesu
expr|@
name|copper
operator|.
name|TEK
operator|.
name|COM
argument_list|(
argument|Steve Summit
argument_list|)
name|Newsgroups
operator|:
name|net
operator|.
name|sources
name|Subject
operator|:
name|Public
name|Domain
name|_doprnt
name|in
name|C
name|Message
operator|-
name|ID
operator|:
operator|<
literal|938
expr|@
name|copper
operator|.
name|TEK
operator|.
name|COM
operator|>
name|Date
operator|:
literal|26
name|Mar
literal|87
literal|04
operator|:
literal|35
operator|:
literal|32
name|GMT
name|Reply
operator|-
name|To
operator|:
name|stevesu
expr|@
name|copper
operator|.
name|UUCP
argument_list|(
argument|Steve Summit
argument_list|)
name|Distribution
operator|:
name|world
name|Organization
operator|:
name|Tektronix
operator|,
name|Inc
operator|.
expr|,
name|Beaverton
operator|,
name|OR
operator|.
name|Lines
operator|:
literal|420
name|Mark
name|Pulver
name|is
name|looking
end_expr_stmt

begin_for
for|for a C version of _doprnt
operator|,
name|so
name|I
name|thought
name|I
literal|'d pass mine along.  I wrote this from the ground up; it is absolutely underived from anything proprietary.  This version is not complete, and has the following two key omissions:  	It doesn'
name|t
end_for

begin_do
do|do
name|floating
name|point
argument_list|(
operator|%
name|f
argument_list|,
operator|%
name|e
argument_list|,
name|or
operator|%
name|g
argument_list|)
decl|.
name|It
name|will
name|handle
decl|%
name|ld
argument_list|(
operator|%
name|lx
argument_list|,
name|etc
operator|.
expr|)
name|incorrectly
name|on
name|machines
name|where
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|.
name|It
name|also
name|does
name|not
name|implement
name|the
operator|%
operator|#
name|stuff
name|which
name|appeared
name|in
name|the
literal|4.2
name|documentation
name|but
name|which
name|I
name|haven
literal|'t seen in any implementation yet.  I believe it handles everything else correctly, although I have not tested it exhaustively.  There are two "fun" additions: %b is binary, and %r is roman.  You are free to use this code as you wish, but please leave the identification comment intact.  I can offer no support for this code, although if I ever implement floating point or pdp11 support (I'
name|m
name|acutely
name|embarrassed
name|to
name|admit
name|making
name|the
name|typical
name|VAX
name|int
operator|/
name|long
name|equivalence
name|assumption
argument_list|)
name|I
decl|'ll try to remember to post those additions.                                             Steve Summit                                            stevesu@copper.tek.com  --------------------- cut here for doprnt.c --------------------- /*  *  Common code for printf et al.  *  *  The calling routine typically takes a variable number of arguments,  *  and passes the address of the first one.  This implementation  *  assumes a straightforward, stack implementation, aligned to the  *  machine'
name|s
name|wordsize
operator|.
name|Increasing
name|addresses
name|are
name|assumed
name|to
name|point
name|to
modifier|*
name|successive
name|arguments
argument_list|(
name|left
operator|-
name|to
operator|-
name|right
argument_list|)
decl_stmt|,
name|as
name|is
name|the
name|case for a machine  *  with a downward-growing stack with arguments pushed right-to-left.  *  *  To write, for example, fprintf() using this routine, the code  *  *	fprintf(fd, format, args)  *	FILE *fd
decl_stmt|;
do|*	char *format;  *
block|{
operator|*
name|_doprnt
argument_list|(
name|format
argument_list|,
operator|&
name|args
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|*
block|}
do|*  *  would suffice.  (This example does not handle the fprintf's "return  *  value" correctly, but who looks at the return value of fprintf  *  anyway?)  *  *  This version implements the following printf features:  *  *	%d	decimal conversion  *	%u	unsigned conversion  *	%x	hexadecimal conversion  *	%X	hexadecimal conversion with capital letters  *	%o	octal conversion  *	%c	character  *	%s	string  *	%m.n	field width, precision  *	%-m.n	left adjustment  *	%0m.n	zero-padding  *	%*.*	width and precision taken from arguments  *  *  This version does not implement %f, %e, or %g.  It accepts, but  *  ignores, an `l' as in %ld
operator|,
do|%lo
operator|,
do|%lx
operator|,
do|and %lu
operator|,
do|and therefore will not  *  work correctly on machines for which sizeof(long
end_do

begin_expr_stmt
unit|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|.
operator|*
name|It
name|does
name|not
name|even
name|parse
operator|%
name|D
operator|,
operator|%
name|O
operator|,
name|or
operator|%
name|U
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|you
name|should
name|be
name|using
operator|%
name|ld
operator|,
operator|%
name|o
name|and
operator|*
operator|%
name|lu
end_expr_stmt

begin_if
if|if you mean long conversion.  *  *  This version implements the following nonstandard features:  *  *	%b	binary conversion  *	%r	roman numeral conversion  *	%R	roman numeral conversion with capital letters  *  *  As mentioned
operator|,
name|this
name|version
name|does
name|not
end_if

begin_return
return|return
name|any
name|reasonable
name|value
operator|.
modifier|*
modifier|*
name|Permission
name|is
name|granted
name|to
name|use
operator|,
name|modify
operator|,
name|or
name|propagate
name|this
name|code
name|as
operator|*
name|long
name|as
name|this
name|notice
name|is
name|incorporated
operator|.
modifier|*
modifier|*
name|Steve
name|Summit
literal|3
operator|/
literal|25
operator|/
literal|87
operator|*
operator|/
include|#
directive|include
file|<stdio.h>
define|#
directive|define
name|TRUE
value|1
define|#
directive|define
name|FALSE
value|0
define|#
directive|define
name|ROMAN
define|#
directive|define
name|isdigit
parameter_list|(
name|d
parameter_list|)
value|((d)>= '0'&& (d)<= '9')
define|#
directive|define
name|Ctod
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
define|#
directive|define
name|MAXBUF
value|(sizeof(long int) * 8)
comment|/* enough for binary */
ifdef|#
directive|ifdef
name|ROMAN
specifier|static
name|tack
argument_list|()
return|;
end_return

begin_expr_stmt
specifier|static
name|doit
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|_doprnt
argument_list|(
name|fmt
argument_list|,
name|argp
argument_list|,
name|fd
argument_list|)
specifier|register
name|char
operator|*
name|fmt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|int
name|ladjust
decl_stmt|;
name|char
name|padc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|int
name|base
decl_stmt|;
name|char
name|buf
index|[
name|MAXBUF
index|]
decl_stmt|;
name|int
name|negflag
decl_stmt|;
name|char
modifier|*
name|digs
decl_stmt|;
ifdef|#
directive|ifdef
name|ROMAN
name|char
modifier|*
name|rdigs
decl_stmt|;
name|int
name|d
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
block|{
name|putc
argument_list|(
operator|*
name|fmt
operator|++
argument_list|,
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'l'
condition|)
name|fmt
operator|++
expr_stmt|;
comment|/* need to use it if sizeof(int)< sizeof(long) */
name|length
operator|=
literal|0
expr_stmt|;
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
name|ladjust
operator|=
name|FALSE
expr_stmt|;
name|padc
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'-'
condition|)
block|{
name|ladjust
operator|=
name|TRUE
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'0'
condition|)
block|{
name|padc
operator|=
literal|'0'
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
name|length
operator|=
literal|10
operator|*
name|length
operator|+
name|Ctod
argument_list|(
operator|*
name|fmt
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|length
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|ladjust
operator|=
operator|!
name|ladjust
expr_stmt|;
name|length
operator|=
operator|-
name|length
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'.'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
name|prec
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
name|prec
operator|=
literal|10
operator|*
name|prec
operator|+
name|Ctod
argument_list|(
operator|*
name|fmt
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|prec
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
block|}
name|negflag
operator|=
name|FALSE
expr_stmt|;
name|digs
operator|=
literal|"0123456789abcdef"
expr_stmt|;
ifdef|#
directive|ifdef
name|ROMAN
name|rdigs
operator|=
literal|"  mdclxvi"
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|u
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|base
operator|=
literal|2
expr_stmt|;
goto|goto
name|donum
goto|;
case|case
literal|'c'
case|:
name|putc
argument_list|(
operator|*
name|argp
operator|++
argument_list|,
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|n
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|u
operator|=
name|n
expr_stmt|;
else|else
block|{
name|u
operator|=
operator|-
name|n
expr_stmt|;
name|negflag
operator|=
name|TRUE
expr_stmt|;
block|}
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|donum
goto|;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|u
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
goto|goto
name|donum
goto|;
ifdef|#
directive|ifdef
name|ROMAN
case|case
literal|'R'
case|:
name|rdigs
operator|=
literal|"  MDCLXVI"
expr_stmt|;
case|case
literal|'r'
case|:
name|n
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|p2
operator|=
operator|&
name|buf
index|[
name|MAXBUF
operator|-
literal|1
index|]
expr_stmt|;
name|d
operator|=
name|n
operator|%
literal|10
expr_stmt|;
name|tack
argument_list|(
name|d
argument_list|,
operator|&
name|rdigs
index|[
literal|6
index|]
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|/
literal|10
expr_stmt|;
name|d
operator|=
name|n
operator|%
literal|10
expr_stmt|;
name|tack
argument_list|(
name|d
argument_list|,
operator|&
name|rdigs
index|[
literal|4
index|]
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|n
operator|=
name|n
operator|/
literal|10
expr_stmt|;
name|d
operator|=
name|n
operator|%
literal|10
expr_stmt|;
name|tack
argument_list|(
name|d
argument_list|,
operator|&
name|rdigs
index|[
literal|2
index|]
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
name|d
operator|=
name|n
operator|%
literal|10
expr_stmt|;
name|tack
argument_list|(
name|d
argument_list|,
name|rdigs
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
name|p
operator|=
name|p2
expr_stmt|;
goto|goto
name|putpad
goto|;
endif|#
directive|endif
case|case
literal|'s'
case|:
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|argp
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"(NULL)"
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
operator|!
name|ladjust
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
name|prec
operator|==
operator|-
literal|1
operator|||
name|n
operator|<
name|prec
operator|)
condition|;
name|p
operator|++
control|)
name|n
operator|++
expr_stmt|;
name|p
operator|=
name|p2
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|length
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|++
name|n
operator|>
name|prec
operator|&&
name|prec
operator|!=
operator|-
literal|1
condition|)
break|break;
name|putc
argument_list|(
operator|*
name|p
operator|++
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
name|length
operator|&&
name|ladjust
condition|)
block|{
while|while
condition|(
name|n
operator|<
name|length
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|u
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
goto|goto
name|donum
goto|;
case|case
literal|'X'
case|:
name|digs
operator|=
literal|"0123456789ABCDEF"
expr_stmt|;
case|case
literal|'x'
case|:
name|u
operator|=
operator|*
name|argp
operator|++
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
name|donum
label|:
name|p
operator|=
operator|&
name|buf
index|[
name|MAXBUF
operator|-
literal|1
index|]
expr_stmt|;
do|do
block|{
operator|*
name|p
operator|--
operator|=
name|digs
index|[
name|u
operator|%
name|base
index|]
expr_stmt|;
name|u
operator|/=
name|base
expr_stmt|;
block|}
do|while
condition|(
name|u
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|negflag
condition|)
name|putc
argument_list|(
literal|'-'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|putpad
label|:
name|size
operator|=
operator|&
name|buf
index|[
name|MAXBUF
operator|-
literal|1
index|]
operator|-
name|p
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|length
operator|&&
operator|!
name|ladjust
condition|)
block|{
while|while
condition|(
name|length
operator|>
name|size
condition|)
block|{
name|putc
argument_list|(
name|padc
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|++
name|p
operator|!=
operator|&
name|buf
index|[
name|MAXBUF
index|]
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|length
condition|)
comment|/* must be ladjust */
block|{
while|while
condition|(
name|length
operator|>
name|size
condition|)
block|{
name|putc
argument_list|(
name|padc
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\0'
case|:
name|fmt
operator|--
expr_stmt|;
break|break;
default|default:
name|putc
argument_list|(
operator|*
name|fmt
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|ROMAN
end_ifdef

begin_expr_stmt
specifier|static
name|tack
argument_list|(
argument|d
argument_list|,
argument|digs
argument_list|,
argument|p
argument_list|)
name|int
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|digs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|d
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|d
operator|>=
literal|1
operator|&&
name|d
operator|<=
literal|3
condition|)
block|{
name|doit
argument_list|(
name|d
argument_list|,
name|digs
index|[
literal|2
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|==
literal|4
operator|||
name|d
operator|==
literal|5
condition|)
block|{
operator|*
operator|*
name|p
operator|=
name|digs
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|==
literal|4
condition|)
block|{
operator|*
operator|*
name|p
operator|=
name|digs
index|[
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|==
literal|5
condition|)
return|return;
if|if
condition|(
name|d
operator|>=
literal|6
operator|&&
name|d
operator|<=
literal|8
condition|)
block|{
name|doit
argument_list|(
name|d
operator|-
literal|5
argument_list|,
name|digs
index|[
literal|2
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
operator|*
name|p
operator|=
name|digs
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
return|return;
block|}
comment|/* d == 9 */
operator|*
operator|*
name|p
operator|=
name|digs
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
operator|*
operator|*
name|p
operator|=
name|digs
index|[
literal|2
index|]
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
specifier|static
name|doit
argument_list|(
argument|d
argument_list|,
argument|one
argument_list|,
argument|p
argument_list|)
name|int
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|one
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|*
name|p
operator|=
name|one
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

