begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mon.c	5.3 (Berkeley) 3/9/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|LIBC_SCCS and not lint
end_endif

begin_define
define|#
directive|define
name|ARCDENSITY
value|5
end_define

begin_comment
comment|/* density of routines */
end_comment

begin_define
define|#
directive|define
name|MINARCS
value|50
end_define

begin_comment
comment|/* minimum number of counters */
end_comment

begin_define
define|#
directive|define
name|HISTFRACTION
value|2
end_define

begin_comment
comment|/* fraction of text space for histograms */
end_comment

begin_struct
struct|struct
name|phdr
block|{
name|int
modifier|*
name|lpc
decl_stmt|;
name|int
modifier|*
name|hpc
decl_stmt|;
name|int
name|ncnt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cnt
block|{
name|int
modifier|*
name|pc
decl_stmt|;
name|long
name|ncall
decl_stmt|;
block|}
modifier|*
name|countbase
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|cntrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|profiling
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|s_sbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s_bufsiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s_scale
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|s_lowpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numctrs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MSG
value|"No space for monitor buffer(s)\n"
end_define

begin_macro
name|monstartup
argument_list|(
argument|lowpc
argument_list|,
argument|highpc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lowpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|highpc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|monsize
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|cntsiz
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|minbrk
decl_stmt|;
name|cntsiz
operator|=
operator|(
name|highpc
operator|-
name|lowpc
operator|)
operator|*
name|ARCDENSITY
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|cntsiz
operator|<
name|MINARCS
condition|)
name|cntsiz
operator|=
name|MINARCS
expr_stmt|;
name|monsize
operator|=
operator|(
name|highpc
operator|-
name|lowpc
operator|+
name|HISTFRACTION
operator|-
literal|1
operator|)
operator|/
name|HISTFRACTION
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|phdr
argument_list|)
operator|+
name|cntsiz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
expr_stmt|;
name|monsize
operator|=
operator|(
name|monsize
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|buffer
operator|=
name|sbrk
argument_list|(
name|monsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
name|MSG
argument_list|,
sizeof|sizeof
argument_list|(
name|MSG
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|minbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|monitor
argument_list|(
name|lowpc
argument_list|,
name|highpc
argument_list|,
name|buffer
argument_list|,
name|monsize
argument_list|,
name|cntsiz
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	This routine is massaged so that it may be jsb'ed to  */
end_comment

begin_asm
asm|asm(".text");
end_asm

begin_asm
asm|asm("#the beginning of mcount()");
end_asm

begin_asm
asm|asm(".data");
end_asm

begin_macro
name|mcount
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|selfpc
decl_stmt|;
comment|/* r11 */
specifier|register
name|long
modifier|*
modifier|*
name|cntp
decl_stmt|;
comment|/* r10 */
comment|/* 	 * find the return address for mcount, 	 * and address of counter pointer 	 */
asm|asm("	movl	(sp),r11");
comment|/* selfpc = ... (jsb frame) */
asm|asm("	movl	r0,r10");
comment|/* address of count local */
comment|/* 	 * check that we aren't recursively invoked. 	 */
if|if
condition|(
name|profiling
condition|)
goto|goto
name|out
goto|;
name|profiling
operator|++
expr_stmt|;
comment|/* 	 * check that counter is allocated 	 */
if|if
condition|(
operator|*
name|cntp
operator|==
literal|0
condition|)
block|{
comment|/* 		 * check that a counter is available 		 */
if|if
condition|(
name|cntrs
operator|++
operator|==
name|numctrs
condition|)
goto|goto
name|overflow
goto|;
name|countbase
operator|->
name|pc
operator|=
name|selfpc
expr_stmt|;
operator|*
name|cntp
operator|=
operator|&
name|countbase
operator|->
name|ncall
expr_stmt|;
name|countbase
operator|++
expr_stmt|;
block|}
operator|(
operator|*
operator|*
name|cntp
operator|)
operator|++
expr_stmt|;
name|profiling
operator|--
expr_stmt|;
name|out
label|:
asm|asm( "	rsb" );
name|overflow
label|:
define|#
directive|define
name|TOLIMIT
value|"mcount: counter overflow\n"
name|write
argument_list|(
literal|2
argument_list|,
name|TOLIMIT
argument_list|,
sizeof|sizeof
argument_list|(
name|TOLIMIT
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_block

begin_asm
asm|asm(".text");
end_asm

begin_asm
asm|asm("#the end of mcount()");
end_asm

begin_asm
asm|asm(".data");
end_asm

begin_macro
name|monitor
argument_list|(
argument|lowpc
argument_list|,
argument|highpc
argument_list|,
argument|buf
argument_list|,
argument|bufsiz
argument_list|,
argument|cntsiz
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|lowpc
decl_stmt|,
modifier|*
name|highpc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bufsiz
decl_stmt|,
name|cntsiz
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
name|struct
name|phdr
modifier|*
name|php
decl_stmt|;
specifier|static
name|int
name|ssiz
decl_stmt|;
specifier|static
name|char
modifier|*
name|sbuf
decl_stmt|;
if|if
condition|(
name|lowpc
operator|==
literal|0
condition|)
block|{
name|moncontrol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|o
operator|=
name|creat
argument_list|(
literal|"mon.out"
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|o
argument_list|,
name|sbuf
argument_list|,
name|ssiz
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return;
block|}
name|sbuf
operator|=
name|buf
expr_stmt|;
name|ssiz
operator|=
name|bufsiz
expr_stmt|;
name|php
operator|=
operator|(
expr|struct
name|phdr
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|php
operator|->
name|lpc
operator|=
operator|(
name|int
operator|*
operator|)
name|lowpc
expr_stmt|;
name|php
operator|->
name|hpc
operator|=
operator|(
name|int
operator|*
operator|)
name|highpc
expr_stmt|;
name|php
operator|->
name|ncnt
operator|=
name|cntsiz
expr_stmt|;
name|numctrs
operator|=
name|cntsiz
expr_stmt|;
name|countbase
operator|=
operator|(
expr|struct
name|cnt
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|phdr
argument_list|)
operator|)
expr_stmt|;
name|o
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|phdr
argument_list|)
operator|+
name|cntsiz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cnt
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|o
expr_stmt|;
name|bufsiz
operator|-=
name|o
expr_stmt|;
if|if
condition|(
name|bufsiz
operator|<=
literal|0
condition|)
return|return;
name|o
operator|=
operator|(
name|highpc
operator|-
name|lowpc
operator|)
expr_stmt|;
if|if
condition|(
name|bufsiz
operator|<
name|o
condition|)
name|o
operator|=
operator|(
operator|(
name|float
operator|)
name|bufsiz
operator|/
name|o
operator|)
operator|*
literal|65536
expr_stmt|;
else|else
name|o
operator|=
literal|65536
expr_stmt|;
name|s_scale
operator|=
name|o
expr_stmt|;
name|s_sbuf
operator|=
name|buf
expr_stmt|;
name|s_bufsiz
operator|=
name|bufsiz
expr_stmt|;
name|s_lowpc
operator|=
name|lowpc
expr_stmt|;
name|moncontrol
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Control profiling  *	profiling is what mcount checks to see if  *	all the data structures are ready.  */
end_comment

begin_macro
name|moncontrol
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|mode
condition|)
block|{
comment|/* start */
name|profil
argument_list|(
name|s_sbuf
argument_list|,
name|s_bufsiz
argument_list|,
name|s_lowpc
argument_list|,
name|s_scale
argument_list|)
expr_stmt|;
name|profiling
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* stop */
name|profil
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|profiling
operator|=
literal|3
expr_stmt|;
block|}
block|}
end_block

end_unit

