begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)kvm.c	5.8 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/text.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmac.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<vis.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ndbm.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*  * files  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unixf
decl_stmt|,
modifier|*
name|memf
decl_stmt|,
modifier|*
name|kmemf
decl_stmt|,
modifier|*
name|swapf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unixx
decl_stmt|,
name|mem
decl_stmt|,
name|kmem
decl_stmt|,
name|swap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DBM
modifier|*
name|db
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * flags  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deadkernel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvminit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvmfilesopen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * state  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|kvmprocbase
decl_stmt|,
modifier|*
name|kvmprocptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvmnprocs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * u. buffer  */
end_comment

begin_union
specifier|static
union|union
block|{
name|struct
name|user
name|user
decl_stmt|;
name|char
name|upages
index|[
name|UPAGES
index|]
index|[
name|NBPG
index|]
decl_stmt|;
block|}
name|user
union|;
end_union

begin_comment
comment|/*  * random other stuff  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pte
modifier|*
name|Usrptmap
decl_stmt|,
modifier|*
name|usrpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dmmin
decl_stmt|,
name|dmmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pte
modifier|*
name|Sysmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Syssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcbpf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|argaddr0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|int
name|argaddr1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nswap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmp
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|lowram
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|basename
parameter_list|(
name|cp
parameter_list|)
value|((tmp=rindex((cp), '/')) ? tmp+1 : (cp))
end_define

begin_define
define|#
directive|define
name|MAXSYMSIZE
value|256
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
end_if

begin_define
define|#
directive|define
name|pftoc
parameter_list|(
name|f
parameter_list|)
value|((f) - lowram)
end_define

begin_define
define|#
directive|define
name|iskva
parameter_list|(
name|v
parameter_list|)
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pftoc
end_ifndef

begin_define
define|#
directive|define
name|pftoc
parameter_list|(
name|f
parameter_list|)
value|(f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|iskva
end_ifndef

begin_define
define|#
directive|define
name|iskva
parameter_list|(
name|v
parameter_list|)
value|((v)& KERNBASE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMAP
value|0
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|1
block|{
literal|"_nswap"
block|}
block|,
define|#
directive|define
name|X_NSWAP
value|2
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|X_DMMIN
value|3
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|X_DMMAX
value|4
comment|/* 	 * everything here and down, only if a dead kernel 	 */
block|{
literal|"_Sysmap"
block|}
block|,
define|#
directive|define
name|X_SYSMAP
value|5
define|#
directive|define
name|X_DEADKERNEL
value|X_SYSMAP
block|{
literal|"_Syssize"
block|}
block|,
define|#
directive|define
name|X_SYSSIZE
value|6
block|{
literal|"_allproc"
block|}
block|,
define|#
directive|define
name|X_ALLPROC
value|7
block|{
literal|"_zombproc"
block|}
block|,
define|#
directive|define
name|X_ZOMBPROC
value|8
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|9
define|#
directive|define
name|X_LAST
value|9
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
block|{
literal|"_lowram"
block|}
block|,
define|#
directive|define
name|X_LOWRAM
value|(X_LAST+1)
endif|#
directive|endif
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * returns 	0 if files were opened now,  * 		1 if files were already opened,  *		-1 if files could not be opened.  */
end_comment

begin_macro
name|kvm_openfiles
argument_list|(
argument|uf
argument_list|,
argument|mf
argument_list|,
argument|sf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|uf
decl_stmt|,
modifier|*
name|mf
decl_stmt|,
modifier|*
name|sf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|kvmfilesopen
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|unixx
operator|=
name|mem
operator|=
name|kmem
operator|=
name|swap
operator|=
operator|-
literal|1
expr_stmt|;
name|unixf
operator|=
operator|(
name|uf
operator|==
name|NULL
operator|)
condition|?
name|_PATH_UNIX
else|:
name|uf
expr_stmt|;
name|memf
operator|=
operator|(
name|mf
operator|==
name|NULL
operator|)
condition|?
name|_PATH_MEM
else|:
name|mf
expr_stmt|;
if|if
condition|(
operator|(
name|unixx
operator|=
name|open
argument_list|(
name|unixf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't open %s"
argument_list|,
name|unixf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
operator|(
name|mem
operator|=
name|open
argument_list|(
name|memf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't open %s"
argument_list|,
name|memf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
name|swapf
operator|=
name|sf
expr_stmt|;
if|if
condition|(
name|mf
operator|!=
name|NULL
condition|)
block|{
name|deadkernel
operator|++
expr_stmt|;
name|kmemf
operator|=
name|mf
expr_stmt|;
name|kmem
operator|=
name|mem
expr_stmt|;
name|swap
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|kmemf
operator|=
name|_PATH_KMEM
expr_stmt|;
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
name|kmemf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't open %s"
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|swapf
operator|=
operator|(
name|sf
operator|==
name|NULL
operator|)
condition|?
name|_PATH_DRUM
else|:
name|sf
expr_stmt|;
comment|/* 		 * live kernel - avoid looking up nlist entries 		 * past X_DEADKERNEL. 		 */
name|nl
index|[
name|X_DEADKERNEL
index|]
operator|.
name|n_name
operator|=
literal|""
expr_stmt|;
block|}
if|if
condition|(
name|swapf
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|swap
operator|=
name|open
argument_list|(
name|swapf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't open %s"
argument_list|,
name|swapf
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|kvmfilesopen
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
name|kvm_close
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|kvm_init
argument_list|(
argument|uf
argument_list|,
argument|mf
argument_list|,
argument|sf
argument_list|)
name|char
operator|*
name|uf
operator|,
operator|*
name|mf
operator|,
operator|*
name|sf
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|kvmfilesopen
operator|==
literal|0
operator|&&
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|getkvars
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|kvminit
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|kvm_close
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|unixx
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|unixx
argument_list|)
expr_stmt|;
name|unixx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|kmem
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|kmem
operator|!=
name|mem
condition|)
name|close
argument_list|(
name|kmem
argument_list|)
expr_stmt|;
comment|/* otherwise kmem is a copy of mem, and will be closed below */
name|kmem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mem
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|swap
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|swap
argument_list|)
expr_stmt|;
name|swap
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
block|}
name|kvminit
operator|=
literal|0
expr_stmt|;
name|kvmfilesopen
operator|=
literal|0
expr_stmt|;
name|deadkernel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Sysmap
condition|)
block|{
name|free
argument_list|(
name|Sysmap
argument_list|)
expr_stmt|;
name|Sysmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|kvm_nlist
argument_list|(
argument|nl
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|nl
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|datum
name|key
decl_stmt|,
name|data
decl_stmt|;
name|char
name|dbname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|dbversion
index|[
name|LINE_MAX
index|]
decl_stmt|;
name|char
name|kversion
index|[
name|LINE_MAX
index|]
decl_stmt|;
name|int
name|dbversionlen
decl_stmt|;
name|char
name|symbuf
index|[
name|MAXSYMSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|nlist
name|nbuf
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|num
decl_stmt|,
name|did
decl_stmt|;
if|if
condition|(
name|kvmfilesopen
operator|==
literal|0
operator|&&
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|deadkernel
condition|)
goto|goto
name|hard2
goto|;
comment|/* 	 * initialize key datum 	 */
name|key
operator|.
name|dptr
operator|=
name|symbuf
expr_stmt|;
name|symbuf
index|[
literal|0
index|]
operator|=
name|KVMDB_NLIST
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
goto|goto
name|win
goto|;
comment|/* off to the races */
comment|/* 	 * open database 	 */
name|sprintf
argument_list|(
name|dbname
argument_list|,
literal|"%s/kvm_%s"
argument_list|,
name|KVMDBDIR
argument_list|,
name|basename
argument_list|(
name|unixf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|db
operator|=
name|dbm_open
argument_list|(
name|dbname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|hard2
goto|;
comment|/* 	 * read version out of database 	 */
name|bcopy
argument_list|(
literal|"VERSION"
argument_list|,
name|symbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
literal|"VERSION"
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
literal|"VERSION"
argument_list|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|data
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|dptr
operator|==
name|NULL
condition|)
goto|goto
name|hard1
goto|;
name|bcopy
argument_list|(
name|data
operator|.
name|dptr
argument_list|,
name|dbversion
argument_list|,
name|data
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|dbversionlen
operator|=
name|data
operator|.
name|dsize
expr_stmt|;
comment|/* 	 * read version string from kernel memory 	 */
name|bcopy
argument_list|(
literal|"_version"
argument_list|,
name|symbuf
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
literal|"_version"
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
literal|"_version"
argument_list|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|data
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|dptr
operator|==
name|NULL
condition|)
goto|goto
name|hard1
goto|;
if|if
condition|(
name|data
operator|.
name|dsize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|)
goto|goto
name|hard1
goto|;
name|bcopy
argument_list|(
name|data
operator|.
name|dptr
argument_list|,
operator|&
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
name|nbuf
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
name|kversion
argument_list|,
name|dbversionlen
argument_list|)
operator|!=
name|dbversionlen
condition|)
goto|goto
name|hard1
goto|;
comment|/* 	 * if they match, we win - otherwise do it the hard way 	 */
if|if
condition|(
name|bcmp
argument_list|(
name|dbversion
argument_list|,
name|kversion
argument_list|,
name|dbversionlen
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|hard1
goto|;
comment|/* 	 * getem from the database. 	 */
name|win
label|:
name|num
operator|=
name|did
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nl
init|;
name|n
operator|->
name|n_name
operator|&&
name|n
operator|->
name|n_name
index|[
literal|0
index|]
condition|;
name|n
operator|++
operator|,
name|num
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
comment|/* 		 * clear out fields from users buffer 		 */
name|n
operator|->
name|n_type
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|n_other
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|n_desc
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|n_value
operator|=
literal|0
expr_stmt|;
comment|/* 		 * query db 		 */
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|n
operator|->
name|n_name
argument_list|)
operator|)
operator|>
name|MAXSYMSIZE
condition|)
block|{
name|seterr
argument_list|(
literal|"kvm_nlist: symbol too large"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|symbuf
operator|+
literal|1
argument_list|,
name|n
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|len
operator|+
literal|1
expr_stmt|;
name|data
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|dptr
operator|==
name|NULL
operator|||
name|data
operator|.
name|dsize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|)
continue|continue;
name|bcopy
argument_list|(
name|data
operator|.
name|dptr
argument_list|,
operator|&
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_value
operator|=
name|nbuf
operator|.
name|n_value
expr_stmt|;
name|n
operator|->
name|n_type
operator|=
name|nbuf
operator|.
name|n_type
expr_stmt|;
name|n
operator|->
name|n_desc
operator|=
name|nbuf
operator|.
name|n_desc
expr_stmt|;
name|n
operator|->
name|n_other
operator|=
name|nbuf
operator|.
name|n_other
expr_stmt|;
name|did
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num
operator|-
name|did
operator|)
return|;
name|hard1
label|:
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
name|hard2
label|:
return|return
operator|(
name|nlist
argument_list|(
name|unixf
argument_list|,
name|nl
argument_list|)
operator|)
return|;
comment|/* XXX seterr if -1 */
block|}
end_block

begin_macro
name|kvm_getprocs
argument_list|(
argument|what
argument_list|,
argument|arg
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|kvminit
operator|==
literal|0
operator|&&
name|kvm_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|deadkernel
condition|)
block|{
name|int
name|ret
decl_stmt|,
name|copysize
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|getkerninfo
argument_list|(
name|what
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't get estimate for kerninfo"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|copysize
operator|=
name|ret
expr_stmt|;
if|if
condition|(
operator|(
name|kvmprocbase
operator|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|malloc
argument_list|(
name|copysize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|seterr
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|getkerninfo
argument_list|(
name|what
argument_list|,
name|kvmprocbase
argument_list|,
operator|&
name|copysize
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|setsyserr
argument_list|(
literal|"can't get proc list"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|copysize
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"proc size mismatch (kinfo_proc: %d)"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kvmnprocs
operator|=
name|copysize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|nproc
decl_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read nproc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|kvmprocbase
operator|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|)
name|malloc
argument_list|(
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|seterr
argument_list|(
literal|"out of memory (addr: %x nproc = %d)"
argument_list|,
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|kvmnprocs
operator|=
name|kvm_doprocs
argument_list|(
name|what
argument_list|,
name|arg
argument_list|,
name|kvmprocbase
argument_list|)
expr_stmt|;
name|realloc
argument_list|(
name|kvmprocbase
argument_list|,
name|kvmnprocs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kvmprocptr
operator|=
name|kvmprocbase
expr_stmt|;
return|return
operator|(
name|kvmnprocs
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * XXX - should NOT give up so easily - especially since the kernel  * may be corrupt (it died).  Should gather as much information as possible.  * Follows proc ptrs instead of reading table since table may go  * away soon.  */
end_comment

begin_expr_stmt
specifier|static
name|kvm_doprocs
argument_list|(
argument|what
argument_list|,
argument|arg
argument_list|,
argument|buff
argument_list|)
name|int
name|what
operator|,
name|arg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buff
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
name|proc
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|buff
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|doingzomb
init|=
literal|0
decl_stmt|;
name|struct
name|eproc
name|eproc
decl_stmt|;
name|struct
name|pgrp
name|pgrp
decl_stmt|;
name|struct
name|session
name|sess
decl_stmt|;
name|struct
name|tty
name|tty
decl_stmt|;
name|struct
name|text
name|text
decl_stmt|;
comment|/* allproc */
if|if
condition|(
name|kvm_read
argument_list|(
name|nl
index|[
name|X_ALLPROC
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read allproc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|again
label|:
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|proc
operator|.
name|p_nxt
control|)
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|p
argument_list|,
operator|&
name|proc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read proc at %x"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|ki_op
argument_list|(
name|what
argument_list|)
condition|)
block|{
case|case
name|KINFO_PROC_PID
case|:
if|if
condition|(
name|proc
operator|.
name|p_pid
operator|!=
operator|(
name|pid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
case|case
name|KINFO_PROC_UID
case|:
if|if
condition|(
name|proc
operator|.
name|p_uid
operator|!=
operator|(
name|uid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
case|case
name|KINFO_PROC_RUID
case|:
if|if
condition|(
name|proc
operator|.
name|p_ruid
operator|!=
operator|(
name|uid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
block|}
comment|/* 		 * gather eproc 		 */
name|eproc
operator|.
name|e_paddr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|proc
operator|.
name|p_pgrp
argument_list|,
operator|&
name|pgrp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read pgrp at %x"
argument_list|,
name|proc
operator|.
name|p_pgrp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eproc
operator|.
name|e_sess
operator|=
name|pgrp
operator|.
name|pg_session
expr_stmt|;
name|eproc
operator|.
name|e_pgid
operator|=
name|pgrp
operator|.
name|pg_id
expr_stmt|;
name|eproc
operator|.
name|e_jobc
operator|=
name|pgrp
operator|.
name|pg_jobc
expr_stmt|;
if|if
condition|(
name|kvm_read
argument_list|(
name|pgrp
operator|.
name|pg_session
argument_list|,
operator|&
name|sess
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|session
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|session
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read session at %x"
argument_list|,
name|pgrp
operator|.
name|pg_session
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|proc
operator|.
name|p_flag
operator|&
name|SCTTY
operator|)
operator|&&
name|sess
operator|.
name|s_ttyp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|sess
operator|.
name|s_ttyp
argument_list|,
operator|&
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read tty at %x"
argument_list|,
name|sess
operator|.
name|s_ttyp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eproc
operator|.
name|e_tdev
operator|=
name|tty
operator|.
name|t_dev
expr_stmt|;
name|eproc
operator|.
name|e_tsess
operator|=
name|tty
operator|.
name|t_session
expr_stmt|;
if|if
condition|(
name|tty
operator|.
name|t_pgrp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|tty
operator|.
name|t_pgrp
argument_list|,
operator|&
name|pgrp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|pgrp
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read tpgrp at&x"
argument_list|,
name|tty
operator|.
name|t_pgrp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|eproc
operator|.
name|e_tpgid
operator|=
name|pgrp
operator|.
name|pg_id
expr_stmt|;
block|}
else|else
name|eproc
operator|.
name|e_tpgid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|eproc
operator|.
name|e_tdev
operator|=
name|NODEV
expr_stmt|;
if|if
condition|(
name|proc
operator|.
name|p_wmesg
condition|)
name|kvm_read
argument_list|(
name|proc
operator|.
name|p_wmesg
argument_list|,
name|eproc
operator|.
name|e_wmesg
argument_list|,
name|WMESGLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|.
name|p_textp
condition|)
block|{
name|kvm_read
argument_list|(
name|proc
operator|.
name|p_textp
argument_list|,
operator|&
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|eproc
operator|.
name|e_xsize
operator|=
name|text
operator|.
name|x_size
expr_stmt|;
name|eproc
operator|.
name|e_xrssize
operator|=
name|text
operator|.
name|x_rssize
expr_stmt|;
name|eproc
operator|.
name|e_xccount
operator|=
name|text
operator|.
name|x_ccount
expr_stmt|;
name|eproc
operator|.
name|e_xswrss
operator|=
name|text
operator|.
name|x_swrss
expr_stmt|;
block|}
else|else
block|{
name|eproc
operator|.
name|e_xsize
operator|=
name|eproc
operator|.
name|e_xrssize
operator|=
name|eproc
operator|.
name|e_xccount
operator|=
name|eproc
operator|.
name|e_xswrss
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|ki_op
argument_list|(
name|what
argument_list|)
condition|)
block|{
case|case
name|KINFO_PROC_PGRP
case|:
if|if
condition|(
name|eproc
operator|.
name|e_pgid
operator|!=
operator|(
name|pid_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
case|case
name|KINFO_PROC_TTY
case|:
if|if
condition|(
operator|(
name|proc
operator|.
name|p_flag
operator|&
name|SCTTY
operator|)
operator|==
literal|0
operator|||
name|eproc
operator|.
name|e_tdev
operator|!=
operator|(
name|dev_t
operator|)
name|arg
condition|)
continue|continue;
break|break;
block|}
name|i
operator|++
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|proc
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|eproc
argument_list|,
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eproc
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|eproc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|doingzomb
condition|)
block|{
comment|/* zombproc */
if|if
condition|(
name|kvm_read
argument_list|(
name|nl
index|[
name|X_ZOMBPROC
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|proc
operator|*
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read zombproc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|doingzomb
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|proc
modifier|*
name|kvm_nextproc
parameter_list|()
block|{
if|if
condition|(
operator|!
name|kvmprocbase
operator|&&
name|kvm_getprocs
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|kvmprocptr
operator|>=
operator|(
name|kvmprocbase
operator|+
name|kvmnprocs
operator|)
condition|)
block|{
name|seterr
argument_list|(
literal|"end of proc list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|proc
operator|*
operator|)
operator|(
name|kvmprocptr
operator|++
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|eproc
modifier|*
name|kvm_geteproc
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
operator|(
expr|struct
name|eproc
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_macro
name|kvm_setproc
argument_list|()
end_macro

begin_block
block|{
name|kvmprocptr
operator|=
name|kvmprocbase
expr_stmt|;
block|}
end_block

begin_macro
name|kvm_freeprocs
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|kvmprocbase
condition|)
block|{
name|free
argument_list|(
name|kvmprocbase
argument_list|)
expr_stmt|;
name|kvmprocbase
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_function
name|struct
name|user
modifier|*
name|kvm_getu
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|pte
modifier|*
name|pteaddr
decl_stmt|,
name|apte
decl_stmt|;
name|struct
name|pte
name|arguutl
index|[
name|HIGHPAGES
operator|+
operator|(
name|CLSIZE
operator|*
literal|2
operator|)
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|ncl
decl_stmt|;
if|if
condition|(
name|kvminit
operator|==
literal|0
operator|&&
name|kvm_init
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SZOMB
condition|)
block|{
name|seterr
argument_list|(
literal|"zombie process"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|swap
operator|<
literal|0
condition|)
block|{
name|seterr
argument_list|(
literal|"no swap"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|long
operator|)
name|dtob
argument_list|(
name|p
operator|->
name|p_swaddr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|user
operator|.
name|user
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read u for pid %d from %s\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|swapf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pcbpf
operator|=
literal|0
expr_stmt|;
name|argaddr0
operator|=
literal|0
expr_stmt|;
name|argaddr1
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|user
operator|.
name|user
operator|)
return|;
block|}
name|pteaddr
operator|=
operator|&
name|Usrptmap
index|[
name|btokmx
argument_list|(
name|p
operator|->
name|p_p0br
argument_list|)
operator|+
name|p
operator|->
name|p_szpt
operator|-
literal|1
index|]
expr_stmt|;
name|klseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|pteaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|apte
argument_list|,
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read indir pte to get u for pid %d from %s"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|kmemf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|long
operator|)
name|ctob
argument_list|(
name|pftoc
argument_list|(
name|apte
operator|.
name|pg_pfnum
operator|+
literal|1
argument_list|)
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arguutl
argument_list|,
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read page table for u of pid %d from %s"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|memf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|arguutl
index|[
literal|0
index|]
operator|.
name|pg_fod
operator|==
literal|0
operator|&&
name|arguutl
index|[
literal|0
index|]
operator|.
name|pg_pfnum
condition|)
name|argaddr0
operator|=
name|ctob
argument_list|(
name|pftoc
argument_list|(
name|arguutl
index|[
literal|0
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|argaddr0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arguutl
index|[
name|CLSIZE
operator|*
literal|1
index|]
operator|.
name|pg_fod
operator|==
literal|0
operator|&&
name|arguutl
index|[
name|CLSIZE
operator|*
literal|1
index|]
operator|.
name|pg_pfnum
condition|)
name|argaddr1
operator|=
name|ctob
argument_list|(
name|pftoc
argument_list|(
name|arguutl
index|[
name|CLSIZE
operator|*
literal|1
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|argaddr1
operator|=
literal|0
expr_stmt|;
name|pcbpf
operator|=
name|arguutl
index|[
name|CLSIZE
operator|*
literal|2
index|]
operator|.
name|pg_pfnum
expr_stmt|;
name|ncl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|+
name|CLBYTES
operator|-
literal|1
operator|)
operator|/
name|CLBYTES
expr_stmt|;
while|while
condition|(
operator|--
name|ncl
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|ncl
operator|*
name|CLSIZE
expr_stmt|;
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|long
operator|)
name|ctob
argument_list|(
name|pftoc
argument_list|(
name|arguutl
index|[
operator|(
name|CLSIZE
operator|*
literal|2
operator|)
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|user
operator|.
name|upages
index|[
name|i
index|]
argument_list|,
name|CLBYTES
argument_list|)
operator|!=
name|CLBYTES
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read page %d of u of pid %d from %s"
argument_list|,
name|arguutl
index|[
operator|(
name|CLSIZE
operator|*
literal|2
operator|)
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|memf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|&
name|user
operator|.
name|user
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|kvm_getargs
parameter_list|(
name|p
parameter_list|,
name|up
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|user
modifier|*
name|up
decl_stmt|;
block|{
name|char
name|cmdbuf
index|[
name|CLBYTES
operator|*
literal|2
index|]
decl_stmt|;
union|union
block|{
name|char
name|argc
index|[
name|CLBYTES
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|argi
index|[
name|CLBYTES
operator|*
literal|2
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
block|}
name|argspac
union|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|nbad
decl_stmt|;
name|struct
name|dblock
name|db
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
operator|||
name|p
operator|->
name|p_pid
operator|==
literal|0
operator|||
name|p
operator|->
name|p_pid
operator|==
literal|2
condition|)
goto|goto
name|retucomm
goto|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
operator|||
name|argaddr1
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|swap
operator|<
literal|0
operator|||
name|p
operator|->
name|p_ssize
operator|==
literal|0
condition|)
goto|goto
name|retucomm
goto|;
name|vstodb
argument_list|(
literal|0
argument_list|,
name|CLSIZE
argument_list|,
operator|&
name|up
operator|->
name|u_smap
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|long
operator|)
name|dtob
argument_list|(
name|db
operator|.
name|db_base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|argspac
operator|.
name|argc
index|[
name|CLBYTES
index|]
argument_list|,
name|CLBYTES
argument_list|)
operator|!=
name|CLBYTES
condition|)
goto|goto
name|bad
goto|;
name|vstodb
argument_list|(
literal|1
argument_list|,
name|CLSIZE
argument_list|,
operator|&
name|up
operator|->
name|u_smap
argument_list|,
operator|&
name|db
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|long
operator|)
name|dtob
argument_list|(
name|db
operator|.
name|db_base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|argspac
operator|.
name|argc
index|[
literal|0
index|]
argument_list|,
name|CLBYTES
argument_list|)
operator|!=
name|CLBYTES
condition|)
goto|goto
name|bad
goto|;
name|file
operator|=
name|swapf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argaddr0
condition|)
block|{
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|long
operator|)
name|argaddr0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|argspac
argument_list|,
name|CLBYTES
argument_list|)
operator|!=
name|CLBYTES
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
name|bzero
argument_list|(
operator|&
name|argspac
argument_list|,
name|CLBYTES
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|long
operator|)
name|argaddr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|&
name|argspac
operator|.
name|argc
index|[
name|CLBYTES
index|]
argument_list|,
name|CLBYTES
argument_list|)
operator|!=
name|CLBYTES
condition|)
goto|goto
name|bad
goto|;
name|file
operator|=
name|memf
expr_stmt|;
block|}
name|ip
operator|=
operator|&
name|argspac
operator|.
name|argi
index|[
name|CLBYTES
operator|*
literal|2
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
expr_stmt|;
name|ip
operator|-=
literal|2
expr_stmt|;
comment|/* last arg word and .long 0 */
while|while
condition|(
operator|*
operator|--
name|ip
condition|)
block|{
if|if
condition|(
name|ip
operator|==
name|argspac
operator|.
name|argi
condition|)
goto|goto
name|retucomm
goto|;
block|}
operator|*
operator|(
name|char
operator|*
operator|)
name|ip
operator|=
literal|' '
expr_stmt|;
name|ip
operator|++
expr_stmt|;
name|nbad
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
init|;
name|cp
operator|<
operator|&
name|argspac
operator|.
name|argc
index|[
name|CLBYTES
operator|*
literal|2
index|]
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|cp
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>
literal|0176
condition|)
block|{
if|if
condition|(
operator|++
name|nbad
operator|>=
literal|5
operator|*
operator|(
literal|0
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* eflg -> 0 XXX */
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
operator|*
name|cp
operator|=
literal|'?'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'='
condition|)
block|{
comment|/* eflg -> 0 XXX */
while|while
condition|(
operator|*
operator|--
name|cp
operator|!=
literal|' '
condition|)
if|if
condition|(
name|cp
operator|<=
operator|(
name|char
operator|*
operator|)
name|ip
condition|)
break|break;
break|break;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp
operator|==
literal|' '
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|ip
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|cmdbuf
argument_list|,
name|cp
argument_list|,
operator|&
name|argspac
operator|.
name|argc
index|[
name|CLBYTES
operator|*
literal|2
index|]
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|||
name|cp
index|[
literal|0
index|]
operator|==
literal|'?'
operator|||
name|cp
index|[
literal|0
index|]
operator|<=
literal|' '
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|cmdbuf
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cmdbuf
operator|)
return|;
name|bad
label|:
name|seterr
argument_list|(
literal|"error locating command name for pid %d from %s\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|retucomm
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cmdbuf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|cmdbuf
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|cmdbuf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmdbuf
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|getkvars
argument_list|()
block|{
if|if
condition|(
name|kvm_nlist
argument_list|(
name|nl
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|deadkernel
condition|)
block|{
comment|/* We must do the sys map first because klseek uses it */
name|long
name|addr
decl_stmt|;
name|Syssize
operator|=
name|nl
index|[
name|X_SYSSIZE
index|]
operator|.
name|n_value
expr_stmt|;
name|Sysmap
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|Syssize
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Sysmap
operator|==
name|NULL
condition|)
block|{
name|seterr
argument_list|(
literal|"out of space for Sysmap"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|addr
operator|=
operator|(
name|long
operator|)
name|nl
index|[
name|X_SYSMAP
index|]
operator|.
name|n_value
expr_stmt|;
name|addr
operator|&=
operator|~
name|KERNBASE
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Sysmap
argument_list|,
name|Syssize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|)
operator|!=
name|Syssize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read Sysmap"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
name|addr
operator|=
operator|(
name|long
operator|)
name|nl
index|[
name|X_LOWRAM
index|]
operator|.
name|n_value
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lowram
argument_list|,
sizeof|sizeof
argument_list|(
name|lowram
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lowram
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read lowram"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lowram
operator|=
name|btop
argument_list|(
name|lowram
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_if

begin_expr_stmt
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Usrptmap
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPTMAP
index|]
operator|.
name|n_value
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_NSWAP
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|nswap
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read nswap"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_DMMIN
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|dmmin
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read dmmin"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|kvm_read
argument_list|(
operator|(
name|long
operator|)
name|nl
index|[
name|X_DMMAX
index|]
operator|.
name|n_value
argument_list|,
operator|&
name|dmmax
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|seterr
argument_list|(
literal|"can't read dmmax"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_expr_stmt
unit|}  kvm_read
operator|(
name|loc
operator|,
name|buf
operator|,
name|len
operator|)
name|unsigned
name|long
name|loc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|kvmfilesopen
operator|==
literal|0
operator|&&
name|kvm_openfiles
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|iskva
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|klseek
argument_list|(
name|kmem
argument_list|,
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|seterr
argument_list|(
literal|"error reading kmem at %x\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|lseek
argument_list|(
name|mem
argument_list|,
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|seterr
argument_list|(
literal|"error reading mem at %x\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|klseek
argument_list|(
argument|fd
argument_list|,
argument|loc
argument_list|,
argument|off
argument_list|)
name|int
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|off_t
name|loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|deadkernel
condition|)
block|{
name|off_t
name|vtophys
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|loc
operator|=
name|vtophys
argument_list|(
name|loc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|loc
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Given a base/size pair in virtual swap area,  * return a physical base/size pair which is the  * (largest) initial, physically contiguous block.  */
end_comment

begin_expr_stmt
specifier|static
name|vstodb
argument_list|(
name|vsbase
argument_list|,
name|vssize
argument_list|,
name|dmp
argument_list|,
name|dbp
argument_list|,
name|rev
argument_list|)
specifier|register
name|int
name|vsbase
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vssize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dmap
modifier|*
name|dmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|dblock
modifier|*
name|dbp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|blk
init|=
name|dmmin
decl_stmt|;
specifier|register
name|swblk_t
modifier|*
name|ip
init|=
name|dmp
operator|->
name|dm_map
decl_stmt|;
name|vsbase
operator|=
name|ctod
argument_list|(
name|vsbase
argument_list|)
expr_stmt|;
name|vssize
operator|=
name|ctod
argument_list|(
name|vssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsbase
operator|<
literal|0
operator|||
name|vsbase
operator|+
name|vssize
operator|>
name|dmp
operator|->
name|dm_size
condition|)
comment|/*panic("vstodb")*/
empty_stmt|;
while|while
condition|(
name|vsbase
operator|>=
name|blk
condition|)
block|{
name|vsbase
operator|-=
name|blk
expr_stmt|;
if|if
condition|(
name|blk
operator|<
name|dmmax
condition|)
name|blk
operator|*=
literal|2
expr_stmt|;
name|ip
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ip
operator|<=
literal|0
operator|||
operator|*
name|ip
operator|+
name|blk
operator|>
name|nswap
condition|)
comment|/*panic("vstodb")*/
empty_stmt|;
name|dbp
operator|->
name|db_size
operator|=
name|MIN
argument_list|(
name|vssize
argument_list|,
name|blk
operator|-
name|vsbase
argument_list|)
expr_stmt|;
name|dbp
operator|->
name|db_base
operator|=
operator|*
name|ip
operator|+
operator|(
name|rev
condition|?
name|blk
operator|-
operator|(
name|vsbase
operator|+
name|dbp
operator|->
name|db_size
operator|)
else|:
name|vsbase
operator|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|off_t
name|vtophys
parameter_list|(
name|loc
parameter_list|)
name|long
name|loc
decl_stmt|;
block|{
name|int
name|p
decl_stmt|;
name|off_t
name|newloc
decl_stmt|;
specifier|register
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
name|newloc
operator|=
name|loc
operator|&
operator|~
name|KERNBASE
expr_stmt|;
name|p
operator|=
name|btop
argument_list|(
name|newloc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
if|if
condition|(
operator|(
name|loc
operator|&
name|KERNBASE
operator|)
operator|==
literal|0
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: translating non-kernel address"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|>=
name|Syssize
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: page out of bound (%d>=%d)"
argument_list|,
name|p
argument_list|,
name|Syssize
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|pte
operator|=
operator|&
name|Sysmap
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|pte
operator|->
name|pg_v
operator|==
literal|0
operator|&&
operator|(
name|pte
operator|->
name|pg_fod
operator|||
name|pte
operator|->
name|pg_pfnum
operator|==
literal|0
operator|)
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: page not valid"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|hp300
argument_list|)
if|if
condition|(
name|pte
operator|->
name|pg_pfnum
operator|<
name|lowram
condition|)
block|{
name|seterr
argument_list|(
literal|"vtophys: non-RAM page (%d<%d)"
argument_list|,
name|pte
operator|->
name|pg_pfnum
argument_list|,
name|lowram
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|off_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|loc
operator|=
call|(
name|long
call|)
argument_list|(
name|ptob
argument_list|(
name|pftoc
argument_list|(
name|pte
operator|->
name|pg_pfnum
argument_list|)
argument_list|)
operator|+
operator|(
name|loc
operator|&
name|PGOFSET
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|loc
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|errbuf
index|[
name|LINE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|seterr
argument_list|(
argument|va_alist
argument_list|)
name|va_dcl
block|{
name|char
operator|*
name|fmt
block|;
name|va_list
name|ap
block|;
name|va_start
argument_list|(
name|ap
argument_list|)
block|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
block|;
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|errbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
block|;
name|va_end
argument_list|(
name|ap
argument_list|)
block|; }
specifier|static
name|setsyserr
argument_list|(
argument|va_alist
argument_list|)
name|va_dcl
block|{
name|char
operator|*
name|fmt
block|,
operator|*
name|cp
block|;
name|va_list
name|ap
block|;
specifier|extern
name|int
name|errno
block|;
name|va_start
argument_list|(
name|ap
argument_list|)
block|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
block|;
operator|(
name|void
operator|)
name|vsprintf
argument_list|(
name|errbuf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
block|;
for|for
control|(
name|cp
operator|=
name|errbuf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  char
operator|*
name|kvm_geterr
argument_list|()
block|{
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
end_expr_stmt

end_unit

