begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|version
index|[]
init|=
literal|"@(#)setup.c	3.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"fsck.h"
end_include

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|setup
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dev_t
name|rootdev
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|daddr_t
name|super
init|=
name|bflag
condition|?
name|bflag
else|:
name|SBLOCK
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|long
name|size
decl_stmt|;
name|BUFAREA
name|asblk
decl_stmt|;
define|#
directive|define
name|altsblock
value|asblk.b_un.b_fs
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
name|rootdev
operator|=
name|statb
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dev
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rawflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFBLK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
name|rawflg
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reply
argument_list|(
literal|"file is not a block or character device; OK"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rootdev
operator|==
name|statb
operator|.
name|st_rdev
condition|)
name|hotroot
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dfile
operator|.
name|rfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Can't open %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** %s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
operator|(
name|dfile
operator|.
name|wfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dfile
operator|.
name|wfdes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"NO WRITE ACCESS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (NO WRITE)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dfile
operator|.
name|mod
operator|=
literal|0
expr_stmt|;
name|muldup
operator|=
name|enddup
operator|=
operator|&
name|duplist
index|[
literal|0
index|]
expr_stmt|;
name|badlnp
operator|=
operator|&
name|badlncnt
index|[
literal|0
index|]
expr_stmt|;
name|lfdir
operator|=
literal|0
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|sblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|inoblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|cgblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|asblk
argument_list|)
expr_stmt|;
comment|/* 	 * Read in the super block and its summary info. 	 */
if|if
condition|(
name|bread
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|super
argument_list|,
operator|(
name|long
operator|)
name|SBSIZE
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sblk
operator|.
name|b_bno
operator|=
name|super
expr_stmt|;
name|sblk
operator|.
name|b_size
operator|=
name|SBSIZE
expr_stmt|;
comment|/* 	 * run a few consistency checks of the super block 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|badsb
argument_list|(
literal|"MAGIC NUMBER WRONG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|<
literal|1
condition|)
block|{
name|badsb
argument_list|(
literal|"NCG OUT OF RANGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|<
literal|1
operator|||
name|sblock
operator|.
name|fs_cpg
operator|>
name|MAXCPG
condition|)
block|{
name|badsb
argument_list|(
literal|"CPG OUT OF RANGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_cpg
operator|<
name|sblock
operator|.
name|fs_ncyl
operator|||
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_cpg
operator|>=
name|sblock
operator|.
name|fs_ncyl
condition|)
block|{
name|badsb
argument_list|(
literal|"NCYL DOES NOT JIVE WITH NCG*CPG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_sbsize
operator|>
name|SBSIZE
condition|)
block|{
name|badsb
argument_list|(
literal|"SIZE PREPOSTEROUSLY LARGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set all possible fields that could differ, then do check 	 * of whole super block against an alternate super block. 	 * When an alternate super-block is specified this check is skipped. 	 */
if|if
condition|(
name|bflag
condition|)
goto|goto
name|sbok
goto|;
name|getblk
argument_list|(
operator|&
name|asblk
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_sbsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|asblk
operator|.
name|b_errs
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|altsblock
operator|.
name|fs_link
operator|=
name|sblock
operator|.
name|fs_link
expr_stmt|;
name|altsblock
operator|.
name|fs_rlink
operator|=
name|sblock
operator|.
name|fs_rlink
expr_stmt|;
name|altsblock
operator|.
name|fs_time
operator|=
name|sblock
operator|.
name|fs_time
expr_stmt|;
name|altsblock
operator|.
name|fs_cstotal
operator|=
name|sblock
operator|.
name|fs_cstotal
expr_stmt|;
name|altsblock
operator|.
name|fs_cgrotor
operator|=
name|sblock
operator|.
name|fs_cgrotor
expr_stmt|;
name|altsblock
operator|.
name|fs_fmod
operator|=
name|sblock
operator|.
name|fs_fmod
expr_stmt|;
name|altsblock
operator|.
name|fs_clean
operator|=
name|sblock
operator|.
name|fs_clean
expr_stmt|;
name|altsblock
operator|.
name|fs_ronly
operator|=
name|sblock
operator|.
name|fs_ronly
expr_stmt|;
name|altsblock
operator|.
name|fs_flags
operator|=
name|sblock
operator|.
name|fs_flags
expr_stmt|;
name|altsblock
operator|.
name|fs_maxcontig
operator|=
name|sblock
operator|.
name|fs_maxcontig
expr_stmt|;
name|altsblock
operator|.
name|fs_minfree
operator|=
name|sblock
operator|.
name|fs_minfree
expr_stmt|;
name|altsblock
operator|.
name|fs_rotdelay
operator|=
name|sblock
operator|.
name|fs_rotdelay
expr_stmt|;
name|altsblock
operator|.
name|fs_maxbpg
operator|=
name|sblock
operator|.
name|fs_maxbpg
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|altsblock
operator|.
name|fs_csp
argument_list|,
sizeof|sizeof
name|sblock
operator|.
name|fs_csp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_fsmnt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|altsblock
operator|.
name|fs_fsmnt
argument_list|,
sizeof|sizeof
name|sblock
operator|.
name|fs_fsmnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|altsblock
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_sbsize
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"TRASHED VALUES IN SUPER BLOCK"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sbok
label|:
name|fmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|imax
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
comment|/* 	 * read in the summary info. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
operator|,
name|j
operator|++
control|)
block|{
name|size
operator|=
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
condition|?
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
else|:
name|sblock
operator|.
name|fs_bsize
expr_stmt|;
name|sblock
operator|.
name|fs_csp
index|[
name|j
index|]
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
index|[
name|j
index|]
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|j
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|)
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * allocate and initialize the necessary maps 	 */
name|bmapsz
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
name|fmax
argument_list|,
name|NBBY
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|blockmap
operator|=
name|calloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bmapsz
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockmap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for blockmap\n"
argument_list|,
name|bmapsz
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
name|statemap
operator|=
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|statemap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for statemap\n"
argument_list|,
name|imax
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
name|lncntp
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lncntp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cannot alloc %d bytes for lncntp\n"
argument_list|,
operator|(
name|imax
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|badsb
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|badsb
label|:
name|ckfini
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|altsblock
block|}
end_block

begin_macro
name|badsb
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD SUPER BLOCK: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pwarn
argument_list|(
literal|"USE -b OPTION TO FSCK TO SPECIFY LOCATION OF AN ALTERNATE\n"
argument_list|)
expr_stmt|;
name|pfatal
argument_list|(
literal|"SUPER-BLOCK TO SUPPLY NEEDED INFORMATION; SEE fsck(8).\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

