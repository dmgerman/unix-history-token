begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)main.c	1.15 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/fs.h"
end_include

begin_include
include|#
directive|include
file|"../h/dir.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/stat.h"
end_include

begin_include
include|#
directive|include
file|"../h/ostat.h"
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|SIG_TYP
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|NDIRECT
parameter_list|(
name|fs
parameter_list|)
value|((fs)->fs_bsize / sizeof(struct direct))
end_define

begin_define
define|#
directive|define
name|MAXNDIRECT
value|(MAXBSIZE / sizeof(struct direct))
end_define

begin_define
define|#
directive|define
name|MAXINOPB
value|(MAXBSIZE / sizeof(struct dinode))
end_define

begin_define
define|#
directive|define
name|MAXNINDIR
value|(MAXBSIZE / sizeof(daddr_t))
end_define

begin_define
define|#
directive|define
name|SPERB
value|(MAXBSIZE / sizeof(short))
end_define

begin_define
define|#
directive|define
name|MAXDUP
value|10
end_define

begin_comment
comment|/* limit on dup blks (per inode) */
end_comment

begin_define
define|#
directive|define
name|MAXBAD
value|10
end_define

begin_comment
comment|/* limit on bad blks (per inode) */
end_comment

begin_define
define|#
directive|define
name|USTATE
value|0
end_define

begin_comment
comment|/* inode not allocated */
end_comment

begin_define
define|#
directive|define
name|FSTATE
value|01
end_define

begin_comment
comment|/* inode is file */
end_comment

begin_define
define|#
directive|define
name|DSTATE
value|02
end_define

begin_comment
comment|/* inode is directory */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|03
end_define

begin_comment
comment|/* inode is to be cleared */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dinode
name|DINODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|direct
name|DIRECT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ALLOC
value|((dp->di_mode& IFMT) != 0)
end_define

begin_define
define|#
directive|define
name|DIR
value|((dp->di_mode& IFMT) == IFDIR)
end_define

begin_define
define|#
directive|define
name|REG
value|((dp->di_mode& IFMT) == IFREG)
end_define

begin_define
define|#
directive|define
name|BLK
value|((dp->di_mode& IFMT) == IFBLK)
end_define

begin_define
define|#
directive|define
name|CHR
value|((dp->di_mode& IFMT) == IFCHR)
end_define

begin_define
define|#
directive|define
name|MPC
value|((dp->di_mode& IFMT) == IFMPC)
end_define

begin_define
define|#
directive|define
name|MPB
value|((dp->di_mode& IFMT) == IFMPB)
end_define

begin_define
define|#
directive|define
name|SPECIAL
value|(BLK || CHR || MPC || MPB)
end_define

begin_decl_stmt
name|ino_t
name|startinum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blk num of first in raw area */
end_comment

begin_struct
struct|struct
name|bufarea
block|{
name|struct
name|bufarea
modifier|*
name|b_next
decl_stmt|;
comment|/* must be first */
name|daddr_t
name|b_bno
decl_stmt|;
name|int
name|b_size
decl_stmt|;
union|union
block|{
name|char
name|b_buf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
comment|/* buffer space */
name|short
name|b_lnks
index|[
name|SPERB
index|]
decl_stmt|;
comment|/* link counts */
name|daddr_t
name|b_indir
index|[
name|MAXNINDIR
index|]
decl_stmt|;
comment|/* indirect block */
name|struct
name|fs
name|b_fs
decl_stmt|;
comment|/* super block */
name|struct
name|cg
name|b_cg
decl_stmt|;
comment|/* cylinder group */
name|struct
name|dinode
name|b_dinode
index|[
name|MAXINOPB
index|]
decl_stmt|;
comment|/* inode block */
name|DIRECT
name|b_dir
index|[
name|MAXNDIRECT
index|]
decl_stmt|;
comment|/* directory */
block|}
name|b_un
union|;
name|char
name|b_dirty
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|bufarea
name|BUFAREA
typedef|;
end_typedef

begin_decl_stmt
name|BUFAREA
name|inoblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode blocks */
end_comment

begin_decl_stmt
name|BUFAREA
name|fileblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other blks in filesys */
end_comment

begin_decl_stmt
name|BUFAREA
name|sblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file system superblock */
end_comment

begin_decl_stmt
name|BUFAREA
name|cgblk
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|initbarea
parameter_list|(
name|x
parameter_list|)
value|(x)->b_dirty = 0;(x)->b_bno = (daddr_t)-1
end_define

begin_define
define|#
directive|define
name|dirty
parameter_list|(
name|x
parameter_list|)
value|(x)->b_dirty = 1
end_define

begin_define
define|#
directive|define
name|inodirty
parameter_list|()
value|inoblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|sbdirty
parameter_list|()
value|sblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|cgdirty
parameter_list|()
value|cgblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|dirblk
value|fileblk.b_un
end_define

begin_define
define|#
directive|define
name|sblock
value|sblk.b_un.b_fs
end_define

begin_define
define|#
directive|define
name|cgrp
value|cgblk.b_un.b_cg
end_define

begin_struct
struct|struct
name|filecntl
block|{
name|int
name|rfdes
decl_stmt|;
name|int
name|wfdes
decl_stmt|;
name|int
name|mod
decl_stmt|;
block|}
name|dfile
struct|;
end_struct

begin_comment
comment|/* file descriptors for filesys */
end_comment

begin_define
define|#
directive|define
name|DUPTBLSIZE
value|100
end_define

begin_comment
comment|/* num of dup blocks to remember */
end_comment

begin_decl_stmt
name|daddr_t
name|duplist
index|[
name|DUPTBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dup block table */
end_comment

begin_decl_stmt
name|daddr_t
modifier|*
name|enddup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry in dup table */
end_comment

begin_decl_stmt
name|daddr_t
modifier|*
name|muldup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* multiple dups part of table */
end_comment

begin_define
define|#
directive|define
name|MAXLNCNT
value|20
end_define

begin_comment
comment|/* num zero link cnts to remember */
end_comment

begin_decl_stmt
name|ino_t
name|badlncnt
index|[
name|MAXLNCNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of inos with zero link cnts */
end_comment

begin_decl_stmt
name|ino_t
modifier|*
name|badlnp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry in table */
end_comment

begin_decl_stmt
name|char
name|rawflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume a no response */
end_comment

begin_decl_stmt
name|char
name|yflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume a yes response */
end_comment

begin_decl_stmt
name|int
name|bflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* location of alternate super block */
end_comment

begin_decl_stmt
name|char
name|preen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just fix normal inconsistencies */
end_comment

begin_decl_stmt
name|char
name|rplyflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* any questions asked? */
end_comment

begin_decl_stmt
name|char
name|hotroot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* checking root device */
end_comment

begin_decl_stmt
name|char
name|fixcg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* corrupted free list bit maps */
end_comment

begin_decl_stmt
name|char
modifier|*
name|blkmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to primary blk allocation map */
end_comment

begin_decl_stmt
name|char
modifier|*
name|freemap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to secondary blk allocation map */
end_comment

begin_decl_stmt
name|char
modifier|*
name|statemap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to inode state table */
end_comment

begin_decl_stmt
name|short
modifier|*
name|lncntp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to link count table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pathp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to pathname position */
end_comment

begin_decl_stmt
name|char
modifier|*
name|thisname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to current pathname component */
end_comment

begin_decl_stmt
name|char
modifier|*
name|srchname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name being searched for in dir */
end_comment

begin_decl_stmt
name|char
name|pathname
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lfname
init|=
literal|"lost+found"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|inum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode we are currently working on */
end_comment

begin_decl_stmt
name|ino_t
name|imax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of inodes */
end_comment

begin_decl_stmt
name|ino_t
name|parentdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i number of parent directory */
end_comment

begin_decl_stmt
name|ino_t
name|lastino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hiwater mark of inodes */
end_comment

begin_decl_stmt
name|ino_t
name|lfdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lost& found directory */
end_comment

begin_decl_stmt
name|ino_t
name|orphan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphaned inode */
end_comment

begin_decl_stmt
name|off_t
name|filsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num blks seen in file */
end_comment

begin_decl_stmt
name|off_t
name|maxblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* largest logical blk in file */
end_comment

begin_decl_stmt
name|off_t
name|bmapsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num chars in blkmap */
end_comment

begin_decl_stmt
name|daddr_t
name|n_ffree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of small free blocks */
end_comment

begin_decl_stmt
name|daddr_t
name|n_bfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of large free blocks */
end_comment

begin_decl_stmt
name|daddr_t
name|n_blks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks used */
end_comment

begin_decl_stmt
name|daddr_t
name|n_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files seen */
end_comment

begin_decl_stmt
name|daddr_t
name|n_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|n_bad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|fmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks in the volume */
end_comment

begin_decl_stmt
name|daddr_t
name|badblk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|dupblk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inosumbad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|offsumbad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|frsumbad
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zapino
parameter_list|(
name|x
parameter_list|)
value|(*(x) = zino)
end_define

begin_decl_stmt
name|struct
name|dinode
name|zino
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|setlncnt
parameter_list|(
name|x
parameter_list|)
value|(lncntp[inum] = x)
end_define

begin_define
define|#
directive|define
name|getlncnt
parameter_list|()
value|(lncntp[inum])
end_define

begin_define
define|#
directive|define
name|declncnt
parameter_list|()
value|(--lncntp[inum])
end_define

begin_define
define|#
directive|define
name|setbmap
parameter_list|(
name|x
parameter_list|)
value|setbit(blkmap, x)
end_define

begin_define
define|#
directive|define
name|getbmap
parameter_list|(
name|x
parameter_list|)
value|isset(blkmap, x)
end_define

begin_define
define|#
directive|define
name|clrbmap
parameter_list|(
name|x
parameter_list|)
value|clrbit(blkmap, x)
end_define

begin_define
define|#
directive|define
name|setfmap
parameter_list|(
name|x
parameter_list|)
value|setbit(freemap, x)
end_define

begin_define
define|#
directive|define
name|getfmap
parameter_list|(
name|x
parameter_list|)
value|isset(freemap, x)
end_define

begin_define
define|#
directive|define
name|clrfmap
parameter_list|(
name|x
parameter_list|)
value|clrbit(freemap, x)
end_define

begin_define
define|#
directive|define
name|setstate
parameter_list|(
name|x
parameter_list|)
value|(statemap[inum] = x)
end_define

begin_define
define|#
directive|define
name|getstate
parameter_list|()
value|statemap[inum]
end_define

begin_define
define|#
directive|define
name|DATA
value|1
end_define

begin_define
define|#
directive|define
name|ADDR
value|0
end_define

begin_define
define|#
directive|define
name|ALTERD
value|010
end_define

begin_define
define|#
directive|define
name|KEEPON
value|04
end_define

begin_define
define|#
directive|define
name|SKIP
value|02
end_define

begin_define
define|#
directive|define
name|STOP
value|01
end_define

begin_expr_stmt
name|int
argument_list|(
operator|*
name|signal
argument_list|()
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DINODE
modifier|*
name|ginode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|BUFAREA
modifier|*
name|getblk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dirscan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|findino
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|catch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mkentry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chgdd
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|pass1
argument_list|()
decl_stmt|,
name|pass1b
argument_list|()
decl_stmt|,
name|pass2
argument_list|()
decl_stmt|,
name|pass4
argument_list|()
decl_stmt|,
name|pass5
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|rawname
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|unrawname
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inside
index|[]
decl_stmt|,
name|around
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
modifier|*
name|fragtbl
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|devname
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|fstab
modifier|*
name|fsp
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|passno
decl_stmt|,
name|anygtr
decl_stmt|,
name|sumstatus
decl_stmt|;
name|sync
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
block|{
case|case
literal|'p'
case|:
name|preen
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bflag
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Alternate super block location: %d\n"
argument_list|,
name|bflag
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* default no answer flag */
case|case
literal|'N'
case|:
name|nflag
operator|++
expr_stmt|;
name|yflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* default yes answer flag */
case|case
literal|'Y'
case|:
name|yflag
operator|++
expr_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|errexit
argument_list|(
literal|"%c option?\n"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|hotroot
operator|=
literal|0
expr_stmt|;
name|check
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|sumstatus
operator|=
literal|0
expr_stmt|;
name|passno
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|anygtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setfsent
argument_list|()
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't open checklist file: %s\n"
argument_list|,
name|FSTAB
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fsp
operator|=
name|getfsent
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RW
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RO
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|preen
operator|==
literal|0
operator|||
name|passno
operator|==
literal|1
operator|&&
name|fsp
operator|->
name|fs_passno
operator|==
name|passno
condition|)
block|{
if|if
condition|(
name|blockcheck
argument_list|(
name|fsp
operator|->
name|fs_spec
argument_list|)
operator|==
literal|0
operator|&&
name|preen
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsp
operator|->
name|fs_passno
operator|>
name|passno
condition|)
name|anygtr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fsp
operator|->
name|fs_passno
operator|==
name|passno
condition|)
block|{
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
if|if
condition|(
name|blockcheck
argument_list|(
name|fsp
operator|->
name|fs_spec
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preen
condition|)
block|{
name|int
name|status
decl_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sumstatus
operator||=
name|status
expr_stmt|;
block|}
name|passno
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|anygtr
condition|)
do|;
if|if
condition|(
name|sumstatus
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|endfsent
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|blockcheck
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ostat
name|stslash
decl_stmt|,
name|stblock
decl_stmt|,
name|stchar
decl_stmt|;
name|char
modifier|*
name|raw
decl_stmt|;
name|int
name|looped
init|=
literal|0
decl_stmt|;
name|hotroot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|stslash
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|retry
label|:
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stblock
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stblock
operator|.
name|st_mode
operator|&
name|S_IFBLK
condition|)
block|{
name|raw
operator|=
name|rawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|raw
argument_list|,
operator|&
name|stchar
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stchar
operator|.
name|st_mode
operator|&
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|stslash
operator|.
name|st_dev
operator|==
name|stblock
operator|.
name|st_rdev
condition|)
block|{
name|hotroot
operator|++
expr_stmt|;
name|raw
operator|=
name|unrawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|check
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%s is not a character device\n"
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stblock
operator|.
name|st_mode
operator|&
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|looped
condition|)
block|{
name|error
argument_list|(
literal|"Can't make sense out of name %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|name
operator|=
name|unrawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|looped
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"Can't make sense out of name %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|unrawname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|dp
init|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|struct
name|ostat
name|stb
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|!=
literal|'r'
condition|)
return|return
operator|(
name|cp
operator|)
return|;
name|strcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
name|dp
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rawname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|rawbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|dp
init|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|rawbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
literal|'/'
expr_stmt|;
name|strcat
argument_list|(
name|rawbuf
argument_list|,
literal|"/r"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rawbuf
argument_list|,
name|dp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rawbuf
operator|)
return|;
block|}
end_function

begin_macro
name|check
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|ino_t
modifier|*
name|blp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|ino_t
name|savino
decl_stmt|;
name|int
name|b
decl_stmt|,
name|c
decl_stmt|;
name|daddr_t
name|d
decl_stmt|,
name|s
decl_stmt|;
name|devname
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|setup
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"CAN'T CHECK DEVICE."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 1 */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|hotroot
condition|)
name|printf
argument_list|(
literal|"** Root file system\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Phase 1 - Check Blocks and Sizes\n"
argument_list|)
expr_stmt|;
block|}
name|pfunc
operator|=
name|pass1
expr_stmt|;
name|inum
operator|=
literal|0
expr_stmt|;
name|n_blks
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|*
name|sblock
operator|.
name|fs_frag
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|cgblk
argument_list|,
name|cgtod
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
name|i
operator|++
operator|,
name|inum
operator|++
control|)
block|{
name|dp
operator|=
name|ginode
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ALLOC
condition|)
block|{
if|if
condition|(
operator|!
name|isset
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* 					printf("%d bad, not used\n", inum); 					*/
name|inosumbad
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|lastino
operator|=
name|inum
expr_stmt|;
if|if
condition|(
name|ftypeok
argument_list|(
name|dp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"UNKNOWN FILE TYPE I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|n_files
operator|++
expr_stmt|;
if|if
condition|(
name|setlncnt
argument_list|(
name|dp
operator|->
name|di_nlink
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|badlnp
operator|<
operator|&
name|badlncnt
index|[
name|MAXLNCNT
index|]
condition|)
operator|*
name|badlnp
operator|++
operator|=
name|inum
expr_stmt|;
else|else
block|{
name|pfatal
argument_list|(
literal|"LINK COUNT TABLE OVERFLOW"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|setstate
argument_list|(
name|DIR
condition|?
name|DSTATE
else|:
name|FSTATE
argument_list|)
expr_stmt|;
name|badblk
operator|=
name|dupblk
operator|=
literal|0
expr_stmt|;
name|filsize
operator|=
literal|0
expr_stmt|;
name|maxblk
operator|=
literal|0
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|DIR
operator|&&
name|dp
operator|->
name|di_size
operator|%
sizeof|sizeof
argument_list|(
name|DIRECT
argument_list|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"DIRECTORY MISALIGNED I=%u\n"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* 					printf("%d bad, marked used\n", inum); 					*/
name|inosumbad
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|di_mode
operator|!=
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"PARTIALLY ALLOCATED INODE I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|n
operator|!=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
condition|)
block|{
name|printf
argument_list|(
literal|"cg[%d].cg_cs.cs_nifree is %d not %d\n"
argument_list|,
name|c
argument_list|,
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
block|}
comment|/* 1b */
if|if
condition|(
name|enddup
operator|!=
operator|&
name|duplist
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"INTERNAL ERROR: dups with -p"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Phase 1b - Rescan For More DUPS\n"
argument_list|)
expr_stmt|;
name|pfunc
operator|=
name|pass1b
expr_stmt|;
name|inum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
name|i
operator|++
operator|,
name|inum
operator|++
control|)
block|{
name|dp
operator|=
name|ginode
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|getstate
argument_list|()
operator|!=
name|USTATE
operator|&&
operator|(
name|ckinode
argument_list|(
name|dp
argument_list|,
name|ADDR
argument_list|)
operator|&
name|STOP
operator|)
condition|)
goto|goto
name|out1b
goto|;
block|}
block|}
block|}
name|out1b
label|:
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|inoblk
argument_list|)
expr_stmt|;
comment|/* 2 */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 2 - Check Pathnames\n"
argument_list|)
expr_stmt|;
name|inum
operator|=
name|ROOTINO
expr_stmt|;
name|thisname
operator|=
name|pathp
operator|=
name|pathname
expr_stmt|;
name|pfunc
operator|=
name|pass2
expr_stmt|;
switch|switch
condition|(
name|getstate
argument_list|()
condition|)
block|{
case|case
name|USTATE
case|:
name|errexit
argument_list|(
literal|"ROOT INODE UNALLOCATED. TERMINATING.\n"
argument_list|)
expr_stmt|;
case|case
name|FSTATE
case|:
name|pfatal
argument_list|(
literal|"ROOT INODE NOT DIRECTORY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_mode
operator|&=
operator|~
name|IFMT
expr_stmt|;
name|dp
operator|->
name|di_mode
operator||=
name|IFDIR
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
name|setstate
argument_list|(
name|DSTATE
argument_list|)
expr_stmt|;
comment|/* fall into ... */
case|case
name|DSTATE
case|:
name|descend
argument_list|()
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|pfatal
argument_list|(
literal|"DUPS/BAD IN ROOT INODE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|setstate
argument_list|(
name|DSTATE
argument_list|)
expr_stmt|;
name|descend
argument_list|()
expr_stmt|;
block|}
comment|/* 3 */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 3 - Check Connectivity\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|inum
operator|=
name|ROOTINO
init|;
name|inum
operator|<=
name|lastino
condition|;
name|inum
operator|++
control|)
block|{
if|if
condition|(
name|getstate
argument_list|()
operator|==
name|DSTATE
condition|)
block|{
name|pfunc
operator|=
name|findino
expr_stmt|;
name|srchname
operator|=
literal|".."
expr_stmt|;
name|savino
operator|=
name|inum
expr_stmt|;
do|do
block|{
name|orphan
operator|=
name|inum
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
break|break;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|parentdir
operator|=
literal|0
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inum
operator|=
name|parentdir
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|getstate
argument_list|()
operator|==
name|DSTATE
condition|)
do|;
name|inum
operator|=
name|orphan
expr_stmt|;
if|if
condition|(
name|linkup
argument_list|()
operator|==
literal|1
condition|)
block|{
name|thisname
operator|=
name|pathp
operator|=
name|pathname
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'?'
expr_stmt|;
name|pfunc
operator|=
name|pass2
expr_stmt|;
name|descend
argument_list|()
expr_stmt|;
block|}
name|inum
operator|=
name|savino
expr_stmt|;
block|}
block|}
comment|/* 4 */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 4 - Check Reference Counts\n"
argument_list|)
expr_stmt|;
name|pfunc
operator|=
name|pass4
expr_stmt|;
for|for
control|(
name|inum
operator|=
name|ROOTINO
init|;
name|inum
operator|<=
name|lastino
condition|;
name|inum
operator|++
control|)
block|{
switch|switch
condition|(
name|getstate
argument_list|()
condition|)
block|{
case|case
name|FSTATE
case|:
if|if
condition|(
name|n
operator|=
name|getlncnt
argument_list|()
condition|)
name|adjust
argument_list|(
operator|(
name|short
operator|)
name|n
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|blp
operator|=
name|badlncnt
init|;
name|blp
operator|<
name|badlnp
condition|;
name|blp
operator|++
control|)
if|if
condition|(
operator|*
name|blp
operator|==
name|inum
condition|)
block|{
name|clri
argument_list|(
literal|"UNREF"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|DSTATE
case|:
name|clri
argument_list|(
literal|"UNREF"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|clri
argument_list|(
literal|"BAD/DUP"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|imax
operator|-
name|ROOTINO
operator|-
name|n_files
operator|!=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
condition|)
block|{
name|pwarn
argument_list|(
literal|"FREE INODE COUNT WRONG IN SUPERBLK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (FIXED)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|=
name|imax
operator|-
name|n_files
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
block|}
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
comment|/* 5 */
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 5 - Check Cyl groups\n"
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|blkmap
argument_list|,
name|freemap
argument_list|,
operator|(
name|unsigned
operator|)
name|bmapsz
argument_list|)
expr_stmt|;
name|dupblk
operator|=
literal|0
expr_stmt|;
name|n_index
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
operator|(
name|cgdmin
argument_list|(
literal|0
argument_list|,
operator|&
name|sblock
argument_list|)
operator|-
name|cgtod
argument_list|(
literal|0
argument_list|,
operator|&
name|sblock
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
name|daddr_t
name|cbase
init|=
name|cgbase
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
decl_stmt|;
name|short
name|bo
index|[
name|MAXCPG
index|]
index|[
name|NRPOS
index|]
decl_stmt|;
name|long
name|frsum
index|[
name|MAXFRAG
index|]
decl_stmt|;
name|int
name|blk
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sblock
operator|.
name|fs_cpg
condition|;
name|n
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRPOS
condition|;
name|i
operator|++
control|)
name|bo
index|[
name|n
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
name|frsum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * need to account for the spare boot and super blocks 		 * which appear (inaccurately) bad 		 */
name|n_bad
operator|+=
name|cgtod
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|cgblk
argument_list|,
name|cgtod
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|sblock
operator|.
name|fs_fpg
condition|;
name|b
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgrp
operator|.
name|cg_free
argument_list|,
name|b
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
block|{
if|if
condition|(
name|pass5
argument_list|(
name|cbase
operator|+
name|b
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|==
name|STOP
condition|)
goto|goto
name|out5
goto|;
comment|/* this is clumsy ... */
name|n_ffree
operator|-=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|n_bfree
operator|++
expr_stmt|;
name|s
operator|=
name|b
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|bo
index|[
name|s
operator|/
name|sblock
operator|.
name|fs_spc
index|]
index|[
name|s
operator|%
name|sblock
operator|.
name|fs_nsect
operator|*
name|NRPOS
operator|/
name|sblock
operator|.
name|fs_nsect
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|d
operator|++
control|)
if|if
condition|(
name|isset
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|b
operator|+
name|d
argument_list|)
condition|)
if|if
condition|(
name|pass5
argument_list|(
name|cbase
operator|+
name|b
operator|+
name|d
argument_list|,
literal|1
argument_list|)
operator|==
name|STOP
condition|)
goto|goto
name|out5
goto|;
name|blk
operator|=
operator|(
operator|(
name|cgrp
operator|.
name|cg_free
index|[
name|b
operator|/
name|NBBY
index|]
operator|>>
operator|(
name|b
operator|%
name|NBBY
operator|)
operator|)
operator|&
operator|(
literal|0xff
operator|>>
operator|(
name|NBBY
operator|-
name|sblock
operator|.
name|fs_frag
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|blk
operator|!=
literal|0
condition|)
name|fragacct
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|,
name|frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cgrp
operator|.
name|cg_frsum
index|[
name|i
index|]
operator|!=
name|frsum
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"cg[%d].cg_frsum[%d] have %d calc %d\n"
argument_list|,
name|c
argument_list|,
name|i
argument_list|,
name|cgrp
operator|.
name|cg_frsum
index|[
name|i
index|]
argument_list|,
name|frsum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|frsumbad
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sblock
operator|.
name|fs_cpg
condition|;
name|n
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRPOS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bo
index|[
name|n
index|]
index|[
name|i
index|]
operator|!=
name|cgrp
operator|.
name|cg_b
index|[
name|n
index|]
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"cg[%d].cg_b[%d][%d] have %d calc %d\n"
argument_list|,
name|c
argument_list|,
name|n
argument_list|,
name|i
argument_list|,
name|cgrp
operator|.
name|cg_b
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|,
name|bo
index|[
name|n
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|offsumbad
operator|++
expr_stmt|;
block|}
block|}
name|out5
label|:
if|if
condition|(
name|dupblk
condition|)
name|pwarn
argument_list|(
literal|"%d DUP BLKS IN BIT MAPS\n"
argument_list|,
name|dupblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixcg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|b
operator|=
name|n_blks
operator|+
name|n_ffree
operator|+
name|sblock
operator|.
name|fs_frag
operator|*
name|n_bfree
operator|+
name|n_index
operator|+
name|n_bad
operator|)
operator|!=
name|fmax
condition|)
block|{
name|pwarn
argument_list|(
literal|"%ld BLK(S) MISSING\n"
argument_list|,
name|fmax
operator|-
name|b
argument_list|)
expr_stmt|;
name|fixcg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inosumbad
operator|+
name|offsumbad
operator|+
name|frsumbad
condition|)
block|{
name|pwarn
argument_list|(
literal|"SUMMARY INFORMATION %s%s%sBAD\n"
argument_list|,
name|inosumbad
condition|?
literal|"(INODE FREE) "
else|:
literal|""
argument_list|,
name|offsumbad
condition|?
literal|"(BLOCK OFFSETS) "
else|:
literal|""
argument_list|,
name|frsumbad
condition|?
literal|"(FRAG SUMMARIES) "
else|:
literal|""
argument_list|)
expr_stmt|;
name|fixcg
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_ffree
operator|!=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|||
name|n_bfree
operator|!=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
condition|)
block|{
name|pwarn
argument_list|(
literal|"FREE BLK COUNT(S) WRONG IN SUPERBLK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (FIXED)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|=
name|n_ffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|=
name|n_bfree
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fixcg
condition|)
block|{
name|pwarn
argument_list|(
literal|"BAD CYLINDER GROUPS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (SALVAGED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"SALVAGE"
argument_list|)
operator|==
literal|0
condition|)
name|fixcg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fixcg
condition|)
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 6 - Salvage Cylinder Groups\n"
argument_list|)
expr_stmt|;
name|makecg
argument_list|()
expr_stmt|;
name|n_ffree
operator|=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
expr_stmt|;
name|n_bfree
operator|=
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
expr_stmt|;
block|}
name|pwarn
argument_list|(
literal|"%d files, %d used, %d free (%d frags, %d blocks)\n"
argument_list|,
name|n_files
argument_list|,
name|n_blks
operator|-
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|*
name|sblock
operator|.
name|fs_frag
argument_list|,
name|n_ffree
operator|+
name|sblock
operator|.
name|fs_frag
operator|*
name|n_bfree
argument_list|,
name|n_ffree
argument_list|,
name|n_bfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfile
operator|.
name|mod
condition|)
block|{
name|time
argument_list|(
operator|&
name|sblock
operator|.
name|fs_time
argument_list|)
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
name|ckfini
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|dfile
operator|.
name|mod
operator|&&
name|hotroot
condition|)
block|{
name|printf
argument_list|(
literal|"\n***** BOOT UNIX (NO SYNC!) *****\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dfile
operator|.
name|mod
operator|&&
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n***** FILE SYSTEM WAS MODIFIED *****\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|blkmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|freemap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|statemap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lncntp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|errexit
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * An inconsistency occured which shouldn't during normal operations.  * Die if preening, otw just printf.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|pfatal
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|preendie
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|preendie
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pwarn is like printf when not preening,  * or a warning (preceded by filename) when preening.  */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|pwarn
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ckinode
argument_list|(
argument|dp
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|DINODE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|flg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|ret
expr_stmt|;
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|,
name|n
decl_stmt|,
name|ndb
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|SPECIAL
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|func
operator|=
operator|(
name|flg
operator|==
name|ADDR
operator|)
condition|?
name|pfunc
else|:
name|dirscan
expr_stmt|;
name|ndb
operator|=
name|howmany
argument_list|(
name|dp
operator|->
name|di_size
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
operator|&
name|dp
operator|->
name|di_db
index|[
literal|0
index|]
init|;
name|ap
operator|<
operator|&
name|dp
operator|->
name|di_db
index|[
name|NDADDR
index|]
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|ndb
operator|==
literal|0
operator|&&
operator|(
name|dp
operator|->
name|di_size
operator|%
name|sblock
operator|.
name|fs_bsize
operator|)
condition|)
name|size
operator|=
name|howmany
argument_list|(
name|dp
operator|->
name|di_size
operator|%
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|&&
operator|(
name|ret
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
operator|*
name|ap
argument_list|,
name|size
argument_list|)
operator|)
operator|&
name|STOP
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|ap
operator|=
operator|&
name|dp
operator|->
name|di_ib
index|[
literal|0
index|]
operator|,
name|n
operator|=
literal|1
init|;
name|n
operator|<=
literal|2
condition|;
name|ap
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|&&
operator|(
name|ret
operator|=
name|iblock
argument_list|(
operator|*
name|ap
argument_list|,
name|n
argument_list|,
name|flg
argument_list|,
name|dp
operator|->
name|di_size
operator|-
name|sblock
operator|.
name|fs_bsize
operator|*
name|NDADDR
argument_list|)
operator|)
operator|&
name|STOP
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|iblock
argument_list|(
argument|blk
argument_list|,
argument|ilevel
argument_list|,
argument|flg
argument_list|,
argument|isize
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|ilevel
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|isize
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|daddr_t
modifier|*
name|aplim
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|,
name|nif
decl_stmt|;
name|BUFAREA
name|ib
decl_stmt|;
if|if
condition|(
name|flg
operator|==
name|ADDR
condition|)
block|{
name|func
operator|=
name|pfunc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|blk
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
operator|)
operator|&
name|KEEPON
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
else|else
name|func
operator|=
name|dirscan
expr_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
comment|/* protect thyself */
return|return
operator|(
name|SKIP
operator|)
return|;
name|initbarea
argument_list|(
operator|&
name|ib
argument_list|)
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|ib
argument_list|,
name|blk
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SKIP
operator|)
return|;
name|ilevel
operator|--
expr_stmt|;
if|if
condition|(
name|ilevel
operator|==
literal|0
condition|)
block|{
name|nif
operator|=
name|isize
operator|/
name|sblock
operator|.
name|fs_bsize
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* ilevel == 1 */
block|{
name|nif
operator|=
name|isize
operator|/
operator|(
name|sblock
operator|.
name|fs_bsize
operator|*
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nif
operator|>
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
name|nif
operator|=
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|aplim
operator|=
operator|&
name|ib
operator|.
name|b_un
operator|.
name|b_indir
index|[
name|nif
index|]
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ib
operator|.
name|b_un
operator|.
name|b_indir
operator|,
name|i
operator|=
literal|1
init|;
name|ap
operator|<
name|aplim
condition|;
name|ap
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|ap
condition|)
block|{
if|if
condition|(
name|ilevel
operator|>
literal|0
condition|)
name|n
operator|=
name|iblock
argument_list|(
operator|*
name|ap
argument_list|,
name|ilevel
argument_list|,
name|flg
argument_list|,
name|isize
operator|-
name|i
operator|*
name|NINDIR
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
operator|*
name|ap
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&
name|STOP
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|pass1
argument_list|(
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
name|int
name|res
init|=
name|KEEPON
decl_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|blk
operator|++
operator|,
name|size
operator|--
control|)
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|blkerr
argument_list|(
literal|"BAD"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|badblk
operator|>=
name|MAXBAD
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE BAD BLKS I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
name|res
operator|=
name|SKIP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getbmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|blkerr
argument_list|(
literal|"DUP"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|dupblk
operator|>=
name|MAXDUP
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE DUP BLKS I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
if|if
condition|(
name|enddup
operator|>=
operator|&
name|duplist
index|[
name|DUPTBLSIZE
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"DUP TABLE OVERFLOW."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|muldup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blk
condition|)
block|{
operator|*
name|enddup
operator|++
operator|=
name|blk
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dlp
operator|>=
name|muldup
condition|)
block|{
operator|*
name|enddup
operator|++
operator|=
operator|*
name|muldup
expr_stmt|;
operator|*
name|muldup
operator|++
operator|=
name|blk
expr_stmt|;
block|}
block|}
else|else
block|{
name|n_blks
operator|++
expr_stmt|;
name|setbmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
name|filsize
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_macro
name|pass1b
argument_list|(
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
name|int
name|res
init|=
name|KEEPON
decl_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|blk
operator|++
operator|,
name|size
operator|--
control|)
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
name|res
operator|=
name|SKIP
expr_stmt|;
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|muldup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blk
condition|)
block|{
name|blkerr
argument_list|(
literal|"DUP"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
operator|*
name|dlp
operator|=
operator|*
operator|--
name|muldup
expr_stmt|;
operator|*
name|muldup
operator|=
name|blk
expr_stmt|;
if|if
condition|(
name|muldup
operator|==
name|duplist
condition|)
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pass2
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|inum
operator|=
name|dirp
operator|->
name|d_ino
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|thisname
operator|=
name|pathp
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dirp
operator|->
name|d_name
init|;
name|p
operator|<
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
index|]
condition|;
control|)
if|if
condition|(
operator|(
operator|*
name|pathp
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
operator|--
name|pathp
expr_stmt|;
break|break;
block|}
operator|*
name|pathp
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inum
operator|>
name|imax
operator|||
name|inum
operator|<=
literal|0
condition|)
name|n
operator|=
name|direrr
argument_list|(
literal|"I OUT OF RANGE"
argument_list|)
expr_stmt|;
else|else
block|{
name|again
label|:
switch|switch
condition|(
name|getstate
argument_list|()
condition|)
block|{
case|case
name|USTATE
case|:
name|n
operator|=
name|direrr
argument_list|(
literal|"UNALLOCATED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|direrr
argument_list|(
literal|"DUP/BAD"
argument_list|)
operator|)
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
break|break;
name|setstate
argument_list|(
name|DIR
condition|?
name|DSTATE
else|:
name|FSTATE
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|FSTATE
case|:
name|declncnt
argument_list|()
expr_stmt|;
break|break;
case|case
name|DSTATE
case|:
name|declncnt
argument_list|()
expr_stmt|;
name|descend
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|pathp
operator|=
name|thisname
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|dirp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|KEEPON
operator||
name|ALTERD
operator|)
return|;
block|}
end_block

begin_macro
name|pass4
argument_list|(
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
name|int
name|res
init|=
name|KEEPON
decl_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|blk
operator|++
operator|,
name|size
operator|--
control|)
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
name|res
operator|=
name|SKIP
expr_stmt|;
elseif|else
if|if
condition|(
name|getbmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|enddup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blk
condition|)
block|{
operator|*
name|dlp
operator|=
operator|*
operator|--
name|enddup
expr_stmt|;
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
name|clrbmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|n_blks
operator|--
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_macro
name|pass5
argument_list|(
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|res
init|=
name|KEEPON
decl_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|blk
operator|++
operator|,
name|size
operator|--
control|)
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|fixcg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"BAD BLOCKS IN BIT MAPS."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|badblk
operator|>=
name|MAXBAD
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE BAD BLKS IN BIT MAPS."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|getfmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|fixcg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|dupblk
operator|>=
name|DUPTBLSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE DUP BLKS IN BIT MAPS."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
else|else
block|{
name|n_ffree
operator|++
expr_stmt|;
name|setfmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_block

begin_macro
name|outrange
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|dtog
argument_list|(
name|blk
argument_list|,
operator|&
name|sblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|blk
operator|>=
name|fmax
operator|||
name|blk
operator|<
name|cgdmin
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|blkerr
argument_list|(
argument|s
argument_list|,
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pfatal
argument_list|(
literal|"%ld %s I=%u"
argument_list|,
name|blk
argument_list|,
name|s
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|setstate
argument_list|(
name|CLEAR
argument_list|)
expr_stmt|;
comment|/* mark for possible clearing */
block|}
end_block

begin_macro
name|descend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|savname
decl_stmt|;
name|off_t
name|savsize
decl_stmt|;
name|setstate
argument_list|(
name|FSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
name|savname
operator|=
name|thisname
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|savsize
operator|=
name|filsize
expr_stmt|;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
name|thisname
operator|=
name|savname
expr_stmt|;
operator|*
operator|--
name|pathp
operator|=
literal|0
expr_stmt|;
name|filsize
operator|=
name|savsize
expr_stmt|;
block|}
end_block

begin_macro
name|dirscan
argument_list|(
argument|blk
argument_list|,
argument|nf
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|DIRECT
modifier|*
name|edirp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|DIRECT
name|direntry
decl_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|filsize
operator|-=
name|sblock
operator|.
name|fs_bsize
expr_stmt|;
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
name|edirp
operator|=
operator|&
name|dirblk
operator|.
name|b_dir
index|[
name|NDIRECT
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|nf
operator|/
name|sblock
operator|.
name|fs_frag
index|]
expr_stmt|;
for|for
control|(
name|dirp
operator|=
name|dirblk
operator|.
name|b_dir
init|;
name|dirp
operator|<
name|edirp
operator|&&
name|filsize
operator|>
literal|0
condition|;
name|dirp
operator|++
operator|,
name|filsize
operator|-=
sizeof|sizeof
argument_list|(
name|DIRECT
argument_list|)
control|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
name|blk
argument_list|,
name|nf
operator|*
name|sblock
operator|.
name|fs_fsize
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|filsize
operator|-=
operator|(
operator|&
name|dirblk
operator|.
name|b_dir
index|[
name|NDIRECT
argument_list|(
operator|&
name|sblock
argument_list|)
index|]
operator|-
name|dirp
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|DIRECT
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
name|p1
operator|=
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|direntry
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
while|while
condition|(
name|p1
operator|>
operator|(
name|char
operator|*
operator|)
name|dirp
condition|)
operator|*
operator|--
name|p2
operator|=
operator|*
operator|--
name|p1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
call|(
modifier|*
name|pfunc
call|)
argument_list|(
operator|&
name|direntry
argument_list|)
operator|)
operator|&
name|ALTERD
condition|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
name|blk
argument_list|,
name|nf
operator|*
name|sblock
operator|.
name|fs_fsize
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p1
operator|=
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|direntry
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
while|while
condition|(
name|p1
operator|>
operator|(
name|char
operator|*
operator|)
name|dirp
condition|)
operator|*
operator|--
name|p1
operator|=
operator|*
operator|--
name|p2
expr_stmt|;
name|dirty
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
else|else
name|n
operator|&=
operator|~
name|ALTERD
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|STOP
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
return|return
operator|(
name|filsize
operator|>
literal|0
condition|?
name|KEEPON
else|:
name|STOP
operator|)
return|;
block|}
end_block

begin_macro
name|direrr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|pwarn
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|!=
name|NULL
operator|&&
name|ftypeok
argument_list|(
name|dp
argument_list|)
condition|)
name|pfatal
argument_list|(
literal|"%s=%s"
argument_list|,
name|DIR
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
else|else
name|pfatal
argument_list|(
literal|"NAME=%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|reply
argument_list|(
literal|"REMOVE"
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|adjust
argument_list|(
name|lcnt
argument_list|)
specifier|register
name|short
name|lcnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|di_nlink
operator|==
name|lcnt
condition|)
block|{
if|if
condition|(
name|linkup
argument_list|()
operator|==
literal|0
condition|)
name|clri
argument_list|(
literal|"UNREF"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pwarn
argument_list|(
literal|"LINK COUNT %s"
argument_list|,
operator|(
name|lfdir
operator|==
name|inum
operator|)
condition|?
name|lfname
else|:
operator|(
name|DIR
condition|?
literal|"DIR"
else|:
literal|"FILE"
operator|)
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" COUNT %d SHOULD BE %d"
argument_list|,
name|dp
operator|->
name|di_nlink
argument_list|,
name|dp
operator|->
name|di_nlink
operator|-
name|lcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
block|{
if|if
condition|(
name|lcnt
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|preendie
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (ADJUSTED)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"ADJUST"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|dp
operator|->
name|di_nlink
operator|-=
name|lcnt
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|clri
argument_list|(
argument|s
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|flg
operator|==
literal|1
condition|)
block|{
name|pwarn
argument_list|(
literal|"%s %s"
argument_list|,
name|s
argument_list|,
name|DIR
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (CLEARED)\n"
argument_list|)
expr_stmt|;
name|n_files
operator|--
expr_stmt|;
name|pfunc
operator|=
name|pass4
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|ADDR
argument_list|)
expr_stmt|;
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|setstate
argument_list|(
name|USTATE
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|inosumbad
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setup
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dev_t
name|rootdev
decl_stmt|;
name|struct
name|ostat
name|statb
decl_stmt|;
name|int
name|super
init|=
name|bflag
condition|?
name|bflag
else|:
name|SBLOCK
decl_stmt|;
name|bflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
name|rootdev
operator|=
name|statb
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dev
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rawflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFBLK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
name|rawflg
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reply
argument_list|(
literal|"file is not a block or character device; OK"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|rootdev
operator|==
name|statb
operator|.
name|st_rdev
condition|)
name|hotroot
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dfile
operator|.
name|rfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't open %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** %s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
operator|(
name|dfile
operator|.
name|wfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dfile
operator|.
name|wfdes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"NO WRITE ACCESS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (NO WRITE)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fixcg
operator|=
literal|0
expr_stmt|;
name|inosumbad
operator|=
literal|0
expr_stmt|;
name|offsumbad
operator|=
literal|0
expr_stmt|;
name|frsumbad
operator|=
literal|0
expr_stmt|;
name|dfile
operator|.
name|mod
operator|=
literal|0
expr_stmt|;
name|n_files
operator|=
name|n_blks
operator|=
name|n_ffree
operator|=
name|n_bfree
operator|=
literal|0
expr_stmt|;
name|muldup
operator|=
name|enddup
operator|=
operator|&
name|duplist
index|[
literal|0
index|]
expr_stmt|;
name|badlnp
operator|=
operator|&
name|badlncnt
index|[
literal|0
index|]
expr_stmt|;
name|lfdir
operator|=
literal|0
expr_stmt|;
name|rplyflag
operator|=
literal|0
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|sblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|inoblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|cgblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|sblock
argument_list|,
name|super
argument_list|,
name|MAXBSIZE
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sblk
operator|.
name|b_bno
operator|=
name|super
expr_stmt|;
name|sblk
operator|.
name|b_size
operator|=
name|MAXBSIZE
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|badsb
argument_list|(
literal|"MAGIC NUMBER WRONG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|<
literal|1
condition|)
block|{
name|badsb
argument_list|(
literal|"NCG OUT OF RANGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|<
literal|1
operator|||
name|sblock
operator|.
name|fs_cpg
operator|>
name|MAXCPG
condition|)
block|{
name|badsb
argument_list|(
literal|"CPG OUT OF RANGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_nsect
operator|<
literal|1
condition|)
block|{
name|badsb
argument_list|(
literal|"NSECT< 1"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ntrak
operator|<
literal|1
condition|)
block|{
name|badsb
argument_list|(
literal|"NTRAK< 1"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ipg
operator|*
name|sblock
operator|.
name|fs_ncg
operator|>
literal|65535
operator|||
name|sblock
operator|.
name|fs_ipg
operator|%
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"TOO MANY INODES IMPLIED"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|+
name|IBLOCK
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>=
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_nsect
operator|*
name|sblock
operator|.
name|fs_ntrak
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"IMPLIES MORE INODE THAN DATA BLOCKS"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* THE FOLLOWING COULD BE CHECKED MORE CLOSELY... */
if|if
condition|(
operator|(
name|sblock
operator|.
name|fs_ncg
operator|+
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_cpg
operator|<
name|sblock
operator|.
name|fs_ncyl
operator|||
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_cpg
operator|>
name|sblock
operator|.
name|fs_ncyl
condition|)
block|{
name|badsb
argument_list|(
literal|"NCYL DOES NOT JIVE WITH NCG*CPG"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_fpg
operator|!=
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"FPG DOES NOT JIVE WITH CPG& SPC"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_size
operator|<=
operator|(
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_fpg
operator|+
name|IBLOCK
argument_list|(
operator|&
name|sblock
argument_list|)
operator|+
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"SIZE PREPOSTEROUSLY SMALL"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_size
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
operator|(
name|sblock
operator|.
name|fs_ncg
operator|+
literal|2
operator|)
operator|*
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
condition|)
block|{
name|badsb
argument_list|(
literal|"SIZE PREPOSTEROUSLY LARGE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* rest we COULD repair... */
if|if
condition|(
name|sblock
operator|.
name|fs_sblkno
operator|!=
name|SBLOCK
condition|)
block|{
name|badsb
argument_list|(
literal|"BLKNO CORRUPTED"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_spc
operator|!=
name|sblock
operator|.
name|fs_nsect
operator|*
name|sblock
operator|.
name|fs_ntrak
condition|)
block|{
name|badsb
argument_list|(
literal|"SPC DOES NOT JIVE w/NTRAK*NSECT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cgsize
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|cg
argument_list|)
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_fpg
argument_list|,
name|NBBY
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"CGSIZE INCORRECT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cssize
operator|!=
name|sblock
operator|.
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|csum
argument_list|)
condition|)
block|{
name|badsb
argument_list|(
literal|"CSSIZE INCORRECT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|imax
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|bmapsz
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
name|fmax
argument_list|,
name|NBBY
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|blkmap
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|bmapsz
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|freemap
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|bmapsz
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|statemap
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|imax
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|lncntp
operator|=
operator|(
name|short
operator|*
operator|)
name|calloc
argument_list|(
name|imax
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|startinum
operator|=
name|imax
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|badsb
label|:
name|ckfini
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|badsb
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BAD SUPER BLOCK: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pwarn
argument_list|(
literal|"USE -b OPTION TO FSCK TO SPECIFY LOCATION OF AN ALTERNATE\n"
argument_list|)
expr_stmt|;
name|pfatal
argument_list|(
literal|"SUPER-BLOCK TO SUPPLY NEEDED INFORMATION; SEE fsck(8).\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|DINODE
modifier|*
name|ginode
parameter_list|()
block|{
name|daddr_t
name|iblk
decl_stmt|;
if|if
condition|(
name|inum
operator|<
name|ROOTINO
operator|||
name|inum
operator|>
name|imax
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|inum
operator|<
name|startinum
operator|||
name|inum
operator|>=
name|startinum
operator|+
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|iblk
operator|=
name|itod
argument_list|(
name|inum
argument_list|,
operator|&
name|sblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|inoblk
argument_list|,
name|iblk
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|startinum
operator|=
operator|(
name|inum
operator|/
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|inoblk
operator|.
name|b_un
operator|.
name|b_dinode
index|[
name|inum
operator|%
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_macro
name|ftypeok
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|DINODE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|dp
operator|->
name|di_mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFDIR
case|:
case|case
name|IFREG
case|:
case|case
name|IFBLK
case|:
case|case
name|IFCHR
case|:
case|case
name|IFMPC
case|:
case|case
name|IFMPB
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|reply
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"INTERNAL ERROR: GOT TO reply()"
argument_list|)
expr_stmt|;
name|rplyflag
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s? "
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|dfile
operator|.
name|wfdes
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" no\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|yflag
condition|)
block|{
name|printf
argument_list|(
literal|" yes\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|getline
argument_list|(
name|stdin
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
operator|==
name|EOF
condition|)
name|errexit
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|fp
argument_list|,
argument|loc
argument_list|,
argument|maxlen
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastloc
decl_stmt|;
name|p
operator|=
name|loc
expr_stmt|;
name|lastloc
operator|=
operator|&
name|p
index|[
name|maxlen
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|n
argument_list|)
operator|&&
name|p
operator|<
name|lastloc
condition|)
operator|*
name|p
operator|++
operator|=
name|n
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|-
name|loc
operator|)
return|;
block|}
end_block

begin_function
name|BUFAREA
modifier|*
name|getblk
parameter_list|(
name|bp
parameter_list|,
name|blk
parameter_list|,
name|size
parameter_list|)
name|daddr_t
name|blk
decl_stmt|;
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
name|daddr_t
name|dblk
decl_stmt|;
name|fcp
operator|=
operator|&
name|dfile
expr_stmt|;
name|dblk
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|==
name|dblk
condition|)
return|return
operator|(
name|bp
operator|)
return|;
name|flush
argument_list|(
name|fcp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|fcp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|dblk
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_bno
operator|=
name|dblk
expr_stmt|;
name|bp
operator|->
name|b_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|bp
operator|->
name|b_bno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|flush
argument_list|(
argument|fcp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
name|bwrite
argument_list|(
name|fcp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|bp
operator|->
name|b_bno
argument_list|,
name|bp
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|rwerr
argument_list|(
argument|s
argument_list|,
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pfatal
argument_list|(
literal|"CANNOT %s: BLK %ld"
argument_list|,
name|s
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"Program terminated\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ckfini
argument_list|()
end_macro

begin_block
block|{
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|sblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblk
operator|.
name|b_bno
operator|!=
name|SBLOCK
condition|)
block|{
name|sblk
operator|.
name|b_bno
operator|=
name|SBLOCK
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|sblk
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|inoblk
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfile
operator|.
name|rfdes
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfile
operator|.
name|wfdes
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pinode
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|uidbuf
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|" I=%u "
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|" OWNER="
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpw
argument_list|(
operator|(
name|int
operator|)
name|dp
operator|->
name|di_uid
argument_list|,
name|uidbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|uidbuf
init|;
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|uidbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|dp
operator|->
name|di_uid
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"MODE=%o\n"
argument_list|,
name|dp
operator|->
name|di_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SIZE=%ld "
argument_list|,
name|dp
operator|->
name|di_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|dp
operator|->
name|di_mtime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MTIME=%12.12s %4.4s "
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|copy
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|tp
operator|,
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|size
operator|--
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|makecg
argument_list|()
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|,
name|blk
decl_stmt|;
name|daddr_t
name|dbase
decl_stmt|,
name|d
decl_stmt|,
name|dmin
decl_stmt|,
name|dmax
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sblock
operator|.
name|fs_csp
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
name|getblk
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
index|[
name|i
index|]
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|i
operator|*
name|sblock
operator|.
name|fs_frag
operator|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|c
operator|++
control|)
block|{
name|dbase
operator|=
name|cgbase
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|dbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|dmin
operator|=
name|cgdmin
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
operator|-
name|dbase
expr_stmt|;
name|cs
operator|=
operator|&
name|sblock
operator|.
name|fs_cs
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_time
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_magic
operator|=
name|CG_MAGIC
expr_stmt|;
name|cgrp
operator|.
name|cg_cgx
operator|=
name|c
expr_stmt|;
name|cgrp
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|cgrp
operator|.
name|cg_niblk
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|cgrp
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|dbase
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|cgrp
operator|.
name|cg_rotor
operator|=
name|dmin
expr_stmt|;
name|cgrp
operator|.
name|cg_frotor
operator|=
name|dmin
expr_stmt|;
name|cgrp
operator|.
name|cg_irotor
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
name|cgrp
operator|.
name|cg_frsum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|inum
operator|=
name|sblock
operator|.
name|fs_ipg
operator|*
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
name|inum
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|ginode
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ALLOC
condition|)
block|{
if|if
condition|(
name|DIR
condition|)
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|++
expr_stmt|;
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|MAXIPG
condition|)
block|{
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|MAXCPG
condition|;
name|s
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRPOS
condition|;
name|i
operator|++
control|)
name|cgrp
operator|.
name|cg_b
index|[
name|s
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|dmin
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|*
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dmin
condition|;
name|d
operator|++
control|)
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|)
operator|<=
name|dmax
operator|-
name|dbase
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getbmap
argument_list|(
name|dbase
operator|+
name|d
operator|+
name|i
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
operator|+
name|i
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
else|else
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
name|sblock
operator|.
name|fs_frag
condition|)
block|{
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|s
operator|=
name|d
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_b
index|[
name|s
operator|/
name|sblock
operator|.
name|fs_spc
index|]
index|[
name|s
operator|%
name|sblock
operator|.
name|fs_nsect
operator|*
name|NRPOS
operator|/
name|sblock
operator|.
name|fs_nsect
index|]
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|j
expr_stmt|;
name|blk
operator|=
operator|(
operator|(
name|cgrp
operator|.
name|cg_free
index|[
name|d
operator|/
name|NBBY
index|]
operator|>>
operator|(
name|d
operator|%
name|NBBY
operator|)
operator|)
operator|&
operator|(
literal|0xff
operator|>>
operator|(
name|NBBY
operator|-
name|sblock
operator|.
name|fs_frag
operator|)
operator|)
operator|)
expr_stmt|;
name|fragacct
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|,
name|cgrp
operator|.
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
name|d
init|;
name|d
operator|<
name|dmax
operator|-
name|dbase
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getbmap
argument_list|(
name|dbase
operator|+
name|d
argument_list|)
condition|)
block|{
name|setbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
else|else
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|!=
name|d
condition|)
block|{
name|blk
operator|=
operator|(
operator|(
name|cgrp
operator|.
name|cg_free
index|[
name|j
operator|/
name|NBBY
index|]
operator|>>
operator|(
name|j
operator|%
name|NBBY
operator|)
operator|)
operator|&
operator|(
literal|0xff
operator|>>
operator|(
name|NBBY
operator|-
name|sblock
operator|.
name|fs_frag
operator|)
operator|)
operator|)
expr_stmt|;
name|fragacct
argument_list|(
operator|&
name|sblock
argument_list|,
name|blk
argument_list|,
name|cgrp
operator|.
name|cg_frsum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|d
operator|<
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|d
operator|++
control|)
name|clrbit
argument_list|(
name|cgrp
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|cgrp
operator|.
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
operator|*
name|cs
operator|=
name|cgrp
operator|.
name|cg_cs
expr_stmt|;
name|bwrite
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|cgrp
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
name|c
argument_list|,
operator|&
name|sblock
argument_list|)
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cgsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|bwrite
argument_list|(
operator|&
name|dfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sblock
operator|.
name|fs_csp
index|[
name|i
index|]
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
operator|(
name|i
operator|*
name|sblock
operator|.
name|fs_frag
operator|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_ronly
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * update the frsum fields to reflect addition or deletion   * of some frags  */
end_comment

begin_macro
name|fragacct
argument_list|(
argument|fs
argument_list|,
argument|fragmap
argument_list|,
argument|fraglist
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fragmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|fraglist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|inblk
decl_stmt|;
specifier|register
name|int
name|field
decl_stmt|,
name|subfield
decl_stmt|;
specifier|register
name|int
name|siz
decl_stmt|,
name|pos
decl_stmt|;
name|inblk
operator|=
call|(
name|int
call|)
argument_list|(
name|fragtbl
index|[
name|fs
operator|->
name|fs_frag
index|]
index|[
name|fragmap
index|]
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|fragmap
operator|<<=
literal|1
expr_stmt|;
for|for
control|(
name|siz
operator|=
literal|1
init|;
name|siz
operator|<
name|fs
operator|->
name|fs_frag
condition|;
name|siz
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|siz
operator|)
operator|&
name|inblk
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|field
operator|=
name|around
index|[
name|siz
index|]
expr_stmt|;
name|subfield
operator|=
name|inside
index|[
name|siz
index|]
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|siz
init|;
name|pos
operator|<=
name|fs
operator|->
name|fs_frag
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fragmap
operator|&
name|field
operator|)
operator|==
name|subfield
condition|)
block|{
name|fraglist
index|[
name|siz
index|]
operator|+=
name|cnt
expr_stmt|;
name|pos
operator|+=
name|siz
expr_stmt|;
name|field
operator|<<=
name|siz
expr_stmt|;
name|subfield
operator|<<=
name|siz
expr_stmt|;
block|}
name|field
operator|<<=
literal|1
expr_stmt|;
name|subfield
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|findino
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|==
literal|0
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
for|for
control|(
name|p1
operator|=
name|dirp
operator|->
name|d_name
operator|,
name|p2
operator|=
name|srchname
init|;
operator|*
name|p2
operator|++
operator|==
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
operator|||
name|p1
operator|==
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|>=
name|ROOTINO
operator|&&
name|dirp
operator|->
name|d_ino
operator|<=
name|imax
condition|)
name|parentdir
operator|=
name|dirp
operator|->
name|d_ino
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mkentry
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ino_t
name|in
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|dirp
operator|->
name|d_ino
operator|=
name|orphan
expr_stmt|;
name|in
operator|=
name|orphan
expr_stmt|;
name|p
operator|=
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|8
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|dirp
operator|->
name|d_name
condition|)
block|{
operator|*
operator|--
name|p
operator|=
operator|(
name|in
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|in
operator|/=
literal|10
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'#'
expr_stmt|;
return|return
operator|(
name|ALTERD
operator||
name|STOP
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|chgdd
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|dirp
operator|->
name|d_ino
operator|=
name|lfdir
expr_stmt|;
return|return
operator|(
name|ALTERD
operator||
name|STOP
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|linkup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|lostdir
expr_stmt|;
specifier|register
name|ino_t
name|pdir
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lostdir
operator|=
name|DIR
expr_stmt|;
name|pdir
operator|=
name|parentdir
expr_stmt|;
name|pwarn
argument_list|(
literal|"UNREF %s "
argument_list|,
name|lostdir
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
if|if
condition|(
name|preen
operator|&&
name|dp
operator|->
name|di_size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (RECONNECTED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"RECONNECT"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|orphan
operator|=
name|inum
expr_stmt|;
if|if
condition|(
name|lfdir
operator|==
literal|0
condition|)
block|{
name|inum
operator|=
name|ROOTINO
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|inum
operator|=
name|orphan
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pfunc
operator|=
name|findino
expr_stmt|;
name|srchname
operator|=
name|lfname
expr_stmt|;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|parentdir
operator|=
literal|0
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
name|inum
operator|=
name|orphan
expr_stmt|;
if|if
condition|(
operator|(
name|lfdir
operator|=
name|parentdir
operator|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|inum
operator|=
name|lfdir
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|!
name|DIR
operator|||
name|getstate
argument_list|()
operator|!=
name|FSTATE
condition|)
block|{
name|inum
operator|=
name|orphan
expr_stmt|;
name|pfatal
argument_list|(
literal|"SORRY. NO lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|di_size
operator|%
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|dp
operator|->
name|di_size
operator|=
name|roundup
argument_list|(
name|dp
operator|->
name|di_size
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|inum
operator|=
name|orphan
expr_stmt|;
name|pfunc
operator|=
name|mkentry
expr_stmt|;
if|if
condition|(
operator|(
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
operator|&
name|ALTERD
operator|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO SPACE IN lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|declncnt
argument_list|()
expr_stmt|;
if|if
condition|(
name|lostdir
condition|)
block|{
name|pfunc
operator|=
name|chgdd
expr_stmt|;
name|dp
operator|=
name|ginode
argument_list|()
expr_stmt|;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
name|inum
operator|=
name|lfdir
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|di_nlink
operator|++
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|setlncnt
argument_list|(
name|getlncnt
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|inum
operator|=
name|orphan
expr_stmt|;
name|pwarn
argument_list|(
literal|"DIR I=%u CONNECTED. "
argument_list|,
name|orphan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PARENT WAS I=%u\n"
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|bread
argument_list|(
argument|fcp
argument_list|,
argument|buf
argument_list|,
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fcp
operator|->
name|rfdes
argument_list|,
name|blk
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rwerr
argument_list|(
literal|"SEEK"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|read
argument_list|(
name|fcp
operator|->
name|rfdes
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
name|size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rwerr
argument_list|(
literal|"READ"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|bwrite
argument_list|(
argument|fcp
argument_list|,
argument|buf
argument_list|,
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fcp
operator|->
name|wfdes
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|fcp
operator|->
name|wfdes
argument_list|,
name|blk
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rwerr
argument_list|(
literal|"SEEK"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write
argument_list|(
name|fcp
operator|->
name|wfdes
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
name|size
condition|)
block|{
name|fcp
operator|->
name|mod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rwerr
argument_list|(
literal|"WRITE"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|catch
argument_list|()
end_macro

begin_block
block|{
name|ckfini
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * block operations  */
end_comment

begin_macro
name|isblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|mask
decl_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
return|return
operator|(
name|cp
index|[
name|h
index|]
operator|==
literal|0xff
operator|)
return|;
case|case
literal|4
case|:
name|mask
operator|=
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|2
case|:
name|mask
operator|=
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|1
case|:
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

end_unit

