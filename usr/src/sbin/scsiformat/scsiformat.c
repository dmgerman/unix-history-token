begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * %sccs.include.redist.c%  *  *	@(#)scsiformat.c	5.5 (Berkeley) %G%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1992, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)scsiformat.c	5.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/disktape.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsi/scsi_ioctl.h>
end_include

begin_define
define|#
directive|define
name|COMPAT_HPSCSI
end_define

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|scsi_str
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|do_command
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|scsi_cdb
operator|*
operator|,
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|do_format
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_capacity
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_inquiry
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|prflags
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|print_mode_page
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_mode_sense
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N2
parameter_list|(
name|c
parameter_list|,
name|d
parameter_list|)
value|(((c)<< 8) | (d))
end_define

begin_define
define|#
directive|define
name|N3
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(((b)<< 16) | N2(c, d))
end_define

begin_define
define|#
directive|define
name|N4
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(((a)<< 24) | N3(b, c, d))
end_define

begin_decl_stmt
name|int
name|sense_pctl
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|readonly
decl_stmt|;
name|readonly
operator|=
literal|0
expr_stmt|;
name|sense_pctl
operator|=
name|SCSI_MSENSE_PCTL_CUR
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"rp:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'r'
case|:
name|readonly
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* mode sense page control */
switch|switch
condition|(
operator|*
name|optarg
condition|)
block|{
case|case
literal|'c'
case|:
name|sense_pctl
operator|=
name|SCSI_MSENSE_PCTL_CUR
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|sense_pctl
operator|=
name|SCSI_MSENSE_PCTL_DFLT
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sense_pctl
operator|=
name|SCSI_MSENSE_PCTL_SAVED
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"*** note: for variable parameters, 1-bit means ``can write here''\n"
argument_list|)
expr_stmt|;
name|sense_pctl
operator|=
name|SCSI_MSENSE_PCTL_VAR
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|device
operator|=
operator|*
name|argv
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|readonly
condition|?
name|O_RDONLY
else|:
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: %s: %s\n"
argument_list|,
name|device
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|print_inquiry
argument_list|()
expr_stmt|;
name|print_capacity
argument_list|()
expr_stmt|;
name|print_mode_sense
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readonly
condition|)
name|do_format
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy a counted string, trimming trailing blanks, and turning the  * result into a C-style string.  */
end_comment

begin_function
name|void
name|scsi_str
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|src
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dst
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|void
name|print_inquiry
parameter_list|()
block|{
specifier|register
name|struct
name|scsi_inq_ansi
modifier|*
name|si
decl_stmt|;
name|int
name|ver
decl_stmt|;
name|struct
name|scsi_inquiry
name|inqbuf
decl_stmt|;
name|char
name|vendor
index|[
literal|10
index|]
decl_stmt|,
name|product
index|[
literal|17
index|]
decl_stmt|,
name|rev
index|[
literal|5
index|]
decl_stmt|;
specifier|static
name|struct
name|scsi_cdb
name|inq
init|=
block|{
name|CMD_INQUIRY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|do_command
argument_list|(
name|fd
argument_list|,
operator|&
name|inq
argument_list|,
operator|&
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inqbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|ver
operator|=
operator|(
name|inqbuf
operator|.
name|si_version
operator|>>
name|VER_ANSI_SHIFT
operator|)
operator|&
name|VER_ANSI_MASK
expr_stmt|;
if|if
condition|(
name|ver
operator|!=
literal|1
operator|&&
name|ver
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"type 0x%x, qual 0x%x, ver 0x%x (ansi %d)\n"
argument_list|,
name|inqbuf
operator|.
name|si_type
argument_list|,
name|inqbuf
operator|.
name|si_qual
argument_list|,
name|inqbuf
operator|.
name|si_version
argument_list|,
name|ver
argument_list|)
expr_stmt|;
return|return;
block|}
name|si
operator|=
operator|(
expr|struct
name|scsi_inq_ansi
operator|*
operator|)
operator|&
name|inqbuf
expr_stmt|;
switch|switch
condition|(
name|si
operator|->
name|si_type
operator|&
name|TYPE_TYPE_MASK
condition|)
block|{
case|case
name|TYPE_DAD
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(disk)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_WORM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(WORM)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_ROM
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(CD-ROM)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_MO
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(MO-DISK)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_JUKEBOX
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(jukebox)"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"(??)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|scsi_str
argument_list|(
name|si
operator|->
name|si_vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|si
operator|->
name|si_vendor
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_str
argument_list|(
name|si
operator|->
name|si_product
argument_list|,
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|si
operator|->
name|si_product
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_str
argument_list|(
name|si
operator|->
name|si_rev
argument_list|,
name|rev
argument_list|,
sizeof|sizeof
argument_list|(
name|si
operator|->
name|si_rev
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s %s rev %s:"
argument_list|,
name|vendor
argument_list|,
name|product
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_capacity
parameter_list|()
block|{
name|struct
name|scsi_rc
name|rc
decl_stmt|;
comment|/* for READ CAPACITY */
specifier|static
name|struct
name|scsi_cdb
name|cap
init|=
block|{
name|CMD_READ_CAPACITY
block|}
decl_stmt|;
name|do_command
argument_list|(
name|fd
argument_list|,
operator|&
name|cap
argument_list|,
operator|&
name|rc
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %d blocks of %d bytes each\n"
argument_list|,
name|N4
argument_list|(
name|rc
operator|.
name|rc_lbah
argument_list|,
name|rc
operator|.
name|rc_lbahm
argument_list|,
name|rc
operator|.
name|rc_lbalm
argument_list|,
name|rc
operator|.
name|rc_lbal
argument_list|)
operator|+
literal|1
argument_list|,
name|N4
argument_list|(
name|rc
operator|.
name|rc_blh
argument_list|,
name|rc
operator|.
name|rc_blhm
argument_list|,
name|rc
operator|.
name|rc_bllm
argument_list|,
name|rc
operator|.
name|rc_bll
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_mode_sense
parameter_list|()
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|scsi_ms_bd
modifier|*
name|bd
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|,
name|len
decl_stmt|,
name|bdlen
decl_stmt|;
ifdef|#
directive|ifdef
name|TEN_BYTE_SENSE
struct|struct
block|{
name|struct
name|scsi_ms10
name|ms
decl_stmt|;
name|u_char
name|p
index|[
literal|1023
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_ms10
argument_list|)
index|]
decl_stmt|;
block|}
name|msbuf
struct|;
specifier|static
name|struct
name|scsi_cdb
name|modesense
init|=
block|{
name|CMD_MODE_SENSE10
block|,
name|SCSI_MSENSE_DBD
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|msbuf
argument_list|)
operator|>>
literal|8
block|,
sizeof|sizeof
argument_list|(
name|msbuf
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|CDB10
argument_list|(
operator|&
name|modesense
argument_list|)
operator|->
name|cdb_lbam
operator|=
name|sense_pctl
operator||
name|SCSI_MS_PC_ALL
expr_stmt|;
name|do_command
argument_list|(
name|fd
argument_list|,
operator|&
name|modesense
argument_list|,
operator|&
name|msbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msbuf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|N2
argument_list|(
name|msbuf
operator|.
name|ms
operator|.
name|ms_lenh
argument_list|,
name|msbuf
operator|.
name|ms
operator|.
name|ms_lenl
argument_list|)
expr_stmt|;
name|bdlen
operator|=
name|N2
argument_list|(
name|msbuf
operator|.
name|ms
operator|.
name|ms_bdlh
argument_list|,
name|msbuf
operator|.
name|ms
operator|.
name|ms_bdll
argument_list|)
expr_stmt|;
else|#
directive|else
struct|struct
block|{
name|struct
name|scsi_ms6
name|ms
decl_stmt|;
name|u_char
name|p
index|[
literal|255
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_ms6
argument_list|)
index|]
decl_stmt|;
block|}
name|msbuf
struct|;
specifier|static
name|struct
name|scsi_cdb
name|modesense
init|=
block|{
name|CMD_MODE_SENSE6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|msbuf
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
name|CDB6
argument_list|(
operator|&
name|modesense
argument_list|)
operator|->
name|cdb_lbam
operator|=
name|sense_pctl
operator||
name|SCSI_MS_PC_ALL
expr_stmt|;
name|do_command
argument_list|(
name|fd
argument_list|,
operator|&
name|modesense
argument_list|,
operator|&
name|msbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msbuf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|msbuf
operator|.
name|ms
operator|.
name|ms_len
expr_stmt|;
name|bdlen
operator|=
name|msbuf
operator|.
name|ms
operator|.
name|ms_bdl
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%d bytes of mode sense data. "
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"medium type 0x%x, %swrite protected\n"
argument_list|,
name|msbuf
operator|.
name|ms
operator|.
name|ms_mt
argument_list|,
name|msbuf
operator|.
name|ms
operator|.
name|ms_dsp
operator|&
name|SCSI_MS_DSP_WP
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|bdlen
operator|)
operator|!=
literal|0
condition|)
block|{
name|bd
operator|=
operator|(
expr|struct
name|scsi_ms_bd
operator|*
operator|)
name|msbuf
operator|.
name|p
expr_stmt|;
for|for
control|(
name|n
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|bd
argument_list|)
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|bd
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tdensity code 0x%x, "
argument_list|,
name|bd
operator|->
name|bd_dc
argument_list|)
expr_stmt|;
name|i
operator|=
name|N3
argument_list|(
name|bd
operator|->
name|bd_nbh
argument_list|,
name|bd
operator|->
name|bd_nbm
argument_list|,
name|bd
operator|->
name|bd_nbl
argument_list|)
expr_stmt|;
name|l
operator|=
name|N3
argument_list|(
name|bd
operator|->
name|bd_blh
argument_list|,
name|bd
operator|->
name|bd_blm
argument_list|,
name|bd
operator|->
name|bd_bll
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d blocks of length %d\n"
argument_list|,
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"all blocks of length %d\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Sense header lengths includes the sense header, while mode page 	 * lengths do not ... let's hear it for consistency! 	 */
name|cp
operator|=
name|msbuf
operator|.
name|p
operator|+
name|bdlen
expr_stmt|;
name|ep
operator|=
name|msbuf
operator|.
name|p
operator|+
name|len
operator|-
sizeof|sizeof
argument_list|(
name|msbuf
operator|.
name|ms
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
name|cp
operator|=
name|print_mode_page
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prflags
parameter_list|(
name|v
parameter_list|,
name|cp
parameter_list|)
name|int
name|v
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
name|char
name|f
decl_stmt|,
name|sep
decl_stmt|;
for|for
control|(
name|sep
operator|=
literal|'<'
init|;
operator|(
name|f
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|0
condition|;
name|cp
operator|=
name|np
control|)
block|{
for|for
control|(
name|np
operator|=
name|cp
init|;
operator|*
name|np
operator|>=
literal|' '
condition|;
control|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|&
operator|(
literal|1
operator|<<
operator|(
name|f
operator|-
literal|1
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%c%.*s"
argument_list|,
name|sep
argument_list|,
name|np
operator|-
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|','
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|!=
literal|'<'
condition|)
name|putchar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cache_policy
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
specifier|static
name|char
name|rsvd
index|[
literal|30
index|]
decl_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
name|SCSI_CACHE_DEFAULT
case|:
return|return
operator|(
literal|"default"
operator|)
return|;
case|case
name|SCSI_CACHE_KEEPPF
case|:
return|return
operator|(
literal|"toss cmd data, save prefetch"
operator|)
return|;
case|case
name|SCSI_CACHE_KEEPCMD
case|:
return|return
operator|(
literal|"toss prefetch data, save cmd"
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rsvd
argument_list|,
literal|"reserved %d"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rsvd
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|u_char
modifier|*
name|print_mode_page
parameter_list|(
name|cp
parameter_list|)
name|u_char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|struct
name|scsi_ms_page_hdr
modifier|*
name|mp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|code
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|tp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|mp
operator|=
operator|(
expr|struct
name|scsi_ms_page_hdr
operator|*
operator|)
name|cp
expr_stmt|;
name|code
operator|=
name|mp
operator|->
name|mp_psc
operator|&
name|SCSI_MS_PC_MASK
expr_stmt|;
name|len
operator|=
name|mp
operator|->
name|mp_len
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\npage type %d%s (%d bytes): "
argument_list|,
name|code
argument_list|,
name|mp
operator|->
name|mp_psc
operator|&
name|SCSI_MS_MP_SAVEABLE
condition|?
literal|" (saveable)"
else|:
literal|""
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SCSI_MS_PC_RWERRREC
case|:
define|#
directive|define
name|rw
value|((struct scsi_page_rwerrrec *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Read/Write Error Recovery parameters.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tflags = 0x%x"
argument_list|,
name|rw
operator|->
name|rw_flags
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|rw
operator|->
name|rw_flags
argument_list|,
literal|"\10AWRE\7ARRE\6TB\5RC\4EER\3PER\2DTE\1DCR"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",\n\t%d read retries, %d correction span bits,\n"
argument_list|,
name|rw
operator|->
name|rw_read_retry
argument_list|,
name|rw
operator|->
name|rw_corr_span
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%d head offsets, %d data strobe offsets%s\n"
argument_list|,
name|rw
operator|->
name|rw_hd_off
argument_list|,
name|rw
operator|->
name|rw_ds_off
argument_list|,
name|len
operator|>
literal|6
condition|?
literal|","
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|6
condition|)
break|break;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%d write retries, "
argument_list|,
name|rw
operator|->
name|rw_write_retry
argument_list|)
expr_stmt|;
name|i
operator|=
name|N2
argument_list|(
name|rw
operator|->
name|rw_rtlh
argument_list|,
name|rw
operator|->
name|rw_rtll
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0xffff
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" recovery time limit.\n"
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|rw
case|case
name|SCSI_MS_PC_DR
case|:
define|#
directive|define
name|dr
value|((struct scsi_page_dr *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Disconnect/Reconnect control.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tbuffer full ratio %d, buffer empty ratio %d,\n"
argument_list|,
name|dr
operator|->
name|dr_full
argument_list|,
name|dr
operator|->
name|dr_empty
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\ttime limits: %d bus inactivity, "
argument_list|,
name|N2
argument_list|(
name|dr
operator|->
name|dr_inacth
argument_list|,
name|dr
operator|->
name|dr_inactl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d disconnect, %d connect.\n"
argument_list|,
name|N2
argument_list|(
name|dr
operator|->
name|dr_disconh
argument_list|,
name|dr
operator|->
name|dr_disconl
argument_list|)
argument_list|,
name|N2
argument_list|(
name|dr
operator|->
name|dr_conh
argument_list|,
name|dr
operator|->
name|dr_conl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tmaximum burst size %d,\n"
argument_list|,
name|N2
argument_list|(
name|dr
operator|->
name|dr_bursth
argument_list|,
name|dr
operator|->
name|dr_burstl
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dr
operator|->
name|dr_dtdc
operator|&
name|SCSI_DR_DTDC_MASK
condition|)
block|{
case|case
name|SCSI_DR_DTDC_NONE
case|:
name|s
operator|=
literal|"never"
expr_stmt|;
break|break;
case|case
name|SCSI_DR_DTDC_NOTDATA
case|:
name|s
operator|=
literal|"during data transfer"
expr_stmt|;
break|break;
case|case
name|SCSI_DR_DTDC_RSVD
case|:
name|s
operator|=
literal|"???"
expr_stmt|;
break|break;
case|case
name|SCSI_DR_DTDC_NOTD2
case|:
name|s
operator|=
literal|"during and after data transfer"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tsuppress disconnect %s.\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|dr
case|case
name|SCSI_MS_PC_FMT
case|:
define|#
directive|define
name|fmt
value|((struct scsi_page_fmt *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Format parameters.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%d tracks/zone, %d alt.sect./zone, "
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_tpzh
argument_list|,
name|fmt
operator|->
name|fmt_tpzl
argument_list|)
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_aspzh
argument_list|,
name|fmt
operator|->
name|fmt_aspzl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d alt.tracks/zone,\n\t%d alt.tracks/vol., "
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_atpzh
argument_list|,
name|fmt
operator|->
name|fmt_atpzl
argument_list|)
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_atpvh
argument_list|,
name|fmt
operator|->
name|fmt_atpvl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d sectors/track, %d bytes/phys.sector,\n"
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_spth
argument_list|,
name|fmt
operator|->
name|fmt_sptl
argument_list|)
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_dbppsh
argument_list|,
name|fmt
operator|->
name|fmt_dbppsl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tinterleave %d, track skew %d, cyl.skew %d,\n"
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_ilh
argument_list|,
name|fmt
operator|->
name|fmt_ill
argument_list|)
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_tsfh
argument_list|,
name|fmt
operator|->
name|fmt_tsfl
argument_list|)
argument_list|,
name|N2
argument_list|(
name|fmt
operator|->
name|fmt_csfh
argument_list|,
name|fmt
operator|->
name|fmt_csfl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tdrive flags 0x%x"
argument_list|,
name|fmt
operator|->
name|fmt_flags
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|fmt
operator|->
name|fmt_flags
argument_list|,
literal|"\10SSEC\7HSEC\6RMB\5SURF"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|fmt
case|case
name|SCSI_MS_PC_RDGEOM
case|:
define|#
directive|define
name|rd
value|((struct scsi_page_rdgeom *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Disk Geometry parameters.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%d cylinders, %d heads,\n"
argument_list|,
name|N3
argument_list|(
name|rd
operator|->
name|rd_ncylh
argument_list|,
name|rd
operator|->
name|rd_ncylm
argument_list|,
name|rd
operator|->
name|rd_ncyll
argument_list|)
argument_list|,
name|rd
operator|->
name|rd_nheads
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tstart write precompensation at cyl %d,\n"
argument_list|,
name|N3
argument_list|(
name|rd
operator|->
name|rd_wpcylh
argument_list|,
name|rd
operator|->
name|rd_wpcylm
argument_list|,
name|rd
operator|->
name|rd_wpcyll
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tstart reduced write current at cyl %d,\n"
argument_list|,
name|N3
argument_list|(
name|rd
operator|->
name|rd_rwcylh
argument_list|,
name|rd
operator|->
name|rd_rwcylm
argument_list|,
name|rd
operator|->
name|rd_rwcyll
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tseek step rate %f us, landing zone cyl %d,\n"
argument_list|,
name|N2
argument_list|(
name|rd
operator|->
name|rd_steph
argument_list|,
name|rd
operator|->
name|rd_stepl
argument_list|)
operator|*
literal|0.1
argument_list|,
name|N3
argument_list|(
name|rd
operator|->
name|rd_lcylh
argument_list|,
name|rd
operator|->
name|rd_lcylm
argument_list|,
name|rd
operator|->
name|rd_lcyll
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rd
operator|->
name|rd_rpl
operator|&
name|SCSI_RD_RPL_MASK
condition|)
block|{
case|case
name|SCSI_RD_RPL_NONE
case|:
name|s
operator|=
literal|"disabled or unsupported"
expr_stmt|;
break|break;
case|case
name|SCSI_RD_RPL_SLAVE
case|:
name|s
operator|=
literal|"slave"
expr_stmt|;
break|break;
case|case
name|SCSI_RD_RPL_MASTER
case|:
name|s
operator|=
literal|"master"
expr_stmt|;
break|break;
case|case
name|SCSI_RD_RPL_MCONTROL
case|:
name|s
operator|=
literal|"master control"
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\trotational synch %s, offset %d/256%s\n"
argument_list|,
name|s
argument_list|,
name|rd
operator|->
name|rd_roff
argument_list|,
name|len
operator|>
literal|18
condition|?
literal|","
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|18
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\trotation %d rpm.\n"
argument_list|,
name|N2
argument_list|(
name|rd
operator|->
name|rd_rpmh
argument_list|,
name|rd
operator|->
name|rd_rpml
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|rd
case|case
name|SCSI_MS_PC_VERRREC
case|:
define|#
directive|define
name|v
value|((struct scsi_page_verrrec *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Verify Error Recovery parameters.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tflags = 0x%x"
argument_list|,
name|v
operator|->
name|v_flags
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|v
operator|->
name|v_flags
argument_list|,
literal|"\4EER\3PER\2DTE\1DCR"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",\n\t%d verify retries, %d %s span bits,\n\t"
argument_list|,
name|v
operator|->
name|v_verify_retry
argument_list|,
name|v
operator|->
name|v_corr_span
argument_list|,
literal|"correction"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%d recovery time limit.\n"
argument_list|,
name|N2
argument_list|(
name|v
operator|->
name|v_rtlh
argument_list|,
name|v
operator|->
name|v_rtll
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|v
case|case
name|SCSI_MS_PC_CACHE
case|:
define|#
directive|define
name|cache
value|((struct scsi_page_cache *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Caching Page.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tflags = 0x%x"
argument_list|,
name|cache
operator|->
name|cache_flags
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|cache
operator|->
name|cache_flags
argument_list|,
literal|"\3WCE\2MF\1RCD"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",\n\tread retention = %s, write retention = %s,\n"
argument_list|,
name|cache_policy
argument_list|(
name|SCSI_CACHE_RDPOLICY
argument_list|(
name|cache
operator|->
name|cache_reten
argument_list|)
argument_list|)
argument_list|,
name|cache_policy
argument_list|(
name|SCSI_CACHE_WRPOLICY
argument_list|(
name|cache
operator|->
name|cache_reten
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tdisable prefetch transfer length = %d,\n"
argument_list|,
name|N2
argument_list|(
name|cache
operator|->
name|cache_dptlh
argument_list|,
name|cache
operator|->
name|cache_dptll
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tmin prefetch = %d, max prefetch = %d, "
argument_list|,
name|N2
argument_list|(
name|cache
operator|->
name|cache_minpfh
argument_list|,
name|cache
operator|->
name|cache_minpfl
argument_list|)
argument_list|,
name|N2
argument_list|(
name|cache
operator|->
name|cache_maxpfh
argument_list|,
name|cache
operator|->
name|cache_maxpfl
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"max prefetch ceiling = %d.\n"
argument_list|,
name|N2
argument_list|(
name|cache
operator|->
name|cache_mpch
argument_list|,
name|cache
operator|->
name|cache_mpcl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|cache
case|case
name|SCSI_MS_PC_CTLMODE
case|:
define|#
directive|define
name|cm
value|((struct scsi_page_ctlmode *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Control Mode Page.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s report log-activity error conditions,\n"
argument_list|,
name|cm
operator|->
name|cm_rlec
operator|&
name|SCSI_CM_RLEC
condition|?
literal|"do"
else|:
literal|"do not"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tqueue algorithm modifier = %d, flags = 0x%x"
argument_list|,
name|SCSI_CM_QMOD
argument_list|(
name|cm
operator|->
name|cm_qctl
argument_list|)
argument_list|,
name|cm
operator|->
name|cm_qctl
operator|&
operator|(
name|SCSI_CM_QERR
operator||
name|SCSI_CM_DQUE
operator|)
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|cm
operator|->
name|cm_qctl
argument_list|,
literal|"\2QERR\1DQUE"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|",\n\tECA/AEN flags = 0x%x"
argument_list|,
name|cm
operator|->
name|cm_ecaaen
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|cm
operator|->
name|cm_ecaaen
argument_list|,
literal|"\10ECA\3RAENP\2UUAENP\1EAENP"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|", AEN holdoff period = %d ms.\n"
argument_list|,
name|N2
argument_list|(
name|cm
operator|->
name|cm_aenholdh
argument_list|,
name|cm
operator|->
name|cm_aenholdl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|cm
comment|/* 	 * Vendor Unique, but what the heck. 	 */
case|case
name|SCSI_MS_PC_CDCCACHECTL
case|:
define|#
directive|define
name|ccm
value|((struct scsi_page_CDCcachectlmode *)(mp + 1))
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"CDC-specific Cache Control Mode Page.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tflags = 0x%x"
argument_list|,
name|ccm
operator|->
name|ccm_flags
argument_list|)
expr_stmt|;
name|prflags
argument_list|(
name|ccm
operator|->
name|ccm_flags
argument_list|,
literal|"\7WIE\5ENABLE"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|", table size = %d, prefetch threshold = %d\n"
argument_list|,
name|SCSI_CDC_CCM_TBLSZ
argument_list|(
name|ccm
operator|->
name|ccm_flags
argument_list|)
argument_list|,
name|ccm
operator|->
name|ccm_pfthresh
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tmaximum %s = %d, maximum %s = %d,\n"
argument_list|,
literal|"threshold"
argument_list|,
name|ccm
operator|->
name|ccm_maxthresh
argument_list|,
literal|"prefetch multiplier"
argument_list|,
name|ccm
operator|->
name|ccm_maxpfmult
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tminimum %s = %d, minimum %s = %d.\n"
argument_list|,
literal|"threshold"
argument_list|,
name|ccm
operator|->
name|ccm_minthresh
argument_list|,
literal|"prefetch multiplier"
argument_list|,
name|ccm
operator|->
name|ccm_minpfmult
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|ccm
default|default:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Unknown page type."
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|cp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n\t%2d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
name|tp
operator|++
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|cp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pr_sense
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
specifier|static
name|struct
name|scsi_fmt_sense
name|s
decl_stmt|;
specifier|register
name|struct
name|scsi_sense
modifier|*
name|sn
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SDIOCSENSE
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: SDIOCSENSE: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"scsi status 0x%x"
argument_list|,
name|s
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|status
operator|&
name|STS_CHECKCOND
condition|)
block|{
name|sn
operator|=
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|s
operator|.
name|sense
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" sense class %d, code %d"
argument_list|,
name|SENSE_ECLASS
argument_list|(
name|sn
argument_list|)
argument_list|,
name|SENSE_ECODE
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SENSE_ISXSENSE
argument_list|(
name|sn
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|", key %d"
argument_list|,
name|XSENSE_KEY
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSENSE_IVALID
argument_list|(
name|sn
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|", blk %d"
argument_list|,
name|XSENSE_INFO
argument_list|(
name|sn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_format
parameter_list|()
block|{
struct|struct
block|{
name|struct
name|scsi_ms6
name|ms
decl_stmt|;
comment|/* mode select header */
name|struct
name|scsi_ms_bd
name|bd
decl_stmt|;
comment|/* block descriptor */
name|struct
name|scsi_ms_page_hdr
name|mp
decl_stmt|;
comment|/* ctl mode page hdr */
name|struct
name|scsi_page_ctlmode
name|cm
decl_stmt|;
comment|/* ctl mode page */
name|u_char
name|pad
index|[
literal|4
index|]
decl_stmt|;
comment|/* ??? */
block|}
name|msel
struct|;
name|u_char
name|fmtbuf
index|[
literal|128
index|]
decl_stmt|;
specifier|static
name|struct
name|scsi_cdb
name|modeselect
init|=
block|{
name|CMD_MODE_SELECT6
block|,
name|SCSI_MSEL_SCSI2_DATA
operator||
name|SCSI_MSEL_SAVEPAGES
block|,
literal|0
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|msel
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|scsi_cdb
name|format
init|=
block|{
name|CMD_FORMAT_UNIT
block|}
decl_stmt|;
comment|/* want mostly 0s; set them all zero here */
name|bzero
argument_list|(
operator|&
name|msel
argument_list|,
sizeof|sizeof
argument_list|(
name|msel
argument_list|)
argument_list|)
expr_stmt|;
comment|/* one block descriptor */
name|msel
operator|.
name|ms
operator|.
name|ms_bdl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_ms_bd
argument_list|)
expr_stmt|;
comment|/* block length = 512 bytes */
name|msel
operator|.
name|bd
operator|.
name|bd_blm
operator|=
literal|512
operator|/
literal|256
expr_stmt|;
name|msel
operator|.
name|bd
operator|.
name|bd_bll
operator|=
literal|512
operator|%
literal|256
expr_stmt|;
comment|/* 	 * In the following, the mystery pad region is copied from 	 * the original driver.  I have no idea what it is for. 	 * (Anyone got SCSI-2 documents?) 	 */
comment|/* mode page parameters: report log-activity exception conditions */
name|msel
operator|.
name|mp
operator|.
name|mp_psc
operator|=
name|SCSI_MS_PC_CTLMODE
expr_stmt|;
name|msel
operator|.
name|mp
operator|.
name|mp_len
operator|=
sizeof|sizeof
argument_list|(
name|msel
operator|.
name|cm
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|msel
operator|.
name|pad
argument_list|)
expr_stmt|;
name|msel
operator|.
name|cm
operator|.
name|cm_rlec
operator|=
name|SCSI_CM_RLEC
expr_stmt|;
name|do_command
argument_list|(
name|fd
argument_list|,
operator|&
name|modeselect
argument_list|,
operator|&
name|msel
argument_list|,
sizeof|sizeof
argument_list|(
name|msel
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fmtbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|fmtbuf
argument_list|)
argument_list|)
expr_stmt|;
name|do_command
argument_list|(
name|fd
argument_list|,
operator|&
name|format
argument_list|,
name|fmtbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|fmtbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_command
parameter_list|(
name|fd
parameter_list|,
name|cdb
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|scsi_cdb
modifier|*
name|cdb
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|static
name|int
name|on
init|=
literal|1
decl_stmt|,
name|off
init|=
literal|0
decl_stmt|;
name|int
name|user
decl_stmt|,
name|ret
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SDIOCSFORMAT
argument_list|,
operator|&
name|on
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: SDIOCSFORMAT (on): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SDIOCGFORMAT
argument_list|,
operator|&
name|user
argument_list|)
operator|==
literal|0
operator|&&
name|user
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: pid %d has it\n"
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return;
block|}
name|ret
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SDIOCSCSICOMMAND
argument_list|,
name|cdb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_HPSCSI
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
specifier|static
specifier|const
name|char
name|scsicmdlen
index|[
literal|8
index|]
init|=
block|{
literal|6
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
define|#
directive|define
name|SCSICMDLEN
parameter_list|(
name|cmd
parameter_list|)
value|scsicmdlen[(cmd)>> 5]
struct|struct
name|scsi_fmt_cdb
block|{
name|int
name|len
decl_stmt|;
name|u_char
name|cdb
index|[
literal|28
index|]
decl_stmt|;
block|}
name|sc
struct|;
define|#
directive|define
name|OSDIOCSCSICOMMAND
value|_IOW('S', 0x3, struct scsi_fmt_cdb)
name|sc
operator|.
name|len
operator|=
name|SCSICMDLEN
argument_list|(
name|cdb
operator|->
name|cdb_bytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cdb
operator|->
name|cdb_bytes
argument_list|,
name|sc
operator|.
name|cdb
argument_list|,
name|sc
operator|.
name|len
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|OSDIOCSCSICOMMAND
argument_list|,
operator|&
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: SDIOCSCSICOMMAND: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: read: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|pr_sense
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SDIOCSFORMAT
argument_list|,
operator|&
name|off
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"scsiformat: SDIOCSFORMAT (off): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: scsiformat [-r] [-p c|d|s|v] device\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

