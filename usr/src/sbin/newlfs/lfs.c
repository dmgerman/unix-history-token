begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)lfs.c	5.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"lfs.h"
end_include

begin_comment
comment|/* XXX move to<sys/lfs.h> */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|LFS_SUPER
name|lfs_default
init|=
block|{
comment|/* lfs_magic */
name|LFS_MAGIC
block|,
comment|/* lfs_version */
name|LFS_VERSION
block|,
comment|/* lfs_size */
literal|0
block|,
comment|/* lfs_ssize */
literal|0
block|,
comment|/* lfs_dsize */
literal|0
block|,
comment|/* lfs_bsize */
name|DFL_LFSBLOCK
block|,
comment|/* lfs_fsize */
literal|0
block|,
comment|/* lfs_frag */
literal|0
block|,
comment|/* lfs_free */
name|LFS_FIRST_INUM
block|,
comment|/* lfs_idaddr */
literal|0
block|,
comment|/* lfs_ifile */
name|LFS_IFILE_INUM
block|,
comment|/* lfs_lastseg */
literal|0
block|,
comment|/* lfs_tstamp */
literal|0
block|,
comment|/* lfs_minfree */
name|MINFREE
block|,
comment|/* lfs_inopb */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
block|,
comment|/* lfs_ifpb */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
name|IFILE
argument_list|)
block|,
comment|/* lfs_nindir */
name|DFL_LFSBLOCK
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
block|,
comment|/* lfs_nseg */
literal|0
block|,
comment|/* lfs_nspf */
literal|0
block|,
comment|/* lfs_segtabsz */
literal|0
block|,
comment|/* lfs_segmask */
name|DFL_LFSSEG_MASK
block|,
comment|/* lfs_segshift */
name|DFL_LFSSEG_SHIFT
block|,
comment|/* lfs_bmask */
name|DFL_LFSBLOCK_MASK
block|,
comment|/* lfs_bshift */
name|DFL_LFSBLOCK_SHIFT
block|,
comment|/* lfs_ffmask */
literal|0
block|,
comment|/* lfs_ffshift */
literal|0
block|,
comment|/* lfs_fbmask */
literal|0
block|,
comment|/* lfs_fbshift */
literal|0
block|,
comment|/* lfs_fsbtodb */
literal|0
block|,
comment|/* lfs_sboffs */
block|{
literal|0
block|}
block|,
comment|/* lfs_fmod */
literal|0
block|,
comment|/* lfs_clean */
literal|0
block|,
comment|/* lfs_ronly */
literal|0
block|,
comment|/* lfs_flags */
literal|0
block|,
comment|/* lfs_fsmnt */
block|{
literal|0
block|}
block|,
comment|/* lfs_cksum */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put
name|__P
argument_list|(
operator|(
name|int
operator|,
name|off_t
operator|,
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|make_lfs
parameter_list|(
name|fd
parameter_list|,
name|lp
parameter_list|,
name|partp
parameter_list|,
name|minfree
parameter_list|,
name|block_size
parameter_list|,
name|seg_size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|partition
modifier|*
name|partp
decl_stmt|;
name|int
name|minfree
decl_stmt|;
name|int
name|block_size
decl_stmt|;
name|int
name|seg_size
decl_stmt|;
block|{
name|struct
name|dinode
modifier|*
name|dip
decl_stmt|;
comment|/* Pointer to a disk inode */
name|FINFO
name|file_info
decl_stmt|;
comment|/* File info structure in summary blocks */
name|IFILE
modifier|*
name|ifile
decl_stmt|;
comment|/* Pointer to array of ifile structures */
name|IFILE
modifier|*
name|ip
decl_stmt|;
comment|/* Pointer to array of ifile structures */
name|LFS_SUPER
modifier|*
name|lfsp
decl_stmt|;
comment|/* Superblock */
name|SEGUSAGE
modifier|*
name|segp
decl_stmt|;
comment|/* Segment usage table */
name|SEGUSAGE
modifier|*
name|segtable
decl_stmt|;
comment|/* Segment usage table */
name|SEGSUM
name|summary
decl_stmt|;
comment|/* Segment summary structure */
name|SEGSUM
modifier|*
name|sp
decl_stmt|;
comment|/* Segment summary pointer */
name|daddr_t
name|last_sb_addr
decl_stmt|;
comment|/* Address of superblocks */
name|daddr_t
name|sb_addr
decl_stmt|;
comment|/* Address of superblocks */
name|void
modifier|*
name|pagep
decl_stmt|;
comment|/* Pointer to the page we use to write stuff */
name|void
modifier|*
name|sump
decl_stmt|;
comment|/* Used to copy stuff into segment buffer */
name|u_long
modifier|*
name|block_array
decl_stmt|;
comment|/* Array of logical block nos to put in sum */
name|int
name|block_array_size
decl_stmt|;
comment|/* How many entries in block array */
name|int
name|bsize
decl_stmt|;
comment|/* Block size */
name|int
name|db_per_fb
decl_stmt|;
comment|/* Disk blocks per file block */
name|int
name|i
decl_stmt|;
name|int
name|sb_to_sum
decl_stmt|;
comment|/* offset between superblock and summary */
name|int
name|sb_interval
decl_stmt|;
comment|/* number of segs between super blocks */
name|int
name|seg_seek
decl_stmt|;
comment|/* Seek offset for a segment */
name|int
name|ssize
decl_stmt|;
comment|/* Segment size */
name|int
name|sum_size
decl_stmt|;
comment|/* Size of the summary block */
name|int
name|wbytes
decl_stmt|;
comment|/* Number of bytes returned by write */
name|lfsp
operator|=
operator|&
name|lfs_default
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bsize
operator|=
name|block_size
operator|)
condition|)
name|bsize
operator|=
name|DFL_LFSBLOCK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ssize
operator|=
name|seg_size
operator|)
condition|)
name|ssize
operator|=
name|DFL_LFSSEG
expr_stmt|;
comment|/* Modify parts of superblock overridden by command line arguments */
if|if
condition|(
name|bsize
operator|!=
name|DFL_LFSBLOCK
condition|)
block|{
name|lfsp
operator|->
name|lfs_bshift
operator|=
name|log2
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|!=
name|bsize
condition|)
name|fatal
argument_list|(
literal|"%d: block size not a power of 2"
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_bsize
operator|=
name|bsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_bmask
operator|=
name|bsize
operator|-
literal|1
expr_stmt|;
name|lfsp
operator|->
name|lfs_inopb
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
expr_stmt|;
comment|/* MIS -- should I round to power of 2 */
name|lfsp
operator|->
name|lfs_ifpb
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
name|IFILE
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_nindir
operator|=
name|bsize
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssize
operator|!=
name|DFL_LFSSEG
condition|)
block|{
name|lfsp
operator|->
name|lfs_segshift
operator|=
name|log2
argument_list|(
name|ssize
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<<
name|lfsp
operator|->
name|lfs_segshift
operator|!=
name|ssize
condition|)
name|fatal
argument_list|(
literal|"%d: segment size not power of 2"
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_ssize
operator|=
name|ssize
expr_stmt|;
name|lfsp
operator|->
name|lfs_segmask
operator|=
name|ssize
operator|-
literal|1
expr_stmt|;
block|}
name|lfsp
operator|->
name|lfs_ssize
operator|=
name|ssize
operator|>>
name|lfsp
operator|->
name|lfs_bshift
expr_stmt|;
if|if
condition|(
name|minfree
condition|)
name|lfsp
operator|->
name|lfs_minfree
operator|=
name|minfree
expr_stmt|;
comment|/* 	 * Fill in parts of superblock that can be computed from file system 	 * size, disk geometry and current time. 	 */
name|db_per_fb
operator|=
name|bsize
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_fsbtodb
operator|=
name|log2
argument_list|(
name|db_per_fb
argument_list|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_size
operator|=
name|partp
operator|->
name|p_size
operator|>>
name|lfsp
operator|->
name|lfs_fsbtodb
expr_stmt|;
name|lfsp
operator|->
name|lfs_dsize
operator|=
name|lfsp
operator|->
name|lfs_size
operator|-
operator|(
name|LFS_LABELPAD
operator|>>
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
name|lfsp
operator|->
name|lfs_nseg
operator|=
name|lfsp
operator|->
name|lfs_dsize
operator|/
name|lfsp
operator|->
name|lfs_ssize
expr_stmt|;
name|lfsp
operator|->
name|lfs_segtabsz
operator|=
name|SEGTABSIZE_SU
argument_list|(
name|lfsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lfsp
operator|->
name|lfs_tstamp
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"time: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sb_interval
operator|=
name|lfsp
operator|->
name|lfs_nseg
operator|/
name|LFS_MAXNUMSB
operator|)
operator|<
name|LFS_MIN_SBINTERVAL
condition|)
name|sb_interval
operator|=
name|LFS_MIN_SBINTERVAL
expr_stmt|;
comment|/* 	 * Now, lay out the file system.  We need to figure out where 	 * the superblocks go, initialize the checkpoint information 	 * for the first two superblocks, initialize the segment usage 	 * information, put the segusage information in the ifile, create 	 * the first block of IFILE structures, and link all the IFILE 	 * structures into a free list. 	 */
comment|/* Figure out where the superblocks are going to live */
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
operator|=
name|LFS_LABELPAD
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|LFS_MAXNUMSB
condition|;
name|i
operator|++
control|)
block|{
name|sb_addr
operator|=
operator|(
operator|(
name|i
operator|*
name|sb_interval
operator|)
operator|<<
operator|(
name|lfsp
operator|->
name|lfs_segshift
operator|-
name|lfsp
operator|->
name|lfs_bshift
operator|+
name|lfsp
operator|->
name|lfs_fsbtodb
operator|)
operator|)
operator|+
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sb_addr
operator|>
name|partp
operator|->
name|p_size
condition|)
break|break;
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
index|]
operator|=
name|sb_addr
expr_stmt|;
block|}
name|last_sb_addr
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|lfsp
operator|->
name|lfs_lastseg
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Initialize the segment usage table.  The first segment will 	 * contain the superblock, the segusage table (segtabsz), 1 	 * block's worth of IFILE entries, and one block's worth of inodes 	 * (containing the ifile inode). 	 */
if|if
condition|(
operator|!
operator|(
name|segtable
operator|=
name|malloc
argument_list|(
name|lfsp
operator|->
name|lfs_segtabsz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|segp
operator|=
name|segtable
expr_stmt|;
name|segp
operator|->
name|su_nbytes
operator|=
name|LFS_SBPAD
operator|+
operator|(
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|2
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
name|segp
operator|->
name|su_lastmod
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
name|segp
operator|->
name|su_flags
operator|=
name|SEGUSAGE_DIRTY
expr_stmt|;
comment|/* Now use su_nbytes to figure out the daddr of the ifile inode */
name|lfsp
operator|->
name|lfs_idaddr
operator|=
operator|(
operator|(
operator|(
name|segp
operator|->
name|su_nbytes
operator|>>
name|lfsp
operator|->
name|lfs_bshift
operator|)
operator|-
literal|1
operator|)
operator|<<
name|lfsp
operator|->
name|lfs_fsbtodb
operator|)
operator|+
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|segp
operator|=
name|segtable
operator|+
literal|1
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_nseg
condition|;
name|i
operator|++
operator|,
name|segp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
name|sb_interval
operator|)
operator|==
operator|(
name|sb_interval
operator|-
literal|1
operator|)
condition|)
name|segp
operator|->
name|su_nbytes
operator|=
name|LFS_SBPAD
expr_stmt|;
else|else
name|segp
operator|->
name|su_nbytes
operator|=
literal|0
expr_stmt|;
name|segp
operator|->
name|su_lastmod
operator|=
literal|0
expr_stmt|;
name|segp
operator|->
name|su_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Ready to start writing segments.  The first segment is different 	 * because it contains the segment usage table and the ifile inode 	 * as well as a superblock.  We don't have to write any segments which 	 * don't contain superblocks since they are marked as clean and do not 	 * containing any live bytes, so the only other segments we need to 	 * write are those containing superblock info.  For all these segments, 	 * set the time stamp to be 0 so that the first superblock looks like 	 * the most recent. 	 */
name|lfsp
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
name|LFS_SUPER
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lfsp
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|LFS_LABELPAD
argument_list|,
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
name|LFS_SUPER
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|LFS_LABELPAD
operator|+
name|LFS_SBPAD
argument_list|,
name|segtable
argument_list|,
name|lfsp
operator|->
name|lfs_segtabsz
operator|<<
name|lfsp
operator|->
name|lfs_bshift
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
name|segtable
argument_list|)
expr_stmt|;
comment|/* Create the first block of the ifile. */
if|if
condition|(
operator|!
operator|(
name|pagep
operator|=
name|malloc
argument_list|(
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ifile
operator|=
operator|(
name|IFILE
operator|*
operator|)
name|pagep
expr_stmt|;
for|for
control|(
name|ip
operator|=
operator|&
name|ifile
index|[
literal|2
index|]
operator|,
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_ifpb
condition|;
operator|++
name|ip
control|)
block|{
name|ip
operator|->
name|if_version
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|if_daddr
operator|=
name|LFS_UNUSED_DADDR
expr_stmt|;
name|ip
operator|->
name|if_nextfree
operator|=
operator|++
name|i
expr_stmt|;
block|}
name|ifile
index|[
name|lfsp
operator|->
name|lfs_ifpb
operator|-
literal|1
index|]
operator|.
name|if_nextfree
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
name|ip
operator|=
operator|&
name|ifile
index|[
name|LFS_IFILE_INUM
index|]
expr_stmt|;
name|ip
operator|->
name|if_version
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|if_daddr
operator|=
name|lfsp
operator|->
name|lfs_idaddr
expr_stmt|;
name|ip
operator|->
name|if_st_atime
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
if|if
condition|(
operator|(
name|wbytes
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|ifile
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wbytes
operator|!=
name|lfsp
operator|->
name|lfs_bsize
condition|)
name|fatal
argument_list|(
literal|"%s: short write (%d, not %d)"
argument_list|,
name|special
argument_list|,
name|wbytes
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* Now create a block of disk inodes */
name|dip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|pagep
expr_stmt|;
name|bzero
argument_list|(
name|dip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
argument_list|)
expr_stmt|;
name|dip
operator|->
name|di_mode
operator|=
name|IFREG
expr_stmt|;
name|dip
operator|->
name|di_nlink
operator|=
literal|1
expr_stmt|;
name|dip
operator|->
name|di_blocks
operator|=
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
expr_stmt|;
comment|/* If we ever need something longer than 32 bits, this changes */
name|dip
operator|->
name|di_size
operator|=
operator|(
name|dip
operator|->
name|di_blocks
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
expr_stmt|;
name|dip
operator|->
name|di_atime
operator|=
name|dip
operator|->
name|di_mtime
operator|=
name|dip
operator|->
name|di_ctime
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
name|dip
operator|->
name|di_inum
operator|=
name|LFS_IFILE_INUM
expr_stmt|;
define|#
directive|define
name|SEGERR
define|\
value|"Segusage table requires too many blocks; increase block or segment size."
if|if
condition|(
name|NDADDR
operator|<
name|lfsp
operator|->
name|lfs_segtabsz
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|SEGERR
argument_list|)
expr_stmt|;
name|sb_addr
operator|=
operator|(
name|LFS_LABELPAD
operator|+
name|LFS_SBPAD
operator|)
operator|/
name|lp
operator|->
name|d_secsize
expr_stmt|;
comment|/* Assign the block addresses for the ifile */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dip
operator|->
name|di_blocks
condition|;
name|i
operator|++
operator|,
name|sb_addr
operator|+=
name|db_per_fb
control|)
name|dip
operator|->
name|di_db
index|[
name|i
index|]
operator|=
name|sb_addr
expr_stmt|;
comment|/* Make all the other dinodes invalid */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|dip
operator|++
init|;
name|i
operator|<
name|lfsp
operator|->
name|lfs_inopb
condition|;
name|i
operator|++
operator|,
name|dip
operator|++
control|)
name|dip
operator|->
name|di_inum
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
comment|/* Finally, write out the inode block */
if|if
condition|(
operator|(
name|wbytes
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|pagep
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wbytes
operator|!=
name|lfsp
operator|->
name|lfs_bsize
condition|)
name|fatal
argument_list|(
literal|"%s: short write (%d, not %d)"
argument_list|,
name|special
argument_list|,
name|wbytes
argument_list|,
name|lfsp
operator|->
name|lfs_bsize
argument_list|)
expr_stmt|;
comment|/* MIS -- probably want to replace with "write block code" */
comment|/* Now it's time to write the summary for the first segment. */
name|summary
operator|.
name|ss_next
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
condition|?
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|1
index|]
else|:
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
name|summary
operator|.
name|ss_prev
operator|=
name|last_sb_addr
expr_stmt|;
name|summary
operator|.
name|ss_nextsum
operator|=
operator|-
literal|1
expr_stmt|;
name|summary
operator|.
name|ss_create
operator|=
name|lfsp
operator|->
name|lfs_tstamp
expr_stmt|;
name|summary
operator|.
name|ss_nfinfo
operator|=
literal|2
expr_stmt|;
name|summary
operator|.
name|ss_ninos
operator|=
literal|1
expr_stmt|;
comment|/* Superblock and disk label */
name|file_info
operator|.
name|fi_nblocks
operator|=
name|LFS_SBPAD
operator|>>
name|lfsp
operator|->
name|lfs_bshift
expr_stmt|;
name|file_info
operator|.
name|fi_version
operator|=
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_ino
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
comment|/* Make sure that we don't overflow a summary block. */
name|sum_size
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
operator|+
name|file_info
operator|.
name|fi_nblocks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|+
operator|(
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
define|#
directive|define
name|SUMERR
define|\
value|"Multiple summary blocks in segment 1 not yet implemented\nsummary is %d bytes."
if|if
condition|(
name|sum_size
operator|>
name|LFS_SUMMARY_SIZE
condition|)
name|fatal
argument_list|(
name|SUMERR
argument_list|,
name|sum_size
argument_list|)
expr_stmt|;
name|block_array_size
operator|=
name|file_info
operator|.
name|fi_nblocks
expr_stmt|;
if|if
condition|(
operator|(
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
operator|)
operator|>
name|block_array_size
condition|)
name|block_array_size
operator|=
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|block_array
operator|=
name|malloc
argument_list|(
name|block_array_size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in the array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_info
operator|.
name|fi_nblocks
condition|;
name|i
operator|++
control|)
name|block_array
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* copy into segment */
name|sump
operator|=
name|pagep
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|summary
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|file_info
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|block_array
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|file_info
operator|.
name|fi_nblocks
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|file_info
operator|.
name|fi_nblocks
expr_stmt|;
comment|/* Now, add the ifile */
name|file_info
operator|.
name|fi_nblocks
operator|=
name|lfsp
operator|->
name|lfs_segtabsz
operator|+
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_version
operator|=
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_ino
operator|=
name|LFS_IFILE_INUM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_info
operator|.
name|fi_nblocks
condition|;
name|i
operator|++
control|)
name|block_array
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|file_info
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|block_array
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|file_info
operator|.
name|fi_nblocks
argument_list|)
expr_stmt|;
name|sb_to_sum
operator|=
operator|(
name|lfsp
operator|->
name|lfs_ssize
operator|<<
name|lfsp
operator|->
name|lfs_bshift
operator|)
operator|-
name|LFS_SUMMARY_SIZE
expr_stmt|;
operator|(
operator|(
name|SEGSUM
operator|*
operator|)
name|pagep
operator|)
operator|->
name|ss_cksum
operator|=
name|cksum
argument_list|(
name|pagep
operator|+
sizeof|sizeof
argument_list|(
name|summary
operator|.
name|ss_cksum
argument_list|)
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|summary
operator|.
name|ss_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|LFS_LABELPAD
operator|+
name|sb_to_sum
argument_list|,
name|pagep
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
name|summary
operator|.
name|ss_nextsum
operator|=
operator|-
literal|1
expr_stmt|;
name|summary
operator|.
name|ss_create
operator|=
literal|0
expr_stmt|;
name|summary
operator|.
name|ss_nfinfo
operator|=
literal|1
expr_stmt|;
name|summary
operator|.
name|ss_ninos
operator|=
literal|0
expr_stmt|;
comment|/* Superblock */
name|file_info
operator|.
name|fi_nblocks
operator|=
name|LFS_SBPAD
operator|>>
name|lfsp
operator|->
name|lfs_bshift
expr_stmt|;
name|file_info
operator|.
name|fi_version
operator|=
literal|1
expr_stmt|;
name|file_info
operator|.
name|fi_ino
operator|=
name|LFS_UNUSED_INUM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_info
operator|.
name|fi_nblocks
condition|;
name|i
operator|++
control|)
name|block_array
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|sump
operator|=
name|pagep
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|summary
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|SEGSUM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|file_info
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|sump
operator|+=
sizeof|sizeof
argument_list|(
name|FINFO
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|block_array
argument_list|,
name|sump
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|file_info
operator|.
name|fi_nblocks
argument_list|)
expr_stmt|;
comment|/* Now, write rest of segments containing superblocks */
name|lfsp
operator|->
name|lfs_tstamp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
operator|(
name|SEGSUM
operator|*
operator|)
name|pagep
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|LFS_MAXNUMSB
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
index|]
condition|)
break|break;
name|sp
operator|->
name|ss_prev
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|LFS_MAXNUMSB
operator|-
literal|1
operator|)
condition|)
name|sp
operator|->
name|ss_next
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|sp
operator|->
name|ss_next
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
literal|0
index|]
expr_stmt|;
comment|/* Superblock */
name|seg_seek
operator|=
name|lfsp
operator|->
name|lfs_sboffs
index|[
name|i
index|]
operator|*
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|lfsp
operator|->
name|lfs_cksum
operator|=
name|cksum
argument_list|(
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
name|LFS_SUPER
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|lfsp
operator|->
name|lfs_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|seg_seek
argument_list|,
name|lfsp
argument_list|,
sizeof|sizeof
argument_list|(
name|LFS_SUPER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Summary */
name|sp
operator|->
name|ss_cksum
operator|=
name|cksum
argument_list|(
operator|&
name|sp
operator|->
name|ss_cksum
argument_list|,
name|LFS_SUMMARY_SIZE
operator|-
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|ss_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|put
argument_list|(
name|fd
argument_list|,
name|sb_to_sum
operator|+
name|seg_seek
argument_list|,
name|pagep
argument_list|,
name|LFS_SUMMARY_SIZE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
name|pagep
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put
parameter_list|(
name|fd
parameter_list|,
name|off
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|fd
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|int
name|wbytes
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wbytes
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"%s: %s"
argument_list|,
name|special
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wbytes
operator|!=
name|len
condition|)
name|fatal
argument_list|(
literal|"%s: short write (%d, not %d)"
argument_list|,
name|special
argument_list|,
name|wbytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

