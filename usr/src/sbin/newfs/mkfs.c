begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)mkfs.c	1.18 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * make file system for cylinder-group style file systems  *  * usage: mkfs special size [ nsect ntrak bsize fsize cpg ]  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STANDALONE
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/param.h"
end_include

begin_include
include|#
directive|include
file|"../h/inode.h"
end_include

begin_include
include|#
directive|include
file|"../h/fs.h"
end_include

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_define
define|#
directive|define
name|UMASK
value|0755
end_define

begin_define
define|#
directive|define
name|MAXINOPB
value|(MAXBSIZE / sizeof(struct dinode))
end_define

begin_define
define|#
directive|define
name|POWEROF2
parameter_list|(
name|num
parameter_list|)
value|(((num)& ((num) - 1)) == 0)
end_define

begin_union
union|union
block|{
name|struct
name|fs
name|fs
decl_stmt|;
name|char
name|pad
index|[
name|MAXBSIZE
index|]
decl_stmt|;
block|}
name|fsun
union|;
end_union

begin_define
define|#
directive|define
name|sblock
value|fsun.fs
end_define

begin_decl_stmt
name|struct
name|csum
modifier|*
name|fscs
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|cg
name|cg
decl_stmt|;
name|char
name|pad
index|[
name|MAXBSIZE
index|]
decl_stmt|;
block|}
name|cgun
union|;
end_union

begin_define
define|#
directive|define
name|acg
value|cgun.cg
end_define

begin_decl_stmt
name|struct
name|dinode
name|zino
index|[
name|MAXIPG
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fsys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|utime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fsi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fso
decl_stmt|;
end_decl_stmt

begin_function_decl
name|daddr_t
name|alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|long
name|cylno
decl_stmt|,
name|rpos
decl_stmt|,
name|blk
decl_stmt|,
name|i
decl_stmt|,
name|inos
decl_stmt|,
name|fssize
decl_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
name|time
argument_list|(
operator|&
name|utime
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"usage: mkfs special size [ nsect ntrak bsize fsize cpg ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fsys
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|fssize
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fso
operator|=
name|creat
argument_list|(
name|fsys
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fso
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot create\n"
argument_list|,
name|fsys
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fsi
operator|=
name|open
argument_list|(
name|fsys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsi
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot open\n"
argument_list|,
name|fsys
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
specifier|static
name|char
name|protos
index|[
literal|60
index|]
decl_stmt|;
name|char
name|fsbuf
index|[
literal|100
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"file sys size: "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|protos
argument_list|)
expr_stmt|;
name|fssize
operator|=
name|atoi
argument_list|(
name|protos
argument_list|)
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|"file system: "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|fsbuf
argument_list|)
expr_stmt|;
name|fso
operator|=
name|open
argument_list|(
name|fsbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fsi
operator|=
name|open
argument_list|(
name|fsbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fso
operator|<
literal|0
operator|||
name|fsi
operator|<
literal|0
condition|)
do|;
block|}
name|argc
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fssize
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"preposterous size %d\n"
argument_list|,
name|fssize
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * collect and verify the sector and track info 	 */
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|sblock
operator|.
name|fs_nsect
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|sblock
operator|.
name|fs_nsect
operator|=
name|DFLNSECT
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
name|sblock
operator|.
name|fs_ntrak
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|sblock
operator|.
name|fs_ntrak
operator|=
name|DFLNTRAK
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ntrak
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"preposterous ntrak %d\n"
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_nsect
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"preposterous nsect %d\n"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_spc
operator|=
name|sblock
operator|.
name|fs_ntrak
operator|*
name|sblock
operator|.
name|fs_nsect
expr_stmt|;
comment|/* 	 * collect and verify the block and fragment sizes 	 */
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|sblock
operator|.
name|fs_bsize
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|sblock
operator|.
name|fs_bsize
operator|=
name|MAXBSIZE
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|5
condition|)
name|sblock
operator|.
name|fs_fsize
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
else|else
name|sblock
operator|.
name|fs_fsize
operator|=
name|MAX
argument_list|(
name|sblock
operator|.
name|fs_bsize
operator|/
name|DESFRAG
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POWEROF2
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"block size must be a power of 2, not %d\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|POWEROF2
argument_list|(
name|sblock
operator|.
name|fs_fsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fragment size must be a power of 2, not %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_fsize
operator|<
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"fragment size %d is too small, minimum is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_bsize
operator|<
name|MINBSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"block size %d is too small, minimum is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|MINBSIZE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_bsize
operator|<
name|sblock
operator|.
name|fs_fsize
condition|)
block|{
name|printf
argument_list|(
literal|"block size (%d) cannot be smaller than fragment size (%d)\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_frag
operator|=
name|sblock
operator|.
name|fs_bsize
operator|/
name|sblock
operator|.
name|fs_fsize
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_frag
operator|>
name|MAXFRAG
condition|)
block|{
name|printf
argument_list|(
literal|"fragment size %d is too small, minimum with block size %d is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|/
name|MAXFRAG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_bblkno
operator|=
name|BBLOCK
expr_stmt|;
name|sblock
operator|.
name|fs_sblkno
operator|=
name|SBLOCK
expr_stmt|;
name|sblock
operator|.
name|fs_cblkno
operator|=
operator|(
name|daddr_t
operator|)
name|roundup
argument_list|(
name|howmany
argument_list|(
name|BBSIZE
operator|+
name|SBSIZE
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_iblkno
operator|=
name|sblock
operator|.
name|fs_cblkno
operator|+
name|sblock
operator|.
name|fs_frag
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_cpc
operator|=
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|,
name|i
operator|=
name|sblock
operator|.
name|fs_spc
init|;
name|sblock
operator|.
name|fs_cpc
operator|>
literal|1
operator|&&
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|sblock
operator|.
name|fs_cpc
operator|>>=
literal|1
operator|,
name|i
operator|>>=
literal|1
control|)
comment|/* void */
empty_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_cpc
operator|>
name|MAXCPG
condition|)
block|{
name|printf
argument_list|(
literal|"maximum block size with nsect %d and ntrak %d is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|/
operator|(
name|sblock
operator|.
name|fs_cpc
operator|/
name|MAXCPG
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * collect and verify the number of cylinders per group 	 */
if|if
condition|(
name|argc
operator|>
literal|6
condition|)
block|{
name|sblock
operator|.
name|fs_cpg
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_fpg
operator|=
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sblock
operator|.
name|fs_cpg
operator|=
name|MAX
argument_list|(
name|sblock
operator|.
name|fs_cpc
argument_list|,
name|DESCPG
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_fpg
operator|=
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
while|while
condition|(
name|sblock
operator|.
name|fs_fpg
operator|/
name|sblock
operator|.
name|fs_frag
operator|>
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|&&
name|sblock
operator|.
name|fs_cpg
operator|>
name|sblock
operator|.
name|fs_cpc
condition|)
block|{
name|sblock
operator|.
name|fs_cpg
operator|-=
name|sblock
operator|.
name|fs_cpc
expr_stmt|;
name|sblock
operator|.
name|fs_fpg
operator|=
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"cylinder groups must have at least 1 cylinder\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|>
name|MAXCPG
condition|)
block|{
name|printf
argument_list|(
literal|"cylinder groups are limited to %d cylinders\n"
argument_list|,
name|MAXCPG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|%
name|sblock
operator|.
name|fs_cpc
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cylinder groups must have a multiple of %d cylinders\n"
argument_list|,
name|sblock
operator|.
name|fs_cpc
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now have size for file system and nsect and ntrak. 	 * Determine number of cylinders and blocks in the file system. 	 */
name|sblock
operator|.
name|fs_size
operator|=
name|fssize
operator|=
name|dbtofsb
argument_list|(
operator|&
name|sblock
argument_list|,
name|fssize
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ncyl
operator|=
name|fssize
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|/
name|sblock
operator|.
name|fs_spc
expr_stmt|;
if|if
condition|(
name|fssize
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
name|sblock
operator|.
name|fs_ncyl
operator|*
name|sblock
operator|.
name|fs_spc
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: %d sector(s) in last cylinder unallocated\n"
argument_list|,
name|sblock
operator|.
name|fs_spc
operator|-
operator|(
name|fssize
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|-
name|sblock
operator|.
name|fs_ncyl
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ncyl
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncyl
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"file systems must have at least one cylinder\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * determine feasability/values of rotational layout tables 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_ntrak
operator|==
literal|1
condition|)
block|{
name|sblock
operator|.
name|fs_cpc
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_spc
operator|*
name|sblock
operator|.
name|fs_cpc
operator|>
name|MAXBPC
operator|*
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|||
name|sblock
operator|.
name|fs_nsect
operator|>
operator|(
literal|1
operator|<<
name|NBBY
operator|)
operator|*
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s %d %s %d.%s"
argument_list|,
literal|"Warning: insufficient space in super block for\n"
argument_list|,
literal|"rotational layout tables with nsect"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|,
literal|"and ntrak"
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
literal|"\nFile system performance may be impared.\n"
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cpc
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 	 * calculate the available blocks for each rotational position 	 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|MAXCPG
condition|;
name|cylno
operator|++
control|)
for|for
control|(
name|rpos
operator|=
literal|0
init|;
name|rpos
operator|<
name|NRPOS
condition|;
name|rpos
operator|++
control|)
name|sblock
operator|.
name|fs_postbl
index|[
name|cylno
index|]
index|[
name|rpos
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|blk
operator|=
name|sblock
operator|.
name|fs_spc
operator|*
name|sblock
operator|.
name|fs_cpc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blk
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
comment|/* void */
empty_stmt|;
for|for
control|(
name|i
operator|-=
name|sblock
operator|.
name|fs_frag
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|cylno
operator|=
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rpos
operator|=
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|blk
operator|=
name|i
operator|/
name|sblock
operator|.
name|fs_frag
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_postbl
index|[
name|cylno
index|]
index|[
name|rpos
index|]
operator|==
operator|-
literal|1
condition|)
name|sblock
operator|.
name|fs_rotbl
index|[
name|blk
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|sblock
operator|.
name|fs_rotbl
index|[
name|blk
index|]
operator|=
name|sblock
operator|.
name|fs_postbl
index|[
name|cylno
index|]
index|[
name|rpos
index|]
operator|-
name|blk
expr_stmt|;
name|sblock
operator|.
name|fs_postbl
index|[
name|cylno
index|]
index|[
name|rpos
index|]
operator|=
name|blk
expr_stmt|;
block|}
name|next
label|:
comment|/* 	 * Validate specified/determined cpg. 	 */
if|if
condition|(
name|sblock
operator|.
name|fs_spc
operator|>
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"too many sectors per cylinder (%d sectors)\n"
argument_list|,
name|sblock
operator|.
name|fs_spc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sblock
operator|.
name|fs_spc
operator|>
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|sblock
operator|.
name|fs_bsize
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_frag
operator|<
name|MAXFRAG
condition|)
name|sblock
operator|.
name|fs_frag
operator|<<=
literal|1
expr_stmt|;
else|else
name|sblock
operator|.
name|fs_fsize
operator|<<=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"nsect %d, and ntrak %d, requires block size of %d,\n"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tand fragment size of %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_fpg
operator|>
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|sblock
operator|.
name|fs_frag
condition|)
block|{
name|printf
argument_list|(
literal|"cylinder group too large (%d cylinders); "
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"max: %d cylinders per group\n"
argument_list|,
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|*
name|sblock
operator|.
name|fs_frag
operator|/
operator|(
name|sblock
operator|.
name|fs_fpg
operator|/
name|sblock
operator|.
name|fs_cpg
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_cgsize
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cg
argument_list|)
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_fpg
argument_list|,
name|NBBY
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
comment|/* 	 * Compute/validate number of cylinder groups. 	 */
name|sblock
operator|.
name|fs_ncg
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|/
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
condition|)
name|sblock
operator|.
name|fs_ncg
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sblock
operator|.
name|fs_spc
operator|*
name|sblock
operator|.
name|fs_cpg
operator|)
operator|%
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"mkfs: nsect %d, ntrak %d, cpg %d is not tolerable\n"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"as this would would have cyl groups whose size\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is not a multiple of %d; choke!\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Compute number of inode blocks per cylinder group. 	 * Start with one inode per NBPI bytes; adjust as necessary. 	 */
name|i
operator|=
name|sblock
operator|.
name|fs_iblkno
operator|+
name|MAXIPG
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|inos
operator|=
operator|(
name|fssize
operator|-
name|sblock
operator|.
name|fs_ncg
operator|*
name|i
operator|)
operator|*
name|sblock
operator|.
name|fs_fsize
operator|/
name|MAX
argument_list|(
name|NBPI
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
operator|/
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|inos
operator|<=
literal|0
condition|)
name|inos
operator|=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_ipg
operator|=
operator|(
operator|(
name|inos
operator|/
name|sblock
operator|.
name|fs_ncg
operator|)
operator|+
literal|1
operator|)
operator|*
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ipg
operator|>
name|MAXIPG
condition|)
name|sblock
operator|.
name|fs_ipg
operator|=
name|MAXIPG
expr_stmt|;
name|sblock
operator|.
name|fs_dblkno
operator|=
name|sblock
operator|.
name|fs_iblkno
operator|+
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
operator|>=
name|sblock
operator|.
name|fs_fpg
condition|)
block|{
name|printf
argument_list|(
literal|"inode blocks/cyl group (%d)>= data blocks (%d)\n"
argument_list|,
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|,
name|sblock
operator|.
name|fs_fpg
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"number of cylinder per cylinder group must be increased\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * fill in remaining fields of the super block 	 */
name|sblock
operator|.
name|fs_csaddr
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cssize
operator|=
name|sblock
operator|.
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|csum
argument_list|)
expr_stmt|;
name|fscs
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_magic
operator|=
name|FS_MAGIC
expr_stmt|;
name|sblock
operator|.
name|fs_rotdelay
operator|=
name|ROTDELAY
expr_stmt|;
name|sblock
operator|.
name|fs_minfree
operator|=
name|MINFREE
expr_stmt|;
name|sblock
operator|.
name|fs_rps
operator|=
name|HZ
expr_stmt|;
comment|/* assume disk speed == HZ */
name|sblock
operator|.
name|fs_cgrotor
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_ronly
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Dump out summary information about file system. 	 */
name|printf
argument_list|(
literal|"%s:\t%d sectors in %d cylinders of %d tracks, %d sectors\n"
argument_list|,
name|fsys
argument_list|,
name|sblock
operator|.
name|fs_size
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_ncyl
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%.1fMb in %d cyl groups (%d c/g, %.2fMb/g, %d i/g)\n"
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
literal|1e-6
argument_list|,
name|sblock
operator|.
name|fs_ncg
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_fpg
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
literal|1e-6
argument_list|,
name|sblock
operator|.
name|fs_ipg
argument_list|)
expr_stmt|;
comment|/* 	 * Now build the cylinders group blocks and 	 * then print out indices of cylinder groups. 	 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
name|initcg
argument_list|(
name|cylno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ncg
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Warning: no super-block backups with only one cylinder group\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tsuper-block backups (for fsck -b#) at %d+k*%d (%d .. %d)\n"
argument_list|,
name|SBLOCK
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
literal|1
argument_list|)
operator|-
name|SBLOCK
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
literal|1
argument_list|)
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now construct the initial file system, 	 * then write out the super-block. 	 */
name|fsinit
argument_list|()
expr_stmt|;
name|sblock
operator|.
name|fs_time
operator|=
name|utime
expr_stmt|;
name|wtfs
argument_list|(
name|SBLOCK
argument_list|,
name|SBSIZE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
control|)
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|i
operator|/
name|sblock
operator|.
name|fs_fsize
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|fscs
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/*  	 * Write out the duplicate super blocks 	 */
for|for
control|(
name|cylno
operator|=
literal|1
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
name|wtfs
argument_list|(
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|,
name|SBSIZE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize a cylinder group.  */
end_comment

begin_macro
name|initcg
argument_list|(
argument|cylno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cylno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|daddr_t
name|cbase
decl_stmt|,
name|d
decl_stmt|,
name|dmin
decl_stmt|,
name|dmax
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
comment|/* 	 * Determine block bounds for cylinder group. 	 * Allow space for super block summary information in first 	 * cylinder group. 	 */
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|dmin
operator|=
name|sblock
operator|.
name|fs_dblkno
expr_stmt|;
name|d
operator|=
name|cbase
expr_stmt|;
name|cs
operator|=
name|fscs
operator|+
name|cylno
expr_stmt|;
name|acg
operator|.
name|cg_time
operator|=
name|utime
expr_stmt|;
name|acg
operator|.
name|cg_magic
operator|=
name|CG_MAGIC
expr_stmt|;
name|acg
operator|.
name|cg_cgx
operator|=
name|cylno
expr_stmt|;
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|acg
operator|.
name|cg_niblk
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|acg
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|cbase
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_rotor
operator|=
name|dmin
expr_stmt|;
name|acg
operator|.
name|cg_frotor
operator|=
name|dmin
expr_stmt|;
name|acg
operator|.
name|cg_irotor
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
condition|;
control|)
block|{
for|for
control|(
name|j
operator|=
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|clrbit
argument_list|(
name|acg
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|+=
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROOTINO
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|acg
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|MAXIPG
condition|)
block|{
name|clrbit
argument_list|(
name|acg
operator|.
name|cg_iused
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|lseek
argument_list|(
name|fso
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgimin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fso
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zino
argument_list|,
name|sblock
operator|.
name|fs_ipg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
argument_list|)
operator|!=
name|sblock
operator|.
name|fs_ipg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
condition|)
name|printf
argument_list|(
literal|"write error %D\n"
argument_list|,
name|tell
argument_list|(
name|fso
argument_list|)
operator|/
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPG
condition|;
name|i
operator|++
control|)
block|{
name|acg
operator|.
name|cg_btot
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NRPOS
condition|;
name|j
operator|++
control|)
name|acg
operator|.
name|cg_b
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
block|{
name|dmin
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
operator|*
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dmin
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_free
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|)
operator|<=
name|dmax
operator|-
name|cbase
condition|)
block|{
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_free
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|acg
operator|.
name|cg_btot
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|acg
operator|.
name|cg_b
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|dmax
operator|-
name|cbase
condition|)
name|acg
operator|.
name|cg_frsum
index|[
name|dmax
operator|-
name|cbase
operator|-
name|d
index|]
operator|++
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|dmax
operator|-
name|cbase
condition|;
name|d
operator|++
control|)
block|{
name|setbit
argument_list|(
name|acg
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|d
operator|<
name|MAXBPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|d
operator|++
control|)
name|clrbit
argument_list|(
name|acg
operator|.
name|cg_free
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_dsize
operator|+=
name|acg
operator|.
name|cg_ndblk
operator|-
name|dmin
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * initialize the file system  */
end_comment

begin_decl_stmt
name|struct
name|inode
name|node
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PREDEFDIR
value|3
end_define

begin_decl_stmt
name|struct
name|direct
name|root_dir
index|[]
init|=
block|{
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|1
block|,
literal|"."
block|}
block|,
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|2
block|,
literal|".."
block|}
block|,
block|{
name|LOSTFOUNDINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|10
block|,
literal|"lost+found"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|direct
name|lost_found_dir
index|[]
init|=
block|{
block|{
name|LOSTFOUNDINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|1
block|,
literal|"."
block|}
block|,
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|2
block|,
literal|".."
block|}
block|,
block|{
literal|0
block|,
name|DIRBLKSIZ
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|fsinit
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * initialize the node 	 */
name|node
operator|.
name|i_atime
operator|=
name|utime
expr_stmt|;
name|node
operator|.
name|i_mtime
operator|=
name|utime
expr_stmt|;
name|node
operator|.
name|i_ctime
operator|=
name|utime
expr_stmt|;
comment|/* 	 * create the lost+found directory 	 */
operator|(
name|void
operator|)
name|makedir
argument_list|(
name|lost_found_dir
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DIRBLKSIZ
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
condition|;
name|i
operator|+=
name|DIRBLKSIZ
control|)
name|bcopy
argument_list|(
operator|&
name|lost_found_dir
index|[
literal|2
index|]
argument_list|,
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
name|DIRSIZ
argument_list|(
operator|&
name|lost_found_dir
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|i_number
operator|=
name|LOSTFOUNDINO
expr_stmt|;
name|node
operator|.
name|i_mode
operator|=
name|IFDIR
operator||
name|UMASK
expr_stmt|;
name|node
operator|.
name|i_nlink
operator|=
literal|2
expr_stmt|;
name|node
operator|.
name|i_size
operator|=
name|sblock
operator|.
name|fs_bsize
expr_stmt|;
name|node
operator|.
name|i_db
index|[
literal|0
index|]
operator|=
name|alloc
argument_list|(
name|node
operator|.
name|i_size
argument_list|,
name|node
operator|.
name|i_mode
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|node
operator|.
name|i_db
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|node
operator|.
name|i_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|iput
argument_list|(
operator|&
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * create the root directory 	 */
name|node
operator|.
name|i_number
operator|=
name|ROOTINO
expr_stmt|;
name|node
operator|.
name|i_mode
operator|=
name|IFDIR
operator||
name|UMASK
expr_stmt|;
name|node
operator|.
name|i_nlink
operator|=
name|PREDEFDIR
expr_stmt|;
name|node
operator|.
name|i_size
operator|=
name|makedir
argument_list|(
name|root_dir
argument_list|,
name|PREDEFDIR
argument_list|)
expr_stmt|;
name|node
operator|.
name|i_db
index|[
literal|0
index|]
operator|=
name|alloc
argument_list|(
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|node
operator|.
name|i_mode
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|node
operator|.
name|i_db
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|iput
argument_list|(
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * construct a set of directory entries in "buf".  * return size of directory.  */
end_comment

begin_expr_stmt
name|makedir
argument_list|(
name|protodir
argument_list|,
name|entries
argument_list|)
specifier|register
expr|struct
name|direct
operator|*
name|protodir
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|entries
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|spcleft
decl_stmt|;
name|spcleft
operator|=
name|DIRBLKSIZ
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|,
name|cp
argument_list|,
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
expr_stmt|;
name|spcleft
operator|-=
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
expr_stmt|;
block|}
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|=
name|spcleft
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|,
name|cp
argument_list|,
name|DIRSIZ
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|DIRSIZ
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * allocate a block or frag  */
end_comment

begin_function
name|daddr_t
name|alloc
parameter_list|(
name|size
parameter_list|,
name|mode
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|frag
decl_stmt|;
name|daddr_t
name|d
decl_stmt|;
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cgsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
if|if
condition|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"first cylinder group ran out of space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|acg
operator|.
name|cg_ndblk
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_free
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
goto|goto
name|goth
goto|;
name|printf
argument_list|(
literal|"internal error: can't find block in cyl 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|goth
label|:
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|acg
operator|.
name|cg_free
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|IFDIR
condition|)
block|{
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_ndir
operator|++
expr_stmt|;
block|}
name|acg
operator|.
name|cg_btot
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
name|acg
operator|.
name|cg_b
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|frag
operator|=
name|howmany
argument_list|(
name|size
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
expr_stmt|;
name|acg
operator|.
name|cg_frsum
index|[
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|frag
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|acg
operator|.
name|cg_free
argument_list|,
name|d
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cgsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an inode on the disk  */
end_comment

begin_expr_stmt
name|iput
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|inode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|dinode
name|buf
index|[
name|MAXINOPB
index|]
decl_stmt|;
name|daddr_t
name|d
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|itog
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cgsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|setbit
argument_list|(
name|acg
operator|.
name|cg_iused
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|c
argument_list|)
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cgsize
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_nifree
operator|--
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_number
operator|>=
name|sblock
operator|.
name|fs_ipg
operator|*
name|sblock
operator|.
name|fs_ncg
condition|)
block|{
name|printf
argument_list|(
literal|"fsinit: inode value out of range (%d).\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|itod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|itoo
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
index|]
operator|.
name|di_ic
operator|=
name|ip
operator|->
name|i_ic
expr_stmt|;
name|wtfs
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read a block from the file system  */
end_comment

begin_macro
name|rdfs
argument_list|(
argument|bno
argument_list|,
argument|size
argument_list|,
argument|bf
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fsi
argument_list|,
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"seek error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"rdfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|read
argument_list|(
name|fsi
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"read error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"rdfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * write a block to the file system  */
end_comment

begin_macro
name|wtfs
argument_list|(
argument|bno
argument_list|,
argument|size
argument_list|,
argument|bf
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|lseek
argument_list|(
name|fso
argument_list|,
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fso
argument_list|,
name|bno
operator|*
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"seek error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"wtfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|write
argument_list|(
name|fso
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"write error: %D\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"wtfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * copy a block  */
end_comment

begin_macro
name|bcopy
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("	movc3	12(ap),*4(ap),*8(ap)");
block|}
end_block

begin_comment
comment|/*  * check if a block is available  */
end_comment

begin_macro
name|isblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|mask
decl_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
return|return
operator|(
name|cp
index|[
name|h
index|]
operator|==
literal|0xff
operator|)
return|;
case|case
literal|4
case|:
name|mask
operator|=
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|2
case|:
name|mask
operator|=
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|1
case|:
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * take a block out of the map  */
end_comment

begin_macro
name|clrblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
operator|(
name|fs
operator|)
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&=
operator|~
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&=
operator|~
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
return|return;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clrblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * put a block into the map  */
end_comment

begin_macro
name|setblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0xff
expr_stmt|;
return|return;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator||=
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator||=
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
return|return;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

end_unit

