begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mkfs.c	6.10 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDALONE
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_comment
comment|/*  * make file system for cylinder-group style file systems  */
end_comment

begin_comment
comment|/*  * The size of a cylinder group is calculated by CGSIZE. The maximum size  * is limited by the fact that cylinder groups are at most one block.  * Its size is derived from the size of the maps maintained in the   * cylinder group and the (struct cg) size.  */
end_comment

begin_define
define|#
directive|define
name|CGSIZE
parameter_list|(
name|fs
parameter_list|)
define|\
comment|/* base cg */
value|(sizeof(struct cg) + \
comment|/* blktot size */
value|(fs)->fs_cpg * sizeof(long) + \
comment|/* blks size */
value|(fs)->fs_cpg * (fs)->fs_nrpos * sizeof(short) + \
comment|/* inode map */
value|howmany((fs)->fs_ipg, NBBY) + \
comment|/* block map */
value|howmany((fs)->fs_cpg * (fs)->fs_spc / NSPF(fs), NBBY))
end_define

begin_comment
comment|/*  * We limit the size of the inode map to be no more than a  * third of the cylinder group space, since we must leave at  * least an equal amount of space for the block map.  *  * N.B.: MAXIPG must be a multiple of INOPB(fs).  */
end_comment

begin_define
define|#
directive|define
name|MAXIPG
parameter_list|(
name|fs
parameter_list|)
value|roundup((fs)->fs_bsize * NBBY / 3, INOPB(fs))
end_define

begin_define
define|#
directive|define
name|UMASK
value|0755
end_define

begin_define
define|#
directive|define
name|MAXINOPB
value|(MAXBSIZE / sizeof(struct dinode))
end_define

begin_define
define|#
directive|define
name|POWEROF2
parameter_list|(
name|num
parameter_list|)
value|(((num)& ((num) - 1)) == 0)
end_define

begin_comment
comment|/*  * variables set up by front end.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|Nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run mkfs without writing file system */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fssize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file system size */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ntracks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tracks/cylinder */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nsectors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # sectors/track */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nphyssectors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # sectors/track including spares */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|secpercyl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sectors per cylinder */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sectorsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bytes/sector */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rpm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* revolutions/minute of drive */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|interleave
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hardware sector interleave */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|trackskew
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sector 0 skew, per track */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|headswitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head switch time, usec */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|trackseek
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* track-to-track seek, usec */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fragment size */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* block size */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cpg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cylinders/cylinder group */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cpgflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cylinders/cylinder group flag was given */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|minfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free space threshold */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|opt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optimization preference (space or time) */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|density
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes per inode */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|maxcontig
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max contiguous blocks to allocate */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rotdelay
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rotational delay between blocks */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|maxbpg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum blocks per file in a cyl group */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nrpos
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of distinguished rotational positions */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bbsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boot block size */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sbsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* superblock size */
end_comment

begin_union
union|union
block|{
name|struct
name|fs
name|fs
decl_stmt|;
name|char
name|pad
index|[
name|SBSIZE
index|]
decl_stmt|;
block|}
name|fsun
union|;
end_union

begin_define
define|#
directive|define
name|sblock
value|fsun.fs
end_define

begin_decl_stmt
name|struct
name|csum
modifier|*
name|fscs
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|cg
name|cg
decl_stmt|;
name|char
name|pad
index|[
name|MAXBSIZE
index|]
decl_stmt|;
block|}
name|cgun
union|;
end_union

begin_define
define|#
directive|define
name|acg
value|cgun.cg
end_define

begin_decl_stmt
name|struct
name|dinode
name|zino
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fsi
decl_stmt|,
name|fso
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|utime
decl_stmt|;
end_decl_stmt

begin_function_decl
name|daddr_t
name|alloc
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|mkfs
argument_list|(
argument|pp
argument_list|,
argument|fsys
argument_list|,
argument|fi
argument_list|,
argument|fo
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fsys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fi
decl_stmt|,
name|fo
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|long
name|i
decl_stmt|,
name|mincpc
decl_stmt|,
name|mincpg
decl_stmt|,
name|inospercg
decl_stmt|;
name|long
name|cylno
decl_stmt|,
name|rpos
decl_stmt|,
name|blk
decl_stmt|,
name|j
decl_stmt|,
name|warn
init|=
literal|0
decl_stmt|;
name|long
name|used
decl_stmt|,
name|mincpgcnt
decl_stmt|,
name|bpcg
decl_stmt|;
name|long
name|mapcramped
decl_stmt|,
name|inodecramped
decl_stmt|;
name|long
name|postblsize
decl_stmt|,
name|rotblsize
decl_stmt|,
name|totalsbsize
decl_stmt|;
ifndef|#
directive|ifndef
name|STANDALONE
name|time
argument_list|(
operator|&
name|utime
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fsi
operator|=
name|fi
expr_stmt|;
name|fso
operator|=
name|fo
expr_stmt|;
comment|/* 	 * Validate the given file system size. 	 * Verify that its last block can actually be accessed. 	 */
if|if
condition|(
name|fssize
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"preposterous size %d\n"
argument_list|,
name|fssize
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fssize
operator|-
literal|1
argument_list|,
name|sectorsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|)
expr_stmt|;
comment|/* 	 * collect and verify the sector and track info 	 */
name|sblock
operator|.
name|fs_nsect
operator|=
name|nsectors
expr_stmt|;
name|sblock
operator|.
name|fs_ntrak
operator|=
name|ntracks
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ntrak
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"preposterous ntrak %d\n"
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_nsect
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"preposterous nsect %d\n"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * collect and verify the block and fragment sizes 	 */
name|sblock
operator|.
name|fs_bsize
operator|=
name|bsize
expr_stmt|;
name|sblock
operator|.
name|fs_fsize
operator|=
name|fsize
expr_stmt|;
if|if
condition|(
operator|!
name|POWEROF2
argument_list|(
name|sblock
operator|.
name|fs_bsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"block size must be a power of 2, not %d\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|POWEROF2
argument_list|(
name|sblock
operator|.
name|fs_fsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fragment size must be a power of 2, not %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_fsize
operator|<
name|sectorsize
condition|)
block|{
name|printf
argument_list|(
literal|"fragment size %d is too small, minimum is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|sectorsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_bsize
operator|<
name|MINBSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"block size %d is too small, minimum is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|MINBSIZE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_bsize
operator|<
name|sblock
operator|.
name|fs_fsize
condition|)
block|{
name|printf
argument_list|(
literal|"block size (%d) cannot be smaller than fragment size (%d)\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_bmask
operator|=
operator|~
operator|(
name|sblock
operator|.
name|fs_bsize
operator|-
literal|1
operator|)
expr_stmt|;
name|sblock
operator|.
name|fs_fmask
operator|=
operator|~
operator|(
name|sblock
operator|.
name|fs_fsize
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Planning now for future expansion. 	 */
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
name|sblock
operator|.
name|fs_qbmask
operator|.
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_qbmask
operator|.
name|val
index|[
literal|1
index|]
operator|=
operator|~
name|sblock
operator|.
name|fs_bmask
expr_stmt|;
name|sblock
operator|.
name|fs_qfmask
operator|.
name|val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_qfmask
operator|.
name|val
index|[
literal|1
index|]
operator|=
operator|~
name|sblock
operator|.
name|fs_fmask
expr_stmt|;
endif|#
directive|endif
comment|/* BIG_ENDIAN */
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
operator|)
name|sblock
operator|.
name|fs_qbmask
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|~
name|sblock
operator|.
name|fs_bmask
expr_stmt|;
name|sblock
operator|.
name|fs_qbmask
operator|.
name|val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_qfmask
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|~
name|sblock
operator|.
name|fs_fmask
expr_stmt|;
name|sblock
operator|.
name|fs_qfmask
operator|.
name|val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* LITTLE_ENDIAN */
for|for
control|(
name|sblock
operator|.
name|fs_bshift
operator|=
literal|0
operator|,
name|i
operator|=
name|sblock
operator|.
name|fs_bsize
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|>>=
literal|1
control|)
name|sblock
operator|.
name|fs_bshift
operator|++
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_fshift
operator|=
literal|0
operator|,
name|i
operator|=
name|sblock
operator|.
name|fs_fsize
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|>>=
literal|1
control|)
name|sblock
operator|.
name|fs_fshift
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_frag
operator|=
name|numfrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_fragshift
operator|=
literal|0
operator|,
name|i
operator|=
name|sblock
operator|.
name|fs_frag
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|>>=
literal|1
control|)
name|sblock
operator|.
name|fs_fragshift
operator|++
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_frag
operator|>
name|MAXFRAG
condition|)
block|{
name|printf
argument_list|(
literal|"fragment size %d is too small, minimum with block size %d is %d\n"
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|sblock
operator|.
name|fs_bsize
operator|/
name|MAXFRAG
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_nrpos
operator|=
name|nrpos
expr_stmt|;
name|sblock
operator|.
name|fs_nindir
operator|=
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
name|daddr_t
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_inopb
operator|=
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_nspf
operator|=
name|sblock
operator|.
name|fs_fsize
operator|/
name|sectorsize
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_fsbtodb
operator|=
literal|0
operator|,
name|i
operator|=
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|>>=
literal|1
control|)
name|sblock
operator|.
name|fs_fsbtodb
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_sblkno
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
name|bbsize
operator|+
name|sbsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cblkno
operator|=
call|(
name|daddr_t
call|)
argument_list|(
name|sblock
operator|.
name|fs_sblkno
operator|+
name|roundup
argument_list|(
name|howmany
argument_list|(
name|sbsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_iblkno
operator|=
name|sblock
operator|.
name|fs_cblkno
operator|+
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|sblock
operator|.
name|fs_cgoffset
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_nsect
argument_list|,
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_cgmask
operator|=
literal|0xffffffff
operator|,
name|i
operator|=
name|sblock
operator|.
name|fs_ntrak
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|>>=
literal|1
control|)
name|sblock
operator|.
name|fs_cgmask
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|POWEROF2
argument_list|(
name|sblock
operator|.
name|fs_ntrak
argument_list|)
condition|)
name|sblock
operator|.
name|fs_cgmask
operator|<<=
literal|1
expr_stmt|;
comment|/* 	 * Validate specified/determined secpercyl 	 * and calculate minimum cylinders per group. 	 */
name|sblock
operator|.
name|fs_spc
operator|=
name|secpercyl
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_cpc
operator|=
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|,
name|i
operator|=
name|sblock
operator|.
name|fs_spc
init|;
name|sblock
operator|.
name|fs_cpc
operator|>
literal|1
operator|&&
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|sblock
operator|.
name|fs_cpc
operator|>>=
literal|1
operator|,
name|i
operator|>>=
literal|1
control|)
comment|/* void */
empty_stmt|;
name|mincpc
operator|=
name|sblock
operator|.
name|fs_cpc
expr_stmt|;
name|bpcg
operator|=
name|sblock
operator|.
name|fs_spc
operator|*
name|sectorsize
expr_stmt|;
name|inospercg
operator|=
name|roundup
argument_list|(
name|bpcg
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
argument_list|,
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inospercg
operator|>
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
name|inospercg
operator|=
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|used
operator|=
operator|(
name|sblock
operator|.
name|fs_iblkno
operator|+
name|inospercg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|)
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|mincpgcnt
operator|=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cgoffset
operator|*
operator|(
operator|~
name|sblock
operator|.
name|fs_cgmask
operator|)
operator|+
name|used
argument_list|,
name|sblock
operator|.
name|fs_spc
argument_list|)
expr_stmt|;
name|mincpg
operator|=
name|roundup
argument_list|(
name|mincpgcnt
argument_list|,
name|mincpc
argument_list|)
expr_stmt|;
comment|/* 	 * Insure that cylinder group with mincpg has enough space 	 * for block maps 	 */
name|sblock
operator|.
name|fs_cpg
operator|=
name|mincpg
expr_stmt|;
name|sblock
operator|.
name|fs_ipg
operator|=
name|inospercg
expr_stmt|;
name|mapcramped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|CGSIZE
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|mapcramped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_bsize
operator|<
name|MAXBSIZE
condition|)
block|{
name|sblock
operator|.
name|fs_bsize
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|>>=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sblock
operator|.
name|fs_cpc
operator|<<=
literal|1
expr_stmt|;
name|mincpc
operator|<<=
literal|1
expr_stmt|;
name|mincpg
operator|=
name|roundup
argument_list|(
name|mincpgcnt
argument_list|,
name|mincpc
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cpg
operator|=
name|mincpg
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_frag
operator|<<=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_fragshift
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_frag
operator|<=
name|MAXFRAG
condition|)
continue|continue;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_fsize
operator|==
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|printf
argument_list|(
literal|"There is no block size that"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" can support this disk\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_frag
operator|>>=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_fragshift
operator|-=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_fsize
operator|<<=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_nspf
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Insure that cylinder group with mincpg has enough space for inodes 	 */
name|inodecramped
operator|=
literal|0
expr_stmt|;
name|used
operator|*=
name|sectorsize
expr_stmt|;
name|inospercg
operator|=
name|roundup
argument_list|(
operator|(
name|mincpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|density
argument_list|,
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ipg
operator|=
name|inospercg
expr_stmt|;
while|while
condition|(
name|inospercg
operator|>
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|inodecramped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mincpc
operator|==
literal|1
operator|||
name|sblock
operator|.
name|fs_frag
operator|==
literal|1
operator|||
name|sblock
operator|.
name|fs_bsize
operator|==
name|MINBSIZE
condition|)
break|break;
name|printf
argument_list|(
literal|"With a block size of %d %s %d\n"
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
literal|"minimum bytes per inode is"
argument_list|,
operator|(
name|mincpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_bsize
operator|>>=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_frag
operator|>>=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_fragshift
operator|-=
literal|1
expr_stmt|;
name|mincpc
operator|>>=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_cpg
operator|=
name|roundup
argument_list|(
name|mincpgcnt
argument_list|,
name|mincpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|CGSIZE
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|sblock
operator|.
name|fs_bsize
operator|<<=
literal|1
expr_stmt|;
break|break;
block|}
name|mincpg
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|inospercg
operator|=
name|roundup
argument_list|(
operator|(
name|mincpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|density
argument_list|,
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ipg
operator|=
name|inospercg
expr_stmt|;
block|}
if|if
condition|(
name|inodecramped
condition|)
block|{
if|if
condition|(
name|inospercg
operator|>
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Minimum bytes per inode is %d\n"
argument_list|,
operator|(
name|mincpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mapcramped
condition|)
block|{
name|printf
argument_list|(
literal|"With %d bytes per inode, "
argument_list|,
name|density
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"minimum cylinders per group is %d\n"
argument_list|,
name|mincpg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mapcramped
condition|)
block|{
name|printf
argument_list|(
literal|"With %d sectors per cylinder, "
argument_list|,
name|sblock
operator|.
name|fs_spc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"minimum cylinders per group is %d\n"
argument_list|,
name|mincpg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inodecramped
operator|||
name|mapcramped
condition|)
block|{
if|if
condition|(
name|sblock
operator|.
name|fs_bsize
operator|!=
name|bsize
condition|)
name|printf
argument_list|(
literal|"%s to be changed from %d to %d\n"
argument_list|,
literal|"This requires the block size"
argument_list|,
name|bsize
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_fsize
operator|!=
name|fsize
condition|)
name|printf
argument_list|(
literal|"\t%s to be changed from %d to %d\n"
argument_list|,
literal|"and the fragment size"
argument_list|,
name|fsize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Calculate the number of cylinders per group 	 */
name|sblock
operator|.
name|fs_cpg
operator|=
name|cpg
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|%
name|mincpc
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s groups must have a multiple of %d cylinders\n"
argument_list|,
name|cpgflg
condition|?
literal|"Cylinder"
else|:
literal|"Warning: cylinder"
argument_list|,
name|mincpc
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cpg
operator|=
name|roundup
argument_list|(
name|sblock
operator|.
name|fs_cpg
argument_list|,
name|mincpc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpgflg
condition|)
name|cpg
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
block|}
comment|/* 	 * Must insure there is enough space for inodes 	 */
name|sblock
operator|.
name|fs_ipg
operator|=
name|roundup
argument_list|(
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|density
argument_list|,
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sblock
operator|.
name|fs_ipg
operator|>
name|MAXIPG
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|inodecramped
operator|=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_cpg
operator|-=
name|mincpc
expr_stmt|;
name|sblock
operator|.
name|fs_ipg
operator|=
name|roundup
argument_list|(
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|density
argument_list|,
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Must insure there is enough space to hold block map 	 */
while|while
condition|(
name|CGSIZE
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|mapcramped
operator|=
literal|1
expr_stmt|;
name|sblock
operator|.
name|fs_cpg
operator|-=
name|mincpc
expr_stmt|;
name|sblock
operator|.
name|fs_ipg
operator|=
name|roundup
argument_list|(
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|bpcg
operator|-
name|used
operator|)
operator|/
name|density
argument_list|,
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_fpg
operator|=
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
operator|%
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"newfs: panic (fs_cpg * fs_spc) % NSPF != 0"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|<
name|mincpg
condition|)
block|{
name|printf
argument_list|(
literal|"cylinder groups must have at least %d cylinders\n"
argument_list|,
name|mincpg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sblock
operator|.
name|fs_cpg
operator|!=
name|cpg
condition|)
block|{
if|if
condition|(
operator|!
name|cpgflg
condition|)
name|printf
argument_list|(
literal|"Warning: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|mapcramped
operator|&&
operator|!
name|inodecramped
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapcramped
operator|&&
name|inodecramped
condition|)
name|printf
argument_list|(
literal|"Block size and bytes per inode restrict"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mapcramped
condition|)
name|printf
argument_list|(
literal|"Block size restricts"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Bytes per inode restrict"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cylinders per group to %d.\n"
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpgflg
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_cgsize
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|CGSIZE
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now have size for file system and nsect and ntrak. 	 * Determine number of cylinders and blocks in the file system. 	 */
name|sblock
operator|.
name|fs_size
operator|=
name|fssize
operator|=
name|dbtofsb
argument_list|(
operator|&
name|sblock
argument_list|,
name|fssize
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ncyl
operator|=
name|fssize
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|/
name|sblock
operator|.
name|fs_spc
expr_stmt|;
if|if
condition|(
name|fssize
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|>
name|sblock
operator|.
name|fs_ncyl
operator|*
name|sblock
operator|.
name|fs_spc
condition|)
block|{
name|sblock
operator|.
name|fs_ncyl
operator|++
expr_stmt|;
name|warn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sblock
operator|.
name|fs_ncyl
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"file systems must have at least one cylinder\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine feasability/values of rotational layout tables. 	 * 	 * The size of the rotational layout tables is limited by the 	 * size of the superblock, SBSIZE. The amount of space available 	 * for tables is calculated as (SBSIZE - sizeof (struct fs)). 	 * The size of these tables is inversely proportional to the block 	 * size of the file system. The size increases if sectors per track 	 * are not powers of two, because more cylinders must be described 	 * by the tables before the rotational pattern repeats (fs_cpc). 	 */
name|sblock
operator|.
name|fs_interleave
operator|=
name|interleave
expr_stmt|;
name|sblock
operator|.
name|fs_trackskew
operator|=
name|trackskew
expr_stmt|;
name|sblock
operator|.
name|fs_npsect
operator|=
name|nphyssectors
expr_stmt|;
name|sblock
operator|.
name|fs_postblformat
operator|=
name|FS_DYNAMICPOSTBLFMT
expr_stmt|;
name|sblock
operator|.
name|fs_sbsize
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ntrak
operator|==
literal|1
condition|)
block|{
name|sblock
operator|.
name|fs_cpc
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|postblsize
operator|=
name|sblock
operator|.
name|fs_nrpos
operator|*
name|sblock
operator|.
name|fs_cpc
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|rotblsize
operator|=
name|sblock
operator|.
name|fs_cpc
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|totalsbsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fs
argument_list|)
operator|+
name|rotblsize
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_nrpos
operator|==
literal|8
operator|&&
name|sblock
operator|.
name|fs_cpc
operator|<=
literal|16
condition|)
block|{
comment|/* use old static table space */
name|sblock
operator|.
name|fs_postbloff
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|sblock
operator|.
name|fs_opostbl
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|sblock
operator|.
name|fs_link
operator|)
expr_stmt|;
name|sblock
operator|.
name|fs_rotbloff
operator|=
operator|&
name|sblock
operator|.
name|fs_space
index|[
literal|0
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|sblock
operator|.
name|fs_link
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use dynamic table space */
name|sblock
operator|.
name|fs_postbloff
operator|=
operator|&
name|sblock
operator|.
name|fs_space
index|[
literal|0
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|sblock
operator|.
name|fs_link
operator|)
expr_stmt|;
name|sblock
operator|.
name|fs_rotbloff
operator|=
name|sblock
operator|.
name|fs_postbloff
operator|+
name|postblsize
expr_stmt|;
name|totalsbsize
operator|+=
name|postblsize
expr_stmt|;
block|}
if|if
condition|(
name|totalsbsize
operator|>
name|SBSIZE
operator|||
name|sblock
operator|.
name|fs_nsect
operator|>
operator|(
literal|1
operator|<<
name|NBBY
operator|)
operator|*
name|NSPB
argument_list|(
operator|&
name|sblock
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s %s %d %s %d.%s"
argument_list|,
literal|"Warning: insufficient space in super block for\n"
argument_list|,
literal|"rotational layout tables with nsect"
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|,
literal|"and ntrak"
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
literal|"\nFile system performance may be impared.\n"
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cpc
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|sblock
operator|.
name|fs_sbsize
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|totalsbsize
argument_list|)
expr_stmt|;
comment|/* 	 * calculate the available blocks for each rotational position 	 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_cpc
condition|;
name|cylno
operator|++
control|)
for|for
control|(
name|rpos
operator|=
literal|0
init|;
name|rpos
operator|<
name|sblock
operator|.
name|fs_nrpos
condition|;
name|rpos
operator|++
control|)
name|fs_postbl
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
index|[
name|rpos
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|rotblsize
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_frag
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|cylno
operator|=
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rpos
operator|=
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|blk
operator|=
name|fragstoblks
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_postbl
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
index|[
name|rpos
index|]
operator|==
operator|-
literal|1
condition|)
name|fs_rotbl
argument_list|(
operator|&
name|sblock
argument_list|)
index|[
name|blk
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|fs_rotbl
argument_list|(
operator|&
name|sblock
argument_list|)
index|[
name|blk
index|]
operator|=
name|fs_postbl
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
index|[
name|rpos
index|]
operator|-
name|blk
expr_stmt|;
name|fs_postbl
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
index|[
name|rpos
index|]
operator|=
name|blk
expr_stmt|;
block|}
name|next
label|:
comment|/* 	 * Compute/validate number of cylinder groups. 	 */
name|sblock
operator|.
name|fs_ncg
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|/
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
if|if
condition|(
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
condition|)
name|sblock
operator|.
name|fs_ncg
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_dblkno
operator|=
name|sblock
operator|.
name|fs_iblkno
operator|+
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|i
operator|=
name|MIN
argument_list|(
operator|~
name|sblock
operator|.
name|fs_cgmask
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
operator|>=
name|sblock
operator|.
name|fs_fpg
condition|)
block|{
name|printf
argument_list|(
literal|"inode blocks/cyl group (%d)>= data blocks (%d)\n"
argument_list|,
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|,
name|sblock
operator|.
name|fs_fpg
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"number of cylinders per cylinder group (%d) %s.\n"
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|,
literal|"must be increased"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fssize
operator|-
name|j
operator|*
name|sblock
operator|.
name|fs_fpg
operator|)
operator|<
name|sblock
operator|.
name|fs_fpg
operator|&&
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|j
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|j
argument_list|)
operator|>
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: inode blocks/cyl group (%d)>= data blocks (%d) in last\n"
argument_list|,
operator|(
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|j
argument_list|)
operator|-
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|j
argument_list|)
operator|)
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|,
name|i
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cylinder group. This implies %d sector(s) cannot be allocated.\n"
argument_list|,
name|i
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_ncg
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_ncyl
operator|-=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|sblock
operator|.
name|fs_size
operator|=
name|fssize
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|warn
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: %d sector(s) in last cylinder unallocated\n"
argument_list|,
name|sblock
operator|.
name|fs_spc
operator|-
operator|(
name|fssize
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
operator|-
operator|(
name|sblock
operator|.
name|fs_ncyl
operator|-
literal|1
operator|)
operator|*
name|sblock
operator|.
name|fs_spc
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * fill in remaining fields of the super block 	 */
name|sblock
operator|.
name|fs_csaddr
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cssize
operator|=
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_ncg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|csum
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|sblock
operator|.
name|fs_bsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|csum
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_csmask
operator|=
operator|~
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|sblock
operator|.
name|fs_csshift
operator|=
literal|0
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|>>=
literal|1
control|)
name|sblock
operator|.
name|fs_csshift
operator|++
expr_stmt|;
name|fscs
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|sblock
operator|.
name|fs_cssize
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_magic
operator|=
name|FS_MAGIC
expr_stmt|;
name|sblock
operator|.
name|fs_rotdelay
operator|=
name|rotdelay
expr_stmt|;
name|sblock
operator|.
name|fs_minfree
operator|=
name|minfree
expr_stmt|;
name|sblock
operator|.
name|fs_maxcontig
operator|=
name|maxcontig
expr_stmt|;
name|sblock
operator|.
name|fs_headswitch
operator|=
name|headswitch
expr_stmt|;
name|sblock
operator|.
name|fs_trkseek
operator|=
name|trackseek
expr_stmt|;
name|sblock
operator|.
name|fs_maxbpg
operator|=
name|maxbpg
expr_stmt|;
name|sblock
operator|.
name|fs_rps
operator|=
name|rpm
operator|/
literal|60
expr_stmt|;
name|sblock
operator|.
name|fs_optim
operator|=
name|opt
expr_stmt|;
name|sblock
operator|.
name|fs_cgrotor
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|sblock
operator|.
name|fs_ronly
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Dump out summary information about file system. 	 */
name|printf
argument_list|(
literal|"%s:\t%d sectors in %d cylinders of %d tracks, %d sectors\n"
argument_list|,
name|fsys
argument_list|,
name|sblock
operator|.
name|fs_size
operator|*
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_ncyl
argument_list|,
name|sblock
operator|.
name|fs_ntrak
argument_list|,
name|sblock
operator|.
name|fs_nsect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n"
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_size
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
literal|1e-6
argument_list|,
name|sblock
operator|.
name|fs_ncg
argument_list|,
name|sblock
operator|.
name|fs_cpg
argument_list|,
operator|(
name|float
operator|)
name|sblock
operator|.
name|fs_fpg
operator|*
name|sblock
operator|.
name|fs_fsize
operator|*
literal|1e-6
argument_list|,
name|sblock
operator|.
name|fs_ipg
argument_list|)
expr_stmt|;
comment|/* 	 * Now build the cylinders group blocks and 	 * then print out indices of cylinder groups. 	 */
name|printf
argument_list|(
literal|"super-block backups (for fsck -b #) at:"
argument_list|)
expr_stmt|;
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
block|{
name|initcg
argument_list|(
name|cylno
argument_list|)
expr_stmt|;
if|if
condition|(
name|cylno
operator|%
literal|9
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nflag
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Now construct the initial file system, 	 * then write out the super-block. 	 */
name|fsinit
argument_list|()
expr_stmt|;
name|sblock
operator|.
name|fs_time
operator|=
name|utime
expr_stmt|;
name|wtfs
argument_list|(
name|SBOFF
operator|/
name|sectorsize
argument_list|,
name|sbsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_cssize
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_bsize
control|)
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|sblock
operator|.
name|fs_csaddr
operator|+
name|numfrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
condition|?
name|sblock
operator|.
name|fs_cssize
operator|-
name|i
else|:
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|fscs
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/*  	 * Write out the duplicate super blocks 	 */
for|for
control|(
name|cylno
operator|=
literal|0
init|;
name|cylno
operator|<
name|sblock
operator|.
name|fs_ncg
condition|;
name|cylno
operator|++
control|)
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
name|sbsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|)
expr_stmt|;
comment|/* 	 * Update information about this partion in pack 	 * label, to that it may be updated on disk. 	 */
name|pp
operator|->
name|p_fstype
operator|=
name|FS_BSDFFS
expr_stmt|;
name|pp
operator|->
name|p_fsize
operator|=
name|sblock
operator|.
name|fs_fsize
expr_stmt|;
name|pp
operator|->
name|p_frag
operator|=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
name|pp
operator|->
name|p_cpg
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize a cylinder group.  */
end_comment

begin_macro
name|initcg
argument_list|(
argument|cylno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cylno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|daddr_t
name|cbase
decl_stmt|,
name|d
decl_stmt|,
name|dlower
decl_stmt|,
name|dupper
decl_stmt|,
name|dmax
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|struct
name|csum
modifier|*
name|cs
decl_stmt|;
comment|/* 	 * Determine block bounds for cylinder group. 	 * Allow space for super block summary information in first 	 * cylinder group. 	 */
name|cbase
operator|=
name|cgbase
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
expr_stmt|;
name|dmax
operator|=
name|cbase
operator|+
name|sblock
operator|.
name|fs_fpg
expr_stmt|;
if|if
condition|(
name|dmax
operator|>
name|sblock
operator|.
name|fs_size
condition|)
name|dmax
operator|=
name|sblock
operator|.
name|fs_size
expr_stmt|;
name|dlower
operator|=
name|cgsblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
name|dupper
operator|=
name|cgdmin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|-
name|cbase
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
name|dupper
operator|+=
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cssize
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|cs
operator|=
name|fscs
operator|+
name|cylno
expr_stmt|;
name|acg
operator|.
name|cg_time
operator|=
name|utime
expr_stmt|;
name|acg
operator|.
name|cg_magic
operator|=
name|CG_MAGIC
expr_stmt|;
name|acg
operator|.
name|cg_cgx
operator|=
name|cylno
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
name|sblock
operator|.
name|fs_ncg
operator|-
literal|1
condition|)
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_ncyl
operator|%
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
else|else
name|acg
operator|.
name|cg_ncyl
operator|=
name|sblock
operator|.
name|fs_cpg
expr_stmt|;
name|acg
operator|.
name|cg_niblk
operator|=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
name|acg
operator|.
name|cg_ndblk
operator|=
name|dmax
operator|-
name|cbase
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_rotor
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_frotor
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_irotor
operator|=
literal|0
expr_stmt|;
name|acg
operator|.
name|cg_btotoff
operator|=
operator|&
name|acg
operator|.
name|cg_space
index|[
literal|0
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|acg
operator|.
name|cg_link
operator|)
expr_stmt|;
name|acg
operator|.
name|cg_boff
operator|=
name|acg
operator|.
name|cg_btotoff
operator|+
name|sblock
operator|.
name|fs_cpg
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_iusedoff
operator|=
name|acg
operator|.
name|cg_boff
operator|+
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_nrpos
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_freeoff
operator|=
name|acg
operator|.
name|cg_iusedoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_ipg
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_nextfreeoff
operator|=
name|acg
operator|.
name|cg_freeoff
operator|+
name|howmany
argument_list|(
name|sblock
operator|.
name|fs_cpg
operator|*
name|sblock
operator|.
name|fs_spc
operator|/
name|NSPF
argument_list|(
operator|&
name|sblock
argument_list|)
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cg_inosused
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|acg
operator|.
name|cg_freeoff
operator|-
name|acg
operator|.
name|cg_iusedoff
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|+=
name|sblock
operator|.
name|fs_ipg
expr_stmt|;
if|if
condition|(
name|cylno
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ROOTINO
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_inosused
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_ipg
operator|/
name|INOPF
argument_list|(
operator|&
name|sblock
argument_list|)
condition|;
name|i
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgimin
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
operator|+
name|i
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zino
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|acg
operator|.
name|cg_boff
operator|-
name|acg
operator|.
name|cg_btotoff
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|acg
operator|.
name|cg_iusedoff
operator|-
name|acg
operator|.
name|cg_boff
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|acg
operator|.
name|cg_nextfreeoff
operator|-
name|acg
operator|.
name|cg_freeoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|cylno
operator|>
literal|0
condition|)
block|{
comment|/* 		 * In cylno 0, beginning space is reserved 		 * for boot and super blocks. 		 */
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|dlower
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
block|{
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_dsize
operator|+=
name|dlower
expr_stmt|;
block|}
name|sblock
operator|.
name|fs_dsize
operator|+=
name|acg
operator|.
name|cg_ndblk
operator|-
name|dupper
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|dupper
operator|%
name|sblock
operator|.
name|fs_frag
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|sblock
operator|.
name|fs_frag
operator|-
name|i
index|]
operator|++
expr_stmt|;
for|for
control|(
name|d
operator|=
name|dupper
operator|+
name|sblock
operator|.
name|fs_frag
operator|-
name|i
init|;
name|dupper
operator|<
name|d
condition|;
name|dupper
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|dupper
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|d
operator|=
name|dupper
init|;
name|d
operator|+
name|sblock
operator|.
name|fs_frag
operator|<=
name|dmax
operator|-
name|cbase
condition|;
control|)
block|{
name|setblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|++
expr_stmt|;
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|++
expr_stmt|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|dmax
operator|-
name|cbase
condition|)
block|{
name|acg
operator|.
name|cg_frsum
index|[
name|dmax
operator|-
name|cbase
operator|-
name|d
index|]
operator|++
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|dmax
operator|-
name|cbase
condition|;
name|d
operator|++
control|)
block|{
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|++
expr_stmt|;
block|}
block|}
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|+=
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
expr_stmt|;
operator|*
name|cs
operator|=
name|acg
operator|.
name|cg_cs
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
name|cylno
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * initialize the file system  */
end_comment

begin_decl_stmt
name|struct
name|inode
name|node
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOSTDIR
end_ifdef

begin_define
define|#
directive|define
name|PREDEFDIR
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PREDEFDIR
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|direct
name|root_dir
index|[]
init|=
block|{
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|1
block|,
literal|"."
block|}
block|,
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|2
block|,
literal|".."
block|}
block|,
ifdef|#
directive|ifdef
name|LOSTDIR
block|{
name|LOSTFOUNDINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|10
block|,
literal|"lost+found"
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOSTDIR
end_ifdef

begin_decl_stmt
name|struct
name|direct
name|lost_found_dir
index|[]
init|=
block|{
block|{
name|LOSTFOUNDINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|1
block|,
literal|"."
block|}
block|,
block|{
name|ROOTINO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
block|,
literal|2
block|,
literal|".."
block|}
block|,
block|{
literal|0
block|,
name|DIRBLKSIZ
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|buf
index|[
name|MAXBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|fsinit
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * initialize the node 	 */
name|node
operator|.
name|i_atime
operator|=
name|utime
expr_stmt|;
name|node
operator|.
name|i_mtime
operator|=
name|utime
expr_stmt|;
name|node
operator|.
name|i_ctime
operator|=
name|utime
expr_stmt|;
ifdef|#
directive|ifdef
name|LOSTDIR
comment|/* 	 * create the lost+found directory 	 */
operator|(
name|void
operator|)
name|makedir
argument_list|(
name|lost_found_dir
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DIRBLKSIZ
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_bsize
condition|;
name|i
operator|+=
name|DIRBLKSIZ
control|)
name|bcopy
argument_list|(
operator|&
name|lost_found_dir
index|[
literal|2
index|]
argument_list|,
operator|&
name|buf
index|[
name|i
index|]
argument_list|,
name|DIRSIZ
argument_list|(
operator|&
name|lost_found_dir
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|.
name|i_number
operator|=
name|LOSTFOUNDINO
expr_stmt|;
name|node
operator|.
name|i_mode
operator|=
name|IFDIR
operator||
name|UMASK
expr_stmt|;
name|node
operator|.
name|i_nlink
operator|=
literal|2
expr_stmt|;
name|node
operator|.
name|i_size
operator|=
name|sblock
operator|.
name|fs_bsize
expr_stmt|;
name|node
operator|.
name|i_db
index|[
literal|0
index|]
operator|=
name|alloc
argument_list|(
name|node
operator|.
name|i_size
argument_list|,
name|node
operator|.
name|i_mode
argument_list|)
expr_stmt|;
name|node
operator|.
name|i_blocks
operator|=
name|btodb
argument_list|(
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|node
operator|.
name|i_size
argument_list|)
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|node
operator|.
name|i_db
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|node
operator|.
name|i_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|iput
argument_list|(
operator|&
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * create the root directory 	 */
name|node
operator|.
name|i_number
operator|=
name|ROOTINO
expr_stmt|;
name|node
operator|.
name|i_mode
operator|=
name|IFDIR
operator||
name|UMASK
expr_stmt|;
name|node
operator|.
name|i_nlink
operator|=
name|PREDEFDIR
expr_stmt|;
name|node
operator|.
name|i_size
operator|=
name|makedir
argument_list|(
name|root_dir
argument_list|,
name|PREDEFDIR
argument_list|)
expr_stmt|;
name|node
operator|.
name|i_db
index|[
literal|0
index|]
operator|=
name|alloc
argument_list|(
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|node
operator|.
name|i_mode
argument_list|)
expr_stmt|;
name|node
operator|.
name|i_blocks
operator|=
name|btodb
argument_list|(
name|fragroundup
argument_list|(
operator|&
name|sblock
argument_list|,
name|node
operator|.
name|i_size
argument_list|)
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|node
operator|.
name|i_db
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|iput
argument_list|(
operator|&
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * construct a set of directory entries in "buf".  * return size of directory.  */
end_comment

begin_expr_stmt
name|makedir
argument_list|(
name|protodir
argument_list|,
name|entries
argument_list|)
specifier|register
expr|struct
name|direct
operator|*
name|protodir
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|entries
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|spcleft
decl_stmt|;
name|spcleft
operator|=
name|DIRBLKSIZ
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|=
name|DIRSIZ
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|,
name|cp
argument_list|,
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
expr_stmt|;
name|spcleft
operator|-=
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
expr_stmt|;
block|}
name|protodir
index|[
name|i
index|]
operator|.
name|d_reclen
operator|=
name|spcleft
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|,
name|cp
argument_list|,
name|DIRSIZ
argument_list|(
operator|&
name|protodir
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|DIRBLKSIZ
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * allocate a block or frag  */
end_comment

begin_function
name|daddr_t
name|alloc
parameter_list|(
name|size
parameter_list|,
name|mode
parameter_list|)
name|int
name|size
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|frag
decl_stmt|;
name|daddr_t
name|d
decl_stmt|;
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
if|if
condition|(
name|acg
operator|.
name|cg_magic
operator|!=
name|CG_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"cg 0: bad magic number\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"first cylinder group ran out of space\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|acg
operator|.
name|cg_ndblk
condition|;
name|d
operator|+=
name|sblock
operator|.
name|fs_frag
control|)
if|if
condition|(
name|isblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
condition|)
goto|goto
name|goth
goto|;
name|printf
argument_list|(
literal|"internal error: can't find block in cyl 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|goth
label|:
name|clrblock
argument_list|(
operator|&
name|sblock
argument_list|,
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|/
name|sblock
operator|.
name|fs_frag
argument_list|)
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_nbfree
operator|--
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|IFDIR
condition|)
block|{
name|acg
operator|.
name|cg_cs
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_ndir
operator|++
expr_stmt|;
block|}
name|cg_blktot
argument_list|(
operator|&
name|acg
argument_list|)
index|[
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
name|cg_blks
argument_list|(
operator|&
name|sblock
argument_list|,
operator|&
name|acg
argument_list|,
name|cbtocylno
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
argument_list|)
index|[
name|cbtorpos
argument_list|(
operator|&
name|sblock
argument_list|,
name|d
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|sblock
operator|.
name|fs_bsize
condition|)
block|{
name|frag
operator|=
name|howmany
argument_list|(
name|size
argument_list|,
name|sblock
operator|.
name|fs_fsize
argument_list|)
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
expr_stmt|;
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nffree
operator|+=
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
expr_stmt|;
name|acg
operator|.
name|cg_frsum
index|[
name|sblock
operator|.
name|fs_frag
operator|-
name|frag
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|frag
init|;
name|i
operator|<
name|sblock
operator|.
name|fs_frag
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|cg_blksfree
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|d
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an inode on the disk  */
end_comment

begin_expr_stmt
name|iput
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|inode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|dinode
name|buf
index|[
name|MAXINOPB
index|]
decl_stmt|;
name|daddr_t
name|d
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|itog
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
if|if
condition|(
name|acg
operator|.
name|cg_magic
operator|!=
name|CG_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"cg 0: bad magic number\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|acg
operator|.
name|cg_cs
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|setbit
argument_list|(
name|cg_inosused
argument_list|(
operator|&
name|acg
argument_list|)
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|wtfs
argument_list|(
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|cgtod
argument_list|(
operator|&
name|sblock
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|sblock
operator|.
name|fs_cgsize
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acg
argument_list|)
expr_stmt|;
name|sblock
operator|.
name|fs_cstotal
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|fscs
index|[
literal|0
index|]
operator|.
name|cs_nifree
operator|--
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_number
operator|>=
name|sblock
operator|.
name|fs_ipg
operator|*
name|sblock
operator|.
name|fs_ncg
condition|)
block|{
name|printf
argument_list|(
literal|"fsinit: inode value out of range (%d).\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|itod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
argument_list|)
expr_stmt|;
name|rdfs
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|itoo
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
index|]
operator|.
name|di_ic
operator|=
name|ip
operator|->
name|i_ic
expr_stmt|;
name|wtfs
argument_list|(
name|d
argument_list|,
name|sblock
operator|.
name|fs_bsize
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read a block from the file system  */
end_comment

begin_macro
name|rdfs
argument_list|(
argument|bno
argument_list|,
argument|size
argument_list|,
argument|bf
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fsi
argument_list|,
name|bno
operator|*
name|sectorsize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"seek error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"rdfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|read
argument_list|(
name|fsi
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"read error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"rdfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * write a block to the file system  */
end_comment

begin_macro
name|wtfs
argument_list|(
argument|bno
argument_list|,
argument|size
argument_list|,
argument|bf
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|Nflag
condition|)
return|return;
if|if
condition|(
name|lseek
argument_list|(
name|fso
argument_list|,
name|bno
operator|*
name|sectorsize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"seek error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"wtfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|write
argument_list|(
name|fso
argument_list|,
name|bf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"write error: %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"wtfs"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * check if a block is available  */
end_comment

begin_macro
name|isblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|mask
decl_stmt|;
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
return|return
operator|(
name|cp
index|[
name|h
index|]
operator|==
literal|0xff
operator|)
return|;
case|case
literal|4
case|:
name|mask
operator|=
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|2
case|:
name|mask
operator|=
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
case|case
literal|1
case|:
name|mask
operator|=
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&
name|mask
operator|)
operator|==
name|mask
operator|)
return|;
default|default:
ifdef|#
directive|ifdef
name|STANDALONE
name|printf
argument_list|(
literal|"isblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * take a block out of the map  */
end_comment

begin_macro
name|clrblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
operator|(
name|fs
operator|)
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator|&=
operator|~
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator|&=
operator|~
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
return|return;
default|default:
ifdef|#
directive|ifdef
name|STANDALONE
name|printf
argument_list|(
literal|"clrblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"clrblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * put a block into the map  */
end_comment

begin_macro
name|setblock
argument_list|(
argument|fs
argument_list|,
argument|cp
argument_list|,
argument|h
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|h
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|fs
operator|->
name|fs_frag
condition|)
block|{
case|case
literal|8
case|:
name|cp
index|[
name|h
index|]
operator|=
literal|0xff
expr_stmt|;
return|return;
case|case
literal|4
case|:
name|cp
index|[
name|h
operator|>>
literal|1
index|]
operator||=
operator|(
literal|0x0f
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x1
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|cp
index|[
name|h
operator|>>
literal|2
index|]
operator||=
operator|(
literal|0x03
operator|<<
operator|(
operator|(
name|h
operator|&
literal|0x3
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
name|cp
index|[
name|h
operator|>>
literal|3
index|]
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|h
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
return|return;
default|default:
ifdef|#
directive|ifdef
name|STANDALONE
name|printf
argument_list|(
literal|"setblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setblock bad fs_frag %d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
end_block

end_unit

