begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Computer Consoles Inc.  *  * %sccs.include.proprietary.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fsdb.c	8.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  *  fsdb - file system debugger  *  *  usage: fsdb [options] special  *  options:  *	-?		display usage  *	-o		override some error conditions  *	-p"string"	set prompt to string  *	-w		open for write  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_comment
comment|/*  * Defines from the 4.3-tahoe file system, for systems with the 4.2 or 4.3  * file system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FS_42POSTBLFMT
end_ifndef

begin_define
define|#
directive|define
name|cg_blktot
parameter_list|(
name|cgp
parameter_list|)
value|(((cgp))->cg_btot)
end_define

begin_define
define|#
directive|define
name|cg_blks
parameter_list|(
name|fs
parameter_list|,
name|cgp
parameter_list|,
name|cylno
parameter_list|)
value|(((cgp))->cg_b[cylno])
end_define

begin_define
define|#
directive|define
name|cg_inosused
parameter_list|(
name|cgp
parameter_list|)
value|(((cgp))->cg_iused)
end_define

begin_define
define|#
directive|define
name|cg_blksfree
parameter_list|(
name|cgp
parameter_list|)
value|(((cgp))->cg_free)
end_define

begin_define
define|#
directive|define
name|cg_chkmagic
parameter_list|(
name|cgp
parameter_list|)
value|((cgp)->cg_magic == CG_MAGIC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Never changing defines.  */
end_comment

begin_define
define|#
directive|define
name|OCTAL
value|8
end_define

begin_comment
comment|/* octal base */
end_comment

begin_define
define|#
directive|define
name|DECIMAL
value|10
end_define

begin_comment
comment|/* decimal base */
end_comment

begin_define
define|#
directive|define
name|HEX
value|16
end_define

begin_comment
comment|/* hexadecimal base */
end_comment

begin_comment
comment|/*  * Adjustable defines.  */
end_comment

begin_define
define|#
directive|define
name|NBUF
value|10
end_define

begin_comment
comment|/* number of cache buffers */
end_comment

begin_define
define|#
directive|define
name|PROMPTSIZE
value|80
end_define

begin_comment
comment|/* size of user definable prompt */
end_comment

begin_define
define|#
directive|define
name|MAXFILES
value|40000
end_define

begin_comment
comment|/* max number of files ls can handle */
end_comment

begin_define
define|#
directive|define
name|FIRST_DEPTH
value|10
end_define

begin_comment
comment|/* default depth for find and ls */
end_comment

begin_define
define|#
directive|define
name|SECOND_DEPTH
value|100
end_define

begin_comment
comment|/* second try at depth (maximum) */
end_comment

begin_define
define|#
directive|define
name|INPUTBUFFER
value|1040
end_define

begin_comment
comment|/* size of input buffer */
end_comment

begin_define
define|#
directive|define
name|BYTESPERLINE
value|16
end_define

begin_comment
comment|/* bytes per line of /dxo output */
end_comment

begin_define
define|#
directive|define
name|NREG
value|36
end_define

begin_comment
comment|/* number of save registers */
end_comment

begin_comment
comment|/*  * Values dependent on sizes of structs and such.  */
end_comment

begin_define
define|#
directive|define
name|NUMB
value|3
end_define

begin_comment
comment|/* these three are arbitrary, */
end_comment

begin_define
define|#
directive|define
name|BLOCK
value|5
end_define

begin_comment
comment|/* but must be different from */
end_comment

begin_define
define|#
directive|define
name|FRAGMENT
value|7
end_define

begin_comment
comment|/* the rest (hence odd).      */
end_comment

begin_define
define|#
directive|define
name|BITSPERCHAR
value|8
end_define

begin_comment
comment|/* couldn't find it anywhere  */
end_comment

begin_define
define|#
directive|define
name|CHAR
value|(sizeof (char))
end_define

begin_define
define|#
directive|define
name|SHORT
value|(sizeof (short))
end_define

begin_define
define|#
directive|define
name|LONG
value|(sizeof (long))
end_define

begin_define
define|#
directive|define
name|INODE
value|(sizeof (struct dinode))
end_define

begin_define
define|#
directive|define
name|DIRECTORY
value|(sizeof (struct direct))
end_define

begin_define
define|#
directive|define
name|CGRP
value|(sizeof (struct cg))
end_define

begin_define
define|#
directive|define
name|SB
value|(sizeof (struct fs))
end_define

begin_define
define|#
directive|define
name|BLKSIZE
value|(fs->fs_bsize)
end_define

begin_comment
comment|/* for clarity */
end_comment

begin_define
define|#
directive|define
name|FRGSIZE
value|(fs->fs_fsize)
end_define

begin_define
define|#
directive|define
name|BLKSHIFT
value|(fs->fs_bshift)
end_define

begin_define
define|#
directive|define
name|FRGSHIFT
value|(fs->fs_fshift)
end_define

begin_comment
comment|/*  * Messy macros that would otherwise clutter up such glamorous code.  */
end_comment

begin_define
define|#
directive|define
name|itob
parameter_list|(
name|i
parameter_list|)
value|((ino_to_fsba(fs,				\ 			    (i))<< FRGSHIFT) + ino_to_fsbo(fs, (i)) * INODE)
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_define
define|#
directive|define
name|STRINGSIZE
parameter_list|(
name|d
parameter_list|)
value|((long)d->d_reclen - \ 				((long)&d->d_name[0] - (long)&d->d_ino))
end_define

begin_define
define|#
directive|define
name|letter
parameter_list|(
name|c
parameter_list|)
value|((((c)>= 'a')&&((c)<= 'z')) ||\ 				(((c)>= 'A')&&((c)<= 'Z')))
end_define

begin_define
define|#
directive|define
name|digit
parameter_list|(
name|c
parameter_list|)
value|(((c)>= '0')&& ((c)<= '9'))
end_define

begin_define
define|#
directive|define
name|HEXLETTER
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'A')&& ((c)<= 'F'))
end_define

begin_define
define|#
directive|define
name|hexletter
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'a')&& ((c)<= 'f'))
end_define

begin_define
define|#
directive|define
name|octaldigit
parameter_list|(
name|c
parameter_list|)
value|(((c)>= '0')&& ((c)<= '7'))
end_define

begin_define
define|#
directive|define
name|uppertolower
parameter_list|(
name|c
parameter_list|)
value|((c) - 'A' + 'a')
end_define

begin_define
define|#
directive|define
name|hextodigit
parameter_list|(
name|c
parameter_list|)
value|((c) - 'a' + 10)
end_define

begin_define
define|#
directive|define
name|numtodigit
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_define
define|#
directive|define
name|loword
parameter_list|(
name|X
parameter_list|)
value|(((ushort *)&X)[1])
end_define

begin_define
define|#
directive|define
name|lobyte
parameter_list|(
name|X
parameter_list|)
value|(((unsigned char *)&X)[1])
end_define

begin_comment
comment|/*  * buffer cache structure.  */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|struct
name|buf
modifier|*
name|fwd
decl_stmt|;
name|struct
name|buf
modifier|*
name|back
decl_stmt|;
name|char
modifier|*
name|blkaddr
decl_stmt|;
name|short
name|valid
decl_stmt|;
name|long
name|blkno
decl_stmt|;
block|}
name|buf
index|[
name|NBUF
index|]
struct|,
name|bhdr
struct|;
end_struct

begin_comment
comment|/*  * used to hold save registers (see '<' and '>').  */
end_comment

begin_struct
struct|struct
name|save_registers
block|{
name|long
name|sv_addr
decl_stmt|;
name|long
name|sv_value
decl_stmt|;
name|long
name|sv_objsz
decl_stmt|;
block|}
name|regs
index|[
name|NREG
index|]
struct|;
end_struct

begin_comment
comment|/*  * cd, find, and ls use this to hold filenames.  Each filename is broken  * up by a slash.  In other words, /usr/src/adm would have a len field  * of 2 (starting from 0), and filenames->fname[0-2] would hold usr,  * src, and adm components of the pathname.  */
end_comment

begin_struct
struct|struct
name|filenames
block|{
name|long
name|ino
decl_stmt|;
comment|/* inode */
name|long
name|len
decl_stmt|;
comment|/* number of components */
name|char
name|flag
decl_stmt|;
comment|/* flag if using SECOND_DEPTH allocator */
name|char
name|find
decl_stmt|;
comment|/* flag if found by find */
name|char
modifier|*
modifier|*
name|fname
decl_stmt|;
comment|/* hold components of pathname */
block|}
modifier|*
name|filenames
struct|,
modifier|*
name|top
struct|;
end_struct

begin_decl_stmt
name|struct
name|fs
name|filesystem
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* super block */
end_comment

begin_comment
comment|/*  * Global data.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stack_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|current_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|input_buffer
index|[
name|INPUTBUFFER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|scratch
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|BASE
index|[]
init|=
literal|"o u     x"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PROMPT
index|[
name|PROMPTSIZE
index|]
init|=
literal|"> "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|laststyle
init|=
literal|'/'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lastpo
init|=
literal|'x'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|input_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|current_pathp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|stack_pathp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|input_pathp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|cmp_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|type
init|=
name|NUMB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|dirslot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|c_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|paren
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|trapped
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|doing_cd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|doing_find
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|find_by_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|find_by_inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|long_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|recursive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|objsz
init|=
name|SHORT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|wrtflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|base
init|=
name|HEX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|acting_on_inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|acting_on_directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|should_print
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|clear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|star
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bod_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|erraddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|errcur_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|errino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|errinum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cur_cgrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cur_ino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cur_inum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cur_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cur_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|cur_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|find_ino
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|filesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|blocksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|stringsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|commands
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|read_requests
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|actual_disk_reads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
name|getachar
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|getblk
argument_list|()
decl_stmt|,
modifier|*
name|fmtentry
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|err
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|long
name|get
argument_list|()
decl_stmt|,
name|bmap
argument_list|()
decl_stmt|,
name|expr
argument_list|()
decl_stmt|,
name|term
argument_list|()
decl_stmt|,
name|getnumb
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|unsigned
name|long
modifier|*
name|print_check
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * main - lines are read up to the unprotected ('\') newline and  *	held in an input buffer.  Characters may be read from the  *	input buffer using getachar() and unread using ungetachar().  *	Reading the whole line ahead allows the use of debuggers  *	which would otherwise be impossible since the debugger  *	and fsdb could not share stdin.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|short
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|cptr
decl_stmt|;
specifier|register
name|short
name|i
decl_stmt|,
name|j
decl_stmt|,
modifier|*
name|iptr
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|filenames
modifier|*
name|fn
decl_stmt|;
name|char
modifier|*
name|progname
decl_stmt|;
name|short
name|colon
decl_stmt|,
name|mode
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|unsigned
name|block
decl_stmt|;
name|int
name|ffcmp
parameter_list|()
function_decl|;
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|prompt
operator|=
operator|&
name|PROMPT
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Parse options. 	 */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"-?"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"-o"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error checking off\n"
argument_list|)
expr_stmt|;
name|override
operator|=
literal|1
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"-p"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prompt
operator|=
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
literal|"-w"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wrtflag
operator|=
literal|2
expr_stmt|;
comment|/* suitable for open */
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|usage
label|:
name|printf
argument_list|(
literal|"usage:   %s [options] special\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-?		display usage\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-o		override some error conditions\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-p\"string\"	set prompt to string\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t-w		open for write\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Attempt to open the special file. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|wrtflag
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read in the super block and validate (not too picky). 	 */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|SBLOCK
operator|*
name|DEV_BSIZE
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|filesystem
argument_list|,
sizeof|sizeof
name|filesystem
argument_list|)
operator|!=
sizeof|sizeof
name|filesystem
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot read superblock\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fs
operator|=
operator|&
name|filesystem
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Bad magic number in file system\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
if|if
condition|(
name|fs
operator|->
name|fs_postblformat
operator|==
name|FS_42POSTBLFMT
condition|)
name|fs
operator|->
name|fs_nrpos
operator|=
literal|8
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"fsdb of %s %s -- last mounted on %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|wrtflag
condition|?
literal|"(Opened for write)"
else|:
literal|"(Read only)"
argument_list|,
operator|&
name|fs
operator|->
name|fs_fsmnt
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Malloc buffers and set up cache. 	 */
name|buffers
operator|=
name|malloc
argument_list|(
name|NBUF
operator|*
name|BLKSIZE
argument_list|)
expr_stmt|;
name|bhdr
operator|.
name|fwd
operator|=
name|bhdr
operator|.
name|back
operator|=
operator|&
name|bhdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUF
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|bp
operator|->
name|blkaddr
operator|=
name|buffers
operator|+
operator|(
name|i
operator|*
name|BLKSIZE
operator|)
expr_stmt|;
name|bp
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|insert
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Malloc filenames structure.  The space for the actual filenames 	 * is allocated as it needs it. 	 */
name|filenames
operator|=
operator|(
expr|struct
name|filenames
operator|*
operator|)
name|calloc
argument_list|(
name|MAXFILES
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|filenames
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filenames
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fn
operator|=
name|filenames
expr_stmt|;
name|restore_inode
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Malloc a few filenames (needed by pwd for example). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPATHLEN
condition|;
name|i
operator|++
control|)
block|{
name|input_path
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|MAXNAMLEN
argument_list|)
expr_stmt|;
name|stack_path
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|MAXNAMLEN
argument_list|)
expr_stmt|;
name|current_path
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_path
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|current_pathp
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
literal|2
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|setjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|getnextinput
argument_list|()
expr_stmt|;
comment|/* 	 * Main loop and case statement.  If an error condition occurs 	 * initialization and recovery is attempted. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|error
condition|)
block|{
name|freemem
argument_list|(
name|filenames
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
name|nfiles
operator|=
literal|0
expr_stmt|;
name|c_count
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|star
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
name|acting_on_inode
operator|=
literal|0
expr_stmt|;
name|acting_on_directory
operator|=
literal|0
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
name|erraddr
expr_stmt|;
name|cur_ino
operator|=
name|errino
expr_stmt|;
name|cur_inum
operator|=
name|errinum
expr_stmt|;
name|cur_bytes
operator|=
name|errcur_bytes
expr_stmt|;
name|printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|getnextinput
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
block|}
name|c_count
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|getachar
argument_list|()
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* command end */
name|freemem
argument_list|(
name|filenames
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
name|nfiles
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|should_print
operator|&&
name|laststyle
operator|==
literal|'='
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
goto|goto
name|calc
goto|;
block|}
if|if
condition|(
name|c_count
operator|==
literal|1
condition|)
block|{
name|clear
operator|=
literal|0
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errino
operator|=
name|cur_ino
expr_stmt|;
name|errinum
operator|=
name|cur_inum
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|DIRECTORY
case|:
name|addr
operator|=
name|getdirslot
argument_list|(
name|dirslot
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
name|should_print
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|INODE
case|:
name|cur_inum
operator|++
expr_stmt|;
name|addr
operator|=
name|itob
argument_list|(
name|cur_inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icheck
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|cur_inum
operator|--
expr_stmt|;
name|should_print
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|CGRP
case|:
case|case
name|SB
case|:
name|cur_cgrp
operator|++
expr_stmt|;
name|addr
operator|=
name|cgrp_check
argument_list|(
name|cur_cgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|cur_cgrp
operator|--
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|addr
operator|+=
name|objsz
expr_stmt|;
name|cur_bytes
operator|+=
name|objsz
expr_stmt|;
if|if
condition|(
name|valid_addr
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|trapped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|should_print
condition|)
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|DIRECTORY
case|:
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
break|break;
case|case
name|INODE
case|:
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cur_ino
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|CGRP
case|:
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
break|break;
case|case
name|SB
case|:
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
case|case
name|SHORT
case|:
case|case
name|LONG
case|:
name|fprnt
argument_list|(
name|laststyle
argument_list|,
name|lastpo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c_count
operator|=
name|colon
operator|=
name|acting_on_inode
operator|=
literal|0
expr_stmt|;
name|acting_on_directory
operator|=
literal|0
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|getnextinput
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errino
operator|=
name|cur_ino
expr_stmt|;
name|errinum
operator|=
name|cur_inum
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
continue|continue;
case|case
literal|'('
case|:
comment|/* numeric expression or unknown command */
default|default:
name|colon
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'('
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|addr
operator|=
name|expr
argument_list|()
expr_stmt|;
name|type
operator|=
name|NUMB
expr_stmt|;
name|value
operator|=
name|addr
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"unknown command or bad syntax\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'?'
case|:
comment|/* general print facilities */
case|case
literal|'/'
case|:
name|fprnt
argument_list|(
name|c
argument_list|,
name|getachar
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|';'
case|:
comment|/* command separator and . */
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
case|case
literal|'.'
case|:
continue|continue;
case|case
literal|':'
case|:
comment|/* command indicator */
name|colon
operator|++
expr_stmt|;
name|commands
operator|++
expr_stmt|;
name|should_print
operator|=
literal|0
expr_stmt|;
name|stringsize
operator|=
literal|0
expr_stmt|;
name|trapped
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|','
case|:
comment|/* count indicator */
name|colon
operator|=
name|star
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
block|{
name|star
operator|=
literal|1
expr_stmt|;
name|count
operator|=
name|BLKSIZE
expr_stmt|;
block|}
else|else
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|count
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
operator|!
name|count
condition|)
name|count
operator|=
literal|1
expr_stmt|;
block|}
name|clear
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
comment|/* address addition */
name|colon
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|temp
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
block|}
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|DIRECTORY
case|:
name|addr
operator|=
name|getdirslot
argument_list|(
name|dirslot
operator|+
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
break|break;
case|case
name|INODE
case|:
name|cur_inum
operator|+=
name|temp
expr_stmt|;
name|addr
operator|=
name|itob
argument_list|(
name|cur_inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icheck
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|cur_inum
operator|-=
name|temp
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|CGRP
case|:
case|case
name|SB
case|:
name|cur_cgrp
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|cgrp_check
argument_list|(
name|cur_cgrp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|cur_cgrp
operator|-=
name|temp
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|laststyle
operator|=
literal|'/'
expr_stmt|;
name|addr
operator|+=
name|temp
operator|*
name|objsz
expr_stmt|;
name|cur_bytes
operator|+=
name|temp
operator|*
name|objsz
expr_stmt|;
if|if
condition|(
name|valid_addr
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
block|}
name|value
operator|=
name|get
argument_list|(
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
comment|/* address subtraction */
name|colon
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|temp
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
block|}
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|DIRECTORY
case|:
name|addr
operator|=
name|getdirslot
argument_list|(
name|dirslot
operator|-
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
break|break;
case|case
name|INODE
case|:
name|cur_inum
operator|-=
name|temp
expr_stmt|;
name|addr
operator|=
name|itob
argument_list|(
name|cur_inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icheck
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|cur_inum
operator|+=
name|temp
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|CGRP
case|:
case|case
name|SB
case|:
name|cur_cgrp
operator|-=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|cgrp_check
argument_list|(
name|cur_cgrp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|cur_cgrp
operator|+=
name|temp
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|laststyle
operator|=
literal|'/'
expr_stmt|;
name|addr
operator|-=
name|temp
operator|*
name|objsz
expr_stmt|;
name|cur_bytes
operator|-=
name|temp
operator|*
name|objsz
expr_stmt|;
if|if
condition|(
name|valid_addr
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
block|}
name|value
operator|=
name|get
argument_list|(
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
comment|/* address multiplication */
name|colon
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
name|objsz
operator|!=
name|INODE
operator|&&
name|objsz
operator|!=
name|DIRECTORY
condition|)
name|laststyle
operator|=
literal|'/'
expr_stmt|;
name|addr
operator|*=
name|temp
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
comment|/* address division */
name|colon
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|printf
argument_list|(
literal|"divide by zero\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|objsz
operator|!=
name|INODE
operator|&&
name|objsz
operator|!=
name|DIRECTORY
condition|)
name|laststyle
operator|=
literal|'/'
expr_stmt|;
name|addr
operator|/=
name|temp
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
block|{
comment|/* assignment operation */
name|short
name|tbase
init|=
name|base
decl_stmt|;
name|calc
label|:
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|lastpo
expr_stmt|;
if|if
condition|(
name|acting_on_inode
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'o'
operator|&&
name|c
operator|!=
literal|'d'
operator|&&
name|c
operator|!=
literal|'x'
operator|&&
name|c
operator|!=
literal|'O'
operator|&&
name|c
operator|!=
literal|'D'
operator|&&
name|c
operator|!=
literal|'X'
condition|)
block|{
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|LONG
case|:
name|c
operator|=
name|lastpo
operator|=
literal|'X'
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|c
operator|=
name|lastpo
operator|=
literal|'x'
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|c
operator|=
name|lastpo
operator|=
literal|'c'
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|acting_on_inode
operator|==
literal|2
condition|)
name|c
operator|=
name|lastpo
operator|=
literal|'t'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|acting_on_inode
condition|)
name|lastpo
operator|=
name|c
expr_stmt|;
name|should_print
operator|=
name|star
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
comment|/* character string */
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
block|{
name|blocksize
operator|=
name|BLKSIZE
expr_stmt|;
name|filesize
operator|=
name|BLKSIZE
operator|*
literal|2
expr_stmt|;
name|cur_bytes
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
operator|||
name|objsz
operator|==
name|INODE
condition|)
name|lastpo
operator|=
literal|'X'
expr_stmt|;
block|}
name|puta
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
comment|/* =+ operator */
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|objsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|put
argument_list|(
name|value
operator|+
name|temp
argument_list|,
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
comment|/* =- operator */
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|objsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|put
argument_list|(
name|value
operator|-
name|temp
argument_list|,
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
if|if
condition|(
name|objsz
operator|==
name|CGRP
condition|)
name|fprnt
argument_list|(
literal|'?'
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprnt
argument_list|(
literal|'/'
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|addr
operator|=
name|cur_ino
expr_stmt|;
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'s'
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|laststyle
operator|=
literal|'='
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'o'
case|:
name|base
operator|=
name|OCTAL
expr_stmt|;
goto|goto
name|otx
goto|;
case|case
literal|'d'
case|:
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
condition|)
block|{
name|addr
operator|=
name|cur_dir
expr_stmt|;
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|base
operator|=
name|DECIMAL
expr_stmt|;
goto|goto
name|otx
goto|;
case|case
literal|'x'
case|:
name|base
operator|=
name|HEX
expr_stmt|;
name|otx
label|:
name|laststyle
operator|=
literal|'='
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|acting_on_inode
condition|)
name|print
argument_list|(
name|value
operator|&
literal|0177777L
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print
argument_list|(
name|addr
operator|&
literal|0177777L
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|base
operator|=
name|tbase
expr_stmt|;
continue|continue;
case|case
literal|'O'
case|:
name|base
operator|=
name|OCTAL
expr_stmt|;
goto|goto
name|OTX
goto|;
case|case
literal|'D'
case|:
name|base
operator|=
name|DECIMAL
expr_stmt|;
goto|goto
name|OTX
goto|;
case|case
literal|'X'
case|:
name|base
operator|=
name|HEX
expr_stmt|;
name|OTX
label|:
name|laststyle
operator|=
literal|'='
expr_stmt|;
name|printf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|acting_on_inode
condition|)
name|print
argument_list|(
name|value
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print
argument_list|(
name|addr
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|base
operator|=
name|tbase
expr_stmt|;
continue|continue;
default|default:
comment|/* regular assignment */
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"syntax error\n"
argument_list|)
expr_stmt|;
else|else
name|put
argument_list|(
name|value
argument_list|,
name|objsz
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
case|case
literal|'>'
case|:
comment|/* save current address */
name|colon
operator|=
literal|0
expr_stmt|;
name|should_print
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|letter
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"invalid register specification, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"must be letter or digit\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|letter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|'a'
condition|)
name|c
operator|=
name|uppertolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|hextodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|=
name|numtodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|regs
index|[
name|c
index|]
operator|.
name|sv_addr
operator|=
name|addr
expr_stmt|;
name|regs
index|[
name|c
index|]
operator|.
name|sv_value
operator|=
name|value
expr_stmt|;
name|regs
index|[
name|c
index|]
operator|.
name|sv_objsz
operator|=
name|objsz
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
comment|/* restore saved address */
name|colon
operator|=
literal|0
expr_stmt|;
name|should_print
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|letter
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"invalid register specification, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"must be letter or digit\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|letter
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|'a'
condition|)
name|c
operator|=
name|uppertolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|hextodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|=
name|numtodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|addr
operator|=
name|regs
index|[
name|c
index|]
operator|.
name|sv_addr
expr_stmt|;
name|value
operator|=
name|regs
index|[
name|c
index|]
operator|.
name|sv_value
expr_stmt|;
name|objsz
operator|=
name|regs
index|[
name|c
index|]
operator|.
name|sv_objsz
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"at"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* access time */
name|acting_on_inode
operator|=
literal|2
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_atime
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'b'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"block"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* block conversion */
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
block|{
name|value
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|=
literal|0
expr_stmt|;
name|blocksize
operator|=
name|BLKSIZE
expr_stmt|;
name|filesize
operator|=
name|BLKSIZE
operator|*
literal|2
expr_stmt|;
block|}
name|addr
operator|=
name|value
operator|<<
name|FRGSHIFT
expr_stmt|;
name|bod_addr
operator|=
name|addr
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|BLOCK
expr_stmt|;
name|dirslot
operator|=
literal|0
expr_stmt|;
name|trapped
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"bs"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* block size */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|icheck
argument_list|(
name|cur_ino
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_blocks
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"base"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* change/show base */
name|showbase
label|:
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"base =\t\t"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
case|case
name|OCTAL
case|:
name|printf
argument_list|(
literal|"OCTAL\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DECIMAL
case|:
name|printf
argument_list|(
literal|"DECIMAL\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|HEX
case|:
name|printf
argument_list|(
literal|"HEX\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|'='
condition|)
block|{
name|printf
argument_list|(
literal|"missing '='\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|value
operator|=
name|expr
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"invalid base\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
case|case
name|OCTAL
case|:
case|case
name|DECIMAL
case|:
case|case
name|HEX
case|:
name|base
operator|=
name|value
expr_stmt|;
block|}
goto|goto
name|showbase
goto|;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'c'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"cd"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* change directory */
name|top
operator|=
name|filenames
operator|-
literal|1
expr_stmt|;
name|eat_spaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|current_pathp
operator|=
operator|-
literal|1
expr_stmt|;
name|restore_inode
argument_list|(
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|temp
operator|=
name|cur_inum
expr_stmt|;
name|doing_cd
operator|=
literal|1
expr_stmt|;
name|parse
argument_list|()
expr_stmt|;
name|doing_cd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nfiles
operator|!=
literal|1
condition|)
block|{
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|print_path
argument_list|(
name|input_path
argument_list|,
name|input_pathp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" not found\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" ambiguous\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
name|restore_inode
argument_list|(
name|filenames
operator|->
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
block|{
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|input_path
argument_list|,
name|input_pathp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" not a directory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|top
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|strcpy
argument_list|(
name|current_path
index|[
name|i
index|]
argument_list|,
name|top
operator|->
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|current_pathp
operator|=
name|top
operator|->
name|len
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"cg"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* cylinder group */
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|fs
operator|->
name|fs_ncg
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"maximum cylinder group is "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|fs
operator|->
name|fs_ncg
operator|-
literal|1
argument_list|,
literal|8
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|type
operator|=
name|objsz
operator|=
name|CGRP
expr_stmt|;
name|cur_cgrp
operator|=
name|value
expr_stmt|;
name|addr
operator|=
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cur_cgrp
argument_list|)
operator|<<
name|FRGSHIFT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"ct"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* creation time */
name|acting_on_inode
operator|=
literal|2
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_ctime
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'d'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"directory"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* directory offsets */
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
name|objsz
operator|=
name|DIRECTORY
expr_stmt|;
name|type
operator|=
name|DIRECTORY
expr_stmt|;
name|addr
operator|=
name|getdirslot
argument_list|(
name|value
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"db"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* direct block */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|NDADDR
condition|)
block|{
name|printf
argument_list|(
literal|"direct blocks are 0 to "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|NDADDR
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
name|cur_ino
expr_stmt|;
if|if
condition|(
operator|!
name|icheck
argument_list|(
name|addr
argument_list|)
condition|)
continue|continue;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_db
index|[
name|value
index|]
expr_stmt|;
name|bod_addr
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|=
operator|(
name|value
operator|)
operator|*
name|BLKSIZE
expr_stmt|;
name|cur_block
operator|=
name|value
expr_stmt|;
name|type
operator|=
name|BLOCK
expr_stmt|;
name|dirslot
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|&&
operator|!
name|override
condition|)
block|{
name|printf
argument_list|(
literal|"non existent block\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'f'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"find"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* find command */
name|find
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"fragment"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* fragment conv. */
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
block|{
name|value
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|=
literal|0
expr_stmt|;
name|blocksize
operator|=
name|FRGSIZE
expr_stmt|;
name|filesize
operator|=
name|FRGSIZE
operator|*
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|min
argument_list|(
name|blocksize
argument_list|,
name|filesize
argument_list|)
operator|-
name|cur_bytes
operator|>
name|FRGSIZE
condition|)
block|{
name|blocksize
operator|=
name|cur_bytes
operator|+
name|FRGSIZE
expr_stmt|;
name|filesize
operator|=
name|blocksize
operator|*
literal|2
expr_stmt|;
block|}
name|addr
operator|=
name|value
operator|<<
name|FRGSHIFT
expr_stmt|;
name|bod_addr
operator|=
name|addr
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|FRAGMENT
expr_stmt|;
name|dirslot
operator|=
literal|0
expr_stmt|;
name|trapped
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"file"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* access as file */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|cur_ino
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFCHR
operator|)
operator|&&
operator|!
name|override
condition|)
block|{
name|printf
argument_list|(
literal|"special device\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|addr
operator|=
operator|(
name|bmap
argument_list|(
name|value
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|cur_block
operator|=
name|value
expr_stmt|;
name|bod_addr
operator|=
name|addr
expr_stmt|;
name|type
operator|=
name|BLOCK
expr_stmt|;
name|dirslot
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"fill"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* fill */
if|if
condition|(
name|getachar
argument_list|()
operator|!=
literal|'='
condition|)
block|{
name|printf
argument_list|(
literal|"missing '='\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|objsz
operator|==
name|INODE
operator|||
name|objsz
operator|==
name|DIRECTORY
condition|)
block|{
name|printf
argument_list|(
literal|"can't fill inode or directory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|fill
argument_list|()
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'g'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"gid"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* group id */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_gid
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|SHORT
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'i'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"inode"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* i# to inode conversion */
if|if
condition|(
name|c_count
operator|==
literal|2
condition|)
block|{
name|addr
operator|=
name|cur_ino
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|INODE
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
name|laststyle
operator|=
literal|'='
expr_stmt|;
name|lastpo
operator|=
literal|'i'
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
name|itob
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icheck
argument_list|(
name|addr
argument_list|)
condition|)
continue|continue;
name|cur_ino
operator|=
name|addr
expr_stmt|;
name|cur_inum
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|INODE
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"ib"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* indirect block */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|NIADDR
condition|)
block|{
name|printf
argument_list|(
literal|"indirect blocks are 0 to "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|NIADDR
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_ib
index|[
name|value
index|]
expr_stmt|;
name|cur_bytes
operator|=
operator|(
name|NDADDR
operator|-
literal|1
operator|)
operator|*
name|BLKSIZE
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|value
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|*
name|BLKSIZE
expr_stmt|;
name|cur_bytes
operator|+=
name|temp
expr_stmt|;
block|}
name|type
operator|=
name|BLOCK
expr_stmt|;
name|dirslot
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|&&
operator|!
name|override
condition|)
block|{
name|printf
argument_list|(
literal|"non existent block\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'l'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"ls"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* ls command */
name|temp
operator|=
name|cur_inum
expr_stmt|;
name|recursive
operator|=
name|long_list
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|filenames
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|eat_spaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'R'
condition|)
block|{
name|recursive
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
name|long_list
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"unknown option "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'%c'\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c_count
operator|!=
literal|2
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c_count
operator|++
expr_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|parse
argument_list|()
expr_stmt|;
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|recursive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|nfiles
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|print_path
argument_list|(
name|input_path
argument_list|,
name|input_pathp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" not found\n"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|nfiles
condition|)
block|{
name|cmp_level
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|filenames
argument_list|,
name|nfiles
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|filenames
argument_list|)
argument_list|,
name|ffcmp
argument_list|)
expr_stmt|;
name|ls
argument_list|(
name|filenames
argument_list|,
name|filenames
operator|+
operator|(
name|nfiles
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"no match\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"ln"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* link count */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_nlink
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|SHORT
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
name|addr
operator|=
name|cur_ino
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|match
argument_list|(
literal|"mt"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* modification time */
name|acting_on_inode
operator|=
literal|2
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_mtime
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"md"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* mode */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_mode
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|SHORT
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"maj"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* major device number */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|devcheck
argument_list|(
name|mode
argument_list|)
condition|)
continue|continue;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_db
index|[
literal|1
index|]
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"min"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* minor device number */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|devcheck
argument_list|(
name|mode
argument_list|)
condition|)
continue|continue;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_db
index|[
literal|0
index|]
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'n'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"nm"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* directory name */
name|objsz
operator|=
name|DIRECTORY
expr_stmt|;
name|acting_on_directory
operator|=
literal|1
expr_stmt|;
name|cur_dir
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|cptr
operator|+
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
operator|)
expr_stmt|;
name|stringsize
operator|=
operator|(
name|long
operator|)
name|dirp
operator|->
name|d_reclen
operator|-
operator|(
operator|(
name|long
operator|)
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
operator|-
operator|(
name|long
operator|)
operator|&
name|dirp
operator|->
name|d_ino
operator|)
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|direct
operator|*
operator|)
name|addr
operator|)
operator|->
name|d_name
index|[
literal|0
index|]
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'o'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"override"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* override flip flop */
if|if
condition|(
name|override
operator|=
operator|!
name|override
condition|)
name|printf
argument_list|(
literal|"error checking off\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"error checking on\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'p'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"pwd"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* print working dir */
name|print_path
argument_list|(
name|current_path
argument_list|,
name|current_pathp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"prompt"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* change prompt */
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'='
condition|)
block|{
name|printf
argument_list|(
literal|"missing '='\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'"'
condition|)
block|{
name|printf
argument_list|(
literal|"missing '\"'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|prompt
operator|=
operator|&
name|prompt
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|prompt
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|PROMPTSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"string too long\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|prompt
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'q'
case|:
if|if
condition|(
operator|!
name|colon
condition|)
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"quit"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* quit */
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"sb"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* super block */
if|if
condition|(
name|c_count
operator|==
literal|2
condition|)
block|{
name|cur_cgrp
operator|=
operator|-
literal|1
expr_stmt|;
name|type
operator|=
name|objsz
operator|=
name|SB
expr_stmt|;
name|laststyle
operator|=
literal|'='
expr_stmt|;
name|lastpo
operator|=
literal|'s'
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|value
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|fs
operator|->
name|fs_ncg
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"maximum super block is "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|fs
operator|->
name|fs_ncg
operator|-
literal|1
argument_list|,
literal|8
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|type
operator|=
name|objsz
operator|=
name|SB
expr_stmt|;
name|cur_cgrp
operator|=
name|value
expr_stmt|;
name|addr
operator|=
name|cgsblock
argument_list|(
name|fs
argument_list|,
name|cur_cgrp
argument_list|)
operator|<<
name|FRGSHIFT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match
argument_list|(
literal|"sz"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* file size */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_size
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'u'
case|:
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
if|if
condition|(
name|match
argument_list|(
literal|"uid"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* user id */
name|acting_on_inode
operator|=
literal|1
expr_stmt|;
name|should_print
operator|=
literal|1
expr_stmt|;
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
operator|(
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
operator|)
operator|->
name|di_uid
expr_stmt|;
name|value
operator|=
name|get
argument_list|(
name|SHORT
argument_list|)
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
goto|goto
name|bad_syntax
goto|;
case|case
literal|'F'
case|:
comment|/* buffer status (internal use only) */
if|if
condition|(
name|colon
condition|)
name|colon
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|no_colon
goto|;
for|for
control|(
name|bp
operator|=
name|bhdr
operator|.
name|fwd
init|;
name|bp
operator|!=
operator|&
name|bhdr
condition|;
name|bp
operator|=
name|bp
operator|->
name|fwd
control|)
name|printf
argument_list|(
literal|"%8x %d\n"
argument_list|,
name|bp
operator|->
name|blkno
argument_list|,
name|bp
operator|->
name|valid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# commands\t\t%d\n"
argument_list|,
name|commands
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# read requests\t\t%d\n"
argument_list|,
name|read_requests
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"# actual disk reads\t%d\n"
argument_list|,
name|actual_disk_reads
argument_list|)
expr_stmt|;
continue|continue;
name|no_colon
label|:
name|printf
argument_list|(
literal|"a colon should precede a command\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
name|bad_syntax
label|:
name|printf
argument_list|(
literal|"more letters needed to distinguish command\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * getachar - get next character from input buffer.  */
end_comment

begin_function
name|char
name|getachar
parameter_list|()
block|{
return|return
operator|(
name|input_buffer
index|[
name|input_pointer
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ungetachar - return character to input buffer.  */
end_comment

begin_expr_stmt
name|ungetachar
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|input_pointer
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"internal problem maintaining input buffer\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|input_buffer
index|[
operator|--
name|input_pointer
index|]
operator|=
name|c
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * getnextinput - display the prompt and read an input line.  *	An input line is up to 128 characters terminated by the newline  *	character.  Handle overflow, shell escape, and eof.  */
end_comment

begin_macro
name|getnextinput
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|short
name|pid
decl_stmt|,
name|rpid
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|newline
label|:
name|i
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|ignore_eol
label|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
operator|!
operator|(
name|c
operator|==
literal|'!'
operator|&&
name|i
operator|==
literal|0
operator|)
operator|&&
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
operator|&&
name|i
operator|<=
name|INPUTBUFFER
operator|-
literal|2
condition|)
name|input_buffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|input_buffer
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
name|input_buffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
goto|goto
name|ignore_eol
goto|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|execl
argument_list|(
name|_PATH_BSHELL
argument_list|,
literal|"sh"
argument_list|,
literal|"-t"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|rpid
operator|=
name|wait
argument_list|(
operator|&
name|retcode
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|rpid
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
goto|goto
name|newline
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
name|printf
argument_list|(
literal|"input truncated to 128 characters\n"
argument_list|)
expr_stmt|;
name|input_buffer
index|[
name|i
index|]
operator|=
literal|'\n'
expr_stmt|;
name|input_pointer
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * eat_spaces - read extraneous spaces.  */
end_comment

begin_macro
name|eat_spaces
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * restore_inode - set up all inode indicators so inum is now  *	the current inode.  */
end_comment

begin_macro
name|restore_inode
argument_list|(
argument|inum
argument_list|)
end_macro

begin_decl_stmt
name|long
name|inum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errinum
operator|=
name|cur_inum
operator|=
name|inum
expr_stmt|;
name|addr
operator|=
name|errino
operator|=
name|cur_ino
operator|=
name|itob
argument_list|(
name|inum
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * match - return false if the input does not match string up to  *	upto letters.   Then proceed to chew up extraneous letters.  */
end_comment

begin_expr_stmt
name|match
argument_list|(
name|string
argument_list|,
name|upto
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|upto
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|length
init|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|save_upto
init|=
name|upto
decl_stmt|;
while|while
condition|(
operator|--
name|upto
condition|)
block|{
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
operator|*
name|string
condition|)
block|{
for|for
control|(
name|i
operator|=
name|save_upto
operator|-
name|upto
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
operator|--
name|string
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|length
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|string
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
operator|*
name|string
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * expr - expression evaluator.  Will evaluate expressions from  *	left to right with no operator precedence.  Parentheses may  *	be used.  */
end_comment

begin_function
name|long
name|expr
parameter_list|()
block|{
specifier|register
name|long
name|numb
init|=
literal|0
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|numb
operator|=
name|term
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|error
condition|)
return|return;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|numb
operator|+=
name|term
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
name|numb
operator|-=
name|term
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
name|numb
operator|*=
name|term
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|temp
operator|=
name|term
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
block|{
name|printf
argument_list|(
literal|"divide by zero\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|numb
operator|/=
name|temp
expr_stmt|;
continue|continue;
case|case
literal|')'
case|:
name|paren
operator|--
expr_stmt|;
return|return
operator|(
name|numb
operator|)
return|;
default|default:
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
operator|&&
operator|!
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"missing ')'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numb
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * term - used by expression evaluator to get an operand.  */
end_comment

begin_function
name|long
name|term
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|getachar
argument_list|()
condition|)
block|{
default|default:
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
case|case
literal|'+'
case|:
return|return
operator|(
name|getnumb
argument_list|()
operator|)
return|;
case|case
literal|'-'
case|:
return|return
operator|(
operator|-
name|getnumb
argument_list|()
operator|)
return|;
case|case
literal|'('
case|:
name|paren
operator|++
expr_stmt|;
return|return
operator|(
name|expr
argument_list|()
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * getnumb - read a number from the input stream.  A leading  *	zero signifies octal interpretation, a leading '0x'  *	signifies hexadecimal, and a leading '0t' signifies  *	decimal.  If the first character is a character,  *	return an error.  */
end_comment

begin_function
name|long
name|getnumb
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|,
name|savec
decl_stmt|;
name|long
name|number
init|=
literal|0
decl_stmt|,
name|tbase
decl_stmt|,
name|num
decl_stmt|;
specifier|extern
name|short
name|error
decl_stmt|;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|digit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|tbase
operator|=
name|OCTAL
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'x'
condition|)
name|tbase
operator|=
name|HEX
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
name|tbase
operator|=
name|DECIMAL
expr_stmt|;
else|else
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tbase
operator|=
name|base
expr_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|num
operator|=
name|tbase
expr_stmt|;
name|c
operator|=
name|savec
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
name|HEXLETTER
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|uppertolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tbase
condition|)
block|{
case|case
name|HEX
case|:
if|if
condition|(
name|hexletter
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|num
operator|=
name|hextodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DECIMAL
case|:
if|if
condition|(
name|digit
argument_list|(
name|c
argument_list|)
condition|)
name|num
operator|=
name|numtodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|OCTAL
case|:
if|if
condition|(
name|octaldigit
argument_list|(
name|c
argument_list|)
condition|)
name|num
operator|=
name|numtodigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|==
name|tbase
condition|)
break|break;
name|number
operator|=
name|number
operator|*
name|tbase
operator|+
name|num
expr_stmt|;
block|}
name|ungetachar
argument_list|(
name|savec
argument_list|)
expr_stmt|;
return|return
operator|(
name|number
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find - the syntax is almost identical to the unix command.  *		find dir [-name pattern] [-inum number]  *	Note:  only one of -name or -inum may be used at a time.  *	       Also, the -print is not needed (implied).  */
end_comment

begin_macro
name|find
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|filenames
modifier|*
name|fn
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|long
name|temp
decl_stmt|;
name|short
name|mode
decl_stmt|;
name|eat_spaces
argument_list|()
expr_stmt|;
name|temp
operator|=
name|cur_inum
expr_stmt|;
name|top
operator|=
name|filenames
operator|-
literal|1
expr_stmt|;
name|doing_cd
operator|=
literal|1
expr_stmt|;
name|parse
argument_list|()
expr_stmt|;
name|doing_cd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nfiles
operator|!=
literal|1
condition|)
block|{
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|print_path
argument_list|(
name|input_path
argument_list|,
name|input_pathp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" not found\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" ambiguous\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|restore_inode
argument_list|(
name|filenames
operator|->
name|ino
argument_list|)
expr_stmt|;
name|freemem
argument_list|(
name|filenames
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
name|nfiles
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|filenames
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
block|{
name|print_path
argument_list|(
name|input_path
argument_list|,
name|input_pathp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" not a directory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|eat_spaces
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'-'
condition|)
block|{
name|printf
argument_list|(
literal|"missing '-'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|find_by_name
operator|=
name|find_by_inode
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
literal|"name"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|eat_spaces
argument_list|()
expr_stmt|;
name|find_by_name
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match
argument_list|(
literal|"inum"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|eat_spaces
argument_list|()
expr_stmt|;
name|find_ino
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|find_by_inode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"use -name or -inum with find\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|doing_find
operator|=
literal|1
expr_stmt|;
name|parse
argument_list|()
expr_stmt|;
name|doing_find
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|fn
operator|=
name|filenames
init|;
name|fn
operator|<=
name|top
condition|;
name|fn
operator|++
control|)
block|{
if|if
condition|(
name|fn
operator|->
name|find
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"i#: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|fn
operator|->
name|ino
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|fn
operator|->
name|fname
argument_list|,
name|fn
operator|->
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|restore_inode
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ls - do an ls.  Should behave exactly as ls(1).  *	Only -R and -l is supported and -l gives different results.  */
end_comment

begin_macro
name|ls
argument_list|(
argument|fn0
argument_list|,
argument|fnlast
argument_list|,
argument|level
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filenames
modifier|*
name|fn0
decl_stmt|,
modifier|*
name|fnlast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|level
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|filenames
modifier|*
name|fn
decl_stmt|,
modifier|*
name|fnn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fcmp
parameter_list|()
function_decl|;
name|fn
operator|=
name|fn0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fn0
operator|=
name|fn
expr_stmt|;
if|if
condition|(
name|fn0
operator|->
name|len
condition|)
block|{
name|cmp_level
operator|=
name|level
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fn0
argument_list|,
name|fnlast
operator|-
name|fn0
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|filenames
argument_list|)
argument_list|,
name|fcmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|fnn
operator|=
name|fn
operator|,
name|fn
operator|++
init|;
name|fn
operator|<=
name|fnlast
condition|;
name|fnn
operator|=
name|fn
operator|,
name|fn
operator|++
control|)
block|{
if|if
condition|(
name|fnn
operator|->
name|len
operator|!=
name|fn
operator|->
name|len
operator|&&
name|level
operator|==
name|fnn
operator|->
name|len
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|fnn
operator|->
name|len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|fn
operator|->
name|fname
index|[
name|level
index|]
argument_list|,
name|fnn
operator|->
name|fname
index|[
name|level
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|fn0
operator|->
name|len
operator|&&
name|level
operator|!=
name|fn0
operator|->
name|len
operator|-
literal|1
condition|)
name|ls
argument_list|(
name|fn0
argument_list|,
name|fnn
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fn0
operator|!=
name|filenames
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_path
argument_list|(
name|fn0
operator|->
name|fname
argument_list|,
name|fn0
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn0
operator|->
name|len
operator|==
literal|0
condition|)
name|cmp_level
operator|=
name|level
expr_stmt|;
else|else
name|cmp_level
operator|=
name|level
operator|+
literal|1
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fn0
argument_list|,
name|fnn
operator|-
name|fn0
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|filenames
argument_list|)
argument_list|,
name|fcmp
argument_list|)
expr_stmt|;
name|formatf
argument_list|(
name|fn0
argument_list|,
name|fnn
argument_list|)
expr_stmt|;
name|nfiles
operator|-=
name|fnn
operator|-
name|fn0
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|>
name|fnlast
condition|)
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * formatf - code lifted from ls.  */
end_comment

begin_expr_stmt
name|formatf
argument_list|(
name|fn0
argument_list|,
name|fnlast
argument_list|)
specifier|register
expr|struct
name|filenames
operator|*
name|fn0
operator|,
operator|*
name|fnlast
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|filenames
modifier|*
name|fn
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|,
name|w
decl_stmt|,
name|nentry
init|=
name|fnlast
operator|-
name|fn0
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|columns
decl_stmt|,
name|lines
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|long_list
condition|)
block|{
name|columns
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|fn
operator|=
name|fn0
init|;
name|fn
operator|<=
name|fnlast
condition|;
name|fn
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|fn
operator|->
name|fname
index|[
name|cmp_level
index|]
argument_list|)
operator|+
literal|2
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|width
condition|)
name|width
operator|=
name|len
expr_stmt|;
block|}
name|width
operator|=
operator|(
name|width
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|columns
operator|=
literal|80
operator|/
name|width
expr_stmt|;
if|if
condition|(
name|columns
operator|==
literal|0
condition|)
name|columns
operator|=
literal|1
expr_stmt|;
block|}
name|lines
operator|=
operator|(
name|nentry
operator|+
name|columns
operator|-
literal|1
operator|)
operator|/
name|columns
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
block|{
name|fn
operator|=
name|fn0
operator|+
name|j
operator|*
name|lines
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|long_list
condition|)
block|{
name|printf
argument_list|(
literal|"i#: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|fn
operator|->
name|ino
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|fmtentry
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|+
name|lines
operator|>
name|fnlast
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|w
operator|<
name|width
condition|)
block|{
name|w
operator|=
operator|(
name|w
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * fmtentry - code lifted from ls.  */
end_comment

begin_function
name|char
modifier|*
name|fmtentry
parameter_list|(
name|fn
parameter_list|)
specifier|register
name|struct
name|filenames
modifier|*
name|fn
decl_stmt|;
block|{
specifier|static
name|char
name|fmtres
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|dp
operator|=
operator|&
name|fmtres
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|fn
operator|->
name|fname
index|[
name|cmp_level
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<
literal|' '
operator|||
operator|*
name|cp
operator|>=
literal|0177
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|addr
operator|=
name|itob
argument_list|(
name|fn
operator|->
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cptr
expr_stmt|;
switch|switch
condition|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFDIR
case|:
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
break|break;
case|case
name|IFLNK
case|:
operator|*
name|dp
operator|++
operator|=
literal|'@'
expr_stmt|;
break|break;
case|case
name|IFSOCK
case|:
operator|*
name|dp
operator|++
operator|=
literal|'='
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IFIFO
case|case
name|IFIFO
case|:
operator|*
name|dp
operator|++
operator|=
literal|'p'
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IFCHR
case|:
case|case
name|IFBLK
case|:
case|case
name|IFREG
case|:
if|if
condition|(
name|ip
operator|->
name|di_mode
operator|&
literal|0111
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'*'
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
default|default:
operator|*
name|dp
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
operator|*
name|dp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|fmtres
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fcmp - routine used by qsort.  Will sort first by name, then  *	then by pathname length if names are equal.  Uses global  *	cmp_level to tell what component of the path name we are comparing.  */
end_comment

begin_expr_stmt
name|fcmp
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
specifier|register
expr|struct
name|filenames
operator|*
name|f1
operator|,
operator|*
name|f2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
operator|(
name|value
operator|=
name|strcmp
argument_list|(
name|f1
operator|->
name|fname
index|[
name|cmp_level
index|]
argument_list|,
name|f2
operator|->
name|fname
index|[
name|cmp_level
index|]
argument_list|)
operator|)
condition|)
return|return
operator|(
name|value
operator|)
return|;
return|return
operator|(
name|f1
operator|->
name|len
operator|-
name|f2
operator|->
name|len
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * ffcmp - routine used by qsort.  Sort only by pathname length.  */
end_comment

begin_expr_stmt
name|ffcmp
argument_list|(
name|f1
argument_list|,
name|f2
argument_list|)
specifier|register
expr|struct
name|filenames
operator|*
name|f1
operator|,
operator|*
name|f2
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|f1
operator|->
name|len
operator|-
name|f2
operator|->
name|len
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * parse - set up the call to follow_path.  */
end_comment

begin_macro
name|parse
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|c
decl_stmt|;
name|stack_pathp
operator|=
name|input_pathp
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'/'
condition|)
empty_stmt|;
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cur_inum
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|doing_cd
condition|)
block|{
name|top
operator|++
expr_stmt|;
name|top
operator|->
name|ino
operator|=
literal|2
expr_stmt|;
name|top
operator|->
name|len
operator|=
operator|-
literal|1
expr_stmt|;
name|nfiles
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|stack_pathp
operator|=
name|current_pathp
expr_stmt|;
if|if
condition|(
operator|!
name|doing_find
condition|)
name|input_pathp
operator|=
name|current_pathp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|current_pathp
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|doing_find
condition|)
name|strcpy
argument_list|(
name|input_path
index|[
name|i
index|]
argument_list|,
name|current_path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stack_path
index|[
name|i
index|]
argument_list|,
name|current_path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|getname
argument_list|()
expr_stmt|;
name|follow_path
argument_list|(
name|stack_pathp
operator|+
literal|1
argument_list|,
name|cur_inum
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * follow_path - called by cd, find, and ls.  *	input_path holds the name typed by the user.  *	stack_path holds the name at the current depth.  */
end_comment

begin_macro
name|follow_path
argument_list|(
argument|level
argument_list|,
argument|inum
argument_list|)
end_macro

begin_decl_stmt
name|long
name|level
decl_stmt|,
name|inum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|direct
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ccptr
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|filenames
modifier|*
name|tos
decl_stmt|,
modifier|*
name|bos
decl_stmt|,
modifier|*
name|fn
decl_stmt|,
modifier|*
name|fnn
decl_stmt|,
modifier|*
name|fnnn
decl_stmt|;
name|long
name|block
decl_stmt|;
name|short
name|mode
decl_stmt|;
name|tos
operator|=
name|top
operator|+
literal|1
expr_stmt|;
name|restore_inode
argument_list|(
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
condition|)
return|return;
name|block
operator|=
name|cur_bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_bytes
operator|<
name|filesize
condition|)
block|{
if|if
condition|(
name|block
operator|==
literal|0
operator|||
name|bcomp
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
operator|(
name|bmap
argument_list|(
name|block
operator|++
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
condition|)
block|{
if|if
condition|(
name|level
operator|>
name|input_pathp
operator|||
name|doing_find
operator|||
name|compare
argument_list|(
name|input_path
index|[
name|level
index|]
argument_list|,
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|top
operator|-
name|filenames
operator|>=
name|MAXFILES
condition|)
block|{
name|printf
argument_list|(
literal|"too many files\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|top
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|FIRST_DEPTH
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|fname
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|nfiles
operator|++
expr_stmt|;
name|top
operator|->
name|ino
operator|=
name|dirp
operator|->
name|d_ino
expr_stmt|;
name|top
operator|->
name|len
operator|=
name|stack_pathp
expr_stmt|;
name|top
operator|->
name|find
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doing_find
condition|)
block|{
if|if
condition|(
name|find_by_name
condition|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|input_path
index|[
literal|0
index|]
argument_list|,
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
condition|)
name|top
operator|->
name|find
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find_by_inode
condition|)
if|if
condition|(
name|find_ino
operator|==
name|dirp
operator|->
name|d_ino
condition|)
name|top
operator|->
name|find
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|->
name|len
operator|+
literal|1
operator|>=
name|FIRST_DEPTH
operator|&&
name|top
operator|->
name|flag
operator|==
literal|0
condition|)
block|{
name|ccptr
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|SECOND_DEPTH
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccptr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_DEPTH
condition|;
name|i
operator|++
control|)
name|ccptr
index|[
name|i
index|]
operator|=
name|top
operator|->
name|fname
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|top
operator|->
name|fname
argument_list|)
expr_stmt|;
name|top
operator|->
name|fname
operator|=
name|ccptr
expr_stmt|;
name|top
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|->
name|len
operator|>=
name|SECOND_DEPTH
condition|)
block|{
name|printf
argument_list|(
literal|"maximum depth exceeded, try to cd lower\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		     * Copy current depth. 		     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|stack_pathp
condition|;
name|i
operator|++
control|)
block|{
name|top
operator|->
name|fname
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|stack_path
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|fname
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|top
operator|->
name|fname
index|[
name|i
index|]
argument_list|,
name|stack_path
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * Check for '.' or '..' typed. 		     */
if|if
condition|(
operator|(
name|level
operator|<=
name|input_pathp
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|input_path
index|[
name|level
index|]
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|input_path
index|[
name|level
index|]
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|input_path
index|[
name|level
index|]
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|&&
name|top
operator|->
name|len
operator|>=
literal|0
condition|)
block|{
name|free
argument_list|(
name|top
operator|->
name|fname
index|[
name|top
operator|->
name|len
index|]
argument_list|)
expr_stmt|;
name|top
operator|->
name|len
operator|-=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Check for duplicates. 			 */
if|if
condition|(
operator|!
name|doing_cd
operator|&&
operator|!
name|doing_find
condition|)
block|{
for|for
control|(
name|fn
operator|=
name|filenames
init|;
name|fn
operator|<
name|top
condition|;
name|fn
operator|++
control|)
block|{
if|if
condition|(
name|fn
operator|->
name|ino
operator|==
name|dirp
operator|->
name|d_ino
operator|&&
name|fn
operator|->
name|len
operator|==
name|stack_pathp
operator|+
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fn
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|fn
operator|->
name|fname
index|[
name|i
index|]
argument_list|,
name|stack_path
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|fn
operator|->
name|len
operator|||
name|strcmp
argument_list|(
name|fn
operator|->
name|fname
index|[
name|i
index|]
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|freemem
argument_list|(
name|top
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|filenames
condition|)
name|top
operator|=
name|NULL
expr_stmt|;
else|else
name|top
operator|--
expr_stmt|;
name|nfiles
operator|--
expr_stmt|;
goto|goto
name|duplicate
goto|;
block|}
block|}
block|}
name|top
operator|->
name|len
operator|+=
literal|1
expr_stmt|;
name|top
operator|->
name|fname
index|[
name|top
operator|->
name|len
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|fname
index|[
name|top
operator|->
name|len
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|top
operator|->
name|fname
index|[
name|top
operator|->
name|len
index|]
argument_list|,
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|duplicate
label|:
name|addr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cptr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cur_bytes
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|<
name|filenames
condition|)
return|return;
if|if
condition|(
operator|(
name|doing_cd
operator|&&
name|level
operator|==
name|input_pathp
operator|)
operator|||
operator|(
operator|!
name|recursive
operator|&&
operator|!
name|doing_find
operator|&&
name|level
operator|>
name|input_pathp
operator|)
condition|)
return|return;
name|bos
operator|=
name|top
expr_stmt|;
comment|/* 	 * Check newly added entries to determine if further expansion 	 * is required. 	 */
for|for
control|(
name|fn
operator|=
name|tos
init|;
name|fn
operator|<=
name|bos
condition|;
name|fn
operator|++
control|)
block|{
comment|/* 	     * Avoid '.' and '..' if beyond input. 	     */
if|if
condition|(
operator|(
name|recursive
operator|||
name|doing_find
operator|)
operator|&&
operator|(
name|level
operator|>
name|input_pathp
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|fn
operator|->
name|fname
index|[
name|fn
operator|->
name|len
index|]
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|fn
operator|->
name|fname
index|[
name|fn
operator|->
name|len
index|]
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|restore_inode
argument_list|(
name|fn
operator|->
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|cur_ino
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|||
name|level
operator|<
name|input_pathp
condition|)
block|{
comment|/* 		 * Set up current depth, remove current entry and 		 * continue recursion. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|fn
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|strcpy
argument_list|(
name|stack_path
index|[
name|i
index|]
argument_list|,
name|fn
operator|->
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stack_pathp
operator|=
name|fn
operator|->
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|doing_find
operator|&&
operator|(
operator|!
name|recursive
operator|||
operator|(
name|recursive
operator|&&
name|level
operator|<=
name|input_pathp
operator|)
operator|)
condition|)
block|{
comment|/* 		     * Remove current entry by moving others up. 		     */
name|freemem
argument_list|(
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fnn
operator|=
name|fn
expr_stmt|;
for|for
control|(
name|fnnn
operator|=
name|fnn
operator|,
name|fnn
operator|++
init|;
name|fnn
operator|<=
name|top
condition|;
name|fnnn
operator|=
name|fnn
operator|,
name|fnn
operator|++
control|)
block|{
name|fnnn
operator|->
name|ino
operator|=
name|fnn
operator|->
name|ino
expr_stmt|;
name|fnnn
operator|->
name|len
operator|=
name|fnn
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|fnnn
operator|->
name|len
operator|+
literal|1
operator|<
name|FIRST_DEPTH
condition|)
block|{
name|fnnn
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|FIRST_DEPTH
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fnnn
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fnnn
operator|->
name|len
operator|<
name|SECOND_DEPTH
condition|)
block|{
name|fnnn
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|SECOND_DEPTH
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|fnnn
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"maximum depth exceeded, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"try to cd lower\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|fnn
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|fnnn
operator|->
name|fname
index|[
name|i
index|]
operator|=
name|fnn
operator|->
name|fname
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|fn
operator|==
name|tos
condition|)
name|fn
operator|--
expr_stmt|;
name|top
operator|--
expr_stmt|;
name|bos
operator|--
expr_stmt|;
name|nfiles
operator|--
expr_stmt|;
block|}
name|follow_path
argument_list|(
name|level
operator|+
literal|1
argument_list|,
name|cur_inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * getname - break up the pathname entered by the user into components.  */
end_comment

begin_macro
name|getname
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|input_pathp
operator|++
expr_stmt|;
name|clear
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNAMLEN
condition|;
name|i
operator|++
control|)
name|input_path
index|[
name|input_pathp
index|]
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getachar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|input_path
index|[
name|input_pathp
index|]
argument_list|)
operator|+
literal|1
operator|>=
name|MAXNAMLEN
condition|)
block|{
name|printf
argument_list|(
literal|"maximum name length exceeded, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"truncating\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_path
index|[
name|input_pathp
index|]
index|[
name|strlen
argument_list|(
name|input_path
index|[
name|input_pathp
index|]
argument_list|)
index|]
operator|=
name|c
expr_stmt|;
name|input_path
index|[
name|input_pathp
index|]
index|[
name|strlen
argument_list|(
name|input_path
index|[
name|input_pathp
index|]
argument_list|)
index|]
operator|=
name|getachar
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|doing_find
operator|&&
name|c
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
operator|++
name|input_pathp
operator|>=
name|MAXPATHLEN
condition|)
block|{
name|printf
argument_list|(
literal|"maximum path length exceeded, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"truncating\n"
argument_list|)
expr_stmt|;
name|input_pathp
operator|--
expr_stmt|;
return|return;
block|}
goto|goto
name|clear
goto|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|input_path
index|[
name|input_pathp
index|]
argument_list|)
operator|>=
name|MAXNAMLEN
condition|)
block|{
name|printf
argument_list|(
literal|"maximum name length exceeded, truncating\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_path
index|[
name|input_pathp
index|]
index|[
name|strlen
argument_list|(
name|input_path
index|[
name|input_pathp
index|]
argument_list|)
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * compare - check if a filename matches the pattern entered by the user.  *	Handles '*', '?', and '[]'.  */
end_comment

begin_macro
name|compare
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|at_start
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|at_start
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|s2
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|at_start
operator|&&
name|s
operator|==
name|s2
operator|&&
operator|!
name|letter
argument_list|(
operator|*
name|s2
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
operator|++
name|s1
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|s2
condition|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s2
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|s1
operator|++
expr_stmt|;
goto|goto
name|compare_chars
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
block|{
if|if
condition|(
name|at_start
operator|&&
name|s
operator|==
name|s2
operator|&&
operator|!
name|letter
argument_list|(
operator|*
name|s2
argument_list|)
operator|&&
operator|!
name|digit
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s1
operator|++
expr_stmt|;
name|s2
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s2
operator|>=
operator|*
name|s1
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'-'
condition|)
block|{
name|printf
argument_list|(
literal|"missing '-'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s2
operator|<=
operator|*
name|s1
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|']'
condition|)
block|{
name|printf
argument_list|(
literal|"missing ']'"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s2
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|compare_chars
label|:
if|if
condition|(
operator|*
name|s1
operator|++
operator|==
operator|*
name|s2
operator|++
condition|)
continue|continue;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * freemem - free the memory allocated to the filenames structure.  */
end_comment

begin_macro
name|freemem
argument_list|(
argument|p
argument_list|,
argument|numb
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filenames
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|numb
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numb
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|p
operator|->
name|len
condition|;
name|j
operator|++
control|)
name|free
argument_list|(
name|p
operator|->
name|fname
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * print_path - print the pathname held in p.  */
end_comment

begin_macro
name|print_path
argument_list|(
argument|p
argument_list|,
argument|pntr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|pntr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pntr
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pntr
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s/"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|p
index|[
name|pntr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * fill - fill a section with a value or string.  *	addr,count:fill=[value, "string"].  */
end_comment

begin_macro
name|fill
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|short
name|eof_flag
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|;
name|long
name|temp
decl_stmt|,
name|tcount
decl_stmt|,
name|taddr
decl_stmt|;
if|if
condition|(
operator|!
name|wrtflag
condition|)
block|{
name|printf
argument_list|(
literal|"not opened for write '-w'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|eof_flag
operator|=
literal|0
expr_stmt|;
else|else
name|eof_flag
operator|=
literal|1
expr_stmt|;
name|taddr
operator|=
name|addr
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|LONG
case|:
name|addr
operator|&=
operator|~
operator|(
name|LONG
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|addr
operator|&=
operator|~
operator|(
name|SHORT
operator|-
literal|1
operator|)
expr_stmt|;
name|temp
operator|&=
literal|0177777L
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|temp
operator|&=
literal|0377
expr_stmt|;
block|}
name|cur_bytes
operator|-=
name|taddr
operator|-
name|addr
expr_stmt|;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|tcount
operator|=
name|check_addr
argument_list|(
name|eof_flag
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|eof
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tcount
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|LONG
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|cptr
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
operator|*
operator|(
name|short
operator|*
operator|)
name|cptr
operator|=
name|temp
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
operator|*
name|cptr
operator|=
name|temp
expr_stmt|;
block|}
name|cptr
operator|+=
name|objsz
expr_stmt|;
block|}
name|addr
operator|+=
operator|(
name|tcount
operator|-
literal|1
operator|)
operator|*
name|objsz
expr_stmt|;
name|cur_bytes
operator|+=
operator|(
name|tcount
operator|-
literal|1
operator|)
operator|*
name|objsz
expr_stmt|;
name|put
argument_list|(
name|temp
argument_list|,
name|objsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * get - read a byte, short or long from the file system.  *	The entire block containing the desired item is read  *	and the appropriate data is extracted and returned.  */
end_comment

begin_function
name|long
name|get
parameter_list|(
name|lngth
parameter_list|)
name|short
name|lngth
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|;
name|long
name|temp
init|=
name|addr
decl_stmt|;
name|objsz
operator|=
name|lngth
expr_stmt|;
if|if
condition|(
name|objsz
operator|==
name|INODE
operator|||
name|objsz
operator|==
name|SHORT
condition|)
name|temp
operator|&=
operator|~
operator|(
name|SHORT
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
operator|||
name|objsz
operator|==
name|LONG
condition|)
name|temp
operator|&=
operator|~
operator|(
name|LONG
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bptr
operator|=
name|getblk
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|temp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|CHAR
case|:
return|return
operator|(
operator|(
name|long
operator|)
operator|*
name|bptr
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|INODE
case|:
return|return
operator|(
call|(
name|long
call|)
argument_list|(
operator|*
operator|(
name|short
operator|*
operator|)
name|bptr
argument_list|)
operator|)
return|;
case|case
name|LONG
case|:
case|case
name|DIRECTORY
case|:
return|return
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|bptr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cgrp_check - make sure that we don't bump the cylinder group  *	beyond the total number of cylinder groups or before the start.  */
end_comment

begin_macro
name|cgrp_check
argument_list|(
argument|cgrp
argument_list|)
end_macro

begin_decl_stmt
name|long
name|cgrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cgrp
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|objsz
operator|==
name|CGRP
condition|)
name|printf
argument_list|(
literal|"beginning of cylinder groups\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"beginning of super blocks\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cgrp
operator|>=
name|fs
operator|->
name|fs_ncg
condition|)
block|{
if|if
condition|(
name|objsz
operator|==
name|CGRP
condition|)
name|printf
argument_list|(
literal|"end of cylinder groups\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"end of super blocks\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|objsz
operator|==
name|CGRP
condition|)
return|return
operator|(
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cgrp
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
return|;
else|else
return|return
operator|(
name|cgsblock
argument_list|(
name|fs
argument_list|,
name|cgrp
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * icheck -  make sure we can read the block containing the inode  *	and determine the filesize (0 if inode not allocated).  Return  *	0 if error otherwise return the mode.  */
end_comment

begin_macro
name|icheck
argument_list|(
argument|address
argument_list|)
end_macro

begin_decl_stmt
name|long
name|address
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cptr
decl_stmt|;
specifier|register
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|address
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|override
condition|)
block|{
name|printf
argument_list|(
literal|"inode not allocated\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|blocksize
operator|=
name|filesize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|trapped
operator|++
expr_stmt|;
name|filesize
operator|=
name|ip
operator|->
name|di_size
expr_stmt|;
name|blocksize
operator|=
name|filesize
operator|*
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|ip
operator|->
name|di_mode
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * getdirslot - get the address of the directory slot desired.  */
end_comment

begin_macro
name|getdirslot
argument_list|(
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|short
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cptr
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|short
name|i
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|&
name|scratch
index|[
literal|0
index|]
decl_stmt|;
name|short
name|bod
init|=
literal|0
decl_stmt|,
name|mode
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
name|slot
operator|=
literal|0
expr_stmt|;
name|bod
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|DIRECTORY
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|string
operator|=
literal|"block"
expr_stmt|;
else|else
name|string
operator|=
literal|"fragment"
expr_stmt|;
name|addr
operator|=
name|bod_addr
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|cur_bytes
operator|=
literal|0
expr_stmt|;
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|cptr
expr_stmt|;
for|for
control|(
name|dirslot
operator|=
literal|0
init|;
name|dirslot
operator|<
name|slot
condition|;
name|dirslot
operator|++
control|)
block|{
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
name|blocksize
operator|>
name|filesize
condition|)
block|{
if|if
condition|(
name|cur_bytes
operator|+
name|dirp
operator|->
name|d_reclen
operator|>=
name|filesize
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|stringsize
operator|=
name|STRINGSIZE
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_bytes
operator|+
name|dirp
operator|->
name|d_reclen
operator|>=
name|blocksize
condition|)
block|{
name|printf
argument_list|(
literal|"end of %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|stringsize
operator|=
name|STRINGSIZE
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
name|cptr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|addr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cur_bytes
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
block|}
if|if
condition|(
name|bod
condition|)
block|{
if|if
condition|(
name|blocksize
operator|>
name|filesize
condition|)
name|printf
argument_list|(
literal|"beginning of file\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"beginning of %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
name|stringsize
operator|=
name|STRINGSIZE
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
else|else
block|{
name|addr
operator|=
name|cur_ino
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|override
operator|&&
operator|(
name|mode
operator|&
name|IFDIR
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"inode is not a directory\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|temp
operator|=
name|slot
expr_stmt|;
name|i
operator|=
name|cur_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|bcomp
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
operator|(
name|bmap
argument_list|(
name|i
operator|++
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|cptr
expr_stmt|;
name|value
operator|=
name|dirp
operator|->
name|d_ino
expr_stmt|;
if|if
condition|(
operator|!
name|temp
operator|--
condition|)
break|break;
if|if
condition|(
name|cur_bytes
operator|+
name|dirp
operator|->
name|d_reclen
operator|>=
name|filesize
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|dirslot
operator|=
name|slot
operator|-
name|temp
operator|-
literal|1
expr_stmt|;
name|objsz
operator|=
name|DIRECTORY
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|stringsize
operator|=
name|STRINGSIZE
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
name|addr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cptr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cur_bytes
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
block|}
name|dirslot
operator|=
name|slot
expr_stmt|;
name|objsz
operator|=
name|DIRECTORY
expr_stmt|;
if|if
condition|(
name|bod
condition|)
block|{
name|printf
argument_list|(
literal|"beginning of file\n"
argument_list|)
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
name|stringsize
operator|=
name|STRINGSIZE
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * putf - print a byte as an ascii character if possible.  *	The exceptions are tabs, newlines, backslashes  *	and nulls which are printed as the standard C  *	language escapes. Characters which are not  *	recognized are printed as \?.  */
end_comment

begin_expr_stmt
name|putf
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
operator|<=
literal|037
operator|||
name|c
operator|>=
literal|0177
operator|||
name|c
operator|==
literal|'\\'
condition|)
block|{
name|printf
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|printf
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|printf
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * put - write an item into the buffer for the current address  *	block.  The value is checked to make sure that it will  *	fit in the size given without truncation.  If successful,  *	the entire block is written back to the file system.  */
end_comment

begin_macro
name|put
argument_list|(
argument|item
argument_list|,
argument|lngth
argument_list|)
end_macro

begin_decl_stmt
name|long
name|item
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|lngth
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|,
modifier|*
name|sbptr
decl_stmt|;
specifier|register
name|long
modifier|*
name|vptr
decl_stmt|;
name|off_t
name|s_err
decl_stmt|;
name|long
name|nbytes
decl_stmt|;
name|long
name|olditem
decl_stmt|;
if|if
condition|(
operator|!
name|wrtflag
condition|)
block|{
name|printf
argument_list|(
literal|"not opened for write '-w'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|objsz
operator|=
name|lngth
expr_stmt|;
if|if
condition|(
operator|(
name|sbptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|bptr
operator|=
name|sbptr
operator|+
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|LONG
case|:
case|case
name|DIRECTORY
case|:
name|olditem
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|bptr
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|bptr
operator|=
name|item
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
case|case
name|INODE
case|:
name|olditem
operator|=
operator|(
name|long
operator|)
operator|*
operator|(
name|short
operator|*
operator|)
name|bptr
expr_stmt|;
name|item
operator|&=
literal|0177777L
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|bptr
operator|=
name|item
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|olditem
operator|=
operator|(
name|long
operator|)
operator|*
name|bptr
expr_stmt|;
name|item
operator|&=
literal|0377
expr_stmt|;
operator|*
name|bptr
operator|=
name|lobyte
argument_list|(
name|loword
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|s_err
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|addr
operator|&
name|fs
operator|->
name|fs_bmask
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"seek error : %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nbytes
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|sbptr
argument_list|,
name|BLKSIZE
argument_list|)
operator|)
operator|!=
name|BLKSIZE
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"write error : addr   = %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            : s_err  = %qx\n"
argument_list|,
name|s_err
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            : nbytes = %x\n"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|acting_on_inode
operator|&&
name|objsz
operator|!=
name|INODE
operator|&&
name|objsz
operator|!=
name|DIRECTORY
condition|)
block|{
name|index
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|olditem
argument_list|,
literal|8
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t=\t"
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|item
argument_list|,
literal|8
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
condition|)
block|{
name|addr
operator|=
name|cur_dir
expr_stmt|;
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|cur_ino
expr_stmt|;
name|objsz
operator|=
name|INODE
expr_stmt|;
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_block

begin_comment
comment|/*  * getblk - check if the desired block is in the file system.  *	Search the incore buffers to see if the block is already  *	available. If successful, unlink the buffer control block  *	from its position in the buffer list and re-insert it at  *	the head of the list.  If failure, use the last buffer  *	in the list for the desired block. Again, this control  *	block is placed at the head of the list. This process  *	will leave commonly requested blocks in the in-core buffers.  *	Finally, a pointer to the buffer is returned.  */
end_comment

begin_function
name|char
modifier|*
name|getblk
parameter_list|(
name|address
parameter_list|)
name|long
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|off_t
name|s_err
decl_stmt|;
name|long
name|nbytes
decl_stmt|;
name|unsigned
name|long
name|block
decl_stmt|;
name|read_requests
operator|++
expr_stmt|;
name|block
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|>=
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|fs_size
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"block exceeds maximum block in file system\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|bp
operator|=
name|bhdr
operator|.
name|fwd
init|;
name|bp
operator|!=
operator|&
name|bhdr
condition|;
name|bp
operator|=
name|bp
operator|->
name|fwd
control|)
if|if
condition|(
name|bp
operator|->
name|valid
operator|&&
name|bp
operator|->
name|blkno
operator|==
name|block
condition|)
goto|goto
name|xit
goto|;
name|actual_disk_reads
operator|++
expr_stmt|;
name|bp
operator|=
name|bhdr
operator|.
name|back
expr_stmt|;
name|bp
operator|->
name|blkno
operator|=
name|block
expr_stmt|;
name|bp
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|s_err
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|address
operator|&
name|fs
operator|->
name|fs_bmask
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_err
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"seek error : %x\n"
argument_list|,
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|bp
operator|->
name|blkaddr
argument_list|,
name|BLKSIZE
argument_list|)
operator|)
operator|!=
name|BLKSIZE
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"read error : addr   = %x\n"
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           : s_err  = %qx\n"
argument_list|,
name|s_err
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"           : nbytes = %x\n"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|->
name|valid
operator|++
expr_stmt|;
name|xit
label|:
name|bp
operator|->
name|back
operator|->
name|fwd
operator|=
name|bp
operator|->
name|fwd
expr_stmt|;
name|bp
operator|->
name|fwd
operator|->
name|back
operator|=
name|bp
operator|->
name|back
expr_stmt|;
name|insert
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|blkaddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * insert - place the designated buffer control block  *	at the head of the linked list of buffers.  */
end_comment

begin_expr_stmt
name|insert
argument_list|(
name|bp
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bp
operator|->
name|back
operator|=
operator|&
name|bhdr
expr_stmt|;
name|bp
operator|->
name|fwd
operator|=
name|bhdr
operator|.
name|fwd
expr_stmt|;
name|bhdr
operator|.
name|fwd
operator|->
name|back
operator|=
name|bp
expr_stmt|;
name|bhdr
operator|.
name|fwd
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * err - called on interrupts.  Set the current address  *	back to the last address stored in erraddr. Reset all  *	appropriate flags.  A reset call is made to return  *	to the main loop;  */
end_comment

begin_function
name|void
name|err
parameter_list|()
block|{
name|freemem
argument_list|(
name|filenames
argument_list|,
name|nfiles
argument_list|)
expr_stmt|;
name|nfiles
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
literal|2
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|addr
operator|=
name|erraddr
expr_stmt|;
name|cur_ino
operator|=
name|errino
expr_stmt|;
name|cur_inum
operator|=
name|errinum
expr_stmt|;
name|cur_bytes
operator|=
name|errcur_bytes
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|c_count
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\n?\n"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|stdin
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * devcheck - check that the given mode represents a  *	special device. The IFCHR bit is on for both  *	character and block devices.  */
end_comment

begin_expr_stmt
name|devcheck
argument_list|(
name|md
argument_list|)
specifier|register
name|short
name|md
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|override
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|md
operator|&
name|IFCHR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"not character or block device\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nullblk - return error if address is zero.  This is done  *	to prevent block 0 from being used as an indirect block  *	for a large file or as a data block for a small file.  */
end_comment

begin_macro
name|nullblk
argument_list|(
argument|bn
argument_list|)
end_macro

begin_decl_stmt
name|long
name|bn
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bn
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"non existent block\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * puta - put ascii characters into a buffer.  The string  *	terminates with a quote or newline.  The leading quote,  *	which is optional for directory names, was stripped off  *	by the assignment case in the main loop.  */
end_comment

begin_macro
name|puta
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cptr
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|sbptr
decl_stmt|;
name|short
name|terror
init|=
literal|0
decl_stmt|;
name|long
name|maxchars
decl_stmt|,
name|nbytes
decl_stmt|,
name|temp
decl_stmt|;
name|off_t
name|s_err
decl_stmt|;
name|long
name|taddr
init|=
name|addr
decl_stmt|,
name|tcount
init|=
literal|0
decl_stmt|,
name|item
decl_stmt|,
name|olditem
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|wrtflag
condition|)
block|{
name|printf
argument_list|(
literal|"not opened for write '-w'\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sbptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|cptr
operator|=
name|sbptr
operator|+
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
condition|)
block|{
if|if
condition|(
name|acting_on_directory
condition|)
name|maxchars
operator|=
name|stringsize
operator|-
literal|1
expr_stmt|;
else|else
name|maxchars
operator|=
name|LONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objsz
operator|==
name|INODE
condition|)
name|maxchars
operator|=
name|objsz
operator|-
operator|(
name|addr
operator|-
name|cur_ino
operator|)
expr_stmt|;
else|else
name|maxchars
operator|=
name|min
argument_list|(
name|blocksize
operator|-
name|cur_bytes
argument_list|,
name|filesize
operator|-
name|cur_bytes
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getachar
argument_list|()
operator|)
operator|!=
literal|'"'
condition|)
block|{
if|if
condition|(
name|tcount
operator|>=
name|maxchars
condition|)
block|{
name|printf
argument_list|(
literal|"string too long\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
condition|)
name|addr
operator|=
name|cur_dir
expr_stmt|;
elseif|else
if|if
condition|(
name|acting_on_inode
operator|||
name|objsz
operator|==
name|INODE
condition|)
name|addr
operator|=
name|cur_ino
expr_stmt|;
else|else
name|addr
operator|=
name|taddr
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|terror
operator|++
expr_stmt|;
break|break;
block|}
name|tcount
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|ungetachar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|temp
operator|=
operator|(
name|long
operator|)
operator|*
name|cptr
expr_stmt|;
name|olditem
operator|<<=
name|BITSPERCHAR
expr_stmt|;
name|olditem
operator|+=
name|temp
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
name|getachar
argument_list|()
condition|)
block|{
case|case
literal|'t'
case|:
operator|*
name|cptr
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|cptr
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
operator|*
name|cptr
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
else|else
operator|*
name|cptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
operator|&&
name|acting_on_directory
condition|)
for|for
control|(
name|i
operator|=
name|tcount
init|;
name|i
operator|<=
name|maxchars
condition|;
name|i
operator|++
control|)
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|s_err
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|addr
operator|&
name|fs
operator|->
name|fs_bmask
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"seek error : %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nbytes
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|sbptr
argument_list|,
name|BLKSIZE
argument_list|)
operator|)
operator|!=
name|BLKSIZE
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"write error : addr   = %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            : s_err  = %qx\n"
argument_list|,
name|s_err
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"            : nbytes = %x\n"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|acting_on_inode
operator|&&
name|objsz
operator|!=
name|INODE
operator|&&
name|objsz
operator|!=
name|DIRECTORY
condition|)
block|{
name|addr
operator|+=
name|tcount
expr_stmt|;
name|cur_bytes
operator|+=
name|tcount
expr_stmt|;
name|taddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|objsz
operator|!=
name|CHAR
condition|)
block|{
name|addr
operator|&=
operator|~
operator|(
name|objsz
operator|-
literal|1
operator|)
expr_stmt|;
name|cur_bytes
operator|-=
name|taddr
operator|-
name|addr
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|taddr
condition|)
block|{
name|addr
operator|-=
name|objsz
expr_stmt|;
name|taddr
operator|=
name|addr
expr_stmt|;
block|}
name|tcount
operator|=
name|LONG
operator|-
operator|(
name|taddr
operator|-
name|addr
operator|)
expr_stmt|;
name|index
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|objsz
condition|)
block|{
case|case
name|LONG
case|:
name|item
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
name|tcount
operator|<
name|LONG
condition|)
block|{
name|olditem
operator|<<=
name|tcount
operator|*
name|BITSPERCHAR
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tcount
operator|*
name|BITSPERCHAR
operator|)
condition|;
name|i
operator|++
control|)
name|temp
operator|<<=
literal|1
expr_stmt|;
name|olditem
operator|+=
name|item
operator|&
operator|(
name|temp
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|SHORT
case|:
name|item
operator|=
operator|(
name|long
operator|)
operator|*
operator|(
name|short
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
name|tcount
operator|<
name|SHORT
condition|)
block|{
name|olditem
operator|<<=
name|tcount
operator|*
name|BITSPERCHAR
expr_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|tcount
operator|*
name|BITSPERCHAR
operator|)
condition|;
name|i
operator|++
control|)
name|temp
operator|<<=
literal|1
expr_stmt|;
name|olditem
operator|+=
name|item
operator|&
operator|(
name|temp
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|olditem
operator|&=
literal|0177777L
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|item
operator|=
operator|(
name|long
operator|)
operator|*
name|cptr
expr_stmt|;
name|olditem
operator|&=
literal|0377
expr_stmt|;
block|}
name|print
argument_list|(
name|olditem
argument_list|,
literal|8
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t=\t"
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|item
argument_list|,
literal|8
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|objsz
operator|==
name|DIRECTORY
condition|)
block|{
name|addr
operator|=
name|cur_dir
expr_stmt|;
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|cur_ino
expr_stmt|;
name|objsz
operator|=
name|INODE
expr_stmt|;
name|fprnt
argument_list|(
literal|'?'
argument_list|,
literal|'i'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|terror
condition|)
name|error
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * fprnt - print data.  'count' elements are printed where '*' will  *	print an entire blocks worth or up to the eof, whichever  *	occurs first.  An error will occur if crossing a block boundary  *	is attempted since consecutive blocks don't usually have  *	meaning.  Current print types:  *		/		b   - print as bytes (base sensitive)  *				c   - print as characters  *				o O - print as octal shorts (longs)  *				d D - print as decimal shorts (longs)  *				x X - print as hexadecimal shorts (longs)  *		?		c   - print as cylinder groups  *				d   - print as directories  *				i   - print as inodes  *				s   - print as super blocks  */
end_comment

begin_expr_stmt
name|fprnt
argument_list|(
name|style
argument_list|,
name|po
argument_list|)
specifier|register
name|char
name|style
operator|,
name|po
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|fs
modifier|*
name|sb
decl_stmt|;
specifier|register
name|struct
name|cg
modifier|*
name|cg
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
name|int
name|tbase
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|long
name|tinode
decl_stmt|,
name|tcount
decl_stmt|,
name|temp
decl_stmt|,
name|taddr
decl_stmt|;
name|short
name|offset
decl_stmt|,
name|mode
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|,
name|eof_flag
decl_stmt|;
name|unsigned
name|short
modifier|*
name|sptr
decl_stmt|;
name|unsigned
name|long
modifier|*
name|lptr
decl_stmt|;
name|laststyle
operator|=
name|style
expr_stmt|;
name|lastpo
operator|=
name|po
expr_stmt|;
name|should_print
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|clear
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|star
operator|=
literal|0
expr_stmt|;
name|clear
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|clear
operator|=
literal|1
expr_stmt|;
block|}
name|tcount
operator|=
name|count
expr_stmt|;
name|offset
operator|=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
name|eof_flag
operator|=
literal|0
expr_stmt|;
else|else
name|eof_flag
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|po
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* print as characters */
case|case
literal|'b'
case|:
comment|/* or bytes */
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|cptr
operator|+=
name|offset
expr_stmt|;
name|objsz
operator|=
name|CHAR
expr_stmt|;
name|tcount
operator|=
name|check_addr
argument_list|(
name|eof_flag
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|eof
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tcount
operator|--
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|16
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|po
operator|==
literal|'c'
condition|)
block|{
name|putf
argument_list|(
operator|*
name|cptr
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|16
operator|==
literal|0
condition|)
name|print
argument_list|(
operator|*
name|cptr
operator|++
operator|&
literal|0377
argument_list|,
literal|2
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|print
argument_list|(
operator|*
name|cptr
operator|++
operator|&
literal|0377
argument_list|,
literal|4
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
name|CHAR
expr_stmt|;
name|cur_bytes
operator|+=
name|CHAR
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|addr
operator|-=
name|CHAR
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|-=
name|CHAR
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"end of fragment\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return;
case|case
literal|'o'
case|:
comment|/* print as octal shorts */
name|tbase
operator|=
name|OCTAL
expr_stmt|;
goto|goto
name|otx
goto|;
case|case
literal|'d'
case|:
comment|/* print as decimal shorts */
name|tbase
operator|=
name|DECIMAL
expr_stmt|;
goto|goto
name|otx
goto|;
case|case
literal|'x'
case|:
comment|/* print as hex shorts */
name|tbase
operator|=
name|HEX
expr_stmt|;
name|otx
label|:
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|taddr
operator|=
name|addr
expr_stmt|;
name|addr
operator|&=
operator|~
operator|(
name|SHORT
operator|-
literal|1
operator|)
expr_stmt|;
name|cur_bytes
operator|-=
name|taddr
operator|-
name|addr
expr_stmt|;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|sptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|cptr
expr_stmt|;
name|objsz
operator|=
name|SHORT
expr_stmt|;
name|tcount
operator|=
name|check_addr
argument_list|(
name|eof_flag
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|eof
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tcount
operator|--
condition|;
name|i
operator|++
control|)
block|{
name|sptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|print_check
argument_list|(
name|sptr
argument_list|,
operator|&
name|tcount
argument_list|,
name|tbase
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|po
condition|)
block|{
case|case
literal|'o'
case|:
name|printf
argument_list|(
literal|"%06o "
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|printf
argument_list|(
literal|"%05d  "
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|printf
argument_list|(
literal|"%04x   "
argument_list|,
operator|*
name|sptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
name|SHORT
expr_stmt|;
name|cur_bytes
operator|+=
name|SHORT
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|addr
operator|-=
name|SHORT
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|-=
name|SHORT
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"end of fragment\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return;
case|case
literal|'O'
case|:
comment|/* print as octal longs */
name|tbase
operator|=
name|OCTAL
expr_stmt|;
goto|goto
name|OTX
goto|;
case|case
literal|'D'
case|:
comment|/* print as decimal longs */
name|tbase
operator|=
name|DECIMAL
expr_stmt|;
goto|goto
name|OTX
goto|;
case|case
literal|'X'
case|:
comment|/* print as hex longs */
name|tbase
operator|=
name|HEX
expr_stmt|;
name|OTX
label|:
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|taddr
operator|=
name|addr
expr_stmt|;
name|addr
operator|&=
operator|~
operator|(
name|LONG
operator|-
literal|1
operator|)
expr_stmt|;
name|cur_bytes
operator|-=
name|taddr
operator|-
name|addr
expr_stmt|;
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|lptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|cptr
expr_stmt|;
name|objsz
operator|=
name|LONG
expr_stmt|;
name|tcount
operator|=
name|check_addr
argument_list|(
name|eof_flag
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|eof
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tcount
operator|--
condition|;
name|i
operator|++
control|)
block|{
name|lptr
operator|=
name|print_check
argument_list|(
name|lptr
argument_list|,
operator|&
name|tcount
argument_list|,
name|tbase
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|po
condition|)
block|{
case|case
literal|'O'
case|:
name|printf
argument_list|(
literal|"%011o    "
argument_list|,
operator|*
name|lptr
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|printf
argument_list|(
literal|"%010u     "
argument_list|,
operator|*
name|lptr
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|printf
argument_list|(
literal|"%08x       "
argument_list|,
operator|*
name|lptr
operator|++
argument_list|)
expr_stmt|;
block|}
name|addr
operator|+=
name|LONG
expr_stmt|;
name|cur_bytes
operator|+=
name|LONG
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|addr
operator|-=
name|LONG
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|-=
name|LONG
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"end of fragment\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return;
default|default:
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"no such print option\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
switch|switch
condition|(
name|po
condition|)
block|{
case|case
literal|'c'
case|:
comment|/* print as cylinder group */
if|if
condition|(
name|type
operator|!=
name|NUMB
condition|)
if|if
condition|(
name|cur_cgrp
operator|+
name|count
operator|>
name|fs
operator|->
name|fs_ncg
condition|)
block|{
name|tcount
operator|=
name|fs
operator|->
name|fs_ncg
operator|-
name|cur_cgrp
expr_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
name|end
operator|++
expr_stmt|;
block|}
name|addr
operator|&=
operator|~
operator|(
name|LONG
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
init|;
name|tcount
operator|--
condition|;
control|)
block|{
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NUMB
condition|)
block|{
name|addr
operator|=
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cur_cgrp
argument_list|)
operator|<<
name|FRGSHIFT
expr_stmt|;
name|cur_cgrp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cur_cgrp
condition|)
name|cur_cgrp
operator|--
expr_stmt|;
return|return;
block|}
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|cg
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
block|{
name|cur_cgrp
operator|=
name|cg
operator|->
name|cg_cgx
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|objsz
operator|=
name|CGRP
expr_stmt|;
if|if
condition|(
name|cur_cgrp
operator|+
name|count
operator|-
literal|1
operator|>
name|fs
operator|->
name|fs_ncg
condition|)
block|{
name|tcount
operator|=
name|fs
operator|->
name|fs_ncg
operator|-
name|cur_cgrp
expr_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
name|end
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|override
operator|&&
operator|!
name|cg_chkmagic
argument_list|(
name|cg
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"invalid cylinder group "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"magic word\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_cgrp
condition|)
name|cur_cgrp
operator|--
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|printcg
argument_list|(
name|cg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cur_cgrp
operator|--
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"end of cylinder groups\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return;
case|case
literal|'d'
case|:
comment|/* print as directories */
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
block|{
if|if
condition|(
name|fragoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"address must be at the "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"beginning of a fragment\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
name|bod_addr
operator|=
name|addr
expr_stmt|;
name|type
operator|=
name|FRAGMENT
expr_stmt|;
name|dirslot
operator|=
literal|0
expr_stmt|;
name|cur_bytes
operator|=
literal|0
expr_stmt|;
name|blocksize
operator|=
name|FRGSIZE
expr_stmt|;
name|filesize
operator|=
name|FRGSIZE
operator|*
literal|2
expr_stmt|;
block|}
name|cptr
operator|+=
name|offset
expr_stmt|;
name|objsz
operator|=
name|DIRECTORY
expr_stmt|;
while|while
condition|(
name|tcount
operator|--
operator|&&
name|cur_bytes
operator|<
name|filesize
operator|&&
name|cur_bytes
operator|<
name|blocksize
operator|&&
operator|!
name|bcomp
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|dirp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|cptr
expr_stmt|;
name|tinode
operator|=
name|dirp
operator|->
name|d_ino
expr_stmt|;
name|printf
argument_list|(
literal|"i#: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinode
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"free\t"
argument_list|)
expr_stmt|;
else|else
name|print
argument_list|(
name|tinode
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|addr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cptr
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|cur_bytes
operator|+=
name|dirp
operator|->
name|d_reclen
expr_stmt|;
name|dirslot
operator|++
expr_stmt|;
block|}
name|addr
operator|=
name|erraddr
expr_stmt|;
name|cur_dir
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|=
name|errcur_bytes
expr_stmt|;
name|stringsize
operator|=
name|STRINGSIZE
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|dirslot
operator|--
expr_stmt|;
if|if
condition|(
name|tcount
operator|>=
literal|0
operator|&&
operator|!
name|star
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FRAGMENT
case|:
name|printf
argument_list|(
literal|"end of fragment\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BLOCK
case|:
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"end of directory\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|++
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'i'
case|:
comment|/* print as inodes */
if|if
condition|(
operator|(
name|ip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|addr
operator|<
operator|(
name|cgimin
argument_list|(
name|fs
argument_list|,
name|i
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
condition|)
break|break;
name|i
operator|--
expr_stmt|;
name|offset
operator|/=
name|INODE
expr_stmt|;
name|temp
operator|=
operator|(
name|addr
operator|-
operator|(
name|cgimin
argument_list|(
name|fs
argument_list|,
name|i
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|)
operator|>>
name|FRGSHIFT
expr_stmt|;
name|temp
operator|=
operator|(
name|i
operator|*
name|fs
operator|->
name|fs_ipg
operator|)
operator|+
name|fragstoblks
argument_list|(
name|fs
argument_list|,
name|temp
argument_list|)
operator|*
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|count
operator|+
name|offset
operator|>
name|INOPB
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|tcount
operator|=
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|-
name|offset
expr_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
name|end
operator|++
expr_stmt|;
block|}
name|objsz
operator|=
name|INODE
expr_stmt|;
name|ip
operator|+=
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tcount
operator|--
condition|;
name|ip
operator|++
operator|,
name|temp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mode
operator|=
name|icheck
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|override
condition|)
continue|continue;
name|p
operator|=
literal|" ugtrwxrwxrwx"
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFDIR
case|:
name|c
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|IFCHR
case|:
name|c
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|IFBLK
case|:
name|c
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|IFREG
case|:
name|c
operator|=
literal|'-'
expr_stmt|;
break|break;
case|case
name|IFLNK
case|:
name|c
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
name|IFSOCK
case|:
name|c
operator|=
literal|'s'
expr_stmt|;
break|break;
default|default:
name|c
operator|=
literal|'?'
expr_stmt|;
if|if
condition|(
operator|!
name|override
condition|)
goto|goto
name|empty
goto|;
block|}
name|printf
argument_list|(
literal|"i#: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|temp
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   md: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|mode
operator|<<
literal|4
init|;
operator|*
operator|++
name|p
condition|;
name|mode
operator|=
name|mode
operator|<<
literal|1
control|)
block|{
if|if
condition|(
name|mode
operator|&
name|IFREG
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  uid: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_uid
argument_list|,
literal|8
argument_list|,
operator|-
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      gid: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_gid
argument_list|,
literal|8
argument_list|,
operator|-
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ln: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_nlink
argument_list|,
literal|8
argument_list|,
operator|-
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       bs: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_blocks
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   sz : "
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|(
name|int
operator|)
name|ip
operator|->
name|di_size
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|di_mode
operator|&
name|IFCHR
condition|)
block|{
name|printf
argument_list|(
literal|"maj: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_db
index|[
literal|1
index|]
operator|&
literal|0377
argument_list|,
literal|4
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  min: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_db
index|[
literal|0
index|]
operator|&
literal|0377
argument_list|,
literal|4
argument_list|,
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
condition|;
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|di_db
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"db#%x: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_db
index|[
name|i
index|]
argument_list|,
literal|11
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
literal|4
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|di_ib
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"ib#%x: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|ip
operator|->
name|di_ib
index|[
name|i
index|]
argument_list|,
literal|11
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\taccessed: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|ip
operator|->
name|di_atime
operator|.
name|ts_sec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmodified: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|ip
operator|->
name|di_mtime
operator|.
name|ts_sec
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcreated : %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|ip
operator|->
name|di_ctime
operator|.
name|ts_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcount
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|empty
label|:
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
operator|!
name|override
condition|)
block|{
name|printf
argument_list|(
literal|"i#: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|temp
argument_list|,
literal|12
argument_list|,
operator|-
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  is unallocated\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cur_ino
operator|=
name|erraddr
operator|=
name|addr
expr_stmt|;
name|errcur_bytes
operator|=
name|cur_bytes
expr_stmt|;
name|cur_inum
operator|++
expr_stmt|;
name|addr
operator|=
name|addr
operator|+
name|INODE
expr_stmt|;
block|}
name|addr
operator|=
name|erraddr
expr_stmt|;
name|cur_bytes
operator|=
name|errcur_bytes
expr_stmt|;
name|cur_inum
operator|--
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return;
case|case
literal|'s'
case|:
comment|/* print as super block */
if|if
condition|(
name|cur_cgrp
operator|==
operator|-
literal|1
condition|)
block|{
name|addr
operator|=
name|SBLOCK
operator|*
name|DEV_BSIZE
expr_stmt|;
name|type
operator|=
name|NUMB
expr_stmt|;
block|}
name|addr
operator|&=
operator|~
operator|(
name|LONG
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NUMB
condition|)
if|if
condition|(
name|cur_cgrp
operator|+
name|count
operator|>
name|fs
operator|->
name|fs_ncg
condition|)
block|{
name|tcount
operator|=
name|fs
operator|->
name|fs_ncg
operator|-
name|cur_cgrp
expr_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
name|end
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|tcount
operator|--
condition|;
control|)
block|{
name|erraddr
operator|=
name|addr
expr_stmt|;
name|cur_bytes
operator|=
name|errcur_bytes
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NUMB
condition|)
block|{
name|addr
operator|=
name|cgsblock
argument_list|(
name|fs
argument_list|,
name|cur_cgrp
argument_list|)
operator|<<
name|FRGSHIFT
expr_stmt|;
name|cur_cgrp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cptr
operator|=
name|getblk
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cur_cgrp
condition|)
name|cur_cgrp
operator|--
expr_stmt|;
return|return;
block|}
name|cptr
operator|+=
name|blkoff
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|(
expr|struct
name|fs
operator|*
operator|)
name|cptr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NUMB
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|addr
operator|==
name|cgsblock
argument_list|(
name|fs
argument_list|,
name|i
argument_list|)
operator|<<
name|FRGSHIFT
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|fs
operator|->
name|fs_ncg
condition|)
name|cur_cgrp
operator|=
literal|0
expr_stmt|;
else|else
name|cur_cgrp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|objsz
operator|=
name|SB
expr_stmt|;
if|if
condition|(
name|cur_cgrp
operator|+
name|count
operator|-
literal|1
operator|>
name|fs
operator|->
name|fs_ncg
condition|)
block|{
name|tcount
operator|=
name|fs
operator|->
name|fs_ncg
operator|-
name|cur_cgrp
expr_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
name|end
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sb
operator|->
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|cur_cgrp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|override
condition|)
block|{
name|printf
argument_list|(
literal|"invalid super block "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"magic word\n"
argument_list|)
expr_stmt|;
name|cur_cgrp
operator|--
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|cur_cgrp
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tsuper block:\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\tsuper block in cylinder "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"group "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|cur_cgrp
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
block|}
name|printsb
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcount
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|cur_cgrp
operator|--
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
name|printf
argument_list|(
literal|"end of super blocks\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
block|}
return|return;
default|default:
name|error
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"no such print option\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * valid_addr - call check_addr to validate the current address.  */
end_comment

begin_macro
name|valid_addr
argument_list|()
end_macro

begin_block
block|{
name|short
name|eof_flag
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|;
name|long
name|tcount
init|=
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|trapped
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cur_bytes
operator|<
literal|0
condition|)
block|{
name|cur_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blocksize
operator|>
name|filesize
condition|)
block|{
name|printf
argument_list|(
literal|"beginning of file\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|printf
argument_list|(
literal|"beginning of block\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"beginning of fragment\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|1
expr_stmt|;
name|check_addr
argument_list|(
literal|1
argument_list|,
operator|&
name|end
argument_list|,
operator|&
name|eof
argument_list|,
operator|(
name|filesize
operator|<
name|blocksize
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|tcount
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|end
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|erraddr
operator|>
name|addr
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|printf
argument_list|(
literal|"beginning of block\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"beginning of fragment\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BLOCK
condition|)
name|printf
argument_list|(
literal|"end of block\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"end of fragment\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * check_addr - check if the address crosses the end of block or  *	end of file.  Return the proper count.  */
end_comment

begin_macro
name|check_addr
argument_list|(
argument|eof_flag
argument_list|,
argument|end
argument_list|,
argument|eof
argument_list|,
argument|keep_on
argument_list|)
end_macro

begin_decl_stmt
name|short
name|eof_flag
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|eof
decl_stmt|,
name|keep_on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|temp
decl_stmt|,
name|tcount
init|=
name|count
decl_stmt|,
name|taddr
init|=
name|addr
decl_stmt|,
name|tcur_bytes
init|=
name|cur_bytes
decl_stmt|;
if|if
condition|(
name|bcomp
argument_list|(
name|addr
operator|+
name|count
operator|*
name|objsz
operator|-
literal|1
argument_list|)
operator|||
operator|(
name|keep_on
operator|&&
name|taddr
operator|<
operator|(
name|bmap
argument_list|(
name|cur_block
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|taddr
expr_stmt|;
name|cur_bytes
operator|=
name|tcur_bytes
expr_stmt|;
if|if
condition|(
name|keep_on
condition|)
block|{
if|if
condition|(
name|addr
operator|<
name|erraddr
condition|)
block|{
if|if
condition|(
name|cur_bytes
operator|<
literal|0
condition|)
block|{
operator|(
operator|*
name|end
operator|)
operator|=
literal|2
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|cur_block
operator|-
name|lblkno
argument_list|(
name|fs
argument_list|,
name|cur_bytes
argument_list|)
expr_stmt|;
name|cur_block
operator|-=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|bmap
argument_list|(
name|cur_block
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|==
literal|0
condition|)
block|{
name|cur_block
operator|+=
name|temp
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|tcur_bytes
operator|-
name|cur_bytes
expr_stmt|;
name|addr
operator|+=
name|temp
expr_stmt|;
name|cur_bytes
operator|+=
name|temp
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|cur_bytes
operator|>=
name|filesize
condition|)
block|{
operator|(
operator|*
name|eof
operator|)
operator|++
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|lblkno
argument_list|(
name|fs
argument_list|,
name|cur_bytes
argument_list|)
operator|-
name|cur_block
expr_stmt|;
name|cur_block
operator|+=
name|temp
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|=
name|bmap
argument_list|(
name|cur_block
argument_list|)
operator|<<
name|FRGSHIFT
operator|)
operator|==
literal|0
condition|)
block|{
name|cur_block
operator|-=
name|temp
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|tcur_bytes
operator|-
name|cur_bytes
expr_stmt|;
name|addr
operator|+=
name|temp
expr_stmt|;
name|cur_bytes
operator|+=
name|temp
expr_stmt|;
return|return;
block|}
block|}
name|tcount
operator|=
operator|(
name|blkroundup
argument_list|(
name|fs
argument_list|,
name|addr
operator|+
literal|1
argument_list|)
operator|-
name|addr
operator|)
operator|/
name|objsz
expr_stmt|;
if|if
condition|(
operator|!
name|star
condition|)
operator|(
operator|*
name|end
operator|)
operator|=
literal|2
expr_stmt|;
block|}
name|addr
operator|=
name|taddr
expr_stmt|;
name|cur_bytes
operator|=
name|tcur_bytes
expr_stmt|;
if|if
condition|(
name|eof_flag
condition|)
block|{
if|if
condition|(
name|blocksize
operator|>
name|filesize
condition|)
block|{
if|if
condition|(
name|cur_bytes
operator|>=
name|filesize
condition|)
block|{
name|tcount
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|eof
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcount
operator|>
operator|(
name|filesize
operator|-
name|cur_bytes
operator|)
operator|/
name|objsz
condition|)
block|{
name|tcount
operator|=
operator|(
name|filesize
operator|-
name|cur_bytes
operator|)
operator|/
name|objsz
expr_stmt|;
if|if
condition|(
operator|!
name|star
operator|||
name|tcount
operator|==
literal|0
condition|)
operator|(
operator|*
name|eof
operator|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cur_bytes
operator|>=
name|blocksize
condition|)
block|{
name|tcount
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|end
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tcount
operator|>
operator|(
name|blocksize
operator|-
name|cur_bytes
operator|)
operator|/
name|objsz
condition|)
block|{
name|tcount
operator|=
operator|(
name|blocksize
operator|-
name|cur_bytes
operator|)
operator|/
name|objsz
expr_stmt|;
if|if
condition|(
operator|!
name|star
operator|||
name|tcount
operator|==
literal|0
condition|)
operator|(
operator|*
name|end
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|tcount
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * print_check - check if the index needs to be printed and delete  *	rows of zeros from the output.  */
end_comment

begin_function
name|unsigned
name|long
modifier|*
name|print_check
parameter_list|(
name|lptr
parameter_list|,
name|tcount
parameter_list|,
name|tbase
parameter_list|,
name|i
parameter_list|)
name|unsigned
name|long
modifier|*
name|lptr
decl_stmt|;
name|long
modifier|*
name|tcount
decl_stmt|;
name|short
name|tbase
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|temp
init|=
name|BYTESPERLINE
operator|/
name|objsz
decl_stmt|;
name|short
name|first_time
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
modifier|*
name|tlptr
decl_stmt|;
name|unsigned
name|short
modifier|*
name|tsptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|;
name|sptr
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|lptr
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|first_time
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|%
name|temp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|tcount
operator|>=
name|temp
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|objsz
operator|==
name|SHORT
condition|)
name|tsptr
operator|=
name|sptr
expr_stmt|;
else|else
name|tlptr
operator|=
name|lptr
expr_stmt|;
name|k
operator|=
operator|*
name|tcount
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|k
operator|--
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|objsz
operator|==
name|SHORT
condition|)
block|{
if|if
condition|(
operator|*
name|tsptr
operator|++
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|tlptr
operator|++
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
operator|(
name|i
operator|+
name|temp
operator|-
literal|1
operator|)
condition|)
block|{
name|j
operator|=
operator|(
name|j
operator|-
name|i
operator|)
operator|/
name|temp
expr_stmt|;
while|while
condition|(
name|j
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|objsz
operator|==
name|SHORT
condition|)
name|sptr
operator|+=
name|temp
expr_stmt|;
else|else
name|lptr
operator|+=
name|temp
expr_stmt|;
operator|*
name|tcount
operator|-=
name|temp
expr_stmt|;
name|i
operator|+=
name|temp
expr_stmt|;
name|addr
operator|+=
name|BYTESPERLINE
expr_stmt|;
name|cur_bytes
operator|+=
name|BYTESPERLINE
expr_stmt|;
block|}
if|if
condition|(
name|first_time
condition|)
name|printf
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n*"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|tbase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|index
argument_list|(
name|tbase
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objsz
operator|==
name|SHORT
condition|)
return|return
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|sptr
operator|)
return|;
else|else
return|return
operator|(
name|lptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * index - print a byte index for the printout in base b  *	with leading zeros.  */
end_comment

begin_macro
name|index
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|tbase
init|=
name|base
decl_stmt|;
name|base
operator|=
name|b
expr_stmt|;
name|print
argument_list|(
name|addr
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\t"
argument_list|)
expr_stmt|;
name|base
operator|=
name|tbase
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * print - print out the value to digits places with/without  *	leading zeros and right/left justified in the current base.  */
end_comment

begin_macro
name|print
argument_list|(
argument|value
argument_list|,
argument|fieldsz
argument_list|,
argument|digits
argument_list|,
argument|lead
argument_list|)
end_macro

begin_decl_stmt
name|int
name|value
decl_stmt|,
name|fieldsz
decl_stmt|,
name|digits
decl_stmt|,
name|lead
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|left
init|=
literal|0
decl_stmt|;
name|char
name|mode
init|=
name|BASE
index|[
name|base
operator|-
name|OCTAL
index|]
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|&
name|scratch
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|digits
operator|<
literal|0
condition|)
block|{
name|left
operator|=
literal|1
expr_stmt|;
name|digits
operator|*=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|!=
name|HEX
condition|)
if|if
condition|(
name|digits
condition|)
name|digits
operator|=
name|digits
operator|+
operator|(
name|digits
operator|-
literal|1
operator|)
operator|/
operator|(
operator|(
name|base
operator|>>
literal|1
operator|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
else|else
name|digits
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lead
condition|)
block|{
if|if
condition|(
name|left
condition|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%%%c%d%d.%d%c"
argument_list|,
literal|'-'
argument_list|,
literal|0
argument_list|,
name|digits
argument_list|,
name|lead
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%%%d%d.%d%c"
argument_list|,
literal|0
argument_list|,
name|digits
argument_list|,
name|lead
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|left
condition|)
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%%%c%d%c"
argument_list|,
literal|'-'
argument_list|,
name|digits
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%%%d%c"
argument_list|,
name|digits
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
name|string
argument_list|,
name|value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fieldsz
operator|-
name|digits
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print out the contents of a superblock.  */
end_comment

begin_macro
name|printsb
argument_list|(
argument|fs
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
if|if
condition|(
name|fs
operator|->
name|fs_postblformat
operator|==
name|FS_42POSTBLFMT
condition|)
name|fs
operator|->
name|fs_nrpos
operator|=
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"magic\t%x\tformat\t%s\ttime\t%s"
argument_list|,
name|fs
operator|->
name|fs_magic
argument_list|,
name|fs
operator|->
name|fs_postblformat
operator|==
name|FS_42POSTBLFMT
condition|?
literal|"static"
else|:
literal|"dynamic"
argument_list|,
name|ctime
argument_list|(
operator|&
name|fs
operator|->
name|fs_time
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"magic\t%x\ttime\t%s"
argument_list|,
name|fs
operator|->
name|fs_magic
argument_list|,
name|ctime
argument_list|(
operator|&
name|fs
operator|->
name|fs_time
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"nbfree\t%d\tndir\t%d\tnifree\t%d\tnffree\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
argument_list|,
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_ndir
argument_list|,
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
argument_list|,
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ncg\t%d\tncyl\t%d\tsize\t%d\tblocks\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_ncg
argument_list|,
name|fs
operator|->
name|fs_ncyl
argument_list|,
name|fs
operator|->
name|fs_size
argument_list|,
name|fs
operator|->
name|fs_dsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bsize\t%d\tshift\t%d\tmask\t0x%08x\n"
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|fs
operator|->
name|fs_bshift
argument_list|,
name|fs
operator|->
name|fs_bmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fsize\t%d\tshift\t%d\tmask\t0x%08x\n"
argument_list|,
name|fs
operator|->
name|fs_fsize
argument_list|,
name|fs
operator|->
name|fs_fshift
argument_list|,
name|fs
operator|->
name|fs_fmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frag\t%d\tshift\t%d\tfsbtodb\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_frag
argument_list|,
name|fs
operator|->
name|fs_fragshift
argument_list|,
name|fs
operator|->
name|fs_fsbtodb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cpg\t%d\tbpg\t%d\tfpg\t%d\tipg\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_cpg
argument_list|,
name|fs
operator|->
name|fs_fpg
operator|/
name|fs
operator|->
name|fs_frag
argument_list|,
name|fs
operator|->
name|fs_fpg
argument_list|,
name|fs
operator|->
name|fs_ipg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"minfree\t%d%%\toptim\t%s\tmaxcontig %d\tmaxbpg\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_minfree
argument_list|,
name|fs
operator|->
name|fs_optim
operator|==
name|FS_OPTSPACE
condition|?
literal|"space"
else|:
literal|"time"
argument_list|,
name|fs
operator|->
name|fs_maxcontig
argument_list|,
name|fs
operator|->
name|fs_maxbpg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
name|printf
argument_list|(
literal|"rotdelay %dms\theadswitch %dus\ttrackseek %dus\trps\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_rotdelay
argument_list|,
name|fs
operator|->
name|fs_headswitch
argument_list|,
name|fs
operator|->
name|fs_trkseek
argument_list|,
name|fs
operator|->
name|fs_rps
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ntrak\t%d\tnsect\t%d\tnpsect\t%d\tspc\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_ntrak
argument_list|,
name|fs
operator|->
name|fs_nsect
argument_list|,
name|fs
operator|->
name|fs_npsect
argument_list|,
name|fs
operator|->
name|fs_spc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"trackskew %d\tinterleave %d\n"
argument_list|,
name|fs
operator|->
name|fs_trackskew
argument_list|,
name|fs
operator|->
name|fs_interleave
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"rotdelay %dms\trps\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_rotdelay
argument_list|,
name|fs
operator|->
name|fs_rps
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ntrak\t%d\tnsect\t%d\tspc\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_ntrak
argument_list|,
name|fs
operator|->
name|fs_nsect
argument_list|,
name|fs
operator|->
name|fs_spc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"nindir\t%d\tinopb\t%d\tnspf\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_nindir
argument_list|,
name|fs
operator|->
name|fs_inopb
argument_list|,
name|fs
operator|->
name|fs_nspf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sblkno\t%d\tcblkno\t%d\tiblkno\t%d\tdblkno\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_sblkno
argument_list|,
name|fs
operator|->
name|fs_cblkno
argument_list|,
name|fs
operator|->
name|fs_iblkno
argument_list|,
name|fs
operator|->
name|fs_dblkno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbsize\t%d\tcgsize\t%d\tcgoffset %d\tcgmask\t0x%08x\n"
argument_list|,
name|fs
operator|->
name|fs_sbsize
argument_list|,
name|fs
operator|->
name|fs_cgsize
argument_list|,
name|fs
operator|->
name|fs_cgoffset
argument_list|,
name|fs
operator|->
name|fs_cgmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"csaddr\t%d\tcssize\t%d\tshift\t%d\tmask\t0x%08x\n"
argument_list|,
name|fs
operator|->
name|fs_csaddr
argument_list|,
name|fs
operator|->
name|fs_cssize
argument_list|,
name|fs
operator|->
name|fs_csshift
argument_list|,
name|fs
operator|->
name|fs_csmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cgrotor\t%d\tfmod\t%d\tronly\t%d\n"
argument_list|,
name|fs
operator|->
name|fs_cgrotor
argument_list|,
name|fs
operator|->
name|fs_fmod
argument_list|,
name|fs
operator|->
name|fs_ronly
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
if|if
condition|(
name|fs
operator|->
name|fs_cpc
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"blocks available in each of %d rotational positions"
argument_list|,
name|fs
operator|->
name|fs_nrpos
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"insufficient space to maintain rotational tables\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|fs
operator|->
name|fs_cpc
condition|;
name|c
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\ncylinder number %d:"
argument_list|,
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_nrpos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fs_postbl
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\n   position %d:\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|fs_postbl
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
index|[
name|i
index|]
operator|,
name|k
operator|=
literal|1
init|;
condition|;
name|j
operator|+=
name|fs_rotbl
argument_list|(
name|fs
argument_list|)
index|[
name|j
index|]
operator|,
name|k
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|%
literal|12
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n\t\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_rotbl
argument_list|(
name|fs
argument_list|)
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
block|}
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRPOS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_postbl
index|[
name|c
index|]
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\n   position %d:\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|fs
operator|->
name|fs_postbl
index|[
name|c
index|]
index|[
name|i
index|]
operator|,
name|k
operator|=
literal|1
init|;
condition|;
name|j
operator|+=
name|fs
operator|->
name|fs_rotbl
index|[
name|j
index|]
operator|,
name|k
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|%
literal|12
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n\t\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_rotbl
index|[
name|j
index|]
operator|==
literal|0
condition|)
break|break;
block|}
block|}
endif|#
directive|endif
block|}
name|printf
argument_list|(
literal|"\ncs[].cs_(nbfree, ndir, nifree, nffree):\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_cssize
condition|;
name|i
operator|+=
name|fs
operator|->
name|fs_bsize
operator|,
name|j
operator|++
control|)
block|{
name|size
operator|=
name|fs
operator|->
name|fs_cssize
operator|-
name|i
operator|<
name|fs
operator|->
name|fs_bsize
condition|?
name|fs
operator|->
name|fs_cssize
operator|-
name|i
else|:
name|fs
operator|->
name|fs_bsize
expr_stmt|;
name|fs
operator|->
name|fs_csp
index|[
name|j
index|]
operator|=
operator|(
expr|struct
name|csum
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
operator|(
name|fs
operator|->
name|fs_csaddr
operator|+
name|j
operator|*
name|fs
operator|->
name|fs_frag
operator|)
argument_list|)
operator|*
name|fs
operator|->
name|fs_fsize
operator|/
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|fs
operator|->
name|fs_csp
index|[
name|j
index|]
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
for|for
control|(
name|j
operator|--
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|free
argument_list|(
name|fs
operator|->
name|fs_csp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_ncg
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|csum
modifier|*
name|cs
init|=
operator|&
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|&&
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%d,%d,%d,%d) "
argument_list|,
name|cs
operator|->
name|cs_nbfree
argument_list|,
name|cs
operator|->
name|cs_ndir
argument_list|,
name|cs
operator|->
name|cs_nifree
argument_list|,
name|cs
operator|->
name|cs_nffree
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|--
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|free
argument_list|(
name|fs
operator|->
name|fs_csp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_ncyl
operator|%
name|fs
operator|->
name|fs_cpg
condition|)
block|{
name|printf
argument_list|(
literal|"cylinders in last group %d\n"
argument_list|,
name|i
operator|=
name|fs
operator|->
name|fs_ncyl
operator|%
name|fs
operator|->
name|fs_cpg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"blocks in last group %d\n"
argument_list|,
name|i
operator|*
name|fs
operator|->
name|fs_spc
operator|/
name|NSPB
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print out the contents of a cylinder group.  */
end_comment

begin_macro
name|printcg
argument_list|(
argument|cg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|cg
modifier|*
name|cg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|printf
argument_list|(
literal|"\ncg %d:\n"
argument_list|,
name|cg
operator|->
name|cg_cgx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
name|printf
argument_list|(
literal|"magic\t%x\ttell\t%x\ttime\t%s"
argument_list|,
name|fs
operator|->
name|fs_postblformat
operator|==
name|FS_42POSTBLFMT
condition|?
operator|(
operator|(
expr|struct
name|ocg
operator|*
operator|)
name|cg
operator|)
operator|->
name|cg_magic
else|:
name|cg
operator|->
name|cg_magic
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
operator|->
name|cg_cgx
argument_list|)
argument_list|)
operator|*
name|fs
operator|->
name|fs_fsize
operator|/
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|cg
operator|->
name|cg_time
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"magic\t%x\ttell\t%x\ttime\t%s"
argument_list|,
name|cg
operator|->
name|cg_magic
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
operator|->
name|cg_cgx
argument_list|)
argument_list|)
operator|*
name|fs
operator|->
name|fs_fsize
operator|/
name|fsbtodb
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|cg
operator|->
name|cg_time
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"cgx\t%d\tncyl\t%d\tniblk\t%d\tndblk\t%d\n"
argument_list|,
name|cg
operator|->
name|cg_cgx
argument_list|,
name|cg
operator|->
name|cg_ncyl
argument_list|,
name|cg
operator|->
name|cg_niblk
argument_list|,
name|cg
operator|->
name|cg_ndblk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nbfree\t%d\tndir\t%d\tnifree\t%d\tnffree\t%d\n"
argument_list|,
name|cg
operator|->
name|cg_cs
operator|.
name|cs_nbfree
argument_list|,
name|cg
operator|->
name|cg_cs
operator|.
name|cs_ndir
argument_list|,
name|cg
operator|->
name|cg_cs
operator|.
name|cs_nifree
argument_list|,
name|cg
operator|->
name|cg_cs
operator|.
name|cs_nffree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rotor\t%d\tirotor\t%d\tfrotor\t%d\nfrsum"
argument_list|,
name|cg
operator|->
name|cg_rotor
argument_list|,
name|cg
operator|->
name|cg_irotor
argument_list|,
name|cg
operator|->
name|cg_frotor
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_frag
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|cg
operator|->
name|cg_frsum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|j
operator|+=
name|i
operator|*
name|cg
operator|->
name|cg_frsum
index|[
name|i
index|]
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nsum of frsum: %d\niused:\t"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|pbits
argument_list|(
name|cg_inosused
argument_list|(
name|cg
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_ipg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"free:\t"
argument_list|)
expr_stmt|;
name|pbits
argument_list|(
name|cg_blksfree
argument_list|(
name|cg
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_fpg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"b:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|fs_cpg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cg_blktot
argument_list|(
name|cg
argument_list|)
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"   c%d:\t(%d)\t"
argument_list|,
name|i
argument_list|,
name|cg_blktot
argument_list|(
name|cg
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FS_42POSTBLFMT
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fs
operator|->
name|fs_nrpos
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_cpc
operator|==
literal|0
operator|||
name|fs_postbl
argument_list|(
name|fs
argument_list|,
name|i
operator|%
name|fs
operator|->
name|fs_cpc
argument_list|)
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|cg_blks
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|,
name|i
argument_list|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NRPOS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|fs
operator|->
name|fs_cpc
operator|==
literal|0
operator|||
name|fs
operator|->
name|fs_postbl
index|[
name|i
operator|%
name|fs
operator|->
name|fs_cpc
index|]
index|[
name|j
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|cg
operator|->
name|cg_b
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print out the contents of a bit array.  */
end_comment

begin_expr_stmt
name|pbits
argument_list|(
name|cp
argument_list|,
name|max
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|max
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isset
argument_list|(
name|cp
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|",%s"
argument_list|,
name|count
operator|%
literal|6
condition|?
literal|" "
else|:
literal|"\n\t"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|max
operator|&&
name|isset
argument_list|(
name|cp
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|printf
argument_list|(
literal|"-%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * bcomp - used to check for block over/under flows when stepping through  *	a file system.  */
end_comment

begin_macro
name|bcomp
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|long
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|override
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lblkno
argument_list|(
name|fs
argument_list|,
name|addr
argument_list|)
operator|==
operator|(
name|bhdr
operator|.
name|fwd
operator|)
operator|->
name|blkno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * bmap - maps the logical block number of a file into  *	the corresponding physical block on the file  *	system.  */
end_comment

begin_function
name|long
name|bmap
parameter_list|(
name|bn
parameter_list|)
name|long
name|bn
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
name|int
name|sh
decl_stmt|;
name|long
name|nb
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|cur_ino
expr_stmt|;
if|if
condition|(
name|bn
operator|<
name|NDADDR
condition|)
block|{
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
name|ip
operator|->
name|di_db
index|[
name|bn
index|]
expr_stmt|;
name|cur_bytes
operator|=
name|bn
operator|*
name|BLKSIZE
expr_stmt|;
return|return
operator|(
name|nullblk
argument_list|(
name|nb
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
argument_list|)
condition|?
literal|0L
else|:
name|nb
operator|)
return|;
block|}
name|sh
operator|=
literal|1
expr_stmt|;
name|bn
operator|-=
name|NDADDR
expr_stmt|;
for|for
control|(
name|j
operator|=
name|NIADDR
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|sh
operator|*=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|<
name|sh
condition|)
break|break;
name|bn
operator|-=
name|sh
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"file too big\n"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
return|return
operator|(
literal|0L
operator|)
return|;
block|}
name|addr
operator|=
operator|(
name|long
operator|)
operator|&
name|ip
operator|->
name|di_ib
index|[
name|NIADDR
operator|-
name|j
index|]
expr_stmt|;
name|nb
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|==
literal|0
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
for|for
control|(
init|;
name|j
operator|<=
name|NIADDR
condition|;
name|j
operator|++
control|)
block|{
name|sh
operator|/=
name|NINDIR
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|nb
operator|<<
name|FRGSHIFT
operator|)
operator|+
operator|(
operator|(
name|bn
operator|/
name|sh
operator|)
operator|%
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|)
operator|*
name|LONG
expr_stmt|;
if|if
condition|(
name|nullblk
argument_list|(
name|nb
operator|=
name|get
argument_list|(
name|LONG
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0L
operator|)
return|;
block|}
return|return
operator|(
name|nb
operator|)
return|;
block|}
end_function

end_unit

