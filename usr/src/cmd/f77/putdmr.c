begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  INTERMEDIATE CODE GENERATION FOR D. M. RITCHIE C COMPILERS */
end_comment

begin_if
if|#
directive|if
name|FAMILY
operator|!=
name|DMR
end_if

begin_expr_stmt
name|WRONG
name|put
name|FILE
operator|!
operator|!
operator|!
operator|!
endif|#
directive|endif
include|#
directive|include
file|"defs"
include|#
directive|include
file|"dmrdefs"
specifier|extern
name|int
name|ops2
index|[]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|types2
index|[]
decl_stmt|;
end_decl_stmt

begin_macro
name|puthead
argument_list|(
argument|s
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
name|p2op2
argument_list|(
name|P2SETREG
argument_list|,
name|ARGREG
operator|-
name|maxregvar
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2PROG
argument_list|)
expr_stmt|;
name|headerdone
operator|=
name|YES
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
comment|/* fake jump to start the optimizer */
if|if
condition|(
name|class
operator|!=
name|CLBLOCK
condition|)
name|putgoto
argument_list|(
name|fudgelabel
operator|=
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|putnreg
argument_list|()
end_macro

begin_block
block|{
name|p2op2
argument_list|(
name|P2SETREG
argument_list|,
name|ARGREG
operator|-
name|nregvar
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|puteof
argument_list|()
end_macro

begin_block
block|{
name|p2op
argument_list|(
name|P2EOF
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putstmt
argument_list|()
end_macro

begin_block
block|{
name|p2op2
argument_list|(
name|P2EXPR
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* put out code for if( ! p) goto l  */
end_comment

begin_expr_stmt
name|putif
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
operator|(
name|p
operator|=
name|fixtype
argument_list|(
name|p
argument_list|)
operator|)
operator|->
name|vtype
operator|)
operator|!=
name|TYLOGICAL
condition|)
block|{
if|if
condition|(
name|k
operator|!=
name|TYERROR
condition|)
name|err
argument_list|(
literal|"non-logical expression in IF statement"
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2CBRANCH
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* put out code for  goto l   */
end_comment

begin_macro
name|putgoto
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op2
argument_list|(
name|P2GOTO
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* branch to address constant or integer variable */
end_comment

begin_expr_stmt
name|putbranch
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|addrblock
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|type
decl_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|fatal
argument_list|(
literal|"invalid goto label"
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|p
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TYINT
condition|)
name|p2op2
argument_list|(
name|P2LTOI
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2INDIRECT
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2JUMP
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* put out label  l:     */
end_comment

begin_macro
name|putlabel
argument_list|(
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|int
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op2
argument_list|(
name|P2LABEL
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putexpr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putex1
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|prarif
argument_list|(
argument|p
argument_list|,
argument|neg
argument_list|,
argument|zero
argument_list|,
argument|pos
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|neg
decl_stmt|,
name|zero
decl_stmt|,
name|pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2ARIF
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|neg
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|zero
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putcmgo
argument_list|(
argument|index
argument_list|,
argument|nlab
argument_list|,
argument|labs
argument_list|)
end_macro

begin_decl_stmt
name|expptr
name|index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|labelblock
modifier|*
name|labs
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|skiplabel
decl_stmt|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|index
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|execerr
argument_list|(
literal|"computed goto index must be integer"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|putforce
argument_list|(
name|TYINT
argument_list|,
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|P2SWITCH
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|skiplabel
operator|=
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlab
condition|;
operator|++
name|i
control|)
block|{
name|p2i
argument_list|(
name|labs
index|[
name|i
index|]
operator|->
name|labelno
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|p2i
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putlabel
argument_list|(
name|skiplabel
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_expr_stmt
name|putx
argument_list|(
name|p
argument_list|)
specifier|register
name|expptr
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|addrblock
modifier|*
name|putcall
argument_list|()
decl_stmt|,
modifier|*
name|putcx1
argument_list|()
decl_stmt|,
modifier|*
name|realpart
argument_list|()
decl_stmt|;
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|int
name|opc
decl_stmt|;
name|int
name|type
decl_stmt|,
name|ncomma
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TERROR
case|:
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCONST
case|:
switch|switch
condition|(
name|type
operator|=
name|p
operator|->
name|vtype
condition|)
block|{
case|case
name|TYLOGICAL
case|:
name|type
operator|=
name|tylogical
expr_stmt|;
case|case
name|TYLONG
case|:
case|case
name|TYSHORT
case|:
if|if
condition|(
name|type
operator|==
name|TYSHORT
condition|)
block|{
name|p2op2
argument_list|(
name|P2ICON
argument_list|,
name|P2SHORT
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
call|(
name|short
call|)
argument_list|(
name|p
operator|->
expr|const
operator|.
name|ci
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2op2
argument_list|(
name|P2LCON
argument_list|,
name|P2LONG
argument_list|)
expr_stmt|;
name|p2li
argument_list|(
name|p
operator|->
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYADDR
case|:
name|p2op
argument_list|(
name|P2NAME
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|P2STATIC
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|P2INT
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
operator|(
name|int
operator|)
name|p
operator|->
expr|const
operator|.
name|ci
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2ADDR
argument_list|,
name|P2PTR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putx
argument_list|(
name|putconst
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TEXPR
case|:
switch|switch
condition|(
name|opc
operator|=
name|p
operator|->
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMIN
case|:
case|case
name|OPMAX
case|:
name|putmnmx
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPASSIGN
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|vtype
argument_list|)
condition|)
name|frexpr
argument_list|(
name|putcxeq
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
argument_list|)
condition|)
name|putcheq
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPEQ
case|:
case|case
name|OPNE
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|vtype
argument_list|)
operator|||
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|putcxcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPLT
case|:
case|case
name|OPLE
case|:
case|case
name|OPGT
case|:
case|case
name|OPGE
case|:
if|if
condition|(
name|ISCHAR
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
condition|)
name|putchcmp
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPPOWER
case|:
name|putpower
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPMOD
case|:
goto|goto
name|putopp
goto|;
case|case
name|OPSTAR
case|:
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
case|case
name|OPSLASH
case|:
case|case
name|OPNEG
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|vtype
argument_list|)
condition|)
block|{
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putx
argument_list|(
name|mkconv
argument_list|(
name|p
operator|->
name|vtype
argument_list|,
name|realpart
argument_list|(
name|putcx1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|p
operator|->
name|vtype
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|putopp
goto|;
break|break;
case|case
name|OPNOT
case|:
case|case
name|OPOR
case|:
case|case
name|OPAND
case|:
case|case
name|OPEQV
case|:
case|case
name|OPNEQV
case|:
case|case
name|OPADDR
case|:
case|case
name|OPPLUSEQ
case|:
case|case
name|OPSTAREQ
case|:
case|case
name|OPCOMMA
case|:
case|case
name|OPQUEST
case|:
case|case
name|OPCOLON
case|:
case|case
name|OPBITOR
case|:
case|case
name|OPBITAND
case|:
case|case
name|OPBITXOR
case|:
case|case
name|OPBITNOT
case|:
case|case
name|OPLSHIFT
case|:
case|case
name|OPRSHIFT
case|:
name|putopp
label|:
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"putx: invalid opcode %d"
argument_list|,
name|opc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TADDR
case|:
name|putaddr
argument_list|(
name|p
argument_list|,
name|YES
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"putx: impossible tag %d"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|putop
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|k
decl_stmt|,
name|ncomma
decl_stmt|;
name|int
name|type2
decl_stmt|,
name|ptype
decl_stmt|,
name|ltype
decl_stmt|;
name|int
name|convop
decl_stmt|;
specifier|register
name|expptr
name|lp
decl_stmt|,
name|tp
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|opcode
condition|)
comment|/* check for special cases and rewrite */
block|{
case|case
name|OPCONV
case|:
name|lp
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|opcode
operator|==
name|OPCONV
operator|&&
operator|(
operator|(
operator|(
name|ptype
operator|=
name|p
operator|->
name|vtype
operator|)
operator|==
operator|(
name|ltype
operator|=
name|lp
operator|->
name|vtype
operator|)
operator|)
operator|||
operator|(
name|ISREAL
argument_list|(
name|ptype
argument_list|)
operator|&&
name|ISREAL
argument_list|(
name|ltype
argument_list|)
operator|)
operator|||
operator|(
name|ONEOF
argument_list|(
name|ptype
argument_list|,
name|M
argument_list|(
name|TYSHORT
argument_list|)
operator||
name|M
argument_list|(
name|TYADDR
argument_list|)
argument_list|)
operator|&&
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|M
argument_list|(
name|TYSHORT
argument_list|)
operator||
name|M
argument_list|(
name|TYADDR
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|ptype
operator|==
name|TYINT
operator|&&
name|ONEOF
argument_list|(
name|ltype
argument_list|,
name|M
argument_list|(
name|TYSUBR
argument_list|)
operator||
name|M
argument_list|(
name|TYCHAR
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
operator|||
name|p
operator|->
name|opcode
operator|!=
name|OPCONV
operator|||
name|ISCOMPLEX
argument_list|(
operator|(
name|ltype
operator|=
name|lp
operator|->
name|vtype
operator|)
argument_list|)
condition|)
block|{
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|ltype
operator|=
name|lp
operator|->
name|vtype
expr_stmt|;
switch|switch
condition|(
name|ptype
operator|=
name|p
operator|->
name|vtype
condition|)
block|{
case|case
name|TYCHAR
case|:
name|p
operator|->
name|leftp
operator|=
name|lp
operator|=
name|mkconv
argument_list|(
name|TYSHORT
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|convop
operator|=
name|P2ITOC
expr_stmt|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYADDR
case|:
switch|switch
condition|(
name|ltype
condition|)
block|{
case|case
name|TYLONG
case|:
name|convop
operator|=
name|P2LTOI
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|convop
operator|=
name|P2FTOI
expr_stmt|;
break|break;
default|default:
goto|goto
name|badconv
goto|;
block|}
break|break;
case|case
name|TYLONG
case|:
switch|switch
condition|(
name|ltype
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYADDR
case|:
name|convop
operator|=
name|P2ITOL
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|convop
operator|=
name|P2FTOL
expr_stmt|;
break|break;
default|default:
goto|goto
name|badconv
goto|;
block|}
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
switch|switch
condition|(
name|ltype
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYADDR
case|:
name|convop
operator|=
name|P2ITOF
expr_stmt|;
break|break;
case|case
name|TYLONG
case|:
name|convop
operator|=
name|P2LTOF
expr_stmt|;
break|break;
default|default:
goto|goto
name|badconv
goto|;
block|}
break|break;
default|default:
name|badconv
label|:
name|fatal
argument_list|(
literal|"putop: impossible conversion"
argument_list|)
expr_stmt|;
block|}
name|putx
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|convop
argument_list|,
name|types2
index|[
name|ptype
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPADDR
case|:
name|lp
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|tag
operator|!=
name|TADDR
condition|)
block|{
name|tp
operator|=
name|mktemp
argument_list|(
name|lp
operator|->
name|vtype
argument_list|,
name|lp
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|lp
operator|=
name|tp
expr_stmt|;
block|}
else|else
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|lp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OPASSIGN
case|:
if|if
condition|(
name|p
operator|->
name|vtype
operator|==
name|TYLOGICAL
operator|&&
name|tylogical
operator|!=
name|TYINT
operator|&&
name|p
operator|->
name|rightp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|rightp
operator|->
name|opcode
operator|!=
name|OPCALL
operator|&&
name|p
operator|->
name|rightp
operator|->
name|opcode
operator|!=
name|OPCCALL
condition|)
block|{
name|p
operator|->
name|rightp
operator|->
name|vtype
operator|=
name|TYINT
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|mkconv
argument_list|(
name|tylogical
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|ops2
index|[
name|p
operator|->
name|opcode
index|]
operator|)
operator|<=
literal|0
condition|)
name|fatal1
argument_list|(
literal|"putop: invalid opcode %d"
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
name|putx
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|type2
operator|=
operator|(
name|p
operator|->
name|vtype
operator|==
name|TYLOGICAL
condition|?
name|P2INT
else|:
name|types2
index|[
name|p
operator|->
name|vtype
index|]
operator|)
expr_stmt|;
name|p2op2
argument_list|(
name|k
argument_list|,
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vleng
condition|)
name|frexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_macro
name|putforce
argument_list|(
argument|t
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|expptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p
operator|=
name|mkconv
argument_list|(
name|t
argument_list|,
name|fixtype
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2FORCE
argument_list|,
operator|(
name|t
operator|==
name|TYSHORT
condition|?
name|P2SHORT
else|:
operator|(
name|t
operator|==
name|TYLONG
condition|?
name|P2LONG
else|:
name|P2DREAL
operator|)
operator|)
argument_list|)
expr_stmt|;
name|putstmt
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|putpower
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|expptr
name|base
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|ftnint
name|k
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
operator|||
operator|(
name|k
operator|=
name|p
operator|->
name|rightp
operator|->
expr|const
operator|.
name|ci
operator|)
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"putpower: bad call"
argument_list|)
expr_stmt|;
name|base
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
name|type
operator|=
name|base
operator|->
name|vtype
expr_stmt|;
name|t1
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t2
operator|=
name|NULL
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|>
literal|2
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|2
condition|)
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|t2
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|>>=
literal|1
init|;
name|k
operator|>
literal|1
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
block|}
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|frexpr
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|struct
name|addrblock
modifier|*
name|intdouble
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
name|struct
name|addrblock
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|struct
name|addrblock
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|mktemp
argument_list|(
name|TYDREAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxeq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|addrblock
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|struct
name|addrblock
modifier|*
name|putcx1
parameter_list|()
function_decl|;
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putcx1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|struct
name|addrblock
modifier|*
name|putcx1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
name|struct
name|addrblock
modifier|*
name|q
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
specifier|register
name|struct
name|addrblock
modifier|*
name|resp
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
name|p
operator|=
name|putconst
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TADDR
case|:
if|if
condition|(
operator|!
name|addressable
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mktemp
argument_list|(
name|tyint
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
operator|->
name|memoffset
argument_list|)
expr_stmt|;
name|p
operator|->
name|memoffset
operator|=
name|resp
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|vtype
argument_list|)
condition|)
break|break;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mktemp
argument_list|(
name|TYDREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
default|default:
name|fatal1
argument_list|(
literal|"putcx1: bad tag %d"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|p
operator|->
name|opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPCALL
operator|||
name|opcode
operator|==
name|OPCCALL
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcall
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcxeq
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
name|resp
operator|=
name|mktemp
argument_list|(
name|p
operator|->
name|vtype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|ltype
operator|=
name|lp
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|rtype
operator|=
name|rp
operator|->
name|vtype
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPCOMMA
case|:
name|frexpr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPNEG
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPPLUS
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
name|lp
operator|=
name|intdouble
argument_list|(
name|lp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
comment|/* fixexpr has already replaced all divisions 		 * by a complex by a function call 		 */
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lp
operator|->
name|vtype
argument_list|)
condition|)
name|q
operator|=
name|imagpart
argument_list|(
name|lp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
name|q
operator|=
name|realpart
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|mkrealcon
argument_list|(
name|TYDREAL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"putcx1 of invalid opcode %d"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putcxcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|opcode
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
specifier|register
name|struct
name|addrblock
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|struct
name|exprblock
modifier|*
name|q
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|opcode
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|opcode
operator|==
name|OPEQ
condition|?
name|OPAND
else|:
name|OPOR
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|fixexpr
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|struct
name|addrblock
modifier|*
name|putch1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|struct
name|addrblock
modifier|*
name|t
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|mktemp
argument_list|()
decl_stmt|,
modifier|*
name|putconst
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|putconst
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|TADDR
case|:
return|return
operator|(
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
operator|++
operator|*
name|ncommap
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|opcode
condition|)
block|{
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|t
operator|=
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|t
operator|=
name|mktemp
argument_list|(
name|TYCHAR
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|putcat
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
operator|||
name|p
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
operator|!=
literal|1
operator|||
operator|!
name|INT
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|vtype
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"putch1: bad character conversion"
argument_list|)
expr_stmt|;
name|t
operator|=
name|mktemp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"putch1: invalid opcode %d"
argument_list|,
name|p
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
default|default:
name|fatal1
argument_list|(
literal|"putch1: bad tag %d"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|putchop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYCHAR
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putcheq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|rightp
operator|->
name|opcode
operator|==
name|OPCONCAT
condition|)
name|putcat
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISONE
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2ASSIGN
argument_list|,
name|P2CHAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putx
argument_list|(
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_copy"
argument_list|,
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putchcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISONE
argument_list|(
name|p
operator|->
name|leftp
operator|->
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
operator|->
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|ops2
index|[
name|p
operator|->
name|opcode
index|]
argument_list|,
name|P2CHAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|leftp
operator|=
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_cmp"
argument_list|,
name|p
operator|->
name|leftp
argument_list|,
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|putcat
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
specifier|register
name|struct
name|addrblock
modifier|*
name|lhs
decl_stmt|;
specifier|register
name|expptr
name|rhs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ncomma
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|lp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ncat
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|lp
operator|=
name|mktmpn
argument_list|(
name|n
argument_list|,
name|TYLENG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|mktmpn
argument_list|(
name|n
argument_list|,
name|TYADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|putct1
argument_list|(
name|rhs
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|call4
argument_list|(
name|TYSUBR
argument_list|,
literal|"s_cat"
argument_list|,
name|lhs
argument_list|,
name|cp
argument_list|,
name|lp
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|ICON
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|ncat
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|opcode
operator|==
name|OPCONCAT
condition|)
return|return
operator|(
name|ncat
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
operator|+
name|ncat
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putct1
parameter_list|(
name|q
parameter_list|,
name|lp
parameter_list|,
name|cp
parameter_list|,
name|ip
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|struct
name|addrblock
modifier|*
name|lp
decl_stmt|,
decl|*
name|cp
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|ip
decl_stmt|,
modifier|*
name|ncommap
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|lp1
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|opcode
operator|==
name|OPCONCAT
condition|)
block|{
name|putct1
argument_list|(
name|q
operator|->
name|leftp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putct1
argument_list|(
name|q
operator|->
name|rightp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|*
name|ip
operator|)
operator|++
expr_stmt|;
name|lp1
operator|=
name|cpexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|lp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZLENG
argument_list|)
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZADDR
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|lp1
argument_list|,
name|cpexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cp1
argument_list|,
name|addrof
argument_list|(
name|putch1
argument_list|(
name|q
argument_list|,
name|ncommap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|LOCAL
name|putaddr
parameter_list|(
name|p
parameter_list|,
name|indir
parameter_list|)
specifier|register
name|struct
name|addrblock
modifier|*
name|p
decl_stmt|;
name|int
name|indir
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|funct
decl_stmt|;
name|expptr
name|offp
decl_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
block|{
name|funct
operator|=
name|P2FUNCT
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
name|type2
operator|=
name|P2INT
expr_stmt|;
block|}
else|else
name|funct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|memoffset
operator|&&
operator|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
operator|||
name|p
operator|->
name|memoffset
operator|->
expr|const
operator|.
name|ci
operator|!=
literal|0
operator|)
condition|)
name|offp
operator|=
name|cpexpr
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
expr_stmt|;
else|else
name|offp
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FUDGEOFFSET
operator|!=
literal|1
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|ICON
argument_list|(
name|FUDGEOFFSET
argument_list|)
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
case|case
name|STGAUTO
case|:
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|P2PTR
argument_list|)
expr_stmt|;
name|p2offset
argument_list|(
name|type2
operator||
name|P2PTR
argument_list|,
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op2
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGLENG
case|:
case|case
name|STGARG
case|:
name|p2reg
argument_list|(
name|ARGREG
argument_list|,
name|type2
operator||
name|P2PTR
operator||
operator|(
operator|(
name|funct
condition|?
name|funct
else|:
name|P2PTR
operator|)
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|memno
condition|)
block|{
name|putx
argument_list|(
name|ICON
argument_list|(
name|p
operator|->
name|memno
argument_list|)
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2PLUS
argument_list|,
name|type2
operator||
name|P2PTR
operator||
operator|(
name|funct
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
name|p2op2
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
name|p2offset
argument_list|(
name|type2
operator||
name|P2PTR
operator||
operator|(
name|funct
operator|<<
literal|2
operator|)
argument_list|,
name|offp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indir
condition|)
name|p2op2
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
operator||
name|funct
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
case|case
name|STGEXT
case|:
case|case
name|STGCOMMON
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGCONST
case|:
name|p2op
argument_list|(
name|P2NAME
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|P2EXTERN
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|type2
operator||
name|funct
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|memname
argument_list|(
name|p
operator|->
name|vstg
argument_list|,
name|p
operator|->
name|memno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|indir
operator|||
name|offp
operator|!=
name|NULL
condition|)
name|p2op2
argument_list|(
name|P2ADDR
argument_list|,
name|type2
operator||
name|P2PTR
argument_list|)
expr_stmt|;
name|p2offset
argument_list|(
name|type2
operator||
name|P2PTR
argument_list|,
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
operator|&&
name|offp
operator|!=
name|NULL
condition|)
name|p2op2
argument_list|(
name|P2INDIRECT
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGREG
case|:
if|if
condition|(
name|indir
condition|)
name|p2reg
argument_list|(
name|p
operator|->
name|memno
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"putaddr: invalid vstg %d"
argument_list|,
name|p
operator|->
name|vstg
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|struct
name|addrblock
modifier|*
name|putcall
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|chainp
name|arglist
decl_stmt|,
name|charsp
decl_stmt|,
name|cp
decl_stmt|;
name|int
name|first
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|t
decl_stmt|;
specifier|register
name|struct
name|exprblock
modifier|*
name|q
decl_stmt|;
name|struct
name|exprblock
modifier|*
name|fval
decl_stmt|;
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|ctype
decl_stmt|,
name|indir
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|p
operator|->
name|vtype
operator|)
operator|==
name|TYLOGICAL
condition|)
name|type
operator|=
name|tylogical
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
name|charsp
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
name|YES
expr_stmt|;
name|indir
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPCCALL
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
block|{
name|arglist
operator|=
name|p
operator|->
name|rightp
operator|->
name|listp
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|indir
condition|)
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYSHORT
condition|)
name|q
operator|=
name|mkconv
argument_list|(
name|tyint
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|cp
operator|->
name|datap
operator|=
name|q
operator|=
name|putconst
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
name|charsp
operator|=
name|hookup
argument_list|(
name|charsp
argument_list|,
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLPROC
condition|)
name|charsp
operator|=
name|hookup
argument_list|(
name|charsp
argument_list|,
name|mkchain
argument_list|(
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
condition|)
name|fval
operator|=
name|mktemp
argument_list|(
name|TYCHAR
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"adjustable character function"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
name|fval
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fval
operator|=
name|NULL
expr_stmt|;
name|ctype
operator|=
operator|(
name|fval
condition|?
name|P2INT
else|:
name|type2
operator|)
expr_stmt|;
name|putaddr
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
condition|)
block|{
name|first
operator|=
name|NO
expr_stmt|;
name|putaddr
argument_list|(
name|cpexpr
argument_list|(
name|fval
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2LISTOP
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
name|indir
operator|||
name|q
operator|->
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
name|putaddr
argument_list|(
name|q
argument_list|,
name|indir
operator|&&
name|q
operator|->
name|vtype
operator|!=
name|TYCHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
name|putchop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISERROR
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|indir
condition|)
name|putx
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|mktemp
argument_list|(
name|q
operator|->
name|vtype
argument_list|,
name|q
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|t
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
literal|1
argument_list|,
name|q
operator|->
name|vtype
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|NO
expr_stmt|;
else|else
name|p2op2
argument_list|(
name|P2LISTOP
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
condition|)
name|frchain
argument_list|(
operator|&
name|arglist
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|charsp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|NO
expr_stmt|;
else|else
name|p2op2
argument_list|(
name|P2LISTOP
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|charsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|p2op
argument_list|(
name|P2NULL
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2CALL
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|fval
operator|)
return|;
block|}
end_function

begin_function
name|LOCAL
name|putmnmx
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|struct
name|exprblock
modifier|*
name|qp
decl_stmt|;
name|chainp
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|op
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPMIN
condition|?
name|OPLT
else|:
name|OPGT
operator|)
expr_stmt|;
name|p0
operator|=
name|p
operator|->
name|leftp
operator|->
name|listp
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sp
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mktemp
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|mkexpr
argument_list|(
name|op
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qp
operator|=
name|fixexpr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|p0
operator|->
name|datap
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p0
operator|->
name|nextp
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|p1
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|nextp
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putx
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|frtemp
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|putcomma
parameter_list|(
name|n
parameter_list|,
name|type
parameter_list|,
name|indir
parameter_list|)
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|indir
decl_stmt|;
block|{
name|type
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|type
operator||=
name|P2PTR
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|p2op2
argument_list|(
name|P2COMOP
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  routines that put bytes on the pass2 input stream */
end_comment

begin_macro
name|p2i
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
operator|&
name|k
expr_stmt|;
name|putc
argument_list|(
operator|*
name|s
operator|++
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2op
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putc
argument_list|(
name|op
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|0376
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
comment|/* MAGIC NUMBER */
block|}
end_block

begin_expr_stmt
name|p2str
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
do|do
name|putc
argument_list|(
operator|*
name|s
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|++
condition|)
do|;
block|}
end_block

begin_macro
name|p2op2
argument_list|(
argument|op
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|,
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|p2reg
argument_list|(
argument|k
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|p2op2
argument_list|(
name|P2NAME
argument_list|,
name|P2REG
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|p2i
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|LOCAL
name|p2li
parameter_list|(
name|n
parameter_list|)
name|long
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
name|i
decl_stmt|;
name|p
operator|=
operator|&
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
expr|sizeof
operator|(
name|long
name|int
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
operator|++
name|i
control|)
name|p2i
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|p2offset
parameter_list|(
name|type
parameter_list|,
name|offp
parameter_list|)
name|int
name|type
decl_stmt|;
specifier|register
name|expptr
name|offp
decl_stmt|;
block|{
name|expptr
name|shorten
parameter_list|()
function_decl|;
if|if
condition|(
name|offp
condition|)
block|{
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
if|if
condition|(
name|shortsubs
condition|)
name|offp
operator|=
name|shorten
argument_list|(
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offp
operator|->
name|vtype
operator|!=
name|TYLONG
condition|)
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
operator|->
name|vtype
operator|==
name|TYLONG
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2LTOI
argument_list|,
name|P2INT
argument_list|)
expr_stmt|;
block|}
else|else
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|p2op2
argument_list|(
name|P2PLUS
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

