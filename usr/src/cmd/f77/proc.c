begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs"
end_include

begin_comment
comment|/* start a new procedure */
end_comment

begin_macro
name|newproc
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|parstate
operator|!=
name|OUTSIDE
condition|)
block|{
name|execerr
argument_list|(
literal|"missing end statement"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|endproc
argument_list|()
expr_stmt|;
block|}
name|parstate
operator|=
name|INSIDE
expr_stmt|;
name|procclass
operator|=
name|CLMAIN
expr_stmt|;
comment|/* default */
block|}
end_block

begin_comment
comment|/* end of procedure. generate variables, epilogs, and prologs */
end_comment

begin_macro
name|endproc
argument_list|()
end_macro

begin_block
block|{
name|struct
name|labelblock
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|parstate
operator|<
name|INDATA
condition|)
name|enddcl
argument_list|()
expr_stmt|;
if|if
condition|(
name|ctlstack
operator|>=
name|ctls
condition|)
name|err
argument_list|(
literal|"DO loop or BLOCK IF not closed"
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|labeltab
init|;
name|lp
operator|<
name|labtabend
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|lp
operator|->
name|stateno
operator|!=
literal|0
operator|&&
name|lp
operator|->
name|labdefined
operator|==
name|NO
condition|)
name|err1
argument_list|(
literal|"missing statement number %s"
argument_list|,
name|convic
argument_list|(
name|lp
operator|->
name|stateno
argument_list|)
argument_list|)
expr_stmt|;
name|epicode
argument_list|()
expr_stmt|;
name|procode
argument_list|()
expr_stmt|;
name|dobss
argument_list|()
expr_stmt|;
name|prdbginfo
argument_list|()
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|SCJ
name|putbracket
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|procinit
argument_list|()
expr_stmt|;
comment|/* clean up for next procedure */
block|}
end_block

begin_comment
comment|/* End of declaration section of procedure.  Allocate storage. */
end_comment

begin_macro
name|enddcl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|entrypoint
modifier|*
name|p
decl_stmt|;
name|parstate
operator|=
name|INEXEC
expr_stmt|;
name|docommon
argument_list|()
expr_stmt|;
name|doequiv
argument_list|()
expr_stmt|;
name|docomleng
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|doentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ROUTINES CALLED WHEN ENCOUNTERING ENTRY POINTS */
end_comment

begin_comment
comment|/* Main program or Block data */
end_comment

begin_macro
name|startproc
argument_list|(
argument|progname
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|extsym
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|entrypoint
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|entrypoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|puthead
argument_list|(
literal|"MAIN__"
argument_list|,
name|CLMAIN
argument_list|)
expr_stmt|;
else|else
name|puthead
argument_list|(
name|NULL
argument_list|,
name|CLBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLMAIN
condition|)
name|newentry
argument_list|(
name|mkname
argument_list|(
literal|5
argument_list|,
literal|"MAIN_"
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|entryname
operator|=
name|progname
expr_stmt|;
name|p
operator|->
name|entrylabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|entries
operator|=
name|p
expr_stmt|;
name|procclass
operator|=
name|class
expr_stmt|;
name|retlabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   %s"
argument_list|,
operator|(
name|class
operator|==
name|CLMAIN
condition|?
literal|"MAIN"
else|:
literal|"BLOCK DATA"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|" %s"
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|procname
operator|=
name|progname
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* subroutine or function statement */
end_comment

begin_function
name|struct
name|extsym
modifier|*
name|newentry
parameter_list|(
name|v
parameter_list|)
specifier|register
name|struct
name|nameblock
modifier|*
name|v
decl_stmt|;
block|{
specifier|register
name|struct
name|extsym
modifier|*
name|p
decl_stmt|;
name|struct
name|extsym
modifier|*
name|mkext
parameter_list|()
function_decl|;
name|p
operator|=
name|mkext
argument_list|(
name|varunder
argument_list|(
name|VL
argument_list|,
name|v
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|extinit
operator|||
operator|!
name|ONEOF
argument_list|(
name|p
operator|->
name|extstg
argument_list|,
name|M
argument_list|(
name|STGUNKNOWN
argument_list|)
operator||
name|M
argument_list|(
name|STGEXT
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|dclerr
argument_list|(
literal|"invalid entry name"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"external name already used"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|v
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|v
operator|->
name|vprocclass
operator|=
name|PTHISPROC
expr_stmt|;
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
name|p
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
name|p
operator|->
name|extinit
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|entrypt
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|,
argument|length
argument_list|,
argument|entry
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ftnint
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|extsym
modifier|*
name|entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chainp
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nameblock
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|entrypoint
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|class
operator|!=
name|CLENTRY
condition|)
name|puthead
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|procname
operator|=
name|entry
operator|->
name|extname
argument_list|)
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLENTRY
condition|)
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"       entry "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"   %s:\n"
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|entry
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkname
argument_list|(
name|VL
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|entry
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
operator|)
operator|!=
name|TYCHAR
condition|)
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLPROC
condition|)
block|{
name|procclass
operator|=
name|CLPROC
expr_stmt|;
name|proctype
operator|=
name|type
expr_stmt|;
name|procleng
operator|=
name|length
expr_stmt|;
name|retlabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYSUBR
condition|)
name|ret0label
operator|=
name|newlabel
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|ALLOC
argument_list|(
name|entrypoint
argument_list|)
expr_stmt|;
name|entries
operator|=
name|hookup
argument_list|(
name|entries
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|entryname
operator|=
name|entry
expr_stmt|;
name|p
operator|->
name|arglist
operator|=
name|args
expr_stmt|;
name|p
operator|->
name|entrylabel
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|p
operator|->
name|enamep
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|CLENTRY
condition|)
block|{
name|class
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYSUBR
condition|)
name|type
operator|=
name|TYSUBR
expr_stmt|;
block|}
name|q
operator|->
name|vclass
operator|=
name|class
expr_stmt|;
name|q
operator|->
name|vprocclass
operator|=
name|PTHISPROC
expr_stmt|;
name|settype
argument_list|(
name|q
argument_list|,
name|type
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
comment|/* hold all initial entry points till end of declarations */
if|if
condition|(
name|parstate
operator|>=
name|INDATA
condition|)
name|doentry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* generate epilogs */
end_comment

begin_function
name|LOCAL
name|epicode
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLPROC
condition|)
block|{
if|if
condition|(
name|proctype
operator|==
name|TYSUBR
condition|)
block|{
name|putlabel
argument_list|(
name|ret0label
argument_list|)
expr_stmt|;
if|if
condition|(
name|substars
condition|)
name|putforce
argument_list|(
name|TYINT
argument_list|,
name|ICON
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|putlabel
argument_list|(
name|retlabel
argument_list|)
expr_stmt|;
name|goret
argument_list|(
name|TYSUBR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putlabel
argument_list|(
name|retlabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|multitypes
condition|)
block|{
name|typeaddr
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|TYADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|putbranch
argument_list|(
name|cpexpr
argument_list|(
name|typeaddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTYPES
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|rtvlabel
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|putlabel
argument_list|(
name|rtvlabel
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|retval
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|retval
argument_list|(
name|proctype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|procclass
operator|!=
name|CLBLOCK
condition|)
block|{
name|putlabel
argument_list|(
name|retlabel
argument_list|)
expr_stmt|;
name|goret
argument_list|(
name|TYSUBR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* generate code to return value of type  t */
end_comment

begin_function
name|LOCAL
name|retval
parameter_list|(
name|t
parameter_list|)
specifier|register
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|addrblock
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYCOMPLEX
case|:
case|case
name|TYDCOMPLEX
case|:
break|break;
case|case
name|TYLOGICAL
case|:
name|t
operator|=
name|tylogical
expr_stmt|;
case|case
name|TYADDR
case|:
case|case
name|TYSHORT
case|:
case|case
name|TYLONG
case|:
name|p
operator|=
name|cpexpr
argument_list|(
name|retslot
argument_list|)
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|putforce
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYREAL
case|:
case|case
name|TYDREAL
case|:
name|p
operator|=
name|cpexpr
argument_list|(
name|retslot
argument_list|)
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|putforce
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"retval: impossible type %d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|goret
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate extra argument array if needed. Generate prologs. */
end_comment

begin_function
name|LOCAL
name|procode
parameter_list|()
block|{
specifier|register
name|struct
name|entrypoint
modifier|*
name|p
decl_stmt|;
name|struct
name|addrblock
modifier|*
name|argvec
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|GCOS
name|argvec
operator|=
name|autovar
argument_list|(
name|lastargslot
operator|/
name|SZADDR
argument_list|,
name|TYADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|lastargslot
operator|>
literal|0
operator|&&
name|nentry
operator|>
literal|1
condition|)
name|argvec
operator|=
name|autovar
argument_list|(
name|lastargslot
operator|/
name|SZADDR
argument_list|,
name|TYADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|argvec
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|PDP11
comment|/* for the optimizer */
if|if
condition|(
name|fudgelabel
condition|)
name|putlabel
argument_list|(
name|fudgelabel
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|entries
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|prolog
argument_list|(
name|p
argument_list|,
name|argvec
argument_list|)
expr_stmt|;
if|#
directive|if
name|FAMILY
operator|==
name|SCJ
name|putrbrack
argument_list|(
name|procno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prendproc
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*    manipulate argument lists (allocate argument slot positions)  * keep track of return types and labels  */
end_comment

begin_function
name|LOCAL
name|doentry
parameter_list|(
name|ep
parameter_list|)
name|struct
name|entrypoint
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|struct
name|nameblock
modifier|*
name|np
decl_stmt|;
name|chainp
name|p
decl_stmt|;
specifier|register
name|struct
name|nameblock
modifier|*
name|q
decl_stmt|;
operator|++
name|nentry
expr_stmt|;
if|if
condition|(
name|procclass
operator|==
name|CLMAIN
condition|)
block|{
name|putlabel
argument_list|(
name|ep
operator|->
name|entrylabel
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|procclass
operator|==
name|CLBLOCK
condition|)
return|return;
name|impldcl
argument_list|(
name|np
operator|=
name|mkname
argument_list|(
name|VL
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|ep
operator|->
name|entryname
operator|->
name|extname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|np
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYUNKNOWN
condition|)
if|if
condition|(
operator|(
name|proctype
operator|=
name|type
operator|)
operator|==
name|TYCHAR
condition|)
name|procleng
operator|=
operator|(
name|np
operator|->
name|vleng
condition|?
name|np
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
else|:
operator|(
name|ftnint
operator|)
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|proctype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
name|err
argument_list|(
literal|"noncharacter entry of character function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|vleng
condition|?
name|np
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
else|:
operator|(
name|ftnint
operator|)
literal|0
operator|)
operator|!=
name|procleng
condition|)
name|err
argument_list|(
literal|"mismatched character entry lengths"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|err
argument_list|(
literal|"character entry of noncharacter function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|proctype
condition|)
name|multitype
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|rtvlabel
index|[
name|type
index|]
operator|==
literal|0
condition|)
name|rtvlabel
index|[
name|type
index|]
operator|=
name|newlabel
argument_list|()
expr_stmt|;
name|ep
operator|->
name|typelabel
operator|=
name|rtvlabel
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|chslot
operator|<
literal|0
condition|)
block|{
name|chslot
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|chlgslot
operator|=
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|chslot
expr_stmt|;
if|if
condition|(
name|procleng
operator|==
literal|0
condition|)
name|np
operator|->
name|vleng
operator|=
name|mkarg
argument_list|(
name|TYLENG
argument_list|,
name|chlgslot
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|np
operator|->
name|vstg
operator|=
name|STGARG
expr_stmt|;
if|if
condition|(
name|cxslot
operator|<
literal|0
condition|)
name|cxslot
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|cxslot
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|TYSUBR
condition|)
block|{
if|if
condition|(
name|nentry
operator|==
literal|1
condition|)
name|retslot
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|TYDREAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|np
operator|->
name|voffset
operator|=
name|retslot
operator|->
name|memoffset
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|arglist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|q
operator|=
name|p
operator|->
name|datap
operator|)
operator|->
name|vdcldone
operator|)
condition|)
name|q
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|nextarg
argument_list|(
name|TYADDR
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ep
operator|->
name|arglist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|!
operator|(
operator|(
name|q
operator|=
name|p
operator|->
name|datap
operator|)
operator|->
name|vdcldone
operator|)
condition|)
block|{
name|impldcl
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|vdcldone
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|vleng
operator|==
name|NULL
condition|)
comment|/* character*(*) */
name|q
operator|->
name|vleng
operator|=
name|mkarg
argument_list|(
name|TYLENG
argument_list|,
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nentry
operator|==
literal|1
condition|)
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|nentry
operator|==
literal|1
condition|)
name|nextarg
argument_list|(
name|TYLENG
argument_list|)
expr_stmt|;
block|}
name|putlabel
argument_list|(
name|ep
operator|->
name|entrylabel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|nextarg
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|int
name|k
decl_stmt|;
name|k
operator|=
name|lastargslot
expr_stmt|;
name|lastargslot
operator|+=
name|typesize
index|[
name|type
index|]
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* generate variable references */
end_comment

begin_function
name|LOCAL
name|dobss
parameter_list|()
block|{
specifier|register
name|struct
name|hashentry
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|nameblock
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|align
decl_stmt|;
name|ftnint
name|leng
decl_stmt|,
name|iarrl
decl_stmt|,
name|iarrlen
argument_list|()
decl_stmt|;
name|struct
name|extsym
modifier|*
name|mkext
parameter_list|()
function_decl|;
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|pruse
argument_list|(
name|asmfile
argument_list|,
name|USEBSS
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hashtab
init|;
name|p
operator|<
name|lasthash
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|varp
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|->
name|vclass
operator|==
name|CLUNKNOWN
operator|&&
name|q
operator|->
name|vstg
operator|!=
name|STGARG
operator|)
operator|||
operator|(
name|q
operator|->
name|vclass
operator|==
name|CLVAR
operator|&&
name|q
operator|->
name|vstg
operator|==
name|STGUNKNOWN
operator|)
condition|)
name|warn1
argument_list|(
literal|"local variable %s never used"
argument_list|,
name|varstr
argument_list|(
name|VL
argument_list|,
name|q
operator|->
name|varname
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLVAR
operator|&&
name|q
operator|->
name|vstg
operator|==
name|STGBSS
condition|)
block|{
name|align
operator|=
operator|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
condition|?
name|ALILONG
else|:
name|typealign
index|[
name|q
operator|->
name|vtype
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|bssleng
operator|%
name|align
operator|!=
literal|0
condition|)
block|{
name|bssleng
operator|=
name|roundup
argument_list|(
name|bssleng
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|preven
argument_list|(
name|align
argument_list|)
expr_stmt|;
block|}
name|prlocvar
argument_list|(
name|memname
argument_list|(
name|STGBSS
argument_list|,
name|q
operator|->
name|vardesc
operator|.
name|varno
argument_list|)
argument_list|,
name|iarrl
operator|=
name|iarrlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|bssleng
operator|+=
name|iarrl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLPROC
operator|&&
name|q
operator|->
name|vprocclass
operator|==
name|PEXTERNAL
operator|&&
name|q
operator|->
name|vstg
operator|!=
name|STGARG
condition|)
name|mkext
argument_list|(
name|varunder
argument_list|(
name|VL
argument_list|,
name|q
operator|->
name|varname
argument_list|)
argument_list|)
operator|->
name|extstg
operator|=
name|STGEXT
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vclass
operator|==
name|CLVAR
operator|&&
name|q
operator|->
name|vstg
operator|!=
name|STGARG
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|vdim
operator|&&
operator|!
name|ISICON
argument_list|(
name|q
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
condition|)
name|dclerr
argument_list|(
literal|"adjustable dimension on non-argument"
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYCHAR
operator|&&
operator|(
name|q
operator|->
name|vleng
operator|==
name|NULL
operator|||
operator|!
name|ISICON
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
operator|)
condition|)
name|dclerr
argument_list|(
literal|"adjustable leng on nonargument"
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nequiv
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|eqvclass
index|[
name|i
index|]
operator|.
name|eqvinit
operator|==
name|NO
operator|&&
operator|(
name|leng
operator|=
name|eqvclass
index|[
name|i
index|]
operator|.
name|eqvleng
operator|)
operator|!=
literal|0
condition|)
block|{
name|bssleng
operator|=
name|roundup
argument_list|(
name|bssleng
argument_list|,
name|ALIDOUBLE
argument_list|)
expr_stmt|;
name|preven
argument_list|(
name|ALIDOUBLE
argument_list|)
expr_stmt|;
name|prlocvar
argument_list|(
name|memname
argument_list|(
name|STGEQUIV
argument_list|,
name|i
argument_list|)
argument_list|,
name|leng
argument_list|)
expr_stmt|;
name|bssleng
operator|+=
name|leng
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|doext
argument_list|()
end_macro

begin_block
block|{
name|struct
name|extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
name|prext
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|p
operator|->
name|extname
argument_list|)
argument_list|,
name|p
operator|->
name|maxleng
argument_list|,
name|p
operator|->
name|extinit
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|ftnint
name|iarrlen
parameter_list|(
name|q
parameter_list|)
specifier|register
name|struct
name|nameblock
modifier|*
name|q
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
name|leng
operator|=
name|typesize
index|[
name|q
operator|->
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|leng
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|vdim
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vdim
operator|->
name|nelt
argument_list|)
condition|)
name|leng
operator|*=
name|q
operator|->
name|vdim
operator|->
name|nelt
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|q
operator|->
name|vleng
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|q
operator|->
name|vleng
argument_list|)
condition|)
name|leng
operator|*=
name|q
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|leng
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|LOCAL
name|docommon
parameter_list|()
block|{
specifier|register
name|struct
name|extsym
modifier|*
name|p
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|;
name|struct
name|dimblock
modifier|*
name|t
decl_stmt|;
name|expptr
name|neltp
decl_stmt|;
specifier|register
name|struct
name|nameblock
modifier|*
name|v
decl_stmt|;
name|ftnint
name|size
decl_stmt|;
name|int
name|type
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
block|{
for|for
control|(
name|q
operator|=
name|p
operator|->
name|extp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
name|v
operator|=
name|q
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vdcldone
operator|==
name|NO
condition|)
name|vardcl
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extleng
operator|%
name|typealign
index|[
name|type
index|]
operator|!=
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"common alignment"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|->
name|extleng
operator|=
name|roundup
argument_list|(
name|p
operator|->
name|extleng
argument_list|,
name|typealign
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|voffset
operator|=
name|p
operator|->
name|extleng
expr_stmt|;
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|p
operator|-
name|extsymtab
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
name|size
operator|=
name|v
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
else|else
name|size
operator|=
name|typesize
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|v
operator|->
name|vdim
condition|)
if|if
condition|(
operator|(
name|neltp
operator|=
name|t
operator|->
name|nelt
operator|)
operator|&&
name|ISCONST
argument_list|(
name|neltp
argument_list|)
condition|)
name|size
operator|*=
name|neltp
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"adjustable array in common"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|->
name|extleng
operator|+=
name|size
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
operator|(
name|p
operator|->
name|extp
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|docomleng
parameter_list|()
block|{
specifier|register
name|struct
name|extsym
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extsymtab
init|;
name|p
operator|<
name|nextext
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGCOMMON
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|maxleng
operator|!=
literal|0
operator|&&
name|p
operator|->
name|extleng
operator|!=
literal|0
operator|&&
name|p
operator|->
name|maxleng
operator|!=
name|p
operator|->
name|extleng
operator|&&
operator|!
name|eqn
argument_list|(
name|XL
argument_list|,
literal|"_BLNK__ "
argument_list|,
name|p
operator|->
name|extname
argument_list|)
condition|)
name|warn1
argument_list|(
literal|"incompatible lengths for common block %s"
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|p
operator|->
name|extname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|maxleng
operator|<
name|p
operator|->
name|extleng
condition|)
name|p
operator|->
name|maxleng
operator|=
name|p
operator|->
name|extleng
expr_stmt|;
name|p
operator|->
name|extleng
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ROUTINES DEALING WITH AUTOMATIC AND TEMPORARY STORAGE */
end_comment

begin_macro
name|frtemp
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|addrblock
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|holdtemps
operator|=
name|mkchain
argument_list|(
name|p
argument_list|,
name|holdtemps
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* allocate an automatic variable slot */
end_comment

begin_function
name|struct
name|addrblock
modifier|*
name|autovar
parameter_list|(
name|nelt
parameter_list|,
name|t
parameter_list|,
name|lengp
parameter_list|)
specifier|register
name|int
name|nelt
decl_stmt|,
name|t
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
specifier|register
name|struct
name|addrblock
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|fatal
argument_list|(
literal|"automatic variable of nonconstant length"
argument_list|)
expr_stmt|;
block|}
else|else
name|leng
operator|=
name|typesize
index|[
name|t
index|]
expr_stmt|;
name|autoleng
operator|=
name|roundup
argument_list|(
name|autoleng
argument_list|,
name|typealign
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|addrblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TADDR
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
name|q
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|leng
argument_list|)
expr_stmt|;
name|q
operator|->
name|vstg
operator|=
name|STGAUTO
expr_stmt|;
name|q
operator|->
name|ntempelt
operator|=
name|nelt
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
operator|||
name|TARGET
operator|==
name|VAX
comment|/* stack grows downward */
name|autoleng
operator|+=
name|nelt
operator|*
name|leng
expr_stmt|;
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
operator|-
name|autoleng
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|memoffset
operator|=
name|ICON
argument_list|(
name|autoleng
argument_list|)
expr_stmt|;
name|autoleng
operator|+=
name|nelt
operator|*
name|leng
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|addrblock
modifier|*
name|mktmpn
parameter_list|(
name|nelt
parameter_list|,
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|nelt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
name|ftnint
name|leng
decl_stmt|;
name|chainp
name|p
decl_stmt|,
name|oldp
decl_stmt|;
specifier|register
name|struct
name|addrblock
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
operator|||
name|type
operator|==
name|TYERROR
condition|)
name|fatal1
argument_list|(
literal|"mktmpn: invalid type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
if|if
condition|(
name|ISICON
argument_list|(
name|lengp
argument_list|)
condition|)
name|leng
operator|=
name|lengp
operator|->
expr|const
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|err
argument_list|(
literal|"adjustable length"
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
for|for
control|(
name|oldp
operator|=
operator|&
name|templist
init|;
name|p
operator|=
name|oldp
operator|->
name|nextp
condition|;
name|oldp
operator|=
name|p
control|)
block|{
name|q
operator|=
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|type
operator|&&
name|q
operator|->
name|ntempelt
operator|==
name|nelt
operator|&&
operator|(
name|type
operator|!=
name|TYCHAR
operator|||
name|q
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
operator|==
name|leng
operator|)
condition|)
block|{
name|oldp
operator|->
name|nextp
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
name|q
operator|=
name|autovar
argument_list|(
name|nelt
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
expr_stmt|;
name|q
operator|->
name|istemp
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|addrblock
modifier|*
name|mktemp
parameter_list|(
name|type
parameter_list|,
name|lengp
parameter_list|)
name|int
name|type
decl_stmt|;
name|expptr
name|lengp
decl_stmt|;
block|{
return|return
operator|(
name|mktmpn
argument_list|(
literal|1
argument_list|,
name|type
argument_list|,
name|lengp
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* VARIOUS ROUTINES FOR PROCESSING DECLARATIONS */
end_comment

begin_function
name|struct
name|extsym
modifier|*
name|comblock
parameter_list|(
name|len
parameter_list|,
name|s
parameter_list|)
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|extsym
modifier|*
name|mkext
argument_list|()
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|BLANKCOMMON
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|mkext
argument_list|(
name|varunder
argument_list|(
name|len
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|extstg
operator|==
name|STGUNKNOWN
condition|)
name|p
operator|->
name|extstg
operator|=
name|STGCOMMON
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|extstg
operator|!=
name|STGCOMMON
condition|)
block|{
name|err1
argument_list|(
literal|"%s cannot be a common block name"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|incomm
argument_list|(
argument|c
argument_list|,
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|extsym
modifier|*
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nameblock
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
name|STGUNKNOWN
condition|)
name|dclerr
argument_list|(
literal|"incompatible common declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
block|{
name|v
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|c
operator|->
name|extp
operator|=
name|hookup
argument_list|(
name|c
operator|->
name|extp
argument_list|,
name|mkchain
argument_list|(
name|v
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|settype
argument_list|(
name|v
argument_list|,
name|type
argument_list|,
name|length
argument_list|)
specifier|register
expr|struct
name|nameblock
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|type
operator|==
name|TYUNKNOWN
condition|)
return|return;
if|if
condition|(
name|type
operator|==
name|TYSUBR
operator|&&
name|v
operator|->
name|vtype
operator|!=
name|TYUNKNOWN
operator|&&
name|v
operator|->
name|vstg
operator|==
name|STGARG
condition|)
block|{
name|v
operator|->
name|vtype
operator|=
name|TYSUBR
expr_stmt|;
name|frexpr
argument_list|(
name|v
operator|->
name|vleng
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|<
literal|0
condition|)
comment|/* storage class set */
block|{
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
operator|-
name|type
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
operator|-
name|type
condition|)
name|dclerr
argument_list|(
literal|"incompatible storage declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|vtype
operator|==
name|TYUNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|vtype
operator|=
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
operator|)
operator|==
name|TYCHAR
operator|&&
name|length
operator|!=
literal|0
condition|)
name|v
operator|->
name|vleng
operator|=
name|ICON
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|->
name|vtype
operator|!=
name|type
operator|||
operator|(
name|type
operator|==
name|TYCHAR
operator|&&
name|v
operator|->
name|vleng
operator|->
expr|const
operator|.
name|ci
operator|!=
name|length
operator|)
condition|)
name|dclerr
argument_list|(
literal|"incompatible type declarations"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lengtype
argument_list|(
name|type
argument_list|,
name|length
argument_list|)
specifier|register
name|int
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYREAL
case|:
if|if
condition|(
name|length
operator|==
literal|8
condition|)
return|return
operator|(
name|TYDREAL
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|4
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYCOMPLEX
case|:
if|if
condition|(
name|length
operator|==
literal|16
condition|)
return|return
operator|(
name|TYDCOMPLEX
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|8
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYSHORT
case|:
case|case
name|TYDREAL
case|:
case|case
name|TYDCOMPLEX
case|:
case|case
name|TYCHAR
case|:
case|case
name|TYUNKNOWN
case|:
case|case
name|TYSUBR
case|:
case|case
name|TYERROR
case|:
goto|goto
name|ret
goto|;
case|case
name|TYLOGICAL
case|:
if|if
condition|(
name|length
operator|==
literal|4
condition|)
goto|goto
name|ret
goto|;
break|break;
case|case
name|TYLONG
case|:
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
operator|(
name|tyint
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|2
condition|)
return|return
operator|(
name|TYSHORT
operator|)
return|;
if|if
condition|(
name|length
operator|==
literal|4
condition|)
goto|goto
name|ret
goto|;
break|break;
default|default:
name|fatal1
argument_list|(
literal|"lengtype: invalid type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|"incompatible type-length combination"
argument_list|)
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|type
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setintr
argument_list|(
name|v
argument_list|)
specifier|register
expr|struct
name|nameblock
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vstg
operator|==
name|STGUNKNOWN
condition|)
name|v
operator|->
name|vstg
operator|=
name|STGINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vstg
operator|!=
name|STGINTR
condition|)
name|dclerr
argument_list|(
literal|"incompatible use of intrinsic function"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PUNKNOWN
condition|)
name|v
operator|->
name|vprocclass
operator|=
name|PINTRINSIC
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|!=
name|PINTRINSIC
condition|)
name|dclerr
argument_list|(
literal|"invalid intrinsic declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|intrfunct
argument_list|(
name|v
operator|->
name|varname
argument_list|)
condition|)
name|v
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|k
expr_stmt|;
else|else
name|dclerr
argument_list|(
literal|"unknown intrinsic function"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|setext
argument_list|(
name|v
argument_list|)
specifier|register
expr|struct
name|nameblock
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLPROC
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLPROC
condition|)
name|dclerr
argument_list|(
literal|"invalid external declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|==
name|PUNKNOWN
condition|)
name|v
operator|->
name|vprocclass
operator|=
name|PEXTERNAL
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vprocclass
operator|!=
name|PEXTERNAL
condition|)
name|dclerr
argument_list|(
literal|"invalid external declaration"
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* create dimensions block for array variable */
end_comment

begin_expr_stmt
name|setbound
argument_list|(
name|v
argument_list|,
name|nd
argument_list|,
name|dims
argument_list|)
specifier|register
expr|struct
name|nameblock
operator|*
name|v
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nd
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|expptr
name|lb
decl_stmt|,
name|ub
decl_stmt|;
block|}
name|dims
index|[ ]
struct|;
end_struct

begin_block
block|{
specifier|register
name|expptr
name|q
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|struct
name|dimblock
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|vclass
operator|==
name|CLUNKNOWN
condition|)
name|v
operator|->
name|vclass
operator|=
name|CLVAR
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|->
name|vclass
operator|!=
name|CLVAR
condition|)
block|{
name|dclerr
argument_list|(
literal|"only variables may be arrays"
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|->
name|vdim
operator|=
name|p
operator|=
operator|(
expr|struct
name|dimblock
operator|*
operator|)
name|ckalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
operator|(
literal|3
operator|+
literal|2
operator|*
name|nd
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|expptr
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ndim
operator|=
name|nd
expr_stmt|;
name|p
operator|->
name|nelt
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nd
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|ub
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|nd
operator|-
literal|1
condition|)
block|{
name|frexpr
argument_list|(
name|p
operator|->
name|nelt
argument_list|)
expr_stmt|;
name|p
operator|->
name|nelt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|err
argument_list|(
literal|"only last bound may be asterisk"
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
condition|)
block|{
name|q
operator|=
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|q
argument_list|,
name|cpexpr
argument_list|(
name|dims
index|[
name|i
index|]
operator|.
name|lb
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|q
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimexpr
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|nelt
condition|)
name|p
operator|->
name|nelt
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|p
operator|->
name|nelt
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|q
operator|=
name|dims
index|[
name|nd
operator|-
literal|1
index|]
operator|.
name|lb
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|q
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nd
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|dims
index|[
name|i
index|]
operator|.
name|lb
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|t
operator|=
name|ICON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
condition|)
name|q
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|t
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|p
operator|->
name|dims
index|[
name|i
index|]
operator|.
name|dimsize
argument_list|)
argument_list|,
name|q
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|p
operator|->
name|baseoffset
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|basexpr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|baseoffset
operator|=
name|autovar
argument_list|(
literal|1
argument_list|,
name|tyint
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|->
name|basexpr
operator|=
name|q
expr_stmt|;
block|}
block|}
end_block

end_unit

