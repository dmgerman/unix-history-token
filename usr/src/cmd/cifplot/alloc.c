begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* *                                                                  * *    File: CIFPLOT/alloc.c                                         * *    Written by Dan Fitzpatrick                                    * *    copyright 1980 -- Regents of the University of California     * *                                                                  * ********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_function_decl
name|IMPORT
name|int
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|int
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BLOCKSIZE
value|4
end_define

begin_comment
comment|/* Memory is allocated in multiples of BLOCKSIZE */
end_comment

begin_comment
comment|/* ALLOC_ID, PALLOC_ID,& FREED_ID are used to mark memory as  * allocated, permanently allocated,& freed, repectively */
end_comment

begin_define
define|#
directive|define
name|ALLOC_ID
value|0xAA00FFFF
end_define

begin_define
define|#
directive|define
name|PALLOC_ID
value|0x55AAA0F0
end_define

begin_define
define|#
directive|define
name|FREED_ID
value|0xAFFA8118
end_define

begin_comment
comment|/* size returns how much memory 'x' points to */
end_comment

begin_define
define|#
directive|define
name|size
parameter_list|(
name|x
parameter_list|)
value|( *(x-1) - ((int) x) + 1 )
end_define

begin_comment
comment|/* These are variables that are used to keep track of how much  * memory has been allocated.		*/
end_comment

begin_decl_stmt
name|int
name|AllocCount
decl_stmt|,
name|FreeCount
decl_stmt|,
name|AllocBytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|FreeBytes
decl_stmt|,
name|PallocCount
decl_stmt|,
name|PallocBytes
decl_stmt|,
name|MaxBytes
decl_stmt|;
end_decl_stmt

begin_function
name|int
modifier|*
name|alloc
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
comment|/* Returns a pointer to a block of memory of size 'nbytes' */
block|{
name|int
name|nunits
decl_stmt|;
name|int
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
name|nbytes
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nunits
operator|=
operator|(
operator|(
name|nbytes
operator|-
literal|1
operator|)
operator|/
name|BLOCKSIZE
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|ptr
operator|=
name|malloc
argument_list|(
name|nunits
operator|*
name|BLOCKSIZE
argument_list|)
operator|)
condition|)
name|Error
argument_list|(
literal|"Out of space!\n"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
comment|/* Set up an identifier to show this has been allocated */
operator|*
name|ptr
operator|=
name|ALLOC_ID
expr_stmt|;
name|AllocCount
operator|++
expr_stmt|;
name|AllocBytes
operator|+=
name|size
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|AllocBytes
operator|-
name|FreeBytes
operator|)
operator|>
name|MaxBytes
condition|)
name|MaxBytes
operator|=
name|AllocBytes
operator|-
name|FreeBytes
expr_stmt|;
return|return
operator|(
operator|++
name|ptr
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ptr
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
modifier|*
name|palloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* Allocate n bytes of permanent memory (this memory will not be freed) */
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
name|PallocCount
operator|++
expr_stmt|;
name|PallocBytes
operator|+=
name|n
expr_stmt|;
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
name|PALLOC_ID
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|Free
argument_list|(
argument|ptr
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free the block of memory pointed to by 'ptr'. This memory must  * have been allocated by 'alloc'. */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|ADEBUG
comment|/* Check to see that the memory was allocated by 'alloc' */
operator|--
name|ptr
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|ALLOC_ID
condition|)
if|if
condition|(
operator|*
name|ptr
operator|==
name|PALLOC_ID
condition|)
name|Error
argument_list|(
literal|"Tried to Free Permanent Storage"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
name|FREED_ID
condition|)
name|Error
argument_list|(
literal|"Tried to Free an already free block"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
else|else
name|Error
argument_list|(
literal|"Tried to Free an Unallocated Block"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
comment|/* Mark this memory as free, if memory is freed again flag an error */
operator|*
name|ptr
operator|=
name|FREED_ID
expr_stmt|;
name|FreeCount
operator|++
expr_stmt|;
name|FreeBytes
operator|+=
name|size
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|int
modifier|*
name|expand
parameter_list|(
name|ptr
parameter_list|,
name|n
parameter_list|)
name|int
modifier|*
name|ptr
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 'expand' changes the size of an array pointed to by 'ptr' to be an  * array of n bytes. This is useful to avoid table overflow. Instead  * of aborting on overflow we can just make the table bigger.	*/
block|{
name|Free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ptr
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|FREED_ID
condition|)
name|Error
argument_list|(
literal|"Block has not been freed"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|Error
argument_list|(
literal|"Out of memory"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADEBUG
if|if
condition|(
operator|*
name|ptr
operator|!=
name|FREED_ID
condition|)
name|Error
argument_list|(
literal|"Block has not been copied correctly"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|ALLOC_ID
expr_stmt|;
name|AllocCount
operator|++
expr_stmt|;
name|AllocBytes
operator|+=
name|size
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|AllocBytes
operator|-
name|FreeBytes
operator|)
operator|>
name|MaxBytes
condition|)
name|MaxBytes
operator|=
name|AllocBytes
operator|-
name|FreeBytes
expr_stmt|;
return|return
operator|(
operator|++
name|ptr
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ptr
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|int
name|acnt0
decl_stmt|,
name|acnt1
decl_stmt|,
name|acnt2
decl_stmt|,
name|acnt3
decl_stmt|,
name|acnt4
decl_stmt|,
name|acnt5
decl_stmt|,
name|acnt6
decl_stmt|,
name|acnt7
decl_stmt|,
name|acnt8
decl_stmt|,
name|acnt9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bcnt0
decl_stmt|,
name|bcnt1
decl_stmt|,
name|bcnt2
decl_stmt|,
name|bcnt3
decl_stmt|,
name|bcnt4
decl_stmt|,
name|bcnt5
decl_stmt|,
name|bcnt6
decl_stmt|,
name|bcnt7
decl_stmt|,
name|bcnt8
decl_stmt|,
name|bcnt9
decl_stmt|;
end_decl_stmt

begin_macro
name|AllocSummary
argument_list|()
end_macro

begin_comment
comment|/* Prints out statistics of memory allocated */
end_comment

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6d blocks, %8d bytes allocated\n"
argument_list|,
name|AllocCount
argument_list|,
name|AllocBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6d blocks, %8d bytes permanent requests\n"
argument_list|,
name|PallocCount
argument_list|,
name|PallocBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6d blocks, %8d bytes freed\n"
argument_list|,
name|FreeCount
argument_list|,
name|FreeBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6d blocks, %8d bytes unretrieved\n"
argument_list|,
name|AllocCount
operator|-
name|FreeCount
argument_list|,
name|AllocBytes
operator|-
name|FreeBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%8d bytes were required\n"
argument_list|,
name|MaxBytes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nPlot Time allocation\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n"
argument_list|,
name|acnt0
argument_list|,
name|acnt1
argument_list|,
name|acnt2
argument_list|,
name|acnt3
argument_list|,
name|acnt4
argument_list|,
name|acnt5
argument_list|,
name|acnt6
argument_list|,
name|acnt7
argument_list|,
name|acnt8
argument_list|,
name|acnt9
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n"
argument_list|,
name|bcnt0
argument_list|,
name|bcnt1
argument_list|,
name|bcnt2
argument_list|,
name|bcnt3
argument_list|,
name|bcnt4
argument_list|,
name|bcnt5
argument_list|,
name|bcnt6
argument_list|,
name|bcnt7
argument_list|,
name|bcnt8
argument_list|,
name|bcnt9
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

