begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* *                                                                  * *    File: CIFPLOT/symbol.c                                        * *    Written by Dan Fitzpatrick                                    * *    copyright 1980 -- Regents of the University of California     * *                                                                  * ********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"parser_defs.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_function_decl
specifier|extern
name|Command
modifier|*
name|FindSymbol
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Forward reference FindSymbol */
end_comment

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeSymbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakePoly
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeWire
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeBox
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeFlash
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeText
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeCall
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeArray
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakePointName
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|struct
name|PathHeader
modifier|*
name|MakePath
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|AddCmd
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|CopyDelete
argument_list|(
argument|sym
argument_list|)
end_macro

begin_decl_stmt
name|Command
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a copy of the symbol 'sym' and mark the original deleted.  * Go down 'sym' backtrace list and CopyDelete all the symbols on that */
end_comment

begin_block
block|{
name|struct
name|CCell
modifier|*
name|p
decl_stmt|;
name|int
name|b
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|!=
name|DELETED
condition|)
block|{
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|DELETED
expr_stmt|;
name|b
operator|=
literal|1
expr_stmt|;
name|CopySymbol
argument_list|(
name|sym
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|backTrace
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|CCLink
control|)
name|CopyDelete
argument_list|(
name|p
operator|->
name|CCCom
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|b
operator|)
return|;
block|}
end_block

begin_macro
name|CopySymbol
argument_list|(
argument|sym
argument_list|)
end_macro

begin_decl_stmt
name|Command
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a new symbol header and copy all the Commands contained in 'sym'. */
end_comment

begin_block
block|{
name|Command
modifier|*
name|newsym
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|PointList
modifier|*
name|ptr
decl_stmt|;
name|struct
name|PathHeader
modifier|*
name|path
decl_stmt|;
name|point
modifier|*
name|pt
decl_stmt|;
name|newsym
operator|=
name|MakeSymbol
argument_list|(
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
argument_list|,
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|a
argument_list|,
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|b
argument_list|)
expr_stmt|;
name|newsym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|UNUSED
expr_stmt|;
name|newsym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SName
operator|=
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SName
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|CStart
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|CLink
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|POLYGON
case|:
name|pt
operator|=
operator|&
operator|(
name|p
operator|->
name|Ctype
operator|.
name|Path
operator|->
name|pt
operator|)
expr_stmt|;
name|path
operator|=
name|MakePath
argument_list|(
name|pt
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|p
operator|->
name|Ctype
operator|.
name|Path
operator|->
name|PLink
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|PLink
control|)
name|AddPath
argument_list|(
name|path
argument_list|,
operator|&
operator|(
name|ptr
operator|->
name|pt
operator|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|MakePoly
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|q
operator|->
name|level
operator|=
name|p
operator|->
name|level
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|WIRE
case|:
name|pt
operator|=
operator|&
operator|(
name|p
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WPath
operator|->
name|pt
operator|)
expr_stmt|;
name|path
operator|=
name|MakePath
argument_list|(
name|pt
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|p
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WPath
operator|->
name|PLink
init|;
name|ptr
operator|!=
name|NIL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|PLink
control|)
name|AddPath
argument_list|(
name|path
argument_list|,
operator|&
operator|(
name|ptr
operator|->
name|pt
operator|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|MakeWire
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WWidth
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|q
operator|->
name|level
operator|=
name|p
operator|->
name|level
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOX
case|:
name|q
operator|=
name|MakeBox
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|blength
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bwidth
argument_list|,
operator|&
operator|(
name|p
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|)
argument_list|,
operator|&
operator|(
name|p
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bdirect
operator|)
argument_list|)
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLASH
case|:
name|q
operator|=
name|MakeFlash
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fdia
argument_list|,
operator|&
operator|(
name|p
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fcenter
operator|)
argument_list|)
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXT
case|:
name|q
operator|=
name|MakeText
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|Text
operator|.
name|TString
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Text
operator|.
name|TTrans
argument_list|)
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTNAME
case|:
name|q
operator|=
name|MakePointName
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|PointName
operator|.
name|Name
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|PointName
operator|.
name|loc
operator|.
name|x
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|PointName
operator|.
name|loc
operator|.
name|y
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|PointName
operator|.
name|Label
argument_list|)
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
comment|/* 		case POLYGON: 		case BOX: 		case WIRE: 		case FLASH: 		case TEXT: 			AddCmd(newsym,q); 			break; 			*/
case|case
name|ARRAY
case|:
name|q
operator|=
name|MakeArray
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|As
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Am
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|An
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Adx
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Ady
argument_list|)
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL
case|:
name|q
operator|=
name|MakeCall
argument_list|(
name|p
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|trans
argument_list|)
expr_stmt|;
name|AddCmd
argument_list|(
name|newsym
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
name|char
name|s
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Illegal command found in symbol %d\n"
argument_list|,
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|s
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|StoreSymbol
argument_list|(
name|newsym
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|Command
modifier|*
name|SymbolTable
index|[
name|TableSize
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hash
parameter_list|(
name|x
parameter_list|)
value|ABS(x % TableSize)
end_define

begin_macro
name|StoreSymbol
argument_list|(
argument|sym
argument_list|)
end_macro

begin_decl_stmt
name|Command
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Put 'sym' in to the Symbol hash table */
end_comment

begin_block
block|{
name|int
name|n
decl_stmt|,
name|status
decl_stmt|;
name|n
operator|=
name|sym
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
expr_stmt|;
comment|/* Check to see there is no other copy of n */
name|status
operator|=
name|State
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|NONEXIST
operator|)
operator|&&
operator|(
name|status
operator|!=
name|DELETED
operator|)
condition|)
block|{
name|char
name|s
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Two Living Copies of Symbol %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|s
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
block|}
name|sym
operator|->
name|CLink
operator|=
name|SymbolTable
index|[
name|hash
argument_list|(
name|n
argument_list|)
index|]
expr_stmt|;
name|SymbolTable
index|[
name|hash
argument_list|(
name|n
argument_list|)
index|]
operator|=
name|sym
expr_stmt|;
block|}
end_block

begin_function
name|Command
modifier|*
name|FindSymbol
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* Return a pointer to symbol n */
block|{
name|Command
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|SymbolTable
index|[
name|hash
argument_list|(
name|n
argument_list|)
index|]
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|CLink
control|)
if|if
condition|(
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
operator|==
name|n
condition|)
block|{
return|return
operator|(
name|p
operator|)
return|;
block|}
name|DEBUG
argument_list|(
literal|"FindSymbol failed to return symbol\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_macro
name|DeleteDefintion
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|,
name|p
decl_stmt|;
name|Command
modifier|*
name|temp
decl_stmt|,
modifier|*
name|store
decl_stmt|,
modifier|*
name|RemovedSymbols
decl_stmt|;
name|struct
name|CCell
modifier|*
name|bptr
decl_stmt|;
name|RemovedSymbols
operator|=
name|NIL
expr_stmt|;
comment|/* Go through every symbol in the symbol table      * If the symbol is greater or equal to 'i' delete      * the symbol and put it in the RemovedSymbol list.      * If the symbol is less than 'i' put in a store list.      * This reverses the order so put back in SymbolTable again      * reversing the order      */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TableSize
condition|;
name|j
operator|++
control|)
block|{
name|store
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|SymbolTable
index|[
name|j
index|]
init|;
name|temp
operator|!=
name|NIL
condition|;
name|temp
operator|=
name|SymbolTable
index|[
name|j
index|]
control|)
block|{
name|SymbolTable
index|[
name|j
index|]
operator|=
name|temp
operator|->
name|CLink
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
operator|<
name|i
condition|)
block|{
name|temp
operator|->
name|CLink
operator|=
name|store
expr_stmt|;
name|store
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|DELETED
expr_stmt|;
name|temp
operator|->
name|CLink
operator|=
name|RemovedSymbols
expr_stmt|;
name|RemovedSymbols
operator|=
name|temp
expr_stmt|;
block|}
block|}
for|for
control|(
name|temp
operator|=
name|store
init|;
name|temp
operator|!=
name|NIL
condition|;
name|temp
operator|=
name|store
control|)
block|{
name|store
operator|=
name|temp
operator|->
name|CLink
expr_stmt|;
name|temp
operator|->
name|CLink
operator|=
name|SymbolTable
index|[
name|j
index|]
expr_stmt|;
name|SymbolTable
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
comment|/* Now CopyDelete all the non-deleted backtrace symbols */
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|RemovedSymbols
init|;
name|temp
operator|!=
name|NIL
condition|;
name|temp
operator|=
name|temp
operator|->
name|CLink
control|)
for|for
control|(
name|bptr
operator|=
name|temp
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|backTrace
init|;
name|bptr
operator|!=
name|NIL
condition|;
name|bptr
operator|=
name|bptr
operator|->
name|CCLink
control|)
name|p
operator||=
name|CopyDelete
argument_list|(
name|bptr
operator|->
name|CCCom
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|Error
argument_list|(
literal|"Dangling References After Delete Defintion"
argument_list|,
name|WARNING
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|State
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the state of symbol n */
end_comment

begin_block
block|{
name|Command
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|SymbolTable
index|[
name|hash
argument_list|(
name|n
argument_list|)
index|]
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|CLink
control|)
if|if
condition|(
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
operator|==
name|n
condition|)
return|return
operator|(
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|)
return|;
return|return
operator|(
name|NONEXIST
operator|)
return|;
block|}
end_block

begin_macro
name|InitSymbol
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TableSize
condition|;
name|i
operator|++
control|)
name|SymbolTable
index|[
name|i
index|]
operator|=
name|NIL
expr_stmt|;
block|}
end_block

end_unit

