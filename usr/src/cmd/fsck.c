begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)fsck.c	4.13 (Berkeley) 81/03/09"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/filsys.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/fblk.h>
end_include

begin_include
include|#
directive|include
file|<sys/ino.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|SIG_TYP
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_define
define|#
directive|define
name|NDIRECT
value|(BSIZE/sizeof(struct direct))
end_define

begin_define
define|#
directive|define
name|SPERB
value|(BSIZE/sizeof(short))
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|MAXDUP
value|10
end_define

begin_comment
comment|/* limit on dup blks (per inode) */
end_comment

begin_define
define|#
directive|define
name|MAXBAD
value|10
end_define

begin_comment
comment|/* limit on bad blks (per inode) */
end_comment

begin_define
define|#
directive|define
name|STEPSIZE
value|9
end_define

begin_comment
comment|/* default step for freelist spacing */
end_comment

begin_define
define|#
directive|define
name|CYLSIZE
value|400
end_define

begin_comment
comment|/* default cyl size for spacing */
end_comment

begin_define
define|#
directive|define
name|MAXCYL
value|500
end_define

begin_comment
comment|/* maximum cylinder size */
end_comment

begin_define
define|#
directive|define
name|BITSPB
value|8
end_define

begin_comment
comment|/* number bits per byte */
end_comment

begin_define
define|#
directive|define
name|BITSHIFT
value|3
end_define

begin_comment
comment|/* log2(BITSPB) */
end_comment

begin_define
define|#
directive|define
name|BITMASK
value|07
end_define

begin_comment
comment|/* BITSPB-1 */
end_comment

begin_define
define|#
directive|define
name|LSTATE
value|2
end_define

begin_comment
comment|/* bits per inode state */
end_comment

begin_define
define|#
directive|define
name|STATEPB
value|(BITSPB/LSTATE)
end_define

begin_comment
comment|/* inode states per byte */
end_comment

begin_define
define|#
directive|define
name|USTATE
value|0
end_define

begin_comment
comment|/* inode not allocated */
end_comment

begin_define
define|#
directive|define
name|FSTATE
value|01
end_define

begin_comment
comment|/* inode is file */
end_comment

begin_define
define|#
directive|define
name|DSTATE
value|02
end_define

begin_comment
comment|/* inode is directory */
end_comment

begin_define
define|#
directive|define
name|CLEAR
value|03
end_define

begin_comment
comment|/* inode is to be cleared */
end_comment

begin_define
define|#
directive|define
name|SMASK
value|03
end_define

begin_comment
comment|/* mask for inode state */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dinode
name|DINODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|direct
name|DIRECT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ALLOC
value|((dp->di_mode& IFMT) != 0)
end_define

begin_define
define|#
directive|define
name|DIR
value|((dp->di_mode& IFMT) == IFDIR)
end_define

begin_define
define|#
directive|define
name|REG
value|((dp->di_mode& IFMT) == IFREG)
end_define

begin_define
define|#
directive|define
name|BLK
value|((dp->di_mode& IFMT) == IFBLK)
end_define

begin_define
define|#
directive|define
name|CHR
value|((dp->di_mode& IFMT) == IFCHR)
end_define

begin_define
define|#
directive|define
name|MPC
value|((dp->di_mode& IFMT) == IFMPC)
end_define

begin_define
define|#
directive|define
name|MPB
value|((dp->di_mode& IFMT) == IFMPB)
end_define

begin_define
define|#
directive|define
name|SPECIAL
value|(BLK || CHR || MPC || MPB)
end_define

begin_define
define|#
directive|define
name|NINOBLK
value|11
end_define

begin_comment
comment|/* num blks for raw reading */
end_comment

begin_define
define|#
directive|define
name|MAXRAW
value|110
end_define

begin_comment
comment|/* largest raw read (in blks) */
end_comment

begin_decl_stmt
name|daddr_t
name|startib
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* blk num of first in raw area */
end_comment

begin_decl_stmt
name|unsigned
name|niblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num of blks in raw area */
end_comment

begin_struct
struct|struct
name|bufarea
block|{
name|struct
name|bufarea
modifier|*
name|b_next
decl_stmt|;
comment|/* must be first */
name|daddr_t
name|b_bno
decl_stmt|;
union|union
block|{
name|char
name|b_buf
index|[
name|BSIZE
index|]
decl_stmt|;
comment|/* buffer space */
name|short
name|b_lnks
index|[
name|SPERB
index|]
decl_stmt|;
comment|/* link counts */
name|daddr_t
name|b_indir
index|[
name|NINDIR
index|]
decl_stmt|;
comment|/* indirect block */
name|struct
name|filsys
name|b_fs
decl_stmt|;
comment|/* super block */
name|struct
name|fblk
name|b_fb
decl_stmt|;
comment|/* free block */
name|struct
name|dinode
name|b_dinode
index|[
name|INOPB
index|]
decl_stmt|;
comment|/* inode block */
name|DIRECT
name|b_dir
index|[
name|NDIRECT
index|]
decl_stmt|;
comment|/* directory */
block|}
name|b_un
union|;
name|char
name|b_dirty
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|bufarea
name|BUFAREA
typedef|;
end_typedef

begin_decl_stmt
name|BUFAREA
name|inoblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode blocks */
end_comment

begin_decl_stmt
name|BUFAREA
name|fileblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* other blks in filesys */
end_comment

begin_decl_stmt
name|BUFAREA
name|sblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file system superblock */
end_comment

begin_decl_stmt
name|BUFAREA
modifier|*
name|poolhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to first buffer in pool */
end_comment

begin_define
define|#
directive|define
name|initbarea
parameter_list|(
name|x
parameter_list|)
value|(x)->b_dirty = 0;(x)->b_bno = (daddr_t)-1
end_define

begin_define
define|#
directive|define
name|dirty
parameter_list|(
name|x
parameter_list|)
value|(x)->b_dirty = 1
end_define

begin_define
define|#
directive|define
name|inodirty
parameter_list|()
value|inoblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|fbdirty
parameter_list|()
value|fileblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|sbdirty
parameter_list|()
value|sblk.b_dirty = 1
end_define

begin_define
define|#
directive|define
name|freeblk
value|fileblk.b_un.b_fb
end_define

begin_define
define|#
directive|define
name|dirblk
value|fileblk.b_un
end_define

begin_define
define|#
directive|define
name|superblk
value|sblk.b_un.b_fs
end_define

begin_struct
struct|struct
name|filecntl
block|{
name|int
name|rfdes
decl_stmt|;
name|int
name|wfdes
decl_stmt|;
name|int
name|mod
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|filecntl
name|dfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptors for filesys */
end_comment

begin_decl_stmt
name|struct
name|filecntl
name|sfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptors for scratch file */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|MEMSIZE
typedef|;
end_typedef

begin_decl_stmt
name|MEMSIZE
name|memsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* amt of memory we got */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_define
define|#
directive|define
name|MAXDATA
value|((MEMSIZE)54*1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_define
define|#
directive|define
name|MAXDATA
value|((MEMSIZE)400*1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DUPTBLSIZE
value|100
end_define

begin_comment
comment|/* num of dup blocks to remember */
end_comment

begin_decl_stmt
name|daddr_t
name|duplist
index|[
name|DUPTBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dup block table */
end_comment

begin_decl_stmt
name|daddr_t
modifier|*
name|enddup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry in dup table */
end_comment

begin_decl_stmt
name|daddr_t
modifier|*
name|muldup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* multiple dups part of table */
end_comment

begin_define
define|#
directive|define
name|MAXLNCNT
value|50
end_define

begin_comment
comment|/* num zero link cnts to remember */
end_comment

begin_decl_stmt
name|ino_t
name|badlncnt
index|[
name|MAXLNCNT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of inos with zero link cnts */
end_comment

begin_decl_stmt
name|ino_t
modifier|*
name|badlnp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next entry in table */
end_comment

begin_decl_stmt
name|char
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* salvage free block list */
end_comment

begin_decl_stmt
name|char
name|csflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* salvage free block list (conditional) */
end_comment

begin_decl_stmt
name|char
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume a no response */
end_comment

begin_decl_stmt
name|char
name|yflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assume a yes response */
end_comment

begin_decl_stmt
name|char
name|tflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scratch file specified */
end_comment

begin_decl_stmt
name|char
name|preen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* just fix normal inconsistencies */
end_comment

begin_decl_stmt
name|char
name|rplyflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* any questions asked? */
end_comment

begin_decl_stmt
name|char
name|hotroot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* checking root device */
end_comment

begin_decl_stmt
name|char
name|rawflg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read raw device */
end_comment

begin_decl_stmt
name|char
name|rmscr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remove scratch file when done */
end_comment

begin_decl_stmt
name|char
name|fixfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* corrupted free list */
end_comment

begin_decl_stmt
name|char
modifier|*
name|membase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base of memory we get */
end_comment

begin_decl_stmt
name|char
modifier|*
name|blkmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to primary blk allocation map */
end_comment

begin_decl_stmt
name|char
modifier|*
name|freemap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to secondary blk allocation map */
end_comment

begin_decl_stmt
name|char
modifier|*
name|statemap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to inode state table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pathp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to pathname position */
end_comment

begin_decl_stmt
name|char
modifier|*
name|thisname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to current pathname component */
end_comment

begin_decl_stmt
name|char
modifier|*
name|srchname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name being searched for in dir */
end_comment

begin_decl_stmt
name|char
name|pathname
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|scrfile
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lfname
init|=
literal|"lost+found"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|checklist
init|=
name|FSTAB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|lncntp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to link count table */
end_comment

begin_decl_stmt
name|int
name|cylsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num blocks per cylinder */
end_comment

begin_decl_stmt
name|int
name|stepsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num blocks for spacing purposes */
end_comment

begin_decl_stmt
name|int
name|badblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num of bad blks seen (per inode) */
end_comment

begin_decl_stmt
name|int
name|dupblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num of dup blks seen (per inode) */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|pfunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* function to call to chk blk */
end_comment

begin_decl_stmt
name|ino_t
name|inum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inode we are currently working on */
end_comment

begin_decl_stmt
name|ino_t
name|imax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of inodes */
end_comment

begin_decl_stmt
name|ino_t
name|parentdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i number of parent directory */
end_comment

begin_decl_stmt
name|ino_t
name|lastino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hiwater mark of inodes */
end_comment

begin_decl_stmt
name|ino_t
name|lfdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lost& found directory */
end_comment

begin_decl_stmt
name|ino_t
name|orphan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orphaned inode */
end_comment

begin_decl_stmt
name|off_t
name|filsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num blks seen in file */
end_comment

begin_decl_stmt
name|off_t
name|maxblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* largest logical blk in file */
end_comment

begin_decl_stmt
name|off_t
name|bmapsz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* num chars in blkmap */
end_comment

begin_decl_stmt
name|daddr_t
name|smapblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting blk of state map */
end_comment

begin_decl_stmt
name|daddr_t
name|lncntblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting blk of link cnt table */
end_comment

begin_decl_stmt
name|daddr_t
name|fmapblk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting blk of free map */
end_comment

begin_decl_stmt
name|daddr_t
name|n_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of free blocks */
end_comment

begin_decl_stmt
name|daddr_t
name|n_blks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks used */
end_comment

begin_decl_stmt
name|daddr_t
name|n_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of files seen */
end_comment

begin_decl_stmt
name|daddr_t
name|fmin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* block number of the first data block */
end_comment

begin_decl_stmt
name|daddr_t
name|fmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of blocks in the volume */
end_comment

begin_define
define|#
directive|define
name|howmany
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)+((y)-1))/(y))
end_define

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((((x)+((y)-1))/(y))*(y))
end_define

begin_define
define|#
directive|define
name|outrange
parameter_list|(
name|x
parameter_list|)
value|(x< fmin || x>= fmax)
end_define

begin_define
define|#
directive|define
name|zapino
parameter_list|(
name|x
parameter_list|)
value|clear((char *)(x),sizeof(DINODE))
end_define

begin_define
define|#
directive|define
name|setlncnt
parameter_list|(
name|x
parameter_list|)
value|dolncnt(x,0)
end_define

begin_define
define|#
directive|define
name|getlncnt
parameter_list|()
value|dolncnt(0,1)
end_define

begin_define
define|#
directive|define
name|declncnt
parameter_list|()
value|dolncnt(0,2)
end_define

begin_define
define|#
directive|define
name|setbmap
parameter_list|(
name|x
parameter_list|)
value|domap(x,0)
end_define

begin_define
define|#
directive|define
name|getbmap
parameter_list|(
name|x
parameter_list|)
value|domap(x,1)
end_define

begin_define
define|#
directive|define
name|clrbmap
parameter_list|(
name|x
parameter_list|)
value|domap(x,2)
end_define

begin_define
define|#
directive|define
name|setfmap
parameter_list|(
name|x
parameter_list|)
value|domap(x,0+4)
end_define

begin_define
define|#
directive|define
name|getfmap
parameter_list|(
name|x
parameter_list|)
value|domap(x,1+4)
end_define

begin_define
define|#
directive|define
name|clrfmap
parameter_list|(
name|x
parameter_list|)
value|domap(x,2+4)
end_define

begin_define
define|#
directive|define
name|setstate
parameter_list|(
name|x
parameter_list|)
value|dostate(x,0)
end_define

begin_define
define|#
directive|define
name|getstate
parameter_list|()
value|dostate(0,1)
end_define

begin_define
define|#
directive|define
name|DATA
value|1
end_define

begin_define
define|#
directive|define
name|ADDR
value|0
end_define

begin_define
define|#
directive|define
name|ALTERD
value|010
end_define

begin_define
define|#
directive|define
name|KEEPON
value|04
end_define

begin_define
define|#
directive|define
name|SKIP
value|02
end_define

begin_define
define|#
directive|define
name|STOP
value|01
end_define

begin_expr_stmt
name|int
argument_list|(
operator|*
name|signal
argument_list|()
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|long
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DINODE
modifier|*
name|ginode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|BUFAREA
modifier|*
name|getblk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|BUFAREA
modifier|*
name|search
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dirscan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|findino
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|catch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|mkentry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chgdd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pass1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pass1b
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pass2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pass3
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pass4
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pass5
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|devname
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|filename
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
name|sync
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
block|{
case|case
literal|'p'
case|:
name|preen
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|tflag
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
operator|||
operator|--
name|argc
operator|<=
literal|0
condition|)
name|errexit
argument_list|(
literal|"Bad -t option\n"
argument_list|)
expr_stmt|;
name|p
operator|=
name|scrfile
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|*
name|argv
condition|)
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* salvage flag */
name|stype
argument_list|(
operator|++
operator|*
name|argv
argument_list|)
expr_stmt|;
name|sflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* conditional salvage */
name|stype
argument_list|(
operator|++
operator|*
name|argv
argument_list|)
expr_stmt|;
name|csflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* default no answer flag */
case|case
literal|'N'
case|:
name|nflag
operator|++
expr_stmt|;
name|yflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* default yes answer flag */
case|case
literal|'Y'
case|:
name|yflag
operator|++
expr_stmt|;
name|nflag
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|errexit
argument_list|(
literal|"%c option?\n"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nflag
operator|&&
operator|(
name|sflag
operator|||
name|csflag
operator|)
condition|)
name|errexit
argument_list|(
literal|"Incompatible options: -n and -%s\n"
argument_list|,
name|sflag
condition|?
literal|"s"
else|:
literal|"S"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|&&
name|csflag
condition|)
name|sflag
operator|=
literal|0
expr_stmt|;
name|memsize
operator|=
operator|(
name|MEMSIZE
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|memsize
operator|=
name|MAXDATA
operator|-
name|memsize
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
while|while
condition|(
name|memsize
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|BUFAREA
argument_list|)
operator|&&
operator|(
name|membase
operator|=
name|sbrk
argument_list|(
name|memsize
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|memsize
operator|-=
literal|1024
expr_stmt|;
if|if
condition|(
name|memsize
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|BUFAREA
argument_list|)
condition|)
name|errexit
argument_list|(
literal|"Can't get memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
block|{
comment|/* arg list has file names */
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|hotroot
operator|=
literal|0
expr_stmt|;
name|check
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* use default checklist */
name|struct
name|fstab
modifier|*
name|fsp
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|passno
decl_stmt|,
name|anygtr
decl_stmt|,
name|sumstatus
init|=
literal|0
decl_stmt|;
name|passno
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|anygtr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setfsent
argument_list|()
operator|==
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't open checklist file: %s\n"
argument_list|,
name|FSTAB
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fsp
operator|=
name|getfsent
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RW
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fsp
operator|->
name|fs_type
argument_list|,
name|FSTAB_RO
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|preen
operator|==
literal|0
operator|||
name|passno
operator|==
literal|1
operator|&&
name|fsp
operator|->
name|fs_passno
operator|==
name|passno
condition|)
block|{
if|if
condition|(
name|blockcheck
argument_list|(
name|fsp
operator|->
name|fs_spec
argument_list|)
operator|==
name|NO
operator|&&
name|preen
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsp
operator|->
name|fs_passno
operator|>
name|passno
condition|)
name|anygtr
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|fsp
operator|->
name|fs_passno
operator|==
name|passno
condition|)
block|{
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
if|if
condition|(
name|blockcheck
argument_list|(
name|fsp
operator|->
name|fs_spec
argument_list|)
operator|==
name|NO
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preen
condition|)
block|{
name|int
name|status
decl_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|sumstatus
operator||=
name|status
expr_stmt|;
block|}
name|passno
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|anygtr
condition|)
do|;
if|if
condition|(
name|sumstatus
condition|)
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|endfsent
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|rawname
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|unrawname
argument_list|()
decl_stmt|;
end_decl_stmt

begin_macro
name|blockcheck
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|stat_slash
decl_stmt|,
name|stat_block
decl_stmt|,
name|stat_char
decl_stmt|;
name|char
modifier|*
name|raw
decl_stmt|;
name|int
name|looped
init|=
literal|0
decl_stmt|;
name|hotroot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|stat_slash
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|retry
label|:
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|stat_block
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|stat_block
operator|.
name|st_mode
operator|&
name|S_IFBLK
condition|)
block|{
name|raw
operator|=
name|rawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|raw
argument_list|,
operator|&
name|stat_char
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|stat_char
operator|.
name|st_mode
operator|&
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|stat_slash
operator|.
name|st_dev
operator|==
name|stat_block
operator|.
name|st_rdev
condition|)
block|{
name|hotroot
operator|++
expr_stmt|;
name|raw
operator|=
name|unrawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|check
argument_list|(
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%s is not a character device\n"
argument_list|,
name|raw
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stat_block
operator|.
name|st_mode
operator|&
name|S_IFCHR
condition|)
block|{
if|if
condition|(
name|looped
condition|)
block|{
name|error
argument_list|(
literal|"Can't make sense out of name %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|name
operator|=
name|unrawname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|looped
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|error
argument_list|(
literal|"Can't make sense out of name %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|unrawname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|dp
init|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
operator|(
name|stb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
condition|)
return|return
operator|(
name|cp
operator|)
return|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|!=
literal|'r'
condition|)
return|return
operator|(
name|cp
operator|)
return|;
name|strcpy
argument_list|(
name|dp
operator|+
literal|1
argument_list|,
name|dp
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rawname
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|rawbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|dp
init|=
name|rindex
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|rawbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
literal|'/'
expr_stmt|;
name|strcat
argument_list|(
name|rawbuf
argument_list|,
literal|"/r"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|rawbuf
argument_list|,
name|dp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rawbuf
operator|)
return|;
block|}
end_function

begin_macro
name|check
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|devname
operator|=
name|dev
expr_stmt|;
name|check1
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devname
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|check1
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|ino_t
modifier|*
name|blp
decl_stmt|;
name|ino_t
name|savino
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|BUFAREA
modifier|*
name|bp1
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
if|if
condition|(
name|setup
argument_list|(
name|dev
argument_list|)
operator|==
name|NO
condition|)
return|return;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"** Checking %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Phase 1 - Check Blocks and Sizes\n"
argument_list|)
expr_stmt|;
block|}
name|pfunc
operator|=
name|pass1
expr_stmt|;
for|for
control|(
name|inum
operator|=
literal|1
init|;
name|inum
operator|<=
name|imax
condition|;
name|inum
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ALLOC
condition|)
block|{
name|lastino
operator|=
name|inum
expr_stmt|;
if|if
condition|(
name|ftypeok
argument_list|(
name|dp
argument_list|)
operator|==
name|NO
condition|)
block|{
name|pfatal
argument_list|(
literal|"UNKNOWN FILE TYPE I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
name|YES
condition|)
block|{
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
name|n_files
operator|++
expr_stmt|;
if|if
condition|(
name|setlncnt
argument_list|(
name|dp
operator|->
name|di_nlink
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|badlnp
operator|<
operator|&
name|badlncnt
index|[
name|MAXLNCNT
index|]
condition|)
operator|*
name|badlnp
operator|++
operator|=
name|inum
expr_stmt|;
else|else
block|{
name|pfatal
argument_list|(
literal|"LINK COUNT TABLE OVERFLOW"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|setstate
argument_list|(
name|DIR
condition|?
name|DSTATE
else|:
name|FSTATE
argument_list|)
expr_stmt|;
name|badblk
operator|=
name|dupblk
operator|=
literal|0
expr_stmt|;
name|filsize
operator|=
literal|0
expr_stmt|;
name|maxblk
operator|=
literal|0
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|getstate
argument_list|()
operator|)
operator|==
name|DSTATE
operator|||
name|n
operator|==
name|FSTATE
condition|)
name|sizechk
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|di_mode
operator|!=
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"PARTIALLY ALLOCATED INODE I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
name|YES
condition|)
block|{
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|enddup
operator|!=
operator|&
name|duplist
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"INTERNAL ERROR: dups with -p"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"** Phase 1b - Rescan For More DUPS\n"
argument_list|)
expr_stmt|;
name|pfunc
operator|=
name|pass1b
expr_stmt|;
for|for
control|(
name|inum
operator|=
literal|1
init|;
name|inum
operator|<=
name|lastino
condition|;
name|inum
operator|++
control|)
block|{
if|if
condition|(
name|getstate
argument_list|()
operator|!=
name|USTATE
operator|&&
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|ckinode
argument_list|(
name|dp
argument_list|,
name|ADDR
argument_list|)
operator|&
name|STOP
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|rawflg
condition|)
block|{
if|if
condition|(
name|inoblk
operator|.
name|b_dirty
condition|)
name|bwrite
argument_list|(
operator|&
name|dfile
argument_list|,
name|membase
argument_list|,
name|startib
argument_list|,
operator|(
name|int
operator|)
name|niblk
operator|*
name|BSIZE
argument_list|)
expr_stmt|;
name|inoblk
operator|.
name|b_dirty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|poolhead
condition|)
block|{
name|clear
argument_list|(
name|membase
argument_list|,
name|niblk
operator|*
name|BSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|bp1
operator|=
name|poolhead
init|;
name|bp1
operator|->
name|b_next
condition|;
name|bp1
operator|=
name|bp1
operator|->
name|b_next
control|)
empty_stmt|;
name|bp2
operator|=
operator|&
operator|(
operator|(
name|BUFAREA
operator|*
operator|)
name|membase
operator|)
index|[
operator|(
name|niblk
operator|*
name|BSIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|BUFAREA
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|bp2
operator|>=
operator|(
name|BUFAREA
operator|*
operator|)
name|membase
condition|)
block|{
name|initbarea
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
name|bp2
operator|->
name|b_next
operator|=
name|bp1
operator|->
name|b_next
expr_stmt|;
name|bp1
operator|->
name|b_next
operator|=
name|bp2
expr_stmt|;
block|}
block|}
name|rawflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 2 - Check Pathnames\n"
argument_list|)
expr_stmt|;
name|inum
operator|=
name|ROOTINO
expr_stmt|;
name|thisname
operator|=
name|pathp
operator|=
name|pathname
expr_stmt|;
name|pfunc
operator|=
name|pass2
expr_stmt|;
switch|switch
condition|(
name|getstate
argument_list|()
condition|)
block|{
case|case
name|USTATE
case|:
name|errexit
argument_list|(
literal|"ROOT INODE UNALLOCATED. TERMINATING.\n"
argument_list|)
expr_stmt|;
case|case
name|FSTATE
case|:
name|pfatal
argument_list|(
literal|"ROOT INODE NOT DIRECTORY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
name|NO
operator|||
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|dp
operator|->
name|di_mode
operator|&=
operator|~
name|IFMT
expr_stmt|;
name|dp
operator|->
name|di_mode
operator||=
name|IFDIR
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|setstate
argument_list|(
name|DSTATE
argument_list|)
expr_stmt|;
case|case
name|DSTATE
case|:
name|descend
argument_list|()
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|pfatal
argument_list|(
literal|"DUPS/BAD IN ROOT INODE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|setstate
argument_list|(
name|DSTATE
argument_list|)
expr_stmt|;
name|descend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 3 - Check Connectivity\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|inum
operator|=
name|ROOTINO
init|;
name|inum
operator|<=
name|lastino
condition|;
name|inum
operator|++
control|)
block|{
if|if
condition|(
name|getstate
argument_list|()
operator|==
name|DSTATE
condition|)
block|{
name|pfunc
operator|=
name|findino
expr_stmt|;
name|srchname
operator|=
literal|".."
expr_stmt|;
name|savino
operator|=
name|inum
expr_stmt|;
do|do
block|{
name|orphan
operator|=
name|inum
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
break|break;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|parentdir
operator|=
literal|0
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inum
operator|=
name|parentdir
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
do|while
condition|(
name|getstate
argument_list|()
operator|==
name|DSTATE
condition|)
do|;
name|inum
operator|=
name|orphan
expr_stmt|;
if|if
condition|(
name|linkup
argument_list|()
operator|==
name|YES
condition|)
block|{
name|thisname
operator|=
name|pathp
operator|=
name|pathname
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'?'
expr_stmt|;
name|pfunc
operator|=
name|pass2
expr_stmt|;
name|descend
argument_list|()
expr_stmt|;
block|}
name|inum
operator|=
name|savino
expr_stmt|;
block|}
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 4 - Check Reference Counts\n"
argument_list|)
expr_stmt|;
name|pfunc
operator|=
name|pass4
expr_stmt|;
for|for
control|(
name|inum
operator|=
name|ROOTINO
init|;
name|inum
operator|<=
name|lastino
condition|;
name|inum
operator|++
control|)
block|{
switch|switch
condition|(
name|getstate
argument_list|()
condition|)
block|{
case|case
name|FSTATE
case|:
if|if
condition|(
name|n
operator|=
name|getlncnt
argument_list|()
condition|)
name|adjust
argument_list|(
operator|(
name|short
operator|)
name|n
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|blp
operator|=
name|badlncnt
init|;
name|blp
operator|<
name|badlnp
condition|;
name|blp
operator|++
control|)
if|if
condition|(
operator|*
name|blp
operator|==
name|inum
condition|)
block|{
name|clri
argument_list|(
literal|"UNREF"
argument_list|,
name|YES
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|DSTATE
case|:
name|clri
argument_list|(
literal|"UNREF"
argument_list|,
name|YES
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
name|clri
argument_list|(
literal|"BAD/DUP"
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|imax
operator|-
name|n_files
operator|!=
name|superblk
operator|.
name|s_tinode
condition|)
block|{
name|pwarn
argument_list|(
literal|"FREE INODE COUNT WRONG IN SUPERBLK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (FIXED)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
name|YES
condition|)
block|{
name|superblk
operator|.
name|s_tinode
operator|=
name|imax
operator|-
name|n_files
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
block|}
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 5 - Check Free List "
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|||
operator|(
name|csflag
operator|&&
name|rplyflag
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"(Ignored)\n"
argument_list|)
expr_stmt|;
name|fixfree
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|freemap
condition|)
name|copy
argument_list|(
name|blkmap
argument_list|,
name|freemap
argument_list|,
operator|(
name|MEMSIZE
operator|)
name|bmapsz
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|fmapblk
condition|;
name|blk
operator|++
control|)
block|{
name|bp1
operator|=
name|getblk
argument_list|(
operator|(
name|BUFAREA
operator|*
operator|)
name|NULL
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|bp2
operator|=
name|getblk
argument_list|(
operator|(
name|BUFAREA
operator|*
operator|)
name|NULL
argument_list|,
name|blk
operator|+
name|fmapblk
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|bp1
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|bp2
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|dirty
argument_list|(
name|bp2
argument_list|)
expr_stmt|;
block|}
block|}
name|badblk
operator|=
name|dupblk
operator|=
literal|0
expr_stmt|;
name|freeblk
operator|.
name|df_nfree
operator|=
name|superblk
operator|.
name|s_nfree
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NICFREE
condition|;
name|n
operator|++
control|)
name|freeblk
operator|.
name|df_free
index|[
name|n
index|]
operator|=
name|superblk
operator|.
name|s_free
index|[
name|n
index|]
expr_stmt|;
name|freechk
argument_list|()
expr_stmt|;
if|if
condition|(
name|badblk
condition|)
block|{
name|pfatal
argument_list|(
literal|"%d BAD BLKS IN FREE LIST"
argument_list|,
name|badblk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dupblk
condition|)
name|pwarn
argument_list|(
literal|"%d DUP BLKS IN FREE LIST\n"
argument_list|,
name|dupblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixfree
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n_blks
operator|+
name|n_free
operator|)
operator|!=
operator|(
name|fmax
operator|-
name|fmin
operator|)
condition|)
block|{
name|pwarn
argument_list|(
literal|"%ld BLK(S) MISSING\n"
argument_list|,
name|fmax
operator|-
name|fmin
operator|-
name|n_blks
operator|-
name|n_free
argument_list|)
expr_stmt|;
name|fixfree
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_free
operator|!=
name|superblk
operator|.
name|s_tfree
condition|)
block|{
name|pwarn
argument_list|(
literal|"FREE BLK COUNT WRONG IN SUPERBLK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (FIXED)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"FIX"
argument_list|)
operator|==
name|YES
condition|)
block|{
name|superblk
operator|.
name|s_tfree
operator|=
name|n_free
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fixfree
condition|)
block|{
name|pwarn
argument_list|(
literal|"BAD FREE LIST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (SALVAGED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"SALVAGE"
argument_list|)
operator|==
name|NO
condition|)
name|fixfree
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fixfree
condition|)
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"** Phase 6 - Salvage Free List\n"
argument_list|)
expr_stmt|;
name|makefree
argument_list|()
expr_stmt|;
name|n_free
operator|=
name|superblk
operator|.
name|s_tfree
expr_stmt|;
block|}
name|pwarn
argument_list|(
literal|"%ld files %ld blocks %ld free\n"
argument_list|,
name|n_files
argument_list|,
name|n_blks
argument_list|,
name|n_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfile
operator|.
name|mod
condition|)
block|{
name|time
argument_list|(
operator|&
name|superblk
operator|.
name|s_time
argument_list|)
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
name|ckfini
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|dfile
operator|.
name|mod
operator|&&
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n***** FILE SYSTEM WAS MODIFIED *****\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|errexit
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|,
argument|s3
argument_list|,
argument|s4
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pfatal is called when an inconsistency occurs  * which should not happen during normal operations.  * It prints a message and then dies.  * When not preening, this is just a printf.  */
end_comment

begin_macro
name|pfatal
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|preen
condition|)
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|preendie
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Fatal is called to terminate preening  * due to unexplainable inconsistency.  */
end_comment

begin_macro
name|preendie
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%s: UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY.\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Pwarn is like printf when not preening,  * or a warning (preceded by filename) when preening.  */
end_comment

begin_macro
name|pwarn
argument_list|(
argument|s
argument_list|,
argument|a1
argument_list|,
argument|a2
argument_list|,
argument|a3
argument_list|,
argument|a4
argument_list|,
argument|a5
argument_list|,
argument|a6
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ckinode
argument_list|(
argument|dp
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|DINODE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|flg
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|ret
expr_stmt|;
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|,
name|n
decl_stmt|;
name|daddr_t
name|iaddrs
index|[
name|NADDR
index|]
decl_stmt|;
if|if
condition|(
name|SPECIAL
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|l3tol
argument_list|(
name|iaddrs
argument_list|,
name|dp
operator|->
name|di_addr
argument_list|,
name|NADDR
argument_list|)
expr_stmt|;
name|func
operator|=
operator|(
name|flg
operator|==
name|ADDR
operator|)
condition|?
name|pfunc
else|:
name|dirscan
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|iaddrs
init|;
name|ap
operator|<
operator|&
name|iaddrs
index|[
name|NADDR
operator|-
literal|3
index|]
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|&&
operator|(
name|ret
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
operator|*
name|ap
argument_list|)
operator|)
operator|&
name|STOP
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
operator|&&
operator|(
name|ret
operator|=
name|iblock
argument_list|(
operator|*
name|ap
argument_list|,
name|n
argument_list|,
name|flg
argument_list|)
operator|)
operator|&
name|STOP
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ap
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|iblock
argument_list|(
argument|blk
argument_list|,
argument|ilevel
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|ilevel
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|BUFAREA
name|ib
decl_stmt|;
if|if
condition|(
name|flg
operator|==
name|ADDR
condition|)
block|{
name|func
operator|=
name|pfunc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|blk
argument_list|)
operator|)
operator|&
name|KEEPON
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
else|else
name|func
operator|=
name|dirscan
expr_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
comment|/* protect thyself */
return|return
operator|(
name|SKIP
operator|)
return|;
name|initbarea
argument_list|(
operator|&
name|ib
argument_list|)
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|ib
argument_list|,
name|blk
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SKIP
operator|)
return|;
name|ilevel
operator|--
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|ib
operator|.
name|b_un
operator|.
name|b_indir
init|;
name|ap
operator|<
operator|&
name|ib
operator|.
name|b_un
operator|.
name|b_indir
index|[
name|NINDIR
index|]
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ap
condition|)
block|{
if|if
condition|(
name|ilevel
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|iblock
argument_list|(
operator|*
name|ap
argument_list|,
name|ilevel
argument_list|,
name|flg
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&
name|STOP
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|pass1
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|blkerr
argument_list|(
literal|"BAD"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|badblk
operator|>=
name|MAXBAD
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE BAD BLKS I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
if|if
condition|(
name|getbmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|blkerr
argument_list|(
literal|"DUP"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|dupblk
operator|>=
name|MAXDUP
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE DUP BLKS I=%u"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
if|if
condition|(
name|enddup
operator|>=
operator|&
name|duplist
index|[
name|DUPTBLSIZE
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"DUP TABLE OVERFLOW."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|muldup
condition|;
name|dlp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|dlp
operator|==
name|blk
condition|)
block|{
operator|*
name|enddup
operator|++
operator|=
name|blk
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dlp
operator|>=
name|muldup
condition|)
block|{
operator|*
name|enddup
operator|++
operator|=
operator|*
name|muldup
expr_stmt|;
operator|*
name|muldup
operator|++
operator|=
name|blk
expr_stmt|;
block|}
block|}
else|else
block|{
name|n_blks
operator|++
expr_stmt|;
name|setbmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
name|filsize
operator|++
expr_stmt|;
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|pass1b
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
return|return
operator|(
name|SKIP
operator|)
return|;
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|muldup
condition|;
name|dlp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|dlp
operator|==
name|blk
condition|)
block|{
name|blkerr
argument_list|(
literal|"DUP"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
operator|*
name|dlp
operator|=
operator|*
operator|--
name|muldup
expr_stmt|;
operator|*
name|muldup
operator|=
name|blk
expr_stmt|;
return|return
operator|(
name|muldup
operator|==
name|duplist
condition|?
name|STOP
else|:
name|KEEPON
operator|)
return|;
block|}
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pass2
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|inum
operator|=
name|dirp
operator|->
name|d_ino
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|thisname
operator|=
name|pathp
expr_stmt|;
for|for
control|(
name|p
operator|=
name|dirp
operator|->
name|d_name
init|;
name|p
operator|<
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
index|]
condition|;
control|)
if|if
condition|(
operator|(
operator|*
name|pathp
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
operator|--
name|pathp
expr_stmt|;
break|break;
block|}
operator|*
name|pathp
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|inum
operator|>
name|imax
operator|||
name|inum
operator|<
name|ROOTINO
condition|)
name|n
operator|=
name|direrr
argument_list|(
literal|"I OUT OF RANGE"
argument_list|)
expr_stmt|;
else|else
block|{
name|again
label|:
switch|switch
condition|(
name|getstate
argument_list|()
condition|)
block|{
case|case
name|USTATE
case|:
name|n
operator|=
name|direrr
argument_list|(
literal|"UNALLOCATED"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEAR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|direrr
argument_list|(
literal|"DUP/BAD"
argument_list|)
operator|)
operator|==
name|YES
condition|)
break|break;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
break|break;
name|setstate
argument_list|(
name|DIR
condition|?
name|DSTATE
else|:
name|FSTATE
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|FSTATE
case|:
name|declncnt
argument_list|()
expr_stmt|;
break|break;
case|case
name|DSTATE
case|:
name|declncnt
argument_list|()
expr_stmt|;
name|descend
argument_list|()
expr_stmt|;
block|}
block|}
name|pathp
operator|=
name|thisname
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NO
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|dirp
operator|->
name|d_ino
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|KEEPON
operator||
name|ALTERD
operator|)
return|;
block|}
end_block

begin_macro
name|pass4
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|dlp
decl_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
return|return
operator|(
name|SKIP
operator|)
return|;
if|if
condition|(
name|getbmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
for|for
control|(
name|dlp
operator|=
name|duplist
init|;
name|dlp
operator|<
name|enddup
condition|;
name|dlp
operator|++
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|blk
condition|)
block|{
operator|*
name|dlp
operator|=
operator|*
operator|--
name|enddup
expr_stmt|;
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
name|clrbmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|n_blks
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|pass5
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|fixfree
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"BAD BLOCKS IN FREE LIST."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|badblk
operator|>=
name|MAXBAD
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE BAD BLKS IN FREE LIST."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
if|if
condition|(
name|getfmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|fixfree
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|dupblk
operator|>=
name|DUPTBLSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"EXCESSIVE DUP BLKS IN FREE LIST."
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
else|else
block|{
name|n_free
operator|++
expr_stmt|;
name|setfmap
argument_list|(
name|blk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|blkerr
argument_list|(
argument|s
argument_list|,
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pfatal
argument_list|(
literal|"%ld %s I=%u"
argument_list|,
name|blk
argument_list|,
name|s
argument_list|,
name|inum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|setstate
argument_list|(
name|CLEAR
argument_list|)
expr_stmt|;
comment|/* mark for possible clearing */
block|}
end_block

begin_macro
name|descend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|savname
decl_stmt|;
name|off_t
name|savsize
decl_stmt|;
name|setstate
argument_list|(
name|FSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
name|savname
operator|=
name|thisname
expr_stmt|;
operator|*
name|pathp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|savsize
operator|=
name|filsize
expr_stmt|;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
name|thisname
operator|=
name|savname
expr_stmt|;
operator|*
operator|--
name|pathp
operator|=
literal|0
expr_stmt|;
name|filsize
operator|=
name|savsize
expr_stmt|;
block|}
end_block

begin_macro
name|dirscan
argument_list|(
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DIRECT
modifier|*
name|dirp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|DIRECT
name|direntry
decl_stmt|;
if|if
condition|(
name|outrange
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|filsize
operator|-=
name|BSIZE
expr_stmt|;
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
for|for
control|(
name|dirp
operator|=
name|dirblk
operator|.
name|b_dir
init|;
name|dirp
operator|<
operator|&
name|dirblk
operator|.
name|b_dir
index|[
name|NDIRECT
index|]
operator|&&
name|filsize
operator|>
literal|0
condition|;
name|dirp
operator|++
operator|,
name|filsize
operator|-=
sizeof|sizeof
argument_list|(
name|DIRECT
argument_list|)
control|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
name|blk
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|filsize
operator|-=
operator|(
operator|&
name|dirblk
operator|.
name|b_dir
index|[
name|NDIRECT
index|]
operator|-
name|dirp
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|DIRECT
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKIP
operator|)
return|;
block|}
name|p1
operator|=
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|direntry
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
while|while
condition|(
name|p1
operator|>
operator|(
name|char
operator|*
operator|)
name|dirp
condition|)
operator|*
operator|--
name|p2
operator|=
operator|*
operator|--
name|p1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
call|(
modifier|*
name|pfunc
call|)
argument_list|(
operator|&
name|direntry
argument_list|)
operator|)
operator|&
name|ALTERD
condition|)
block|{
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
name|blk
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p1
operator|=
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
name|p2
operator|=
operator|&
name|direntry
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
expr_stmt|;
while|while
condition|(
name|p1
operator|>
operator|(
name|char
operator|*
operator|)
name|dirp
condition|)
operator|*
operator|--
name|p1
operator|=
operator|*
operator|--
name|p2
expr_stmt|;
name|fbdirty
argument_list|()
expr_stmt|;
block|}
else|else
name|n
operator|&=
operator|~
name|ALTERD
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|&
name|STOP
condition|)
return|return
operator|(
name|n
operator|)
return|;
block|}
return|return
operator|(
name|filsize
operator|>
literal|0
condition|?
name|KEEPON
else|:
name|STOP
operator|)
return|;
block|}
end_block

begin_macro
name|direrr
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
name|pwarn
argument_list|(
literal|"%s "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|!=
name|NULL
operator|&&
name|ftypeok
argument_list|(
name|dp
argument_list|)
condition|)
name|pfatal
argument_list|(
literal|"%s=%s"
argument_list|,
name|DIR
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
else|else
name|pfatal
argument_list|(
literal|"NAME=%s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|reply
argument_list|(
literal|"REMOVE"
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|adjust
argument_list|(
name|lcnt
argument_list|)
specifier|register
name|short
name|lcnt
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|di_nlink
operator|==
name|lcnt
condition|)
block|{
if|if
condition|(
name|linkup
argument_list|()
operator|==
name|NO
condition|)
name|clri
argument_list|(
literal|"UNREF"
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pwarn
argument_list|(
literal|"LINK COUNT %s"
argument_list|,
operator|(
name|lfdir
operator|==
name|inum
operator|)
condition|?
name|lfname
else|:
operator|(
name|DIR
condition|?
literal|"DIR"
else|:
literal|"FILE"
operator|)
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|" COUNT %d SHOULD BE %d"
argument_list|,
name|dp
operator|->
name|di_nlink
argument_list|,
name|dp
operator|->
name|di_nlink
operator|-
name|lcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
block|{
if|if
condition|(
name|lcnt
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|preendie
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" (ADJUSTED)\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"ADJUST"
argument_list|)
operator|==
name|YES
condition|)
block|{
name|dp
operator|->
name|di_nlink
operator|-=
name|lcnt
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|clri
argument_list|(
argument|s
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|flg
operator|==
name|YES
condition|)
block|{
name|pwarn
argument_list|(
literal|"%s %s"
argument_list|,
name|s
argument_list|,
name|DIR
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|||
name|reply
argument_list|(
literal|"CLEAR"
argument_list|)
operator|==
name|YES
condition|)
block|{
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (CLEARED)\n"
argument_list|)
expr_stmt|;
name|n_files
operator|--
expr_stmt|;
name|pfunc
operator|=
name|pass4
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|ADDR
argument_list|)
expr_stmt|;
name|zapino
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|setup
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
specifier|register
name|MEMSIZE
name|msize
decl_stmt|;
name|char
modifier|*
name|mbase
decl_stmt|;
name|daddr_t
name|bcnt
decl_stmt|,
name|nscrblk
decl_stmt|;
name|dev_t
name|rootdev
decl_stmt|;
name|off_t
name|smapsz
decl_stmt|,
name|lncntsz
decl_stmt|,
name|totsz
decl_stmt|;
name|struct
name|stat
name|statarea
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"/"
argument_list|,
operator|&
name|statarea
argument_list|)
operator|<
literal|0
condition|)
name|errexit
argument_list|(
literal|"Can't stat root\n"
argument_list|)
expr_stmt|;
name|rootdev
operator|=
name|statarea
operator|.
name|st_dev
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dev
argument_list|,
operator|&
name|statarea
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't stat %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|rawflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|statarea
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFBLK
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|statarea
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFCHR
condition|)
name|rawflg
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reply
argument_list|(
literal|"file is not a block or character device; OK"
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|rootdev
operator|==
name|statarea
operator|.
name|st_rdev
condition|)
name|hotroot
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dfile
operator|.
name|rfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't open %s\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
operator|(
name|dfile
operator|.
name|wfdes
operator|=
name|open
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dfile
operator|.
name|wfdes
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"NO WRITE ACCESS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (NO WRITE)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fixfree
operator|=
literal|0
expr_stmt|;
name|dfile
operator|.
name|mod
operator|=
literal|0
expr_stmt|;
name|n_files
operator|=
name|n_blks
operator|=
name|n_free
operator|=
literal|0
expr_stmt|;
name|muldup
operator|=
name|enddup
operator|=
operator|&
name|duplist
index|[
literal|0
index|]
expr_stmt|;
name|badlnp
operator|=
operator|&
name|badlncnt
index|[
literal|0
index|]
expr_stmt|;
name|lfdir
operator|=
literal|0
expr_stmt|;
name|rplyflag
operator|=
literal|0
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|sblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|initbarea
argument_list|(
operator|&
name|inoblk
argument_list|)
expr_stmt|;
name|sfile
operator|.
name|wfdes
operator|=
name|sfile
operator|.
name|rfdes
operator|=
operator|-
literal|1
expr_stmt|;
name|rmscr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|sblk
argument_list|,
name|SUPERB
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ckfini
argument_list|()
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|imax
operator|=
operator|(
operator|(
name|ino_t
operator|)
name|superblk
operator|.
name|s_isize
operator|-
operator|(
name|SUPERB
operator|+
literal|1
operator|)
operator|)
operator|*
name|INOPB
expr_stmt|;
name|fmin
operator|=
operator|(
name|daddr_t
operator|)
name|superblk
operator|.
name|s_isize
expr_stmt|;
comment|/* first data blk num */
name|fmax
operator|=
name|superblk
operator|.
name|s_fsize
expr_stmt|;
comment|/* first invalid blk num */
if|if
condition|(
name|fmin
operator|>=
name|fmax
operator|||
operator|(
name|imax
operator|/
name|INOPB
operator|)
operator|!=
operator|(
operator|(
name|ino_t
operator|)
name|superblk
operator|.
name|s_isize
operator|-
operator|(
name|SUPERB
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|pfatal
argument_list|(
literal|"Size check: fsize %ld isize %d"
argument_list|,
name|superblk
operator|.
name|s_fsize
argument_list|,
name|superblk
operator|.
name|s_isize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ckfini
argument_list|()
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"File System: %.12s\n\n"
argument_list|,
name|superblk
operator|.
name|s_fsmnt
argument_list|)
expr_stmt|;
name|bmapsz
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
name|fmax
argument_list|,
name|BITSPB
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lncntp
argument_list|)
argument_list|)
expr_stmt|;
name|smapsz
operator|=
name|roundup
argument_list|(
name|howmany
argument_list|(
call|(
name|long
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
argument_list|,
name|STATEPB
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lncntp
argument_list|)
argument_list|)
expr_stmt|;
name|lncntsz
operator|=
call|(
name|long
call|)
argument_list|(
name|imax
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|lncntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmapsz
operator|>
name|smapsz
operator|+
name|lncntsz
condition|)
name|smapsz
operator|=
name|bmapsz
operator|-
name|lncntsz
expr_stmt|;
name|totsz
operator|=
name|bmapsz
operator|+
name|smapsz
operator|+
name|lncntsz
expr_stmt|;
name|msize
operator|=
name|memsize
expr_stmt|;
name|mbase
operator|=
name|membase
expr_stmt|;
if|if
condition|(
name|rawflg
condition|)
block|{
if|if
condition|(
name|msize
operator|<
call|(
name|MEMSIZE
call|)
argument_list|(
name|NINOBLK
operator|*
name|BSIZE
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|BUFAREA
argument_list|)
condition|)
name|rawflg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|msize
operator|-=
operator|(
name|MEMSIZE
operator|)
name|NINOBLK
operator|*
name|BSIZE
expr_stmt|;
name|mbase
operator|+=
operator|(
name|MEMSIZE
operator|)
name|NINOBLK
operator|*
name|BSIZE
expr_stmt|;
name|niblk
operator|=
name|NINOBLK
expr_stmt|;
name|startib
operator|=
name|fmax
expr_stmt|;
block|}
block|}
name|clear
argument_list|(
name|mbase
argument_list|,
name|msize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_t
operator|)
name|msize
operator|<
name|totsz
condition|)
block|{
name|bmapsz
operator|=
name|roundup
argument_list|(
name|bmapsz
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|smapsz
operator|=
name|roundup
argument_list|(
name|smapsz
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|lncntsz
operator|=
name|roundup
argument_list|(
name|lncntsz
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|nscrblk
operator|=
operator|(
name|bmapsz
operator|+
name|smapsz
operator|+
name|lncntsz
operator|)
operator|>>
name|BSHIFT
expr_stmt|;
if|if
condition|(
name|tflag
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nNEED SCRATCH FILE (%ld BLKS)\n"
argument_list|,
name|nscrblk
argument_list|)
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|"ENTER FILENAME:  "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|getline
argument_list|(
name|stdin
argument_list|,
name|scrfile
argument_list|,
sizeof|sizeof
argument_list|(
name|scrfile
argument_list|)
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|errexit
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|scrfile
argument_list|,
operator|&
name|statarea
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|statarea
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
name|rmscr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sfile
operator|.
name|wfdes
operator|=
name|creat
argument_list|(
name|scrfile
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|sfile
operator|.
name|rfdes
operator|=
name|open
argument_list|(
name|scrfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Can't create %s\n"
argument_list|,
name|scrfile
argument_list|)
expr_stmt|;
name|ckfini
argument_list|()
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|bp
operator|=
operator|&
operator|(
operator|(
name|BUFAREA
operator|*
operator|)
name|mbase
operator|)
index|[
operator|(
name|msize
operator|/
sizeof|sizeof
argument_list|(
name|BUFAREA
argument_list|)
operator|)
index|]
expr_stmt|;
name|poolhead
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|--
name|bp
operator|>=
operator|(
name|BUFAREA
operator|*
operator|)
name|mbase
condition|)
block|{
name|initbarea
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_next
operator|=
name|poolhead
expr_stmt|;
name|poolhead
operator|=
name|bp
expr_stmt|;
block|}
name|bp
operator|=
name|poolhead
expr_stmt|;
for|for
control|(
name|bcnt
operator|=
literal|0
init|;
name|bcnt
operator|<
name|nscrblk
condition|;
name|bcnt
operator|++
control|)
block|{
name|bp
operator|->
name|b_bno
operator|=
name|bcnt
expr_stmt|;
name|dirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|flush
argument_list|(
operator|&
name|sfile
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|blkmap
operator|=
name|freemap
operator|=
name|statemap
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|lncntp
operator|=
operator|(
name|short
operator|*
operator|)
name|NULL
expr_stmt|;
name|smapblk
operator|=
name|bmapsz
operator|/
name|BSIZE
expr_stmt|;
name|lncntblk
operator|=
name|smapblk
operator|+
name|smapsz
operator|/
name|BSIZE
expr_stmt|;
name|fmapblk
operator|=
name|smapblk
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rawflg
operator|&&
operator|(
name|off_t
operator|)
name|msize
operator|>
name|totsz
operator|+
name|BSIZE
condition|)
block|{
name|niblk
operator|+=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|off_t
operator|)
name|msize
operator|-
name|totsz
argument_list|)
operator|>>
name|BSHIFT
expr_stmt|;
if|if
condition|(
name|niblk
operator|>
name|MAXRAW
condition|)
name|niblk
operator|=
name|MAXRAW
expr_stmt|;
name|msize
operator|=
name|memsize
operator|-
operator|(
name|niblk
operator|*
name|BSIZE
operator|)
expr_stmt|;
name|mbase
operator|=
name|membase
operator|+
operator|(
name|niblk
operator|*
name|BSIZE
operator|)
expr_stmt|;
block|}
name|poolhead
operator|=
name|NULL
expr_stmt|;
name|blkmap
operator|=
name|mbase
expr_stmt|;
name|statemap
operator|=
operator|&
name|mbase
index|[
operator|(
name|MEMSIZE
operator|)
name|bmapsz
index|]
expr_stmt|;
name|freemap
operator|=
name|statemap
expr_stmt|;
name|lncntp
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|statemap
index|[
operator|(
name|MEMSIZE
operator|)
name|smapsz
index|]
expr_stmt|;
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_function
name|DINODE
modifier|*
name|ginode
parameter_list|()
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|mbase
decl_stmt|;
name|daddr_t
name|iblk
decl_stmt|;
if|if
condition|(
name|inum
operator|>
name|imax
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|iblk
operator|=
name|itod
argument_list|(
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rawflg
condition|)
block|{
name|mbase
operator|=
name|membase
expr_stmt|;
if|if
condition|(
name|iblk
operator|<
name|startib
operator|||
name|iblk
operator|>=
name|startib
operator|+
name|niblk
condition|)
block|{
if|if
condition|(
name|inoblk
operator|.
name|b_dirty
condition|)
name|bwrite
argument_list|(
operator|&
name|dfile
argument_list|,
name|mbase
argument_list|,
name|startib
argument_list|,
operator|(
name|int
operator|)
name|niblk
operator|*
name|BSIZE
argument_list|)
expr_stmt|;
name|inoblk
operator|.
name|b_dirty
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
operator|&
name|dfile
argument_list|,
name|mbase
argument_list|,
name|iblk
argument_list|,
operator|(
name|int
operator|)
name|niblk
operator|*
name|BSIZE
argument_list|)
operator|==
name|NO
condition|)
block|{
name|startib
operator|=
name|fmax
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|startib
operator|=
name|iblk
expr_stmt|;
block|}
name|dp
operator|=
operator|(
name|DINODE
operator|*
operator|)
operator|&
name|mbase
index|[
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|iblk
operator|-
name|startib
operator|)
operator|<<
name|BSHIFT
argument_list|)
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getblk
argument_list|(
operator|&
name|inoblk
argument_list|,
name|iblk
argument_list|)
operator|!=
name|NULL
condition|)
name|dp
operator|=
name|inoblk
operator|.
name|b_un
operator|.
name|b_dinode
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dp
operator|+
name|itoo
argument_list|(
name|inum
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|ftypeok
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|DINODE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|dp
operator|->
name|di_mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFDIR
case|:
case|case
name|IFREG
case|:
case|case
name|IFBLK
case|:
case|case
name|IFCHR
case|:
case|case
name|IFMPC
case|:
case|case
name|IFMPB
case|:
return|return
operator|(
name|YES
operator|)
return|;
default|default:
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|reply
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|preen
condition|)
name|pfatal
argument_list|(
literal|"INTERNAL ERROR: GOT TO reply()"
argument_list|)
expr_stmt|;
name|rplyflag
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s? "
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|csflag
operator|||
name|dfile
operator|.
name|wfdes
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" no\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|yflag
condition|)
block|{
name|printf
argument_list|(
literal|" yes\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
if|if
condition|(
name|getline
argument_list|(
name|stdin
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
operator|==
name|EOF
condition|)
name|errexit
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
return|return
operator|(
name|YES
operator|)
return|;
else|else
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|fp
argument_list|,
argument|loc
argument_list|,
argument|maxlen
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastloc
decl_stmt|;
name|p
operator|=
name|loc
expr_stmt|;
name|lastloc
operator|=
operator|&
name|p
index|[
name|maxlen
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|n
argument_list|)
operator|&&
name|p
operator|<
name|lastloc
condition|)
operator|*
name|p
operator|++
operator|=
name|n
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|-
name|loc
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|stype
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
block|{
name|cylsize
operator|=
literal|200
expr_stmt|;
name|stepsize
operator|=
literal|5
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'4'
condition|)
block|{
name|cylsize
operator|=
literal|418
expr_stmt|;
name|stepsize
operator|=
literal|9
expr_stmt|;
return|return;
block|}
block|}
name|cylsize
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
name|stepsize
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stepsize
operator|<=
literal|0
operator|||
name|stepsize
operator|>
name|cylsize
operator|||
name|cylsize
operator|<=
literal|0
operator|||
name|cylsize
operator|>
name|MAXCYL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid -s argument, defaults assumed\n"
argument_list|)
expr_stmt|;
name|cylsize
operator|=
name|stepsize
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dostate
argument_list|(
argument|s
argument_list|,
argument|flg
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|byte
decl_stmt|,
name|shift
decl_stmt|;
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
name|byte
operator|=
operator|(
name|inum
operator|)
operator|/
name|STATEPB
expr_stmt|;
name|shift
operator|=
name|LSTATE
operator|*
operator|(
operator|(
name|inum
operator|)
operator|%
name|STATEPB
operator|)
expr_stmt|;
if|if
condition|(
name|statemap
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
operator|&
name|statemap
index|[
name|byte
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|getblk
argument_list|(
operator|(
name|BUFAREA
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|daddr_t
call|)
argument_list|(
name|smapblk
operator|+
operator|(
name|byte
operator|/
name|BSIZE
operator|)
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|"Fatal I/O error\n"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_buf
index|[
name|byte
operator|%
name|BSIZE
index|]
expr_stmt|;
switch|switch
condition|(
name|flg
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|p
operator|&=
operator|~
operator|(
name|SMASK
operator|<<
operator|(
name|shift
operator|)
operator|)
expr_stmt|;
operator|*
name|p
operator||=
name|s
operator|<<
operator|(
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|dirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
operator|(
operator|*
name|p
operator|>>
operator|(
name|shift
operator|)
operator|)
operator|&
name|SMASK
operator|)
return|;
block|}
return|return
operator|(
name|USTATE
operator|)
return|;
block|}
end_block

begin_macro
name|domap
argument_list|(
argument|blk
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|unsigned
name|n
decl_stmt|;
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
name|off_t
name|byte
decl_stmt|;
name|byte
operator|=
name|blk
operator|>>
name|BITSHIFT
expr_stmt|;
name|n
operator|=
literal|1
operator|<<
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|blk
operator|&
name|BITMASK
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|flg
operator|&
literal|04
condition|)
block|{
name|p
operator|=
name|freemap
expr_stmt|;
name|blk
operator|=
name|fmapblk
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|blkmap
expr_stmt|;
name|blk
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|p
operator|+=
operator|(
name|unsigned
operator|)
name|byte
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|getblk
argument_list|(
operator|(
name|BUFAREA
operator|*
operator|)
name|NULL
argument_list|,
name|blk
operator|+
operator|(
name|byte
operator|>>
name|BSHIFT
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|"Fatal I/O error\n"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_buf
index|[
call|(
name|unsigned
call|)
argument_list|(
name|byte
operator|&
name|BMASK
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|flg
operator|&
literal|03
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|p
operator||=
name|n
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|n
operator|&=
operator|*
name|p
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|&=
operator|~
name|n
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|dirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|dolncnt
argument_list|(
argument|val
argument_list|,
argument|flg
argument_list|)
end_macro

begin_decl_stmt
name|short
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|sp
decl_stmt|;
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|lncntp
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|=
operator|&
name|lncntp
index|[
name|inum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|getblk
argument_list|(
operator|(
name|BUFAREA
operator|*
operator|)
name|NULL
argument_list|,
call|(
name|daddr_t
call|)
argument_list|(
name|lncntblk
operator|+
operator|(
name|inum
operator|/
name|SPERB
operator|)
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errexit
argument_list|(
literal|"Fatal I/O error\n"
argument_list|)
expr_stmt|;
else|else
name|sp
operator|=
operator|&
name|bp
operator|->
name|b_un
operator|.
name|b_lnks
index|[
name|inum
operator|%
name|SPERB
index|]
expr_stmt|;
switch|switch
condition|(
name|flg
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|sp
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|(
operator|*
name|sp
operator|)
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|dirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|sp
operator|)
return|;
block|}
end_block

begin_function
name|BUFAREA
modifier|*
name|getblk
parameter_list|(
name|bp
parameter_list|,
name|blk
parameter_list|)
name|daddr_t
name|blk
decl_stmt|;
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|search
argument_list|(
name|blk
argument_list|)
expr_stmt|;
name|fcp
operator|=
operator|&
name|sfile
expr_stmt|;
block|}
else|else
name|fcp
operator|=
operator|&
name|dfile
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|==
name|blk
condition|)
return|return
operator|(
name|bp
operator|)
return|;
name|flush
argument_list|(
name|fcp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|fcp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|blk
argument_list|,
name|BSIZE
argument_list|)
operator|!=
name|NO
condition|)
block|{
name|bp
operator|->
name|b_bno
operator|=
name|blk
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|bp
operator|->
name|b_bno
operator|=
operator|(
name|daddr_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|flush
argument_list|(
argument|fcp
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|BUFAREA
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
block|{
name|bwrite
argument_list|(
name|fcp
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_buf
argument_list|,
name|bp
operator|->
name|b_bno
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|rwerr
argument_list|(
argument|s
argument_list|,
argument|blk
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pfatal
argument_list|(
literal|"CAN NOT %s: BLK %ld"
argument_list|,
name|s
argument_list|,
name|blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
argument_list|(
literal|"CONTINUE"
argument_list|)
operator|==
name|NO
condition|)
name|errexit
argument_list|(
literal|"Program terminated\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|sizechk
argument_list|(
name|dp
argument_list|)
specifier|register
name|DINODE
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* 	if (maxblk != howmany(dp->di_size, BSIZE)) 		printf("POSSIBLE FILE SIZE ERROR I=%u (%ld,%ld)\n\n", 		    inum, maxblk, howmany(dp->di_size,BSIZE)); */
if|if
condition|(
name|DIR
operator|&&
operator|(
name|dp
operator|->
name|di_size
operator|%
sizeof|sizeof
argument_list|(
name|DIRECT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pwarn
argument_list|(
literal|"DIRECTORY MISALIGNED I=%u\n"
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|ckfini
argument_list|()
end_macro

begin_block
block|{
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|sblk
argument_list|)
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|inoblk
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfile
operator|.
name|rfdes
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dfile
operator|.
name|wfdes
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sfile
operator|.
name|rfdes
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sfile
operator|.
name|wfdes
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmscr
condition|)
block|{
name|unlink
argument_list|(
name|scrfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|pinode
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|uidbuf
index|[
literal|200
index|]
decl_stmt|;
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|" I=%u "
argument_list|,
name|inum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|" OWNER="
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpw
argument_list|(
operator|(
name|int
operator|)
name|dp
operator|->
name|di_uid
argument_list|,
name|uidbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|p
operator|=
name|uidbuf
init|;
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|uidbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|dp
operator|->
name|di_uid
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"MODE=%o\n"
argument_list|,
name|dp
operator|->
name|di_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SIZE=%ld "
argument_list|,
name|dp
operator|->
name|di_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|ctime
argument_list|(
operator|&
name|dp
operator|->
name|di_mtime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MTIME=%12.12s %4.4s "
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|p
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|copy
argument_list|(
name|fp
argument_list|,
name|tp
argument_list|,
name|size
argument_list|)
specifier|register
name|char
operator|*
name|tp
operator|,
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MEMSIZE
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|size
operator|--
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|freechk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|daddr_t
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
name|freeblk
operator|.
name|df_nfree
operator|==
literal|0
condition|)
return|return;
do|do
block|{
if|if
condition|(
name|freeblk
operator|.
name|df_nfree
operator|<=
literal|0
operator|||
name|freeblk
operator|.
name|df_nfree
operator|>
name|NICFREE
condition|)
block|{
name|pfatal
argument_list|(
literal|"BAD FREEBLK COUNT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fixfree
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|ap
operator|=
operator|&
name|freeblk
operator|.
name|df_free
index|[
name|freeblk
operator|.
name|df_nfree
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|ap
operator|>
operator|&
name|freeblk
operator|.
name|df_free
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|pass5
argument_list|(
operator|*
name|ap
argument_list|)
operator|==
name|STOP
condition|)
return|return;
block|}
if|if
condition|(
operator|*
name|ap
operator|==
operator|(
name|daddr_t
operator|)
literal|0
operator|||
name|pass5
argument_list|(
operator|*
name|ap
argument_list|)
operator|!=
name|KEEPON
condition|)
return|return;
block|}
do|while
condition|(
name|getblk
argument_list|(
operator|&
name|fileblk
argument_list|,
operator|*
name|ap
argument_list|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_block

begin_macro
name|makefree
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|cyl
operator|,
name|step
expr_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|flg
index|[
name|MAXCYL
index|]
decl_stmt|;
name|short
name|addr
index|[
name|MAXCYL
index|]
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|,
name|baseblk
decl_stmt|;
name|superblk
operator|.
name|s_nfree
operator|=
literal|0
expr_stmt|;
name|superblk
operator|.
name|s_flock
operator|=
literal|0
expr_stmt|;
name|superblk
operator|.
name|s_fmod
operator|=
literal|0
expr_stmt|;
name|superblk
operator|.
name|s_tfree
operator|=
literal|0
expr_stmt|;
name|superblk
operator|.
name|s_ninode
operator|=
literal|0
expr_stmt|;
name|superblk
operator|.
name|s_ilock
operator|=
literal|0
expr_stmt|;
name|superblk
operator|.
name|s_ronly
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cylsize
operator|==
literal|0
operator|||
name|stepsize
operator|==
literal|0
condition|)
block|{
name|step
operator|=
name|superblk
operator|.
name|s_dinfo
index|[
literal|0
index|]
expr_stmt|;
name|cyl
operator|=
name|superblk
operator|.
name|s_dinfo
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|step
operator|=
name|stepsize
expr_stmt|;
name|cyl
operator|=
name|cylsize
expr_stmt|;
block|}
if|if
condition|(
name|step
operator|>
name|cyl
operator|||
name|step
operator|<=
literal|0
operator|||
name|cyl
operator|<=
literal|0
operator|||
name|cyl
operator|>
name|MAXCYL
condition|)
block|{
name|error
argument_list|(
literal|"Default free list spacing assumed\n"
argument_list|)
expr_stmt|;
name|step
operator|=
name|STEPSIZE
expr_stmt|;
name|cyl
operator|=
name|CYLSIZE
expr_stmt|;
block|}
name|superblk
operator|.
name|s_dinfo
index|[
literal|0
index|]
operator|=
name|step
expr_stmt|;
name|superblk
operator|.
name|s_dinfo
index|[
literal|1
index|]
operator|=
name|cyl
expr_stmt|;
name|clear
argument_list|(
name|flg
argument_list|,
sizeof|sizeof
argument_list|(
name|flg
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cyl
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
name|flg
index|[
name|i
index|]
condition|)
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|cyl
expr_stmt|;
name|addr
index|[
name|j
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|flg
index|[
name|i
index|]
operator|++
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
name|step
operator|)
operator|%
name|cyl
expr_stmt|;
block|}
name|baseblk
operator|=
operator|(
name|daddr_t
operator|)
name|roundup
argument_list|(
name|fmax
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|freeblk
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|freeblk
operator|.
name|df_nfree
operator|++
expr_stmt|;
for|for
control|(
init|;
name|baseblk
operator|>
literal|0
condition|;
name|baseblk
operator|-=
name|cyl
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cyl
condition|;
name|i
operator|++
control|)
block|{
name|blk
operator|=
name|baseblk
operator|-
name|addr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|outrange
argument_list|(
name|blk
argument_list|)
operator|&&
operator|!
name|getbmap
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|superblk
operator|.
name|s_tfree
operator|++
expr_stmt|;
if|if
condition|(
name|freeblk
operator|.
name|df_nfree
operator|>=
name|NICFREE
condition|)
block|{
name|fbdirty
argument_list|()
expr_stmt|;
name|fileblk
operator|.
name|b_bno
operator|=
name|blk
expr_stmt|;
name|flush
argument_list|(
operator|&
name|dfile
argument_list|,
operator|&
name|fileblk
argument_list|)
expr_stmt|;
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|freeblk
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
block|}
name|freeblk
operator|.
name|df_free
index|[
name|freeblk
operator|.
name|df_nfree
index|]
operator|=
name|blk
expr_stmt|;
name|freeblk
operator|.
name|df_nfree
operator|++
expr_stmt|;
block|}
block|}
name|superblk
operator|.
name|s_nfree
operator|=
name|freeblk
operator|.
name|df_nfree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NICFREE
condition|;
name|i
operator|++
control|)
name|superblk
operator|.
name|s_free
index|[
name|i
index|]
operator|=
name|freeblk
operator|.
name|df_free
index|[
name|i
index|]
expr_stmt|;
name|sbdirty
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|clear
argument_list|(
name|p
argument_list|,
name|cnt
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MEMSIZE
name|cnt
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|cnt
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|BUFAREA
modifier|*
name|search
parameter_list|(
name|blk
parameter_list|)
name|daddr_t
name|blk
decl_stmt|;
block|{
specifier|register
name|BUFAREA
modifier|*
name|pbp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
operator|(
name|BUFAREA
operator|*
operator|)
operator|&
name|poolhead
init|;
name|bp
operator|->
name|b_next
condition|;
control|)
block|{
name|pbp
operator|=
name|bp
expr_stmt|;
name|bp
operator|=
name|pbp
operator|->
name|b_next
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|==
name|blk
condition|)
break|break;
block|}
name|pbp
operator|->
name|b_next
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
name|bp
operator|->
name|b_next
operator|=
name|poolhead
expr_stmt|;
name|poolhead
operator|=
name|bp
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|findino
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|==
literal|0
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
for|for
control|(
name|p1
operator|=
name|dirp
operator|->
name|d_name
operator|,
name|p2
operator|=
name|srchname
init|;
operator|*
name|p2
operator|++
operator|==
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|0
operator|||
name|p1
operator|==
operator|&
name|dirp
operator|->
name|d_name
index|[
name|DIRSIZ
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|dirp
operator|->
name|d_ino
operator|>=
name|ROOTINO
operator|&&
name|dirp
operator|->
name|d_ino
operator|<=
name|imax
condition|)
name|parentdir
operator|=
name|dirp
operator|->
name|d_ino
expr_stmt|;
return|return
operator|(
name|STOP
operator|)
return|;
block|}
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mkentry
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ino_t
name|in
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dirp
operator|->
name|d_ino
condition|)
return|return
operator|(
name|KEEPON
operator|)
return|;
name|dirp
operator|->
name|d_ino
operator|=
name|orphan
expr_stmt|;
name|in
operator|=
name|orphan
expr_stmt|;
name|p
operator|=
operator|&
name|dirp
operator|->
name|d_name
index|[
literal|8
index|]
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|dirp
operator|->
name|d_name
condition|)
block|{
operator|*
operator|--
name|p
operator|=
operator|(
name|in
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|in
operator|/=
literal|10
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'#'
expr_stmt|;
return|return
operator|(
name|ALTERD
operator||
name|STOP
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|chgdd
argument_list|(
name|dirp
argument_list|)
specifier|register
name|DIRECT
operator|*
name|dirp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|dirp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dirp
operator|->
name|d_name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|dirp
operator|->
name|d_ino
operator|=
name|lfdir
expr_stmt|;
return|return
operator|(
name|ALTERD
operator||
name|STOP
operator|)
return|;
block|}
return|return
operator|(
name|KEEPON
operator|)
return|;
block|}
end_block

begin_macro
name|linkup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|DINODE
modifier|*
name|dp
decl_stmt|;
specifier|register
name|lostdir
expr_stmt|;
specifier|register
name|ino_t
name|pdir
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|lostdir
operator|=
name|DIR
expr_stmt|;
name|pdir
operator|=
name|parentdir
expr_stmt|;
name|pwarn
argument_list|(
literal|"UNREF %s "
argument_list|,
name|lostdir
condition|?
literal|"DIR"
else|:
literal|"FILE"
argument_list|)
expr_stmt|;
name|pinode
argument_list|()
expr_stmt|;
if|if
condition|(
name|preen
operator|&&
name|dp
operator|->
name|di_size
operator|==
literal|0
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|preen
condition|)
name|printf
argument_list|(
literal|" (RECONNECTED)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reply
argument_list|(
literal|"RECONNECT"
argument_list|)
operator|==
name|NO
condition|)
return|return
operator|(
name|NO
operator|)
return|;
name|orphan
operator|=
name|inum
expr_stmt|;
if|if
condition|(
name|lfdir
operator|==
literal|0
condition|)
block|{
name|inum
operator|=
name|ROOTINO
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|inum
operator|=
name|orphan
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|pfunc
operator|=
name|findino
expr_stmt|;
name|srchname
operator|=
name|lfname
expr_stmt|;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|parentdir
operator|=
literal|0
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
name|inum
operator|=
name|orphan
expr_stmt|;
if|if
condition|(
operator|(
name|lfdir
operator|=
name|parentdir
operator|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
block|}
name|inum
operator|=
name|lfdir
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|==
name|NULL
operator|||
operator|!
name|DIR
operator|||
name|getstate
argument_list|()
operator|!=
name|FSTATE
condition|)
block|{
name|inum
operator|=
name|orphan
expr_stmt|;
name|pfatal
argument_list|(
literal|"SORRY. NO lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|di_size
operator|&
name|BMASK
condition|)
block|{
name|dp
operator|->
name|di_size
operator|=
name|roundup
argument_list|(
name|dp
operator|->
name|di_size
argument_list|,
name|BSIZE
argument_list|)
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
block|}
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|inum
operator|=
name|orphan
expr_stmt|;
name|pfunc
operator|=
name|mkentry
expr_stmt|;
if|if
condition|(
operator|(
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
operator|&
name|ALTERD
operator|)
operator|==
literal|0
condition|)
block|{
name|pfatal
argument_list|(
literal|"SORRY. NO SPACE IN lost+found DIRECTORY"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
name|declncnt
argument_list|()
expr_stmt|;
if|if
condition|(
name|lostdir
condition|)
block|{
name|pfunc
operator|=
name|chgdd
expr_stmt|;
name|dp
operator|=
name|ginode
argument_list|()
expr_stmt|;
name|filsize
operator|=
name|dp
operator|->
name|di_size
expr_stmt|;
name|ckinode
argument_list|(
name|dp
argument_list|,
name|DATA
argument_list|)
expr_stmt|;
name|inum
operator|=
name|lfdir
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|ginode
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|di_nlink
operator|++
expr_stmt|;
name|inodirty
argument_list|()
expr_stmt|;
name|setlncnt
argument_list|(
name|getlncnt
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|inum
operator|=
name|orphan
expr_stmt|;
name|pwarn
argument_list|(
literal|"DIR I=%u CONNECTED. "
argument_list|,
name|orphan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PARENT WAS I=%u\n"
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|preen
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|YES
operator|)
return|;
block|}
end_block

begin_macro
name|bread
argument_list|(
argument|fcp
argument_list|,
argument|buf
argument_list|,
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fcp
operator|->
name|rfdes
argument_list|,
name|blk
operator|<<
name|BSHIFT
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rwerr
argument_list|(
literal|"SEEK"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|read
argument_list|(
name|fcp
operator|->
name|rfdes
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
name|size
condition|)
return|return
operator|(
name|YES
operator|)
return|;
name|rwerr
argument_list|(
literal|"READ"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_macro
name|bwrite
argument_list|(
argument|fcp
argument_list|,
argument|buf
argument_list|,
argument|blk
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|daddr_t
name|blk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|filecntl
modifier|*
name|fcp
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fcp
operator|->
name|wfdes
operator|<
literal|0
condition|)
return|return
operator|(
name|NO
operator|)
return|;
if|if
condition|(
name|lseek
argument_list|(
name|fcp
operator|->
name|wfdes
argument_list|,
name|blk
operator|<<
name|BSHIFT
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rwerr
argument_list|(
literal|"SEEK"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|write
argument_list|(
name|fcp
operator|->
name|wfdes
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|==
name|size
condition|)
block|{
name|fcp
operator|->
name|mod
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|YES
operator|)
return|;
block|}
name|rwerr
argument_list|(
literal|"WRITE"
argument_list|,
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO
operator|)
return|;
block|}
end_block

begin_macro
name|catch
argument_list|()
end_macro

begin_block
block|{
name|ckfini
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

