begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|# C library -- conversions
end_empty

begin_expr_stmt
operator|.
name|globl
name|__doprnt
operator|.
name|globl
name|__strout
define|#
directive|define
name|flags
value|r10
define|#
directive|define
name|literb
value|0
define|#
directive|define
name|liter
value|1
define|#
directive|define
name|ndfndb
value|0
define|#
directive|define
name|ndfnd
value|1
define|#
directive|define
name|ljustb
value|1
define|#
directive|define
name|ljust
value|2
define|#
directive|define
name|zfillb
value|2
define|#
directive|define
name|zfill
value|4
define|#
directive|define
name|precb
value|3
define|#
directive|define
name|prec
value|8
define|#
directive|define
name|psignb
value|4
define|#
directive|define
name|psign
value|16
define|#
directive|define
name|gflagb
value|5
define|#
directive|define
name|gflag
value|32
define|#
directive|define
name|width
value|r9
define|#
directive|define
name|ndigit
value|r8
define|#
directive|define
name|fdesc
value|-4(fp)
define|#
directive|define
name|exp
value|-8(fp)
define|#
directive|define
name|sign
value|-9(fp)
operator|.
name|set
name|one
operator|,
literal|010
operator|#
literal|1.0
name|in
name|floating
name|immediate
operator|.
name|set
name|ch
operator|.
name|zer
operator|,
literal|'0			# cpp doesn'
name|t
name|like
name|single
name|appostrophes
operator|.
name|align
literal|1
name|__doprnt
operator|:
operator|.
name|word
literal|0xfc0
operator|#
name|uses
name|r11
operator|-
name|r6
name|subl2
name|$128
operator|,
name|sp
name|movl
literal|4
operator|(
name|ap
operator|)
operator|,
name|r11
operator|#
name|addr
name|of
name|format
name|string
name|movl
literal|12
operator|(
name|ap
operator|)
operator|,
name|fdesc
operator|#
name|output
name|FILE
name|ptr
name|movl
literal|8
operator|(
name|ap
operator|)
operator|,
name|ap
operator|#
name|addr
name|of
name|first
name|arg
name|loop
operator|:
name|movl
name|r11
operator|,
name|r0
operator|#
name|current
name|point
name|in
name|format
name|bicl2
name|$liter
operator|,
name|flags
operator|#
name|no
name|literal
name|characters
name|yet
name|L1
operator|:
name|movb
argument_list|(
name|r11
argument_list|)
operator|+
operator|,
name|width
operator|#
name|next
name|character
name|of
name|format
name|beql
name|L2
operator|#
name|end
name|of
name|format
name|string
name|cmpb
name|width
operator|,
name|$
literal|'% 	beql L2				# warning character 	bisl2 $liter,flags		# literal character 	jbr L1 L2:	blbc flags,L3			# bbc $literb,flags,L3 # no literals in format 	pushl fdesc			# file pointer 	pushl $0			# no left/right adjust 	pushl r0			# addr 	subl3 r0,r11,r1			# length 	subl3 $1,r1,-(sp)		# % or null not part of literal 	calls $4,__strout		# dump the literal L3: 	blbs width,L4			# % is odd; end of format? 	ret				# yes  	# htab overlaps last 16 characters of ftab ftab:	.byte	 0, 0, 0,'
name|c
operator|,
literal|'d,'
name|e
operator|,
literal|'f,'
name|g
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|'+,'
name|l
operator|,
literal|'-,'
operator|.
operator|,
literal|'o htab:	.byte	'
literal|0
operator|,
literal|'1,'
literal|2
operator|,
literal|'3,'
literal|4
operator|,
literal|'5,'
literal|6
operator|,
literal|'7,'
literal|8
operator|,
literal|'9,'
name|a
operator|,
literal|'b,'
name|c
operator|,
literal|'d,'
name|e
operator|,
literal|'f  L4:	movl sp,r5			# reset output buffer pointer 	clrq r9				# width; flags ljustb,ndfndb,zfillb L4a:	movzbl (r11)+,r0		# supposed format 	extzv $0,$5,r0,r1		 # bottom 5 bits L4b:	cmpb r0,ftab[r1]		# good enough? 	jneq L6				# no L4c:	casel r1,$3,$22			# yes L5:	.word charac-L5			# c 	.word decimal-L5		# d 	.word scien-L5			# e 	.word float-L5			# f 	.word general-L5		# g 	.word L6-L5			# h 	.word L6-L5			# i 	.word L6-L5			# j 	.word plus-L5			# + 	.word longorunsg-L5		# l 	.word minus-L5			# - 	.word dot-L5			# . 	.word octal-L5			# o 	.word gnum0-L5			# 0 	.word gnum-L5			# 1 	.word gnum-L5			# 2 	.word gnum-L5			# 3 	.word gnum-L5			# 4 	.word gnum-L5			# 5 	.word gnum-L5			# 6 	.word gnum-L5			# 7 	.word gnum-L5			# 8 	.word gnum-L5			# 9  L6:	jbcs $5,r0,L4b			# capitals same as small 	cmpb r0,$'
name|s
name|jeql
name|string
name|cmpb
name|r0
operator|,
name|$
literal|'x 	jeql hex 	cmpb r0,$'
name|u
name|jeql
name|unsigned
name|cmpb
name|r0
operator|,
name|$
literal|'r 	jeql remote 	movzbl -1(r11),r0		# orginal "format" character 	cmpb r0,$'
operator|*
name|jeql
name|indir
name|L9
operator|:
name|movb
name|r0
operator|,
operator|(
name|r5
operator|)
operator|+
operator|#
name|print
name|the
name|unfound
name|character
name|jbr
name|prbuf
name|nulstr
operator|:
operator|.
name|byte
literal|'(,'
name|n
operator|,
literal|'u,'
name|l
operator|,
literal|'l,'
end_expr_stmt

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
literal|0
name|string
operator|:
name|movl
name|ndigit
operator|,
name|r0
name|jbs
name|$precb
operator|,
name|flags
operator|,
name|L20
operator|#
name|max
name|length
name|was
name|specified
name|mnegl
name|$1
operator|,
name|r0
operator|#
expr|default
name|max
name|length
name|L20
operator|:
name|movl
argument_list|(
name|ap
argument_list|)
operator|+
operator|,
name|r2
operator|#
name|addr
name|first
name|byte
name|bneq
name|L21
name|movab
name|nulstr
operator|,
name|r2
name|L21
operator|:
name|locc
name|$0
operator|,
name|r0
operator|,
operator|(
name|r2
operator|)
operator|#
name|find
name|the
name|zero
name|at
name|the
name|end
name|movl
name|r1
operator|,
name|r5
operator|#
name|addr
name|last
name|byte
operator|+
literal|1
name|movl
name|r2
operator|,
name|r1
operator|#
name|addr
name|first
name|byte
name|jbr
name|prstr
name|longorunsg
operator|:
name|movb
argument_list|(
name|r11
argument_list|)
operator|+
operator|,
name|r0
name|cmpb
name|r0
operator|,
name|$
literal|'o 	jeql loct 	cmpb r0,$'
name|x
name|jeql
name|lhex
name|cmpb
name|r0
operator|,
name|$
literal|'d 	jeql long 	cmpb r0,$'
name|u
name|jeql
name|lunsigned
name|decl
name|r11
name|jbr
name|unsigned
name|loct
operator|:
name|octal
operator|:
name|movl
name|$30
operator|,
name|r2
operator|#
name|init
name|position
name|movl
name|$3
operator|,
name|r3
operator|#
name|field
name|width
name|movl
name|$10
operator|,
name|r4
operator|#
name|result
name|length
operator|-
literal|1
name|jbr
name|L10
name|lhex
operator|:
name|hex
operator|:
name|movl
name|$28
operator|,
name|r2
operator|#
name|init
name|position
name|movl
name|$4
operator|,
name|r3
operator|#
name|field
name|width
name|movl
name|$7
operator|,
name|r4
operator|#
name|result
name|length
operator|-
literal|1
name|L10
operator|:
name|mnegl
name|r3
operator|,
name|r6
operator|#
name|increment
name|clrl
name|r1
name|movl
argument_list|(
name|ap
argument_list|)
operator|+
operator|,
name|r0
operator|#
name|fetch
name|arg
name|L11
operator|:
name|extzv
name|r2
operator|,
name|r3
operator|,
name|r0
operator|,
name|r1
operator|#
name|pull
name|out
name|a
name|digit
name|movb
name|htab
index|[
name|r1
index|]
operator|,
operator|(
name|r5
operator|)
operator|+
operator|#
name|convert
name|to
name|character
name|L12
operator|:
name|acbl
name|$0
operator|,
name|r6
operator|,
name|r2
operator|,
name|L11
operator|#
end_expr_stmt

begin_continue
continue|continue
name|until
name|done
name|clrb
continue|(
name|r5
end_continue

begin_expr_stmt
unit|)
operator|#
name|flag
name|end
name|skpc
name|$
literal|'0,r4,(sp)		# skip over leading zeroes 	jbr prstr  patdec:					# editpc pattern for decimal printing 	.byte 0xA9			# eo$float 9 	.byte 0x01			# eo$end_float 	.byte 0x91			# eo$move 1 	.byte 0				# eo$end  long: decimal: 	cvtlp (ap)+,$10,(sp)		# 10 digits max L14:	editpc $10,(sp),patdec,8(sp)	# ascii at 8(sp); r5=end+1 	skpc $'
operator|,
name|$10
operator|,
literal|8
operator|(
name|sp
operator|)
operator|#
name|skip
name|leading
name|blanks
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|r1
operator|=
name|first
name|prstr
operator|:
operator|#
name|r1
operator|=
name|addr
name|first
name|byte
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|r5
operator|=
name|addr
name|last
name|byte
operator|+
literal|1
name|cvtbl
name|$
literal|' ,-(sp)			# blank fill 	jbc $zfillb,flags,L15 	cvtbl $'
literal|0
operator|,
operator|(
name|sp
operator|)
operator|#
name|zero
name|fill
name|L15
operator|:
name|pushl
name|fdesc
operator|#
name|FILE
name|subl2
name|r1
operator|,
name|r5
operator|#
name|r5
operator|=
name|actual
name|length
operator|=
name|end
operator|+
literal|1
operator|-
name|first
name|subl3
name|r5
operator|,
name|width
operator|,
name|r0
operator|#
end_expr_stmt

begin_if
if|if>0
operator|,
name|how
name|much
name|to
name|fill
name|bgeq
name|L24
name|clrl
name|r0
operator|#
name|no
name|fill
name|L24
operator|:
name|jbs
name|$ljustb
operator|,
name|flags
operator|,
name|L25
name|mnegl
name|r0
operator|,
name|r0
name|L25
operator|:
name|pushl
name|r0
operator|#
name|fill
name|count
name|pushl
name|r1
operator|#
name|addr
name|first
name|byte
name|pushl
name|r5
operator|#
name|length
name|calls
name|$5
operator|,
name|__strout
name|jbr
name|loop
name|pone
operator|:
operator|.
name|byte
literal|0x1C
operator|#
name|packed
literal|1
name|unsigned
operator|:
name|lunsigned
operator|:
name|extzv
name|$1
operator|,
name|$31
operator|,
operator|(
name|ap
operator|)
operator|,
name|r0
operator|#
name|right
name|shift
name|logical
literal|1
name|bit
name|cvtlp
name|r0
operator|,
name|$10
operator|,
operator|(
name|sp
operator|)
operator|#
name|convert
index|[
name|n
operator|/
literal|2
index|]
name|to
name|packed
name|movp
name|$10
operator|,
operator|(
name|sp
operator|)
operator|,
literal|8
operator|(
name|sp
operator|)
operator|#
name|copy
name|packed
name|addp4
name|$10
operator|,
literal|8
operator|(
name|sp
operator|)
operator|,
name|$10
operator|,
operator|(
name|sp
operator|)
operator|#
literal|2
operator|*
index|[
name|n
operator|/
literal|2
index|]
name|in
name|packed
operator|,
name|at
argument_list|(
argument|sp
argument_list|)
name|blbc
argument_list|(
name|ap
argument_list|)
operator|+
operator|,
name|L14
operator|#
name|n
name|was
name|even
name|addp4
name|$1
operator|,
name|pone
operator|,
name|$10
operator|,
operator|(
name|sp
operator|)
operator|#
name|n
name|was
name|odd
name|jbr
name|L14
name|charac
operator|:
name|movl
name|$4
operator|,
name|r0
operator|#
name|chars
name|per
name|word
name|L18
operator|:
name|movb
argument_list|(
name|ap
argument_list|)
operator|+
operator|,
operator|(
name|r5
operator|)
operator|+
operator|#
name|transfer
name|char
name|bneq
name|L19
name|decl
name|r5
operator|#
name|omit
name|null
name|characters
name|L19
operator|:
name|sobgtr
name|r0
operator|,
name|L18
name|prbuf
operator|:
name|movl
name|sp
operator|,
name|r1
operator|#
name|addr
name|first
name|byte
name|jbr
name|prstr
name|plus
operator|:
name|bisl2
name|$psign
operator|,
name|flags
operator|#
name|always
name|print
name|sign
end_if

begin_for
for|for floats 	jbr L4a minus:	bisl2 $ljust
operator|,
name|flags
operator|#
name|left
name|justification
operator|,
name|please
name|jbr
name|L4a
name|gnum0
operator|:
name|jbs
name|$ndfndb
operator|,
name|flags
operator|,
name|gnum
name|jbs
name|$precb
operator|,
name|flags
operator|,
name|gnump
operator|#
name|ignore
name|when
name|reading
name|precision
name|bisl2
name|$zfill
operator|,
name|flags
operator|#
name|leading
name|zero
name|fill
operator|,
name|please
name|gnum
operator|:
name|jbs
name|$precb
operator|,
name|flags
operator|,
name|gnump
name|moval
argument_list|(
name|width
argument_list|)
index|[
name|width
index|]
operator|,
name|width
operator|#
name|width
operator|*=
literal|5
expr_stmt|;
end_for

begin_expr_stmt
name|movaw
operator|-
name|ch
operator|.
name|zer
argument_list|(
name|r0
argument_list|)
index|[
name|width
index|]
operator|,
name|width
operator|#
name|width
operator|=
literal|2
operator|*
name|witdh
operator|+
name|r0
operator|-
literal|'0'
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|jbr
name|gnumd
name|gnump
range|:
name|moval
argument_list|(
name|ndigit
argument_list|)
index|[
name|ndigit
index|]
decl_stmt|,
name|ndigit
decl|#
name|ndigit
decl|*= 5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|movaw
operator|-
name|ch
operator|.
name|zer
argument_list|(
name|r0
argument_list|)
index|[
name|ndigit
index|]
operator|,
name|ndigit
operator|#
name|ndigit
operator|=
literal|2
operator|*
name|ndigit
operator|+
name|r0
operator|-
literal|'0'
expr_stmt|;
end_expr_stmt

begin_label
name|gnumd
label|:
end_label

begin_decl_stmt
name|bisl2
name|$ndfnd
decl_stmt|,
name|flags
decl|#
name|digit
name|seen
name|jbr
name|L4a
name|dot
range|:
name|clrl
name|ndigit
operator|#
name|start
name|on
name|the
name|precision
name|bisl2
name|$prec
decl_stmt|,
name|flags
name|bicl2
name|$ndfnd
decl_stmt|,
name|flags
name|jbr
name|L4a
name|indir
range|:
name|movl
argument_list|(
name|ap
argument_list|)
operator|+
decl_stmt|,
name|ndigit
decl|#
name|width
name|specified
name|by
name|parameter
name|jbr
name|gnumd
name|remote
range|:
name|movl
argument_list|(
name|ap
argument_list|)
operator|+
decl_stmt|,
name|ap
name|movl
argument_list|(
name|ap
argument_list|)
decl|+
decl_stmt|,
name|r11
name|jbr
name|loop
name|float
range|:
name|bsbw
name|fltcvt
name|fltg
operator|:
name|jbs
name|$ndfndb
decl_stmt|,
name|flags
decl_stmt|,
name|float1
name|movl
name|$6
decl_stmt|,
name|ndigit
decl|# default #
name|digits
name|to
name|right
name|of
name|decpt
operator|.
name|float1
range|:
name|addl3
name|exp
decl_stmt|,
name|ndigit
decl_stmt|,
name|r7
name|movl
name|r7
decl_stmt|,
name|r6
decl|# for
name|later
decl|"underflow"
name|checking
name|bgeq
name|fxplrd
name|clrl
name|r7
decl|#
name|poor
name|programmer
name|planning
name|fxplrd
range|:
name|cmpl
name|r7
decl_stmt|,
name|$31
decl|#
name|expressible
name|in
name|packed
name|decimal
decl|?
name|bleq
name|fnarro
decl|#
name|yes
name|movl
name|$31
decl_stmt|,
name|r7
name|fnarro
range|:
name|subl3
name|$17
decl_stmt|,
name|r7
decl_stmt|,
name|r0
decl|#
name|where
name|to
name|round
name|ashp
name|r0
decl_stmt|,
name|$17
decl_stmt|,
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|$5
decl_stmt|,
name|r7
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|# do
name|it
name|bvc
name|fnovfl
empty|# band-aid for microcode error (spurious overflow)
name|clrl
name|r0
decl|#
name|assume
name|even
name|length
name|result
name|jlbc
name|r7
decl_stmt|,
name|fleven
decl|#
name|right
name|movl
name|$4
decl_stmt|,
name|r0
decl|#
name|odd
name|length
name|result
name|fleven
range|:
name|cmpv
name|r0
decl_stmt|,
name|$4
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|$0
decl|#
name|top
name|digit
name|zero
name|iff
name|true
name|overflow
name|bneq
name|fnovfl
empty|# end band-aid
name|aobleq
name|$0
decl_stmt|,
name|r6
decl_stmt|,
name|fnovfl
decl|# if "underflow"
name|then
name|jump
name|movl
name|r7
decl_stmt|,
name|r0
name|incl
name|exp
name|incl
name|r7
name|ashp
name|r0
decl_stmt|,
name|$1
decl_stmt|,
name|pone
decl_stmt|,
name|$0
decl_stmt|,
name|r7
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
name|ashl
name|$
decl|-1
decl_stmt|,
name|r7
decl_stmt|,
name|r0
decl|#
name|displ
name|to
name|last
name|byte
name|bisb2
name|sign
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|[
name|r0
decl|]		#
name|insert
name|sign
name|fnovfl
range|:
name|movc3
name|$4
decl_stmt|,
name|patsci
decl_stmt|,
argument_list|(
name|sp
argument_list|)
name|clrl
name|r6
decl|# #
name|digits
name|moved
name|so
name|far
name|movl
name|exp
decl_stmt|,
name|r0
name|bleq
name|fexpng
name|bsbb
name|patmov
decl|#
name|digits
name|to
name|left
name|of
name|decpt
operator|.
name|fexpng
range|:
name|tstl
name|ndigit
name|jeql
name|fnodp
name|movc3
name|$2
decl_stmt|,
name|fpatdp
decl_stmt|,
argument_list|(
name|r3
argument_list|)
name|tstl
name|exp
name|bgeq
name|fxppos
name|addl3
name|exp
decl_stmt|,
name|ndigit
decl_stmt|,
name|r6
name|bgeq
name|flfakl
name|clrl
name|r6
decl|#
name|it
decl|'s all fill flfakl:	subl3 r6,$31,r6			# fake length for patmov flfill:	movc3 $2,fpatzf,(r3)		# zero fill to right of dec.pt fxppos:	movl ndigit,r0 	bsbb patmov fnodp:	sobgeq r6,fledit		# must move at least 1 digit 	movl $31,r6			# none moved; fake it 	aobleq $1,ndigit,flfill		# with a one-character zero fill fledit:	editpc r7,16(sp),(sp),32(sp) 	jbr prflt  patexp:	.byte	0x03			# eo$set_signif 	.byte	0x44,'
name|e
decl|#
name|eo$insert
decl|'e 	.byte	0x42,'+			#
name|eo$load_plus
decl|'+ 	.byte	0x04			# eo$store_sign 	.byte	0x92			# eo$move 2 	.byte	0			# eo$end patsci:	.byte	0x42,'+			#
name|eo$load_plus
decl|'+ 	.byte	0x03			# eo$set_signif 	.byte	0x04			# eo$store_sign 	.byte	0x91			# eo$move 1 fpatdp:	.byte	0x44,'.			#
name|eo$insert
decl|'. fpatzf:	.byte	0x40,'0			#
name|eo$load_fill
decl|'0  	# construct pattern at (r3) to move  r0  digits in  editpc; 	#  r6  digits already moved for this number patmov: 	movb $0x90,r2			# eo$move 	subl3 r6,$31,r1			# # digits remaining in packed 	addl2 r0,r6 	cmpl r0,r1			# enough digits remaining? 	bleq patsml			# yes 	tstl exp			# zero '
name|fill
decl|'; before or after rest? 	bgeq pataft			# after 	pushl r1			# # digits remaining 	movb $0x80,r2			# eo$fill 	subl3 $31,r6,r0			# number of fill bytes 	bsbb patsml			# recursion! 	movl (sp)+,r0 	movb $0x90,r2			# eo$move 	jbr patsml pataft:	movl r1,r0			# last of the 31 	bsbb patsml			# recursion! 	subl3 $31,r6,r0			# number of fill bytes 	movb $0x80,r2			# eo$fill patsml:	tstl r0 	bleq patzer			# DEC doesn'
name|t
name|like
name|repetition
name|counts
name|of
decl|0
name|mnegl
name|$15
decl_stmt|,
name|r1
decl|# 15
name|digits
name|at
name|a
name|time
name|subl2
name|r1
decl_stmt|,
name|r0
decl|#
name|counteract
name|acbl
name|jbr
name|pattst
name|patmlp
range|:
name|bisb3
name|r2
decl_stmt|,
name|$15
decl_stmt|,
argument_list|(
name|r3
argument_list|)
decl_stmt|+		# 15
name|pattst
range|:
name|acbl
name|$16
decl_stmt|,
name|r1
decl_stmt|,
name|r0
decl_stmt|,
name|patmlp
decl|#
name|until
decl|<= 15
name|left
name|bisb3
name|r2
decl_stmt|,
name|r0
decl_stmt|,
argument_list|(
name|r3
argument_list|)
decl_stmt|+		#
name|rest
name|patzer
range|:
name|clrb
argument_list|(
name|r3
argument_list|)
operator|#
name|eo$end
name|rsb
name|scien
operator|:
name|bsbw
name|fltcvt
operator|#
name|get
name|packed
name|digits
name|scig
operator|:
name|incl
name|ndigit
name|jbs
name|$ndfndb
decl_stmt|,
name|flags
decl_stmt|,
name|L23
name|movl
name|$7
decl_stmt|,
name|ndigit
name|L23
range|:
name|subl3
name|$17
decl_stmt|,
name|ndigit
decl_stmt|,
name|r0
decl|#
name|rounding
name|position
name|ashp
name|r0
decl_stmt|,
name|$17
decl_stmt|,
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|$5
decl_stmt|,
name|ndigit
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|#
name|shift
name|and
name|round
name|bvc
name|snovfl
empty|# band-aid for microcode error (spurious overflow)
name|clrl
name|r0
decl|#
name|assume
name|even
name|length
name|result
name|jlbc
name|ndigit
decl_stmt|,
name|sceven
decl|#
name|right
name|movl
name|$4
decl_stmt|,
name|r0
decl|#
name|odd
name|length
name|result
name|sceven
range|:
name|cmpv
name|r0
decl_stmt|,
name|$4
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|$0
decl|#
name|top
name|digit
name|zero
name|iff
name|true
name|overflow
name|bneq
name|snovfl
empty|# end band-aid
name|incl
name|exp
decl|#
name|rounding
name|overflowed
name|to
decl|100...
name|subl3
name|$1
decl_stmt|,
name|ndigit
decl_stmt|,
name|r0
name|ashp
name|r0
decl_stmt|,
name|$1
decl_stmt|,
name|pone
decl_stmt|,
name|$0
decl_stmt|,
name|ndigit
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
name|ashl
name|$
decl|-1
decl_stmt|,
name|ndigit
decl_stmt|,
name|r0
decl|#
name|displ
name|to
name|last
name|byte
name|bisb2
name|sign
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|[
name|r0
decl|]		#
name|insert
name|sign
name|snovfl
range|:
name|jbc
name|$gflagb
decl_stmt|,
name|flags
decl_stmt|,
name|enotg
decl|#
name|not
decl|%
name|g
name|format
empty|# find trailing zeroes in packed number
name|ashl
name|$
decl|-1
decl_stmt|,
name|ndigit
decl_stmt|,
name|r0
name|addl2
name|r3
decl_stmt|,
name|r0
decl|#
name|addr
name|of
name|l
operator|.
name|s
operator|.
name|digit
name|and
name|sign
name|movl
name|$4
decl_stmt|,
name|r1
decl|#
name|bit
name|position
name|of
name|digit
name|movl
name|ndigit
decl_stmt|,
name|r7
decl|#
name|current
name|length
name|of
name|packed
name|jbr
name|gtz
name|gtz1
range|:
name|xorl2
name|$4
decl_stmt|,
name|r1
decl|#
name|position
name|of
name|next
name|digit
name|bneq
name|gtz
decl|#
name|same
name|byte
name|decl
name|r0
decl|#
name|different
name|byte
name|gtz
range|:
name|cmpv
name|r1
decl_stmt|,
name|$4
decl_stmt|,
argument_list|(
name|r0
argument_list|)
decl_stmt|,
name|$0
decl|#
name|a
name|trailing
name|zero
decl|?
name|jneq
name|gntz
name|sobgtr
name|r7
decl_stmt|,
name|gtz1
name|incl
name|r7
name|gntz
range|:
operator|#
name|r7
operator|:
name|minimum
name|width
name|of
name|fraction
name|cmpl
name|exp
decl_stmt|,
name|$
decl|-4
name|jleq
name|eg
decl|#
name|small
name|exponents
name|use
decl|%
name|e
name|subl3
name|r7
decl_stmt|,
name|exp
decl_stmt|,
name|r0
name|cmpl
name|$5
decl_stmt|,
name|r0
name|jleq
name|eg
decl|#
name|so
decl|do
argument_list|(
name|w
operator|+
literal|5
argument_list|)
decl|<=
name|exp
name|tstl
name|r0
decl|#
name|rest
name|use
decl|%
name|f
name|jleq
name|fg
decl|#
name|did
name|we
name|trim
name|too
name|many
name|trailing
name|zeroes
decl|?
name|movl
name|exp
decl_stmt|,
name|r7
decl|#
name|yes
name|fg
range|:
name|subl3
name|ndigit
decl_stmt|,
name|r7
decl_stmt|,
name|r0
name|ashp
name|r0
decl_stmt|,
name|ndigit
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|$0
decl_stmt|,
name|r7
decl_stmt|,
argument_list|(
name|sp
argument_list|)
name|movp
name|r7
decl_stmt|,
argument_list|(
name|sp
argument_list|)
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
name|subl3
name|exp
decl_stmt|,
name|r7
decl_stmt|,
name|ndigit
decl|#
name|correct
name|ndigit
decl|for %
name|f
name|jbr
name|fnovfl
name|eg
range|:
name|subl3
name|ndigit
decl_stmt|,
name|r7
decl_stmt|,
name|r0
name|ashp
name|r0
decl_stmt|,
name|ndigit
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|,
name|$0
decl_stmt|,
name|r7
decl_stmt|,
argument_list|(
name|sp
argument_list|)
name|movp
name|r7
decl_stmt|,
argument_list|(
name|sp
argument_list|)
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
name|movl
name|r7
decl_stmt|,
name|ndigit
decl|#
name|packed
name|number
name|has
name|been
name|trimmed
name|enotg
range|:
name|movc3
name|$7
decl_stmt|,
name|patsci
decl_stmt|,
argument_list|(
name|sp
argument_list|)
name|movl
name|$1
decl_stmt|,
name|r6
decl|# 1P
name|subl3
name|$1
decl_stmt|,
name|ndigit
decl_stmt|,
name|r0
decl|#
name|digits
name|after
name|dec
operator|.
name|pt
name|bsbw
name|patmov
name|editpc
name|ndigit
decl_stmt|,16
argument_list|(
name|sp
argument_list|)
decl_stmt|,
argument_list|(
name|sp
argument_list|)
decl_stmt|,32
argument_list|(
name|sp
argument_list|)
decl_stmt|# 32
argument_list|(
name|sp
argument_list|)
decl_stmt|->
name|result
decl_stmt|,
name|r5
operator|->
decl|(
name|end
decl|+1
decl_stmt|) 	decl exp			# compensate: 1 digit left of dec.pt 	cvtlp exp
operator|,
decl_stmt|$2
operator|,
decl_stmt|(sp
end_decl_stmt

begin_expr_stmt
unit|)
operator|#
name|exponent
name|editpc
name|$2
operator|,
operator|(
name|sp
operator|)
operator|,
name|patexp
operator|,
operator|(
name|r5
operator|)
name|prflt
operator|:
name|movab
literal|32
operator|(
name|sp
operator|)
operator|,
name|r1
name|jbs
name|$psignb
operator|,
name|flags
operator|,
name|prflt1
name|cmpb
argument_list|(
name|r1
argument_list|)
operator|+
operator|,
name|$
literal|'+ 	beql prflt1 	decl r1 prflt1:	skpc $'
operator|,
name|$63
operator|,
operator|(
name|r1
operator|)
name|jbr
name|prstr
name|general
operator|:
name|jbcs
name|$gflagb
operator|,
name|flags
operator|,
name|scien
name|jbr
name|scien
operator|#
name|safety
name|net
empty|# convert double-floating at (ap) to 17-digit packed at (sp),
empty|# set 'sign' and 'exp', advance ap.
name|fltcvt
operator|:
name|clrb
name|sign
name|movd
argument_list|(
name|ap
argument_list|)
operator|+
operator|,
name|r5
name|jeql
name|fzero
name|bgtr
name|fpos
name|mnegd
name|r5
operator|,
name|r5
name|incb
name|sign
name|fpos
operator|:
name|extzv
name|$7
operator|,
name|$8
operator|,
name|r5
operator|,
name|r2
operator|#
name|exponent
name|of
literal|2
name|movaw
operator|-
literal|0600
operator|(
name|r2
operator|)
index|[
name|r2
index|]
operator|,
name|r2
operator|#
name|unbias
name|and
name|mult
name|by
literal|3
name|bgeq
name|epos
name|subl2
name|$9
operator|,
name|r2
name|epos
operator|:
name|divl2
name|$10
operator|,
name|r2
name|bsbb
name|expten
name|cmpd
name|r0
operator|,
name|r5
name|bgtr
name|ceil
name|incl
name|r2
name|ceil
operator|:
name|movl
name|r2
operator|,
name|exp
name|mnegl
name|r2
operator|,
name|r2
name|cmpl
name|r2
operator|,
name|$29
operator|#
literal|10
operator|^
operator|(
literal|29
operator|+
literal|9
operator|)
name|is
name|all
name|we
name|can
name|handle
name|bleq
name|getman
name|muld2
name|ten16
operator|,
name|r5
name|subl2
name|$16
operator|,
name|r2
name|getman
operator|:
name|addl2
name|$9
operator|,
name|r2
operator|#
operator|-
name|ceil
argument_list|(
name|log10
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
literal|9
name|bsbb
name|expten
name|emodd
name|r0
operator|,
name|r4
operator|,
name|r5
operator|,
name|r0
operator|,
name|r5
operator|#
operator|(
name|r0
operator|+
name|r4
operator|)
operator|*
name|r5
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|r0
operator|=
name|int
operator|,
name|r5
operator|=
name|frac
name|fz1
operator|:
name|cvtlp
name|r0
operator|,
name|$9
operator|,
literal|16
operator|(
name|sp
operator|)
operator|#
name|leading
literal|9
name|digits
name|ashp
name|$8
operator|,
name|$9
operator|,
literal|16
operator|(
name|sp
operator|)
operator|,
name|$0
operator|,
name|$17
operator|,
literal|4
operator|(
name|sp
operator|)
operator|#
name|as
name|top
literal|9
name|of
literal|17
name|emodd
name|ten8
operator|,
name|$0
operator|,
name|r5
operator|,
name|r0
operator|,
name|r5
name|cvtlp
name|r0
operator|,
name|$8
operator|,
literal|16
operator|(
name|sp
operator|)
operator|#
name|trailing
literal|8
name|digits
name|addp4
name|$8
operator|,
literal|16
operator|(
name|sp
operator|)
operator|,
name|$17
operator|,
literal|4
operator|(
name|sp
operator|)
operator|#
name|combine
name|leading
name|and
name|trailing
name|bisb2
name|sign
operator|,
literal|12
operator|(
name|sp
operator|)
operator|#
name|and
name|insert
name|sign
name|rsb
name|fzero
operator|:
name|clrl
name|r0
name|movl
name|$1
operator|,
name|exp
operator|#
literal|0.000e+00
name|and
literal|0.000
name|rather
name|than
literal|0.000e-01
name|and
literal|.000
name|jbr
name|fz1
empty|# return 10^r2 as a double float in r0||r1 and 8 extra bits of precision in r4
empty|# preserve r2, r5||r6
name|expten
operator|:
name|movd
name|$one
operator|,
name|r0
operator|#
name|begin
name|computing
literal|10
operator|^
name|exp10
name|clrl
name|r4
operator|#
name|bit
name|counter
name|movad
name|ten1
operator|,
name|r3
operator|#
name|table
name|address
name|tstl
name|r2
name|bgeq
name|e10lp
name|mnegl
name|r2
operator|,
name|r2
operator|#
name|get
name|absolute
name|value
name|jbss
name|$6
operator|,
name|r2
operator|,
name|e10lp
operator|#
name|flag
name|as
name|negative
name|e10lp
operator|:
name|jbc
name|r4
operator|,
name|r2
operator|,
name|el1
operator|#
name|want
name|this
name|power
condition|?
name|muld2
argument_list|(
name|r3
argument_list|)
operator|,
name|r0
operator|#
name|yes
name|el1
operator|:
name|addl2
name|$8
operator|,
name|r3
operator|#
name|advance
name|to
name|next
name|power
name|aobleq
name|$5
operator|,
name|r4
operator|,
name|e10lp
operator|#
name|through
literal|10
operator|^
literal|32
name|jbcc
name|$6
operator|,
name|r2
operator|,
name|el2
operator|#
name|correct
end_expr_stmt

begin_for
for|for negative exponent 	divd3 r0
operator|,
name|$one
operator|,
name|r0
operator|#
name|by
name|taking
name|reciprocal
name|mnegl
name|r2
operator|,
name|r2
name|el2
operator|:
name|clrl
name|r4
operator|#
literal|8
name|extra
name|bits
name|of
name|precision
name|rsb
empty|# powers of ten
operator|.
name|align
literal|3
name|ten1
operator|:
operator|.
name|word
literal|0x4220
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
name|ten2
operator|:
operator|.
name|word
literal|0x43c8
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
name|ten4
operator|:
operator|.
name|word
literal|0x471c
operator|,
literal|0x4000
operator|,
literal|0
operator|,
literal|0
name|ten8
operator|:
operator|.
name|word
literal|0x4dbe
operator|,
literal|0xbc20
operator|,
literal|0
operator|,
literal|0
name|ten16
operator|:
operator|.
name|word
literal|0x5b0e
operator|,
literal|0x1bc9
operator|,
literal|0xbf04
operator|,
literal|0
name|ten32
operator|:
operator|.
name|word
literal|0x759d
operator|,
literal|0xc5ad
operator|,
literal|0xa82b
operator|,
literal|0x70b6
end_for

end_unit

