begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * UNIX shell  *  * S. R. Bourne  * Bell Telephone Laboratories  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"dup.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"timeout.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_decl_stmt
name|UFD
name|output
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LOCAL
name|BOOL
name|beenhere
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CHAR
name|tmpout
index|[
literal|20
index|]
init|=
literal|"/tmp/sh-"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILEBLK
name|stdfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
name|standin
init|=
operator|&
name|stdfile
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<execargs.h>
end_include

begin_function_decl
name|PROC
name|VOID
name|exfile
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|c
parameter_list|,
name|v
parameter_list|)
name|INT
name|c
decl_stmt|;
name|STRING
name|v
index|[]
decl_stmt|;
block|{
name|REG
name|INT
name|rflag
init|=
name|ttyflg
decl_stmt|;
comment|/* initialise storage allocation */
name|stdsigs
argument_list|()
expr_stmt|;
name|setbrk
argument_list|(
name|BRKINCR
argument_list|)
expr_stmt|;
name|addblok
argument_list|(
operator|(
name|POS
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* set names from userenv */
name|getenv
argument_list|()
expr_stmt|;
comment|/* look for restricted */
comment|/*	IF c>0 ANDF any('r', *v) THEN rflag=0 FI */
comment|/* look for options */
name|dolc
operator|=
name|options
argument_list|(
name|c
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IF
name|dolc
operator|<
literal|2
name|THEN
name|flags
operator||=
name|stdflg
name|FI
name|IF
argument_list|(
name|flags
operator|&
name|stdflg
argument_list|)
operator|==
literal|0
name|THEN
name|dolc
operator|--
expr_stmt|;
name|FI
name|dolv
init|=
name|v
operator|+
name|c
operator|-
name|dolc
decl_stmt|;
name|dolc
operator|--
expr_stmt|;
comment|/* return here for shell file execution */
name|setjmp
argument_list|(
name|subshell
argument_list|)
expr_stmt|;
comment|/* number of positional parameters */
name|assnum
argument_list|(
operator|&
name|dolladr
argument_list|,
name|dolc
argument_list|)
expr_stmt|;
name|cmdadr
operator|=
name|dolv
index|[
literal|0
index|]
expr_stmt|;
comment|/* set pidname */
name|assnum
argument_list|(
operator|&
name|pidadr
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* set up temp file names */
name|settmp
argument_list|()
expr_stmt|;
comment|/* default ifs */
name|dfault
argument_list|(
operator|&
name|ifsnod
argument_list|,
name|sptbnl
argument_list|)
expr_stmt|;
name|IF
argument_list|(
name|beenhere
operator|++
argument_list|)
operator|==
name|FALSE
name|THEN
comment|/* ? profile */
name|IF
operator|*
name|cmdadr
operator|==
literal|'-'
name|ANDF
argument_list|(
name|input
operator|=
name|pathopen
argument_list|(
name|nullstr
argument_list|,
name|profile
argument_list|)
argument_list|)
operator|>=
literal|0
name|THEN
name|exfile
argument_list|(
name|rflag
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|ttyflg
expr_stmt|;
name|FI
name|IF
name|rflag
operator|==
literal|0
name|THEN
name|flags
operator||=
name|rshflg
name|FI
comment|/* open input file if specified */
name|IF
name|comdiv
name|THEN
name|estabf
argument_list|(
name|comdiv
argument_list|)
expr_stmt|;
name|input
operator|=
operator|-
literal|1
expr_stmt|;
name|ELSE
name|input
init|=
operator|(
operator|(
name|flags
operator|&
name|stdflg
operator|)
condition|?
literal|0
else|:
name|chkopen
argument_list|(
name|cmdadr
argument_list|)
operator|)
decl_stmt|;
name|comdiv
operator|--
expr_stmt|;
name|FI
name|ELSE
modifier|*
name|execargs
init|=
name|dolv
decl_stmt|;
comment|/* for `ps' cmd */
name|FI
name|exfile
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|VOID
name|exfile
parameter_list|(
name|prof
parameter_list|)
name|BOOL
name|prof
decl_stmt|;
block|{
name|REG
name|L_INT
name|mailtime
init|=
literal|0
decl_stmt|;
name|REG
name|INT
name|userid
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
comment|/* move input */
name|IF
name|input
operator|>
literal|0
name|THEN
name|Ldup
argument_list|(
name|input
argument_list|,
name|INIO
argument_list|)
expr_stmt|;
name|input
operator|=
name|INIO
expr_stmt|;
name|FI
comment|/* move output to safe place */
name|IF
name|output
operator|==
literal|2
name|THEN
name|Ldup
argument_list|(
name|dup
argument_list|(
literal|2
argument_list|)
argument_list|,
name|OTIO
argument_list|)
expr_stmt|;
name|output
operator|=
name|OTIO
expr_stmt|;
name|FI
name|userid
init|=
name|getuid
argument_list|()
decl_stmt|;
comment|/* decide whether interactive */
name|IF
argument_list|(
argument|flags&intflg
argument_list|)
name|ORF
argument_list|(
argument|(flags&oneflg)==
literal|0
argument|ANDF gtty(output,&statb)==
literal|0
argument|ANDF gtty(input,&statb)==
literal|0
argument_list|)
name|THEN
name|dfault
argument_list|(
operator|&
name|ps1nod
argument_list|,
operator|(
name|userid
condition|?
name|stdprompt
else|:
name|supprompt
operator|)
argument_list|)
decl_stmt|;
name|dfault
argument_list|(
operator|&
name|ps2nod
argument_list|,
name|readmsg
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ttyflg
operator||
name|prompt
expr_stmt|;
name|ignsig
argument_list|(
name|KILL
argument_list|)
expr_stmt|;
comment|/* 		{ 	#include<signal.h> 		signal(SIGTTIN, SIG_IGN); 		signal(SIGTTOU, SIG_IGN); 		signal(SIGTSTP, SIG_IGN); 		} */
name|ELSE
name|flags
operator||=
name|prof
expr_stmt|;
name|flags
operator|&=
operator|~
name|prompt
expr_stmt|;
name|FI
name|IF
name|setjmp
argument_list|(
name|errshell
argument_list|)
name|ANDF
name|prof
name|THEN
name|close
argument_list|(
name|input
argument_list|)
decl_stmt|;
return|return;
name|FI
comment|/* error return here */
name|loopcnt
init|=
name|breakcnt
operator|=
name|peekc
operator|=
literal|0
decl_stmt|;
name|iopend
operator|=
literal|0
expr_stmt|;
name|IF
name|input
operator|>=
literal|0
name|THEN
name|initf
argument_list|(
argument|input
argument_list|)
name|FI
comment|/* command loop */
name|LOOP
name|tdystak
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|stakchk
argument_list|()
expr_stmt|;
comment|/* may reduce sbrk */
name|exitset
argument_list|()
expr_stmt|;
name|IF
argument_list|(
argument|flags&prompt
argument_list|)
name|ANDF
name|standin
operator|->
name|fstak
operator|==
literal|0
name|ANDF
operator|!
name|eof
name|THEN
name|IF
name|mailnod
operator|.
name|namval
name|ANDF
name|stat
argument_list|(
name|mailnod
operator|.
name|namval
argument_list|,
operator|&
name|statb
argument_list|)
operator|>=
literal|0
name|ANDF
name|statb
operator|.
name|st_size
name|ANDF
argument_list|(
argument|statb.st_mtime != mailtime
argument_list|)
name|ANDF
name|mailtime
name|THEN
name|prs
argument_list|(
argument|mailmsg
argument_list|)
name|FI
name|mailtime
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
name|prs
argument_list|(
name|ps1nod
operator|.
name|namval
argument_list|)
expr_stmt|;
name|FI
name|trapnote
init|=
literal|0
decl_stmt|;
name|peekc
operator|=
name|readc
argument_list|()
expr_stmt|;
name|IF
name|eof
name|THEN
return|return;
name|FI
name|execute
argument_list|(
name|cmd
argument_list|(
name|NL
argument_list|,
name|MTFLG
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|eof
operator||=
operator|(
name|flags
operator|&
name|oneflg
operator|)
expr_stmt|;
name|POOL
block|}
end_function

begin_macro
name|chkpr
argument_list|(
argument|eor
argument_list|)
end_macro

begin_decl_stmt
name|char
name|eor
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IF
argument_list|(
argument|flags&prompt
argument_list|)
name|ANDF
name|standin
operator|->
name|fstak
operator|==
literal|0
name|ANDF
name|eor
operator|==
name|NL
name|THEN
name|prs
argument_list|(
name|ps2nod
operator|.
name|namval
argument_list|)
expr_stmt|;
name|FI
block|}
end_block

begin_macro
name|settmp
argument_list|()
end_macro

begin_block
block|{
name|itos
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|serial
operator|=
literal|0
expr_stmt|;
name|tmpnam
operator|=
name|movstr
argument_list|(
name|numbuf
argument_list|,
operator|&
name|tmpout
index|[
name|TMPNAM
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|Ldup
argument_list|(
argument|fa
argument_list|,
argument|fb
argument_list|)
end_macro

begin_decl_stmt
name|REG
name|INT
name|fa
decl_stmt|,
name|fb
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dup
argument_list|(
name|fa
operator||
name|DUPFLG
argument_list|,
name|fb
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fa
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|fb
argument_list|,
name|FIOCLEX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

