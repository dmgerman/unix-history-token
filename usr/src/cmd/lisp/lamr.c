begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Lalloc								*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  This lambda allows allocation of pages from lisp.  The first	*/
end_comment

begin_comment
comment|/*  argument is the name of a space, n pages of which are allocated,	*/
end_comment

begin_comment
comment|/*  if possible.  Returns the number of pages allocated.		*/
end_comment

begin_function
name|lispval
name|Lalloc
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|mylbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|&&
operator|(
name|mylbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|!=
name|nil
condition|)
name|error
argument_list|(
literal|"2nd ARGUMENT TO ALLOCATE MUST BE AN INTEGER"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mylbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|!=
name|nil
condition|)
name|n
operator|=
operator|(
name|mylbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|alloc
argument_list|(
operator|(
name|mylbot
operator|)
operator|->
name|val
argument_list|,
name|n
argument_list|)
operator|)
return|;
comment|/*  call alloc to do the work  */
block|}
end_function

begin_function
name|lispval
name|Lsizeof
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|csizeof
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsegment
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"LENGTH ARG TO SEGMENT MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|<
literal|0
condition|)
block|{
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"LENGTH ARG TO SEGMENT MUST BE POSITIVE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
name|csegment
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|,
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Lforget  *************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  This function removes an atom from the hash table.			*/
end_comment

begin_function
name|lispval
name|Lforget
parameter_list|()
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|struct
name|atom
modifier|*
name|buckpt
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"CANNOT FORGET NON-ATOM"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
operator|->
name|pname
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
name|NULL_CHAR
condition|)
name|hash
operator|^=
name|c
expr_stmt|;
name|hash
operator|=
name|hash
operator|&
literal|0177
expr_stmt|;
comment|/*  We have found the hash bucket for the atom, now we remove it  */
if|if
condition|(
name|hasht
index|[
name|hash
index|]
operator|==
operator|(
expr|struct
name|atom
operator|*
operator|)
name|lbot
operator|->
name|val
condition|)
block|{
name|hasht
index|[
name|hash
index|]
operator|=
name|lbot
operator|->
name|val
operator|->
name|hshlnk
expr_stmt|;
name|lbot
operator|->
name|val
operator|->
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
block|}
name|buckpt
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|buckpt
operator|!=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
condition|)
block|{
if|if
condition|(
name|buckpt
operator|->
name|hshlnk
operator|==
operator|(
expr|struct
name|atom
operator|*
operator|)
name|lbot
operator|->
name|val
condition|)
block|{
name|buckpt
operator|->
name|hshlnk
operator|=
name|lbot
operator|->
name|val
operator|->
name|hshlnk
expr_stmt|;
name|lbot
operator|->
name|val
operator|->
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
block|}
name|buckpt
operator|=
name|buckpt
operator|->
name|hshlnk
expr_stmt|;
block|}
comment|/*  Whoops!  Guess it wasn't in the hash table after all.  */
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetl
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETLENGTH MUST BE AN ARRAY"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|length
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputl
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO PUTLENGTH MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY LENGTH MUST BE AN INTEGER"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|<=
literal|0
condition|)
block|{
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY LENGTH MUST BE POSITIVE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|length
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetdel
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETDELTA MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|delta
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputdel
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO PUTDELTA MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY LENGTH MUST BE AN INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|i
operator|<=
literal|0
condition|)
block|{
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"ARRAY DELTA MUST BE POSITIVE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|delta
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetaux
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETAUX MUST BE ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|aux
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputaux
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"1st ARG TO PUTAUX MUST BBE ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|aux
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgeta
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO GETACCESS MUST BE AN ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|accfun
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputa
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"ARG TO PUTACCESS MUST BE ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|accfun
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmarray
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|(
name|handy
operator|=
name|newarray
argument_list|()
operator|)
expr_stmt|;
comment|/*  get a new array cell  */
name|handy
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|mylbot
operator|->
name|val
expr_stmt|;
comment|/*  insert data address  */
name|handy
operator|->
name|accfun
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
comment|/*  insert access function  */
name|handy
operator|->
name|aux
operator|=
name|mylbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
comment|/*  insert aux data  */
name|handy
operator|->
name|length
operator|=
name|mylbot
index|[
literal|3
index|]
operator|.
name|val
expr_stmt|;
comment|/*  insert length  */
name|handy
operator|->
name|delta
operator|=
name|mylbot
index|[
literal|4
index|]
operator|.
name|val
expr_stmt|;
comment|/*  push delta arg  */
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetentry
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARG TO GETENTRY MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|entry
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetlang
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"ARG TO GETLANG MUST BE FUNCTION DESCRIPTOR"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|language
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputlang
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"FIRST ARG TO PUTLANG MUST BE FUNCTION DESCRIPTOR"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|language
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
return|return
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetparams
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARG TO GETPARAMS MUST BE A FUNCTION DESCRIPTOR"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|params
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputparams
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"1st ARG TO PUTPARAMS MUST BE FUNCTION DESCRIPTOR"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|params
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetdisc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARGUMENT OF GETDISC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|->
name|discipline
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputdisc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARGUMENT OF PUTDISC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|discipline
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lgetloc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
name|error
argument_list|(
literal|"ARGUMENT TO GETLOC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
operator|->
name|val
operator|->
name|loctab
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lputloc
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|BCD
condition|)
empty_stmt|;
name|error
argument_list|(
literal|"FIRST ARGUMENT TO PUTLOC MUST BE FUNCTION"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|lbot
operator|)
operator|->
name|val
operator|->
name|loctab
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmfunction
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|handy
operator|=
operator|(
name|newfunct
argument_list|()
operator|)
expr_stmt|;
comment|/*  get a new function cell  */
name|handy
operator|->
name|entry
operator|=
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
operator|(
name|np
operator|-
literal|5
operator|)
operator|->
name|val
operator|)
expr_stmt|;
comment|/* insert entry point */
name|handy
operator|->
name|discipline
operator|=
operator|(
operator|(
name|np
operator|-
literal|4
operator|)
operator|->
name|val
operator|)
expr_stmt|;
comment|/*  insert discipline  */
ifdef|#
directive|ifdef
name|ROWAN
name|handy
operator|->
name|language
operator|=
operator|(
name|np
operator|-
literal|3
operator|)
operator|->
name|val
expr_stmt|;
comment|/*  insert language  */
name|handy
operator|->
name|params
operator|=
operator|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|)
expr_stmt|;
comment|/*  insert parameters  */
name|handy
operator|->
name|loctab
operator|=
operator|(
operator|(
name|np
operator|-
literal|1
operator|)
operator|->
name|val
operator|)
expr_stmt|;
comment|/*  insert local table  */
endif|#
directive|endif
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Lreplace ************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Destructively modifies almost any kind of data.		 	*/
end_comment

begin_function
name|lispval
name|Lreplace
parameter_list|()
block|{
specifier|register
name|lispval
name|a1
decl_stmt|,
name|a2
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|TYPE
argument_list|(
name|a1
operator|=
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|TYPE
argument_list|(
name|a2
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"REPLACE ARGS MUST BE SAME TYPE"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ATOM
case|:
name|error
argument_list|(
literal|"REPLACE CANNOT STORE ATOMS"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
case|case
name|VALUE
case|:
name|a1
operator|->
name|l
operator|=
name|a2
operator|->
name|l
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|INT
case|:
name|a1
operator|->
name|i
operator|=
name|a2
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|STRNG
case|:
name|error
argument_list|(
literal|"STORE CANNOT STORE STRINGS"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
case|case
name|ARRAY
case|:
name|a1
operator|->
name|data
operator|=
name|a2
operator|->
name|data
expr_stmt|;
name|a1
operator|->
name|accfun
operator|=
name|a2
operator|->
name|accfun
expr_stmt|;
name|a1
operator|->
name|length
operator|=
name|a2
operator|->
name|length
expr_stmt|;
name|a1
operator|->
name|delta
operator|=
name|a2
operator|->
name|delta
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|DOUB
case|:
name|a1
operator|->
name|r
operator|=
name|a2
operator|->
name|r
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|SDOT
case|:
case|case
name|DTPR
case|:
name|a1
operator|->
name|car
operator|=
name|a2
operator|->
name|car
expr_stmt|;
name|a1
operator|->
name|cdr
operator|=
name|a2
operator|->
name|cdr
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
case|case
name|BCD
case|:
name|a1
operator|->
name|entry
operator|=
name|a2
operator|->
name|entry
expr_stmt|;
name|a1
operator|->
name|discipline
operator|=
name|a2
operator|->
name|discipline
expr_stmt|;
return|return
operator|(
name|a1
operator|)
return|;
block|}
comment|/* NOT REACHED */
block|}
end_function

begin_comment
comment|/* Lvaluep */
end_comment

begin_function
name|lispval
name|Lvaluep
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|VALUE
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_macro
name|CNTTYP
argument_list|()
end_macro

begin_block
block|{
return|return;
comment|/* HI! COUNT ONE TYPE CALL! */
block|}
end_block

begin_function
name|lispval
name|Lod
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|error
argument_list|(
literal|"2nd ARG TO OD MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|np
operator|->
name|val
operator|->
name|i
condition|;
operator|++
name|i
control|)
name|printf
argument_list|(
name|copval
argument_list|(
name|odform
argument_list|,
name|CNIL
argument_list|)
operator|->
name|pname
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
name|np
index|[
operator|-
literal|2
index|]
operator|.
name|val
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|poport
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfake
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"ARG TO FAKE MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lwhat
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lpname
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"ARG TO PNAME MUST BE AN ATOM"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|pname
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Larrayref
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
operator|(
name|lbot
operator|)
operator|->
name|val
argument_list|)
operator|!=
name|ARRAY
condition|)
name|error
argument_list|(
literal|"FIRST ARG TO ARRAYREF MUST BE ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vtemp
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
name|chek
label|:
while|while
condition|(
name|TYPE
argument_list|(
name|vtemp
argument_list|)
operator|!=
name|INT
condition|)
name|vtemp
operator|=
name|error
argument_list|(
literal|"SECOND ARG TO ARRAYREF MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtemp
operator|->
name|i
operator|<
literal|0
condition|)
block|{
name|vtemp
operator|=
name|error
argument_list|(
literal|"NEGATIVE ARRAY OFFSET"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
if|if
condition|(
name|vtemp
operator|->
name|i
operator|>=
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|length
operator|->
name|i
condition|)
block|{
name|vtemp
operator|=
name|error
argument_list|(
literal|"ARRAY OFFSET TOO LARGE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
name|vtemp
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|data
operator|+
operator|(
operator|(
name|np
operator|-
literal|2
operator|)
operator|->
name|val
operator|->
name|delta
operator|->
name|i
operator|)
operator|*
operator|(
name|vtemp
operator|->
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/*  compute address of desired item  */
return|return
operator|(
name|vtemp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lptr
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewval
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llctrace
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|lctrace
operator|=
call|(
name|int
call|)
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|clb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|lctrace
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lslevel
parameter_list|()
block|{
return|return
operator|(
name|inewint
argument_list|(
name|np
operator|-
name|orgnp
operator|-
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsimpld
parameter_list|()
block|{
specifier|register
name|lispval
name|pt
decl_stmt|;
specifier|register
name|char
modifier|*
name|cpt
init|=
name|strbuf
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|atmlen
operator|=
literal|1
operator|,
name|pt
operator|=
name|np
operator|->
name|val
init|;
name|NOTNIL
argument_list|(
name|pt
argument_list|)
condition|;
operator|++
name|atmlen
operator|,
name|pt
operator|=
name|pt
operator|->
name|cdr
control|)
empty_stmt|;
if|if
condition|(
name|atmlen
operator|>
name|STRBLEN
condition|)
block|{
name|error
argument_list|(
literal|"LCODE WAS TOO LONG"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|pt
operator|=
name|np
operator|->
name|val
init|;
name|NOTNIL
argument_list|(
name|pt
argument_list|)
condition|;
name|pt
operator|=
name|pt
operator|->
name|cdr
control|)
operator|*
operator|(
name|cpt
operator|++
operator|)
operator|=
name|pt
operator|->
name|car
operator|->
name|i
expr_stmt|;
operator|*
name|cpt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|newstr
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Lopval  *************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Routine which allows system registers and options to be examined	*/
end_comment

begin_comment
comment|/*  and modified.  Calls copval, the routine which is called by c code	*/
end_comment

begin_comment
comment|/*  to do the same thing from inside the system.			*/
end_comment

begin_function
name|lispval
name|Lopval
parameter_list|()
block|{
name|lispval
name|quant
decl_stmt|;
name|snpand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
return|return
operator|(
name|error
argument_list|(
literal|"BAD CALL TO OPVAL"
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
name|quant
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/*  get name of sys variable  */
while|while
condition|(
name|TYPE
argument_list|(
name|quant
argument_list|)
operator|!=
name|ATOM
condition|)
name|quant
operator|=
name|error
argument_list|(
literal|"FIRST ARG TO OPVAL MUST BE AN ATOM"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|>
name|lbot
operator|+
literal|1
condition|)
name|vtemp
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
else|else
name|vtemp
operator|=
name|CNIL
expr_stmt|;
return|return
operator|(
name|copval
argument_list|(
name|quant
argument_list|,
name|vtemp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

