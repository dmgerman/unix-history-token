begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)Talloc.c	34.11 10/31/80"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|UNIXTS
end_ifndef

begin_include
include|#
directive|include
file|<vadvise.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NUMWORDS
value|TTSIZE * 128
end_define

begin_comment
comment|/*  max number of words in P0 space  */
end_comment

begin_define
define|#
directive|define
name|BITQUADS
value|TTSIZE * 2
end_define

begin_comment
comment|/*  length of bit map in quad words  */
end_comment

begin_define
define|#
directive|define
name|ftstbit
value|asm("	ashl	$-2,r11,r3");\ 			asm("	bbcs	r3,_bitmapq,$1");\ 			asm("	.byte	4");
end_define

begin_comment
comment|/*  define ftstbit	if( readbit(p) ) return; oksetbit;  */
end_comment

begin_define
define|#
directive|define
name|readbit
parameter_list|(
name|p
parameter_list|)
value|((int)bitmap[r=(int)p>>5]& (s=bitmsk[((int)p>>2)&7]))
end_define

begin_define
define|#
directive|define
name|lookbit
parameter_list|(
name|p
parameter_list|)
value|(bitmap[(int)p>>5]& bitmsk[((int)p>>2)& 7])
end_define

begin_define
define|#
directive|define
name|setbit
parameter_list|(
name|p
parameter_list|)
value|{bitmap[(int)p>>5] |= bitmsk[((int)p>> 2)& 7];}
end_define

begin_define
define|#
directive|define
name|oksetbit
value|{bitmap[r] |= s;}
end_define

begin_define
define|#
directive|define
name|readchk
parameter_list|(
name|p
parameter_list|)
value|((int)bitfre[(int)p>>5]& bitmsk[((int)p>>2)&7])
end_define

begin_define
define|#
directive|define
name|setchk
parameter_list|(
name|p
parameter_list|)
value|{bitfre[(int)p>>5] |= bitmsk[((int)p>> 2)& 7];}
end_define

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|,
name|l
parameter_list|)
value|(((x - 1) | (l - 1)) + 1)
end_define

begin_comment
comment|/* METER denotes something added to help meter storage allocation. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|heads
name|header
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|chkport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* garbage collection dump file */
end_comment

begin_decl_stmt
specifier|extern
name|lispval
name|datalim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  end of data space */
end_comment

begin_decl_stmt
name|double
name|bitmapq
index|[
name|BITQUADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  the bit map--one bit per long  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|METER
end_ifdef

begin_decl_stmt
name|double
name|Mbitmapq
index|[
name|BITQUADS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|double
name|zeroq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  a quad word of zeros  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bitmap
init|=
operator|(
name|char
operator|*
operator|)
name|bitmapq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  byte version of bit map array */
end_comment

begin_decl_stmt
name|int
modifier|*
name|bitmapi
init|=
operator|(
name|int
operator|*
operator|)
name|bitmapq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  integer version of bit map array */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|METER
end_ifdef

begin_decl_stmt
name|int
modifier|*
name|Mbitmapi
init|=
operator|(
name|int
operator|*
operator|)
name|Mbitmapq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  integer version of bit map array */
end_comment

begin_decl_stmt
name|int
name|freefree
decl_stmt|,
name|usedfree
decl_stmt|,
name|freeused
decl_stmt|,
name|usedused
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|METER
end_ifndef

begin_decl_stmt
name|int
name|freefree
decl_stmt|,
name|usedfree
decl_stmt|,
name|freeused
decl_stmt|,
name|usedused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need so external refs will be 					     satisfied, remove when get rid 					     of meter stuff 					 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|bitmsk
index|[
literal|8
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  used by bit-marking macros  */
end_comment

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|bind_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  lisp data for compiled code */
end_comment

begin_function_decl
name|char
modifier|*
name|xsbrk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|gethspace
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|atmlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|types
name|atom_str
decl_stmt|,
name|strng_str
decl_stmt|,
name|int_str
decl_stmt|,
name|dtpr_str
decl_stmt|,
name|doub_str
decl_stmt|,
name|array_str
decl_stmt|,
name|sdot_str
decl_stmt|,
name|val_str
decl_stmt|,
name|funct_str
decl_stmt|,
name|hunk_str
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|hunk_items
index|[
literal|7
index|]
decl_stmt|,
name|hunk_pages
index|[
literal|7
index|]
decl_stmt|,
name|hunk_name
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|initflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starts off TRUE: initially gc not allowed */
end_comment

begin_decl_stmt
name|int
name|gcflag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  TRUE during garbage collection  */
end_comment

begin_decl_stmt
name|int
name|current
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of pages currently allocated */
end_comment

begin_function_decl
specifier|static
name|struct
name|types
modifier|*
function_decl|(
name|spaces
function_decl|[
name|NUMSPACES
function_decl|]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|atom_str
block|,
operator|&
name|strng_str
block|,
operator|&
name|int_str
block|,
operator|&
name|dtpr_str
block|,
operator|&
name|doub_str
block|,
operator|&
name|array_str
block|,
operator|&
name|sdot_str
block|,
operator|&
name|val_str
block|,
operator|&
name|funct_str
block|,
operator|&
name|hunk_str
index|[
literal|0
index|]
block|,
operator|&
name|hunk_str
index|[
literal|1
index|]
block|,
operator|&
name|hunk_str
index|[
literal|2
index|]
block|,
operator|&
name|hunk_str
index|[
literal|3
index|]
block|,
operator|&
name|hunk_str
index|[
literal|4
index|]
block|,
operator|&
name|hunk_str
index|[
literal|5
index|]
block|,
operator|&
name|hunk_str
index|[
literal|6
index|]
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* this is a table of pointers to collectable struct types objects  * the index is the type number.  */
end_comment

begin_decl_stmt
name|struct
name|types
modifier|*
name|gcableptr
index|[]
init|=
block|{
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* strings not collectable */
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* atoms not collectable   */
operator|&
name|int_str
block|,
operator|&
name|dtpr_str
block|,
operator|&
name|doub_str
block|,
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* binary objects not collectable */
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* port objects not collectable */
operator|&
name|array_str
block|,
operator|(
expr|struct
name|types
operator|*
operator|)
literal|0
block|,
comment|/* gap in the type number sequence */
operator|&
name|sdot_str
block|,
operator|&
name|val_str
block|,
operator|&
name|hunk_str
index|[
literal|0
index|]
block|,
operator|&
name|hunk_str
index|[
literal|1
index|]
block|,
operator|&
name|hunk_str
index|[
literal|2
index|]
block|,
operator|&
name|hunk_str
index|[
literal|3
index|]
block|,
operator|&
name|hunk_str
index|[
literal|4
index|]
block|,
operator|&
name|hunk_str
index|[
literal|5
index|]
block|,
operator|&
name|hunk_str
index|[
literal|6
index|]
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** get_more_space(type_struct) *****************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Allocates and structures a new page, returning 0.			*/
end_comment

begin_comment
comment|/*  If no space is available, returns 1.				*/
end_comment

begin_macro
name|get_more_space
argument_list|(
argument|type_struct
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|cntr
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|int
modifier|*
name|loop
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|lispval
name|p
decl_stmt|,
name|plim
decl_stmt|;
name|struct
name|heads
modifier|*
name|next
decl_stmt|;
specifier|extern
name|char
name|holend
index|[]
decl_stmt|;
if|if
condition|(
name|initflag
operator|==
name|FALSE
condition|)
comment|/*  mustn't look at plist of plima too soon  */
block|{
while|while
condition|(
name|plim
operator|=
name|copval
argument_list|(
name|plima
argument_list|,
operator|(
name|lispval
operator|)
name|CNIL
argument_list|)
operator|,
name|TYPE
argument_list|(
name|plim
argument_list|)
operator|!=
name|INT
condition|)
name|copval
argument_list|(
name|plima
argument_list|,
name|error
argument_list|(
literal|"BAD PAGE LIMIT"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plim
operator|->
name|i
operator|<=
name|current
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/*  Can't allocate  */
block|}
if|if
condition|(
name|current
operator|>=
name|TTSIZE
condition|)
return|return
operator|(
literal|2
operator|)
return|;
ifdef|#
directive|ifdef
name|HOLE
if|if
condition|(
name|type_struct
operator|==
operator|&
name|strng_str
operator|||
operator|(
name|type_struct
operator|==
operator|&
name|funct_str
operator|)
condition|)
name|start
operator|=
name|gethspace
argument_list|(
name|NBPG
argument_list|,
name|type_struct
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|start
operator|=
name|xsbrk
argument_list|()
expr_stmt|;
name|SETTYPE
argument_list|(
name|start
argument_list|,
name|type_struct
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/*  set type of page  */
comment|/* bump the page counter for this space */
operator|++
operator|(
operator|(
operator|*
operator|(
name|type_struct
operator|->
name|pages
operator|)
operator|)
operator|->
name|i
operator|)
expr_stmt|;
name|type_struct
operator|->
name|space_left
operator|=
name|type_struct
operator|->
name|space
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|holend
condition|)
block|{
name|next
operator|=
operator|&
name|header
index|[
name|current
operator|++
index|]
expr_stmt|;
name|next
operator|->
name|pntr
operator|=
name|start
expr_stmt|;
name|next
operator|->
name|link
operator|=
name|type_struct
operator|->
name|first
expr_stmt|;
name|type_struct
operator|->
name|first
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|type_struct
operator|==
operator|&
name|strng_str
condition|)
block|{
name|type_struct
operator|->
name|next_free
operator|=
name|start
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  space was available  */
block|}
name|type_struct
operator|->
name|first
operator|=
name|next
expr_stmt|;
name|temp
operator|=
name|loop
operator|=
operator|(
name|int
operator|*
operator|)
name|start
expr_stmt|;
for|for
control|(
name|cntr
operator|=
literal|1
init|;
name|cntr
operator|<
name|type_struct
operator|->
name|space
condition|;
name|cntr
operator|++
control|)
name|loop
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|loop
operator|+
name|type_struct
operator|->
name|type_len
argument_list|)
operator|)
expr_stmt|;
operator|*
name|loop
operator|=
call|(
name|int
call|)
argument_list|(
name|type_struct
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|type_struct
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
comment|/*  if type atom, set pnames to CNIL  */
if|if
condition|(
name|type_struct
operator|==
operator|&
name|atom_str
condition|)
for|for
control|(
name|cntr
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|lispval
operator|)
name|temp
init|;
name|cntr
operator|<
name|atom_str
operator|.
name|space
condition|;
operator|++
name|cntr
control|)
block|{
name|p
operator|->
name|a
operator|.
name|pname
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
name|p
operator|=
call|(
name|lispval
call|)
argument_list|(
operator|(
name|int
operator|*
operator|)
name|p
operator|+
name|atom_str
operator|.
name|type_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  space was available  */
block|}
end_block

begin_comment
comment|/** next_one(type_struct) ************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Allocates one new item of each kind of space, except STRNG.		*/
end_comment

begin_comment
comment|/*  If there is no space, calls gc, the garbage collector.		*/
end_comment

begin_comment
comment|/*  If there is still no space, allocates a new page using		*/
end_comment

begin_comment
comment|/*  get_more_space(type_struct)						*/
end_comment

begin_function
name|lispval
name|next_one
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|type_struct
operator|->
name|next_free
operator|==
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
block|{
name|int
name|g
decl_stmt|;
if|if
condition|(
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|ATOM
operator|)
operator|&&
comment|/* can't collect atoms */
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|STRNG
operator|)
operator|&&
comment|/* can't collect strings */
operator|(
name|type_struct
operator|->
name|type
operator|!=
name|BCD
operator|)
operator|&&
comment|/* nor function headers  */
operator|(
name|gcthresh
operator|->
name|i
operator|<=
name|current
operator|)
operator|&&
comment|/* threshhold for gc */
name|gcdis
operator|->
name|a
operator|.
name|clb
operator|==
name|nil
operator|&&
comment|/* gc not disabled */
operator|(
name|NOTNIL
argument_list|(
name|copval
argument_list|(
name|gcload
argument_list|,
name|CNIL
argument_list|)
argument_list|)
operator|||
operator|(
name|loading
operator|->
name|a
operator|.
name|clb
operator|!=
name|tatom
operator|)
operator|)
operator|&&
comment|/* not to collect during load */
operator|(
name|initflag
operator|==
name|FALSE
operator|)
operator|&&
comment|/* dont gc during init */
operator|(
name|gcflag
operator|==
name|FALSE
operator|)
condition|)
comment|/* don't recurse gc */
block|{
comment|/* fputs("Collecting",poport); 			dmpport(poport);*/
name|gc
argument_list|(
name|type_struct
argument_list|)
expr_stmt|;
comment|/*  collect  */
block|}
if|if
condition|(
name|type_struct
operator|->
name|next_free
operator|!=
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|g
operator|=
name|get_more_space
argument_list|(
name|type_struct
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|g
operator|==
literal|1
condition|)
block|{
name|plimit
operator|->
name|i
operator|=
name|current
operator|+
name|NUMSPACES
expr_stmt|;
comment|/*  allow a few more pages  */
name|copval
argument_list|(
name|plima
argument_list|,
name|plimit
argument_list|)
expr_stmt|;
comment|/*  restore to reserved reg  */
name|error
argument_list|(
literal|"PAGE LIMIT EXCEEDED--EMERGENCY PAGES ALLOCATED"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"SORRY, ABSOLUTE PAGE LIMIT HAS BEEN REACHED"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|type_struct
operator|->
name|next_free
expr_stmt|;
name|type_struct
operator|->
name|next_free
operator|=
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|type_struct
operator|->
name|next_free
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newint
parameter_list|()
block|{
operator|++
operator|(
name|int_items
operator|->
name|i
operator|)
expr_stmt|;
return|return
operator|(
name|next_one
argument_list|(
operator|&
name|int_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newdot
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|dtpr_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|dtpr_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newdoub
parameter_list|()
block|{
operator|++
operator|(
name|doub_items
operator|->
name|i
operator|)
expr_stmt|;
return|return
operator|(
name|next_one
argument_list|(
operator|&
name|doub_str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newsdot
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|dtpr_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|sdot_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|atom
modifier|*
name|newatom
parameter_list|()
block|{
name|struct
name|atom
modifier|*
name|save
decl_stmt|;
operator|++
operator|(
name|atom_items
operator|->
name|i
operator|)
expr_stmt|;
name|save
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|next_one
argument_list|(
operator|&
name|atom_str
argument_list|)
expr_stmt|;
name|save
operator|->
name|plist
operator|=
name|save
operator|->
name|fnbnd
operator|=
name|nil
expr_stmt|;
name|save
operator|->
name|hshlnk
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
name|save
operator|->
name|clb
operator|=
name|CNIL
expr_stmt|;
name|save
operator|->
name|pname
operator|=
name|newstr
argument_list|()
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|newstr
parameter_list|()
block|{
name|char
modifier|*
name|save
decl_stmt|;
name|int
name|atmlen2
decl_stmt|,
name|atmlen
decl_stmt|;
operator|++
operator|(
name|str_items
operator|->
name|i
operator|)
expr_stmt|;
name|atmlen
operator|=
name|strlen
argument_list|(
name|strbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|atmlen
operator|>
name|strng_str
operator|.
name|space_left
condition|)
while|while
condition|(
name|get_more_space
argument_list|(
operator|&
name|strng_str
argument_list|)
condition|)
name|error
argument_list|(
literal|"YOU HAVE RUN OUT OF SPACE"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|save
operator|=
name|strng_str
operator|.
name|next_free
operator|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|atmlen2
operator|=
name|atmlen
expr_stmt|;
while|while
condition|(
name|atmlen2
operator|&
literal|3
condition|)
operator|++
name|atmlen2
expr_stmt|;
comment|/*  even up length of string  */
name|strng_str
operator|.
name|next_free
operator|+=
name|atmlen2
expr_stmt|;
name|strng_str
operator|.
name|space_left
operator|-=
name|atmlen2
expr_stmt|;
return|return
operator|(
name|save
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|inewstr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|strbuf
index|[
name|STRBLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpyn
argument_list|(
name|strbuf
argument_list|,
name|s
argument_list|,
name|STRBLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|newstr
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newarray
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|array_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|array_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|nil
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|accfun
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|aux
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|length
operator|=
name|SMALL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|->
name|ar
operator|.
name|delta
operator|=
name|SMALL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|badcall
parameter_list|()
block|{
name|error
argument_list|(
literal|"BAD FUNCTION DESCRIPTOR USED IN CALL"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|newfunct
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|funct_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|funct_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|bcd
operator|.
name|entry
operator|=
name|badcall
expr_stmt|;
name|temp
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newval
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|val_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|newhunk
parameter_list|(
name|hunknum
parameter_list|)
name|int
name|hunknum
decl_stmt|;
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|hunk_items
index|[
name|hunknum
index|]
operator|->
name|i
operator|)
expr_stmt|;
comment|/* Update used hunks count */
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|hunk_str
index|[
name|hunknum
index|]
argument_list|)
expr_stmt|;
comment|/* Get a hunk */
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|inewval
parameter_list|(
name|arg
parameter_list|)
name|lispval
name|arg
decl_stmt|;
block|{
name|lispval
name|temp
decl_stmt|;
operator|++
operator|(
name|val_items
operator|->
name|i
operator|)
expr_stmt|;
name|temp
operator|=
name|next_one
argument_list|(
operator|&
name|val_str
argument_list|)
expr_stmt|;
name|temp
operator|->
name|l
operator|=
name|arg
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/** Ngc *****************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  LISP interface to gc.						*/
end_comment

begin_function
name|lispval
name|Ngc
parameter_list|()
block|{
name|lispval
name|temp
decl_stmt|;
if|if
condition|(
name|ISNIL
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
return|return
operator|(
name|gc
argument_list|(
name|CNIL
argument_list|)
operator|)
return|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"BAD CALL TO GC"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|chkport
operator|=
name|poport
expr_stmt|;
if|if
condition|(
name|NOTNIL
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|car
argument_list|)
condition|)
block|{
name|temp
operator|=
name|eval
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|PORT
condition|)
name|chkport
operator|=
name|temp
operator|->
name|p
expr_stmt|;
block|}
name|gc1
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/** gc(type_struct) *****************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  garbage collector:  Collects garbage by mark and sweep algorithm.	*/
end_comment

begin_comment
comment|/*  After this is done, calls the Nlambda, gcafter.			*/
end_comment

begin_comment
comment|/*  gc may also be called from LISP, as a lambda of no arguments.	*/
end_comment

begin_function
name|lispval
name|gc
parameter_list|(
name|type_struct
parameter_list|)
name|struct
name|types
modifier|*
name|type_struct
decl_stmt|;
block|{
name|lispval
name|save
decl_stmt|;
struct|struct
block|{
name|long
name|mytime
decl_stmt|;
name|long
name|allelse
index|[
literal|3
index|]
decl_stmt|;
block|}
name|begin
struct|,
name|finish
struct|;
specifier|extern
name|int
name|GCtime
decl_stmt|;
name|save
operator|=
name|copval
argument_list|(
name|gcport
argument_list|,
name|CNIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCtime
condition|)
name|times
argument_list|(
operator|&
name|begin
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|save
argument_list|)
operator|!=
name|PORT
operator|)
operator|&&
name|NOTNIL
argument_list|(
name|save
argument_list|)
condition|)
name|save
operator|=
name|error
argument_list|(
literal|"NEED PORT FOR GC"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|chkport
operator|=
operator|(
name|ISNIL
argument_list|(
name|save
argument_list|)
condition|?
name|poport
else|:
name|save
operator|->
name|p
operator|)
expr_stmt|;
name|gc1
argument_list|(
name|NOTNIL
argument_list|(
name|copval
argument_list|(
name|gccheck
argument_list|,
name|CNIL
argument_list|)
argument_list|)
operator|||
operator|(
name|chkport
operator|!=
name|poport
operator|)
argument_list|)
expr_stmt|;
comment|/* mark&sweep */
comment|/* Now we call gcafter--special case if gc called from LISP */
if|if
condition|(
name|type_struct
operator|==
operator|(
expr|struct
name|types
operator|*
operator|)
name|CNIL
condition|)
name|gccall1
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
comment|/* make the call "(gcafter)" */
else|else
block|{
name|gccall1
operator|->
name|d
operator|.
name|cdr
operator|=
name|gccall2
expr_stmt|;
name|gccall2
operator|->
name|d
operator|.
name|car
operator|=
operator|*
operator|(
name|type_struct
operator|->
name|type_name
operator|)
expr_stmt|;
block|}
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|rdrsdot
operator|,
name|rdrsdot
operator|=
name|rdrsdot2
operator|,
name|rdrsdot2
operator|=
name|temp
expr_stmt|;
comment|/*KLUDGE*/
block|}
name|gcflag
operator|=
name|TRUE
expr_stmt|;
comment|/*  flag to indicate in garbage collector  */
name|save
operator|=
name|eval
argument_list|(
name|gccall1
argument_list|)
expr_stmt|;
comment|/*  call gcafter  */
name|gcflag
operator|=
name|FALSE
expr_stmt|;
comment|/*  turn off flag  */
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|rdrsdot
operator|,
name|rdrsdot
operator|=
name|rdrsdot2
operator|,
name|rdrsdot2
operator|=
name|temp
expr_stmt|;
comment|/*KLUDGE*/
block|}
if|if
condition|(
name|GCtime
condition|)
block|{
name|times
argument_list|(
operator|&
name|finish
argument_list|)
expr_stmt|;
name|GCtime
operator|+=
operator|(
name|finish
operator|.
name|mytime
operator|-
name|begin
operator|.
name|mytime
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|save
operator|)
return|;
comment|/*  return result of gcafter  */
block|}
end_function

begin_comment
comment|/*  gc1()  **************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  Mark-and-sweep phase						*/
end_comment

begin_macro
name|gc1
argument_list|(
argument|chkflag
argument_list|)
end_macro

begin_decl_stmt
name|int
name|chkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|j
decl_stmt|,
name|typep
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
modifier|*
name|start
decl_stmt|,
name|bvalue
decl_stmt|,
name|type_len
decl_stmt|;
specifier|register
name|struct
name|types
modifier|*
name|s
decl_stmt|;
name|int
modifier|*
name|point
decl_stmt|,
name|i
decl_stmt|,
name|freecnt
decl_stmt|,
name|itemstogo
decl_stmt|,
name|bits
decl_stmt|,
name|bindex
decl_stmt|,
name|type
decl_stmt|,
name|enddat
decl_stmt|;
name|struct
name|heads
modifier|*
name|loop
decl_stmt|;
name|struct
name|argent
modifier|*
name|loop2
decl_stmt|;
name|struct
name|nament
modifier|*
name|loop3
decl_stmt|;
ifdef|#
directive|ifdef
name|METER
name|int
name|Mbvalue
decl_stmt|;
endif|#
directive|endif
name|int
name|markdp
parameter_list|()
function_decl|;
name|int
name|debugin
init|=
name|FALSE
decl_stmt|;
comment|/* temp debug flag */
specifier|extern
name|int
modifier|*
name|beginsweep
decl_stmt|;
define|#
directive|define
name|ERDB
parameter_list|(
name|s
parameter_list|)
value|{ printf(s); fflush(stdout); }
ifndef|#
directive|ifndef
name|UNIXTS
name|vadvise
argument_list|(
name|VA_ANOM
argument_list|)
expr_stmt|;
comment|/*  decide whether to check LISP structure or not  */
endif|#
directive|endif
comment|/*  first set all bit maps to zero  */
if|if
condition|(
name|debugin
condition|)
name|ERDB
argument_list|(
literal|"Begin gc\n"
argument_list|)
expr_stmt|;
name|enddat
operator|=
operator|(
name|int
operator|)
name|datalim
operator|>>
literal|8
expr_stmt|;
for|for
control|(
name|bvalue
operator|=
literal|0
init|;
name|bvalue
operator|<
operator|(
name|int
operator|)
name|enddat
condition|;
operator|++
name|bvalue
control|)
block|{
ifdef|#
directive|ifdef
name|METER
comment|/* Mbitmapq[bvalue] = bitmapq[bvalue];  /* remember old vals */
comment|/* the C compiler will use a movd if we let it,and this 		   will not work since the bit maps may be illegal  		   floating point values 		*/
asm|asm(" movq _bitmapq[r10],_Mbitmapq[r10] ");
endif|#
directive|endif
name|bitmapq
index|[
name|bvalue
index|]
operator|=
name|zeroq
expr_stmt|;
block|}
comment|/* try the movc5 to clear the bit maps */
comment|/* blzero(bitmap,TTSIZE * 16); */
comment|/* then mark all atoms' plists, clbs, and function bindings */
for|for
control|(
name|loop
operator|=
name|atom_str
operator|.
name|first
init|;
name|loop
operator|!=
operator|(
expr|struct
name|heads
operator|*
operator|)
name|CNIL
condition|;
name|loop
operator|=
name|loop
operator|->
name|link
control|)
for|for
control|(
name|start
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|loop
operator|->
name|pntr
operator|)
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|atom_str
operator|.
name|space
condition|;
name|start
operator|=
name|start
operator|+
name|atom_str
operator|.
name|type_len
operator|,
operator|++
name|i
control|)
block|{
comment|/* unused atoms are marked with pname == CNIL */
comment|/* this is done by get_more_space, as well as */
comment|/* by gc (in the future)		      */
if|if
condition|(
operator|(
operator|(
name|lispval
operator|)
name|start
operator|)
operator|->
name|a
operator|.
name|pname
operator|==
operator|(
name|char
operator|*
operator|)
name|CNIL
condition|)
continue|continue;
define|#
directive|define
name|MARKSUB
parameter_list|(
name|p
parameter_list|)
value|if(nil!=((lispval)start)->p)markdp(((lispval)start)->p);
name|MARKSUB
argument_list|(
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
name|MARKSUB
argument_list|(
name|a
operator|.
name|fnbnd
argument_list|)
expr_stmt|;
name|MARKSUB
argument_list|(
name|a
operator|.
name|plist
argument_list|)
expr_stmt|;
block|}
comment|/* Mark all the atoms and ints associated with the hunk 	   data types */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|markdp
argument_list|(
name|hunk_items
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|markdp
argument_list|(
name|hunk_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|markdp
argument_list|(
name|hunk_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* next run up the name stack */
if|if
condition|(
name|debugin
condition|)
name|ERDB
argument_list|(
literal|"name stack\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|loop2
operator|=
name|np
operator|-
literal|1
init|;
name|loop2
operator|>=
name|orgnp
condition|;
operator|--
name|loop2
control|)
name|markdp
argument_list|(
operator|(
name|loop2
operator|->
name|val
operator|)
argument_list|)
expr_stmt|;
comment|/* now the bindstack (vals only, atoms are marked elsewhere ) */
for|for
control|(
name|loop3
operator|=
name|bnp
operator|-
literal|1
init|;
name|loop3
operator|>=
name|orgbnp
condition|;
operator|--
name|loop3
control|)
name|markdp
argument_list|(
name|loop3
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|ERDB
argument_list|(
literal|"compiler stuff\n"
argument_list|)
expr_stmt|;
comment|/* from TBL 29july79  */
comment|/* next mark all compiler linked data */
name|point
operator|=
name|bind_lists
expr_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|point
operator|)
operator|!=
operator|(
name|int
operator|*
operator|)
name|CNIL
condition|)
block|{
if|if
condition|(
name|debugin
condition|)
name|ERDB
argument_list|(
literal|"once "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|!=
operator|-
literal|1
condition|)
name|markdp
argument_list|(
operator|*
name|start
operator|++
argument_list|)
expr_stmt|;
name|point
operator|=
operator|(
name|int
operator|*
operator|)
operator|*
operator|(
name|point
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* end from TBL */
if|if
condition|(
name|debugin
condition|)
name|ERDB
argument_list|(
literal|"signif stuff\n"
argument_list|)
expr_stmt|;
comment|/* next mark all system-significant lisp data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIGNIF
condition|;
operator|++
name|i
control|)
name|markdp
argument_list|(
operator|(
name|lispsys
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugin
condition|)
name|printf
argument_list|(
literal|"time to sweep up\n"
argument_list|)
expr_stmt|;
comment|/* all accessible data has now been marked. */
comment|/* all collectable spaces must be swept,    */
comment|/* and freelists constructed.		    */
comment|/* first clear the structure elements for types 	 * we will sweep 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|HUNK128
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|=
name|gcableptr
index|[
name|k
index|]
condition|)
block|{
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|space_left
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
block|}
block|}
comment|/* sweep up in memory looking at gcable pages */
for|for
control|(
name|start
operator|=
name|beginsweep
operator|,
name|bindex
operator|=
operator|(
name|int
operator|)
name|start
operator|>>
literal|7
init|;
name|start
operator|<
operator|(
name|int
operator|*
operator|)
name|datalim
condition|;
name|start
operator|+=
literal|128
control|)
block|{
comment|/* printf(" start %x, bindex %x\n",start,bindex); */
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|gcableptr
index|[
name|type
operator|=
name|TYPE
argument_list|(
name|start
argument_list|)
index|]
operator|)
condition|)
block|{
name|bindex
operator|+=
literal|4
expr_stmt|;
comment|/* and 4 words of 32 bit bitmap words */
continue|continue;
block|}
name|freecnt
operator|=
literal|0
expr_stmt|;
comment|/* number of free items found */
name|itemstogo
operator|=
name|s
operator|->
name|space
expr_stmt|;
comment|/* number of items per page  */
name|bits
operator|=
literal|32
expr_stmt|;
comment|/* number of bits per word */
name|type_len
operator|=
name|s
operator|->
name|type_len
expr_stmt|;
comment|/* printf(" s %d, itemstogo %d, len %d\n",s,itemstogo,type_len);*/
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
name|Mbvalue
operator|=
name|Mbitmapi
index|[
name|bindex
operator|-
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|point
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/*printf(" bv: %08x, ",bvalue);*/
if|if
condition|(
operator|!
operator|(
name|bvalue
operator|&
literal|1
operator|)
condition|)
comment|/* if data element is not marked */
block|{
name|freecnt
operator|++
expr_stmt|;
operator|*
name|point
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|->
name|next_free
argument_list|)
expr_stmt|;
name|s
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|point
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
if|if
condition|(
name|type
operator|==
name|DTPR
condition|)
block|{
if|if
condition|(
name|Mbvalue
operator|&
literal|1
condition|)
name|usedfree
operator|++
expr_stmt|;
else|else
name|freefree
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|METER
elseif|else
if|if
condition|(
name|type
operator|==
name|DTPR
condition|)
block|{
if|if
condition|(
name|Mbvalue
operator|&
literal|1
condition|)
name|usedused
operator|++
expr_stmt|;
else|else
name|freeused
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|--
name|itemstogo
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|type_len
operator|>=
literal|64
condition|)
block|{
name|bindex
operator|++
expr_stmt|;
if|if
condition|(
name|type_len
operator|>=
literal|128
condition|)
name|bindex
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
block|}
name|point
operator|+=
name|type_len
expr_stmt|;
comment|/* shift over mask by number of words in data type */
if|if
condition|(
operator|(
name|bits
operator|-=
name|type_len
operator|)
operator|>
literal|0
condition|)
block|{
name|bvalue
operator|=
name|bvalue
operator|>>
name|type_len
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
name|Mbvalue
operator|=
name|Mbvalue
operator|>>
name|type_len
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
block|{
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
name|Mbvalue
operator|=
name|Mbitmapi
index|[
name|bindex
operator|-
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
name|bits
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|bits
operator|=
operator|-
name|bits
expr_stmt|;
while|while
condition|(
name|bits
operator|>=
literal|32
condition|)
block|{
name|bindex
operator|++
expr_stmt|;
name|bits
operator|-=
literal|32
expr_stmt|;
block|}
name|bvalue
operator|=
name|bitmapi
index|[
name|bindex
operator|++
index|]
expr_stmt|;
name|bvalue
operator|=
name|bvalue
operator|>>
name|bits
expr_stmt|;
ifdef|#
directive|ifdef
name|METER
name|Mbvalue
operator|=
name|Mbitmapi
index|[
name|bindex
operator|-
literal|1
index|]
expr_stmt|;
name|Mbvalue
operator|=
name|Mbvalue
operator|>>
name|bits
expr_stmt|;
endif|#
directive|endif
name|bits
operator|=
literal|32
operator|-
name|bits
expr_stmt|;
empty_stmt|;
block|}
block|}
comment|/* printf(" t %d,fr %d ",type,freecnt); */
name|s
operator|->
name|space_left
operator|+=
name|freecnt
expr_stmt|;
operator|(
operator|*
operator|(
name|s
operator|->
name|items
operator|)
operator|)
operator|->
name|i
operator|+=
name|s
operator|->
name|space
operator|-
name|freecnt
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|UNIXTS
name|vadvise
argument_list|(
name|VA_NORM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/** alloc() *************************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  This routine tries to allocate one more page of the space named	*/
end_comment

begin_comment
comment|/*  by the argument.  If no more space is available returns 1, else 0.	*/
end_comment

begin_function
name|lispval
name|alloc
parameter_list|(
name|tname
parameter_list|,
name|npages
parameter_list|)
name|lispval
name|tname
decl_stmt|;
name|int
name|npages
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|ii
operator|=
name|typenum
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|datalim
operator|>>
literal|9
operator|)
operator|+
name|npages
operator|>
name|TTSIZE
condition|)
name|error
argument_list|(
literal|"Space request would exceed maximum memory allocation"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|npages
condition|;
operator|++
name|jj
control|)
if|if
condition|(
name|get_more_space
argument_list|(
name|spaces
index|[
name|ii
index|]
argument_list|)
condition|)
break|break;
return|return
operator|(
name|inewint
argument_list|(
name|jj
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|csegment
parameter_list|(
name|tname
parameter_list|,
name|nitems
parameter_list|,
name|useholeflag
parameter_list|)
name|lispval
name|tname
decl_stmt|;
name|int
name|nitems
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|char
modifier|*
name|charadd
decl_stmt|;
name|ii
operator|=
name|typenum
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|nitems
operator|*
literal|4
operator|*
name|spaces
index|[
name|ii
index|]
operator|->
name|type_len
expr_stmt|;
comment|/*  find c-length of space  */
name|nitems
operator|=
name|roundup
argument_list|(
name|nitems
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/*  round up to right length  */
ifdef|#
directive|ifdef
name|HOLE
if|if
condition|(
operator|(
name|tname
operator|==
name|str_name
operator|)
operator|&&
name|useholeflag
condition|)
name|charadd
operator|=
name|gethspace
argument_list|(
name|nitems
argument_list|,
name|ii
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|current
operator|+=
name|nitems
operator|/
literal|512
expr_stmt|;
name|charadd
operator|=
name|sbrk
argument_list|(
name|nitems
argument_list|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|charadd
operator|+
name|nitems
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|charadd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"NOT ENOUGH SPACE FOR ARRAY"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|int
operator|)
name|datalim
operator|)
operator|>>
literal|9
operator|)
operator|>
name|TTSIZE
condition|)
block|{
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|TTSIZE
operator|<<
literal|9
argument_list|)
expr_stmt|;
name|badmem
argument_list|(
literal|53
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nitems
condition|;
name|jj
operator|=
name|jj
operator|+
literal|512
control|)
block|{
name|SETTYPE
argument_list|(
name|charadd
operator|+
name|jj
argument_list|,
name|spaces
index|[
name|ii
index|]
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|blzero
argument_list|(
name|charadd
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|charadd
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csizeof
parameter_list|(
name|tname
parameter_list|)
name|lispval
name|tname
decl_stmt|;
block|{
return|return
operator|(
name|spaces
index|[
name|typenum
argument_list|(
name|tname
argument_list|)
index|]
operator|->
name|type_len
operator|*
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|int
name|typenum
parameter_list|(
name|tname
parameter_list|)
name|lispval
name|tname
decl_stmt|;
block|{
name|int
name|ii
decl_stmt|;
name|chek
label|:
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|NUMSPACES
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|tname
operator|==
operator|*
operator|(
name|spaces
index|[
name|ii
index|]
operator|->
name|type_name
operator|)
condition|)
break|break;
if|if
condition|(
name|ii
operator|==
name|NUMSPACES
condition|)
block|{
name|tname
operator|=
name|error
argument_list|(
literal|"BAD TYPE NAME"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|chek
goto|;
block|}
return|return
operator|(
name|ii
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gethspace
parameter_list|(
name|segsiz
parameter_list|,
name|type
parameter_list|)
block|{
extern|extern usehole;
specifier|extern
name|char
name|holend
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|curhbeg
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|usehole
condition|)
block|{
name|curhbeg
operator|=
operator|(
name|char
operator|*
operator|)
name|roundup
argument_list|(
operator|(
operator|(
name|int
operator|)
name|curhbeg
operator|)
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|holend
operator|-
name|curhbeg
operator|)
operator|<
name|segsiz
condition|)
block|{
name|printf
argument_list|(
literal|"[fasl hole filled up]\n"
argument_list|)
expr_stmt|;
name|usehole
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|curhbeg
expr_stmt|;
name|curhbeg
operator|=
name|curhbeg
operator|+
name|segsiz
expr_stmt|;
comment|/*printf("start %d, finish %d, size %d\n",value, curhbeg,segsiz);*/
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
name|value
operator|=
operator|(
name|ysbrk
argument_list|(
name|segsiz
operator|/
name|NBPG
argument_list|,
name|type
argument_list|)
operator|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|value
operator|+
name|segsiz
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_macro
name|gcrebear
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|HOLE
comment|/* this gets done upon rebirth */
name|strng_str
operator|.
name|space_left
operator|=
literal|0
expr_stmt|;
name|funct_str
operator|.
name|space_left
operator|=
literal|0
expr_stmt|;
name|funct_str
operator|.
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|CNIL
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/** markit(p) ***********************************************************/
end_comment

begin_comment
comment|/*  just calls markdp							*/
end_comment

begin_macro
name|markit
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|lispval
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|markdp
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/** markdp(p) ***********************************************************/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/*  markdp is the routine which marks each data item.  If it is a	*/
end_comment

begin_comment
comment|/*  dotted pair, the car and cdr are marked also.			*/
end_comment

begin_comment
comment|/*  An iterative method is used to mark list structure, to avoid	*/
end_comment

begin_comment
comment|/*  excessive recursion.						*/
end_comment

begin_expr_stmt
name|markdp
argument_list|(
name|p
argument_list|)
specifier|register
name|lispval
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*	register int r, s;	(goes with non-asm readbit, oksetbit)	*/
comment|/*	register hsize, hcntr;						*/
name|int
name|hsize
decl_stmt|,
name|hcntr
decl_stmt|;
name|ptr_loop
label|:
if|if
condition|(
operator|(
name|int
operator|)
name|p
operator|<=
literal|0
condition|)
return|return;
comment|/*  do not mark special data types or nil=0  */
switch|switch
condition|(
name|TYPE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
case|case
name|DOUB
case|:
comment|/*			setbit(p);*/
name|ftstbit
expr_stmt|;
return|return;
case|case
name|VALUE
case|:
name|ftstbit
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|l
expr_stmt|;
goto|goto
name|ptr_loop
goto|;
case|case
name|DTPR
case|:
name|ftstbit
expr_stmt|;
name|markdp
argument_list|(
name|p
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
goto|goto
name|ptr_loop
goto|;
case|case
name|ARRAY
case|:
name|ftstbit
expr_stmt|;
comment|/* mark array itself */
name|markdp
argument_list|(
name|p
operator|->
name|ar
operator|.
name|accfun
argument_list|)
expr_stmt|;
comment|/* mark access function */
name|markdp
argument_list|(
name|p
operator|->
name|ar
operator|.
name|aux
argument_list|)
expr_stmt|;
comment|/* mark aux data */
name|markdp
argument_list|(
name|p
operator|->
name|ar
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* mark length */
name|markdp
argument_list|(
name|p
operator|->
name|ar
operator|.
name|delta
argument_list|)
expr_stmt|;
comment|/* mark delta */
if|if
condition|(
name|TYPE
argument_list|(
name|p
operator|->
name|ar
operator|.
name|aux
argument_list|)
operator|==
name|DTPR
operator|&&
name|p
operator|->
name|ar
operator|.
name|aux
operator|->
name|d
operator|.
name|car
operator|==
name|Vnogbar
condition|)
return|return;
block|{
comment|/*			register int i, l; int d;		*/
comment|/*			register char *dataptr = p->ar.data;	*/
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|d
decl_stmt|;
name|char
modifier|*
name|dataptr
init|=
name|p
operator|->
name|ar
operator|.
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|l
operator|=
name|p
operator|->
name|ar
operator|.
name|length
operator|->
name|i
operator|,
name|d
operator|=
name|p
operator|->
name|ar
operator|.
name|delta
operator|->
name|i
init|;
name|i
operator|<
name|l
condition|;
operator|++
name|i
control|)
block|{
name|markdp
argument_list|(
name|dataptr
argument_list|)
expr_stmt|;
name|dataptr
operator|+=
name|d
expr_stmt|;
block|}
return|return;
block|}
case|case
name|SDOT
case|:
do|do
block|{
name|ftstbit
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|0
condition|)
do|;
return|return;
case|case
name|BCD
case|:
name|ftstbit
expr_stmt|;
name|markdp
argument_list|(
name|p
operator|->
name|bcd
operator|.
name|discipline
argument_list|)
expr_stmt|;
return|return;
case|case
name|HUNK2
case|:
case|case
name|HUNK4
case|:
case|case
name|HUNK8
case|:
case|case
name|HUNK16
case|:
case|case
name|HUNK32
case|:
case|case
name|HUNK64
case|:
case|case
name|HUNK128
case|:
block|{
name|hsize
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ftstbit
expr_stmt|;
for|for
control|(
name|hcntr
operator|=
literal|0
init|;
name|hcntr
operator|<
name|hsize
condition|;
name|hcntr
operator|++
control|)
name|markdp
argument_list|(
name|p
operator|->
name|h
operator|.
name|hunk
index|[
name|hcntr
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
return|return;
block|}
end_block

begin_function
name|char
modifier|*
name|xsbrk
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|xx
decl_stmt|;
comment|/*  pointer to next available blank page  */
specifier|extern
name|int
name|xcycle
decl_stmt|;
comment|/*  number of blank pages available  */
name|lispval
name|u
decl_stmt|;
comment|/*  used to compute limits of bit table  */
if|if
condition|(
operator|(
name|xcycle
operator|--
operator|)
operator|<=
literal|0
condition|)
block|{
name|xcycle
operator|=
literal|15
expr_stmt|;
name|xx
operator|=
name|sbrk
argument_list|(
literal|16
operator|*
name|NBPG
argument_list|)
expr_stmt|;
comment|/*  get pages 16 at a time  */
if|if
condition|(
operator|(
name|int
operator|)
name|xx
operator|==
operator|-
literal|1
condition|)
name|lispend
argument_list|(
literal|"For sbrk from lisp: no space... Goodbye!"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|xx
operator|+=
name|NBPG
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|u
operator|=
call|(
name|lispval
call|)
argument_list|(
name|xx
operator|+
name|NBPG
argument_list|)
operator|)
operator|>
name|datalim
condition|)
name|datalim
operator|=
name|u
expr_stmt|;
return|return
operator|(
name|xx
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ysbrk
parameter_list|(
name|pages
parameter_list|,
name|type
parameter_list|)
name|int
name|pages
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|xx
decl_stmt|;
comment|/*  will point to block of storage  */
name|int
name|i
decl_stmt|;
name|xx
operator|=
name|sbrk
argument_list|(
name|pages
operator|*
name|NBPG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|xx
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"OUT OF SPACE FOR ARRAY REQUEST"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|datalim
operator|=
call|(
name|lispval
call|)
argument_list|(
name|xx
operator|+
name|pages
operator|*
name|NBPG
argument_list|)
expr_stmt|;
comment|/*  compute bit table limit  */
comment|/*  set type for pages  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
condition|;
operator|++
name|i
control|)
block|{
name|SETTYPE
argument_list|(
operator|(
name|xx
operator|+
name|i
operator|*
name|NBPG
operator|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|xx
operator|)
return|;
comment|/*  return pointer to block of storage  */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* sbrk -   *   this function is used by the VMS franz to allocate space.    * It allocates space in the zfreespace array.  * The single argument passed to sbrk is the number of bytes to allocate  *  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|zfreespace
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|lsbrkpnt
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|sbrk
parameter_list|(
name|n
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|lsbrkpnt
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|lsbrkpnt
operator|=
operator|(
name|char
operator|*
operator|)
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|zfreespace
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|lsbrkpnt
expr_stmt|;
comment|/*	printf("lispbrk: %x \n",lsbrkpnt); 	fflush(stdout);  */
name|lsbrkpnt
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|lsbrkpnt
operator|>
operator|&
name|zfreespace
index|[
name|FREESIZE
index|]
condition|)
name|error
argument_list|(
literal|"sbrk: out of space "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* getatom **************************************************************/
end_comment

begin_comment
comment|/* returns either an existing atom with the name specified in strbuf, or*/
end_comment

begin_comment
comment|/* if the atom does not already exist, regurgitates a new one and       */
end_comment

begin_comment
comment|/* returns it.                                                          */
end_comment

begin_function
name|lispval
name|getatom
parameter_list|()
block|{
specifier|register
name|lispval
name|aptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|endname
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|lispval
name|b
decl_stmt|;
name|char
name|c
decl_stmt|;
name|name
operator|=
name|strbuf
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
operator|(
name|char
operator|)
literal|0377
condition|)
return|return
operator|(
name|eofa
operator|)
return|;
name|hash
operator|=
name|hashfcn
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|atmlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|hasht
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
name|CNIL
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|aptr
operator|->
name|a
operator|.
name|pname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|aptr
operator|)
return|;
else|else
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|aptr
operator|->
name|a
operator|.
name|hshlnk
expr_stmt|;
name|aptr
operator|=
operator|(
name|lispval
operator|)
name|newatom
argument_list|()
expr_stmt|;
name|aptr
operator|->
name|a
operator|.
name|hshlnk
operator|=
name|hasht
index|[
name|hash
index|]
expr_stmt|;
name|hasht
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|aptr
expr_stmt|;
name|endname
operator|=
name|name
operator|+
name|atmlen
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|atmlen
operator|!=
literal|4
operator|)
operator|&&
operator|(
operator|*
name|name
operator|==
literal|'c'
operator|)
operator|&&
operator|(
operator|*
name|endname
operator|==
literal|'r'
operator|)
condition|)
block|{
name|b
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|lambda
expr_stmt|;
name|b
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|newdot
argument_list|()
expr_stmt|;
operator|(
name|b
operator|->
name|d
operator|.
name|car
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|xatom
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|b
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
operator|++
name|name
operator|==
name|endname
condition|)
block|{
name|b
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|lispval
operator|)
name|xatom
expr_stmt|;
name|aptr
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|unprot
argument_list|()
expr_stmt|;
break|break;
block|}
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|)
operator|==
literal|'a'
condition|)
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|cara
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
name|b
operator|->
name|d
operator|.
name|car
operator|=
name|cdra
expr_stmt|;
else|else
block|{
name|unprot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|aptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* our hash function */
end_comment

begin_macro
name|hashfcn
argument_list|(
argument|symb
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|symb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|symb
condition|;
name|i
operator|+=
name|i
operator|+
operator|*
name|symb
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|&
operator|(
name|HASHTOP
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|atom
modifier|*
name|hasht
index|[
name|HASHTOP
index|]
decl_stmt|;
end_decl_stmt

end_unit

