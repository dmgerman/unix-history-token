begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)fex2.c	35.3 7/1/81"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_define
define|#
directive|define
name|NDOVARS
value|30
end_define

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/*  * Ndo  maclisp do function.  */
end_comment

begin_function
name|lispval
name|Ndo
parameter_list|()
block|{
specifier|register
name|lispval
name|current
decl_stmt|,
name|where
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|mybnp
decl_stmt|;
name|lispval
name|temp
decl_stmt|,
name|atom
decl_stmt|;
name|lispval
name|body
decl_stmt|,
name|endtest
decl_stmt|,
name|endform
decl_stmt|,
name|varstuff
decl_stmt|,
name|renewals
index|[
name|NDOVARS
index|]
decl_stmt|;
name|struct
name|argent
modifier|*
name|getem
decl_stmt|,
modifier|*
name|startnp
decl_stmt|;
name|struct
name|nament
modifier|*
name|savedbnp
init|=
name|bnp
decl_stmt|;
name|int
name|count
decl_stmt|,
name|repeatdo
decl_stmt|,
name|index
decl_stmt|,
name|virgin
init|=
literal|1
decl_stmt|;
specifier|extern
name|struct
name|frame
modifier|*
name|errp
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|varstuff
operator|=
name|current
operator|->
name|d
operator|.
name|car
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|varstuff
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
comment|/* This is old style maclisp do; 					   atom is var, cadr(current) = init; 					   caddr(current) = repeat etc. */
if|if
condition|(
name|varstuff
operator|==
name|nil
condition|)
goto|goto
name|newstyle
goto|;
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* car(current) is now init */
name|PUSHDOWN
argument_list|(
name|varstuff
argument_list|,
name|eval
argument_list|(
name|current
operator|->
name|d
operator|.
name|car
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init var.	    */
operator|*
name|renewals
operator|=
operator|(
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
operator|)
operator|->
name|d
operator|.
name|car
expr_stmt|;
comment|/* get repeat form  */
name|endtest
operator|=
operator|(
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
operator|)
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|body
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_PROG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|C_RET
case|:
comment|/* 				 * returning from this prog, value to return 				 * is in lispretval 				 */
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
case|case
name|C_GO
case|:
comment|/* 				 * going to a certain label, label to go to in 				 * in lispretval 				 */
name|where
operator|=
name|body
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
operator|)
operator|&
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|!=
name|lispretval
operator|)
condition|)
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|where
operator|->
name|d
operator|.
name|car
operator|==
name|lispretval
condition|)
block|{
name|popnames
argument_list|(
name|errp
operator|->
name|svbnp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* label not found in this prog, must  				 * go up to higher prog 				 */
name|Inonlocalgo
argument_list|(
name|C_GO
argument_list|,
name|lispretval
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|C_INITIAL
case|:
break|break;
comment|/* fall through */
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|eval
argument_list|(
name|endtest
argument_list|)
operator|!=
name|nil
condition|)
block|{
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|where
operator|=
name|body
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|temp
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|eval
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
name|varstuff
operator|->
name|a
operator|.
name|clb
operator|=
name|eval
argument_list|(
operator|*
name|renewals
argument_list|)
expr_stmt|;
block|}
name|newstyle
label|:
case|case
name|DTPR
case|:
comment|/* New style maclisp do; atom is 					   list of things of the form 					   (var init repeat)		*/
name|count
operator|=
literal|0
expr_stmt|;
name|startnp
operator|=
name|np
expr_stmt|;
for|for
control|(
name|where
operator|=
name|varstuff
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
control|)
block|{
comment|/* do inits and count do vars. */
comment|/* requires "simultaneous" eval 					   of all inits			*/
name|handy
operator|=
name|where
operator|->
name|d
operator|.
name|car
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|temp
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|handy
operator|!=
name|nil
condition|)
name|temp
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|NDOVARS
condition|)
name|error
argument_list|(
literal|"More than 15 do vars"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|where
operator|=
name|varstuff
expr_stmt|;
name|getem
operator|=
name|startnp
expr_stmt|;
comment|/* base of stack of init forms */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
block|{
name|handy
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
comment|/* get var name from group	*/
name|atom
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|atom
argument_list|)
operator|!=
name|ATOM
condition|)
name|atom
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"do variable must be a symbol "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|atom
argument_list|)
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|atom
argument_list|,
name|getem
operator|->
name|val
argument_list|)
expr_stmt|;
name|getem
operator|++
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|handy
operator|=
name|CNIL
expr_stmt|;
comment|/* be sure not to rebind later */
else|else
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|renewals
index|[
name|index
index|]
operator|=
name|handy
expr_stmt|;
comment|/* more loop "increments" */
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
name|np
operator|=
name|startnp
expr_stmt|;
comment|/* pop off all init forms */
comment|/* Examine End test and End form */
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|handy
operator|=
name|current
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|body
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/*  		 * a do form with a test of nil just does the body once 		 * and returns nil 		 */
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|repeatdo
operator|=
literal|1
expr_stmt|;
comment|/* just do it once */
else|else
name|repeatdo
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* do it forever   */
name|endtest
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|endform
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|where
operator|=
name|body
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_PROG
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|C_RET
case|:
comment|/* 				 * returning from this prog, value to return 				 * is in lispretval 				 */
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
case|case
name|C_GO
case|:
comment|/* 				 * going to a certain label, label to go to in 				 * in lispretval 				 */
name|where
operator|=
name|body
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
operator|)
operator|&
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|!=
name|lispretval
operator|)
condition|)
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|where
operator|->
name|d
operator|.
name|car
operator|==
name|lispretval
condition|)
block|{
name|popnames
argument_list|(
name|errp
operator|->
name|svbnp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* label not found in this prog, must  				 * go up to higher prog 				 */
name|Inonlocalgo
argument_list|(
name|C_GO
argument_list|,
name|lispretval
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|C_INITIAL
case|:
break|break;
comment|/* fall through */
block|}
name|loop
label|:
name|np
operator|=
name|startnp
expr_stmt|;
comment|/* is bumped when doing repeat forms */
if|if
condition|(
operator|(
name|repeatdo
operator|--
operator|==
literal|0
operator|)
operator|||
operator|(
name|eval
argument_list|(
name|endtest
argument_list|)
operator|!=
name|nil
operator|)
condition|)
block|{
for|for
control|(
name|handy
operator|=
name|nil
init|;
name|endform
operator|!=
name|nil
condition|;
name|endform
operator|=
name|endform
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|handy
operator|=
name|eval
argument_list|(
name|endform
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
while|while
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|temp
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|eval
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
name|where
operator|=
name|body
expr_stmt|;
name|getem
operator|=
name|np
operator|=
name|startnp
expr_stmt|;
comment|/* Simultaneously eval repeat forms */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
block|{
name|temp
operator|=
name|renewals
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|nil
operator|||
name|temp
operator|==
name|CNIL
condition|)
name|protect
argument_list|(
name|temp
argument_list|)
expr_stmt|;
else|else
name|protect
argument_list|(
name|eval
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* now simult. rebind all the atoms */
name|mybnp
operator|=
name|savedbnp
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|count
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|getem
operator|->
name|val
operator|!=
name|CNIL
condition|)
comment|/* if this atom has a repeat */
name|mybnp
operator|->
name|atm
operator|->
name|a
operator|.
name|clb
operator|=
operator|(
name|getem
operator|)
operator|->
name|val
expr_stmt|;
comment|/* rebind */
name|mybnp
operator|++
expr_stmt|;
name|getem
operator|++
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
block|}
block|}
end_function

begin_function
name|lispval
name|Nprogv
parameter_list|()
block|{
specifier|register
name|lispval
name|where
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|vars
decl_stmt|,
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|argent
modifier|*
name|start
decl_stmt|;
name|struct
name|nament
modifier|*
name|oldbnp
init|=
name|bnp
decl_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|protect
argument_list|(
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
argument_list|)
expr_stmt|;
comment|/* list of vars = lbot[1].val */
name|protect
argument_list|(
name|eval
argument_list|(
operator|(
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
operator|)
operator|->
name|d
operator|.
name|car
argument_list|)
argument_list|)
expr_stmt|;
comment|/* list of vals */
name|handy
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
name|start
operator|=
name|np
expr_stmt|;
name|namptr
operator|=
name|oldbnp
expr_stmt|;
comment|/* simultaneous eval of all 						   args */
for|for
control|(
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
operator|(
name|np
operator|++
operator|)
operator|->
name|val
operator|=
operator|(
name|handy
operator|->
name|d
operator|.
name|car
operator|)
expr_stmt|;
comment|/*  Note, each element should not be reevaluated like it  		 *  was  before.  - dhl */
comment|/* Before: (np++)->val = eval(handy->d.car);*/
name|TNP
expr_stmt|;
block|}
asm|asm("# Here is where rebinding is done");
comment|/* very cute */
for|for
control|(
name|handy
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|,
name|vars
operator|=
name|lbot
operator|+
literal|3
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|namptr
operator|->
name|atm
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
operator|++
name|namptr
expr_stmt|;
comment|/* protect against interrupts 						   while re-lambda binding */
name|bnp
operator|=
name|namptr
expr_stmt|;
name|namptr
index|[
operator|-
literal|1
index|]
operator|.
name|atm
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|namptr
index|[
operator|-
literal|1
index|]
operator|.
name|val
operator|=
name|handy
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
expr_stmt|;
if|if
condition|(
name|vars
operator|<
name|np
condition|)
name|handy
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
operator|=
name|vars
operator|++
operator|->
name|val
expr_stmt|;
else|else
name|handy
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
block|}
name|handy
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
control|)
name|handy
operator|=
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|oldbnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nprogn
parameter_list|()
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|where
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|where
operator|=
name|lbot
operator|->
name|val
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
control|)
name|result
operator|=
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nprog2
parameter_list|()
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|where
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|result
operator|=
name|eval
argument_list|(
operator|(
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
operator|)
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
control|)
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

