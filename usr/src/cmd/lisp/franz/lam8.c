begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)lam8.c	35.7 7/8/81"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<pagsiz.h>
end_include

begin_include
include|#
directive|include
file|"naout.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* various functions from the c math library */
end_comment

begin_decl_stmt
name|double
name|sin
argument_list|()
decl_stmt|,
name|cos
argument_list|()
decl_stmt|,
name|asin
argument_list|()
decl_stmt|,
name|acos
argument_list|()
decl_stmt|,
name|atan2
argument_list|()
decl_stmt|,
name|sqrt
argument_list|()
decl_stmt|,
name|log
argument_list|()
decl_stmt|,
name|exp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current
decl_stmt|;
end_decl_stmt

begin_function_decl
name|lispval
name|Imath
function_decl|(
name|func
function_decl|)
name|double
argument_list|(
argument|*func
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|double
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"Math functions"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
operator|=
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|res
operator|=
name|func
argument_list|(
operator|(
name|double
operator|)
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|res
operator|=
name|func
argument_list|(
name|handy
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum to math function"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|handy
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|handy
operator|->
name|r
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Lsin
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|sin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcos
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|cos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lasin
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|asin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lacos
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|acos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsqrt
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|sqrt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lexp
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|exp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llog
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|log
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* although we call this atan, it is really atan2 to the c-world,    that is, it takes two args  */
end_comment

begin_function
name|lispval
name|Latan
parameter_list|()
block|{
specifier|register
name|lispval
name|arg
decl_stmt|;
specifier|register
name|double
name|arg1v
decl_stmt|;
specifier|register
name|double
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"arctan"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|arg
operator|=
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|arg1v
operator|=
operator|(
name|double
operator|)
name|arg
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|arg1v
operator|=
name|arg
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum arg to atan2"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TYPE
argument_list|(
name|arg
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|res
operator|=
name|atan2
argument_list|(
name|arg1v
argument_list|,
operator|(
name|double
operator|)
name|arg
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|res
operator|=
name|atan2
argument_list|(
name|arg1v
argument_list|,
name|arg
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum to atan2"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|arg
operator|->
name|r
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (random) returns a fixnum in the range -2**30 to 2**30 -1    (random fixnum) returns a fixnum in the range 0 to fixnum-1  */
end_comment

begin_function
name|lispval
name|Lrandom
parameter_list|()
block|{
specifier|register
name|int
name|curval
decl_stmt|;
name|float
name|pow
parameter_list|()
function_decl|;
name|curval
operator|=
name|rand
argument_list|()
expr_stmt|;
comment|/* get numb from 0 to 2**31-1 */
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|curval
operator|-
operator|(
name|int
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|30
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<=
literal|0
operator|)
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"random: non fixnum arg:"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|curval
operator|%
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmakunb
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"makunbound"
argument_list|)
expr_stmt|;
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|nil
operator|||
operator|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|!=
name|ATOM
operator|)
condition|)
return|return
operator|(
name|work
operator|)
return|;
name|work
operator|->
name|a
operator|.
name|clb
operator|=
name|CNIL
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lpolyev
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|double
modifier|*
name|handy
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|int
name|type
decl_stmt|;
name|count
operator|=
literal|2
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|-
operator|(
name|int
operator|)
name|lbot
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|8
condition|)
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
name|base
operator|=
name|handy
operator|=
operator|(
name|double
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|type
operator|=
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|DOUB
operator|&&
name|type
operator|!=
name|INT
condition|)
name|argp
operator|->
name|val
operator|=
operator|(
name|lispval
operator|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"%%machine-polyev:non-real arg"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|73
argument_list|,
name|lbot
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
block|}
else|else
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|r
expr_stmt|;
block|}
name|count
operator|=
name|count
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|2
expr_stmt|;
asm|asm("polyd	(r9),r11,8(r9)");
asm|asm("movd	r0,(r9)");
name|result
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|result
operator|->
name|r
operator|=
operator|*
name|base
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|doub
block|{
name|unsigned
name|short
name|f1
range|:
literal|7
decl_stmt|,
name|expt
range|:
literal|8
decl_stmt|,
name|sign
range|:
literal|1
decl_stmt|;
name|unsigned
name|short
name|f2
decl_stmt|,
name|f3p1
range|:
literal|14
decl_stmt|,
name|f3p2
range|:
literal|2
decl_stmt|,
name|f4
decl_stmt|;
block|}
typedef|*
name|dp
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|quad2
block|{
name|unsigned
name|long
name|g4
range|:
literal|16
decl_stmt|,
name|g3p1
range|:
literal|14
decl_stmt|;
block|}
typedef|*
name|qp2
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|quad1
block|{
name|unsigned
name|long
name|g3p2
range|:
literal|2
decl_stmt|,
name|g2
range|:
literal|16
decl_stmt|,
name|g1
range|:
literal|7
decl_stmt|,
name|hide
range|:
literal|1
decl_stmt|;
block|}
typedef|*
name|qp1
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|long
name|workbuf
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exponent
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|Idebig
argument_list|()
block|{
specifier|register
name|lispval
name|work
block|;
specifier|register
name|dp
name|rdp
block|;
specifier|register
name|qp1
name|rqp1
block|;
specifier|register
name|qp2
name|rqp2
block|;
specifier|register
expr|struct
name|argent
operator|*
name|lbot
block|,
name|np
block|;
name|workbuf
index|[
literal|1
index|]
operator|=
name|workbuf
index|[
literal|0
index|]
operator|=
literal|0
block|;
name|work
operator|=
name|lbot
operator|->
name|val
block|;
comment|/* Unfold mantissa */
name|rqp2
operator|=
operator|(
name|qp2
operator|)
name|workbuf
operator|+
literal|1
block|;
name|rqp1
operator|=
operator|(
name|qp1
operator|)
name|workbuf
block|;
name|rdp
operator|=
operator|(
name|dp
operator|)
name|work
block|;
name|rqp2
operator|->
name|g4
operator|=
name|rdp
operator|->
name|f4
block|;
name|rqp2
operator|->
name|g3p1
operator|=
name|rdp
operator|->
name|f3p1
block|;
name|rqp1
operator|->
name|g3p2
operator|=
name|rdp
operator|->
name|f3p2
block|;
name|rqp1
operator|->
name|g2
operator|=
name|rdp
operator|->
name|f2
block|;
name|rqp1
operator|->
name|g1
operator|=
name|rdp
operator|->
name|f1
block|;
name|rqp1
operator|->
name|hide
operator|=
literal|1
block|;
if|if
condition|(
name|rdp
operator|->
name|sign
condition|)
block|{
name|workbuf
index|[
literal|0
index|]
operator|=
operator|(
operator|-
name|workbuf
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|workbuf
index|[
literal|1
index|]
operator|=
operator|(
operator|-
name|workbuf
index|[
literal|1
index|]
operator|)
operator|&
literal|0xC0000000
condition|)
name|workbuf
index|[
literal|0
index|]
operator|--
expr_stmt|;
block|}
comment|/* calcuate exponent and adjustment */
name|exponent
operator|=
operator|-
literal|129
operator|-
literal|55
operator|+
operator|(
name|int
operator|)
name|rdp
operator|->
name|expt
expr_stmt|;
end_expr_stmt

begin_macro
unit|} lispval
name|Lfdecom
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|dum1
operator|,
name|dum2
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"Decompose-float"
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DOUB
condition|)
name|lbot
operator|->
name|val
operator|=
name|error
argument_list|(
literal|"Decompose-float: Non-real argument"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Idebig
argument_list|()
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|result
operator|=
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|exponent
argument_list|)
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|s
operator|.
name|I
operator|=
name|workbuf
index|[
literal|1
index|]
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|s
operator|.
name|CDR
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|s
operator|.
name|I
operator|=
name|workbuf
index|[
literal|0
index|]
expr_stmt|;
block|}
end_block

begin_function
name|lispval
name|Lfseek
parameter_list|()
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|dum1
operator|,
name|dum2
expr_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|disk_addr
decl_stmt|,
name|offset
decl_stmt|,
name|whence
decl_stmt|;
name|lispval
name|retp
decl_stmt|;
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"fseek"
argument_list|)
expr_stmt|;
comment|/* Make sure there are three arguments*/
name|f
operator|=
name|lbot
operator|->
name|val
operator|->
name|p
expr_stmt|;
comment|/* Get first argument into f */
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|PORT
condition|)
comment|/* Check type of first */
name|error
argument_list|(
literal|"fseek: First argument must be a port."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
comment|/* Get second argument */
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"fseek: Second argument must be an integer."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|whence
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
comment|/* Get last arg	*/
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"fseek: Third argument must be an integer."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|offset
argument_list|,
name|whence
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"fseek: Illegal parameters."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retp
operator|=
name|inewint
argument_list|(
name|ftell
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|retp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* function hashtabstat  : return list of number of members in  each bucket */
end_comment

begin_function
name|lispval
name|Lhashst
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|cur
decl_stmt|;
specifier|register
name|struct
name|atom
modifier|*
name|pnt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
specifier|extern
name|int
name|hashtop
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|cur
operator|=
name|handy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hashtop
condition|;
name|i
operator|++
control|)
block|{
name|pnt
operator|=
name|hasht
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|pnt
operator|!=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
condition|;
name|pnt
operator|=
name|pnt
operator|->
name|hshlnk
operator|,
name|cnt
operator|++
control|)
empty_stmt|;
name|cur
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|cur
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
name|cur
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lctcherr   this routine should only be called by the unwind protect simulation   lisp code   It is called after an unwind-protect frame has been entered and   evalated and we want to get on with the error or throw   We only handle the case where there are 0 to 2 extra arguments to the   error call. */
end_comment

begin_function
name|lispval
name|Lctcherr
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
name|type
decl_stmt|,
name|messg
decl_stmt|,
name|valret
decl_stmt|,
name|contuab
decl_stmt|,
name|uniqid
decl_stmt|,
name|datum1
decl_stmt|,
name|datum2
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"I-throw-err"
argument_list|)
expr_stmt|;
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|==
name|tatom
condition|)
block|{
comment|/* continuing a throw */
name|Inonlocalgo
argument_list|(
name|C_THROW
argument_list|,
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|,
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
comment|/* decode the arg list */
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|type
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|messg
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|valret
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|contuab
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|uniqid
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* if not extra args */
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
block|{
name|errorh
argument_list|(
name|type
argument_list|,
name|messg
operator|->
name|a
operator|.
name|pname
argument_list|,
name|valret
argument_list|,
name|contuab
operator|->
name|i
argument_list|,
name|uniqid
operator|->
name|i
argument_list|)
expr_stmt|;
block|}
name|datum1
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* if one extra arg */
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
block|{
name|errorh
argument_list|(
name|type
argument_list|,
name|messg
operator|->
name|a
operator|.
name|pname
argument_list|,
name|valret
argument_list|,
name|contuab
operator|->
name|i
argument_list|,
name|uniqid
operator|->
name|i
argument_list|,
name|datum1
argument_list|)
expr_stmt|;
block|}
comment|/* if two or more extra args, just use first 2 */
name|datum2
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|errorh
argument_list|(
name|type
argument_list|,
name|messg
operator|->
name|a
operator|.
name|pname
argument_list|,
name|valret
argument_list|,
name|contuab
operator|->
name|i
argument_list|,
name|uniqid
operator|->
name|i
argument_list|,
name|datum1
argument_list|,
name|datum2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	(*makhunk '<fixnum>)  *<fixnum>  * Create a hunk of size 2       .<fixnum> must be between 0 and 6.  *  */
end_comment

begin_function
name|lispval
name|LMakhunk
parameter_list|()
block|{
specifier|register
name|int
name|hsize
decl_stmt|,
name|hcntr
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"Makehunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
name|hsize
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
expr_stmt|;
comment|/* size of hunk (0-6) */
if|if
condition|(
operator|(
name|hsize
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|hsize
operator|<=
literal|6
operator|)
condition|)
block|{
name|result
operator|=
name|newhunk
argument_list|(
name|hsize
argument_list|)
expr_stmt|;
name|hsize
operator|=
literal|2
operator|<<
name|hsize
expr_stmt|;
comment|/* size of hunk (2-128) */
for|for
control|(
name|hcntr
operator|=
literal|0
init|;
name|hcntr
operator|<
name|hsize
condition|;
name|hcntr
operator|++
control|)
name|result
operator|->
name|h
operator|.
name|hunk
index|[
name|hcntr
index|]
operator|=
name|hunkfree
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"*makhunk: Illegal hunk size"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"*makhunk: First arg must be an fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	(cxr '<fixnum> '<hunk>)  * Returns the<fixnum>'th element of<hunk>  *  */
end_comment

begin_function
name|lispval
name|Lcxr
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"cxr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"cxr: First arg must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|HUNKP
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"cxr: Second arg must be a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<
operator|(
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|)
operator|)
condition|)
block|{
name|temp
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|lbot
operator|->
name|val
operator|->
name|i
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|hunkfree
condition|)
return|return
operator|(
name|temp
operator|)
return|;
else|else
name|error
argument_list|(
literal|"cxr: Arg outside of hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"cxr: Arg outside of hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	(rplacx '<fixnum> '<hunk> '<expr>)  * Replaces the<fixnum>'th element of<hunk> with<expr>.  *  */
end_comment

begin_function
name|lispval
name|Lrplacx
parameter_list|()
block|{
name|lispval
modifier|*
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"rplacx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"rplacx: First arg must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|HUNKP
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"rplacx: Second arg must be a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<
operator|(
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|handy
operator|=
operator|&
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|lbot
operator|->
name|val
operator|->
name|i
index|]
operator|)
operator|)
operator|!=
name|hunkfree
condition|)
operator|*
name|handy
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
else|else
name|error
argument_list|(
literal|"rplacx: Arg outside hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"rplacx: Arg outside hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(*rplacx '<fixnum> '<hunk> '<expr>)  * Replaces the<fixnum>'th element of<hunk> with<expr>. This is the  * same as (rplacx ...) except with this function you can replace EMPTY's.  *  */
end_comment

begin_function
name|lispval
name|Lstarrpx
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"*rplacx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"*rplacx: First arg must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|HUNKP
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"*rplacx: Second arg must be a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<
operator|(
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|)
operator|)
condition|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|lbot
operator|->
name|val
operator|->
name|i
index|]
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
else|else
name|error
argument_list|(
literal|"*rplacx: Arg outside hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(hunksize '<hunk>)  * Returns the size of<hunk>  *  */
end_comment

begin_function
name|lispval
name|Lhunksize
parameter_list|()
block|{
specifier|register
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"hunksize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUNKP
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
name|size
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|lbot
operator|->
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|!=
name|hunkfree
condition|)
block|{
name|size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|inewint
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"hunksize: First argument must me a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	(fileopen  filename mode)  * open a file for read, write, or append the arguments can be either  * strings or atoms.  */
end_comment

begin_function
name|lispval
name|Lfileopen
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|name
decl_stmt|;
specifier|register
name|lispval
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|namech
decl_stmt|;
specifier|register
name|char
modifier|*
name|modech
decl_stmt|;
name|int
name|typ
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"fileopen"
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|mode
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|namech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|name
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
name|modech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|mode
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
while|while
condition|(
name|modech
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
name|modech
index|[
literal|0
index|]
operator|!=
literal|'w'
operator|&&
name|modech
index|[
literal|0
index|]
operator|!=
literal|'a'
condition|)
block|{
name|mode
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Modes are only r, w, a."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|modech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|mode
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|port
operator|=
name|fopen
argument_list|(
name|namech
argument_list|,
name|modech
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|namech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|name
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
block|}
comment|/* xports is a FILE *, cc complains about adding pointers */
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|xports
operator|+
operator|(
name|port
operator|-
name|_iob
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(*mod '<number> '<modulus>)  * This function returns<number> mod<modulus> (for balanced modulus).  * It is used in vaxima as a speed enhancement.  */
end_comment

begin_function
name|lispval
name|LstarMod
parameter_list|()
block|{
specifier|register
name|int
name|mod_div_2
decl_stmt|,
name|number
decl_stmt|,
name|modulus
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"*mod"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|INT
operator|)
operator|&&
operator|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|==
name|INT
operator|)
condition|)
block|{
name|modulus
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|number
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
operator|%
name|modulus
expr_stmt|;
name|mod_div_2
operator|=
name|modulus
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|number
operator|<
operator|(
operator|-
name|mod_div_2
operator|)
condition|)
name|number
operator|+=
name|modulus
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|number
operator|>
name|mod_div_2
condition|)
name|number
operator|-=
name|modulus
expr_stmt|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|number
argument_list|)
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"*mod: Arguments must be fixnums"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Llsh
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|int
name|val
decl_stmt|,
name|shift
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"lsh"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non ints to lsh"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|mylbot
operator|->
name|val
argument_list|,
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|mylbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|shift
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|shift
operator|<
operator|-
literal|32
operator|||
name|shift
operator|>
literal|32
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
name|val
operator|=
name|val
operator|<<
name|shift
expr_stmt|;
comment|/* do the shift */
if|if
condition|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|&&
operator|(
name|shift
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* special case: the vax doesn't have a logical shift 		   instruction, so we must zero out the ones which 		   will propogate from the sign position 		*/
return|return
operator|(
name|inewint
argument_list|(
name|val
operator|&
operator|~
operator|(
literal|0x80000000
operator|<<
operator|(
name|shift
operator|+
literal|1
operator|)
operator|)
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrot
parameter_list|()
block|{
specifier|register
name|rot
operator|,
name|val
expr_stmt|;
comment|/* these must be the first registers */
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"rot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non ints to rot"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|mylbot
operator|->
name|val
argument_list|,
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|mylbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|rot
operator|%
literal|32
expr_stmt|;
comment|/* bring it down below one byte in size */
asm|asm(" rotl r11,r10,r10 ");
comment|/* rotate val by rot and put back in val */
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------- vms routines to simulate dumplisp -------------------- */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|firstalloc
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lsbrkpnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|zfreespace
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|stabf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of symbol table */
end_comment

begin_decl_stmt
specifier|static
name|char
name|newstabf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer to hold new name */
end_comment

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a-1)|(b-1))+1)
end_define

begin_function
name|lispval
name|Lsavelsp
parameter_list|()
block|{
name|char
modifier|*
name|filnm
decl_stmt|;
name|int
name|fp
decl_stmt|,
name|fp1
decl_stmt|,
name|i
decl_stmt|,
name|num
decl_stmt|,
name|start
decl_stmt|;
name|char
name|stabname
index|[
literal|100
index|]
decl_stmt|,
name|buf
index|[
literal|5000
index|]
decl_stmt|;
name|char
modifier|*
name|gstab
parameter_list|()
function_decl|;
name|int
name|strcmpn
parameter_list|()
function_decl|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"savelisp"
argument_list|)
expr_stmt|;
name|filnm
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"savelisp: non atom arg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|creat
argument_list|(
name|filnm
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"savelisp: can't open file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|start
operator|=
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|firstalloc
argument_list|,
name|PAGSIZ
argument_list|)
expr_stmt|;
name|num
operator|=
name|roundup
argument_list|(
operator|(
operator|(
name|int
operator|)
name|lsbrkpnt
operator|)
operator|-
name|start
argument_list|,
name|PAGSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|write
argument_list|(
name|fp
argument_list|,
name|start
argument_list|,
name|num
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"savelisp: write failed "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %x bytes written from %x to %x \n"
argument_list|,
name|num
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.stb"
argument_list|,
name|gstab
argument_list|()
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|stabname
argument_list|,
literal|"%s.stb"
argument_list|,
name|filnm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmpn
argument_list|(
name|gstab
argument_list|()
argument_list|,
literal|"tmp:"
argument_list|,
literal|4
argument_list|)
condition|)
if|if
condition|(
name|link
argument_list|(
name|buf
argument_list|,
name|stabname
argument_list|)
operator|>=
literal|0
condition|)
if|if
condition|(
name|unlink
argument_list|(
name|buf
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|newstabf
argument_list|,
name|filnm
argument_list|)
expr_stmt|;
name|stabf
operator|=
name|newstabf
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
name|fp1
operator|=
name|creat
argument_list|(
name|stabname
argument_list|,
literal|0666
argument_list|,
literal|"var"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fp
argument_list|,
name|buf
argument_list|,
literal|5000
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fp1
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmpn
argument_list|(
name|gstab
argument_list|()
argument_list|,
literal|"tmp:"
argument_list|,
literal|4
argument_list|)
condition|)
name|unlink
argument_list|(
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.stb"
argument_list|,
name|gstab
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newstabf
argument_list|,
name|filnm
argument_list|)
expr_stmt|;
name|stabf
operator|=
name|newstabf
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrestlsp
parameter_list|()
block|{
name|char
modifier|*
name|filnm
decl_stmt|;
name|int
name|fp
decl_stmt|,
name|i
decl_stmt|,
name|num
decl_stmt|,
name|start
decl_stmt|;
specifier|extern
name|int
name|xcycle
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"restorelisp"
argument_list|)
expr_stmt|;
name|filnm
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"restorelisp: non atom arg"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|filnm
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"restorelisp: can't open file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newstabf
argument_list|,
name|filnm
argument_list|)
expr_stmt|;
comment|/* Mark the new symbol table */
name|start
operator|=
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|firstalloc
argument_list|,
name|PAGSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|num
operator|=
name|vread
argument_list|(
name|fp
argument_list|,
name|start
argument_list|,
operator|(
operator|(
name|int
operator|)
operator|&
name|end
operator|)
operator|-
name|start
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"restorelisp: read failed "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %x bytes read into %x to %x\n"
argument_list|,
name|num
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
name|xcycle
operator|=
literal|0
expr_stmt|;
comment|/* indicate no saved pages to xsbrk */
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|stabf
operator|=
name|newstabf
expr_stmt|;
comment|/* Make this our new symbol table */
name|bnp
operator|=
name|orgbnp
expr_stmt|;
name|lbot
operator|=
name|np
operator|=
name|orgnp
expr_stmt|;
name|Inonlocalgo
argument_list|(
name|C_RESET
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------- */
end_comment

begin_comment
comment|/* getaddress --  *  * (getaddress '|_entry1| 'fncname1 '|_entry2| 'fncname2 ...)  *  * binds value of symbol |_entry1| to function defition of atom fncname1, etc.  *  * returns fnc-binding of fncname1.  *  */
end_comment

begin_function
name|lispval
name|Lgetaddress
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mlbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|int
name|numberofargs
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|gstab
parameter_list|()
function_decl|;
name|char
name|ostabf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|nlist
name|NTABLE
index|[
literal|100
index|]
decl_stmt|;
name|lispval
name|dispget
parameter_list|()
function_decl|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|-
name|lbot
operator|==
literal|2
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* allow 2 args */
name|numberofargs
operator|=
operator|(
name|np
operator|-
name|lbot
operator|)
operator|/
literal|3
expr_stmt|;
if|if
condition|(
name|numberofargs
operator|*
literal|3
operator|!=
name|np
operator|-
name|lbot
condition|)
name|error
argument_list|(
literal|"getaddress: arguments must come in triples "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numberofargs
condition|;
name|i
operator|++
operator|,
name|mlbot
operator|+=
literal|3
control|)
block|{
name|NTABLE
index|[
name|i
index|]
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
operator|=
name|verify
argument_list|(
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"Incorrect entry specification for binding"
argument_list|)
expr_stmt|;
name|NTABLE
index|[
name|i
index|]
operator|.
name|n_un
operator|.
name|n_name
operator|=
operator|(
name|char
operator|*
operator|)
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad associated atom name for binding"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|dispget
argument_list|(
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|,
literal|"getaddress: Incorrect discipline specification "
argument_list|,
name|Vsubrou
operator|->
name|a
operator|.
name|pname
argument_list|)
expr_stmt|;
block|}
name|NTABLE
index|[
operator|(
name|numberofargs
operator|)
index|]
operator|.
name|n_un
operator|.
name|n_name
operator|=
literal|""
expr_stmt|;
name|strcpyn
argument_list|(
name|ostabf
argument_list|,
name|gstab
argument_list|()
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlist
argument_list|(
name|ostabf
argument_list|,
name|NTABLE
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Getaddress: Bad file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|inewstr
argument_list|(
name|ostabf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mlbot
operator|=
name|lbot
operator|+
literal|1
init|;
name|i
operator|<
name|numberofargs
condition|;
name|i
operator|++
operator|,
name|mlbot
operator|+=
literal|3
control|)
block|{
if|if
condition|(
name|NTABLE
index|[
name|i
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Undefined symbol: %s\n"
argument_list|,
name|NTABLE
index|[
name|i
index|]
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
else|else
block|{
name|work
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|work
operator|->
name|bcd
operator|.
name|entry
operator|=
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NTABLE
index|[
name|i
index|]
operator|.
name|n_value
expr_stmt|;
name|work
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|mlbot
operator|->
name|val
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|work
expr_stmt|;
block|}
block|}
empty_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|a
operator|.
name|fnbnd
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* very temporary function to test the validity of the bind stack */
end_comment

begin_macro
name|bndchk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nament
modifier|*
name|npt
decl_stmt|;
specifier|register
name|lispval
name|in2
decl_stmt|;
name|in2
operator|=
name|inewint
argument_list|(
literal|200
argument_list|)
expr_stmt|;
for|for
control|(
name|npt
operator|=
name|orgbnp
init|;
name|npt
operator|<
name|bnp
condition|;
name|npt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|npt
operator|->
name|atm
operator|<
operator|(
name|int
operator|)
name|in2
condition|)
asm|asm(" halt ");
block|}
block|}
end_block

begin_comment
comment|/*  *	formatted printer for lisp data  *    use: (cprintf formatstring datum [port])  */
end_comment

begin_function
name|lispval
name|Lcprintf
parameter_list|()
block|{
name|FILE
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|fstrng
decl_stmt|;
name|lispval
name|v
decl_stmt|;
if|if
condition|(
name|np
operator|-
name|lbot
operator|==
literal|2
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* write to standard output port */
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"cprintf"
argument_list|)
expr_stmt|;
name|fstrng
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"cprintf: first arg not string or symbol"
argument_list|)
expr_stmt|;
name|p
operator|=
name|okport
argument_list|(
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|poport
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|v
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
operator|->
name|a
operator|.
name|pname
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cprintf: Illegal second argument"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lprobef
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"probef"
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"probef: not symbol or string arg "
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsubstring
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|lispval
name|index
decl_stmt|,
name|length
decl_stmt|;
name|int
name|restofstring
init|=
name|FALSE
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ind
decl_stmt|,
name|reallen
decl_stmt|;
specifier|extern
name|char
name|strbuf
index|[]
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|restofstring
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
break|break;
default|default:
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"substring"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"substring: not symbol or string arg "
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|index
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"substring: non integer index "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ind
operator|=
name|index
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
name|ind
operator|=
name|len
operator|+
literal|1
operator|+
name|ind
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
operator|||
name|ind
operator|>
name|len
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/*index out of bounds*/
if|if
condition|(
name|restofstring
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|name
operator|+
name|ind
operator|-
literal|1
argument_list|)
operator|)
return|;
while|while
condition|(
name|TYPE
argument_list|(
name|length
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"substring: not integer length "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reallen
operator|=
name|length
operator|->
name|i
operator|)
operator|<
literal|0
operator|||
operator|(
name|reallen
operator|+
name|ind
operator|)
operator|>
name|len
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|name
operator|+
name|ind
operator|-
literal|1
argument_list|)
operator|)
return|;
name|strncpy
argument_list|(
name|strbuf
argument_list|,
name|name
operator|+
name|ind
operator|-
literal|1
argument_list|,
name|reallen
argument_list|)
expr_stmt|;
name|strbuf
index|[
name|reallen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|newstr
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsubstringn
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|ind
decl_stmt|,
name|reallen
decl_stmt|;
name|lispval
name|index
decl_stmt|,
name|length
decl_stmt|;
name|int
name|restofstring
init|=
name|FALSE
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|-
name|lbot
operator|)
operator|==
literal|2
condition|)
name|restofstring
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"substringn"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"substringn: non symbol or string arg "
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|index
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"substringn: non integer index "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|restofstring
condition|)
block|{
while|while
condition|(
name|TYPE
argument_list|(
name|length
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"substringn: not integer length "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|reallen
operator|=
name|length
operator|->
name|i
expr_stmt|;
block|}
else|else
name|reallen
operator|=
operator|-
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ind
operator|=
name|index
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
name|ind
operator|=
name|len
operator|+
literal|1
operator|+
name|ind
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
operator|||
name|ind
operator|>
name|len
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
name|reallen
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewint
argument_list|(
operator|*
operator|(
name|name
operator|+
name|ind
operator|-
literal|1
operator|)
argument_list|)
operator|)
return|;
else|else
block|{
name|char
modifier|*
name|pnt
init|=
name|name
operator|+
name|ind
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|last
init|=
name|name
operator|+
name|len
operator|-
literal|1
decl_stmt|;
name|lispval
name|cur
decl_stmt|,
name|start
decl_stmt|;
name|protect
argument_list|(
name|cur
operator|=
name|start
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|cur
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
operator|*
name|pnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|pnt
operator|<=
name|last
operator|&&
operator|--
name|reallen
operator|!=
literal|0
condition|)
block|{
name|cur
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|cur
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
operator|*
name|pnt
argument_list|)
expr_stmt|;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|start
operator|)
return|;
block|}
block|}
end_function

begin_function_decl
name|lispval
name|Ipurcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|lispval
name|Lpurcopy
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"purcopy"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Ipurcopy
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ipurcopy
parameter_list|(
name|handy
parameter_list|)
name|lispval
name|handy
decl_stmt|;
block|{
specifier|extern
name|int
modifier|*
name|beginsweep
decl_stmt|;
specifier|register
name|lispval
name|retv
decl_stmt|,
name|curv
decl_stmt|,
name|lv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|DTPR
case|:
name|retv
operator|=
name|curv
operator|=
name|pnewdot
argument_list|()
expr_stmt|;
name|lv
operator|=
name|handy
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|curv
operator|->
name|d
operator|.
name|car
operator|=
name|Ipurcopy
argument_list|(
name|lv
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lv
operator|=
name|lv
operator|->
name|d
operator|.
name|cdr
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|curv
operator|->
name|d
operator|.
name|cdr
operator|=
name|pnewdot
argument_list|()
expr_stmt|;
name|curv
operator|=
name|curv
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
else|else
block|{
name|curv
operator|->
name|d
operator|.
name|cdr
operator|=
name|Ipurcopy
argument_list|(
name|lv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|SDOT
case|:
name|retv
operator|=
name|curv
operator|=
name|pnewsdot
argument_list|()
expr_stmt|;
name|lv
operator|=
name|handy
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|curv
operator|->
name|s
operator|.
name|I
operator|=
name|lv
operator|->
name|s
operator|.
name|I
expr_stmt|;
if|if
condition|(
name|lv
operator|->
name|s
operator|.
name|CDR
operator|==
name|nil
condition|)
break|break;
name|lv
operator|=
name|lv
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
name|curv
operator|->
name|s
operator|.
name|CDR
operator|=
name|pnewdot
argument_list|()
expr_stmt|;
name|curv
operator|=
name|curv
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
block|}
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|INT
case|:
if|if
condition|(
operator|(
name|int
operator|*
operator|)
name|handy
operator|<
name|beginsweep
condition|)
return|return
operator|(
name|handy
operator|)
return|;
name|retv
operator|=
name|pnewint
argument_list|()
expr_stmt|;
name|retv
operator|->
name|i
operator|=
name|handy
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|DOUB
case|:
name|retv
operator|=
name|pnewdoub
argument_list|()
expr_stmt|;
name|retv
operator|->
name|r
operator|=
name|handy
operator|->
name|r
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|HUNK2
case|:
name|i
operator|=
literal|0
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK4
case|:
name|i
operator|=
literal|1
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK8
case|:
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK16
case|:
name|i
operator|=
literal|3
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK32
case|:
name|i
operator|=
literal|4
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK64
case|:
name|i
operator|=
literal|5
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK128
case|:
name|i
operator|=
literal|6
expr_stmt|;
name|hunkit
label|:
name|retv
operator|=
name|pnewhunk
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
operator|<<
name|i
expr_stmt|;
comment|/* number of elements to copy over */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|retv
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|=
name|Ipurcopy
argument_list|(
name|handy
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|ATOM
case|:
case|case
name|STRNG
case|:
case|case
name|BCD
case|:
case|case
name|PORT
case|:
return|return
operator|(
name|handy
operator|)
return|;
comment|/* We don't want to purcopy these, yet 				 * it won't hurt if we don't mark them 				 * since they either aren't swept or  				 * will be marked in a special way  				 */
case|case
name|ARRAY
case|:
name|error
argument_list|(
literal|"purcopy: can't purcopy array structures"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|" bad type to purcopy "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lpurep returns t if the given arg is in pure space  */
end_comment

begin_function
name|lispval
name|Lpurep
parameter_list|()
block|{
name|lispval
name|Ipurep
parameter_list|()
function_decl|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"purep"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Ipurep
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

