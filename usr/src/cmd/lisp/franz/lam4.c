begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)lam4.c	35.2 7/8/81"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_typedef
typedef|typedef
name|struct
name|argent
modifier|*
name|ap
typedef|;
end_typedef

begin_decl_stmt
name|lispval
name|adbig
argument_list|()
decl_stmt|,
name|subbig
argument_list|()
decl_stmt|,
name|mulbig
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|double
name|Ifloat
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|lispval
name|Ladd
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|restype
decl_stmt|,
name|prunep
decl_stmt|,
name|hi
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
comment|/* now start as integers */
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
literal|1
argument_list|,
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
comment|/* In adding the fixnum to the sdot we may make it 		    possible for the bignum to be represented as a fixnum */
break|break;
case|case
name|INT
case|:
if|if
condition|(
name|exarith
argument_list|(
name|lo
argument_list|,
literal|1
argument_list|,
name|work
operator|->
name|i
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|hi
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
operator|&
name|dummybig
argument_list|)
expr_stmt|;
goto|goto
name|code1
goto|;
case|case
name|SDOT
case|:
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* previous result is no longer needed */
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|code1
label|:
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* SDOT or INT */
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
name|lispval
name|handy
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|handy
operator|=
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|handy
expr_stmt|;
block|}
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|+
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|flacc
operator|=
name|work
operator|->
name|r
operator|+
name|lo
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to add"
argument_list|,
name|nil
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
return|return
operator|(
name|work
operator|)
return|;
case|case
name|INT
case|:
return|return
operator|(
name|inewint
argument_list|(
name|lo
argument_list|)
operator|)
return|;
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
operator|==
name|FALSE
condition|)
return|return
operator|(
name|work
operator|)
return|;
else|else
block|{
comment|/* wouldn't (copy result->val) be faster ? -dhl */
comment|/* It might, but isn't guaranteed to canonicalize */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
operator|)
return|;
block|}
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in add "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* exarith 	exact arithmetic  * calculates x=a*b+c  where a,b and c are 32 bit 2's complement integers  * whose top two bits must be the same (i.e. the are members of the set  * of valid fixnum values for Franz Lisp).  The result, x, will be 64 bits  * long but since each of a, b and c had only 31 bits of precision, the  * result x only has 62 bits of precision.  The lower 30 bits are returned  * in *plo and the high 32 bits are returned in *phi.  If *phi is 0 or -1 then  * x doesn't need any more than 31 bits plus sign to describe, so we  * place the sign in the high two bits of *plo and return 0 from this  * routine.  A non zero return indicates that x requires more than 31 bits  * to describe.  */
end_comment

begin_macro
name|exarith
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|phi
argument_list|,
argument|plo
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|phi
decl_stmt|,
modifier|*
name|plo
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("	emul	4(ap),8(ap),12(ap),r2	#r2 = a*b + c to 64 bits");
asm|asm("	extzv	$0,$30,r2,*20(ap)	#get new lo");
asm|asm("	extv	$30,$32,r2,r0		#get new carry");
asm|asm("	beql	out			# hi = 0, no work necessary");
asm|asm("	movl	r0,*16(ap)		# save hi");
asm|asm("	mcoml	r0,r0			# Is hi = -1 (it'll fit in one word)");
asm|asm("	bneq	out			# it doesn't");
asm|asm("	bisl2	$0xc0000000,*20(ap)	# alter low so that it is ok.");
asm|asm("out:	ret");
block|}
end_block

begin_function
name|lispval
name|Lsub
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|prunep
decl_stmt|,
name|restype
decl_stmt|,
name|hi
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|lispval
name|Lminus
parameter_list|()
function_decl|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|mynp
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|oldnp
operator|==
name|lbot
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|oldnp
operator|==
name|mynp
condition|)
block|{
return|return
operator|(
name|Lminus
argument_list|()
operator|)
return|;
block|}
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* examine the first argument and perhaps set restype to the  	 * correct type.  If restype (result type) is INT, then the 	 * fixnum value is stored in lo.  Otherwise, if restype is  	 * SDOT or DOUB, then the value is stored in result->val. 	 */
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
comment|/* we want to copy the sdot we are given as an argument since 		 * the bignum arithmetic routine dmlad clobbers the values it 		 * is given. 		 */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
comment|/* create a zero sdot */
name|dummybig
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
operator|&
name|dummybig
argument_list|)
expr_stmt|;
comment|/* the resulting value may have been reduced from an 		 * sdot to a fixnum.  This should never happen though 		 * but if it does, we simplify things. 		 */
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
comment|/* has turned into an fixnum */
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* return fixnum cell	     */
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|work
operator|->
name|r
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
block|}
comment|/* now loop through the rest of the arguments subtracting them 	 * from the running result in result or lo 	 */
for|for
control|(
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* subtracting a fixnum from an bignum 				 * use the distructive multiply (by 1) 				 * and add the negative of the work value. 				 * The result will still be pointed to 				 * by result->val 				 */
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
literal|1
argument_list|,
operator|-
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
comment|/* check up on exiting 				break;		/* that it didn't collapse */
case|case
name|INT
case|:
comment|/* subtracting a fixnum from a fixnum, 				 * the result could turn into a bignum 				 */
if|if
condition|(
name|exarith
argument_list|(
name|lo
argument_list|,
literal|1
argument_list|,
operator|-
name|work
operator|->
name|i
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|hi
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
comment|/* subtracting a fixnum from a flonum */
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
comment|/* subtracting a bignum from an integer 			     * first make a bignum of the integer and 			     * then fall into the next case 			     */
name|dummybig
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|work
operator|=
name|subbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
case|case
name|SDOT
case|:
comment|/* subtracting one bignum from another.  The 			     * routine to do this ends up calling addbig 			     * and should probably be written specifically 			     * for subtraction. 			     */
name|work
operator|=
name|subbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|on1
label|:
comment|/* check if the result has turned into a fixnum */
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
comment|/* it has */
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
comment|/* Subtract bignum from float */
comment|/* Death on overflow 	 */
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* subtracting a flonum from a bignum. */
if|if
condition|(
name|prunep
condition|)
block|{
name|lispval
name|handy
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|handy
operator|=
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|handy
expr_stmt|;
block|}
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|-
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
comment|/* subtracting a flonum from an fixnum.  				 * The result will be an flonum. 				 */
name|flacc
operator|=
name|lo
operator|-
name|work
operator|->
name|r
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
comment|/* subtracting a flonum from a flonum, what 				 * could be easier? 				 */
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to minus"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
return|return
operator|(
name|work
operator|)
return|;
case|case
name|INT
case|:
return|return
operator|(
name|inewint
argument_list|(
name|lo
argument_list|)
operator|)
return|;
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
operator|==
name|FALSE
condition|)
return|return
operator|(
name|work
operator|)
return|;
else|else
block|{
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
operator|)
return|;
block|}
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in difference"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|lispval
name|Ltimes
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|itemp
decl_stmt|,
name|restype
decl_stmt|,
name|prunep
decl_stmt|,
name|hi
decl_stmt|,
name|lo
init|=
literal|1
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
comment|/* now start as integers */
name|prunep
operator|=
name|TRUE
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
operator|->
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
comment|/* In adding the fixnum to the sdot we may make it 		    possible for the bignum to be represented as a fixnum */
break|break;
case|case
name|INT
case|:
if|if
condition|(
name|exarith
argument_list|(
name|lo
argument_list|,
name|work
operator|->
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|hi
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|work
operator|=
name|mulbig
argument_list|(
name|work
argument_list|,
operator|&
name|dummybig
argument_list|)
expr_stmt|;
goto|goto
name|code1
goto|;
case|case
name|SDOT
case|:
name|work
operator|=
name|mulbig
argument_list|(
name|work
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* previous result is no longer needed */
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|code1
label|:
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* SDOT or INT */
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
name|lispval
name|handy
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|handy
operator|=
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|handy
expr_stmt|;
block|}
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|*
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|flacc
operator|=
name|work
operator|->
name|r
operator|*
name|lo
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to add"
argument_list|,
name|nil
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
return|return
operator|(
name|work
operator|)
return|;
case|case
name|INT
case|:
return|return
operator|(
name|inewint
argument_list|(
name|lo
argument_list|)
operator|)
return|;
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
operator|==
name|FALSE
condition|)
return|return
operator|(
name|work
operator|)
return|;
else|else
block|{
comment|/* wouldn't (copy result->val) be faster ? -dhl */
comment|/* It might, but isn't guaranteed to canonicalize */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|adbig
argument_list|(
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
operator|)
return|;
block|}
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in times"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|lispval
name|Lquo
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|ap
name|result
decl_stmt|,
name|mynp
decl_stmt|,
name|oldnp
decl_stmt|,
name|lbot
decl_stmt|,
name|np
decl_stmt|;
name|int
name|restype
decl_stmt|;
name|lispval
name|quotient
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|mynp
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|1
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|oldnp
operator|==
name|mynp
condition|)
name|mynp
operator|=
name|lbot
expr_stmt|;
else|else
block|{
comment|/* examine the first argument and perhaps set restype to the  	     * correct type.  If restype (result type) is INT, then the 	     * fixnum value is stored in lo.  Otherwise, if restype is  	     * SDOT or DOUB, then the value is stored in result->val. 	     */
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
comment|/* we want to copy the sdot we are given as an argument since 		 * the bignum divide routine divbig expects an argument in 		 * canonical form. 		 */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
comment|/* create a zero sdot */
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
operator|&
name|dummybig
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
comment|/* Either INT or SDOT */
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
comment|/* has turned into an fixnum */
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* return fixnum cell	     */
block|}
else|else
block|{
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|work
operator|->
name|r
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #1: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
block|}
comment|/* now loop through the rest of the arguments dividing them 	 * into the running result in result or dummybig.I 	 */
for|for
control|(
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
if|if
condition|(
name|work
operator|->
name|i
operator|==
literal|0
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* there is no fast routine to destructively 				   divide a bignum by an int, so do it the 				   hard way. */
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|divbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
operator|&
name|dummybig
argument_list|,
operator|&
name|quotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|on1
label|:
comment|/* check if the result has turned into a fixnum */
name|restype
operator|=
name|TYPE
argument_list|(
name|quotient
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
comment|/* Either INT or SDOT */
name|dummybig
operator|.
name|I
operator|=
name|quotient
operator|->
name|i
expr_stmt|;
comment|/* has turned into an fixnum */
name|prunei
argument_list|(
name|quotient
argument_list|)
expr_stmt|;
comment|/* return fixnum cell	     */
block|}
else|else
name|result
operator|->
name|val
operator|=
name|quotient
expr_stmt|;
break|break;
case|case
name|INT
case|:
comment|/* divide int by int */
name|dummybig
operator|.
name|I
operator|/=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|/=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #2: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
comment|/* Although it seems that dividing an int 		     * by a bignum can only lead to zero, it is 		     * concievable that the bignum is improperly boxed, 		     * i.e. actually an int. 		     */
name|divbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|,
operator|&
name|quotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
case|case
name|SDOT
case|:
comment|/* dividing one bignum by another. */
name|divbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
argument_list|,
operator|&
name|quotient
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
case|case
name|DOUB
case|:
comment|/* dividing a bignum into a flonum. 		     */
name|result
operator|->
name|val
operator|->
name|r
operator|/=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #3: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* Divide bignum by flonum converting to flonum 			    * May die due to overflow */
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|/
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
comment|/* dividing a flonum into a fixnum.  			   * The result will be a flonum. */
name|flacc
operator|=
operator|(
operator|(
name|double
operator|)
name|dummybig
operator|.
name|I
operator|)
operator|/
name|work
operator|->
name|r
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
comment|/* dividing a flonum into a flonum, what 			    * could be easier? 			    */
name|result
operator|->
name|val
operator|->
name|r
operator|/=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #4: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to quotient "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
case|case
name|DOUB
case|:
return|return
operator|(
name|work
operator|)
return|;
case|case
name|INT
case|:
return|return
operator|(
name|inewint
argument_list|(
name|dummybig
operator|.
name|I
argument_list|)
operator|)
return|;
default|default:
name|urk
label|:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #5: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|lispval
name|Lfp
parameter_list|()
block|{
specifier|register
name|temp
operator|=
literal|0
operator|,
name|x
operator|,
name|y
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
name|temp
operator|+=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfm
parameter_list|()
block|{
specifier|register
name|temp
operator|,
name|x
operator|,
name|y
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
name|temp
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|lbot
operator|+
literal|1
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
operator|-
name|temp
argument_list|)
operator|)
return|;
for|for
control|(
name|argp
operator|=
name|lbot
operator|+
literal|1
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
name|temp
operator|-=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lft
parameter_list|()
block|{
specifier|register
name|temp
operator|=
literal|1
operator|,
name|x
operator|,
name|y
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
name|temp
operator|*=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfd
parameter_list|()
block|{
specifier|register
name|temp
operator|=
literal|0
operator|,
name|x
operator|,
name|y
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|1
argument_list|)
operator|)
return|;
name|temp
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|lbot
operator|+
literal|1
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|1
operator|/
name|temp
argument_list|)
operator|)
return|;
for|for
control|(
name|argp
operator|=
name|lbot
operator|+
literal|1
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
name|temp
operator|/=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

