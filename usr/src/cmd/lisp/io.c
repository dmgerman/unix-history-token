begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)io.c	34.5 10/24/80"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_struct
struct|struct
name|readtable
block|{
name|char
name|ctable
index|[
literal|132
index|]
decl_stmt|;
block|}
name|initread
init|=
block|{
comment|/*	^@ nul	^A soh	^B stx	^C etx	^D eot	^E eng	^F ack	^G bel  */
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	^H bs	^I ht	^J nl	^K vt	^L np	^M cr	^N so	^O si	*/
name|VCHAR
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	^P dle	^Q dc1	^R dc2	^S dc3	^T dc4	^U nak	^V syn	^W etb	*/
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	^X can	^Y em	^Z sub	^[ esc	^\ fs	^] gs	^^ rs	^_ us	*/
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VSEP
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	sp	!	"	#	$	%&	'	*/
name|VSEP
block|,
name|VCHAR
block|,
name|VSD
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VSQ
block|,
comment|/*	(	)	*	+	,	-	.	/	*/
name|VLPARA
block|,
name|VRPARA
block|,
name|VCHAR
block|,
name|VSIGN
block|,
name|VCHAR
block|,
name|VSIGN
block|,
name|VPERD
block|,
name|VCHAR
block|,
comment|/*	0	1	2	3	4	5	6	7	*/
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
comment|/*	8	9	:	;<	=>	?	*/
name|VNUM
block|,
name|VNUM
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	@	A	B	C	D	E	F	G	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	H	I	J	K	L	M	N	O	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	P	Q	R	S	T	U	V	W	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	X	Y	Z	[	\	]	^	_	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VLBRCK
block|,
name|VESC
block|,
name|VRBRCK
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	`	a	b	c	d	e	f	g	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	h	i	j	k	l	m	n	o	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	p	q	r	s	t	u	v	w	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	x	y	z	{	|	}	~	del	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VDQ
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VEOF
block|,
comment|/*	unused	Xsdc	Xesc	Xdqc					*/
literal|0
block|,
literal|'"'
block|,
literal|'\\'
block|,
literal|'|'
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|ctable
init|=
name|initread
operator|.
name|ctable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|atomval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external varaible containing atom returned 			   from internal atom reading routine */
end_comment

begin_function_decl
name|lispval
name|readrx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|lispval
name|readr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|lispval
name|readry
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|keywait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prinlevel
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contains maximum list recursion count	*/
end_comment

begin_decl_stmt
name|int
name|prinlength
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of list elements printed	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|dbqflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|macflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|splflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mantisfl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lispval
name|lastrtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external variable designating current reader 			   table */
end_comment

begin_decl_stmt
specifier|static
name|char
name|baddot1
index|[]
init|=
literal|"Bad reader construction: (.<something>)\nShould be (nil .<something>)\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|baddot2
index|[]
init|=
literal|"Bad reader construction: (<something> .)\n\ Should be (<something> .<something>), assumed to be (<something>)"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|baddot3
index|[]
init|=
literal|"Bad reader construction: (<something> .<something> not followed by )"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_comment
comment|/* readr ****************************************************************/
end_comment

begin_comment
comment|/* returns a s-expression read in from the port specified as the first	*/
end_comment

begin_comment
comment|/* argument.  Handles superbrackets, reader macros.			*/
end_comment

begin_function
name|lispval
name|readr
parameter_list|(
name|useport
parameter_list|)
name|FILE
modifier|*
name|useport
decl_stmt|;
block|{
specifier|register
name|lispval
name|handy
init|=
name|Vreadtable
operator|->
name|a
operator|.
name|clb
decl_stmt|;
name|chkrtab
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|rbktf
operator|=
name|FALSE
expr_stmt|;
name|rdrport
operator|=
operator|(
name|FILE
operator|*
operator|)
name|useport
expr_stmt|;
if|if
condition|(
name|useport
operator|==
name|stdin
condition|)
name|keywait
operator|=
name|TRUE
expr_stmt|;
name|handy
operator|=
name|readrx
argument_list|(
name|Iratom
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|useport
operator|==
name|stdin
condition|)
name|keywait
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* readrx **************************************************************/
end_comment

begin_comment
comment|/* returns a s-expression beginning with the syntax code of an atom	*/
end_comment

begin_comment
comment|/* passed in the first	*/
end_comment

begin_comment
comment|/* argument.  Does the actual work for readr, including list, dotted	*/
end_comment

begin_comment
comment|/* pair, and quoted atom detection					*/
end_comment

begin_function
name|lispval
name|readrx
parameter_list|(
name|code
parameter_list|)
specifier|register
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|lispval
modifier|*
name|current
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|result
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|inlbkt
init|=
name|FALSE
decl_stmt|;
name|lispval
name|errorh
parameter_list|()
function_decl|;
name|top
label|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TLBKT
case|:
name|inlbkt
operator|=
name|TRUE
expr_stmt|;
case|case
name|TLPARA
case|:
name|result
operator|=
name|np
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|nil
expr_stmt|;
comment|/*protect(nil);*/
for|for
control|(
name|EVER
control|)
block|{
switch|switch
condition|(
name|code
operator|=
name|Iratom
argument_list|()
condition|)
block|{
case|case
name|TRPARA
case|:
if|if
condition|(
name|rbktf
operator|&&
name|inlbkt
condition|)
name|rbktf
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
default|default:
name|atomval
operator|=
name|readrx
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
name|TSCA
case|:
name|np
operator|++
operator|->
name|val
operator|=
name|atomval
expr_stmt|;
operator|*
name|current
operator|=
name|work
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|d
operator|.
name|car
operator|=
name|atomval
expr_stmt|;
name|np
operator|--
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
name|work
operator|->
name|d
operator|.
name|cdr
operator|)
expr_stmt|;
break|break;
case|case
name|TSPL
case|:
name|macrox
argument_list|()
expr_stmt|;
comment|/* input and output in atomval */
operator|*
name|current
operator|=
name|atomval
expr_stmt|;
while|while
condition|(
operator|*
name|current
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
operator|*
name|current
argument_list|)
operator|!=
name|DTPR
condition|)
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-list returned from splicing macro"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
operator|*
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|d
operator|.
name|cdr
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TPERD
case|:
if|if
condition|(
name|result
operator|->
name|val
operator|==
name|nil
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
name|work
operator|->
name|d
operator|.
name|cdr
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|baddot1
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|Iratom
argument_list|()
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TRPARA
condition|)
block|{
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
name|baddot2
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|58
argument_list|,
name|result
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
operator|*
name|current
operator|=
name|readrx
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* there is the possibility that the expression 				   following the dot is terminated with a "]" 				   and thus needs no closing lparens to follow 				*/
if|if
condition|(
operator|!
name|rbktf
operator|&&
operator|(
operator|(
name|code
operator|=
name|Iratom
argument_list|()
operator|)
operator|)
operator|!=
name|TRPARA
condition|)
block|{
name|errorh
argument_list|(
name|Vermisc
argument_list|,
name|baddot3
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|59
argument_list|,
name|result
operator|->
name|val
argument_list|,
name|atomval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbktf
operator|&&
name|inlbkt
condition|)
name|rbktf
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
case|case
name|TEOF
case|:
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Premature end of file after "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbktf
condition|)
block|{
if|if
condition|(
name|inlbkt
condition|)
name|rbktf
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
block|}
block|}
case|case
name|TSCA
case|:
return|return
operator|(
name|atomval
operator|)
return|;
case|case
name|TEOF
case|:
return|return
operator|(
name|eofa
operator|)
return|;
case|case
name|TMAC
case|:
name|macrox
argument_list|()
expr_stmt|;
return|return
operator|(
name|atomval
operator|)
return|;
case|case
name|TSPL
case|:
name|macrox
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|=
name|atomval
operator|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|==
name|DTPR
operator|&&
name|work
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
return|return
operator|(
name|work
operator|->
name|d
operator|.
name|car
operator|)
return|;
else|else
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Improper value returned from splicing macro at top-level"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|9
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|Iratom
argument_list|()
expr_stmt|;
goto|goto
name|top
goto|;
comment|/* return(readrx(Iratom())); */
case|case
name|TSQ
case|:
name|result
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|work
operator|=
name|result
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|quota
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|d
operator|.
name|car
operator|=
name|readrx
argument_list|(
name|Iratom
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|->
name|val
operator|)
return|;
default|default:
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Readlist error,  code "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|inewint
argument_list|(
name|code
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|macrox
argument_list|()
end_macro

begin_block
block|{
name|lispval
name|Lapply
parameter_list|()
function_decl|;
name|snpand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|Iget
argument_list|(
name|atomval
argument_list|,
name|macro
argument_list|)
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|atomval
operator|=
name|Lapply
argument_list|()
expr_stmt|;
name|chkrtab
argument_list|(
name|Vreadtable
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
comment|/* the macro could have changed 					   the readtable 					 */
return|return;
block|}
end_block

begin_comment
comment|/* ratomr ***************************************************************/
end_comment

begin_comment
comment|/* this routine returns a pointer to an atom read in from the port given*/
end_comment

begin_comment
comment|/* by the first argument						*/
end_comment

begin_function
name|lispval
name|ratomr
parameter_list|(
name|useport
parameter_list|)
specifier|register
name|FILE
modifier|*
name|useport
decl_stmt|;
block|{
name|rdrport
operator|=
name|useport
expr_stmt|;
switch|switch
condition|(
name|Iratom
argument_list|()
condition|)
block|{
case|case
name|TEOF
case|:
return|return
operator|(
name|eofa
operator|)
return|;
case|case
name|TSQ
case|:
case|case
name|TRPARA
case|:
case|case
name|TLPARA
case|:
case|case
name|TLBKT
case|:
case|case
name|TPERD
case|:
name|strbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|()
operator|)
return|;
default|default:
return|return
operator|(
name|atomval
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|Iratom
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|marker
decl_stmt|,
modifier|*
name|name
decl_stmt|;
specifier|extern
name|lispval
name|finatom
argument_list|()
decl_stmt|,
name|calcnum
argument_list|()
decl_stmt|,
name|getnum
argument_list|()
decl_stmt|;
name|char
name|positv
init|=
name|TRUE
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|strflag
init|=
name|FALSE
decl_stmt|;
name|name
operator|=
name|strbuf
expr_stmt|;
name|again
label|:
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
operator|*
name|name
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|ctable
index|[
name|c
index|]
operator|&
literal|0377
condition|)
block|{
default|default:
goto|goto
name|again
goto|;
case|case
name|VNUM
case|:
case|case
name|VSIGN
case|:
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
name|atomval
operator|=
operator|(
name|getnum
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|VESC
case|:
name|dbqflag
operator|=
name|TRUE
expr_stmt|;
operator|*
name|name
operator|++
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
name|atomval
operator|=
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|VCHAR
case|:
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
name|atomval
operator|=
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|VLPARA
case|:
return|return
operator|(
name|TLPARA
operator|)
return|;
case|case
name|VRPARA
case|:
return|return
operator|(
name|TRPARA
operator|)
return|;
case|case
name|VPERD
case|:
name|c
operator|=
name|peekc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|VNUM
operator|!=
name|ctable
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
name|SEPMASK
operator|&
name|ctable
index|[
name|c
index|]
condition|)
return|return
operator|(
name|TPERD
operator|)
return|;
else|else
block|{
operator|*
name|name
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* this period begins an atm */
name|atomval
operator|=
name|finatom
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
block|}
block|}
operator|*
name|name
operator|++
operator|=
literal|'.'
expr_stmt|;
name|mantisfl
operator|=
literal|1
expr_stmt|;
name|atomval
operator|=
operator|(
name|getnum
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|VLBRCK
case|:
return|return
operator|(
name|TLBKT
operator|)
return|;
case|case
name|VRBRCK
case|:
name|rbktf
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|TRPARA
operator|)
return|;
case|case
name|VEOF
case|:
comment|/*printf("returning eof atom\n");*/
name|clearerr
argument_list|(
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|TEOF
operator|)
return|;
case|case
name|VSQ
case|:
return|return
operator|(
name|TSQ
operator|)
return|;
case|case
name|VSD
case|:
name|strflag
operator|=
name|TRUE
expr_stmt|;
case|case
name|VDQ
case|:
name|name
operator|=
name|strbuf
expr_stmt|;
name|marker
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|)
operator|!=
name|marker
condition|)
block|{
if|if
condition|(
name|VESC
operator|==
name|ctable
index|[
name|c
index|]
condition|)
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|name
operator|>=
name|endstrb
condition|)
name|error
argument_list|(
literal|"ATOM TOO LONG"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|useport
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|useport
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"EOF encountered while reading atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|name
operator|=
name|NULL_CHAR
expr_stmt|;
if|if
condition|(
name|strflag
condition|)
name|atomval
operator|=
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|strbuf
argument_list|)
expr_stmt|;
else|else
name|atomval
operator|=
operator|(
name|getatom
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|VERR
case|:
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[read: null read and ignored]\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* null pname */
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c (%o): "
argument_list|,
name|c
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"ILLEGAL CHARACTER IN ATOM"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
case|case
name|VSPL
case|:
name|code
operator|=
name|TSPL
expr_stmt|;
goto|goto
name|same
goto|;
case|case
name|VMAC
case|:
name|code
operator|=
name|TMAC
expr_stmt|;
goto|goto
name|same
goto|;
case|case
name|VSCA
case|:
name|code
operator|=
name|TSCA
expr_stmt|;
name|same
label|:
name|strbuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|strbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|atomval
operator|=
operator|(
name|getatom
argument_list|()
operator|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|push
parameter_list|()
value|;	if(name==endstrb) error("Int too long",FALSE); else *name++=c;
end_define

begin_define
define|#
directive|define
name|next
parameter_list|()
value|(stats = ctable[c=getc(useport)& 0177])
end_define

begin_function
name|lispval
name|getnum
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
name|char
name|stats
decl_stmt|;
name|double
name|realno
decl_stmt|;
specifier|extern
name|lispval
name|finatom
argument_list|()
decl_stmt|,
name|calcnum
argument_list|()
decl_stmt|,
name|newdoub
argument_list|()
decl_stmt|,
name|dopow
argument_list|()
decl_stmt|;
if|if
condition|(
name|mantisfl
condition|)
block|{
name|mantisfl
operator|=
literal|0
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
goto|goto
name|mantissa
goto|;
block|}
while|while
condition|(
name|VNUM
operator|==
name|next
argument_list|()
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
comment|/* recognize [0-9]*, in "ex" parlance */
block|}
if|if
condition|(
name|stats
operator|==
name|VPERD
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
comment|/* continue */
block|}
elseif|else
if|if
condition|(
name|stats
operator|&
name|SEPMASK
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|name
argument_list|,
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'d'
operator|||
name|c
operator|==
literal|'D'
condition|)
block|{
goto|goto
name|expt
goto|;
block|}
else|else
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
comment|/* at this point we have [0-9]*\. , which might 				   be a decimal int or the leading part of a 				   float				*/
if|if
condition|(
name|next
argument_list|()
operator|!=
name|VNUM
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'d'
operator|||
name|c
operator|==
literal|'D'
condition|)
goto|goto
name|expt
goto|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* Here we have 1.x where x not num, not sep */
comment|/* Here we have decimal int. NOT FORTRAN! */
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|name
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
operator|)
return|;
block|}
block|}
name|mantissa
label|:
do|do
block|{
name|push
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|VNUM
operator|==
name|next
argument_list|()
condition|)
do|;
comment|/* Here we have [0-9]*\.[0-9]* */
if|if
condition|(
name|stats
operator|&
name|SEPMASK
condition|)
goto|goto
name|last
goto|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'e'
operator|&&
name|c
operator|!=
literal|'E'
operator|&&
name|c
operator|!=
literal|'d'
operator|&&
name|c
operator|!=
literal|'D'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
goto|goto
name|verylast
goto|;
block|}
name|expt
label|:
name|push
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|VNUM
operator|==
name|stats
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
name|last
label|:
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stats
operator|&
name|SEPMASK
operator|)
condition|)
return|return
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
return|;
name|verylast
label|:
operator|*
name|name
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|strbuf
argument_list|,
literal|"%F"
argument_list|,
operator|&
name|realno
argument_list|)
expr_stmt|;
operator|(
name|result
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|realno
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|dopow
parameter_list|(
name|part2
parameter_list|,
name|base
parameter_list|)
name|lispval
name|base
decl_stmt|;
specifier|register
name|char
modifier|*
name|part2
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|part2
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
specifier|register
name|int
name|power
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|char
name|stats
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|end1
init|=
name|part2
operator|-
literal|1
decl_stmt|;
name|lispval
name|Ltimes
parameter_list|()
function_decl|;
while|while
condition|(
name|VNUM
operator|==
name|next
argument_list|()
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'.'
operator|&&
operator|!
operator|(
name|stats
operator|&
name|SEPMASK
operator|)
condition|)
block|{
return|return
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|inewint
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* calculate "mantissa"*/
if|if
condition|(
operator|*
name|end1
operator|==
literal|'.'
condition|)
name|np
operator|++
operator|->
name|val
operator|=
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|end1
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|np
operator|++
operator|->
name|val
operator|=
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|end1
argument_list|,
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|power
operator|=
name|calcnum
argument_list|(
name|part2
argument_list|,
name|name
argument_list|,
literal|10
argument_list|)
operator|->
name|i
expr_stmt|;
else|else
name|power
operator|=
name|calcnum
argument_list|(
name|part2
argument_list|,
name|name
argument_list|,
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|->
name|i
expr_stmt|;
while|while
condition|(
name|power
operator|--
operator|>
literal|0
condition|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|Ltimes
argument_list|()
expr_stmt|;
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|calcnum
parameter_list|(
name|strbuf
parameter_list|,
name|name
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|strbuf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|negflag
init|=
literal|0
decl_stmt|;
name|temp
operator|=
name|rdrsdot
expr_stmt|;
comment|/* initialize sdot cell */
name|temp
operator|->
name|s
operator|.
name|CDR
operator|=
name|nil
expr_stmt|;
name|temp
operator|->
name|i
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strbuf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|negflag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|name
condition|)
return|return
operator|(
name|getatom
argument_list|()
operator|)
return|;
for|for
control|(
init|;
name|p
operator|<
name|name
condition|;
name|p
operator|++
control|)
name|dmlad
argument_list|(
name|temp
argument_list|,
name|base
argument_list|,
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|negflag
condition|)
name|dmlad
argument_list|(
name|temp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|s
operator|.
name|CDR
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|inewint
argument_list|(
name|temp
operator|->
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
operator|(
name|result
operator|=
name|newsdot
argument_list|()
operator|)
operator|->
name|i
operator|=
name|temp
operator|->
name|i
expr_stmt|;
name|result
operator|->
name|s
operator|.
name|CDR
operator|=
name|temp
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
name|temp
operator|->
name|s
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|finatom
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|int
name|uctolc
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|stats
decl_stmt|;
specifier|register
name|char
modifier|*
name|savenm
decl_stmt|;
name|savenm
operator|=
name|name
operator|-
literal|1
expr_stmt|;
comment|/* remember start of name */
while|while
condition|(
operator|!
operator|(
name|next
argument_list|()
operator|&
name|SEPMASK
operator|)
condition|)
block|{
if|if
condition|(
name|stats
operator|==
name|VESC
condition|)
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|name
operator|>=
name|endstrb
condition|)
name|error
argument_list|(
literal|"ATOM TOO LONG"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|*
name|name
operator|=
name|NULL_CHAR
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
name|uctolc
condition|)
for|for
control|(
init|;
operator|*
name|savenm
condition|;
name|savenm
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|savenm
argument_list|)
condition|)
operator|*
name|savenm
operator|=
name|tolower
argument_list|(
operator|*
name|savenm
argument_list|)
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* printr ***************************************************************/
end_comment

begin_comment
comment|/* prints the first argument onto the port specified by the second 	*/
end_comment

begin_comment
comment|/*  * Last modified Mar 21, 1980 for hunks  */
end_comment

begin_expr_stmt
name|printr
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
specifier|register
name|lispval
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|useport
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|hsize
operator|,
name|i
expr_stmt|;
name|char
name|strflag
init|=
literal|0
decl_stmt|;
name|char
name|Idqc
init|=
literal|0
decl_stmt|;
name|int
name|curprinlength
init|=
name|prinlength
decl_stmt|;
name|val_loop
label|:
if|if
condition|(
operator|!
name|VALID
argument_list|(
name|a
argument_list|)
condition|)
block|{
comment|/* 	error("Bad lisp data encountered by printr", TRUE);  		a = badst; 	*/
name|printf
argument_list|(
literal|"<printr:bad lisp data: 0x%x>"
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|UNBO
case|:
name|fputs
argument_list|(
literal|"<UNBOUND>"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUE
case|:
name|fputs
argument_list|(
literal|"(ptr to)"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|l
expr_stmt|;
goto|goto
name|val_loop
goto|;
case|case
name|INT
case|:
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"%d"
argument_list|,
name|a
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|lfltpr
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|r
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PORT
case|:
block|{
name|lispval
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|ioname
index|[
name|PN
argument_list|(
name|a
operator|->
name|p
argument_list|)
index|]
operator|)
operator|==
name|nil
condition|)
name|fputs
argument_list|(
literal|"%$unopenedport"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"%%%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HUNK2
case|:
case|case
name|HUNK4
case|:
case|case
name|HUNK8
case|:
case|case
name|HUNK16
case|:
case|case
name|HUNK32
case|:
case|case
name|HUNK64
case|:
case|case
name|HUNK128
case|:
if|if
condition|(
name|prinlevel
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"%"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
block|}
name|hsize
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"{"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|prinlevel
operator|--
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|h
operator|.
name|hunk
index|[
literal|0
index|]
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|curprinlength
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|hsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|==
name|hunkfree
condition|)
break|break;
if|if
condition|(
name|curprinlength
operator|--
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|" ..."
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|" "
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"}"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|prinlevel
operator|++
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|fputs
argument_list|(
literal|"array["
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|ar
operator|.
name|length
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"]"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCD
case|:
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"#%X-"
argument_list|,
name|a
operator|->
name|bcd
operator|.
name|entry
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|discipline
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|pbignum
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
if|if
condition|(
name|prinlevel
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"&"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
block|}
name|prinlevel
operator|--
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|quota
operator|&&
name|a
operator|->
name|d
operator|.
name|cdr
operator|!=
name|nil
operator|&&
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
block|{
name|putc
argument_list|(
literal|'\''
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|prinlevel
operator|++
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|'('
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|curprinlength
operator|--
expr_stmt|;
name|morelist
label|:
name|printr
argument_list|(
name|a
operator|->
name|d
operator|.
name|car
argument_list|,
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|a
operator|->
name|d
operator|.
name|cdr
operator|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|curprinlength
operator|--
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|" ..."
argument_list|,
name|useport
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|putc
argument_list|(
literal|' '
argument_list|,
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
operator|==
name|DTPR
condition|)
goto|goto
name|morelist
goto|;
name|fputs
argument_list|(
literal|". "
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|fputc
argument_list|(
literal|')'
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|prinlevel
operator|++
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|strflag
operator|=
name|TRUE
expr_stmt|;
name|Idqc
operator|=
name|Xsdc
expr_stmt|;
case|case
name|ATOM
case|:
block|{
name|char
modifier|*
name|front
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|clean
decl_stmt|;
name|temp
operator|=
name|front
operator|=
operator|(
name|strflag
condition|?
operator|(
operator|(
name|char
operator|*
operator|)
name|a
operator|)
else|:
name|a
operator|->
name|a
operator|.
name|pname
operator|)
expr_stmt|;
if|if
condition|(
name|Idqc
operator|==
literal|0
condition|)
name|Idqc
operator|=
name|Xdqc
expr_stmt|;
if|if
condition|(
name|Idqc
condition|)
block|{
name|clean
operator|=
operator|*
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|temp
operator|==
literal|'-'
condition|)
name|temp
operator|++
expr_stmt|;
name|clean
operator|=
name|clean
operator|&&
operator|(
name|ctable
index|[
operator|*
name|temp
index|]
operator|!=
name|VNUM
operator|)
expr_stmt|;
while|while
condition|(
name|clean
operator|&&
operator|*
name|temp
condition|)
name|clean
operator|=
operator|(
operator|!
operator|(
name|ctable
index|[
operator|*
name|temp
operator|++
index|]
operator|&
name|QUTMASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|clean
operator|&
operator|!
name|strflag
condition|)
name|fputs
argument_list|(
name|front
argument_list|,
name|useport
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
name|Idqc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|front
init|;
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
name|Idqc
operator|||
name|ctable
index|[
operator|*
name|temp
index|]
operator|==
name|VESC
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|temp
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|Idqc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|front
decl_stmt|;
if|if
condition|(
name|ctable
index|[
operator|*
name|cp
index|]
operator|==
name|VNUM
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|ctable
index|[
operator|*
name|cp
index|]
operator|&
name|QUTMASK
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_macro
name|lfltpr
argument_list|(
argument|buf
argument_list|,
argument|val
argument_list|)
end_macro

begin_comment
comment|/* lisp floating point printer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%.16G"
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|cp1
operator|=
name|buf
init|;
operator|*
name|cp1
condition|;
name|cp1
operator|++
control|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
operator|||
operator|*
name|cp1
operator|==
literal|'E'
condition|)
return|return;
comment|/* if we are here, there was no dot, so the number was 	   an integer.  Furthermore, cp1 already points to the  	   end of the string. */
operator|*
name|cp1
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* dmpport ****************************************************************/
end_comment

begin_comment
comment|/* outputs buffer indicated by first argument whether full or not	*/
end_comment

begin_expr_stmt
name|dmpport
argument_list|(
name|useport
argument_list|)
specifier|register
name|lispval
name|useport
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|fflush
argument_list|(
name|useport
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  protect and unprot moved to eval.c  (whr)  */
end_comment

end_unit

