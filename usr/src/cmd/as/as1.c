begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_decl_stmt
name|char
name|AS1
index|[]
init|=
literal|"@(#)as1.c 1.21 79/03/21 22:27:27"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sccs ident */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"as.yh"
end_include

begin_decl_stmt
name|int
name|curlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|datbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|nextsym
decl_stmt|,
modifier|*
name|rovjxxx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|endcore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hdr
name|hdr
init|=
block|{
literal|0410
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|vax
end_ifndef

begin_struct
struct|struct
block|{
name|short
name|hiword
decl_stmt|;
name|short
name|loword
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* stupid fp-11 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|writel
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|vax
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|n
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
operator|*
name|p
operator|)
operator|.
name|loword
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
operator|*
name|p
operator|)
operator|.
name|hiword
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|symwrite
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|vax
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|p
operator|->
name|ptype
condition|?
operator|&
operator|(
name|p
operator|->
name|ptype
operator|)
else|:
operator|&
operator|(
name|p
operator|->
name|type
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
name|p
operator|->
name|other
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|other
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
name|p
operator|->
name|desc
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|desc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|#
directive|else
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|p
operator|->
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|writel
argument_list|(
operator|&
operator|(
name|p
operator|->
name|value
operator|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|tmpn1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpn2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tmpn3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exp
name|usedot
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|usefile
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rusefile
index|[
name|NLOC
operator|+
name|NLOC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_sibuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|_sobuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|njxxx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|d124
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|symcmp
parameter_list|()
function_decl|;
specifier|register
name|struct
name|instab
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|v
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|outfile
init|=
literal|"a.out"
decl_stmt|;
name|int
name|infound
init|=
literal|0
decl_stmt|;
name|int
name|delexit
parameter_list|()
function_decl|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|yyerror
argument_list|(
literal|"-o what?"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outfile
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
block|{
name|d124
operator|=
name|argv
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|d124
operator|!=
literal|1
operator|&&
name|d124
operator|!=
literal|2
operator|&&
name|d124
operator|!=
literal|4
condition|)
block|{
name|yyerror
argument_list|(
literal|"-d[124] only"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|infound
condition|)
block|{
name|yyerror
argument_list|(
literal|">1 argument."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|infound
operator|++
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"as: Can't open %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|_sibuf
argument_list|)
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|nextsym
operator|=
name|symtab
operator|=
name|endcore
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rovjxxx
operator|=
name|nextsym
operator|-
literal|1
expr_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|instab
init|;
name|ip
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|;
name|ip
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|ip
operator|->
name|name
operator|,
name|p2
operator|=
name|yytext
init|;
name|p2
operator|<
name|yytext
operator|+
name|NCPS
condition|;
control|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|0
expr_stmt|;
name|usrname
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|lookup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|==
name|NULL
condition|)
block|{
operator|*
name|hp
operator|=
name|ip
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|tag
operator|!=
operator|(
name|INSTn
operator|-
literal|256
operator|)
operator|&&
name|ip
operator|->
name|tag
operator|!=
operator|(
name|INST0
operator|-
literal|256
operator|)
operator|&&
name|ip
operator|->
name|tag
operator|!=
literal|0
condition|)
continue|continue;
comment|/* was pseudo-op */
comment|/*			c++; /*			if (c>=NINST) { /*				yyerror("Instruction table overflow"); /*				continue; /*			} */
name|itab
index|[
name|ip
operator|->
name|opcode
operator|&
literal|0xFF
index|]
operator|=
name|ip
expr_stmt|;
comment|/* given opcode, find instruction */
block|}
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
name|usedot
index|[
name|c
index|]
operator|.
name|xtype
operator|=
name|XTEXT
expr_stmt|;
name|usedot
index|[
name|c
operator|+
name|NLOC
index|]
operator|.
name|xtype
operator|=
name|XDATA
expr_stmt|;
block|}
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
name|tmpn1
operator|=
name|mktemp
argument_list|(
literal|"/tmp/asXXXXX"
argument_list|)
expr_stmt|;
name|tmpfil
operator|=
name|fopen
argument_list|(
name|tmpn1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad temp1file"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|tmpfil
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
name|anyerrs
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|jxxxfix
argument_list|()
expr_stmt|;
name|stabfix
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|tmpfil
operator|=
name|fopen
argument_list|(
name|tmpn1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Bad tmp1file (r)"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|tmpfil
argument_list|,
name|_sibuf
argument_list|)
expr_stmt|;
comment|/* round and assign text segment origins */
name|tsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
name|v
operator|=
name|round
argument_list|(
name|usedot
index|[
name|c
index|]
operator|.
name|xvalue
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|usedot
index|[
name|c
index|]
operator|.
name|xvalue
operator|=
name|tsize
expr_stmt|;
name|tsize
operator|+=
name|v
expr_stmt|;
block|}
comment|/* round and assign data segment origins */
name|datbase
operator|=
name|round
argument_list|(
name|tsize
argument_list|,
name|PAGRND
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
name|v
operator|=
name|round
argument_list|(
name|usedot
index|[
name|NLOC
operator|+
name|c
index|]
operator|.
name|xvalue
argument_list|,
name|FW
argument_list|)
expr_stmt|;
name|usedot
index|[
name|NLOC
operator|+
name|c
index|]
operator|.
name|xvalue
operator|=
name|datbase
operator|+
name|dsize
expr_stmt|;
name|dsize
operator|+=
name|v
expr_stmt|;
block|}
name|hdr
operator|.
name|bsize
operator|=
name|dsize
expr_stmt|;
comment|/* assign final values to symbols */
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|nextsym
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|name
index|[
literal|0
index|]
operator|&
literal|0xFF
operator|)
operator|>=
literal|0xFE
condition|)
continue|continue;
comment|/* ignore jxxx entries */
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEF
condition|)
name|sp
operator|->
name|type
operator|=
name|XXTRN
operator|+
name|XUNDEF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XDATA
condition|)
name|sp
operator|->
name|value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|index
index|]
operator|.
name|xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XTEXT
condition|)
name|sp
operator|->
name|value
operator|+=
name|usedot
index|[
name|sp
operator|->
name|index
index|]
operator|.
name|xvalue
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|XBSS
condition|)
block|{
name|long
name|bs
decl_stmt|;
name|bs
operator|=
name|sp
operator|->
name|value
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|hdr
operator|.
name|bsize
operator|+
name|datbase
expr_stmt|;
name|hdr
operator|.
name|bsize
operator|+=
name|bs
expr_stmt|;
block|}
block|}
name|hdr
operator|.
name|bsize
operator|-=
name|dsize
expr_stmt|;
name|tmpn2
operator|=
name|mktemp
argument_list|(
literal|"/tmp/aaatXXXXX"
argument_list|)
expr_stmt|;
name|txtfil
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txtfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"Cannot create %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|setbuf
argument_list|(
name|txtfil
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
name|usefile
index|[
literal|0
index|]
operator|=
name|txtfil
expr_stmt|;
name|tmpn3
operator|=
name|mktemp
argument_list|(
literal|"/tmp/abatXXXXX"
argument_list|)
expr_stmt|;
name|relfil
operator|=
name|fopen
argument_list|(
name|tmpn3
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"temp file can't be opened"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|rusefile
index|[
literal|0
index|]
operator|=
name|relfil
expr_stmt|;
name|hdr
operator|.
name|tsize
operator|=
name|tsize
expr_stmt|;
name|hdr
operator|.
name|dsize
operator|=
name|dsize
expr_stmt|;
name|hdr
operator|.
name|ssize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|tag
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|index
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|symtab
index|[
literal|0
index|]
operator|.
name|ptype
argument_list|)
operator|)
operator|)
operator|*
operator|(
name|nextsym
operator|-
name|symtab
operator|-
name|njxxx
operator|)
expr_stmt|;
comment|/* hdr.trsize, hdr.drsize set by outrel */
name|writel
argument_list|(
operator|&
name|hdr
argument_list|,
literal|8
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|tsize
operator|=
literal|0
expr_stmt|;
name|dsize
operator|=
literal|0
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
literal|0
index|]
expr_stmt|;
name|passno
operator|=
literal|2
expr_stmt|;
comment|/* 	for (sp=symtab; sp<nextsym; sp++) 		sp->index = 20000; */
name|setindices
argument_list|()
expr_stmt|;
name|yyparse
argument_list|()
expr_stmt|;
comment|/* round csects to FW */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|usefile
index|[
name|c
index|]
condition|)
block|{
name|txtfil
operator|=
name|usefile
index|[
name|c
index|]
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|c
index|]
expr_stmt|;
while|while
condition|(
name|usedot
index|[
name|c
index|]
operator|.
name|xvalue
operator|&
name|FW
condition|)
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
name|fclose
argument_list|(
name|usefile
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rusefile
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usefile
index|[
name|NLOC
operator|+
name|c
index|]
condition|)
block|{
name|txtfil
operator|=
name|usefile
index|[
name|NLOC
operator|+
name|c
index|]
expr_stmt|;
name|dotp
operator|=
operator|&
name|usedot
index|[
name|c
operator|+
name|NLOC
index|]
expr_stmt|;
name|relfil
operator|=
name|rusefile
index|[
name|NLOC
operator|+
name|c
index|]
expr_stmt|;
while|while
condition|(
name|usedot
index|[
name|c
operator|+
name|NLOC
index|]
operator|.
name|xvalue
operator|&
name|FW
condition|)
name|outb
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|txtfil
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|relfil
argument_list|)
expr_stmt|;
block|}
block|}
name|txtfil
operator|=
name|usefile
index|[
literal|0
index|]
expr_stmt|;
comment|/* append csect text onto text for csect 0 */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
specifier|register
name|ch
expr_stmt|;
if|if
condition|(
name|usefile
index|[
name|c
index|]
condition|)
block|{
name|tmpn2
index|[
name|TMPC
index|]
operator|=
name|c
operator|+
literal|'a'
expr_stmt|;
name|relfil
operator|=
name|fopen
argument_list|(
name|tmpn2
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"cannot reopen temp"
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|relfil
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|relfil
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* append relocation info onto text */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
specifier|register
name|ch
expr_stmt|;
if|if
condition|(
name|rusefile
index|[
name|c
index|]
condition|)
block|{
name|tmpn3
index|[
name|TMPC
index|]
operator|=
name|c
operator|+
literal|'a'
expr_stmt|;
name|relfil
operator|=
name|fopen
argument_list|(
name|tmpn3
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|relfil
operator|==
name|NULL
condition|)
block|{
name|yyerror
argument_list|(
literal|"cannot reopen temp"
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|relfil
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|relfil
argument_list|)
expr_stmt|;
block|}
block|}
name|remjxxx
argument_list|()
expr_stmt|;
comment|/* 	qsort(symtab, nextsym-symtab, sizeof(symtab[0]), symcmp); */
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|nextsym
condition|;
name|sp
operator|++
control|)
block|{
name|sp
operator|->
name|type
operator|&=
operator|~
name|XFORW
expr_stmt|;
name|sp
operator|->
name|index
operator|=
literal|0
expr_stmt|;
block|}
name|symwrite
argument_list|(
name|symtab
argument_list|,
name|nextsym
operator|-
name|symtab
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|txtfil
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* a little half-passedness here to get rsize correct */
name|writel
argument_list|(
operator|&
name|hdr
argument_list|,
literal|8
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|delete
argument_list|()
expr_stmt|;
if|if
condition|(
name|anyerrs
operator|==
literal|0
operator|&&
name|orgwarn
condition|)
name|yyerror
argument_list|(
literal|"Caution: absolute origins.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|anyerrs
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|delete
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|delete
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|c
expr_stmt|;
if|if
condition|(
name|tmpn1
condition|)
name|unlink
argument_list|(
name|tmpn1
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NLOC
operator|+
name|NLOC
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|tmpn2
condition|)
block|{
name|tmpn2
index|[
name|TMPC
index|]
operator|=
name|c
operator|+
literal|'a'
expr_stmt|;
name|unlink
argument_list|(
name|tmpn2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpn3
condition|)
block|{
name|tmpn3
index|[
name|TMPC
index|]
operator|=
name|c
operator|+
literal|'a'
expr_stmt|;
name|unlink
argument_list|(
name|tmpn3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|struct
name|symtab
modifier|*
name|symalloc
parameter_list|()
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
operator|++
name|nextsym
operator|>=
name|endcore
condition|)
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|sbrk
argument_list|(
literal|200
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
argument_list|)
condition|)
block|{
name|yyerror
argument_list|(
literal|"Memory overflow"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
name|p
operator|=
name|endcore
operator|+=
literal|200
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|symtab
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|>
operator|(
name|char
operator|*
operator|)
name|nextsym
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/*if(++nextsym-symtab>NSYM) yyerror("Symbol table overflow"); */
return|return
operator|(
name|nextsym
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symtab
modifier|*
modifier|*
name|lookup
parameter_list|(
name|instflg
parameter_list|)
block|{
specifier|register
name|int
name|ihash
decl_stmt|;
name|int
name|un
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|static
name|struct
name|symtab
modifier|*
name|local
decl_stmt|;
if|if
condition|(
name|lclname
operator|!=
literal|0
condition|)
block|{
name|lclname
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|hp
operator|=
operator|&
name|local
operator|)
operator|=
name|symalloc
argument_list|()
expr_stmt|;
name|p1
operator|=
name|yytext
expr_stmt|;
name|p2
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|hp
operator|)
return|;
block|}
name|un
operator|=
name|usrname
expr_stmt|;
name|usrname
operator|=
literal|1
expr_stmt|;
name|ihash
operator|=
literal|0
expr_stmt|;
name|p1
operator|=
name|yytext
expr_stmt|;
while|while
condition|(
operator|*
name|p1
condition|)
block|{
name|ihash
operator|+=
name|ihash
operator|+
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|ihash
operator|&=
literal|077777
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|yytext
operator|+
name|NCPS
condition|)
operator|*
name|p1
operator|++
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
operator|&
name|hshtab
index|[
name|ihash
operator|%
name|NHASH
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|hp
condition|)
block|{
if|if
condition|(
name|hp
operator|>=
name|symtab
operator|&&
operator|(
operator|*
name|hp
operator|)
operator|->
name|ptype
condition|)
block|{
name|printf
argument_list|(
literal|"IGNORING LOOKUP %s %x %x %x\n"
argument_list|,
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|hp
operator|)
operator|->
name|ptype
argument_list|,
operator|(
operator|*
name|hp
operator|)
operator|->
name|type
argument_list|,
operator|(
operator|*
name|hp
operator|)
operator|->
name|type
operator|&
name|STABTYPS
argument_list|)
expr_stmt|;
goto|goto
name|no
goto|;
block|}
name|p2
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|yytext
init|;
name|p1
operator|<
name|yytext
operator|+
name|NCPS
condition|;
control|)
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
goto|goto
name|no
goto|;
comment|/*		if (un == ((*hp)->tag==0)) */
return|return
operator|(
name|hp
operator|)
return|;
name|no
label|:
if|if
condition|(
operator|++
name|hp
operator|>=
operator|&
name|hshtab
index|[
name|NHASH
index|]
condition|)
name|hp
operator|=
name|hshtab
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|hshused
operator|>=
name|NHASH
condition|)
block|{
name|yyerror
argument_list|(
literal|"Symbol table overflow"
argument_list|)
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|instflg
condition|)
block|{
operator|*
name|hp
operator|=
name|symalloc
argument_list|()
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|yytext
operator|,
name|p2
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
init|;
name|p1
operator|<
name|yytext
operator|+
name|NCPS
condition|;
control|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
end_function

begin_macro
name|outb
argument_list|(
argument|val
argument_list|)
end_macro

begin_block
block|{
name|dotp
operator|->
name|xvalue
operator|++
expr_stmt|;
if|if
condition|(
name|passno
operator|==
literal|2
condition|)
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|reflen
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|outrel
argument_list|(
argument|pval
argument_list|,
argument|reftype
argument_list|,
argument|reltype
argument_list|,
argument|xsym
argument_list|)
end_macro

begin_decl_stmt
name|long
modifier|*
name|pval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|reftype
decl_stmt|,
name|reltype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|xsym
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* reftype: PCREL or not, plus length LEN1, LEN2, LEN4, LEN8 /* reltype: csect ("segment") number (XTEXT, XDATA, ...) associated with 'val' /* xsym: symbol table pointer */
name|long
name|ts
decl_stmt|;
name|char
name|tc
decl_stmt|;
name|long
name|tl
decl_stmt|;
name|short
name|t
decl_stmt|;
if|if
condition|(
name|passno
operator|!=
literal|2
condition|)
block|{
name|dotp
operator|->
name|xvalue
operator|+=
name|reflen
index|[
name|reftype
index|]
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bitoff
operator|&
literal|07
condition|)
name|yyerror
argument_list|(
literal|"Padding error"
argument_list|)
expr_stmt|;
name|reltype
operator|&=
operator|~
name|XFORW
expr_stmt|;
if|if
condition|(
name|reltype
operator|==
name|XUNDEF
condition|)
name|yyerror
argument_list|(
literal|"Undefined reference"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reltype
operator|!=
name|XABS
operator|||
name|reftype
operator|&
name|PCREL
condition|)
block|{
comment|/* write the address portion of a relocation datum */
if|if
condition|(
name|dotp
operator|>=
operator|&
name|usedot
index|[
name|NLOC
index|]
condition|)
block|{
name|hdr
operator|.
name|drsize
operator|+=
sizeof|sizeof
argument_list|(
name|dotp
operator|->
name|xvalue
argument_list|)
operator|+
literal|3
operator|+
sizeof|sizeof
name|tc
expr_stmt|;
name|tl
operator|=
name|dotp
operator|->
name|xvalue
operator|-
name|datbase
expr_stmt|;
name|writel
argument_list|(
operator|&
name|tl
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|.
name|trsize
operator|+=
sizeof|sizeof
argument_list|(
name|dotp
operator|->
name|xvalue
argument_list|)
operator|+
literal|3
operator|+
sizeof|sizeof
name|tc
expr_stmt|;
name|writel
argument_list|(
operator|&
name|dotp
operator|->
name|xvalue
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
block|}
comment|/* write the properties portion of a relocation datum */
if|if
condition|(
name|reltype
operator|==
name|XXTRN
operator|+
name|XUNDEF
condition|)
block|{
name|setindex
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|ts
operator|=
operator|(
name|xsym
operator|->
name|index
operator|)
expr_stmt|;
name|tc
operator|=
operator|(
name|XXTRN
operator|<<
literal|3
operator|)
operator||
operator|(
name|reftype
operator|-
name|LEN1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|reltype
operator|&
name|XTYPE
operator|)
operator|==
name|XUNDEFO
condition|)
block|{
name|setindex
argument_list|(
name|xsym
argument_list|)
expr_stmt|;
name|ts
operator|=
operator|(
name|xsym
operator|->
name|index
operator|)
expr_stmt|;
name|tc
operator|=
operator|(
operator|(
name|XXTRN
operator|+
literal|2
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
name|reftype
operator|-
name|LEN1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|=
operator|(
name|reltype
operator|)
expr_stmt|;
name|tc
operator|=
operator|(
name|reftype
operator|-
name|LEN1
operator|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ts
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|tc
argument_list|,
sizeof|sizeof
argument_list|(
name|tc
argument_list|)
argument_list|,
literal|1
argument_list|,
name|relfil
argument_list|)
expr_stmt|;
block|}
comment|/* write the raw ("unrelocated") value to the text file */
name|t
operator|=
name|reflen
index|[
name|reftype
index|]
expr_stmt|;
name|dotp
operator|->
name|xvalue
operator|+=
name|t
expr_stmt|;
if|if
condition|(
name|reftype
operator|&
name|PCREL
condition|)
operator|*
name|pval
operator|-=
name|dotp
operator|->
name|xvalue
expr_stmt|;
ifdef|#
directive|ifdef
name|vax
name|fwrite
argument_list|(
name|pval
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|t
operator|>
literal|2
condition|)
block|{
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pval
operator|)
operator|.
name|loword
operator|)
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pval
operator|)
operator|.
name|hiword
operator|)
argument_list|,
literal|1
argument_list|,
name|t
operator|-
literal|2
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
block|}
else|else
name|fwrite
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pval
operator|)
operator|.
name|loword
operator|)
argument_list|,
literal|1
argument_list|,
name|t
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|setindex
argument_list|(
name|xsym
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|xsym
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return;
comment|/*	 	if (xsym->index == 20000) 		xsym->index = gindex++; 	if (gindex>= 1023) 		yyerror("Too many external symbols"); */
block|}
end_block

begin_macro
name|flushfield
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|bitoff
operator|==
literal|0
condition|)
return|return;
name|n
operator|=
operator|(
operator|(
name|bitoff
operator|+
name|n
operator|-
literal|1
operator|)
operator|/
name|n
operator|)
operator|*
name|n
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|outb
argument_list|(
operator|(
name|int
operator|)
name|bitfield
argument_list|)
expr_stmt|;
name|bitfield
operator|>>=
literal|8
expr_stmt|;
name|n
operator|-=
literal|8
expr_stmt|;
block|}
name|bitoff
operator|=
literal|0
expr_stmt|;
name|bitfield
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|putflt
argument_list|(
argument|fp
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|double
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fwrite
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
name|txtfil
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|symcmp
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|index
operator|<
name|q
operator|->
name|index
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|index
operator|>
name|q
operator|->
name|index
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|value
operator|<
name|q
operator|->
name|value
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|value
operator|>
name|q
operator|->
name|value
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|stabfix
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|nextsym
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|ptype
operator|&&
operator|(
name|sp
operator|->
name|type
operator|&
literal|0200
operator|)
condition|)
block|{
name|p
operator|=
name|sp
operator|->
name|value
expr_stmt|;
name|sp
operator|->
name|value
operator|=
name|p
operator|->
name|value
expr_stmt|;
name|sp
operator|->
name|index
operator|=
name|p
operator|->
name|index
expr_stmt|;
name|sp
operator|->
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
comment|/* printf("STABFIX: %s (old %s) to %d offsets %d %d\n", sp->name, p->name, sp->value, sp, p); */
comment|/* 			sp->ptype = (sp->ptype& STABTYPS) | (p->type& N_EXT); */
block|}
block|}
block|}
end_block

end_unit

