begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  link editor  */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"sys/types.h"
end_include

begin_include
include|#
directive|include
file|"sys/stat.h"
end_include

begin_comment
comment|/*	Layout of a.out file :  *  *	header of 8 words	magic number 405, 407, 410, 411  *				text size	)  *				data size	) in bytes but even  *				bss size	)  *				symbol table size  *				entry point  *				{unused}  *				flag set if no relocation  *  *  *	header:		0  *	text:		16  *	data:		16+textsize  *	relocation:	16+textsize+datasize  *	symbol table:	16+2*(textsize+datasize) or 16+textsize+datasize  *  */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|ARCMAGIC
value|0177545
end_define

begin_define
define|#
directive|define
name|OMAGIC
value|0405
end_define

begin_define
define|#
directive|define
name|FMAGIC
value|0407
end_define

begin_define
define|#
directive|define
name|NMAGIC
value|0410
end_define

begin_define
define|#
directive|define
name|IMAGIC
value|0411
end_define

begin_define
define|#
directive|define
name|EXTERN
value|040
end_define

begin_define
define|#
directive|define
name|UNDEF
value|00
end_define

begin_define
define|#
directive|define
name|ABS
value|01
end_define

begin_define
define|#
directive|define
name|TEXT
value|02
end_define

begin_define
define|#
directive|define
name|DATA
value|03
end_define

begin_define
define|#
directive|define
name|BSS
value|04
end_define

begin_define
define|#
directive|define
name|COMM
value|05
end_define

begin_comment
comment|/* internal use only */
end_comment

begin_define
define|#
directive|define
name|RABS
value|00
end_define

begin_define
define|#
directive|define
name|RTEXT
value|02
end_define

begin_define
define|#
directive|define
name|RDATA
value|04
end_define

begin_define
define|#
directive|define
name|RBSS
value|06
end_define

begin_define
define|#
directive|define
name|REXT
value|010
end_define

begin_define
define|#
directive|define
name|NOVLY
value|16
end_define

begin_define
define|#
directive|define
name|RELFLG
value|01
end_define

begin_define
define|#
directive|define
name|NROUT
value|256
end_define

begin_define
define|#
directive|define
name|NSYM
value|1103
end_define

begin_define
define|#
directive|define
name|NSYMPR
value|1000
end_define

begin_decl_stmt
name|char
name|premeof
index|[]
init|=
literal|"Premature EOF"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|goodnm
index|[]
init|=
literal|"__.SYMDEF"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of contents stuff */
end_comment

begin_define
define|#
directive|define
name|TABSZ
value|700
end_define

begin_struct
struct|struct
name|tab
block|{
name|char
name|cname
index|[
literal|8
index|]
decl_stmt|;
name|long
name|cloc
decl_stmt|;
block|}
name|tab
index|[
name|TABSZ
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|tnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* overlay management */
end_comment

begin_decl_stmt
name|int
name|vindex
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|overlay
block|{
name|int
name|argsav
decl_stmt|;
name|int
name|symsav
decl_stmt|;
name|struct
name|liblist
modifier|*
name|libsav
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|int
name|ctsav
decl_stmt|,
name|cdsav
decl_stmt|,
name|cbsav
decl_stmt|;
name|int
name|offt
decl_stmt|,
name|offd
decl_stmt|,
name|offb
decl_stmt|,
name|offs
decl_stmt|;
block|}
name|vnodes
index|[
name|NOVLY
index|]
struct|;
end_struct

begin_comment
comment|/* input management */
end_comment

begin_struct
struct|struct
name|page
block|{
name|int
name|nuser
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|buff
index|[
literal|256
index|]
decl_stmt|;
block|}
name|page
index|[
literal|2
index|]
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|nuser
decl_stmt|;
name|int
name|bno
decl_stmt|;
block|}
name|fpage
struct|;
end_struct

begin_struct
struct|struct
name|stream
block|{
name|int
modifier|*
name|ptr
decl_stmt|;
name|int
name|bno
decl_stmt|;
name|int
name|nibuf
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|page
modifier|*
name|pno
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|stream
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stream
name|reloc
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|char
name|aname
index|[
literal|14
index|]
decl_stmt|;
name|long
name|atime
decl_stmt|;
name|char
name|auid
decl_stmt|,
name|agid
decl_stmt|;
name|int
name|amode
decl_stmt|;
name|long
name|asize
decl_stmt|;
block|}
name|archdr
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|fmagic
decl_stmt|;
name|int
name|tsize
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|ssize
decl_stmt|;
name|int
name|entry
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|relflg
decl_stmt|;
block|}
name|filhdr
struct|;
end_struct

begin_comment
comment|/* one entry for each archive member referenced;  * set in first pass; needs restoring for overlays  */
end_comment

begin_struct
struct|struct
name|liblist
block|{
name|long
name|loc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|liblist
name|liblist
index|[
name|NROUT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|liblist
modifier|*
name|libp
init|=
name|liblist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol management */
end_comment

begin_struct
struct|struct
name|symbol
block|{
name|char
name|sname
index|[
literal|8
index|]
decl_stmt|;
name|char
name|stype
decl_stmt|;
name|char
name|spare
decl_stmt|;
name|int
name|svalue
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|local
block|{
name|int
name|locindex
decl_stmt|;
comment|/* index to symbol in file */
name|struct
name|symbol
modifier|*
name|locsymbol
decl_stmt|;
comment|/* ptr to symbol table */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|symbol
name|cursym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current symbol */
end_comment

begin_decl_stmt
name|struct
name|symbol
name|symtab
index|[
name|NSYM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actual symbols */
end_comment

begin_decl_stmt
name|struct
name|symbol
modifier|*
modifier|*
name|symhash
index|[
name|NSYM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to hash table entry */
end_comment

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|lastsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last symbol entered */
end_comment

begin_decl_stmt
name|int
name|symindex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next available symbol table entry */
end_comment

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|hshtab
index|[
name|NSYM
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for symbols */
end_comment

begin_decl_stmt
name|struct
name|local
name|local
index|[
name|NSYMPR
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal symbols */
end_comment

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|p_etext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|p_edata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|p_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|entrypt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags */
end_comment

begin_decl_stmt
name|int
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard local symbols */
end_comment

begin_decl_stmt
name|int
name|Xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard locals starting with 'L' */
end_comment

begin_decl_stmt
name|int
name|Sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all except locals and globals*/
end_comment

begin_decl_stmt
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* preserve relocation bits, don't define common */
end_comment

begin_decl_stmt
name|int
name|arflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original copy of rflag */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* discard all symbols */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pure procedure */
end_comment

begin_decl_stmt
name|int
name|Oflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set magic # to 0405 (overlay) */
end_comment

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define common even with rflag */
end_comment

begin_decl_stmt
name|int
name|iflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/D space separated */
end_comment

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* overlays used */
end_comment

begin_decl_stmt
name|int
name|ofilfnd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ofilename
init|=
literal|"l.out"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|infil
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|filname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cumulative sizes set in pass 1 */
end_comment

begin_decl_stmt
name|int
name|tsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ssize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol relocation; both passes */
end_comment

begin_decl_stmt
name|int
name|ctrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cdrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cbrel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|errlev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delarg
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tfname
index|[]
init|=
literal|"/tmp/ldaXXXXX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output management */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|int
name|fildes
decl_stmt|;
name|int
name|nleft
decl_stmt|;
name|int
modifier|*
name|xnext
decl_stmt|;
name|int
name|iobuf
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|buf
name|toutb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|doutb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|troutb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|droutb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|soutb
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|symbol
modifier|*
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|symbol
modifier|*
modifier|*
name|slookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|symbol
modifier|*
name|lookloc
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|delexit
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
literal|"l.out"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delarg
operator|==
literal|0
condition|)
name|chmod
argument_list|(
name|ofilename
argument_list|,
literal|0777
operator|&
operator|~
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|delarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|vscan
decl_stmt|;
name|char
name|save
decl_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|delexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
comment|/* scan files once to find symdefs */
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'o'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"Bad output file"
argument_list|)
expr_stmt|;
name|ofilename
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|ofilfnd
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"Bad 'use' or 'entry'"
argument_list|)
expr_stmt|;
name|enter
argument_list|(
name|slookup
argument_list|(
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|entrypt
operator|=
name|lastsym
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"-v: arg missing"
argument_list|)
expr_stmt|;
name|vflag
operator|=
name|TRUE
expr_stmt|;
name|vscan
operator|=
name|vindex
expr_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|--
name|vscan
operator|>=
literal|0
operator|&&
name|found
operator|==
name|FALSE
condition|)
name|found
operator|=
name|eq
argument_list|(
name|vnodes
index|[
name|vscan
index|]
operator|.
name|vname
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|endload
argument_list|(
name|c
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|restore
argument_list|(
name|vscan
argument_list|)
expr_stmt|;
block|}
else|else
name|record
argument_list|(
name|c
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
if|if
condition|(
operator|++
name|c
operator|>=
name|argc
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"-D: arg missing"
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsize
operator|>
name|num
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"-D: too small"
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|num
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|save
operator|=
name|ap
index|[
operator|--
name|i
index|]
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load1arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ap
index|[
name|i
index|]
operator|=
name|save
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'X'
case|:
name|Xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|Sflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
name|arflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|sflag
operator|++
expr_stmt|;
name|xflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|iflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'O'
case|:
name|Oflag
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|trace
operator|++
expr_stmt|;
continue|continue;
default|default:
name|error
argument_list|(
literal|2
argument_list|,
literal|"bad flag"
argument_list|)
expr_stmt|;
block|}
comment|/*endsw*/
break|break;
block|}
comment|/*endfor*/
block|}
else|else
name|load1arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|endload
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* used after pass 1 */
end_comment

begin_decl_stmt
name|int
name|nsym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|torigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dorigin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|borigin
decl_stmt|;
end_decl_stmt

begin_macro
name|endload
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|int
name|dnum
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|p
decl_stmt|;
name|filname
operator|=
literal|0
expr_stmt|;
name|middle
argument_list|()
expr_stmt|;
name|setupout
argument_list|()
expr_stmt|;
name|p
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
name|libp
operator|=
name|liblist
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|argc
condition|;
name|c
operator|++
control|)
block|{
name|ap
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|ap
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ap
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'D'
case|:
for|for
control|(
name|dnum
operator|=
name|atoi
argument_list|(
operator|*
name|p
argument_list|)
init|;
name|dorigin
operator|<
name|dnum
condition|;
name|dorigin
operator|+=
literal|2
control|)
block|{
name|putw
argument_list|(
literal|0
argument_list|,
operator|&
name|doutb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|putw
argument_list|(
literal|0
argument_list|,
operator|&
name|droutb
argument_list|)
expr_stmt|;
block|}
case|case
literal|'u'
case|:
case|case
literal|'e'
case|:
case|case
literal|'o'
case|:
case|case
literal|'v'
case|:
operator|++
name|c
expr_stmt|;
operator|++
name|p
expr_stmt|;
default|default:
continue|continue;
case|case
literal|'l'
case|:
name|ap
index|[
operator|--
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|load2arg
argument_list|(
operator|&
name|ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*endsw*/
break|break;
block|}
comment|/*endfor*/
block|}
else|else
name|load2arg
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|finishout
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|record
argument_list|(
argument|c
argument_list|,
argument|nam
argument_list|)
end_macro

begin_decl_stmt
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|overlay
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|vnodes
index|[
name|vindex
operator|++
index|]
expr_stmt|;
name|v
operator|->
name|argsav
operator|=
name|c
expr_stmt|;
name|v
operator|->
name|symsav
operator|=
name|symindex
expr_stmt|;
name|v
operator|->
name|libsav
operator|=
name|libp
expr_stmt|;
name|v
operator|->
name|vname
operator|=
name|nam
expr_stmt|;
name|v
operator|->
name|offt
operator|=
name|tsize
expr_stmt|;
name|v
operator|->
name|offd
operator|=
name|dsize
expr_stmt|;
name|v
operator|->
name|offb
operator|=
name|bsize
expr_stmt|;
name|v
operator|->
name|offs
operator|=
name|ssize
expr_stmt|;
name|v
operator|->
name|ctsav
operator|=
name|ctrel
expr_stmt|;
name|v
operator|->
name|cdsav
operator|=
name|cdrel
expr_stmt|;
name|v
operator|->
name|cbsav
operator|=
name|cbrel
expr_stmt|;
block|}
end_block

begin_macro
name|restore
argument_list|(
argument|vscan
argument_list|)
end_macro

begin_decl_stmt
name|int
name|vscan
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|overlay
modifier|*
name|v
decl_stmt|;
specifier|register
name|int
name|saved
decl_stmt|;
name|v
operator|=
operator|&
name|vnodes
index|[
name|vscan
index|]
expr_stmt|;
name|vindex
operator|=
name|vscan
operator|+
literal|1
expr_stmt|;
name|libp
operator|=
name|v
operator|->
name|libsav
expr_stmt|;
name|ctrel
operator|=
name|v
operator|->
name|ctsav
expr_stmt|;
name|cdrel
operator|=
name|v
operator|->
name|cdsav
expr_stmt|;
name|cbrel
operator|=
name|v
operator|->
name|cbsav
expr_stmt|;
name|tsize
operator|=
name|v
operator|->
name|offt
expr_stmt|;
name|dsize
operator|=
name|v
operator|->
name|offd
expr_stmt|;
name|bsize
operator|=
name|v
operator|->
name|offb
expr_stmt|;
name|ssize
operator|=
name|v
operator|->
name|offs
expr_stmt|;
name|saved
operator|=
name|v
operator|->
name|symsav
expr_stmt|;
while|while
condition|(
name|symindex
operator|>
name|saved
condition|)
operator|*
name|symhash
index|[
operator|--
name|symindex
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* scan file to find defined symbols */
end_comment

begin_macro
name|load1arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|nloc
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
switch|switch
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|load1
argument_list|(
literal|0
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
comment|/* regular archive */
case|case
literal|1
case|:
name|nloc
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|step
argument_list|(
name|nloc
argument_list|)
condition|)
name|nloc
operator|+=
operator|(
name|archdr
operator|.
name|asize
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
comment|/* table of contents */
case|case
literal|2
case|:
name|tnum
operator|=
name|archdr
operator|.
name|asize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnum
operator|>=
name|TABSZ
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|"fast load buffer too small"
argument_list|)
expr_stmt|;
block|}
name|lseek
argument_list|(
name|infil
argument_list|,
call|(
name|long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|filhdr
operator|.
name|fmagic
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|infil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tab
argument_list|,
name|tnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tab
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ldrand
argument_list|()
condition|)
empty_stmt|;
name|libp
operator|->
name|loc
operator|=
operator|-
literal|1
expr_stmt|;
name|libp
operator|++
expr_stmt|;
break|break;
comment|/* out of date table of contents */
case|case
literal|3
case|:
name|error
argument_list|(
literal|0
argument_list|,
literal|"out of date (warning)"
argument_list|)
expr_stmt|;
for|for
control|(
name|nloc
operator|=
literal|1
operator|+
operator|(
operator|(
name|archdr
operator|.
name|asize
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
init|;
name|step
argument_list|(
name|nloc
argument_list|)
condition|;
name|nloc
operator|+=
operator|(
name|archdr
operator|.
name|asize
operator|+
sizeof|sizeof
argument_list|(
name|archdr
argument_list|)
operator|+
literal|1
operator|)
operator|>>
literal|1
control|)
empty_stmt|;
break|break;
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|step
argument_list|(
argument|nloc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|nloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|nloc
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
name|libp
operator|->
name|loc
operator|=
operator|-
literal|1
expr_stmt|;
name|libp
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mget
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|load1
argument_list|(
literal|1
argument_list|,
name|nloc
operator|+
operator|(
sizeof|sizeof
name|archdr
operator|)
operator|/
literal|2
argument_list|)
condition|)
block|{
name|libp
operator|->
name|loc
operator|=
name|nloc
expr_stmt|;
name|libp
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|ldrand
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|liblist
modifier|*
name|oldp
init|=
name|libp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|slookup
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|cname
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|sp
operator|=
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|UNDEF
condition|)
continue|continue;
name|step
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|cloc
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oldp
operator|!=
name|libp
operator|)
return|;
block|}
end_block

begin_macro
name|add
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|long
operator|)
operator|(
name|unsigned
operator|)
name|a
operator|+
operator|(
name|unsigned
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0200000
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_block

begin_comment
comment|/* single file or archive member */
end_comment

begin_macro
name|load1
argument_list|(
argument|libflg
argument_list|,
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
name|int
name|savindex
decl_stmt|;
name|int
name|ndef
decl_stmt|,
name|nloc
decl_stmt|,
name|type
decl_stmt|,
name|mtype
decl_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|tsize
expr_stmt|;
name|cdrel
operator|+=
name|dsize
expr_stmt|;
name|cbrel
operator|+=
name|bsize
expr_stmt|;
name|ndef
operator|=
literal|0
expr_stmt|;
name|nloc
operator|=
sizeof|sizeof
name|cursym
expr_stmt|;
name|savindex
operator|=
name|symindex
expr_stmt|;
if|if
condition|(
operator|(
name|filhdr
operator|.
name|relflg
operator|&
name|RELFLG
operator|)
operator|==
literal|1
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|"No relocation bits"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|loc
operator|+=
operator|(
sizeof|sizeof
name|filhdr
operator|)
operator|/
literal|2
operator|+
name|filhdr
operator|.
name|tsize
operator|+
name|filhdr
operator|.
name|dsize
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|ssize
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|mget
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
name|type
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
if|if
condition|(
name|Sflag
condition|)
block|{
name|mtype
operator|=
name|type
operator|&
literal|037
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
literal|1
operator|||
name|mtype
operator|>
literal|4
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|EXTERN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Xflag
operator|==
literal|0
operator|||
name|cursym
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'L'
condition|)
name|nloc
operator|+=
sizeof|sizeof
name|cursym
expr_stmt|;
continue|continue;
block|}
name|symreloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|enter
argument_list|(
name|lookup
argument_list|()
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sp
operator|=
name|lastsym
operator|)
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|UNDEF
condition|)
continue|continue;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
if|if
condition|(
name|cursym
operator|.
name|svalue
operator|>
name|sp
operator|->
name|svalue
condition|)
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|svalue
operator|!=
literal|0
operator|&&
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|TEXT
condition|)
continue|continue;
name|ndef
operator|++
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
block|}
if|if
condition|(
name|libflg
operator|==
literal|0
operator|||
name|ndef
condition|)
block|{
name|tsize
operator|=
name|add
argument_list|(
name|tsize
argument_list|,
name|filhdr
operator|.
name|tsize
argument_list|,
literal|"text overflow"
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|add
argument_list|(
name|dsize
argument_list|,
name|filhdr
operator|.
name|dsize
argument_list|,
literal|"data overflow"
argument_list|)
expr_stmt|;
name|bsize
operator|=
name|add
argument_list|(
name|bsize
argument_list|,
name|filhdr
operator|.
name|bsize
argument_list|,
literal|"bss overflow"
argument_list|)
expr_stmt|;
name|ssize
operator|=
name|add
argument_list|(
name|ssize
argument_list|,
name|nloc
argument_list|,
literal|"symbol table overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * No symbols defined by this library member. 	 * Rip out the hash table entries and reset the symbol table. 	 */
while|while
condition|(
name|symindex
operator|>
name|savindex
condition|)
operator|*
name|symhash
index|[
operator|--
name|symindex
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|middle
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|,
modifier|*
name|symp
decl_stmt|;
specifier|register
name|t
operator|,
name|csize
expr_stmt|;
name|int
name|nund
decl_stmt|,
name|corigin
decl_stmt|;
name|torigin
operator|=
literal|0
expr_stmt|;
name|dorigin
operator|=
literal|0
expr_stmt|;
name|borigin
operator|=
literal|0
expr_stmt|;
name|p_etext
operator|=
operator|*
name|slookup
argument_list|(
literal|"_etext"
argument_list|)
expr_stmt|;
name|p_edata
operator|=
operator|*
name|slookup
argument_list|(
literal|"_edata"
argument_list|)
expr_stmt|;
name|p_end
operator|=
operator|*
name|slookup
argument_list|(
literal|"_end"
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any undefined symbols, save the relocation bits. 	 */
name|symp
operator|=
operator|&
name|symtab
index|[
name|symindex
index|]
expr_stmt|;
if|if
condition|(
name|rflag
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|&&
name|sp
operator|->
name|svalue
operator|==
literal|0
operator|&&
name|sp
operator|!=
name|p_end
operator|&&
name|sp
operator|!=
name|p_edata
operator|&&
name|sp
operator|!=
name|p_etext
condition|)
block|{
name|rflag
operator|++
expr_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|rflag
condition|)
name|nflag
operator|=
name|sflag
operator|=
name|iflag
operator|=
name|Oflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Assign common locations. 	 */
name|csize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dflag
operator|||
name|rflag
operator|==
literal|0
condition|)
block|{
name|ldrsym
argument_list|(
name|p_etext
argument_list|,
name|tsize
argument_list|,
name|EXTERN
operator|+
name|TEXT
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_edata
argument_list|,
name|dsize
argument_list|,
name|EXTERN
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|ldrsym
argument_list|(
name|p_end
argument_list|,
name|bsize
argument_list|,
name|EXTERN
operator|+
name|BSS
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
operator|&&
operator|(
name|t
operator|=
name|sp
operator|->
name|svalue
operator|)
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
operator|(
name|t
operator|+
literal|1
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|csize
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|COMM
expr_stmt|;
name|csize
operator|=
name|add
argument_list|(
name|csize
argument_list|,
name|t
argument_list|,
literal|"bss overflow"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now set symbols to their final value 	 */
if|if
condition|(
name|nflag
operator|||
name|iflag
condition|)
name|tsize
operator|=
operator|(
name|tsize
operator|+
literal|077
operator|)
operator|&
operator|~
literal|077
expr_stmt|;
name|dorigin
operator|=
name|tsize
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|dorigin
operator|=
operator|(
name|tsize
operator|+
literal|017777
operator|)
operator|&
operator|~
literal|017777
expr_stmt|;
if|if
condition|(
name|iflag
condition|)
name|dorigin
operator|=
literal|0
expr_stmt|;
name|corigin
operator|=
name|dorigin
operator|+
name|dsize
expr_stmt|;
name|borigin
operator|=
name|corigin
operator|+
name|csize
expr_stmt|;
name|nund
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symtab
init|;
name|sp
operator|<
name|symp
condition|;
name|sp
operator|++
control|)
switch|switch
condition|(
name|sp
operator|->
name|stype
condition|)
block|{
case|case
name|EXTERN
operator|+
name|UNDEF
case|:
name|errlev
operator||=
literal|01
expr_stmt|;
if|if
condition|(
name|arflag
operator|==
literal|0
operator|&&
name|sp
operator|->
name|svalue
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nund
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Undefined:\n"
argument_list|)
expr_stmt|;
name|nund
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%.8s\n"
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|EXTERN
operator|+
name|ABS
case|:
default|default:
continue|continue;
case|case
name|EXTERN
operator|+
name|TEXT
case|:
name|sp
operator|->
name|svalue
operator|+=
name|torigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|DATA
case|:
name|sp
operator|->
name|svalue
operator|+=
name|dorigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|BSS
case|:
name|sp
operator|->
name|svalue
operator|+=
name|borigin
expr_stmt|;
continue|continue;
case|case
name|EXTERN
operator|+
name|COMM
case|:
name|sp
operator|->
name|stype
operator|=
name|EXTERN
operator|+
name|BSS
expr_stmt|;
name|sp
operator|->
name|svalue
operator|+=
name|corigin
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
name|ssize
operator|=
literal|0
expr_stmt|;
name|bsize
operator|=
name|add
argument_list|(
name|bsize
argument_list|,
name|csize
argument_list|,
literal|"bss overflow"
argument_list|)
expr_stmt|;
name|nsym
operator|=
name|ssize
operator|/
operator|(
sizeof|sizeof
name|cursym
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|ldrsym
argument_list|(
argument|asp
argument_list|,
argument|val
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symbol
modifier|*
name|asp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|asp
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sp
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|UNDEF
operator|||
name|sp
operator|->
name|svalue
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: "
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"Multiply defined"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|stype
operator|=
name|type
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|val
expr_stmt|;
block|}
end_block

begin_macro
name|setupout
argument_list|()
end_macro

begin_block
block|{
name|tcreat
argument_list|(
operator|&
name|toutb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
name|tcreat
argument_list|(
operator|&
name|doutb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflag
operator|==
literal|0
operator|||
name|xflag
operator|==
literal|0
condition|)
name|tcreat
argument_list|(
operator|&
name|soutb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|tcreat
argument_list|(
operator|&
name|troutb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tcreat
argument_list|(
operator|&
name|droutb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|filhdr
operator|.
name|fmagic
operator|=
operator|(
name|Oflag
condition|?
name|OMAGIC
else|:
operator|(
name|iflag
condition|?
name|IMAGIC
else|:
operator|(
name|nflag
condition|?
name|NMAGIC
else|:
name|FMAGIC
operator|)
operator|)
operator|)
expr_stmt|;
name|filhdr
operator|.
name|tsize
operator|=
name|tsize
expr_stmt|;
name|filhdr
operator|.
name|dsize
operator|=
name|dsize
expr_stmt|;
name|filhdr
operator|.
name|bsize
operator|=
name|bsize
expr_stmt|;
name|filhdr
operator|.
name|ssize
operator|=
name|sflag
condition|?
literal|0
else|:
operator|(
name|ssize
operator|+
operator|(
sizeof|sizeof
name|cursym
operator|)
operator|*
name|symindex
operator|)
expr_stmt|;
if|if
condition|(
name|entrypt
condition|)
block|{
if|if
condition|(
name|entrypt
operator|->
name|stype
operator|!=
name|EXTERN
operator|+
name|TEXT
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|"Entry point not in text"
argument_list|)
expr_stmt|;
else|else
name|filhdr
operator|.
name|entry
operator|=
name|entrypt
operator|->
name|svalue
operator||
literal|01
expr_stmt|;
block|}
else|else
name|filhdr
operator|.
name|entry
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|filhdr
operator|.
name|relflg
operator|=
operator|(
name|rflag
operator|==
literal|0
operator|)
expr_stmt|;
name|mput
argument_list|(
operator|&
name|toutb
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
name|filhdr
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|tcreat
argument_list|(
argument|buf
argument_list|,
argument|tempflg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ufd
decl_stmt|;
name|char
modifier|*
name|nam
decl_stmt|;
name|nam
operator|=
operator|(
name|tempflg
condition|?
name|tfname
else|:
name|ofilename
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ufd
operator|=
name|creat
argument_list|(
name|nam
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|tempflg
condition|?
literal|"cannot create temp"
else|:
literal|"cannot create output"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ufd
argument_list|)
expr_stmt|;
name|buf
operator|->
name|fildes
operator|=
name|open
argument_list|(
name|nam
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempflg
condition|)
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
name|buf
operator|->
name|nleft
operator|=
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|iobuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|buf
operator|->
name|xnext
operator|=
name|buf
operator|->
name|iobuf
expr_stmt|;
block|}
end_block

begin_macro
name|load2arg
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|liblist
modifier|*
name|lp
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
if|if
condition|(
name|getfile
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|>=
name|acp
operator|&&
operator|*
operator|--
name|cp
operator|!=
literal|'/'
condition|)
empty_stmt|;
name|mkfsym
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|load2
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* scan archive members referenced */
for|for
control|(
name|lp
operator|=
name|libp
init|;
name|lp
operator|->
name|loc
operator|!=
operator|-
literal|1
condition|;
name|lp
operator|++
control|)
block|{
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|lp
operator|->
name|loc
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
name|mkfsym
argument_list|(
name|archdr
operator|.
name|aname
argument_list|)
expr_stmt|;
name|load2
argument_list|(
name|lp
operator|->
name|loc
operator|+
operator|(
sizeof|sizeof
name|archdr
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
name|libp
operator|=
operator|++
name|lp
expr_stmt|;
block|}
name|close
argument_list|(
name|infil
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|load2
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|symno
decl_stmt|;
name|int
name|type
decl_stmt|,
name|mtype
decl_stmt|;
name|readhdr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|ctrel
operator|=
name|torigin
expr_stmt|;
name|cdrel
operator|+=
name|dorigin
expr_stmt|;
name|cbrel
operator|+=
name|borigin
expr_stmt|;
comment|/* 	 * Reread the symbol table, recording the numbering 	 * of symbols for fixing external references. 	 */
name|lp
operator|=
name|local
expr_stmt|;
name|symno
operator|=
operator|-
literal|1
expr_stmt|;
name|loc
operator|+=
operator|(
sizeof|sizeof
name|filhdr
operator|)
operator|/
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|tsize
operator|+
name|filhdr
operator|.
name|dsize
argument_list|,
name|filhdr
operator|.
name|ssize
argument_list|)
expr_stmt|;
while|while
condition|(
name|text
operator|.
name|size
operator|>
literal|0
condition|)
block|{
name|symno
operator|++
expr_stmt|;
name|mget
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
name|symreloc
argument_list|()
expr_stmt|;
name|type
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
if|if
condition|(
name|Sflag
condition|)
block|{
name|mtype
operator|=
name|type
operator|&
literal|037
expr_stmt|;
if|if
condition|(
name|mtype
operator|==
literal|1
operator|||
name|mtype
operator|>
literal|4
condition|)
continue|continue;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|EXTERN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sflag
operator|&&
operator|!
name|xflag
operator|&&
operator|(
operator|!
name|Xflag
operator|||
name|cursym
operator|.
name|sname
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|)
condition|)
name|mput
argument_list|(
operator|&
name|soutb
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
operator|*
name|lookup
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"internal error: symbol not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursym
operator|.
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
if|if
condition|(
name|lp
operator|>=
operator|&
name|local
index|[
name|NSYMPR
index|]
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"Local symbol overflow"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|locindex
operator|=
name|symno
expr_stmt|;
name|lp
operator|++
operator|->
name|locsymbol
operator|=
name|sp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cursym
operator|.
name|stype
operator|!=
name|sp
operator|->
name|stype
operator|||
name|cursym
operator|.
name|svalue
operator|!=
name|sp
operator|->
name|svalue
condition|)
block|{
name|printf
argument_list|(
literal|"%.8s: "
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|"Multiply defined"
argument_list|)
expr_stmt|;
block|}
block|}
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
name|filhdr
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|half
argument_list|(
name|filhdr
operator|.
name|tsize
operator|+
name|filhdr
operator|.
name|dsize
argument_list|)
argument_list|,
name|filhdr
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|lp
argument_list|,
name|ctrel
argument_list|,
operator|&
name|toutb
argument_list|,
operator|&
name|troutb
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
operator|+
name|half
argument_list|(
name|filhdr
operator|.
name|tsize
argument_list|)
argument_list|,
name|filhdr
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|reloc
argument_list|,
name|loc
operator|+
name|filhdr
operator|.
name|tsize
operator|+
name|half
argument_list|(
name|filhdr
operator|.
name|dsize
argument_list|)
argument_list|,
name|filhdr
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|load2td
argument_list|(
name|lp
argument_list|,
name|cdrel
argument_list|,
operator|&
name|doutb
argument_list|,
operator|&
name|droutb
argument_list|)
expr_stmt|;
name|torigin
operator|+=
name|filhdr
operator|.
name|tsize
expr_stmt|;
name|dorigin
operator|+=
name|filhdr
operator|.
name|dsize
expr_stmt|;
name|borigin
operator|+=
name|filhdr
operator|.
name|bsize
expr_stmt|;
block|}
end_block

begin_macro
name|load2td
argument_list|(
argument|lp
argument_list|,
argument|creloc
argument_list|,
argument|b1
argument_list|,
argument|b2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|local
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
modifier|*
name|b1
decl_stmt|,
modifier|*
name|b2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
operator|,
name|t
expr_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 			 * The pickup code is copied from "get" for speed. 			 */
comment|/* next text or data word */
if|if
condition|(
operator|--
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|text
operator|.
name|size
operator|<
literal|0
condition|)
break|break;
name|text
operator|.
name|size
operator|++
expr_stmt|;
name|t
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|text
operator|.
name|nibuf
operator|<
literal|0
condition|)
block|{
name|text
operator|.
name|nibuf
operator|++
expr_stmt|;
name|text
operator|.
name|size
operator|++
expr_stmt|;
name|t
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
block|}
else|else
name|t
operator|=
operator|*
name|text
operator|.
name|ptr
operator|++
expr_stmt|;
comment|/* next relocation word */
if|if
condition|(
operator|--
name|reloc
operator|.
name|size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|reloc
operator|.
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"Relocation error"
argument_list|)
expr_stmt|;
name|reloc
operator|.
name|size
operator|++
expr_stmt|;
name|r
operator|=
name|get
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|reloc
operator|.
name|nibuf
operator|<
literal|0
condition|)
block|{
name|reloc
operator|.
name|nibuf
operator|++
expr_stmt|;
name|reloc
operator|.
name|size
operator|++
expr_stmt|;
name|r
operator|=
name|get
argument_list|(
operator|&
name|reloc
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
operator|*
name|reloc
operator|.
name|ptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|r
operator|&
literal|016
condition|)
block|{
case|case
name|RTEXT
case|:
name|t
operator|+=
name|ctrel
expr_stmt|;
break|break;
case|case
name|RDATA
case|:
name|t
operator|+=
name|cdrel
expr_stmt|;
break|break;
case|case
name|RBSS
case|:
name|t
operator|+=
name|cbrel
expr_stmt|;
break|break;
case|case
name|REXT
case|:
name|sp
operator|=
name|lookloc
argument_list|(
name|lp
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|EXTERN
operator|+
name|UNDEF
condition|)
block|{
name|r
operator|=
operator|(
name|r
operator|&
literal|01
operator|)
operator|+
operator|(
operator|(
name|nsym
operator|+
operator|(
name|sp
operator|-
name|symtab
operator|)
operator|)
operator|<<
literal|4
operator|)
operator|+
name|REXT
expr_stmt|;
break|break;
block|}
name|t
operator|+=
name|sp
operator|->
name|svalue
expr_stmt|;
name|r
operator|=
operator|(
name|r
operator|&
literal|01
operator|)
operator|+
operator|(
operator|(
name|sp
operator|->
name|stype
operator|-
operator|(
name|EXTERN
operator|+
name|ABS
operator|)
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|&
literal|01
condition|)
name|t
operator|-=
name|creloc
expr_stmt|;
name|putw
argument_list|(
name|t
argument_list|,
name|b1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|putw
argument_list|(
name|r
argument_list|,
name|b2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|finishout
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|n
operator|,
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|nflag
operator|||
name|iflag
condition|)
block|{
name|n
operator|=
name|torigin
expr_stmt|;
while|while
condition|(
name|n
operator|&
literal|077
condition|)
block|{
name|n
operator|+=
literal|2
expr_stmt|;
name|putw
argument_list|(
literal|0
argument_list|,
operator|&
name|toutb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
name|putw
argument_list|(
literal|0
argument_list|,
operator|&
name|troutb
argument_list|)
expr_stmt|;
block|}
block|}
name|copy
argument_list|(
operator|&
name|doutb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rflag
condition|)
block|{
name|copy
argument_list|(
operator|&
name|troutb
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|droutb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|xflag
operator|==
literal|0
condition|)
name|copy
argument_list|(
operator|&
name|soutb
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|symtab
init|;
name|p
operator|<
operator|(
name|int
operator|*
operator|)
operator|&
name|symtab
index|[
name|symindex
index|]
condition|;
control|)
name|putw
argument_list|(
operator|*
name|p
operator|++
argument_list|,
operator|&
name|toutb
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|(
operator|&
name|toutb
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|toutb
operator|.
name|fildes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofilfnd
condition|)
block|{
name|unlink
argument_list|(
literal|"a.out"
argument_list|)
expr_stmt|;
name|link
argument_list|(
literal|"l.out"
argument_list|,
literal|"a.out"
argument_list|)
expr_stmt|;
name|ofilename
operator|=
literal|"a.out"
expr_stmt|;
block|}
name|delarg
operator|=
name|errlev
expr_stmt|;
name|delexit
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|copy
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|f
operator|,
operator|*
name|p
operator|,
name|n
expr_stmt|;
name|flush
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|f
operator|=
name|buf
operator|->
name|fildes
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|doutb
operator|.
name|iobuf
argument_list|,
sizeof|sizeof
argument_list|(
name|doutb
operator|.
name|iobuf
argument_list|)
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|doutb
operator|.
name|iobuf
expr_stmt|;
do|do
name|putw
argument_list|(
operator|*
name|p
operator|++
argument_list|,
operator|&
name|toutb
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mkfsym
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|sflag
operator|||
name|xflag
condition|)
return|return;
name|cp8c
argument_list|(
name|s
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|stype
operator|=
literal|037
expr_stmt|;
name|cursym
operator|.
name|svalue
operator|=
name|torigin
expr_stmt|;
name|mput
argument_list|(
operator|&
name|soutb
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|cursym
argument_list|,
sizeof|sizeof
name|cursym
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mget
argument_list|(
argument|aloc
argument_list|,
argument|an
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|aloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|loc
operator|,
name|n
expr_stmt|;
specifier|register
operator|*
name|p
expr_stmt|;
name|n
operator|=
name|an
expr_stmt|;
name|n
operator|>>=
literal|1
expr_stmt|;
name|loc
operator|=
name|aloc
expr_stmt|;
if|if
condition|(
operator|(
name|text
operator|.
name|nibuf
operator|-=
name|n
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|text
operator|.
name|size
operator|-=
name|n
operator|)
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|text
operator|.
name|ptr
expr_stmt|;
do|do
operator|*
name|loc
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|text
operator|.
name|ptr
operator|=
name|p
expr_stmt|;
return|return;
block|}
else|else
name|text
operator|.
name|size
operator|+=
name|n
expr_stmt|;
block|}
name|text
operator|.
name|nibuf
operator|+=
name|n
expr_stmt|;
do|do
block|{
operator|*
name|loc
operator|++
operator|=
name|get
argument_list|(
operator|&
name|text
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
end_block

begin_macro
name|mput
argument_list|(
argument|buf
argument_list|,
argument|aloc
argument_list|,
argument|an
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|aloc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
operator|*
name|loc
expr_stmt|;
specifier|register
name|n
expr_stmt|;
name|loc
operator|=
name|aloc
expr_stmt|;
name|n
operator|=
name|an
operator|>>
literal|1
expr_stmt|;
do|do
block|{
name|putw
argument_list|(
operator|*
name|loc
operator|++
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
end_block

begin_macro
name|dseek
argument_list|(
argument|asp
argument_list|,
argument|aloc
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|long
name|aloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stream
modifier|*
name|asp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|stream
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|page
modifier|*
name|p
decl_stmt|;
comment|/* register */
name|long
name|b
decl_stmt|,
name|o
decl_stmt|;
name|int
name|n
decl_stmt|;
name|b
operator|=
name|aloc
operator|>>
literal|8
expr_stmt|;
name|o
operator|=
name|aloc
operator|&
literal|0377
expr_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
operator|&&
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|1
index|]
operator|)
operator|->
name|bno
operator|!=
name|b
condition|)
if|if
condition|(
name|p
operator|->
name|nuser
operator|==
literal|0
operator|||
operator|(
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
operator|)
operator|->
name|nuser
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|==
literal|0
operator|&&
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|==
literal|0
condition|)
if|if
condition|(
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|<
name|page
index|[
literal|1
index|]
operator|.
name|bno
condition|)
name|p
operator|=
operator|&
name|page
index|[
literal|0
index|]
expr_stmt|;
name|p
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|lseek
argument_list|(
name|infil
argument_list|,
operator|(
name|aloc
operator|&
operator|~
literal|0377L
operator|)
operator|<<
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|infil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|buff
argument_list|,
literal|512
argument_list|)
operator|>>
literal|1
operator|)
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|nibuf
operator|=
name|n
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|"No pages"
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|bno
operator|=
name|b
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
name|p
expr_stmt|;
name|sp
operator|->
name|ptr
operator|=
name|p
operator|->
name|buff
operator|+
name|o
expr_stmt|;
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
name|sp
operator|->
name|size
operator|=
name|half
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|nibuf
operator|=
name|p
operator|->
name|nibuf
operator|-
name|o
operator|)
operator|<=
literal|0
condition|)
name|sp
operator|->
name|size
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|half
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|077777
operator|)
return|;
block|}
end_block

begin_macro
name|get
argument_list|(
argument|asp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|stream
modifier|*
name|asp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|stream
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
if|if
condition|(
operator|--
name|sp
operator|->
name|nibuf
operator|<
literal|0
condition|)
block|{
name|dseek
argument_list|(
name|sp
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sp
operator|->
name|bno
operator|+
literal|1
argument_list|)
operator|<<
literal|8
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|sp
operator|->
name|nibuf
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|sp
operator|->
name|size
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|premeof
argument_list|)
expr_stmt|;
operator|++
name|fpage
operator|.
name|nuser
expr_stmt|;
operator|--
name|sp
operator|->
name|pno
operator|->
name|nuser
expr_stmt|;
name|sp
operator|->
name|pno
operator|=
operator|(
expr|struct
name|page
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|sp
operator|->
name|ptr
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|getfile
argument_list|(
argument|acp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|acp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|stat
name|x
decl_stmt|;
name|cp
operator|=
name|acp
expr_stmt|;
name|infil
operator|=
operator|-
literal|1
expr_stmt|;
name|archdr
operator|.
name|aname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|filname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|cp
operator|=
literal|"-la"
expr_stmt|;
name|filname
operator|=
literal|"/usr/lib/libxxxxxxxxxxxxxxx"
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|cp
index|[
name|c
operator|+
literal|2
index|]
condition|;
name|c
operator|++
control|)
name|filname
index|[
name|c
operator|+
literal|12
index|]
operator|=
name|cp
index|[
name|c
operator|+
literal|2
index|]
expr_stmt|;
name|filname
index|[
name|c
operator|+
literal|12
index|]
operator|=
literal|'.'
expr_stmt|;
name|filname
index|[
name|c
operator|+
literal|13
index|]
operator|=
literal|'a'
expr_stmt|;
name|filname
index|[
name|c
operator|+
literal|14
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|infil
operator|=
name|open
argument_list|(
name|filname
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|filname
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|infil
operator|==
operator|-
literal|1
operator|&&
operator|(
name|infil
operator|=
name|open
argument_list|(
name|filname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"cannot open"
argument_list|)
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|bno
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|bno
operator|=
operator|-
literal|1
expr_stmt|;
name|page
index|[
literal|0
index|]
operator|.
name|nuser
operator|=
name|page
index|[
literal|1
index|]
operator|.
name|nuser
operator|=
literal|0
expr_stmt|;
name|text
operator|.
name|pno
operator|=
name|reloc
operator|.
name|pno
operator|=
operator|(
expr|struct
name|page
operator|*
operator|)
operator|&
name|fpage
expr_stmt|;
name|fpage
operator|.
name|nuser
operator|=
literal|2
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|premeof
argument_list|)
expr_stmt|;
if|if
condition|(
name|get
argument_list|(
operator|&
name|text
argument_list|)
operator|!=
name|ARCMAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* regualr file */
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
literal|1L
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
comment|/* word addressing */
if|if
condition|(
name|text
operator|.
name|size
operator|<=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* regular archive */
name|mget
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|archdr
argument_list|,
sizeof|sizeof
name|archdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|archdr
operator|.
name|aname
argument_list|,
name|goodnm
argument_list|,
literal|14
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* regular archive */
else|else
block|{
name|fstat
argument_list|(
name|infil
argument_list|,
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|st_mtime
operator|>
name|archdr
operator|.
name|atime
condition|)
block|{
return|return
operator|(
literal|3
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
end_block

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|lookup
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|clash
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|sname
init|;
name|cp
operator|<
operator|&
name|cursym
operator|.
name|sname
index|[
literal|8
index|]
condition|;
control|)
name|i
operator|=
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|&
name|hshtab
index|[
operator|(
name|i
operator|&
literal|077777
operator|)
operator|%
name|NSYM
operator|+
literal|2
index|]
init|;
operator|*
name|hp
operator|!=
literal|0
condition|;
control|)
block|{
name|cp1
operator|=
operator|(
operator|*
name|hp
operator|)
operator|->
name|sname
expr_stmt|;
name|clash
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cursym
operator|.
name|sname
init|;
name|cp
operator|<
operator|&
name|cursym
operator|.
name|sname
index|[
literal|8
index|]
condition|;
control|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
operator|*
name|cp1
operator|++
condition|)
block|{
name|clash
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|clash
condition|)
block|{
if|if
condition|(
operator|++
name|hp
operator|>=
operator|&
name|hshtab
index|[
name|NSYM
operator|+
literal|2
index|]
condition|)
name|hp
operator|=
name|hshtab
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|hp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|symbol
modifier|*
modifier|*
name|slookup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|cp8c
argument_list|(
name|s
argument_list|,
name|cursym
operator|.
name|sname
argument_list|)
expr_stmt|;
name|cursym
operator|.
name|stype
operator|=
name|EXTERN
operator|+
name|UNDEF
expr_stmt|;
name|cursym
operator|.
name|svalue
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|lookup
argument_list|()
operator|)
return|;
block|}
end_function

begin_macro
name|enter
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symbol
modifier|*
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|*
name|hp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symindex
operator|>=
name|NSYM
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"Symbol table overflow"
argument_list|)
expr_stmt|;
name|symhash
index|[
name|symindex
index|]
operator|=
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|lastsym
operator|=
name|sp
operator|=
operator|&
name|symtab
index|[
name|symindex
operator|++
index|]
expr_stmt|;
name|cp8c
argument_list|(
name|cursym
operator|.
name|sname
argument_list|,
name|sp
operator|->
name|sname
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|cursym
operator|.
name|stype
expr_stmt|;
name|sp
operator|->
name|svalue
operator|=
name|cursym
operator|.
name|svalue
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|lastsym
operator|=
operator|*
name|hp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|symreloc
argument_list|()
end_macro

begin_block
block|{
switch|switch
condition|(
name|cursym
operator|.
name|stype
condition|)
block|{
case|case
name|TEXT
case|:
case|case
name|EXTERN
operator|+
name|TEXT
case|:
name|cursym
operator|.
name|svalue
operator|+=
name|ctrel
expr_stmt|;
return|return;
case|case
name|DATA
case|:
case|case
name|EXTERN
operator|+
name|DATA
case|:
name|cursym
operator|.
name|svalue
operator|+=
name|cdrel
expr_stmt|;
return|return;
case|case
name|BSS
case|:
case|case
name|EXTERN
operator|+
name|BSS
case|:
name|cursym
operator|.
name|svalue
operator|+=
name|cbrel
expr_stmt|;
return|return;
case|case
name|EXTERN
operator|+
name|UNDEF
case|:
return|return;
block|}
if|if
condition|(
name|cursym
operator|.
name|stype
operator|&
name|EXTERN
condition|)
name|cursym
operator|.
name|stype
operator|=
name|EXTERN
operator|+
name|ABS
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|n
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|errlev
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ld:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filname
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|filname
argument_list|)
expr_stmt|;
if|if
condition|(
name|archdr
operator|.
name|aname
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"(%.14s)"
argument_list|,
name|archdr
operator|.
name|aname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|delexit
argument_list|()
expr_stmt|;
name|errlev
operator|=
name|n
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|symbol
modifier|*
name|lookloc
parameter_list|(
name|alp
parameter_list|,
name|r
parameter_list|)
name|struct
name|local
modifier|*
name|alp
decl_stmt|;
block|{
specifier|register
name|struct
name|local
modifier|*
name|clp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|sn
expr_stmt|;
name|lp
operator|=
name|alp
expr_stmt|;
name|sn
operator|=
operator|(
name|r
operator|>>
literal|4
operator|)
operator|&
literal|07777
expr_stmt|;
for|for
control|(
name|clp
operator|=
name|local
init|;
name|clp
operator|<
name|lp
condition|;
name|clp
operator|++
control|)
if|if
condition|(
name|clp
operator|->
name|locindex
operator|==
name|sn
condition|)
return|return
operator|(
name|clp
operator|->
name|locsymbol
operator|)
return|;
name|error
argument_list|(
literal|2
argument_list|,
literal|"Local symbol botch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|readhdr
argument_list|(
argument|loc
argument_list|)
end_macro

begin_decl_stmt
name|long
name|loc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|st
operator|,
name|sd
expr_stmt|;
name|dseek
argument_list|(
operator|&
name|text
argument_list|,
name|loc
argument_list|,
sizeof|sizeof
name|filhdr
argument_list|)
expr_stmt|;
name|mget
argument_list|(
operator|(
name|int
operator|*
operator|)
operator|&
name|filhdr
argument_list|,
sizeof|sizeof
name|filhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|filhdr
operator|.
name|fmagic
operator|!=
name|FMAGIC
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"Bad format"
argument_list|)
expr_stmt|;
name|st
operator|=
operator|(
name|filhdr
operator|.
name|tsize
operator|+
literal|01
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
name|filhdr
operator|.
name|tsize
operator|=
name|st
expr_stmt|;
name|cdrel
operator|=
operator|-
name|st
expr_stmt|;
name|sd
operator|=
operator|(
name|filhdr
operator|.
name|dsize
operator|+
literal|01
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
name|cbrel
operator|=
operator|-
operator|(
name|st
operator|+
name|sd
operator|)
expr_stmt|;
name|filhdr
operator|.
name|bsize
operator|=
operator|(
name|filhdr
operator|.
name|bsize
operator|+
literal|01
operator|)
operator|&
operator|~
literal|01
expr_stmt|;
block|}
end_block

begin_macro
name|cp8c
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|te
decl_stmt|;
name|f
operator|=
name|from
expr_stmt|;
name|t
operator|=
name|to
expr_stmt|;
name|te
operator|=
name|t
operator|+
literal|8
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
operator|)
operator|&&
name|t
operator|<
name|te
condition|)
empty_stmt|;
while|while
condition|(
name|t
operator|<
name|te
condition|)
operator|*
name|t
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|eq
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s1
operator|==
operator|*
name|s2
operator|++
condition|)
if|if
condition|(
operator|(
operator|*
name|s1
operator|++
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|putw
argument_list|(
name|w
argument_list|,
name|b
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
operator|(
name|b
operator|->
name|xnext
operator|)
operator|++
operator|=
name|w
expr_stmt|;
if|if
condition|(
operator|--
name|b
operator|->
name|nleft
operator|<=
literal|0
condition|)
name|flush
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|flush
argument_list|(
name|b
argument_list|)
specifier|register
expr|struct
name|buf
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|xnext
operator|-
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|iobuf
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|b
operator|->
name|fildes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
operator|->
name|iobuf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|"output error"
argument_list|)
expr_stmt|;
name|b
operator|->
name|xnext
operator|=
name|b
operator|->
name|iobuf
expr_stmt|;
name|b
operator|->
name|nleft
operator|=
sizeof|sizeof
argument_list|(
name|b
operator|->
name|iobuf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

