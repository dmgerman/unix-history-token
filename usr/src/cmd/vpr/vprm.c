begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|vprmSCCSid
index|[]
init|=
literal|"@(#)vprm.c	1.2\t2/12/81"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dir.h>
end_include

begin_include
include|#
directive|include
file|<stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function_decl
name|char
modifier|*
name|basename
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|_sobuf
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: vprm [ id ... ] [ filename ... ] [ user ... ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Look for something to delete both in Varian and Versatec spool dirs. */
name|delete
argument_list|(
literal|"Varian"
argument_list|,
literal|"/usr/spool/vad"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|delete
argument_list|(
literal|"Versatec"
argument_list|,
literal|"/usr/spool/vpd"
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Look through the argv list for things to delete.  */
end_comment

begin_macro
name|delete
argument_list|(
argument|devname
argument_list|,
argument|spooldir
argument_list|,
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|devname
decl_stmt|,
modifier|*
name|spooldir
decl_stmt|,
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|dir
decl_stmt|;
comment|/* The spool dir. */
name|struct
name|dir
name|dirent
decl_stmt|;
comment|/* An entry read from the spool dir.*/
name|int
name|deletion
init|=
literal|0
decl_stmt|;
comment|/* Flag noting something has been deleted. */
comment|/* Change to the spool directory. */
if|if
condition|(
name|chdir
argument_list|(
name|spooldir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|spooldir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Open it. */
if|if
condition|(
operator|(
name|dir
operator|=
name|fopen
argument_list|(
literal|"."
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|spooldir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s -"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through the args and the spool dir, looking for a spool 	 * command file (has a prefix of 'df'), 	 * and trying to match it with the argument. 	 */
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|rewind
argument_list|(
name|dir
argument_list|)
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|&
name|dirent
argument_list|,
sizeof|sizeof
name|dirent
argument_list|,
literal|1
argument_list|,
name|dir
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dirent
operator|.
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dirent
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|dirent
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|delcheck
argument_list|(
name|dirent
operator|.
name|d_name
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" removing %s"
argument_list|,
name|dirent
operator|.
name|d_name
operator|+
literal|3
argument_list|)
expr_stmt|;
name|deletion
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deletion
condition|)
name|printf
argument_list|(
literal|" nothing to remove\n"
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * delcheck tries to match the given arg against the given command file in  * various ways.  For instance, if dfname = 'dfa12345', then there is a match if  * arg == 'dfa12345', or  * arg == '12345', or  * arg == the name given on the L line of the file (the owner), or  * arg == the basename of a file given on a command line in the file.  * If there is a match, all the U (unlink) commands in the command file  * are executed, and then the command file itself is unlinked.  */
end_comment

begin_function
name|int
name|delcheck
parameter_list|(
name|dfname
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|dfname
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|FILE
modifier|*
name|df
init|=
name|NULL
decl_stmt|;
comment|/* The command file. */
name|int
name|delfile
init|=
literal|0
decl_stmt|;
comment|/* A match was found, so do a deletion. */
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
comment|/* Command line in command file. */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|dfname
argument_list|)
operator|==
literal|0
condition|)
name|delfile
operator|=
literal|1
expr_stmt|;
comment|/* arg == 'dfa12345'. */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|dfname
operator|+
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|delfile
operator|=
literal|1
expr_stmt|;
comment|/* arg == '12345' (skip 'dfa'). */
else|else
block|{
comment|/* No match; look inside on command lines. */
if|if
condition|(
operator|(
name|df
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|!
name|delfile
operator|&&
name|getline
argument_list|(
name|df
argument_list|,
name|line
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Check owner name. */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|line
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|delfile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'P'
case|:
case|case
literal|'T'
case|:
comment|/* Check command line arg. */
if|if
condition|(
name|strcmp
argument_list|(
name|basename
argument_list|(
name|arg
argument_list|)
argument_list|,
name|basename
argument_list|(
name|line
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|delfile
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|delfile
condition|)
block|{
if|if
condition|(
name|df
operator|==
name|NULL
condition|)
comment|/* File not open yet. */
name|df
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Run through the command file, executing Unlink commands. */
name|rewind
argument_list|(
name|df
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|(
name|df
argument_list|,
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'U'
condition|)
name|unlink
argument_list|(
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
comment|/* Now unlink the command file itself. */
block|}
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
return|return
operator|(
name|delfile
operator|)
return|;
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|file
argument_list|,
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|i
operator|<
literal|256
condition|)
name|line
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|line
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * basename gets the final component of the given pathname. E.g. "c" in  * /a/b/c.  */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|lastname
decl_stmt|;
name|lastname
operator|=
name|pathname
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Move to last char in name. */
while|while
condition|(
name|lastname
operator|>=
name|pathname
condition|)
block|{
if|if
condition|(
operator|*
name|lastname
operator|==
literal|'/'
condition|)
return|return
operator|(
name|lastname
operator|+
literal|1
operator|)
return|;
name|lastname
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|pathname
operator|)
return|;
comment|/* No /'s at all. */
block|}
end_function

end_unit

