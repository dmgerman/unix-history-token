begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  daemon.c -- main control routines for spider and phone dpd daemons,  *			and for line printer daemon.  */
end_comment

begin_decl_stmt
name|long
name|snsum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*number of characters written*/
end_comment

begin_include
include|#
directive|include
file|"daemon0.c"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_decl_stmt
name|struct
name|direct
name|dbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|LDIRNAM
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*length of directory name. MRW*/
end_comment

begin_decl_stmt
name|int
name|LCHAR
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*length of file name thru 'df'.*/
end_comment

begin_decl_stmt
name|int
name|LPID
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*length of file name to process-id.*/
end_comment

begin_decl_stmt
name|int
name|retcode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nwait
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fowner
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*RBB*/
end_comment

begin_decl_stmt
name|char
name|baddf
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*name for unsendable df-files.*/
end_comment

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|LPD
end_if

begin_decl_stmt
name|int
name|waittm
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|waittm
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|FILE
modifier|*
name|df
decl_stmt|;
name|dem_setup
argument_list|()
expr_stmt|;
name|LDIRNAM
operator|=
literal|0
expr_stmt|;
comment|/*calculate length of directory name. MRW*/
while|while
condition|(
name|dfname
index|[
name|LDIRNAM
index|]
condition|)
name|LDIRNAM
operator|++
expr_stmt|;
name|LCHAR
operator|=
name|LDIRNAM
operator|+
literal|2
expr_stmt|;
name|LPID
operator|=
name|LDIRNAM
operator|+
literal|3
expr_stmt|;
name|again
label|:
name|snsum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|logerr
argument_list|(
literal|"Lock has disappeared."
argument_list|)
expr_stmt|;
name|dem_dis
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|df
operator|=
name|fopen
argument_list|(
name|dpd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
condition|)
block|{
do|do
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dbuf
argument_list|,
sizeof|sizeof
name|dbuf
argument_list|,
literal|1
argument_list|,
name|df
argument_list|)
operator|<
literal|1
condition|)
block|{
name|dem_dis
argument_list|()
expr_stmt|;
comment|/*disconnect phone line. MRW*/
name|unlink
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dbuf
operator|.
name|d_ino
operator|==
literal|0
operator|||
name|dbuf
operator|.
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'d'
operator|||
name|dbuf
operator|.
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'f'
condition|)
do|;
name|fclose
argument_list|(
name|df
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|dbuf
operator|.
name|d_name
expr_stmt|;
name|p2
operator|=
operator|&
name|dfname
index|[
name|LDIRNAM
index|]
expr_stmt|;
while|while
condition|(
name|p1
operator|<
operator|&
name|dbuf
operator|.
name|d_name
index|[
name|DIRSIZ
index|]
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|trysend
argument_list|()
operator|==
literal|0
condition|)
block|{
name|waittm
operator|=
literal|60
expr_stmt|;
name|nwait
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|#
directive|if
name|PHONE
if|if
condition|(
name|nwait
operator|>
literal|10
condition|)
block|{
comment|/*after 3 hours try fresh daemon. MRW*/
name|unlink
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/lib/dpd"
argument_list|,
literal|"dpd"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/etc/dpd"
argument_list|,
literal|"dpd"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|logerr
argument_list|(
literal|"Can't find dpd."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sleep
argument_list|(
name|waittm
argument_list|)
expr_stmt|;
if|#
directive|if
name|PHONE
operator|||
name|SPIDER
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|waittm
operator|<=
literal|8
operator|*
literal|60
condition|)
name|waittm
operator|*=
literal|2
expr_stmt|;
else|else
name|nwait
operator|++
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * The remaining part is the device interface, to spider, the dataphone,  *    or the line printer.  */
end_comment

begin_define
define|#
directive|define
name|MXLINE
value|128
end_define

begin_define
define|#
directive|define
name|MXMESS
value|500
end_define

begin_decl_stmt
name|char
modifier|*
name|snumb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
name|MXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|message
index|[
name|MXMESS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mesp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mailfname
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|dfb
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ff
init|=
literal|'\014'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*formfeed*/
end_comment

begin_function_decl
name|char
modifier|*
name|copline
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|trysend
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|retcode
operator|!=
literal|0
condition|)
if|if
condition|(
name|retcode
operator|=
name|dem_con
argument_list|()
condition|)
comment|/*connect phone line.*/
return|return
operator|(
name|retcode
operator|)
return|;
name|retcode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
return|return
operator|(
name|retcode
operator|)
return|;
name|xtrysend
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|xtrysend
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|dem_open
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
comment|/*open spider connection.*/
if|if
condition|(
operator|(
name|dfb
operator|=
name|fopen
argument_list|(
name|dfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|LDIRNAM
operator|<
operator|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|baddf
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|baddf
argument_list|,
name|dfname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|baddf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|baddf
index|[
name|LDIRNAM
index|]
operator|=
literal|'b'
expr_stmt|;
name|link
argument_list|(
name|dfname
argument_list|,
name|baddf
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|trouble
argument_list|(
literal|"Can't read %s."
argument_list|,
name|dfname
argument_list|)
expr_stmt|;
block|}
name|getowner
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
comment|/*RBB*/
name|mesp
operator|=
name|message
expr_stmt|;
operator|*
name|mesp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getline
argument_list|()
condition|)
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'S'
case|:
name|get_snumb
argument_list|()
expr_stmt|;
comment|/*get snumb for GCOS.*/
continue|continue;
case|case
literal|'B'
case|:
if|if
condition|(
name|sascii
argument_list|(
literal|0
argument_list|)
condition|)
name|trouble
argument_list|(
literal|"Can't send %s."
argument_list|,
operator|&
name|line
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
if|if
condition|(
name|sascii
argument_list|(
literal|1
argument_list|)
condition|)
name|trouble
argument_list|(
literal|"Can't send %s."
argument_list|,
operator|&
name|line
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'I'
case|:
comment|/*mail back $IDENT card. MRW*/
name|mesp
operator|=
name|copline
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
name|linel
operator|-
literal|1
argument_list|,
name|mesp
argument_list|)
expr_stmt|;
case|case
literal|'L'
case|:
name|lwrite
argument_list|()
expr_stmt|;
comment|/*write a literal line.*/
continue|continue;
case|case
literal|'M'
case|:
continue|continue;
case|case
literal|'N'
case|:
comment|/*mail back file name. MRW*/
name|copline
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
name|linel
operator|-
literal|1
argument_list|,
name|mailfname
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/*additional text to mail back*/
if|if
condition|(
name|mesp
operator|+
name|linel
operator|<=
name|message
operator|+
name|MXMESS
condition|)
name|mesp
operator|=
name|copline
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|,
name|linel
operator|-
literal|1
argument_list|,
name|mesp
argument_list|)
expr_stmt|;
case|case
literal|'U'
case|:
continue|continue;
block|}
comment|/*  * Second pass.  * Unlink files and send mail.  */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|dfb
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|getline
argument_list|()
condition|)
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
default|default:
continue|continue;
case|case
literal|'U'
case|:
name|unlink
argument_list|(
operator|&
name|line
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'M'
case|:
name|sendmail
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|FCLOSE
argument_list|(
name|dfb
argument_list|)
expr_stmt|;
name|dem_close
argument_list|()
expr_stmt|;
comment|/*close connection to spider.*/
name|unlink
argument_list|(
name|dfname
argument_list|)
expr_stmt|;
name|retcode
operator|=
literal|0
expr_stmt|;
name|trouble
argument_list|(
literal|"OK: %-5s %-7s %-8s"
argument_list|,
name|snumb
argument_list|,
name|fowner
argument_list|,
name|dfname
operator|+
name|LDIRNAM
argument_list|)
expr_stmt|;
comment|/*RBB*/
block|}
end_block

begin_define
define|#
directive|define
name|LUBM
value|30
end_define

begin_comment
comment|/*length of mail command line.*/
end_comment

begin_define
define|#
directive|define
name|IARG1
value|5
end_define

begin_comment
comment|/*start of arg to mail command.*/
end_comment

begin_decl_stmt
name|char
name|mail
index|[
name|LUBM
operator|+
literal|1
index|]
init|=
literal|"mail "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|pmail
decl_stmt|;
end_decl_stmt

begin_macro
name|sendmail
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|mail
index|[
name|IARG1
operator|+
name|i
index|]
operator|=
name|line
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|&&
operator|(
operator|++
name|i
operator|<
name|LUBM
operator|-
name|IARG1
operator|)
condition|)
empty_stmt|;
name|mail
index|[
name|IARG1
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pmail
operator|=
name|popen
argument_list|(
name|mail
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|logerr
argument_list|(
literal|"Can't mail: %-5s %-8s"
argument_list|,
name|snumb
argument_list|,
name|dfname
operator|+
name|LDIRNAM
argument_list|)
expr_stmt|;
comment|/*MRW*/
return|return;
block|}
name|maildname
argument_list|()
expr_stmt|;
name|pclose
argument_list|(
name|pmail
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|LPD
operator|==
literal|0
end_if

begin_macro
name|maildname
argument_list|()
end_macro

begin_comment
comment|/*break up dfname into command name, and process-id 			    to send back in the mail. MRW*/
end_comment

begin_block
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|fprintf
argument_list|(
name|pmail
argument_list|,
literal|"Sent %-5s:  file  %s%s"
argument_list|,
name|snumb
argument_list|,
name|mailfname
argument_list|,
name|message
argument_list|)
expr_stmt|;
comment|/* 	c = dfname[LCHAR]; 	switch (c){ 	case 'A': 	case 'a': 		command = "dpr"; 		break;  	case 'G': 	case 'g': 		command = "gcat"; 		break;  	case 'J': 	case 'j': 		command = "ibm"; 		break;  	case 'N': 	case 'n': 		command = "fsend"; 		break;  	case 'T': 	case 't': 		command = "fget"; 		break;  	default: 		command =&dfname[LDIRNAM]; 		break; 	} 	fprintf(pmail, "%s process-id was %s\n", command,&dfname[LPID]); */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|getline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|lp
operator|=
name|line
expr_stmt|;
name|linel
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|dfb
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|linel
operator|<
name|MXLINE
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
do|do
block|{
operator|*
name|lp
operator|++
operator|=
literal|' '
expr_stmt|;
name|linel
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|linel
operator|&
literal|07
operator|)
operator|!=
literal|0
condition|)
do|;
continue|continue;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
name|linel
operator|++
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|copline
parameter_list|(
name|ab
parameter_list|,
name|n
parameter_list|,
name|ml
parameter_list|)
name|char
modifier|*
name|ab
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|ml
index|[
literal|64
index|]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|eb
decl_stmt|;
name|b
operator|=
name|ab
expr_stmt|;
name|eb
operator|=
name|b
operator|+
name|n
expr_stmt|;
name|p
operator|=
name|ml
expr_stmt|;
while|while
condition|(
name|b
operator|<
name|eb
operator|&&
name|p
operator|<
operator|&
name|ml
index|[
literal|63
index|]
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/*RBB*/
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LPD
operator|==
literal|0
end_if

begin_comment
comment|/*  * the following code determines who the file's owner is.  *			/*RBB*/
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|getowner
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|f
operator|=
name|getpwuid
argument_list|(
name|statbuf
operator|.
name|st_uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fowner
operator|=
literal|""
expr_stmt|;
else|else
name|fowner
operator|=
name|f
operator|->
name|pw_name
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

