begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_decl_stmt
name|int
name|proflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strftn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is the current function one which returns a value */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|tmpfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|outfile
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_macro
name|branch
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* output a branch to label n */
comment|/* exception is an ordinary function branching to retlab: then, return */
if|if
condition|(
name|n
operator|==
name|retlab
operator|&&
operator|!
name|strftn
condition|)
block|{
name|printf
argument_list|(
literal|"	jmp	cret\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"	jbr	L%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|lastloc
init|=
name|PROG
decl_stmt|;
end_decl_stmt

begin_macro
name|defalign
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* cause the alignment to become a multiple of n */
name|n
operator|/=
name|SZCHAR
expr_stmt|;
if|if
condition|(
name|lastloc
operator|!=
name|PROG
operator|&&
name|n
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"	.even\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|locctr
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|temp
expr_stmt|;
comment|/* l is PROG, ADATA, DATA, STRNG, ISTRNG, or STAB */
if|if
condition|(
name|l
operator|==
name|lastloc
condition|)
return|return
operator|(
name|l
operator|)
return|;
name|temp
operator|=
name|lastloc
expr_stmt|;
name|lastloc
operator|=
name|l
expr_stmt|;
switch|switch
condition|(
name|l
condition|)
block|{
case|case
name|PROG
case|:
name|outfile
operator|=
name|stdout
expr_stmt|;
name|printf
argument_list|(
literal|"	.text\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA
case|:
case|case
name|ADATA
case|:
name|outfile
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|DATA
operator|&&
name|temp
operator|!=
name|ADATA
condition|)
name|printf
argument_list|(
literal|"	.data\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
case|case
name|ISTRNG
case|:
name|outfile
operator|=
name|tmpfile
expr_stmt|;
break|break;
case|case
name|STAB
case|:
name|cerror
argument_list|(
literal|"locctr: STAB unused"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal location counter"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_block

begin_macro
name|deflab
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* output something to define the current position as label n */
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"L%d:\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|crslab
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_macro
name|getlab
argument_list|()
end_macro

begin_block
block|{
comment|/* return a number usable for a label */
return|return
operator|(
operator|++
name|crslab
operator|)
return|;
block|}
end_block

begin_macro
name|efcode
argument_list|()
end_macro

begin_block
block|{
comment|/* code for the end of a function */
if|if
condition|(
name|strftn
condition|)
block|{
comment|/* copy output (in r0) to caller */
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|stlab
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
name|int
name|size
decl_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
name|deflab
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
name|stlab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"	mov	$L%d,r1\n"
argument_list|,
name|stlab
argument_list|)
expr_stmt|;
name|size
operator|=
name|tsize
argument_list|(
name|DECREF
argument_list|(
name|p
operator|->
name|stype
argument_list|)
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
operator|/
name|SZCHAR
expr_stmt|;
name|count
operator|=
name|size
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|printf
argument_list|(
literal|"	mov	(r0)+,(r1)+\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"	mov	$L%d,r0\n"
argument_list|,
name|stlab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	.bss\nL%d:	.=.+%d.\n	.text\n"
argument_list|,
name|stlab
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* turn off strftn flag, so return sequence will be generated */
name|strftn
operator|=
literal|0
expr_stmt|;
block|}
name|branch
argument_list|(
name|retlab
argument_list|)
expr_stmt|;
name|p2bend
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|bfcode
argument_list|(
argument|a
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* code for the beginning of a function; a is an array of 		indices in stab for the arguments; n is the number */
specifier|register
name|i
expr_stmt|;
specifier|register
name|temp
expr_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|int
name|off
decl_stmt|;
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|curftn
index|]
expr_stmt|;
name|defnam
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|temp
operator|=
name|p
operator|->
name|stype
expr_stmt|;
name|temp
operator|=
name|DECREF
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|strftn
operator|=
operator|(
name|temp
operator|==
name|STRTY
operator|)
operator|||
operator|(
name|temp
operator|==
name|UNIONTY
operator|)
expr_stmt|;
name|retlab
operator|=
name|getlab
argument_list|()
expr_stmt|;
if|if
condition|(
name|proflag
condition|)
block|{
name|int
name|plab
decl_stmt|;
name|plab
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"	mov	$L%d,r0\n"
argument_list|,
name|plab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jsr	pc,mcount\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	.bss\nL%d:	.=.+2\n	.text\n"
argument_list|,
name|plab
argument_list|)
expr_stmt|;
block|}
comment|/* routine prolog */
name|printf
argument_list|(
literal|"	jsr	r5,csv\n"
argument_list|)
expr_stmt|;
comment|/* adjust stack for autos */
name|printf
argument_list|(
literal|"	sub	$.F%d,sp\n"
argument_list|,
name|ftnno
argument_list|)
expr_stmt|;
name|off
operator|=
name|ARGINIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|stab
index|[
name|a
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|REGISTER
condition|)
block|{
name|temp
operator|=
name|p
operator|->
name|offset
expr_stmt|;
comment|/* save register number */
name|p
operator|->
name|sclass
operator|=
name|PARAM
expr_stmt|;
comment|/* forget that it is a register */
name|p
operator|->
name|offset
operator|=
name|NOOFFSET
expr_stmt|;
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	mov	%d.(r5),r%d\n"
argument_list|,
name|p
operator|->
name|offset
operator|/
name|SZCHAR
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|temp
expr_stmt|;
comment|/* remember register number */
name|p
operator|->
name|sclass
operator|=
name|REGISTER
expr_stmt|;
comment|/* remember that it is a register */
block|}
else|else
block|{
if|if
condition|(
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|off
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"bad argument"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|bccode
argument_list|()
end_macro

begin_block
block|{
comment|/* called just before the first executable statment */
comment|/* by now, the automatics and register variables are allocated */
name|SETOFF
argument_list|(
name|autooff
argument_list|,
name|SZINT
argument_list|)
expr_stmt|;
comment|/* set aside store area offset */
name|p2bbeg
argument_list|(
name|autooff
argument_list|,
name|regvar
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ejobcode
argument_list|(
argument|flag
argument_list|)
end_macro

begin_block
block|{
comment|/* called just before final exit */
comment|/* flag is 1 if errors, 0 if none */
block|}
end_block

begin_macro
name|aobeg
argument_list|()
end_macro

begin_block
block|{
comment|/* called before removing automatics from stab */
block|}
end_block

begin_macro
name|aocode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* called when automatic p removed from stab */
block|}
end_block

begin_macro
name|aoend
argument_list|()
end_macro

begin_block
block|{
comment|/* called after removing all automatics from stab */
block|}
end_block

begin_expr_stmt
name|defnam
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* define the current location as the name p->sname */
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|EXTDEF
condition|)
block|{
name|printf
argument_list|(
literal|"	.globl	%s\n"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|STATIC
operator|&&
name|p
operator|->
name|slevel
operator|>
literal|1
condition|)
name|deflab
argument_list|(
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|exname
argument_list|(
name|p
operator|->
name|sname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bycode
argument_list|(
argument|t
argument_list|,
argument|i
argument_list|)
end_macro

begin_block
block|{
comment|/* put byte i+1 in a string */
name|i
operator|&=
literal|07
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
comment|/* end of the string */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stash byte t into string */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"	.byte	"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%o"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|07
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|zecode
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* n integer words of zeros */
name|OFFSZ
name|temp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"	"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n	"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0; "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"0\n"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|n
expr_stmt|;
name|inoff
operator|+=
name|temp
operator|*
name|SZINT
expr_stmt|;
block|}
end_block

begin_macro
name|fldal
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* return the alignment of field of type t */
name|uerror
argument_list|(
literal|"illegal field type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ALINT
operator|)
return|;
block|}
end_block

begin_macro
name|fldty
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* fix up type of field p */
empty_stmt|;
block|}
end_block

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* print location of error  */
comment|/* c is either 'u', 'c', or 'w' */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|ftitle
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|tmpname
init|=
literal|"/tmp/pcXXXXXX"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|dexit
parameter_list|()
function_decl|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'X'
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|proflag
operator|=
literal|1
expr_stmt|;
block|}
name|mktemp
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|dexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|dexit
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|dexit
argument_list|)
expr_stmt|;
name|tmpfile
operator|=
name|fopen
argument_list|(
name|tmpname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|r
operator|=
name|mainp1
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|tmpfile
operator|=
name|freopen
argument_list|(
name|tmpname
argument_list|,
literal|"r"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfile
operator|!=
name|NULL
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|tmpfile
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|cerror
argument_list|(
literal|"Lost temp file"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_macro
name|dexit
argument_list|(
argument|v
argument_list|)
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|genswitch
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
specifier|register
expr|struct
name|sw
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*	p points to an array of structures, each consisting 		of a constant value and a label. 		The first is>=0 if there is a default label; 		its value is the label number 		The entries p[1] to p[n] are the nontrivial cases 		*/
specifier|register
name|i
expr_stmt|;
specifier|register
name|CONSZ
name|j
decl_stmt|,
name|range
decl_stmt|;
specifier|register
name|dlab
operator|,
name|swlab
expr_stmt|;
name|range
operator|=
name|p
index|[
name|n
index|]
operator|.
name|sval
operator|-
name|p
index|[
literal|1
index|]
operator|.
name|sval
expr_stmt|;
if|if
condition|(
name|range
operator|>
literal|0
operator|&&
name|range
operator|<=
literal|3
operator|*
name|n
operator|&&
name|n
operator|>=
literal|4
condition|)
block|{
comment|/* implement a direct switch */
name|dlab
operator|=
name|p
operator|->
name|slab
operator|>=
literal|0
condition|?
name|p
operator|->
name|slab
else|:
name|getlab
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|.
name|sval
condition|)
block|{
name|printf
argument_list|(
literal|"	sub	$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
index|[
literal|1
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".,r0\n"
argument_list|)
expr_stmt|;
block|}
comment|/* note that this is a cl; it thus checks 		   for numbers below range as well as out of range. 		   */
name|printf
argument_list|(
literal|"	cmp	r0,$%ld.\n"
argument_list|,
name|range
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jhi	L%d\n"
argument_list|,
name|dlab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	asl	r0\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jmp	*L%d(r0)\n"
argument_list|,
name|swlab
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
comment|/* output table */
name|locctr
argument_list|(
name|ADATA
argument_list|)
expr_stmt|;
name|defalign
argument_list|(
name|ALPOINT
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|swlab
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|j
operator|=
name|p
index|[
literal|1
index|]
operator|.
name|sval
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|j
control|)
block|{
name|printf
argument_list|(
literal|"	L%d\n"
argument_list|,
operator|(
name|j
operator|==
name|p
index|[
name|i
index|]
operator|.
name|sval
operator|)
condition|?
name|p
index|[
name|i
operator|++
index|]
operator|.
name|slab
else|:
name|dlab
argument_list|)
expr_stmt|;
block|}
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|slab
operator|<
literal|0
condition|)
name|deflab
argument_list|(
name|dlab
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* debugging code */
comment|/* out for the moment 	if( n>= 4 ) werror( "inefficient switch: %d, %d", n, (int) (range/n) ); 	*/
comment|/* simple switch code */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
operator|++
name|i
control|)
block|{
comment|/* already in r0 */
name|printf
argument_list|(
literal|"	cmp	r0,$"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n	jeq	L%d\n"
argument_list|,
name|p
index|[
name|i
index|]
operator|.
name|slab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|slab
operator|>=
literal|0
condition|)
name|branch
argument_list|(
name|p
operator|->
name|slab
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

