begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile2"
end_include

begin_decl_stmt
name|int
name|fltused
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|stoasg
argument_list|(
name|p
argument_list|,
name|o
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* should the assignment op p be stored, 	   given that it lies as the right operand of o 	   (or the left, if o==UNARY MUL) */
return|return
operator|(
name|shltype
argument_list|(
name|p
operator|->
name|left
operator|->
name|op
argument_list|,
name|p
operator|->
name|left
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|deltest
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* should we delay the INCR or DECR operation p */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|INCR
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
operator|&&
name|spsz
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|,
name|p
operator|->
name|right
operator|->
name|lval
argument_list|)
condition|)
block|{
comment|/* STARREG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|op
operator|==
name|NAME
operator|||
name|p
operator|->
name|op
operator|==
name|OREG
operator|||
name|p
operator|->
name|op
operator|==
name|REG
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|mkadrs
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|o
expr_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|su
operator|>=
name|p
operator|->
name|right
operator|->
name|su
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|su
operator|>
literal|0
condition|)
name|SETSTO
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|su
operator|>
literal|0
condition|)
name|SETSTO
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
else|else
name|cerror
argument_list|(
literal|"store finds both sides trivial"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|FLD
operator|&&
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* should be only structure assignment */
name|SETSTO
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|SETSTO
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|su
operator|>
name|p
operator|->
name|right
operator|->
name|su
condition|)
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SETSTO
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INTEMP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|notoff
argument_list|(
argument|t
argument_list|,
argument|r
argument_list|,
argument|off
argument_list|,
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|CONSZ
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* is it legal to make an OREG or NAME entry which has an 	/* offset of off, (from a register of r), if the 	/* resulting thing had type t */
comment|/* return( 1 );  /* NO */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* YES */
block|}
end_block

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)<(y)?(y):(x))
end_define

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)<(y)?(x):(y))
end_define

begin_define
define|#
directive|define
name|ZCHAR
value|01
end_define

begin_define
define|#
directive|define
name|ZLONG
value|02
end_define

begin_define
define|#
directive|define
name|ZFLOAT
value|04
end_define

begin_expr_stmt
name|zum
argument_list|(
name|p
argument_list|,
name|zap
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* zap Sethi-Ullman number for chars, longs, floats */
comment|/* in the case of longs, only STARNM's are zapped */
comment|/* ZCHAR, ZLONG, ZFLOAT are used to select the zapping */
specifier|register
name|su
expr_stmt|;
name|su
operator|=
name|p
operator|->
name|su
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
if|if
condition|(
operator|!
operator|(
name|zap
operator|&
name|ZCHAR
operator|)
condition|)
break|break;
if|if
condition|(
name|su
operator|==
literal|0
condition|)
name|p
operator|->
name|su
operator|=
name|su
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
if|if
condition|(
operator|!
operator|(
name|zap
operator|&
name|ZLONG
operator|)
condition|)
break|break;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|su
operator|==
literal|0
condition|)
name|p
operator|->
name|su
operator|=
name|su
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
operator|!
operator|(
name|zap
operator|&
name|ZFLOAT
operator|)
condition|)
break|break;
if|if
condition|(
name|su
operator|==
literal|0
condition|)
name|p
operator|->
name|su
operator|=
name|su
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|su
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|sucomp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* set the su field in the node to the sethi-ullman 	   number, or local equivalent */
specifier|register
name|o
operator|,
name|ty
operator|,
name|sul
operator|,
name|sur
expr_stmt|;
specifier|register
name|nr
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
operator|=
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
name|nr
operator|=
name|szty
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|p
operator|->
name|su
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|LTYPE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|FLOAT
condition|)
name|p
operator|->
name|su
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ty
operator|==
name|UTYPE
condition|)
block|{
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|UNARY
name|CALL
case|:
case|case
name|UNARY
name|STCALL
case|:
name|p
operator|->
name|su
operator|=
name|fregs
expr_stmt|;
comment|/* all regs needed */
return|return;
case|case
name|UNARY
name|MUL
case|:
if|if
condition|(
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
condition|)
return|return;
default|default:
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|p
operator|->
name|left
operator|->
name|su
argument_list|,
name|nr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If rhs needs n, lhs needs m, regular su computation */
name|sul
operator|=
name|p
operator|->
name|left
operator|->
name|su
expr_stmt|;
name|sur
operator|=
name|p
operator|->
name|right
operator|->
name|su
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|ASSIGN
condition|)
block|{
name|asop
label|:
comment|/* also used for +=, etc., to memory */
if|if
condition|(
name|sul
operator|==
literal|0
condition|)
block|{
comment|/* don't need to worry about the left side */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|sur
argument_list|,
name|nr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* right, left address, op */
if|if
condition|(
name|sur
operator|==
literal|0
condition|)
block|{
comment|/* just get the lhs address into a register, and mov */
comment|/* the `nr' covers the case where value is in reg afterwards */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|sul
argument_list|,
name|nr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* right, left address, op */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|sur
argument_list|,
name|nr
operator|+
name|sul
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
if|if
condition|(
name|o
operator|==
name|CALL
operator|||
name|o
operator|==
name|STCALL
condition|)
block|{
comment|/* in effect, takes all free registers */
name|p
operator|->
name|su
operator|=
name|fregs
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|o
operator|==
name|STASG
condition|)
block|{
comment|/* right, then left */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|max
argument_list|(
name|sul
operator|+
name|nr
argument_list|,
name|sur
argument_list|)
argument_list|,
name|fregs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|logop
argument_list|(
name|o
argument_list|)
condition|)
block|{
comment|/* do the harder side, then the easier side, into registers */
comment|/* left then right, max(sul,sur+nr) */
comment|/* right then left, max(sur,sul+nr) */
comment|/* to hold both sides in regs: nr+nr */
name|nr
operator|=
name|szty
argument_list|(
name|p
operator|->
name|left
operator|->
name|type
argument_list|)
expr_stmt|;
name|sul
operator|=
name|zum
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|ZLONG
operator||
name|ZCHAR
operator||
name|ZFLOAT
argument_list|)
expr_stmt|;
name|sur
operator|=
name|zum
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|ZLONG
operator||
name|ZCHAR
operator||
name|ZFLOAT
argument_list|)
expr_stmt|;
name|p
operator|->
name|su
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|sul
argument_list|,
name|sur
operator|+
name|nr
argument_list|)
argument_list|,
name|max
argument_list|(
name|sur
argument_list|,
name|sul
operator|+
name|nr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
comment|/* computed by doing right, doing left address, doing left, op, and store */
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|INCR
case|:
case|case
name|DECR
case|:
comment|/* do as binary op */
break|break;
case|case
name|ASG
name|DIV
case|:
case|case
name|ASG
name|MOD
case|:
case|case
name|ASG
name|MUL
case|:
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|FLOAT
operator|&&
name|p
operator|->
name|type
operator|!=
name|DOUBLE
condition|)
name|nr
operator|=
name|fregs
expr_stmt|;
goto|goto
name|gencase
goto|;
case|case
name|ASG
name|PLUS
case|:
case|case
name|ASG
name|MINUS
case|:
case|case
name|ASG
name|AND
case|:
comment|/* really bic */
case|case
name|ASG
name|OR
case|:
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
goto|goto
name|asop
goto|;
name|gencase
label|:
default|default:
name|sur
operator|=
name|zum
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|ZCHAR
operator||
name|ZLONG
operator||
name|ZFLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sur
operator|==
literal|0
condition|)
block|{
comment|/* easy case: if addressable, 				do left value, op, store */
if|if
condition|(
name|sul
operator|==
literal|0
condition|)
name|p
operator|->
name|su
operator|=
name|nr
expr_stmt|;
comment|/* harder: left adr, val, op, store */
else|else
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|sul
argument_list|,
name|nr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* do right, left adr, left value, op, store */
if|if
condition|(
name|sul
operator|==
literal|0
condition|)
block|{
comment|/* right, left value, op, store */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|sur
argument_list|,
name|nr
operator|+
name|nr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|sur
argument_list|,
name|max
argument_list|(
name|sul
operator|+
name|nr
argument_list|,
literal|1
operator|+
name|nr
operator|+
name|nr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
case|case
name|QUEST
case|:
case|case
name|COLON
case|:
case|case
name|COMOP
case|:
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|max
argument_list|(
name|sul
argument_list|,
name|sur
argument_list|)
argument_list|,
name|nr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|o
operator|==
name|DIV
operator|||
name|o
operator|==
name|MOD
operator|||
name|o
operator|==
name|MUL
operator|)
operator|&&
name|p
operator|->
name|type
operator|!=
name|FLOAT
operator|&&
name|p
operator|->
name|type
operator|!=
name|DOUBLE
condition|)
name|nr
operator|=
name|fregs
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MUL
operator|||
name|o
operator|==
name|OR
operator|||
name|o
operator|==
name|ER
condition|)
block|{
comment|/* AND is ruined by the hardware */
comment|/* permute: get the harder on the left */
specifier|register
name|rt
operator|,
name|lt
expr_stmt|;
if|if
condition|(
name|istnode
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|||
name|sul
operator|>
name|sur
condition|)
goto|goto
name|noswap
goto|;
comment|/* don't do it! */
comment|/* look for a funny type on the left, one on the right */
name|lt
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
name|rt
operator|=
name|p
operator|->
name|right
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|FLOAT
operator|&&
name|lt
operator|==
name|DOUBLE
condition|)
goto|goto
name|swap
goto|;
if|if
condition|(
operator|(
name|rt
operator|==
name|CHAR
operator|||
name|rt
operator|==
name|UCHAR
operator|)
operator|&&
operator|(
name|lt
operator|==
name|INT
operator|||
name|lt
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|lt
argument_list|)
operator|)
condition|)
goto|goto
name|swap
goto|;
if|if
condition|(
name|lt
operator|==
name|LONG
operator|||
name|lt
operator|==
name|ULONG
condition|)
block|{
if|if
condition|(
name|rt
operator|==
name|LONG
operator|||
name|rt
operator|==
name|ULONG
condition|)
block|{
comment|/* if one is a STARNM, swap */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|sul
operator|==
literal|0
condition|)
goto|goto
name|noswap
goto|;
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|p
operator|->
name|left
operator|->
name|op
operator|!=
name|UNARY
name|MUL
condition|)
goto|goto
name|swap
goto|;
goto|goto
name|noswap
goto|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|sul
operator|==
literal|0
condition|)
goto|goto
name|noswap
goto|;
else|else
goto|goto
name|swap
goto|;
comment|/* put long on right, unless STARNM */
block|}
comment|/* we are finished with the type stuff now; if one is addressable, 			put it on the right */
if|if
condition|(
name|sul
operator|==
literal|0
operator|&&
name|sur
operator|!=
literal|0
condition|)
block|{
name|NODE
modifier|*
name|s
decl_stmt|;
name|int
name|ssu
decl_stmt|;
name|swap
label|:
name|ssu
operator|=
name|sul
expr_stmt|;
name|sul
operator|=
name|sur
expr_stmt|;
name|sur
operator|=
name|ssu
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|s
expr_stmt|;
block|}
block|}
name|noswap
label|:
name|sur
operator|=
name|zum
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|ZCHAR
operator||
name|ZLONG
operator||
name|ZFLOAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sur
operator|==
literal|0
condition|)
block|{
comment|/* get left value into a register, do op */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|nr
argument_list|,
name|sul
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* do harder into a register, then easier */
name|p
operator|->
name|su
operator|=
name|max
argument_list|(
name|nr
operator|+
name|nr
argument_list|,
name|min
argument_list|(
name|max
argument_list|(
name|sul
argument_list|,
name|nr
operator|+
name|sur
argument_list|)
argument_list|,
name|max
argument_list|(
name|sur
argument_list|,
name|nr
operator|+
name|sul
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|radebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|mkrall
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* insure that the use of p gets done with register r; in effect, */
comment|/* simulate offstar */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|->
name|left
operator|->
name|rall
operator|=
name|p
operator|->
name|rall
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|UNARY
name|MUL
condition|)
return|return;
comment|/* no more to do */
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|p
operator|->
name|rall
operator|=
name|r
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
name|p
operator|->
name|rall
operator|=
name|r
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
name|rallo
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rallo
argument_list|(
name|p
argument_list|,
name|down
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* do register allocation */
specifier|register
name|o
operator|,
name|type
operator|,
name|down1
operator|,
name|down2
operator|,
name|ty
expr_stmt|;
if|if
condition|(
name|radebug
condition|)
name|printf
argument_list|(
literal|"rallo( %o, %o )\n"
argument_list|,
name|p
argument_list|,
name|down
argument_list|)
expr_stmt|;
name|down2
operator|=
name|NOPREF
expr_stmt|;
name|p
operator|->
name|rall
operator|=
name|down
expr_stmt|;
name|down1
operator|=
operator|(
name|down
operator|&=
operator|~
name|MUSTDO
operator|)
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
operator|=
name|p
operator|->
name|op
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DOUBLE
operator|||
name|type
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|o
operator|==
name|FORCE
condition|)
name|down1
operator|=
name|FR0
operator||
name|MUSTDO
expr_stmt|;
operator|++
name|fltused
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASSIGN
case|:
name|down1
operator|=
name|NOPREF
expr_stmt|;
name|down2
operator|=
name|down
expr_stmt|;
break|break;
case|case
name|ASG
name|MUL
case|:
case|case
name|ASG
name|DIV
case|:
case|case
name|ASG
name|MOD
case|:
comment|/* keep the addresses out of the hair of (r0,r1) */
if|if
condition|(
name|fregs
operator|==
literal|2
condition|)
block|{
comment|/* lhs in (r0,r1), nothing else matters */
name|down1
operator|=
name|R1
operator||
name|MUSTDO
expr_stmt|;
name|down2
operator|=
name|NOPREF
expr_stmt|;
break|break;
block|}
comment|/* at least 3 regs free */
comment|/* compute lhs in (r0,r1), address of left in r2 */
name|p
operator|->
name|left
operator|->
name|rall
operator|=
name|R1
operator||
name|MUSTDO
expr_stmt|;
name|mkrall
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|R2
operator||
name|MUSTDO
argument_list|)
expr_stmt|;
comment|/* now, deal with right */
if|if
condition|(
name|fregs
operator|==
literal|3
condition|)
name|rallo
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|NOPREF
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* put address of long or value here */
name|p
operator|->
name|right
operator|->
name|rall
operator|=
name|R3
operator||
name|MUSTDO
expr_stmt|;
name|mkrall
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|R3
operator||
name|MUSTDO
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|MUL
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
name|rallo
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|R1
operator||
name|MUSTDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fregs
operator|==
literal|2
condition|)
block|{
name|rallo
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|NOPREF
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* compute addresses, stay away from (r0,r1) */
name|p
operator|->
name|right
operator|->
name|rall
operator|=
operator|(
name|fregs
operator|==
literal|3
operator|)
condition|?
name|R2
operator||
name|MUSTDO
else|:
name|R3
operator||
name|MUSTDO
expr_stmt|;
name|mkrall
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|R2
operator||
name|MUSTDO
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL
case|:
case|case
name|STASG
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|NOT
case|:
case|case
name|ANDAND
case|:
case|case
name|OROR
case|:
name|down1
operator|=
name|NOPREF
expr_stmt|;
break|break;
case|case
name|FORCE
case|:
name|down1
operator|=
name|R0
operator||
name|MUSTDO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|rallo
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|down1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|rallo
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|down2
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|offstar
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* handle indirections */
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|PLUS
operator|||
name|p
operator|->
name|op
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|order
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INAREG
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|setincr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* for the moment, don't bother */
block|}
end_block

begin_expr_stmt
name|niceuty
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|TWORD
name|t
decl_stmt|;
return|return
operator|(
name|p
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
operator|(
name|t
operator|=
name|p
operator|->
name|type
operator|)
operator|!=
name|CHAR
operator|&&
name|t
operator|!=
name|UCHAR
operator|&&
name|t
operator|!=
name|FLOAT
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|left
argument_list|)
operator|!=
name|STARREG
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setbin
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|,
modifier|*
name|l
decl_stmt|;
name|r
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|l
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|su
operator|==
literal|0
condition|)
block|{
comment|/* rhs is addressable */
if|if
condition|(
name|logop
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
name|l
operator|->
name|type
operator|!=
name|FLOAT
operator|&&
name|shumul
argument_list|(
name|l
operator|->
name|left
argument_list|)
operator|!=
name|STARREG
condition|)
name|offstar
argument_list|(
name|l
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
name|order
argument_list|(
name|l
argument_list|,
name|INAREG
operator||
name|INTAREG
operator||
name|INBREG
operator||
name|INTBREG
operator||
name|INTEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|order
argument_list|(
name|l
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* rewrite */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* now, rhs is complicated: must do both sides into registers */
comment|/* do the harder side first */
if|if
condition|(
name|logop
argument_list|(
name|p
operator|->
name|op
argument_list|)
condition|)
block|{
comment|/* relational: do both sides into regs if need be */
if|if
condition|(
name|r
operator|->
name|su
operator|>
name|l
operator|->
name|su
condition|)
block|{
if|if
condition|(
name|niceuty
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|offstar
argument_list|(
name|r
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|order
argument_list|(
name|r
argument_list|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|INTEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|niceuty
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|offstar
argument_list|(
name|l
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|niceuty
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|offstar
argument_list|(
name|r
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|order
argument_list|(
name|l
argument_list|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|INTEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|order
argument_list|(
name|r
argument_list|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|INTEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cerror
argument_list|(
literal|"setbin can't deal with %s"
argument_list|,
name|opst
index|[
name|p
operator|->
name|op
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* ordinary operator */
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|r
argument_list|)
operator|&&
name|r
operator|->
name|su
operator|>
name|l
operator|->
name|su
condition|)
block|{
comment|/* if there is a chance of making it addressable, try it... */
if|if
condition|(
name|niceuty
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|offstar
argument_list|(
name|r
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* hopefully, it is addressable by now */
block|}
name|order
argument_list|(
name|r
argument_list|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|INTEMP
argument_list|)
expr_stmt|;
comment|/* anything goes on rhs */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|istnode
argument_list|(
name|l
argument_list|)
condition|)
block|{
name|order
argument_list|(
name|l
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* rewrite */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_expr_stmt
name|setstr
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure assignment */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|!=
name|REG
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INTAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|NAME
operator|&&
name|p
operator|->
name|op
operator|!=
name|OREG
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|UNARY
name|MUL
condition|)
name|cerror
argument_list|(
literal|"bad setstr"
argument_list|)
expr_stmt|;
name|order
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|INTAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setasg
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* setup for assignment operator */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|su
operator|!=
literal|0
operator|&&
name|p
operator|->
name|right
operator|->
name|op
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
name|offstar
argument_list|(
name|p
operator|->
name|right
operator|->
name|left
argument_list|)
expr_stmt|;
else|else
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|SNAME
operator||
name|SCON
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|!=
name|REG
operator|&&
operator|(
name|p
operator|->
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|type
operator|==
name|DOUBLE
operator|)
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
operator|&&
operator|!
name|tshape
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|STARREG
operator||
name|STARNM
argument_list|)
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|FLD
operator|&&
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* if things are really strange, get rhs into a register */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|!=
name|REG
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|setasop
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* setup for =ops */
specifier|register
name|sul
operator|,
name|sur
expr_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|sul
operator|=
name|p
operator|->
name|left
operator|->
name|su
expr_stmt|;
name|sur
operator|=
name|p
operator|->
name|right
operator|->
name|su
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|op
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
case|case
name|ASG
name|OR
case|:
case|case
name|ASG
name|MINUS
case|:
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|INT
operator|&&
name|p
operator|->
name|type
operator|!=
name|UNSIGNED
operator|&&
operator|!
name|ISPTR
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|type
operator|==
name|CHAR
operator|||
name|p
operator|->
name|right
operator|->
name|type
operator|==
name|UCHAR
condition|)
block|{
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|ASG
name|ER
case|:
if|if
condition|(
name|sul
operator|==
literal|0
operator|||
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|CHAR
operator|||
name|p
operator|->
name|left
operator|->
name|type
operator|==
name|UCHAR
condition|)
goto|goto
name|rew
goto|;
comment|/* rewrite */
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
goto|goto
name|leftadr
goto|;
block|}
if|if
condition|(
name|sur
operator|==
literal|0
condition|)
block|{
name|leftadr
label|:
comment|/* easy case: if addressable, do left value, op, store */
if|if
condition|(
name|sul
operator|==
literal|0
condition|)
goto|goto
name|rew
goto|;
comment|/* rewrite */
comment|/* harder; make aleft address, val, op, and store */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|FLD
operator|&&
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rew
label|:
comment|/* rewrite, accounting for autoincrement and autodecrement */
name|q
operator|=
name|p
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|FLD
condition|)
name|q
operator|=
name|q
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|op
operator|!=
name|UNARY
name|MUL
operator|||
name|shumul
argument_list|(
name|q
operator|->
name|left
argument_list|)
operator|!=
name|STARREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* let reader.c do it */
comment|/* mimic code from reader.c */
name|p2
operator|=
name|tcopy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|reclaim
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|p2
expr_stmt|;
comment|/* now, zap INCR on right, ASG MINUS on left */
if|if
condition|(
name|q
operator|->
name|left
operator|->
name|op
operator|==
name|INCR
condition|)
block|{
name|q
operator|=
name|p2
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|op
operator|==
name|FLD
condition|)
name|q
operator|=
name|q
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|left
operator|->
name|op
operator|!=
name|INCR
condition|)
name|cerror
argument_list|(
literal|"bad incr rewrite"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|left
operator|->
name|op
operator|!=
name|ASG
name|MINUS
condition|)
name|cerror
argument_list|(
literal|" bad -= rewrite"
argument_list|)
expr_stmt|;
name|q
operator|->
name|left
operator|->
name|right
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|q
operator|->
name|left
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|q
operator|->
name|left
operator|=
name|q
operator|->
name|left
operator|->
name|left
expr_stmt|;
comment|/* now, resume reader.c rewriting code */
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rallo
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|rall
argument_list|)
expr_stmt|;
name|order
argument_list|(
name|p2
operator|->
name|left
argument_list|,
name|INTBREG
operator||
name|INTAREG
argument_list|)
expr_stmt|;
name|order
argument_list|(
name|p2
argument_list|,
name|INTBREG
operator||
name|INTAREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* harder case: do right, left address, left value, op, store */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|right
operator|->
name|left
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* sur> 0, since otherwise, done above */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|op
operator|==
name|REG
condition|)
goto|goto
name|leftadr
goto|;
comment|/* make lhs addressable */
name|order
argument_list|(
name|p
operator|->
name|right
argument_list|,
name|INAREG
operator||
name|INBREG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|crslab
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_macro
name|getlab
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|crslab
operator|++
operator|)
return|;
block|}
end_block

begin_macro
name|deflab
argument_list|(
argument|l
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|genargs
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|size
expr_stmt|;
comment|/* generate code for the arguments */
comment|/*  first, do the arguments on the right (last->first) */
while|while
condition|(
name|p
operator|->
name|op
operator|==
name|CM
condition|)
block|{
name|genargs
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STARG
condition|)
block|{
comment|/* structure valued argument */
name|size
operator|=
name|p
operator|->
name|stsize
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|ICON
condition|)
block|{
comment|/* make into a name node */
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|left
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|NAME
expr_stmt|;
block|}
else|else
block|{
comment|/* make it look beautiful... */
name|p
operator|->
name|op
operator|=
name|UNARY
name|MUL
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* turn it into an oreg */
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|OREG
condition|)
block|{
name|offstar
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|!=
name|OREG
condition|)
name|cerror
argument_list|(
literal|"stuck starg"
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|lval
operator|+=
name|size
expr_stmt|;
comment|/* end of structure */
comment|/* put on stack backwards */
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
literal|2
control|)
block|{
name|p
operator|->
name|lval
operator|-=
literal|2
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|RNOP
argument_list|,
literal|"	mov	AR,Z-\n"
argument_list|)
expr_stmt|;
block|}
name|reclaim
argument_list|(
name|p
argument_list|,
name|RNULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ordinary case */
name|order
argument_list|(
name|p
argument_list|,
name|FORARG
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|argsize
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|t
expr_stmt|;
name|t
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|CM
condition|)
block|{
name|t
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|DOUBLE
operator|||
name|p
operator|->
name|type
operator|==
name|FLOAT
condition|)
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|+
literal|8
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|type
operator|==
name|LONG
operator|||
name|p
operator|->
name|type
operator|==
name|ULONG
condition|)
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|+
literal|4
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|op
operator|==
name|STARG
condition|)
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|stalign
argument_list|)
expr_stmt|;
comment|/* alignment */
return|return
operator|(
name|t
operator|+
name|p
operator|->
name|stsize
operator|)
return|;
comment|/* size */
block|}
else|else
block|{
name|SETOFF
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|+
literal|2
operator|)
return|;
block|}
block|}
end_block

end_unit

