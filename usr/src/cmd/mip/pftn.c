begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"mfile1"
end_include

begin_struct
struct|struct
name|instk
block|{
name|int
name|in_sz
decl_stmt|;
comment|/* size of array element */
name|int
name|in_x
decl_stmt|;
comment|/* current index for structure member in structure initializations */
name|int
name|in_n
decl_stmt|;
comment|/* number of initializations seen */
name|int
name|in_s
decl_stmt|;
comment|/* sizoff */
name|int
name|in_d
decl_stmt|;
comment|/* dimoff */
name|TWORD
name|in_t
decl_stmt|;
comment|/* type */
name|int
name|in_id
decl_stmt|;
comment|/* stab index */
name|int
name|in_fl
decl_stmt|;
comment|/* flag which says if this level is controlled by {} */
name|OFFSZ
name|in_off
decl_stmt|;
comment|/* offset of the beginning of this level */
block|}
name|instack
index|[
literal|10
index|]
struct|,
modifier|*
name|pstk
struct|;
end_struct

begin_comment
comment|/* defines used for getting things off of the initialization stack */
end_comment

begin_function_decl
name|struct
name|symtab
modifier|*
name|relook
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ddebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|defid
argument_list|(
argument|q
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|int
name|idp
decl_stmt|;
name|TWORD
name|type
decl_stmt|;
name|TWORD
name|stp
decl_stmt|;
name|int
name|scl
decl_stmt|;
name|int
name|dsym
decl_stmt|,
name|ddef
decl_stmt|;
name|int
name|slev
decl_stmt|,
name|temp
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NIL
condition|)
return|return;
comment|/* an error was detected */
if|if
condition|(
name|q
operator|<
name|node
operator|||
name|q
operator|>=
operator|&
name|node
index|[
name|TREESZ
index|]
condition|)
name|cerror
argument_list|(
literal|"defid call"
argument_list|)
expr_stmt|;
name|idp
operator|=
name|q
operator|->
name|rval
expr_stmt|;
if|if
condition|(
name|idp
operator|<
literal|0
condition|)
name|cerror
argument_list|(
literal|"tyreduce"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|idp
index|]
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
block|{
name|printf
argument_list|(
literal|"defid( %.8s (%d), "
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|idp
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|q
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s, (%d,%d) ), level %d\n"
argument_list|,
name|scnames
argument_list|(
name|class
argument_list|)
argument_list|,
name|q
operator|->
name|cdim
argument_list|,
name|q
operator|->
name|csiz
argument_list|,
name|blevel
argument_list|)
expr_stmt|;
block|}
name|fixtype
argument_list|(
name|q
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|type
operator|=
name|q
operator|->
name|type
expr_stmt|;
name|class
operator|=
name|fixclass
argument_list|(
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|stp
operator|=
name|p
operator|->
name|stype
expr_stmt|;
name|slev
operator|=
name|p
operator|->
name|slevel
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
block|{
name|printf
argument_list|(
literal|"	modified to "
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s\n"
argument_list|,
name|scnames
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	previous def'n: "
argument_list|)
expr_stmt|;
name|tprint
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s, (%d,%d) ), level %d\n"
argument_list|,
name|scnames
argument_list|(
name|p
operator|->
name|sclass
argument_list|)
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|,
name|slev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stp
operator|==
name|UNDEF
operator|||
name|stp
operator|==
name|FARG
condition|)
block|{
if|if
condition|(
name|blevel
operator|==
literal|1
operator|&&
name|stp
operator|!=
name|FARG
condition|)
switch|switch
condition|(
name|class
condition|)
block|{
default|default:
if|if
condition|(
operator|!
operator|(
name|class
operator|&
name|FIELD
operator|)
condition|)
name|uerror
argument_list|(
literal|"declared argument %.8s is missing"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
case|case
name|MOS
case|:
case|case
name|STNAME
case|:
case|case
name|MOU
case|:
case|case
name|UNAME
case|:
case|case
name|MOE
case|:
case|case
name|ENAME
case|:
case|case
name|TYPEDEF
case|:
empty_stmt|;
block|}
goto|goto
name|enter
goto|;
block|}
if|if
condition|(
name|type
operator|!=
name|stp
condition|)
goto|goto
name|mismatch
goto|;
comment|/* test (and possibly adjust) dimensions */
name|dsym
operator|=
name|p
operator|->
name|dimoff
expr_stmt|;
name|ddef
operator|=
name|q
operator|->
name|cdim
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|type
init|;
name|temp
operator|&
name|TMASK
condition|;
name|temp
operator|=
name|DECREF
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|ISARY
argument_list|(
name|temp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dimtab
index|[
name|dsym
index|]
operator|==
literal|0
condition|)
name|dimtab
index|[
name|dsym
index|]
operator|=
name|dimtab
index|[
name|ddef
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|dimtab
index|[
name|ddef
index|]
operator|!=
literal|0
operator|&&
name|dimtab
index|[
name|dsym
index|]
operator|!=
name|dimtab
index|[
name|ddef
index|]
condition|)
block|{
goto|goto
name|mismatch
goto|;
block|}
operator|++
name|dsym
expr_stmt|;
operator|++
name|ddef
expr_stmt|;
block|}
block|}
comment|/* check that redeclarations are to the same structure */
if|if
condition|(
operator|(
name|temp
operator|==
name|STRTY
operator|||
name|temp
operator|==
name|UNIONTY
operator|||
name|temp
operator|==
name|ENUMTY
operator|)
operator|&&
name|p
operator|->
name|sizoff
operator|!=
name|q
operator|->
name|csiz
operator|&&
operator|(
name|type
operator|&
name|TMASK
operator|)
condition|)
block|{
goto|goto
name|mismatch
goto|;
block|}
name|scl
operator|=
operator|(
name|p
operator|->
name|sclass
operator|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
block|{
name|printf
argument_list|(
literal|"	previous class: %s\n"
argument_list|,
name|scnames
argument_list|(
name|scl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|&
name|FIELD
condition|)
block|{
comment|/* redefinition */
if|if
condition|(
operator|!
name|falloc
argument_list|(
name|p
argument_list|,
name|class
operator|&
name|FLDSIZ
argument_list|,
literal|1
argument_list|,
name|NIL
argument_list|)
condition|)
block|{
comment|/* successful allocation */
name|psave
argument_list|(
name|idp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* blew it: resume at end of switch... */
block|}
else|else
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|EXTERN
case|:
switch|switch
condition|(
name|scl
condition|)
block|{
case|case
name|STATIC
case|:
case|case
name|USTATIC
case|:
if|if
condition|(
name|slev
operator|==
literal|0
condition|)
return|return;
break|break;
case|case
name|EXTDEF
case|:
case|case
name|EXTERN
case|:
case|case
name|FORTRAN
case|:
case|case
name|UFORTRAN
case|:
return|return;
block|}
break|break;
case|case
name|STATIC
case|:
if|if
condition|(
name|scl
operator|==
name|USTATIC
operator|||
operator|(
name|scl
operator|==
name|EXTERN
operator|&&
name|blevel
operator|==
literal|0
operator|)
condition|)
block|{
name|p
operator|->
name|sclass
operator|=
name|STATIC
expr_stmt|;
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|curftn
operator|=
name|idp
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|USTATIC
case|:
if|if
condition|(
name|scl
operator|==
name|STATIC
operator|||
name|scl
operator|==
name|USTATIC
condition|)
return|return;
break|break;
case|case
name|LABEL
case|:
if|if
condition|(
name|scl
operator|==
name|ULABEL
condition|)
block|{
name|p
operator|->
name|sclass
operator|=
name|LABEL
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|TYPEDEF
case|:
if|if
condition|(
name|scl
operator|==
name|class
condition|)
return|return;
break|break;
case|case
name|UFORTRAN
case|:
if|if
condition|(
name|scl
operator|==
name|UFORTRAN
operator|||
name|scl
operator|==
name|FORTRAN
condition|)
return|return;
break|break;
case|case
name|FORTRAN
case|:
if|if
condition|(
name|scl
operator|==
name|UFORTRAN
condition|)
block|{
name|p
operator|->
name|sclass
operator|=
name|FORTRAN
expr_stmt|;
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|curftn
operator|=
name|idp
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MOU
case|:
case|case
name|MOS
case|:
if|if
condition|(
name|scl
operator|==
name|class
condition|)
block|{
if|if
condition|(
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|strucoff
argument_list|)
condition|)
break|break;
if|if
condition|(
name|class
operator|==
name|MOU
condition|)
name|strucoff
operator|=
literal|0
expr_stmt|;
name|psave
argument_list|(
name|idp
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|MOE
case|:
if|if
condition|(
name|scl
operator|==
name|class
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|offset
operator|!=
name|strucoff
operator|++
condition|)
break|break;
name|psave
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTDEF
case|:
if|if
condition|(
name|scl
operator|==
name|EXTERN
condition|)
block|{
name|p
operator|->
name|sclass
operator|=
name|EXTDEF
expr_stmt|;
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|curftn
operator|=
name|idp
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|STNAME
case|:
case|case
name|UNAME
case|:
case|case
name|ENAME
case|:
if|if
condition|(
name|scl
operator|!=
name|class
condition|)
break|break;
if|if
condition|(
name|dimtab
index|[
name|p
operator|->
name|sizoff
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* previous entry just a mention */
break|break;
case|case
name|ULABEL
case|:
if|if
condition|(
name|scl
operator|==
name|LABEL
operator|||
name|scl
operator|==
name|ULABEL
condition|)
return|return;
case|case
name|PARAM
case|:
case|case
name|AUTO
case|:
case|case
name|REGISTER
case|:
empty_stmt|;
comment|/* mismatch.. */
block|}
name|mismatch
label|:
if|if
condition|(
name|blevel
operator|>
name|slev
operator|&&
name|class
operator|!=
name|EXTERN
operator|&&
name|class
operator|!=
name|FORTRAN
operator|&&
name|class
operator|!=
name|UFORTRAN
operator|&&
operator|!
operator|(
name|class
operator|==
name|LABEL
operator|&&
name|slev
operator|>=
literal|2
operator|)
condition|)
block|{
name|q
operator|->
name|rval
operator|=
name|idp
operator|=
name|hide
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|idp
index|]
expr_stmt|;
goto|goto
name|enter
goto|;
block|}
name|uerror
argument_list|(
literal|"redeclaration of %.8s"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|EXTDEF
operator|&&
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|curftn
operator|=
name|idp
expr_stmt|;
return|return;
name|enter
label|:
comment|/* make a new entry */
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"	new entry made\n"
argument_list|)
expr_stmt|;
name|p
operator|->
name|stype
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sclass
operator|=
name|class
expr_stmt|;
name|p
operator|->
name|slevel
operator|=
name|blevel
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|NOOFFSET
expr_stmt|;
name|p
operator|->
name|suse
operator|=
name|lineno
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|STNAME
operator|||
name|class
operator|==
name|UNAME
operator|||
name|class
operator|==
name|ENAME
condition|)
block|{
name|p
operator|->
name|sizoff
operator|=
name|curdim
expr_stmt|;
name|dstash
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* size */
name|dstash
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* index to members of str or union */
name|dstash
argument_list|(
name|ALSTRUCT
argument_list|)
expr_stmt|;
comment|/* alignment */
block|}
else|else
block|{
switch|switch
condition|(
name|BTYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|STRTY
case|:
case|case
name|UNIONTY
case|:
case|case
name|ENUMTY
case|:
name|p
operator|->
name|sizoff
operator|=
name|q
operator|->
name|csiz
expr_stmt|;
break|break;
default|default:
name|p
operator|->
name|sizoff
operator|=
name|BTYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* copy dimensions */
name|p
operator|->
name|dimoff
operator|=
name|q
operator|->
name|cdim
expr_stmt|;
comment|/* allocate offsets */
if|if
condition|(
name|class
operator|&
name|FIELD
condition|)
block|{
name|falloc
argument_list|(
name|p
argument_list|,
name|class
operator|&
name|FLDSIZ
argument_list|,
literal|0
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
comment|/* new entry */
name|psave
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|AUTO
case|:
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|autooff
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATIC
case|:
case|case
name|EXTDEF
case|:
name|p
operator|->
name|offset
operator|=
name|getlab
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|curftn
operator|=
name|idp
expr_stmt|;
break|break;
case|case
name|ULABEL
case|:
case|case
name|LABEL
case|:
name|p
operator|->
name|offset
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|p
operator|->
name|slevel
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|LABEL
condition|)
block|{
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTERN
case|:
case|case
name|UFORTRAN
case|:
case|case
name|FORTRAN
case|:
name|p
operator|->
name|offset
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|p
operator|->
name|slevel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MOU
case|:
case|case
name|MOS
case|:
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|strucoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|MOU
condition|)
name|strucoff
operator|=
literal|0
expr_stmt|;
name|psave
argument_list|(
name|idp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOE
case|:
name|p
operator|->
name|offset
operator|=
name|strucoff
operator|++
expr_stmt|;
name|psave
argument_list|(
name|idp
argument_list|)
expr_stmt|;
break|break;
case|case
name|REGISTER
case|:
name|p
operator|->
name|offset
operator|=
name|regvar
operator|--
expr_stmt|;
if|if
condition|(
name|blevel
operator|==
literal|1
condition|)
name|p
operator|->
name|sflags
operator||=
name|SSET
expr_stmt|;
if|if
condition|(
name|regvar
operator|<
name|minrvar
condition|)
name|minrvar
operator|=
name|regvar
expr_stmt|;
break|break;
block|}
comment|/* user-supplied routine to fix up new definitions */
name|FIXDEF
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"	dimoff, sizoff, offset: %d, %d, %d\n"
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|,
name|p
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|psave
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|paramno
operator|>=
name|PARAMSZ
condition|)
block|{
name|cerror
argument_list|(
literal|"parameter stack overflow"
argument_list|)
expr_stmt|;
block|}
name|paramstk
index|[
name|paramno
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
end_block

begin_macro
name|ftnend
argument_list|()
end_macro

begin_block
block|{
comment|/* end of function */
if|if
condition|(
name|retlab
operator|!=
name|NOLAB
condition|)
block|{
comment|/* inside a real function */
name|efcode
argument_list|()
expr_stmt|;
block|}
name|checkst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|retstat
operator|=
literal|0
expr_stmt|;
name|tcheck
argument_list|()
expr_stmt|;
name|curclass
operator|=
name|SNULL
expr_stmt|;
name|brklab
operator|=
name|contlab
operator|=
name|retlab
operator|=
name|NOLAB
expr_stmt|;
name|flostat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nerrors
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|psavbc
operator|!=
operator|&
name|asavbc
index|[
literal|0
index|]
condition|)
name|cerror
argument_list|(
literal|"bcsave error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|paramno
operator|!=
literal|0
condition|)
name|cerror
argument_list|(
literal|"parameter reset error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|swx
operator|!=
literal|0
condition|)
name|cerror
argument_list|(
literal|"switch error"
argument_list|)
expr_stmt|;
block|}
name|psavbc
operator|=
operator|&
name|asavbc
index|[
literal|0
index|]
expr_stmt|;
name|paramno
operator|=
literal|0
expr_stmt|;
name|autooff
operator|=
name|AUTOINIT
expr_stmt|;
name|minrvar
operator|=
name|regvar
operator|=
name|MAXRVAR
expr_stmt|;
name|reached
operator|=
literal|1
expr_stmt|;
name|swx
operator|=
literal|0
expr_stmt|;
name|swp
operator|=
name|swtab
expr_stmt|;
name|locctr
argument_list|(
name|DATA
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dclargs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|argoff
operator|=
name|ARGINIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paramno
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|paramstk
index|[
name|i
index|]
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|p
operator|=
operator|&
name|stab
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|FARG
condition|)
block|{
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|INT
argument_list|,
literal|0
argument_list|,
name|INT
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|j
expr_stmt|;
name|defid
argument_list|(
name|q
argument_list|,
name|PARAM
argument_list|)
expr_stmt|;
block|}
name|oalloc
argument_list|(
name|p
argument_list|,
operator|&
name|argoff
argument_list|)
expr_stmt|;
comment|/* always set aside space, even for register arguments */
block|}
name|cendarg
argument_list|()
expr_stmt|;
name|locctr
argument_list|(
name|PROG
argument_list|)
expr_stmt|;
name|defalign
argument_list|(
name|ALINT
argument_list|)
expr_stmt|;
operator|++
name|ftnno
expr_stmt|;
name|bfcode
argument_list|(
name|paramstk
argument_list|,
name|paramno
argument_list|)
expr_stmt|;
name|paramno
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|rstruct
parameter_list|(
name|idn
parameter_list|,
name|soru
parameter_list|)
block|{
comment|/* reference to a structure or union, with no definition */
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|idn
index|]
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|stype
condition|)
block|{
case|case
name|UNDEF
case|:
name|def
label|:
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|idn
expr_stmt|;
name|q
operator|->
name|type
operator|=
operator|(
name|soru
operator|&
name|INSTRUCT
operator|)
condition|?
name|STRTY
else|:
operator|(
operator|(
name|soru
operator|&
name|INUNION
operator|)
condition|?
name|UNIONTY
else|:
name|ENUMTY
operator|)
expr_stmt|;
name|defid
argument_list|(
name|q
argument_list|,
operator|(
name|soru
operator|&
name|INSTRUCT
operator|)
condition|?
name|STNAME
else|:
operator|(
operator|(
name|soru
operator|&
name|INUNION
operator|)
condition|?
name|UNAME
else|:
name|ENAME
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRTY
case|:
if|if
condition|(
name|soru
operator|&
name|INSTRUCT
condition|)
break|break;
goto|goto
name|def
goto|;
case|case
name|UNIONTY
case|:
if|if
condition|(
name|soru
operator|&
name|INUNION
condition|)
break|break;
goto|goto
name|def
goto|;
case|case
name|ENUMTY
case|:
if|if
condition|(
operator|!
operator|(
name|soru
operator|&
operator|(
name|INUNION
operator||
name|INSTRUCT
operator|)
operator|)
condition|)
break|break;
goto|goto
name|def
goto|;
block|}
name|stwart
operator|=
name|instruct
expr_stmt|;
return|return
operator|(
name|mkty
argument_list|(
name|p
operator|->
name|stype
argument_list|,
literal|0
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|moedef
argument_list|(
argument|idn
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|MOETY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|idn
expr_stmt|;
if|if
condition|(
name|idn
operator|>=
literal|0
condition|)
name|defid
argument_list|(
name|q
argument_list|,
name|MOE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bstruct
argument_list|(
argument|idn
argument_list|,
argument|soru
argument_list|)
end_macro

begin_block
block|{
comment|/* begining of structure or union declaration */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|psave
argument_list|(
name|instruct
argument_list|)
expr_stmt|;
name|psave
argument_list|(
name|curclass
argument_list|)
expr_stmt|;
name|psave
argument_list|(
name|strucoff
argument_list|)
expr_stmt|;
name|strucoff
operator|=
literal|0
expr_stmt|;
name|instruct
operator|=
name|soru
expr_stmt|;
name|q
operator|=
name|block
argument_list|(
name|FREE
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|rval
operator|=
name|idn
expr_stmt|;
if|if
condition|(
name|instruct
operator|==
name|INSTRUCT
condition|)
block|{
name|curclass
operator|=
name|MOS
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|STRTY
expr_stmt|;
if|if
condition|(
name|idn
operator|>=
literal|0
condition|)
name|defid
argument_list|(
name|q
argument_list|,
name|STNAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruct
operator|==
name|INUNION
condition|)
block|{
name|curclass
operator|=
name|MOU
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|UNIONTY
expr_stmt|;
if|if
condition|(
name|idn
operator|>=
literal|0
condition|)
name|defid
argument_list|(
name|q
argument_list|,
name|UNAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* enum */
name|curclass
operator|=
name|MOE
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|ENUMTY
expr_stmt|;
if|if
condition|(
name|idn
operator|>=
literal|0
condition|)
name|defid
argument_list|(
name|q
argument_list|,
name|ENAME
argument_list|)
expr_stmt|;
block|}
name|psave
argument_list|(
name|q
operator|->
name|rval
argument_list|)
expr_stmt|;
return|return
operator|(
name|paramno
operator|-
literal|4
operator|)
return|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|dclstruct
parameter_list|(
name|oparam
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
specifier|register
name|i
operator|,
name|al
operator|,
name|sa
operator|,
name|j
operator|,
name|sz
operator|,
name|szindex
expr_stmt|;
specifier|register
name|TWORD
name|temp
decl_stmt|;
specifier|register
name|high
operator|,
name|low
expr_stmt|;
comment|/* paramstack contains: 		paramstack[ oparam ] = previous instruct 		paramstack[ oparam+1 ] = previous class 		paramstk[ oparam+2 ] = previous strucoff 		paramstk[ oparam+3 ] = structure name  		paramstk[ oparam+4, ... ]  = member stab indices  		*/
if|if
condition|(
operator|(
name|i
operator|=
name|paramstk
index|[
name|oparam
operator|+
literal|3
index|]
operator|)
operator|<
literal|0
condition|)
block|{
name|szindex
operator|=
name|curdim
expr_stmt|;
name|dstash
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* size */
name|dstash
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* index to member names */
name|dstash
argument_list|(
name|ALSTRUCT
argument_list|)
expr_stmt|;
comment|/* alignment */
block|}
else|else
block|{
name|szindex
operator|=
name|stab
index|[
name|i
index|]
operator|.
name|sizoff
expr_stmt|;
block|}
if|if
condition|(
name|ddebug
condition|)
block|{
name|printf
argument_list|(
literal|"dclstruct( %.8s ), szindex = %d\n"
argument_list|,
operator|(
name|i
operator|>=
literal|0
operator|)
condition|?
name|stab
index|[
name|i
index|]
operator|.
name|sname
else|:
literal|"??"
argument_list|,
name|szindex
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
operator|(
name|instruct
operator|&
name|INSTRUCT
operator|)
condition|?
name|STRTY
else|:
operator|(
operator|(
name|instruct
operator|&
name|INUNION
operator|)
condition|?
name|UNIONTY
else|:
name|ENUMTY
operator|)
expr_stmt|;
name|stwart
operator|=
name|instruct
operator|=
name|paramstk
index|[
name|oparam
index|]
expr_stmt|;
name|curclass
operator|=
name|paramstk
index|[
name|oparam
operator|+
literal|1
index|]
expr_stmt|;
name|dimtab
index|[
name|szindex
operator|+
literal|1
index|]
operator|=
name|curdim
expr_stmt|;
name|al
operator|=
name|ALSTRUCT
expr_stmt|;
name|high
operator|=
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|oparam
operator|+
literal|4
init|;
name|i
operator|<
name|paramno
condition|;
operator|++
name|i
control|)
block|{
name|dstash
argument_list|(
name|j
operator|=
name|paramstk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
operator|||
name|j
operator|>=
name|SYMTSZ
condition|)
name|cerror
argument_list|(
literal|"gummy structure member"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|ENUMTY
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|offset
operator|<
name|low
condition|)
name|low
operator|=
name|p
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|offset
operator|>
name|high
condition|)
name|high
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|p
operator|->
name|sizoff
operator|=
name|szindex
expr_stmt|;
continue|continue;
block|}
name|sa
operator|=
name|talign
argument_list|(
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sclass
operator|&
name|FIELD
condition|)
block|{
name|sz
operator|=
name|p
operator|->
name|sclass
operator|&
name|FLDSIZ
expr_stmt|;
block|}
else|else
block|{
name|sz
operator|=
name|tsize
argument_list|(
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"illegal zero sized structure member: %.8s"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|>
name|strucoff
condition|)
name|strucoff
operator|=
name|sz
expr_stmt|;
comment|/* for use with unions */
name|SETOFF
argument_list|(
name|al
argument_list|,
name|sa
argument_list|)
expr_stmt|;
comment|/* set al, the alignment, to the lcm of the alignments of the members */
block|}
name|dstash
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* endmarker */
name|SETOFF
argument_list|(
name|strucoff
argument_list|,
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|ENUMTY
condition|)
block|{
specifier|register
name|TWORD
name|ty
decl_stmt|;
ifdef|#
directive|ifdef
name|ENUMSIZE
name|ty
operator|=
name|ENUMSIZE
argument_list|(
name|high
argument_list|,
name|low
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|char
operator|)
name|high
operator|==
name|high
operator|&&
operator|(
name|char
operator|)
name|low
operator|==
name|low
condition|)
name|ty
operator|=
name|ctype
argument_list|(
name|CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|short
operator|)
name|high
operator|==
name|high
operator|&&
operator|(
name|short
operator|)
name|low
operator|==
name|low
condition|)
name|ty
operator|=
name|ctype
argument_list|(
name|SHORT
argument_list|)
expr_stmt|;
else|else
name|ty
operator|=
name|ctype
argument_list|(
name|INT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strucoff
operator|=
name|tsize
argument_list|(
name|ty
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|ty
argument_list|)
expr_stmt|;
name|dimtab
index|[
name|szindex
operator|+
literal|2
index|]
operator|=
name|al
operator|=
name|talign
argument_list|(
name|ty
argument_list|,
operator|(
name|int
operator|)
name|ty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strucoff
operator|==
literal|0
condition|)
name|uerror
argument_list|(
literal|"zero sized structure"
argument_list|)
expr_stmt|;
name|dimtab
index|[
name|szindex
index|]
operator|=
name|strucoff
expr_stmt|;
name|dimtab
index|[
name|szindex
operator|+
literal|2
index|]
operator|=
name|al
expr_stmt|;
if|if
condition|(
name|ddebug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\tdimtab[%d,%d,%d] = %d,%d,%d\n"
argument_list|,
name|szindex
argument_list|,
name|szindex
operator|+
literal|1
argument_list|,
name|szindex
operator|+
literal|2
argument_list|,
name|dimtab
index|[
name|szindex
index|]
argument_list|,
name|dimtab
index|[
name|szindex
operator|+
literal|1
index|]
argument_list|,
name|dimtab
index|[
name|szindex
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dimtab
index|[
name|szindex
operator|+
literal|1
index|]
init|;
name|dimtab
index|[
name|i
index|]
operator|>=
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|printf
argument_list|(
literal|"\tmember %.8s(%d)\n"
argument_list|,
name|stab
index|[
name|dimtab
index|[
name|i
index|]
index|]
operator|.
name|sname
argument_list|,
name|dimtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|strucoff
operator|=
name|paramstk
index|[
name|oparam
operator|+
literal|2
index|]
expr_stmt|;
name|paramno
operator|=
name|oparam
expr_stmt|;
return|return
operator|(
name|mkty
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
name|szindex
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VARARGS */
end_comment

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* error printing routine in parser */
name|uerror
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|yyaccpt
argument_list|()
end_macro

begin_block
block|{
name|ftnend
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|ftnarg
argument_list|(
argument|idn
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|stab
index|[
name|idn
index|]
operator|.
name|stype
operator|!=
name|UNDEF
condition|)
block|{
name|idn
operator|=
name|hide
argument_list|(
operator|&
name|stab
index|[
name|idn
index|]
argument_list|)
expr_stmt|;
block|}
name|stab
index|[
name|idn
index|]
operator|.
name|stype
operator|=
name|FARG
expr_stmt|;
name|stab
index|[
name|idn
index|]
operator|.
name|sclass
operator|=
name|PARAM
expr_stmt|;
name|psave
argument_list|(
name|idn
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|talign
argument_list|(
name|ty
argument_list|,
name|s
argument_list|)
specifier|register
name|unsigned
name|ty
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|s
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* compute the alignment of an object with type ty, sizeoff index s */
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
operator|&&
name|ty
operator|!=
name|INT
operator|&&
name|ty
operator|!=
name|CHAR
operator|&&
name|ty
operator|!=
name|SHORT
operator|&&
name|ty
operator|!=
name|UNSIGNED
operator|&&
name|ty
operator|!=
name|UCHAR
operator|&&
name|ty
operator|!=
name|USHORT
ifdef|#
directive|ifdef
name|LONGFIELDS
operator|&&
name|ty
operator|!=
name|LONG
operator|&&
name|ty
operator|!=
name|ULONG
endif|#
directive|endif
condition|)
block|{
return|return
operator|(
name|fldal
argument_list|(
name|ty
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|SZINT
operator|-
name|BTSHIFT
operator|-
literal|1
operator|)
condition|;
name|i
operator|+=
name|TSHIFT
control|)
block|{
switch|switch
condition|(
operator|(
name|ty
operator|>>
name|i
operator|)
operator|&
name|TMASK
condition|)
block|{
case|case
name|FTN
case|:
name|cerror
argument_list|(
literal|"compiler takes alignment of function"
argument_list|)
expr_stmt|;
case|case
name|PTR
case|:
return|return
operator|(
name|ALPOINT
operator|)
return|;
case|case
name|ARY
case|:
continue|continue;
case|case
literal|0
case|:
break|break;
block|}
block|}
switch|switch
condition|(
name|BTYPE
argument_list|(
name|ty
argument_list|)
condition|)
block|{
case|case
name|UNIONTY
case|:
case|case
name|ENUMTY
case|:
case|case
name|STRTY
case|:
return|return
operator|(
name|dimtab
index|[
name|s
operator|+
literal|2
index|]
operator|)
return|;
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
name|ALCHAR
operator|)
return|;
case|case
name|FLOAT
case|:
return|return
operator|(
name|ALFLOAT
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
name|ALDOUBLE
operator|)
return|;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
return|return
operator|(
name|ALLONG
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
name|ALSHORT
operator|)
return|;
default|default:
return|return
operator|(
name|ALINT
operator|)
return|;
block|}
block|}
end_block

begin_function
name|OFFSZ
name|tsize
parameter_list|(
name|ty
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|)
name|TWORD
name|ty
decl_stmt|;
block|{
comment|/* compute the size associated with type ty, 	    dimoff d, and sizoff s */
comment|/* BETTER NOT BE CALLED WHEN t, d, and s REFER TO A BIT FIELD... */
name|int
name|i
decl_stmt|;
name|OFFSZ
name|mult
decl_stmt|;
name|mult
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|SZINT
operator|-
name|BTSHIFT
operator|-
literal|1
operator|)
condition|;
name|i
operator|+=
name|TSHIFT
control|)
block|{
switch|switch
condition|(
operator|(
name|ty
operator|>>
name|i
operator|)
operator|&
name|TMASK
condition|)
block|{
case|case
name|FTN
case|:
name|cerror
argument_list|(
literal|"compiler takes size of function"
argument_list|)
expr_stmt|;
case|case
name|PTR
case|:
return|return
operator|(
name|SZPOINT
operator|*
name|mult
operator|)
return|;
case|case
name|ARY
case|:
name|mult
operator|*=
name|dimtab
index|[
name|d
operator|++
index|]
expr_stmt|;
continue|continue;
case|case
literal|0
case|:
break|break;
block|}
block|}
if|if
condition|(
name|dimtab
index|[
name|s
index|]
operator|==
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"unknown size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SZINT
operator|)
return|;
block|}
return|return
operator|(
name|dimtab
index|[
name|s
index|]
operator|*
name|mult
operator|)
return|;
block|}
end_function

begin_macro
name|inforce
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|OFFSZ
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* force inoff to have the value n */
comment|/* inoff is updated to have the value n */
name|OFFSZ
name|wb
decl_stmt|;
specifier|register
name|rest
expr_stmt|;
comment|/* rest is used to do a lot of conversion to ints... */
if|if
condition|(
name|inoff
operator|==
name|n
condition|)
return|return;
if|if
condition|(
name|inoff
operator|>
name|n
condition|)
block|{
name|cerror
argument_list|(
literal|"initialization alignment error"
argument_list|)
expr_stmt|;
block|}
name|wb
operator|=
name|inoff
expr_stmt|;
name|SETOFF
argument_list|(
name|wb
argument_list|,
name|SZINT
argument_list|)
expr_stmt|;
comment|/* wb now has the next higher word boundary */
if|if
condition|(
name|wb
operator|>=
name|n
condition|)
block|{
comment|/* in the same word */
name|rest
operator|=
name|n
operator|-
name|inoff
expr_stmt|;
name|vfdzero
argument_list|(
name|rest
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* otherwise, extend inoff to be word aligned */
name|rest
operator|=
name|wb
operator|-
name|inoff
expr_stmt|;
name|vfdzero
argument_list|(
name|rest
argument_list|)
expr_stmt|;
comment|/* now, skip full words until near to n */
name|rest
operator|=
operator|(
name|n
operator|-
name|inoff
operator|)
operator|/
name|SZINT
expr_stmt|;
name|zecode
argument_list|(
name|rest
argument_list|)
expr_stmt|;
comment|/* now, the remainder of the last word */
name|rest
operator|=
name|n
operator|-
name|inoff
expr_stmt|;
name|vfdzero
argument_list|(
name|rest
argument_list|)
expr_stmt|;
if|if
condition|(
name|inoff
operator|!=
name|n
condition|)
name|cerror
argument_list|(
literal|"inoff error"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vfdalign
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
comment|/* make inoff have the offset the next alignment of n */
name|OFFSZ
name|m
decl_stmt|;
name|m
operator|=
name|inoff
expr_stmt|;
name|SETOFF
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|inforce
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|idebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ibseen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the number of } constructions which have been filled */
end_comment

begin_decl_stmt
name|int
name|iclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* storage class of thing being initialized */
end_comment

begin_decl_stmt
name|int
name|ilocctr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* location counter for current initialization */
end_comment

begin_macro
name|beginit
argument_list|(
argument|curid
argument_list|)
end_macro

begin_block
block|{
comment|/* beginning of initilization; set location ctr and set type */
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|idebug
operator|>=
literal|3
condition|)
name|printf
argument_list|(
literal|"beginit(), curid = %d\n"
argument_list|,
name|curid
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|curid
index|]
expr_stmt|;
name|iclass
operator|=
name|p
operator|->
name|sclass
expr_stmt|;
if|if
condition|(
name|curclass
operator|==
name|EXTERN
operator|||
name|curclass
operator|==
name|FORTRAN
condition|)
name|iclass
operator|=
name|EXTERN
expr_stmt|;
switch|switch
condition|(
name|iclass
condition|)
block|{
case|case
name|UNAME
case|:
case|case
name|EXTERN
case|:
return|return;
case|case
name|AUTO
case|:
case|case
name|REGISTER
case|:
break|break;
case|case
name|EXTDEF
case|:
case|case
name|STATIC
case|:
name|ilocctr
operator|=
name|ISARY
argument_list|(
name|p
operator|->
name|stype
argument_list|)
condition|?
name|ADATA
else|:
name|DATA
expr_stmt|;
name|locctr
argument_list|(
name|ilocctr
argument_list|)
expr_stmt|;
name|defalign
argument_list|(
name|talign
argument_list|(
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
argument_list|)
expr_stmt|;
name|defnam
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|inoff
operator|=
literal|0
expr_stmt|;
name|ibseen
operator|=
literal|0
expr_stmt|;
name|pstk
operator|=
literal|0
expr_stmt|;
name|instk
argument_list|(
name|curid
argument_list|,
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|,
name|inoff
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|instk
argument_list|(
argument|id
argument_list|,
argument|t
argument_list|,
argument|d
argument_list|,
argument|s
argument_list|,
argument|off
argument_list|)
end_macro

begin_decl_stmt
name|OFFSZ
name|off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* make a new entry on the parameter stack to initialize id */
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|idebug
condition|)
name|printf
argument_list|(
literal|"instk((%d, %o,%d,%d, %d)\n"
argument_list|,
name|id
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* save information on the stack */
if|if
condition|(
operator|!
name|pstk
condition|)
name|pstk
operator|=
name|instack
expr_stmt|;
else|else
operator|++
name|pstk
expr_stmt|;
name|pstk
operator|->
name|in_fl
operator|=
literal|0
expr_stmt|;
comment|/* { flag */
name|pstk
operator|->
name|in_id
operator|=
name|id
expr_stmt|;
name|pstk
operator|->
name|in_t
operator|=
name|t
expr_stmt|;
name|pstk
operator|->
name|in_d
operator|=
name|d
expr_stmt|;
name|pstk
operator|->
name|in_s
operator|=
name|s
expr_stmt|;
name|pstk
operator|->
name|in_n
operator|=
literal|0
expr_stmt|;
comment|/* number seen */
name|pstk
operator|->
name|in_x
operator|=
name|t
operator|==
name|STRTY
condition|?
name|dimtab
index|[
name|s
operator|+
literal|1
index|]
else|:
literal|0
expr_stmt|;
name|pstk
operator|->
name|in_off
operator|=
name|off
expr_stmt|;
comment|/* offset at the beginning of this element */
comment|/* if t is an array, DECREF(t) can't be a field */
comment|/* INS_sz has size of array elements, and -size for fields */
if|if
condition|(
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|pstk
operator|->
name|in_sz
operator|=
name|tsize
argument_list|(
name|DECREF
argument_list|(
name|t
argument_list|)
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stab
index|[
name|id
index|]
operator|.
name|sclass
operator|&
name|FIELD
condition|)
block|{
name|pstk
operator|->
name|in_sz
operator|=
operator|-
operator|(
name|stab
index|[
name|id
index|]
operator|.
name|sclass
operator|&
name|FLDSIZ
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pstk
operator|->
name|in_sz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|iclass
operator|==
name|AUTO
operator|||
name|iclass
operator|==
name|REGISTER
operator|)
operator|&&
operator|(
name|ISARY
argument_list|(
name|t
argument_list|)
operator|||
name|t
operator|==
name|STRTY
operator|)
condition|)
name|uerror
argument_list|(
literal|"no automatic aggregate initialization"
argument_list|)
expr_stmt|;
comment|/* now, if this is not a scalar, put on another element */
if|if
condition|(
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|++
name|d
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|STRTY
condition|)
block|{
name|id
operator|=
name|dimtab
index|[
name|pstk
operator|->
name|in_x
index|]
expr_stmt|;
name|p
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sclass
operator|!=
name|MOS
operator|&&
operator|!
operator|(
name|p
operator|->
name|sclass
operator|&
name|FIELD
operator|)
condition|)
name|cerror
argument_list|(
literal|"insane structure member list"
argument_list|)
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|stype
expr_stmt|;
name|d
operator|=
name|p
operator|->
name|dimoff
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|sizoff
expr_stmt|;
name|off
operator|+=
name|p
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
else|else
return|return;
block|}
block|}
end_block

begin_function
name|NODE
modifier|*
name|getstr
parameter_list|()
block|{
comment|/* decide if the string is external or an initializer, and get the contents accordingly */
specifier|register
name|l
operator|,
name|temp
expr_stmt|;
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|iclass
operator|==
name|EXTDEF
operator|||
name|iclass
operator|==
name|STATIC
operator|)
operator|&&
operator|(
name|pstk
operator|->
name|in_t
operator|==
name|CHAR
operator|||
name|pstk
operator|->
name|in_t
operator|==
name|UCHAR
operator|)
operator|&&
name|pstk
operator|!=
name|instack
operator|&&
name|ISARY
argument_list|(
name|pstk
index|[
operator|-
literal|1
index|]
operator|.
name|in_t
argument_list|)
condition|)
block|{
comment|/* treat "abc" as { 'a', 'b', 'c', 0 } */
name|strflg
operator|=
literal|1
expr_stmt|;
name|ilbrace
argument_list|()
expr_stmt|;
comment|/* simulate { */
name|inforce
argument_list|(
name|pstk
operator|->
name|in_off
argument_list|)
expr_stmt|;
comment|/* if the array is inflexible (not top level), pass in the size and 			be prepared to throw away unwanted initializers */
name|lxstr
argument_list|(
operator|(
name|pstk
operator|-
literal|1
operator|)
operator|!=
name|instack
condition|?
name|dimtab
index|[
operator|(
name|pstk
operator|-
literal|1
operator|)
operator|->
name|in_d
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* get the contents */
name|irbrace
argument_list|()
expr_stmt|;
comment|/* simulate } */
return|return
operator|(
name|NIL
operator|)
return|;
block|}
else|else
block|{
comment|/* make a label, and get the contents and stash them away */
if|if
condition|(
name|iclass
operator|!=
name|SNULL
condition|)
block|{
comment|/* initializing */
comment|/* fill out previous word, to permit pointer */
name|vfdalign
argument_list|(
name|ALPOINT
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|locctr
argument_list|(
name|blevel
operator|==
literal|0
condition|?
name|ISTRNG
else|:
name|STRNG
argument_list|)
expr_stmt|;
comment|/* set up location counter */
name|deflab
argument_list|(
name|l
operator|=
name|getlab
argument_list|()
argument_list|)
expr_stmt|;
name|strflg
operator|=
literal|0
expr_stmt|;
name|lxstr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* get the contents */
name|locctr
argument_list|(
name|blevel
operator|==
literal|0
condition|?
name|ilocctr
else|:
name|temp
argument_list|)
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
name|STRING
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|p
operator|->
name|rval
operator|=
operator|-
name|l
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|putbyte
argument_list|(
argument|v
argument_list|)
end_macro

begin_block
block|{
comment|/* simulate byte v appearing in a list of integer values */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|bcon
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|incode
argument_list|(
name|p
argument_list|,
name|SZCHAR
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|gotscal
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|endinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|TWORD
name|t
decl_stmt|;
specifier|register
name|d
operator|,
name|s
operator|,
name|n
operator|,
name|d1
expr_stmt|;
if|if
condition|(
name|idebug
condition|)
name|printf
argument_list|(
literal|"endinit(), inoff = %d\n"
argument_list|,
name|inoff
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iclass
condition|)
block|{
case|case
name|EXTERN
case|:
case|case
name|AUTO
case|:
case|case
name|REGISTER
case|:
return|return;
block|}
name|pstk
operator|=
name|instack
expr_stmt|;
name|t
operator|=
name|pstk
operator|->
name|in_t
expr_stmt|;
name|d
operator|=
name|pstk
operator|->
name|in_d
expr_stmt|;
name|s
operator|=
name|pstk
operator|->
name|in_s
expr_stmt|;
name|n
operator|=
name|pstk
operator|->
name|in_n
expr_stmt|;
if|if
condition|(
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|d1
operator|=
name|dimtab
index|[
name|d
index|]
expr_stmt|;
name|vfdalign
argument_list|(
name|pstk
operator|->
name|in_sz
argument_list|)
expr_stmt|;
comment|/* fill out part of the last element, if needed */
name|n
operator|=
name|inoff
operator|/
name|pstk
operator|->
name|in_sz
expr_stmt|;
comment|/* real number of initializers */
if|if
condition|(
name|d1
operator|>=
name|n
condition|)
block|{
comment|/* once again, t is an array, so no fields */
name|inforce
argument_list|(
name|tsize
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|d1
expr_stmt|;
block|}
if|if
condition|(
name|d1
operator|!=
literal|0
operator|&&
name|d1
operator|!=
name|n
condition|)
name|uerror
argument_list|(
literal|"too many initializers"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|werror
argument_list|(
literal|"empty array declaration"
argument_list|)
expr_stmt|;
name|dimtab
index|[
name|d
index|]
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|STRTY
operator|||
name|t
operator|==
name|UNIONTY
condition|)
block|{
comment|/* clearly not fields either */
name|inforce
argument_list|(
name|tsize
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|uerror
argument_list|(
literal|"bad scalar initialization"
argument_list|)
expr_stmt|;
comment|/* this will never be called with a field element... */
else|else
name|inforce
argument_list|(
name|tsize
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|paramno
operator|=
literal|0
expr_stmt|;
name|vfdalign
argument_list|(
name|AL_INIT
argument_list|)
expr_stmt|;
name|inoff
operator|=
literal|0
expr_stmt|;
name|iclass
operator|=
name|SNULL
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|doinit
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* take care of generating a value for the initializer p */
comment|/* inoff has the current offset (last bit written) 		in the current word being generated */
specifier|register
name|sz
operator|,
name|d
operator|,
name|s
expr_stmt|;
specifier|register
name|TWORD
name|t
decl_stmt|;
comment|/* note: size of an individual initializer is assumed to fit into an int */
if|if
condition|(
name|iclass
operator|<
literal|0
condition|)
goto|goto
name|leave
goto|;
if|if
condition|(
name|iclass
operator|==
name|EXTERN
operator|||
name|iclass
operator|==
name|UNAME
condition|)
block|{
name|uerror
argument_list|(
literal|"cannot initialize extern or union"
argument_list|)
expr_stmt|;
name|iclass
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
if|if
condition|(
name|iclass
operator|==
name|AUTO
operator|||
name|iclass
operator|==
name|REGISTER
condition|)
block|{
comment|/* do the initialization and get out, without regard  		    for filing out the variable with zeros, etc. */
name|bccode
argument_list|()
expr_stmt|;
name|idname
operator|=
name|pstk
operator|->
name|in_id
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
name|ASSIGN
argument_list|,
name|buildtree
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ecomp
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
return|return;
comment|/* for throwing away strings that have been turned into lists */
if|if
condition|(
name|ibseen
condition|)
block|{
name|uerror
argument_list|(
literal|"} expected"
argument_list|)
expr_stmt|;
goto|goto
name|leave
goto|;
block|}
if|if
condition|(
name|idebug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"doinit(%o)\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t
operator|=
name|pstk
operator|->
name|in_t
expr_stmt|;
comment|/* type required */
name|d
operator|=
name|pstk
operator|->
name|in_d
expr_stmt|;
name|s
operator|=
name|pstk
operator|->
name|in_s
expr_stmt|;
if|if
condition|(
name|pstk
operator|->
name|in_sz
operator|<
literal|0
condition|)
block|{
comment|/* bit field */
name|sz
operator|=
operator|-
name|pstk
operator|->
name|in_sz
expr_stmt|;
block|}
else|else
block|{
name|sz
operator|=
name|tsize
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|inforce
argument_list|(
name|pstk
operator|->
name|in_off
argument_list|)
expr_stmt|;
name|p
operator|=
name|buildtree
argument_list|(
name|ASSIGN
argument_list|,
name|block
argument_list|(
name|NAME
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
name|t
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|left
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|NIL
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|optim
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|UNARY
name|AND
condition|)
block|{
name|p
operator|->
name|left
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|left
operator|->
name|left
expr_stmt|;
block|}
name|p
operator|->
name|op
operator|=
name|INIT
expr_stmt|;
if|if
condition|(
name|sz
operator|<
name|SZINT
condition|)
block|{
comment|/* special case: bit fields, etc. */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|!=
name|ICON
condition|)
name|uerror
argument_list|(
literal|"illegal initialization"
argument_list|)
expr_stmt|;
else|else
name|incode
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|op
operator|==
name|FCON
condition|)
block|{
name|fincode
argument_list|(
name|p
operator|->
name|left
operator|->
name|dval
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cinit
argument_list|(
name|optim
argument_list|(
name|p
argument_list|)
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
name|gotscal
argument_list|()
expr_stmt|;
name|leave
label|:
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gotscal
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|t
operator|,
name|ix
expr_stmt|;
specifier|register
name|n
operator|,
name|id
expr_stmt|;
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
name|OFFSZ
name|temp
decl_stmt|;
for|for
control|(
init|;
name|pstk
operator|>
name|instack
condition|;
control|)
block|{
if|if
condition|(
name|pstk
operator|->
name|in_fl
condition|)
operator|++
name|ibseen
expr_stmt|;
operator|--
name|pstk
expr_stmt|;
name|t
operator|=
name|pstk
operator|->
name|in_t
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|STRTY
condition|)
block|{
name|ix
operator|=
operator|++
name|pstk
operator|->
name|in_x
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|dimtab
index|[
name|ix
index|]
operator|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* otherwise, put next element on the stack */
name|p
operator|=
operator|&
name|stab
index|[
name|id
index|]
expr_stmt|;
name|instk
argument_list|(
name|id
argument_list|,
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|,
name|p
operator|->
name|offset
operator|+
name|pstk
operator|->
name|in_off
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|n
operator|=
operator|++
name|pstk
operator|->
name|in_n
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|dimtab
index|[
name|pstk
operator|->
name|in_d
index|]
operator|&&
name|pstk
operator|>
name|instack
condition|)
continue|continue;
comment|/* put the new element onto the stack */
name|temp
operator|=
name|pstk
operator|->
name|in_sz
expr_stmt|;
name|instk
argument_list|(
name|pstk
operator|->
name|in_id
argument_list|,
operator|(
name|TWORD
operator|)
name|DECREF
argument_list|(
name|pstk
operator|->
name|in_t
argument_list|)
argument_list|,
name|pstk
operator|->
name|in_d
operator|+
literal|1
argument_list|,
name|pstk
operator|->
name|in_s
argument_list|,
name|pstk
operator|->
name|in_off
operator|+
name|n
operator|*
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_macro
name|ilbrace
argument_list|()
end_macro

begin_block
block|{
comment|/* process an initializer's left brace */
specifier|register
name|t
expr_stmt|;
name|struct
name|instk
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|pstk
expr_stmt|;
for|for
control|(
init|;
name|pstk
operator|>
name|instack
condition|;
operator|--
name|pstk
control|)
block|{
name|t
operator|=
name|pstk
operator|->
name|in_t
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|STRTY
operator|&&
operator|!
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
comment|/* not an aggregate */
if|if
condition|(
name|pstk
operator|->
name|in_fl
condition|)
block|{
comment|/* already associated with a { */
if|if
condition|(
name|pstk
operator|->
name|in_n
condition|)
name|uerror
argument_list|(
literal|"illegal {"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* we have one ... */
name|pstk
operator|->
name|in_fl
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* cannot find one */
comment|/* ignore such right braces */
name|pstk
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_macro
name|irbrace
argument_list|()
end_macro

begin_block
block|{
comment|/* called when a '}' is seen */
if|if
condition|(
name|idebug
condition|)
name|printf
argument_list|(
literal|"irbrace(): paramno = %d on entry\n"
argument_list|,
name|paramno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibseen
condition|)
block|{
operator|--
name|ibseen
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
name|pstk
operator|>
name|instack
condition|;
operator|--
name|pstk
control|)
block|{
if|if
condition|(
operator|!
name|pstk
operator|->
name|in_fl
condition|)
continue|continue;
comment|/* we have one now */
name|pstk
operator|->
name|in_fl
operator|=
literal|0
expr_stmt|;
comment|/* cancel { */
name|gotscal
argument_list|()
expr_stmt|;
comment|/* take it away... */
return|return;
block|}
comment|/* these right braces match ignored left braces: throw out */
block|}
end_block

begin_expr_stmt
name|upoff
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|,
name|poff
argument_list|)
specifier|register
name|alignment
operator|,
operator|*
name|poff
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* update the offset pointed to by poff; return the 	/* offset of a value of size `size', alignment `alignment', 	/* given that off is increasing */
specifier|register
name|off
expr_stmt|;
name|off
operator|=
operator|*
name|poff
expr_stmt|;
name|SETOFF
argument_list|(
name|off
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
operator|*
name|poff
operator|=
name|off
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|oalloc
argument_list|(
name|p
argument_list|,
name|poff
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
operator|*
name|poff
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* allocate p with offset *poff, and update *poff */
specifier|register
name|al
operator|,
name|off
operator|,
name|tsz
expr_stmt|;
name|int
name|noff
decl_stmt|;
name|al
operator|=
name|talign
argument_list|(
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
expr_stmt|;
name|noff
operator|=
name|off
operator|=
operator|*
name|poff
expr_stmt|;
name|tsz
operator|=
name|tsize
argument_list|(
name|p
operator|->
name|stype
argument_list|,
name|p
operator|->
name|dimoff
argument_list|,
name|p
operator|->
name|sizoff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKAUTO
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|AUTO
condition|)
block|{
name|noff
operator|=
name|off
operator|+
name|tsz
expr_stmt|;
name|SETOFF
argument_list|(
name|noff
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|off
operator|=
operator|-
name|noff
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|sclass
operator|==
name|PARAM
operator|&&
operator|(
name|p
operator|->
name|stype
operator|==
name|CHAR
operator|||
name|p
operator|->
name|stype
operator|==
name|UCHAR
operator|||
name|p
operator|->
name|stype
operator|==
name|SHORT
operator|||
name|p
operator|->
name|stype
operator|==
name|USHORT
operator|)
condition|)
block|{
name|off
operator|=
name|upoff
argument_list|(
name|SZINT
argument_list|,
name|ALINT
argument_list|,
operator|&
name|noff
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RTOLBYTES
name|off
operator|=
name|noff
operator|-
name|tsz
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|off
operator|=
name|upoff
argument_list|(
name|tsz
argument_list|,
name|al
argument_list|,
operator|&
name|noff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|sclass
operator|!=
name|REGISTER
condition|)
block|{
comment|/* in case we are allocating stack space for register arguments */
if|if
condition|(
name|p
operator|->
name|offset
operator|==
name|NOOFFSET
condition|)
name|p
operator|->
name|offset
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|!=
name|p
operator|->
name|offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|poff
operator|=
name|noff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|falloc
argument_list|(
name|p
argument_list|,
name|w
argument_list|,
name|new
argument_list|,
name|pty
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|NODE
modifier|*
name|pty
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* allocate a field of width w */
comment|/* new is 0 if new entry, 1 if redefinition, -1 if alignment */
specifier|register
name|al
operator|,
name|sz
operator|,
name|type
expr_stmt|;
name|type
operator|=
operator|(
name|new
operator|<
literal|0
operator|)
condition|?
name|pty
operator|->
name|type
else|:
name|p
operator|->
name|stype
expr_stmt|;
comment|/* this must be fixed to use the current type in alignments */
switch|switch
condition|(
name|new
operator|<
literal|0
condition|?
name|pty
operator|->
name|type
else|:
name|p
operator|->
name|stype
condition|)
block|{
case|case
name|ENUMTY
case|:
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|new
operator|<
literal|0
condition|?
name|pty
operator|->
name|csiz
else|:
name|p
operator|->
name|sizoff
expr_stmt|;
name|al
operator|=
name|dimtab
index|[
name|s
operator|+
literal|2
index|]
expr_stmt|;
name|sz
operator|=
name|dimtab
index|[
name|s
index|]
expr_stmt|;
break|break;
block|}
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
name|al
operator|=
name|ALCHAR
expr_stmt|;
name|sz
operator|=
name|SZCHAR
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
name|al
operator|=
name|ALSHORT
expr_stmt|;
name|sz
operator|=
name|SZSHORT
expr_stmt|;
break|break;
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|al
operator|=
name|ALINT
expr_stmt|;
name|sz
operator|=
name|SZINT
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LONGFIELDS
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
name|al
operator|=
name|ALLONG
expr_stmt|;
name|sz
operator|=
name|SZLONG
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|new
operator|<
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"illegal field type"
argument_list|)
expr_stmt|;
name|al
operator|=
name|ALINT
expr_stmt|;
block|}
else|else
block|{
name|al
operator|=
name|fldal
argument_list|(
name|p
operator|->
name|stype
argument_list|)
expr_stmt|;
name|sz
operator|=
name|SZINT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|w
operator|>
name|sz
condition|)
block|{
name|uerror
argument_list|(
literal|"field too big"
argument_list|)
expr_stmt|;
name|w
operator|=
name|sz
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|==
literal|0
condition|)
block|{
comment|/* align only */
name|SETOFF
argument_list|(
name|strucoff
argument_list|,
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>=
literal|0
condition|)
name|uerror
argument_list|(
literal|"zero size field"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strucoff
operator|%
name|al
operator|+
name|w
operator|>
name|sz
condition|)
name|SETOFF
argument_list|(
name|strucoff
argument_list|,
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|<
literal|0
condition|)
block|{
name|strucoff
operator|+=
name|w
expr_stmt|;
comment|/* we know it will fit */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* establish the field */
if|if
condition|(
name|new
operator|==
literal|1
condition|)
block|{
comment|/* previous definition */
if|if
condition|(
name|p
operator|->
name|offset
operator|!=
name|strucoff
operator|||
name|p
operator|->
name|sclass
operator|!=
operator|(
name|FIELD
operator||
name|w
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|offset
operator|=
name|strucoff
expr_stmt|;
name|strucoff
operator|+=
name|w
expr_stmt|;
name|p
operator|->
name|stype
operator|=
name|type
expr_stmt|;
name|fldty
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nidcl
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* handle unitialized declarations */
comment|/* assumed to be not functions */
specifier|register
name|class
expr_stmt|;
specifier|register
name|commflag
expr_stmt|;
comment|/* flag for labelled common declarations */
name|commflag
operator|=
literal|0
expr_stmt|;
comment|/* compute class */
if|if
condition|(
operator|(
name|class
operator|=
name|curclass
operator|)
operator|==
name|SNULL
condition|)
block|{
if|if
condition|(
name|blevel
operator|>
literal|1
condition|)
name|class
operator|=
name|AUTO
expr_stmt|;
elseif|else
if|if
condition|(
name|blevel
operator|!=
literal|0
operator|||
name|instruct
condition|)
name|cerror
argument_list|(
literal|"nidcl error"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* blevel = 0 */
name|class
operator|=
name|noinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|EXTERN
condition|)
name|commflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|defid
argument_list|(
name|p
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|EXTDEF
operator|||
name|class
operator|==
name|STATIC
condition|)
block|{
comment|/* simulate initialization by 0 */
name|beginit
argument_list|(
name|p
operator|->
name|rval
argument_list|)
expr_stmt|;
name|endinit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|commflag
condition|)
name|commdec
argument_list|(
name|p
operator|->
name|rval
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|TWORD
name|types
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|,
name|t3
parameter_list|)
name|TWORD
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
block|{
comment|/* return a basic type from basic types t1, t2, and t3 */
name|TWORD
name|t
index|[
literal|3
index|]
decl_stmt|,
name|noun
decl_stmt|,
name|adj
decl_stmt|,
name|unsg
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|t1
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|t2
expr_stmt|;
name|t
index|[
literal|2
index|]
operator|=
name|t3
expr_stmt|;
name|unsg
operator|=
name|INT
expr_stmt|;
comment|/* INT or UNSIGNED */
name|noun
operator|=
name|UNDEF
expr_stmt|;
comment|/* INT, CHAR, or FLOAT */
name|adj
operator|=
name|INT
expr_stmt|;
comment|/* INT, LONG, or SHORT */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|t
index|[
name|i
index|]
condition|)
block|{
default|default:
name|bad
label|:
name|uerror
argument_list|(
literal|"illegal type combination"
argument_list|)
expr_stmt|;
return|return
operator|(
name|INT
operator|)
return|;
case|case
name|UNDEF
case|:
continue|continue;
case|case
name|UNSIGNED
case|:
if|if
condition|(
name|unsg
operator|!=
name|INT
condition|)
goto|goto
name|bad
goto|;
name|unsg
operator|=
name|UNSIGNED
expr_stmt|;
continue|continue;
case|case
name|LONG
case|:
case|case
name|SHORT
case|:
if|if
condition|(
name|adj
operator|!=
name|INT
condition|)
goto|goto
name|bad
goto|;
name|adj
operator|=
name|t
index|[
name|i
index|]
expr_stmt|;
continue|continue;
case|case
name|INT
case|:
case|case
name|CHAR
case|:
case|case
name|FLOAT
case|:
if|if
condition|(
name|noun
operator|!=
name|UNDEF
condition|)
goto|goto
name|bad
goto|;
name|noun
operator|=
name|t
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* now, construct final type */
if|if
condition|(
name|noun
operator|==
name|UNDEF
condition|)
name|noun
operator|=
name|INT
expr_stmt|;
elseif|else
if|if
condition|(
name|noun
operator|==
name|FLOAT
condition|)
block|{
if|if
condition|(
name|unsg
operator|!=
name|INT
operator|||
name|adj
operator|==
name|SHORT
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
name|adj
operator|==
name|LONG
condition|?
name|DOUBLE
else|:
name|FLOAT
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|noun
operator|==
name|CHAR
operator|&&
name|adj
operator|!=
name|INT
condition|)
goto|goto
name|bad
goto|;
comment|/* now, noun is INT or CHAR */
if|if
condition|(
name|adj
operator|!=
name|INT
condition|)
name|noun
operator|=
name|adj
expr_stmt|;
if|if
condition|(
name|unsg
operator|==
name|UNSIGNED
condition|)
return|return
operator|(
name|noun
operator|+
operator|(
name|UNSIGNED
operator|-
name|INT
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|noun
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|tymerge
parameter_list|(
name|typ
parameter_list|,
name|idp
parameter_list|)
name|NODE
modifier|*
name|typ
decl_stmt|,
decl|*
name|idp
decl_stmt|;
end_function

begin_block
block|{
comment|/* merge type typ with identifier idp  */
specifier|register
name|unsigned
name|t
decl_stmt|;
specifier|register
name|i
expr_stmt|;
specifier|extern
name|int
name|eprint
parameter_list|()
function_decl|;
if|if
condition|(
name|typ
operator|->
name|op
operator|!=
name|TYPE
condition|)
name|cerror
argument_list|(
literal|"tymerge: arg 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|ddebug
operator|>
literal|2
condition|)
name|fwalk
argument_list|(
name|idp
argument_list|,
name|eprint
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|idp
operator|->
name|type
operator|=
name|typ
operator|->
name|type
expr_stmt|;
name|idp
operator|->
name|cdim
operator|=
name|curdim
expr_stmt|;
name|tyreduce
argument_list|(
name|idp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|csiz
operator|=
name|typ
operator|->
name|csiz
expr_stmt|;
for|for
control|(
name|t
operator|=
name|typ
operator|->
name|type
operator|,
name|i
operator|=
name|typ
operator|->
name|cdim
init|;
name|t
operator|&
name|TMASK
condition|;
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
name|dstash
argument_list|(
name|dimtab
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* now idp is a single node: fix up type */
name|idp
operator|->
name|type
operator|=
name|ctype
argument_list|(
name|idp
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|BTYPE
argument_list|(
name|idp
operator|->
name|type
argument_list|)
operator|)
operator|!=
name|STRTY
operator|&&
name|t
operator|!=
name|UNIONTY
operator|&&
name|t
operator|!=
name|ENUMTY
condition|)
block|{
name|idp
operator|->
name|csiz
operator|=
name|t
expr_stmt|;
comment|/* in case ctype has rewritten things */
block|}
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|tyreduce
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* build a type, and stash away dimensions, from a parse tree of the declaration */
comment|/* the type is build top down, the dimensions bottom up */
specifier|register
name|o
operator|,
name|temp
expr_stmt|;
specifier|register
name|unsigned
name|t
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|op
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
condition|)
return|return;
name|t
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|UNARY
name|CALL
condition|)
name|t
operator|+=
operator|(
name|FTN
operator|-
name|PTR
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|o
operator|==
name|LB
condition|)
block|{
name|t
operator|+=
operator|(
name|ARY
operator|-
name|PTR
operator|)
expr_stmt|;
name|temp
operator|=
name|p
operator|->
name|right
operator|->
name|lval
expr_stmt|;
name|p
operator|->
name|right
operator|->
name|op
operator|=
name|FREE
expr_stmt|;
block|}
name|p
operator|->
name|left
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|tyreduce
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|LB
condition|)
name|dstash
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|p
operator|->
name|rval
operator|=
name|p
operator|->
name|left
operator|->
name|rval
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|p
operator|->
name|left
operator|->
name|type
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|fixtype
argument_list|(
name|p
argument_list|,
name|class
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|unsigned
name|t
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|mod1
operator|,
name|mod2
expr_stmt|;
comment|/* fix up the types, and check for legality */
if|if
condition|(
operator|(
name|type
operator|=
name|p
operator|->
name|type
operator|)
operator|==
name|UNDEF
condition|)
return|return;
if|if
condition|(
name|mod2
operator|=
operator|(
name|type
operator|&
name|TMASK
operator|)
condition|)
block|{
name|t
operator|=
name|DECREF
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|mod1
operator|=
name|mod2
operator|,
name|mod2
operator|=
operator|(
name|t
operator|&
name|TMASK
operator|)
condition|)
block|{
if|if
condition|(
name|mod1
operator|==
name|ARY
operator|&&
name|mod2
operator|==
name|FTN
condition|)
block|{
name|uerror
argument_list|(
literal|"array of functions is illegal"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mod1
operator|==
name|FTN
operator|&&
operator|(
name|mod2
operator|==
name|ARY
operator|||
name|mod2
operator|==
name|FTN
operator|)
condition|)
block|{
name|uerror
argument_list|(
literal|"function returns illegal type"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* detect function arguments, watching out for structure declarations */
if|if
condition|(
name|class
operator|==
name|SNULL
operator|&&
name|blevel
operator|==
literal|1
operator|&&
operator|!
operator|(
name|instruct
operator|&
operator|(
name|INSTRUCT
operator||
name|INUNION
operator|)
operator|)
condition|)
name|class
operator|=
name|PARAM
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PARAM
operator|||
operator|(
name|class
operator|==
name|REGISTER
operator|&&
name|blevel
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|FLOAT
condition|)
name|type
operator|=
name|DOUBLE
expr_stmt|;
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|type
argument_list|)
condition|)
block|{
operator|++
name|p
operator|->
name|cdim
expr_stmt|;
name|type
operator|+=
operator|(
name|PTR
operator|-
name|ARY
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|INCREF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|instruct
operator|&&
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|uerror
argument_list|(
literal|"function illegal in structure or union"
argument_list|)
expr_stmt|;
name|type
operator|=
name|INCREF
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|uclass
argument_list|(
name|class
argument_list|)
specifier|register
name|class
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* give undefined version of class */
if|if
condition|(
name|class
operator|==
name|SNULL
condition|)
return|return
operator|(
name|EXTERN
operator|)
return|;
elseif|else
if|if
condition|(
name|class
operator|==
name|STATIC
condition|)
return|return
operator|(
name|USTATIC
operator|)
return|;
elseif|else
if|if
condition|(
name|class
operator|==
name|FORTRAN
condition|)
return|return
operator|(
name|UFORTRAN
operator|)
return|;
else|else
return|return
operator|(
name|class
operator|)
return|;
block|}
end_block

begin_macro
name|fixclass
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* first, fix null class */
if|if
condition|(
name|class
operator|==
name|SNULL
condition|)
block|{
if|if
condition|(
name|instruct
operator|&
name|INSTRUCT
condition|)
name|class
operator|=
name|MOS
expr_stmt|;
elseif|else
if|if
condition|(
name|instruct
operator|&
name|INUNION
condition|)
name|class
operator|=
name|MOU
expr_stmt|;
elseif|else
if|if
condition|(
name|blevel
operator|==
literal|0
condition|)
name|class
operator|=
name|EXTDEF
expr_stmt|;
elseif|else
if|if
condition|(
name|blevel
operator|==
literal|1
condition|)
name|class
operator|=
name|PARAM
expr_stmt|;
else|else
name|class
operator|=
name|AUTO
expr_stmt|;
block|}
comment|/* now, do general checking */
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|class
condition|)
block|{
default|default:
name|uerror
argument_list|(
literal|"function has illegal storage class"
argument_list|)
expr_stmt|;
case|case
name|AUTO
case|:
name|class
operator|=
name|EXTERN
expr_stmt|;
case|case
name|EXTERN
case|:
case|case
name|EXTDEF
case|:
case|case
name|FORTRAN
case|:
case|case
name|TYPEDEF
case|:
case|case
name|STATIC
case|:
case|case
name|UFORTRAN
case|:
case|case
name|USTATIC
case|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|class
operator|&
name|FIELD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|instruct
operator|&
name|INSTRUCT
operator|)
condition|)
name|uerror
argument_list|(
literal|"illegal use of field"
argument_list|)
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
block|}
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|MOU
case|:
if|if
condition|(
operator|!
operator|(
name|instruct
operator|&
name|INUNION
operator|)
condition|)
name|uerror
argument_list|(
literal|"illegal class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
case|case
name|MOS
case|:
if|if
condition|(
operator|!
operator|(
name|instruct
operator|&
name|INSTRUCT
operator|)
condition|)
name|uerror
argument_list|(
literal|"illegal class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
case|case
name|MOE
case|:
if|if
condition|(
name|instruct
operator|&
operator|(
name|INSTRUCT
operator||
name|INUNION
operator|)
condition|)
name|uerror
argument_list|(
literal|"illegal class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
case|case
name|REGISTER
case|:
if|if
condition|(
name|blevel
operator|==
literal|0
condition|)
name|uerror
argument_list|(
literal|"illegal register declaration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regvar
operator|>=
name|MINRVAR
operator|&&
name|cisreg
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
name|class
operator|)
return|;
if|if
condition|(
name|blevel
operator|==
literal|1
condition|)
return|return
operator|(
name|PARAM
operator|)
return|;
else|else
return|return
operator|(
name|AUTO
operator|)
return|;
case|case
name|AUTO
case|:
case|case
name|LABEL
case|:
case|case
name|ULABEL
case|:
if|if
condition|(
name|blevel
operator|<
literal|2
condition|)
name|uerror
argument_list|(
literal|"illegal class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
case|case
name|PARAM
case|:
if|if
condition|(
name|blevel
operator|!=
literal|1
condition|)
name|uerror
argument_list|(
literal|"illegal class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|class
operator|)
return|;
case|case
name|UFORTRAN
case|:
case|case
name|FORTRAN
case|:
ifdef|#
directive|ifdef
name|NOFORTRAN
name|NOFORTRAN
expr_stmt|;
comment|/* a condition which can regulate the FORTRAN usage */
endif|#
directive|endif
if|if
condition|(
operator|!
name|ISFTN
argument_list|(
name|type
argument_list|)
condition|)
name|uerror
argument_list|(
literal|"fortran declaration must apply to function"
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|DECREF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFTN
argument_list|(
name|type
argument_list|)
operator|||
name|ISARY
argument_list|(
name|type
argument_list|)
operator|||
name|ISPTR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|uerror
argument_list|(
literal|"fortran function has wrong type"
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|STNAME
case|:
case|case
name|UNAME
case|:
case|case
name|ENAME
case|:
case|case
name|EXTERN
case|:
case|case
name|STATIC
case|:
case|case
name|EXTDEF
case|:
case|case
name|TYPEDEF
case|:
case|case
name|USTATIC
case|:
return|return
operator|(
name|class
operator|)
return|;
default|default:
name|cerror
argument_list|(
literal|"illegal class: %d"
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_macro
name|lookup
argument_list|(
argument|name
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* look up name: must agree with s w.r.t. SMOS and SHIDDEN */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ii
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|sp
decl_stmt|;
comment|/* compute initial hash index */
if|if
condition|(
name|ddebug
operator|>
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"lookup( %s, %d ), stwart=%d, instruct=%d\n"
argument_list|,
name|name
argument_list|,
name|s
argument_list|,
name|stwart
argument_list|,
name|instruct
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|name
operator|,
name|j
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
name|i
operator|+=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|>=
name|NCHNAM
condition|)
break|break;
block|}
name|i
operator|=
name|i
operator|%
name|SYMTSZ
expr_stmt|;
name|sp
operator|=
operator|&
name|stab
index|[
name|ii
operator|=
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* look for name */
if|if
condition|(
name|sp
operator|->
name|stype
operator|==
name|TNULL
condition|)
block|{
comment|/* empty slot */
name|p
operator|=
name|sp
operator|->
name|sname
expr_stmt|;
name|sp
operator|->
name|sflags
operator|=
name|s
expr_stmt|;
comment|/* set SMOS if needed, turn off all others */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCHNAM
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|name
condition|)
operator|++
name|name
expr_stmt|;
name|sp
operator|->
name|stype
operator|=
name|UNDEF
expr_stmt|;
name|sp
operator|->
name|sclass
operator|=
name|SNULL
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|sflags
operator|&
operator|(
name|SMOS
operator||
name|SHIDDEN
operator|)
operator|)
operator|!=
name|s
condition|)
goto|goto
name|next
goto|;
name|p
operator|=
name|sp
operator|->
name|sname
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCHNAM
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
operator|!
operator|*
name|q
operator|++
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
name|next
label|:
if|if
condition|(
operator|++
name|i
operator|>=
name|SYMTSZ
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|stab
expr_stmt|;
block|}
else|else
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ii
condition|)
name|cerror
argument_list|(
literal|"symbol table full"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|checkst
end_ifndef

begin_comment
comment|/* if not debugging, make checkst a macro */
end_comment

begin_macro
name|checkst
argument_list|(
argument|lev
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|stab
init|;
name|i
operator|<
name|SYMTSZ
condition|;
operator|++
name|i
operator|,
operator|++
name|p
control|)
block|{
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|TNULL
condition|)
continue|continue;
name|j
operator|=
name|lookup
argument_list|(
name|p
operator|->
name|sname
argument_list|,
name|p
operator|->
name|sflags
operator|&
name|SMOS
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|i
condition|)
block|{
name|q
operator|=
operator|&
name|stab
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|stype
operator|==
name|UNDEF
operator|||
name|q
operator|->
name|slevel
operator|<=
name|p
operator|->
name|slevel
condition|)
block|{
name|cerror
argument_list|(
literal|"check error: %.8s"
argument_list|,
name|q
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|slevel
operator|>
name|lev
condition|)
name|cerror
argument_list|(
literal|"%.8s check at level %d"
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|lev
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|symtab
modifier|*
name|relook
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|;
block|{
comment|/* look up p again, and see where it lies */
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
comment|/* I'm not sure that this handles towers of several hidden definitions in all cases */
name|q
operator|=
operator|&
name|stab
index|[
name|lookup
argument_list|(
name|p
operator|->
name|sname
argument_list|,
name|p
operator|->
name|sflags
operator|&
operator|(
name|SMOS
operator||
name|SHIDDEN
operator|)
argument_list|)
index|]
expr_stmt|;
comment|/* make relook always point to either p or an empty cell */
if|if
condition|(
name|q
operator|->
name|stype
operator|==
name|UNDEF
condition|)
block|{
name|q
operator|->
name|stype
operator|=
name|TNULL
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
while|while
condition|(
name|q
operator|!=
name|p
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|stype
operator|==
name|TNULL
condition|)
break|break;
if|if
condition|(
operator|++
name|q
operator|>=
operator|&
name|stab
index|[
name|SYMTSZ
index|]
condition|)
name|q
operator|=
name|stab
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_macro
name|clearst
argument_list|(
argument|lev
argument_list|)
end_macro

begin_block
block|{
comment|/* clear entries of internal scope  from the symbol table */
specifier|register
name|struct
name|symtab
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|,
name|rehash
decl_stmt|;
name|temp
operator|=
name|lineno
expr_stmt|;
name|aobeg
argument_list|()
expr_stmt|;
comment|/* first, find an empty slot to prevent newly hashed entries from 	   being slopped into... */
for|for
control|(
name|q
operator|=
name|stab
init|;
name|q
operator|<
operator|&
name|stab
index|[
name|SYMTSZ
index|]
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|stype
operator|==
name|TNULL
condition|)
goto|goto
name|search
goto|;
block|}
name|cerror
argument_list|(
literal|"symbol table full"
argument_list|)
expr_stmt|;
name|search
label|:
name|p
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|TNULL
condition|)
block|{
name|rehash
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|lineno
operator|=
name|p
operator|->
name|suse
expr_stmt|;
if|if
condition|(
name|lineno
operator|<
literal|0
condition|)
name|lineno
operator|=
operator|-
name|lineno
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|slevel
operator|>
name|lev
condition|)
block|{
comment|/* must clobber */
if|if
condition|(
name|p
operator|->
name|stype
operator|==
name|UNDEF
operator|||
operator|(
name|p
operator|->
name|sclass
operator|==
name|ULABEL
operator|&&
name|lev
operator|<
literal|2
operator|)
condition|)
block|{
name|lineno
operator|=
name|temp
expr_stmt|;
name|uerror
argument_list|(
literal|"%.8s undefined"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
block|}
else|else
name|aocode
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"removing %8s from stab[ %d], flags %o level %d\n"
argument_list|,
name|p
operator|->
name|sname
argument_list|,
name|p
operator|-
name|stab
argument_list|,
name|p
operator|->
name|sflags
argument_list|,
name|p
operator|->
name|slevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sflags
operator|&
name|SHIDES
condition|)
name|unhide
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|stype
operator|=
name|TNULL
expr_stmt|;
name|rehash
operator|=
literal|1
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|rehash
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|relook
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|p
condition|)
block|{
name|movestab
argument_list|(
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|stype
operator|=
name|TNULL
expr_stmt|;
block|}
block|}
name|next
label|:
if|if
condition|(
operator|++
name|p
operator|>=
operator|&
name|stab
index|[
name|SYMTSZ
index|]
condition|)
name|p
operator|=
name|stab
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
break|break;
block|}
name|lineno
operator|=
name|temp
expr_stmt|;
name|aoend
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|movestab
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|k
decl_stmt|;
comment|/* structure assignment: *p = *q; */
name|p
operator|->
name|stype
operator|=
name|q
operator|->
name|stype
expr_stmt|;
name|p
operator|->
name|sclass
operator|=
name|q
operator|->
name|sclass
expr_stmt|;
name|p
operator|->
name|slevel
operator|=
name|q
operator|->
name|slevel
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|q
operator|->
name|offset
expr_stmt|;
name|p
operator|->
name|sflags
operator|=
name|q
operator|->
name|sflags
expr_stmt|;
name|p
operator|->
name|dimoff
operator|=
name|q
operator|->
name|dimoff
expr_stmt|;
name|p
operator|->
name|sizoff
operator|=
name|q
operator|->
name|sizoff
expr_stmt|;
name|p
operator|->
name|suse
operator|=
name|q
operator|->
name|suse
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NCHNAM
condition|;
operator|++
name|k
control|)
block|{
name|p
operator|->
name|sname
index|[
name|k
index|]
operator|=
name|q
operator|->
name|sname
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|hide
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|+
literal|1
init|;
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|>=
operator|&
name|stab
index|[
name|SYMTSZ
index|]
condition|)
name|q
operator|=
name|stab
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
name|cerror
argument_list|(
literal|"symbol table full"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|stype
operator|==
name|TNULL
condition|)
break|break;
block|}
name|movestab
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|sflags
operator||=
name|SHIDDEN
expr_stmt|;
name|q
operator|->
name|sflags
operator|=
operator|(
name|p
operator|->
name|sflags
operator|&
name|SMOS
operator|)
operator||
name|SHIDES
expr_stmt|;
if|if
condition|(
name|hflag
condition|)
name|werror
argument_list|(
literal|"%.8s redefinition hides earlier one"
argument_list|,
name|p
operator|->
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"	%d hidden in %d\n"
argument_list|,
name|p
operator|-
name|stab
argument_list|,
name|q
operator|-
name|stab
argument_list|)
expr_stmt|;
return|return
operator|(
name|idname
operator|=
name|q
operator|-
name|stab
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|unhide
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|symtab
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|q
decl_stmt|;
specifier|register
name|s
operator|,
name|j
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|sflags
operator|&
name|SMOS
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|q
operator|==
name|stab
condition|)
name|q
operator|=
operator|&
name|stab
index|[
name|SYMTSZ
operator|-
literal|1
index|]
expr_stmt|;
else|else
operator|--
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|p
condition|)
break|break;
if|if
condition|(
operator|(
name|q
operator|->
name|sflags
operator|&
name|SMOS
operator|)
operator|==
name|s
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCHNAM
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|p
operator|->
name|sname
index|[
name|j
index|]
operator|!=
name|q
operator|->
name|sname
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|NCHNAM
condition|)
block|{
comment|/* found the name */
name|q
operator|->
name|sflags
operator|&=
operator|~
name|SHIDDEN
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|printf
argument_list|(
literal|"unhide uncovered %d from %d\n"
argument_list|,
name|q
operator|-
name|stab
argument_list|,
name|p
operator|-
name|stab
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|cerror
argument_list|(
literal|"unhide fails"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

