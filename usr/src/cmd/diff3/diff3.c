begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_empty
empty|#
end_empty

begin_comment
comment|/* diff3 - 3-way differential file comparison*/
end_comment

begin_comment
comment|/* diff3 [-e] d13 d23 f1 f2 f3   *  * d13 = diff report on f1 vs f3  * d23 = diff report on f2 vs f3  * f1, f2, f3 the 3 files */
end_comment

begin_struct
struct|struct
name|range
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* from is first in range of changed lines 	 * to is last+1 	 * from=to=line after point of insertion 	* for added lines 	*/
end_comment

begin_struct
struct|struct
name|diff
block|{
name|struct
name|range
name|old
decl_stmt|,
name|new
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NC
value|200
end_define

begin_comment
comment|/* de is used to gather editing scripts,  * that are later spewed out in reverse order.  * its first element must be all zero  * the "new" component of de contains line positions  * or byte positions depending on when you look(!?) */
end_comment

begin_decl_stmt
name|struct
name|diff
name|d13
index|[
name|NC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|diff
name|d23
index|[
name|NC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|diff
name|de
index|[
name|NC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linct
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	the number of the last-read line in each file  *	is kept in cline[0-2] */
end_comment

begin_decl_stmt
name|int
name|cline
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	the latest known correspondence between line  *	numbers of the 3 files is stored in last[1-3] */
end_comment

begin_decl_stmt
name|int
name|last
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|i
operator|,
name|m
operator|,
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
default|default:
name|eflag
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|eflag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|eflag
operator|=
literal|1
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|6
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"diff3: arg count\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|readin
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|d13
argument_list|)
expr_stmt|;
name|n
operator|=
name|readin
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
name|d23
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|fp
index|[
name|i
index|]
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"diff3: can't open %s\n"
argument_list|,
name|argv
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|merge
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*pick up the line numbers of allcahnges from  * one change file  * (this puts the numbers in a vector, which is not  * strictly necessary, since the vector is processed  * in one sequential pass. The vector could be optimized  * out of existence) */
end_comment

begin_macro
name|readin
argument_list|(
argument|name
argument_list|,
argument|dd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|diff
modifier|*
name|dd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|char
name|kind
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|fp
index|[
literal|0
index|]
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|getchange
argument_list|(
name|fp
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|NC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"diff3: too many changes\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|line
expr_stmt|;
name|a
operator|=
name|b
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|b
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
name|kind
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|d
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|d
operator|=
name|number
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
literal|'a'
condition|)
name|a
operator|++
expr_stmt|;
if|if
condition|(
name|kind
operator|==
literal|'d'
condition|)
name|c
operator|++
expr_stmt|;
name|b
operator|++
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|dd
index|[
name|i
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|a
expr_stmt|;
name|dd
index|[
name|i
index|]
operator|.
name|old
operator|.
name|to
operator|=
name|b
expr_stmt|;
name|dd
index|[
name|i
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|c
expr_stmt|;
name|dd
index|[
name|i
index|]
operator|.
name|new
operator|.
name|to
operator|=
name|d
expr_stmt|;
block|}
name|dd
index|[
name|i
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|dd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|old
operator|.
name|to
expr_stmt|;
name|dd
index|[
name|i
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|dd
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|new
operator|.
name|to
expr_stmt|;
name|fclose
argument_list|(
name|fp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|number
argument_list|(
argument|lc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|lc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|nn
expr_stmt|;
name|nn
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|digit
argument_list|(
operator|*
operator|*
name|lc
argument_list|)
condition|)
name|nn
operator|=
name|nn
operator|*
literal|10
operator|+
operator|*
operator|(
operator|*
name|lc
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
name|nn
operator|)
return|;
block|}
end_block

begin_macro
name|digit
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_block

begin_macro
name|getchange
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|getline
argument_list|(
name|b
argument_list|)
condition|)
if|if
condition|(
name|digit
argument_list|(
name|line
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|line
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|line
index|[
operator|++
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|merge
argument_list|(
argument|m1
argument_list|,
argument|m2
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|diff
modifier|*
name|d1
decl_stmt|,
modifier|*
name|d2
decl_stmt|,
modifier|*
name|d3
decl_stmt|;
name|int
name|dup
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|d1
operator|=
name|d13
expr_stmt|;
name|d2
operator|=
name|d23
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|t1
operator|=
name|d1
operator|<
name|d13
operator|+
name|m1
operator|)
operator||
operator|(
name|t2
operator|=
name|d2
operator|<
name|d23
operator|+
name|m2
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"%d,%d=%d,%d %d,%d=%d,%d\n"
argument_list|,
name|d1
operator|->
name|old
operator|.
name|from
argument_list|,
name|d1
operator|->
name|old
operator|.
name|to
argument_list|,
name|d1
operator|->
name|new
operator|.
name|from
argument_list|,
name|d1
operator|->
name|new
operator|.
name|to
argument_list|,
name|d2
operator|->
name|old
operator|.
name|from
argument_list|,
name|d2
operator|->
name|old
operator|.
name|to
argument_list|,
name|d2
operator|->
name|new
operator|.
name|from
argument_list|,
name|d2
operator|->
name|new
operator|.
name|to
argument_list|)
expr_stmt|;
block|}
comment|/*			first file is different from others*/
if|if
condition|(
operator|!
name|t2
operator|||
name|t1
operator|&&
name|d1
operator|->
name|new
operator|.
name|to
operator|<
name|d2
operator|->
name|new
operator|.
name|from
condition|)
block|{
comment|/*			stuff peculiar to 1st file */
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
name|separate
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|1
argument_list|,
operator|&
name|d1
operator|->
name|old
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|keep
argument_list|(
literal|2
argument_list|,
operator|&
name|d1
operator|->
name|old
argument_list|,
operator|&
name|d1
operator|->
name|new
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|3
argument_list|,
operator|&
name|d1
operator|->
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|d1
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*			second file is different from others*/
if|if
condition|(
operator|!
name|t1
operator|||
name|t2
operator|&&
name|d2
operator|->
name|new
operator|.
name|to
operator|<
name|d1
operator|->
name|new
operator|.
name|from
condition|)
block|{
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
name|separate
argument_list|(
literal|"2"
argument_list|)
expr_stmt|;
name|keep
argument_list|(
literal|1
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|,
operator|&
name|d2
operator|->
name|new
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|2
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|3
argument_list|,
operator|&
name|d2
operator|->
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|d2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*			merge overlapping changes in first file  *			this happens after extension see below*/
if|if
condition|(
name|d1
operator|+
literal|1
operator|<
name|d13
operator|+
name|m1
operator|&&
name|d1
operator|->
name|new
operator|.
name|to
operator|>=
name|d1
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
condition|)
block|{
name|d1
index|[
literal|1
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|d1
operator|->
name|old
operator|.
name|from
expr_stmt|;
name|d1
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|d1
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d1
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*			merge overlapping changes in second*/
if|if
condition|(
name|d2
operator|+
literal|1
operator|<
name|d23
operator|+
name|m2
operator|&&
name|d2
operator|->
name|new
operator|.
name|to
operator|>=
name|d2
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
condition|)
block|{
name|d2
index|[
literal|1
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|d2
operator|->
name|old
operator|.
name|from
expr_stmt|;
name|d2
index|[
literal|1
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|d2
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*			stuff peculiar to third file or different in all*/
if|if
condition|(
name|d1
operator|->
name|new
operator|.
name|from
operator|==
name|d2
operator|->
name|new
operator|.
name|from
operator|&&
name|d1
operator|->
name|new
operator|.
name|to
operator|==
name|d2
operator|->
name|new
operator|.
name|to
condition|)
block|{
name|dup
operator|=
name|duplicate
argument_list|(
operator|&
name|d1
operator|->
name|old
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|)
expr_stmt|;
comment|/*				dup=0 means all files differ  *				dup =1 meands files 1&2 identical*/
if|if
condition|(
name|eflag
operator|==
literal|0
condition|)
block|{
name|separate
argument_list|(
name|dup
condition|?
literal|"3"
else|:
literal|""
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|1
argument_list|,
operator|&
name|d1
operator|->
name|old
argument_list|,
name|dup
argument_list|)
expr_stmt|;
name|change
argument_list|(
literal|2
argument_list|,
operator|&
name|d2
operator|->
name|old
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d3
operator|=
name|d1
operator|->
name|old
operator|.
name|to
operator|>
name|d1
operator|->
name|old
operator|.
name|from
condition|?
name|d1
else|:
name|d2
expr_stmt|;
name|change
argument_list|(
literal|3
argument_list|,
operator|&
name|d3
operator|->
name|new
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
name|edit
argument_list|(
name|d1
argument_list|,
name|dup
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|d1
operator|++
expr_stmt|;
name|d2
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*			overlapping changes from file1& 2  *			extend changes appropriately to  *			make them coincide*/
if|if
condition|(
name|d1
operator|->
name|new
operator|.
name|from
operator|<
name|d2
operator|->
name|new
operator|.
name|from
condition|)
block|{
name|d2
operator|->
name|old
operator|.
name|from
operator|-=
name|d2
operator|->
name|new
operator|.
name|from
operator|-
name|d1
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d2
operator|->
name|new
operator|.
name|from
operator|=
name|d1
operator|->
name|new
operator|.
name|from
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2
operator|->
name|new
operator|.
name|from
operator|<
name|d1
operator|->
name|new
operator|.
name|from
condition|)
block|{
name|d1
operator|->
name|old
operator|.
name|from
operator|-=
name|d1
operator|->
name|new
operator|.
name|from
operator|-
name|d2
operator|->
name|new
operator|.
name|from
expr_stmt|;
name|d1
operator|->
name|new
operator|.
name|from
operator|=
name|d2
operator|->
name|new
operator|.
name|from
expr_stmt|;
block|}
if|if
condition|(
name|d1
operator|->
name|new
operator|.
name|to
operator|>
name|d2
operator|->
name|new
operator|.
name|to
condition|)
block|{
name|d2
operator|->
name|old
operator|.
name|to
operator|+=
name|d1
operator|->
name|new
operator|.
name|to
operator|-
name|d2
operator|->
name|new
operator|.
name|to
expr_stmt|;
name|d2
operator|->
name|new
operator|.
name|to
operator|=
name|d1
operator|->
name|new
operator|.
name|to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d2
operator|->
name|new
operator|.
name|to
operator|>
name|d1
operator|->
name|new
operator|.
name|to
condition|)
block|{
name|d1
operator|->
name|old
operator|.
name|to
operator|+=
name|d2
operator|->
name|new
operator|.
name|to
operator|-
name|d1
operator|->
name|new
operator|.
name|to
expr_stmt|;
name|d1
operator|->
name|new
operator|.
name|to
operator|=
name|d2
operator|->
name|new
operator|.
name|to
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eflag
condition|)
name|edscript
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|separate
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"====%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*	the range of ines rold.from thru rold.to in file i  *	is to be changed. it is to be printed only if  *	it does not duplicate something to be printed later */
end_comment

begin_macro
name|change
argument_list|(
argument|i
argument_list|,
argument|rold
argument_list|,
argument|dup
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|range
modifier|*
name|rold
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|last
index|[
name|i
index|]
operator|=
name|rold
operator|->
name|to
expr_stmt|;
name|prange
argument_list|(
name|rold
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
condition|)
return|return;
if|if
condition|(
name|debug
condition|)
return|return;
name|i
operator|--
expr_stmt|;
name|skip
argument_list|(
name|i
argument_list|,
name|rold
operator|->
name|from
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|skip
argument_list|(
name|i
argument_list|,
name|rold
operator|->
name|to
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*	print the range of line numbers, rold.from  thru rold.to  *	as n1,n2 or n1 */
end_comment

begin_macro
name|prange
argument_list|(
argument|rold
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|range
modifier|*
name|rold
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|rold
operator|->
name|to
operator|<=
name|rold
operator|->
name|from
condition|)
name|printf
argument_list|(
literal|"%da\n"
argument_list|,
name|rold
operator|->
name|from
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|rold
operator|->
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|rold
operator|->
name|to
operator|>
name|rold
operator|->
name|from
operator|+
literal|1
condition|)
name|printf
argument_list|(
literal|",%d"
argument_list|,
name|rold
operator|->
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"c\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*	no difference was reported by diff between file 1(or 2)  *	and file 3, and an artificial dummy difference (trange)  *	must be ginned up to correspond to the change reported  *	in the other file */
end_comment

begin_macro
name|keep
argument_list|(
argument|i
argument_list|,
argument|rold
argument_list|,
argument|rnew
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|range
modifier|*
name|rold
decl_stmt|,
modifier|*
name|rnew
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|delta
expr_stmt|;
name|struct
name|range
name|trange
decl_stmt|;
name|delta
operator|=
name|last
index|[
literal|3
index|]
operator|-
name|last
index|[
name|i
index|]
expr_stmt|;
name|trange
operator|.
name|from
operator|=
name|rnew
operator|->
name|from
operator|-
name|delta
expr_stmt|;
name|trange
operator|.
name|to
operator|=
name|rnew
operator|->
name|to
operator|-
name|delta
expr_stmt|;
name|change
argument_list|(
name|i
argument_list|,
operator|&
name|trange
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*	skip to just befor line number from in file i  *	if "pr" is nonzero, print all skipped stuff  * w	with string pr as a prefix */
end_comment

begin_macro
name|skip
argument_list|(
argument|i
argument_list|,
argument|from
argument_list|,
argument|pr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|j
operator|,
name|n
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|cline
index|[
name|i
index|]
operator|<
name|from
operator|-
literal|1
condition|;
name|n
operator|+=
name|j
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|getline
argument_list|(
name|fp
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|trouble
argument_list|()
expr_stmt|;
if|if
condition|(
name|pr
condition|)
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|pr
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|cline
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/*	return 1 or 0 according as the old range  *	(in file 1) contains exactly the same data  *	as the new range (in file 2) */
end_comment

begin_macro
name|duplicate
argument_list|(
argument|r1
argument_list|,
argument|r2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|range
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|d
expr_stmt|;
specifier|register
name|nchar
expr_stmt|;
name|int
name|nline
decl_stmt|;
if|if
condition|(
name|r1
operator|->
name|to
operator|-
name|r1
operator|->
name|from
operator|!=
name|r2
operator|->
name|to
operator|-
name|r2
operator|->
name|from
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|skip
argument_list|(
literal|0
argument_list|,
name|r1
operator|->
name|from
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|skip
argument_list|(
literal|1
argument_list|,
name|r2
operator|->
name|from
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nchar
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nline
operator|=
literal|0
init|;
name|nline
operator|<
name|r1
operator|->
name|to
operator|-
name|r1
operator|->
name|from
condition|;
name|nline
operator|++
control|)
block|{
do|do
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|getc
argument_list|(
name|fp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
operator|||
name|d
operator|==
operator|-
literal|1
condition|)
name|trouble
argument_list|()
expr_stmt|;
name|nchar
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|d
condition|)
block|{
name|repos
argument_list|(
name|nchar
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
name|repos
argument_list|(
name|nchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|repos
argument_list|(
argument|nchar
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|fseek
argument_list|(
name|fp
index|[
name|i
index|]
argument_list|,
operator|(
name|long
operator|)
operator|-
name|nchar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|trouble
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"diff3: logic error\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*	collect an editing script for later regurgitation */
end_comment

begin_macro
name|edit
argument_list|(
argument|diff
argument_list|,
argument|dup
argument_list|,
argument|j
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|diff
modifier|*
name|diff
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|(
name|dup
operator|+
literal|1
operator|)
operator|&
name|eflag
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|j
operator|)
return|;
name|j
operator|++
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|old
operator|.
name|from
operator|=
name|diff
operator|->
name|old
operator|.
name|from
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|old
operator|.
name|to
operator|=
name|diff
operator|->
name|old
operator|.
name|to
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|new
operator|.
name|from
operator|=
name|de
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|new
operator|.
name|to
operator|+
name|skip
argument_list|(
literal|2
argument_list|,
name|diff
operator|->
name|new
operator|.
name|from
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|de
index|[
name|j
index|]
operator|.
name|new
operator|.
name|to
operator|=
name|de
index|[
name|j
index|]
operator|.
name|new
operator|.
name|from
operator|+
name|skip
argument_list|(
literal|2
argument_list|,
name|diff
operator|->
name|new
operator|.
name|to
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|j
operator|)
return|;
block|}
end_block

begin_comment
comment|/*		regurgitate */
end_comment

begin_macro
name|edscript
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|j
operator|,
name|k
expr_stmt|;
name|char
name|block
index|[
literal|512
index|]
decl_stmt|;
for|for
control|(
name|n
operator|=
name|n
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
control|)
block|{
name|prange
argument_list|(
operator|&
name|de
index|[
name|n
index|]
operator|.
name|old
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
index|[
literal|2
index|]
argument_list|,
operator|(
name|long
operator|)
name|de
index|[
name|n
index|]
operator|.
name|new
operator|.
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|de
index|[
name|n
index|]
operator|.
name|new
operator|.
name|to
operator|-
name|de
index|[
name|n
index|]
operator|.
name|new
operator|.
name|from
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|-=
name|j
control|)
block|{
name|j
operator|=
name|k
operator|>
literal|512
condition|?
literal|512
else|:
name|k
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|j
argument_list|,
name|fp
index|[
literal|2
index|]
argument_list|)
operator|!=
name|j
condition|)
name|trouble
argument_list|()
expr_stmt|;
name|fwrite
argument_list|(
name|block
argument_list|,
literal|1
argument_list|,
name|j
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

