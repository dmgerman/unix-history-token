begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)dnd.c	4.4 (Berkeley) 1/20/81"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * batch queue manager. by Greg Chesson.  Modified to be  * a daemon managing requests to a multiple autodialers, by  * Keith Sklower.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/mx.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_define
define|#
directive|define
name|QSIZE
value|16
end_define

begin_define
define|#
directive|define
name|DSIZE
value|40
end_define

begin_decl_stmt
name|int
name|xd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dndebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we actually run debug = 1 */
end_comment

begin_decl_stmt
name|int
name|nactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number running */
end_comment

begin_decl_stmt
name|int
name|max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowable */
end_comment

begin_decl_stmt
name|int
name|jobnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dialbuf
index|[
name|DSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dp
init|=
name|dialbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|actfile
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mx_leaves
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|rack
decl_stmt|,
name|modem
decl_stmt|;
name|short
name|chan
decl_stmt|;
name|int
name|file
decl_stmt|;
block|}
name|pdevs
index|[]
init|=
block|{
block|{
literal|"/dev/cua0"
block|,
literal|'4'
block|,
literal|'8'
block|}
block|,
comment|/*{"/dev/cua1",'4','1'},*/
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* the second line here is commented out because,    our 1200 baud dialer is being repaired, and if one attempts    to dial with a modem that is not capable, the dialer gets    hung and must be pulled out of the machine */
end_comment

begin_struct
struct|struct
name|actinfo
block|{
name|short
name|index
decl_stmt|;
name|short
name|uid
decl_stmt|;
block|}
name|runq
index|[
name|QSIZE
index|]
struct|,
name|xx
struct|;
end_struct

begin_define
define|#
directive|define
name|INDEX
parameter_list|(
name|x
parameter_list|)
value|((x&0xff00)>>4)
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|cc
expr_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*if (argc<2) 		quit("max jobs?"); 	max = atoi(argv[1]);*/
name|max
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|fork
argument_list|()
condition|)
block|{
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"dnd-child"
argument_list|)
expr_stmt|;
name|xd
operator|=
name|init
argument_list|()
expr_stmt|;
if|if
condition|(
name|xd
operator|<
literal|0
condition|)
name|quit
argument_list|(
literal|"can't make node"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|read
argument_list|(
name|xd
argument_list|,
name|buf
argument_list|,
literal|512
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|unpack
argument_list|(
name|buf
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|short
name|noioctl
init|=
name|M_IOANS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|control
argument_list|(
name|x
argument_list|,
name|cb
argument_list|,
name|cc
argument_list|)
specifier|register
name|char
operator|*
name|cb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|struct
name|chan
modifier|*
name|cp
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|stat
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|end
operator|=
name|cb
operator|+
name|cc
expr_stmt|;
while|while
condition|(
name|cb
operator|<
name|end
condition|)
block|{
name|cmd
operator|=
operator|*
name|cb
operator|++
expr_stmt|;
name|cb
operator|++
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|M_WATCH
case|:
name|uid
operator|=
operator|*
operator|(
operator|(
name|short
operator|*
operator|)
name|cb
operator|)
expr_stmt|;
name|cb
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|putq
argument_list|(
name|x
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|startjob
argument_list|()
expr_stmt|;
break|break;
case|case
name|M_CLOSE
case|:
name|stopjob
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_IOCTL
case|:
name|wctl
argument_list|(
name|x
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|noioctl
argument_list|,
sizeof|sizeof
argument_list|(
name|noioctl
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sgttyb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|startjob
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|x
operator|,
name|stat
expr_stmt|;
if|if
condition|(
name|nactive
operator|>=
name|max
condition|)
return|return;
name|x
operator|=
name|getq
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|stat
operator|=
name|attach
argument_list|(
name|x
argument_list|,
name|xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
operator|-
literal|1
condition|)
return|return;
name|nactive
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"starting to dial on behalf of uid %d\n"
argument_list|,
name|xx
operator|.
name|uid
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dialbuf
expr_stmt|;
block|}
end_block

begin_macro
name|stopjob
argument_list|(
argument|x
argument_list|)
end_macro

begin_block
block|{
name|detach
argument_list|(
name|x
argument_list|,
name|xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|delq
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"channel %d aborted\n"
argument_list|,
name|INDEX
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nactive
operator|--
expr_stmt|;
name|printf
argument_list|(
literal|"channel %d finished\n"
argument_list|,
name|INDEX
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|startjob
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * make mpx node, open accounting file, and initialize queue.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|mx_leaves
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|xd
decl_stmt|;
if|if
condition|(
name|dndebug
operator|==
literal|0
condition|)
name|freopen
argument_list|(
name|stdout
argument_list|,
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|actfile
operator|=
name|fopen
argument_list|(
literal|"/usr/adm/dnacct"
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|"Can't make accouting file"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|QSIZE
init|;
operator|--
name|t
operator|>=
literal|0
condition|;
control|)
name|runq
index|[
name|t
index|]
operator|.
name|uid
operator|=
operator|-
literal|1
expr_stmt|;
name|xd
operator|=
name|mpx
argument_list|(
literal|""
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|xd
operator|<
literal|0
condition|)
name|quit
argument_list|(
literal|"Can't open master mpx node"
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|pdevs
init|;
name|lp
operator|->
name|name
condition|;
name|lp
operator|++
control|)
block|{
name|t
operator|=
name|mpx
argument_list|(
name|lp
operator|->
name|name
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|lp
operator|->
name|name
argument_list|)
expr_stmt|;
name|t
operator|=
name|mpx
argument_list|(
name|lp
operator|->
name|name
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|quit
argument_list|(
literal|"Can't make minor mpx node"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|file
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|join
argument_list|(
name|t
argument_list|,
name|xd
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|quit
argument_list|(
literal|"Can't attach to tree"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"pseudo-device %s assigned channel %x\n"
argument_list|,
name|lp
operator|->
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|lp
operator|->
name|chan
operator|=
name|t
expr_stmt|;
block|}
return|return
operator|(
name|xd
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * unpack an mpx buffer at  * bp of length cc.  */
end_comment

begin_expr_stmt
name|unpack
argument_list|(
name|bp
argument_list|,
name|cc
argument_list|)
specifier|register
name|char
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|struct
name|rh
modifier|*
name|rp
decl_stmt|;
name|end
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|end
condition|)
block|{
name|rp
operator|=
operator|(
expr|struct
name|rh
operator|*
operator|)
name|bp
expr_stmt|;
name|bp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|rh
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|control
argument_list|(
name|rp
operator|->
name|index
argument_list|,
name|bp
argument_list|,
name|rp
operator|->
name|ccount
argument_list|)
expr_stmt|;
block|}
else|else
name|perform
argument_list|(
name|rp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|count
operator|+=
name|rp
operator|->
name|ccount
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|count
operator|&
literal|1
condition|)
name|rp
operator|->
name|count
operator|++
expr_stmt|;
name|bp
operator|+=
name|rp
operator|->
name|count
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* transfer numbers to the unique dialer */
end_comment

begin_expr_stmt
name|perform
argument_list|(
name|rp
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|rh
operator|*
name|rp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|lim
decl_stmt|;
name|long
name|clock
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|mdata
decl_stmt|,
modifier|*
name|tmpt
decl_stmt|,
modifier|*
name|ctime
argument_list|()
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
if|if
condition|(
name|rp
operator|->
name|index
operator|!=
name|xx
operator|.
name|index
condition|)
name|printf
argument_list|(
literal|"phase error: Writing data from chan %x on behalf of chan %x\n"
argument_list|,
name|rp
operator|->
name|index
argument_list|,
name|xx
operator|.
name|index
argument_list|)
expr_stmt|;
name|lim
operator|=
name|rp
operator|->
name|count
operator|+
name|data
expr_stmt|;
name|mdata
operator|=
name|data
expr_stmt|;
while|while
condition|(
name|mdata
operator|<
name|lim
operator|&&
name|dp
operator|<
name|dialbuf
operator|+
name|DSIZE
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|mdata
expr_stmt|;
if|if
condition|(
operator|*
name|mdata
operator|==
literal|'<'
condition|)
block|{
operator|*
name|dp
operator|++
operator|=
literal|0
expr_stmt|;
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tmpt
operator|=
name|ctime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tmpt
index|[
literal|20
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|dialit
argument_list|(
name|dialbuf
argument_list|)
operator|)
operator|==
literal|'A'
condition|)
name|fprintf
argument_list|(
name|actfile
argument_list|,
literal|"%s dialed %s at %s\n"
argument_list|,
name|getpwuid
argument_list|(
name|xx
operator|.
name|uid
argument_list|)
operator|->
name|pw_name
argument_list|,
name|dialbuf
argument_list|,
name|tmpt
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Dialer returns %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|actfile
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dialbuf
expr_stmt|;
name|stopjob
argument_list|(
name|rp
operator|->
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdata
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|quit
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putq
argument_list|(
argument|x
argument_list|,
argument|uid
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|runq
index|[
name|i
index|]
operator|.
name|uid
operator|==
operator|-
literal|1
condition|)
block|{
name|runq
index|[
name|i
index|]
operator|.
name|index
operator|=
name|x
expr_stmt|;
name|runq
index|[
name|i
index|]
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_macro
name|getq
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
operator|,
name|j
operator|,
name|x
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|xx
operator|=
name|runq
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|xx
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|xx
operator|.
name|uid
operator|==
operator|-
literal|1
condition|)
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|runq
index|[
name|i
index|]
operator|.
name|uid
operator|!=
operator|-
literal|1
condition|)
block|{
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|runq
index|[
name|i
index|]
operator|=
name|runq
index|[
name|j
index|]
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|delq
argument_list|(
name|x
argument_list|)
specifier|register
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|runq
index|[
name|i
index|]
operator|.
name|index
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|runq
index|[
name|i
index|]
operator|.
name|index
operator|!=
name|x
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|QSIZE
condition|;
name|j
operator|++
control|)
block|{
name|runq
index|[
name|i
index|]
operator|=
name|runq
index|[
name|j
index|]
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
name|runq
index|[
name|j
index|]
operator|.
name|uid
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|wchan
argument_list|(
name|chan
argument_list|,
name|obuf
argument_list|,
name|count
argument_list|)
specifier|register
name|char
operator|*
name|obuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|wh
name|msg
decl_stmt|;
name|msg
operator|.
name|index
operator|=
name|chan
expr_stmt|;
name|msg
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|msg
operator|.
name|ccount
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|data
operator|=
name|obuf
expr_stmt|;
name|write
argument_list|(
name|xd
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|wctl
argument_list|(
name|chan
argument_list|,
name|obuf
argument_list|,
name|count
argument_list|)
specifier|register
name|char
operator|*
name|obuf
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|wh
name|msg
decl_stmt|;
name|msg
operator|.
name|index
operator|=
name|chan
expr_stmt|;
name|msg
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|ccount
operator|=
name|count
expr_stmt|;
name|msg
operator|.
name|data
operator|=
name|obuf
expr_stmt|;
name|write
argument_list|(
name|xd
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|DN
init|=
literal|"/dev/ttya2"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|pc
parameter_list|(
name|x
parameter_list|)
value|(c = x, write(fd,&c,1))
end_define

begin_define
define|#
directive|define
name|ABORT
value|01
end_define

begin_define
define|#
directive|define
name|SI
value|017
end_define

begin_define
define|#
directive|define
name|STX
value|02
end_define

begin_define
define|#
directive|define
name|ETX
value|03
end_define

begin_define
define|#
directive|define
name|unlike
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)^(b))&0xf)
end_define

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|cntrl
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|dialit
argument_list|(
name|string
argument_list|)
specifier|register
name|char
operator|*
name|string
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|fd
init|=
name|open
argument_list|(
name|DN
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|,
name|cc
decl_stmt|,
modifier|*
name|sanitize
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|mx_leaves
modifier|*
name|lp
init|=
name|pdevs
decl_stmt|;
name|int
name|test
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
literal|'C'
operator|)
return|;
comment|/*if(linebusy()) return('X');*/
name|gtty
argument_list|(
name|fd
argument_list|,
operator|&
name|cntrl
argument_list|)
expr_stmt|;
comment|/* set raw, -echo, 2400 Baud */
name|cntrl
operator|.
name|sg_ispeed
operator|=
name|cntrl
operator|.
name|sg_ospeed
operator|=
name|B2400
expr_stmt|;
name|cntrl
operator|.
name|sg_flags
operator|=
name|RAW
operator||
name|EVENP
operator||
name|ODDP
expr_stmt|;
name|stty
argument_list|(
name|fd
argument_list|,
operator|&
name|cntrl
argument_list|)
expr_stmt|;
name|string
operator|=
name|sanitize
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
literal|'<'
operator|&&
name|string
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|c
operator|=
literal|'U'
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
while|while
condition|(
name|test
operator|=
name|unlike
argument_list|(
name|lp
operator|->
name|chan
argument_list|,
name|xx
operator|.
name|index
argument_list|)
condition|)
if|if
condition|(
name|lp
operator|->
name|name
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to locate dialer, chan = %x\n"
argument_list|,
name|xx
operator|.
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
literal|'K'
operator|)
return|;
block|}
else|else
name|lp
operator|++
expr_stmt|;
name|pc
argument_list|(
name|STX
argument_list|)
expr_stmt|;
name|pc
argument_list|(
name|lp
operator|->
name|rack
argument_list|)
expr_stmt|;
name|pc
argument_list|(
name|lp
operator|->
name|modem
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|string
operator|&&
operator|*
name|string
operator|!=
literal|'<'
condition|;
name|string
operator|++
control|)
name|pc
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
comment|/*for(;*string; string++) pc(*string);*/
name|pc
argument_list|(
name|SI
argument_list|)
expr_stmt|;
name|pc
argument_list|(
name|ETX
argument_list|)
expr_stmt|;
comment|/*if(*string=='<') { 	    c = 'M'; 	    read(fd,&c,1); 	    if(c=='A'); 	}*/
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|c
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'B'
operator|||
name|c
operator|==
literal|'G'
condition|)
block|{
name|pc
argument_list|(
name|ABORT
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|cc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|sanitize
parameter_list|(
name|string
parameter_list|)
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
for|for
control|(
init|;
operator|*
name|string
condition|;
name|string
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|string
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'<'
case|:
operator|*
name|cp
operator|++
operator|=
operator|*
name|string
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
operator|*
name|cp
operator|++
operator|=
literal|'='
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Band-aid for hardware glitch - access forbidded to dialer while line in use */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DZ
init|=
literal|"/dev/cul0"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|jmp_buf
name|handy
decl_stmt|;
end_decl_stmt

begin_macro
name|linebusy
argument_list|()
end_macro

begin_block
block|{
name|void
name|catchit
parameter_list|()
function_decl|;
name|int
name|fd
decl_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|catchit
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handy
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|DZ
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* if we are there the open did not hang, so 		we problem got the line was busy */
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"open succeeded did not hang\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Line in use\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* line busy */
block|}
else|else
comment|/* came in on interrupt */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* line is free, we did hang waiting for Carrier */
block|}
end_block

begin_function
name|void
name|catchit
parameter_list|()
block|{
name|longjmp
argument_list|(
name|handy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

