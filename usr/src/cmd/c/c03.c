begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * C compiler, phase 1  *  *  * Handles processing of declarations,  * except for top-level processing of  * externals.  */
end_comment

begin_include
include|#
directive|include
file|"c0.h"
end_include

begin_comment
comment|/*  * Process a sequence of declaration statements  */
end_comment

begin_macro
name|declist
argument_list|(
argument|sclass
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|sc
operator|,
name|offset
expr_stmt|;
name|struct
name|hshtab
name|typer
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|sclass
expr_stmt|;
while|while
condition|(
name|getkeywords
argument_list|(
operator|&
name|sclass
argument_list|,
operator|&
name|typer
argument_list|)
condition|)
block|{
name|offset
operator|=
name|declare
argument_list|(
name|sclass
argument_list|,
operator|&
name|typer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|sclass
operator|=
name|sc
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|+
name|align
argument_list|(
name|INT
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Read the keywords introducing a declaration statement  * Store back the storage class, and fill in the type  * entry, which looks like a hash table entry.  */
end_comment

begin_macro
name|getkeywords
argument_list|(
argument|scptr
argument_list|,
argument|tptr
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|scptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshtab
modifier|*
name|tptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|skw
operator|,
name|tkw
operator|,
name|longf
expr_stmt|;
name|int
name|o
decl_stmt|,
name|isadecl
decl_stmt|,
name|ismos
decl_stmt|,
name|unsignf
decl_stmt|;
name|isadecl
operator|=
literal|0
expr_stmt|;
name|longf
operator|=
literal|0
expr_stmt|;
name|unsignf
operator|=
literal|0
expr_stmt|;
name|tptr
operator|->
name|htype
operator|=
name|INT
expr_stmt|;
name|tptr
operator|->
name|hstrp
operator|=
name|NULL
expr_stmt|;
name|tptr
operator|->
name|hsubsp
operator|=
name|NULL
expr_stmt|;
name|tkw
operator|=
operator|-
literal|1
expr_stmt|;
name|skw
operator|=
operator|*
name|scptr
expr_stmt|;
name|ismos
operator|=
name|skw
operator|==
name|MOS
operator|||
name|skw
operator|==
name|MOU
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mosflg
operator|=
name|ismos
operator|&&
name|isadecl
expr_stmt|;
name|o
operator|=
name|symbol
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|&&
name|csym
operator|->
name|hclass
operator|==
name|TYPEDEF
operator|&&
name|tkw
operator|<
literal|0
condition|)
block|{
name|tkw
operator|=
name|csym
operator|->
name|htype
expr_stmt|;
name|tptr
operator|->
name|hsubsp
operator|=
name|csym
operator|->
name|hsubsp
expr_stmt|;
name|tptr
operator|->
name|hstrp
operator|=
name|csym
operator|->
name|hstrp
expr_stmt|;
name|isadecl
operator|++
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|o
operator|==
name|KEYW
condition|?
name|cval
else|:
operator|-
literal|1
condition|)
block|{
case|case
name|AUTO
case|:
case|case
name|STATIC
case|:
case|case
name|EXTERN
case|:
case|case
name|REG
case|:
case|case
name|TYPEDEF
case|:
if|if
condition|(
name|skw
operator|&&
name|skw
operator|!=
name|cval
condition|)
block|{
if|if
condition|(
name|skw
operator|==
name|ARG
operator|&&
name|cval
operator|==
name|REG
condition|)
name|cval
operator|=
name|AREG
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Conflict in storage class"
argument_list|)
expr_stmt|;
block|}
name|skw
operator|=
name|cval
expr_stmt|;
break|break;
case|case
name|UNSIGN
case|:
name|unsignf
operator|++
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|longf
operator|++
expr_stmt|;
break|break;
case|case
name|ENUM
case|:
name|strdec
argument_list|(
name|ismos
argument_list|,
name|cval
argument_list|)
expr_stmt|;
name|cval
operator|=
name|INT
expr_stmt|;
goto|goto
name|types
goto|;
case|case
name|UNION
case|:
case|case
name|STRUCT
case|:
name|tptr
operator|->
name|hstrp
operator|=
name|strdec
argument_list|(
name|ismos
argument_list|,
name|cval
argument_list|)
expr_stmt|;
name|cval
operator|=
name|STRUCT
expr_stmt|;
case|case
name|INT
case|:
case|case
name|CHAR
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
name|types
label|:
if|if
condition|(
name|tkw
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Type clash"
argument_list|)
expr_stmt|;
name|tkw
operator|=
name|cval
expr_stmt|;
break|break;
default|default:
name|peeksym
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|isadecl
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tkw
operator|<
literal|0
condition|)
name|tkw
operator|=
name|INT
expr_stmt|;
if|if
condition|(
name|skw
operator|==
literal|0
condition|)
name|skw
operator|=
name|blklev
operator|==
literal|0
condition|?
name|DEFXTRN
else|:
name|AUTO
expr_stmt|;
if|if
condition|(
name|unsignf
condition|)
block|{
if|if
condition|(
name|tkw
operator|==
name|INT
condition|)
name|tkw
operator|=
name|UNSIGN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Misplaced 'unsigned'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|longf
condition|)
block|{
if|if
condition|(
name|tkw
operator|==
name|FLOAT
condition|)
name|tkw
operator|=
name|DOUBLE
expr_stmt|;
elseif|else
if|if
condition|(
name|tkw
operator|==
name|INT
condition|)
name|tkw
operator|=
name|LONG
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Misplaced 'long'"
argument_list|)
expr_stmt|;
block|}
operator|*
name|scptr
operator|=
name|skw
expr_stmt|;
name|tptr
operator|->
name|htype
operator|=
name|tkw
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|isadecl
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Process a structure, union, or enum declaration; a subroutine  * of getkeywords.  */
end_comment

begin_function
name|struct
name|str
modifier|*
name|strdec
parameter_list|(
name|mosf
parameter_list|,
name|kind
parameter_list|)
block|{
specifier|register
name|elsize
operator|,
name|o
expr_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|ssym
decl_stmt|;
name|int
name|savebits
decl_stmt|;
name|struct
name|hshtab
modifier|*
modifier|*
name|savememlist
decl_stmt|;
name|int
name|savenmems
decl_stmt|;
name|struct
name|str
modifier|*
name|strp
decl_stmt|;
name|struct
name|hshtab
modifier|*
name|ds
decl_stmt|;
name|struct
name|hshtab
modifier|*
name|mems
index|[
name|NMEMS
index|]
decl_stmt|;
name|struct
name|hshtab
name|typer
decl_stmt|;
name|int
name|tagkind
decl_stmt|;
if|if
condition|(
name|kind
operator|!=
name|ENUM
condition|)
block|{
name|tagkind
operator|=
name|STRTAG
expr_stmt|;
name|mosflg
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|tagkind
operator|=
name|ENUMTAG
expr_stmt|;
name|ssym
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|NAME
condition|)
block|{
name|ssym
operator|=
name|csym
expr_stmt|;
name|mosflg
operator|=
name|mosf
expr_stmt|;
name|o
operator|=
name|symbol
argument_list|()
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|LBRACE
operator|&&
name|ssym
operator|->
name|hblklev
operator|<
name|blklev
condition|)
name|pushdecl
argument_list|(
name|ssym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|==
literal|0
condition|)
block|{
name|ssym
operator|->
name|hclass
operator|=
name|tagkind
expr_stmt|;
name|ssym
operator|->
name|strp
operator|=
name|gblock
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|strp
argument_list|)
argument_list|)
expr_stmt|;
name|funcbase
operator|=
name|curbase
expr_stmt|;
name|ssym
operator|->
name|strp
operator|->
name|ssize
operator|=
literal|0
expr_stmt|;
name|ssym
operator|->
name|strp
operator|->
name|memlist
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|!=
name|tagkind
condition|)
name|redec
argument_list|()
expr_stmt|;
name|strp
operator|=
name|ssym
operator|->
name|strp
expr_stmt|;
block|}
else|else
block|{
name|strp
operator|=
name|gblock
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|strp
argument_list|)
argument_list|)
expr_stmt|;
name|funcbase
operator|=
name|curbase
expr_stmt|;
name|strp
operator|->
name|ssize
operator|=
literal|0
expr_stmt|;
name|strp
operator|->
name|memlist
operator|=
name|NULL
expr_stmt|;
block|}
name|mosflg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|o
operator|!=
name|LBRACE
condition|)
block|{
if|if
condition|(
name|ssym
operator|==
literal|0
condition|)
goto|goto
name|syntax
goto|;
if|if
condition|(
name|ssym
operator|->
name|hclass
operator|!=
name|tagkind
condition|)
name|error
argument_list|(
literal|"Bad structure/union/enum name"
argument_list|)
expr_stmt|;
name|peeksym
operator|=
name|o
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|defsym
expr_stmt|;
name|mosflg
operator|=
literal|0
expr_stmt|;
name|savebits
operator|=
name|bitoffs
expr_stmt|;
name|savememlist
operator|=
name|memlist
expr_stmt|;
name|savenmems
operator|=
name|nmems
expr_stmt|;
name|memlist
operator|=
name|mems
expr_stmt|;
name|nmems
operator|=
literal|2
expr_stmt|;
name|bitoffs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|ENUM
condition|)
block|{
name|typer
operator|.
name|htype
operator|=
name|INT
expr_stmt|;
name|typer
operator|.
name|hstrp
operator|=
name|strp
expr_stmt|;
name|declare
argument_list|(
name|ENUM
argument_list|,
operator|&
name|typer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|elsize
operator|=
name|declist
argument_list|(
name|kind
operator|==
name|UNION
condition|?
name|MOU
else|:
name|MOS
argument_list|)
expr_stmt|;
name|bitoffs
operator|=
name|savebits
expr_stmt|;
name|defsym
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|strp
operator|->
name|ssize
condition|)
name|error
argument_list|(
literal|"%.8s redeclared"
argument_list|,
name|ssym
operator|->
name|name
argument_list|)
expr_stmt|;
name|strp
operator|->
name|ssize
operator|=
name|elsize
expr_stmt|;
operator|*
name|memlist
operator|++
operator|=
name|NULL
expr_stmt|;
name|strp
operator|->
name|memlist
operator|=
name|gblock
argument_list|(
operator|(
name|memlist
operator|-
name|mems
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|memlist
argument_list|)
argument_list|)
expr_stmt|;
name|funcbase
operator|=
name|curbase
expr_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
operator|&
name|mems
index|[
name|o
index|]
operator|!=
name|memlist
condition|;
name|o
operator|++
control|)
name|strp
operator|->
name|memlist
index|[
name|o
index|]
operator|=
name|mems
index|[
name|o
index|]
expr_stmt|;
name|memlist
operator|=
name|savememlist
expr_stmt|;
name|nmems
operator|=
name|savenmems
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACE
condition|)
goto|goto
name|syntax
goto|;
block|}
return|return
operator|(
name|strp
operator|)
return|;
name|syntax
label|:
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a comma-separated list of declarators  */
end_comment

begin_macro
name|declare
argument_list|(
argument|askw
argument_list|,
argument|tptr
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshtab
modifier|*
name|tptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|int
name|skw
decl_stmt|,
name|isunion
decl_stmt|;
name|skw
operator|=
name|askw
expr_stmt|;
name|isunion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|MOU
condition|)
block|{
name|skw
operator|=
name|MOS
expr_stmt|;
name|isunion
operator|++
expr_stmt|;
name|mosflg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|SEMI
condition|)
block|{
name|o
operator|=
name|length
argument_list|(
name|tptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>
name|offset
condition|)
name|offset
operator|=
name|o
expr_stmt|;
block|}
block|}
do|do
block|{
if|if
condition|(
name|skw
operator|==
name|ENUM
operator|&&
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|RBRACE
condition|)
block|{
name|o
operator|=
name|peeksym
expr_stmt|;
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|o
operator|=
name|decl1
argument_list|(
name|skw
argument_list|,
name|tptr
argument_list|,
name|isunion
condition|?
literal|0
else|:
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isunion
condition|)
block|{
name|o
operator|=
operator|+
name|align
argument_list|(
name|CHAR
argument_list|,
name|o
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|>
name|offset
condition|)
name|offset
operator|=
name|o
expr_stmt|;
block|}
else|else
name|offset
operator|=
operator|+
name|o
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COMMA
condition|)
do|;
if|if
condition|(
name|o
operator|==
name|RBRACE
condition|)
block|{
name|peeksym
operator|=
name|o
expr_stmt|;
name|o
operator|=
name|SEMI
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|!=
name|SEMI
operator|&&
operator|(
name|o
operator|!=
name|RPARN
operator|||
name|skw
operator|!=
name|ARG1
operator|)
condition|)
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process a single declarator  */
end_comment

begin_macro
name|decl1
argument_list|(
argument|askw
argument_list|,
argument|atptr
argument_list|,
argument|offset
argument_list|,
argument|absname
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshtab
modifier|*
name|atptr
decl_stmt|,
modifier|*
name|absname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|t1
decl_stmt|,
name|chkoff
decl_stmt|,
name|a
decl_stmt|,
name|elsize
decl_stmt|;
specifier|register
name|int
name|skw
decl_stmt|;
name|int
name|type
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|dsym
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|tptr
decl_stmt|;
name|struct
name|tdim
name|dim
decl_stmt|;
name|struct
name|field
modifier|*
name|fldp
decl_stmt|;
name|int
modifier|*
name|dp
decl_stmt|;
name|int
name|isinit
decl_stmt|;
name|skw
operator|=
name|askw
expr_stmt|;
name|tptr
operator|=
name|atptr
expr_stmt|;
name|chkoff
operator|=
literal|0
expr_stmt|;
name|mosflg
operator|=
name|skw
operator|==
name|MOS
expr_stmt|;
name|dim
operator|.
name|rank
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|SEMI
operator|||
name|peeksym
operator|==
name|RPARN
operator|)
operator|&&
name|absname
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Filler field 	 */
if|if
condition|(
name|peeksym
operator|==
name|COLON
operator|&&
name|skw
operator|==
name|MOS
condition|)
block|{
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
name|t1
operator|=
name|conexp
argument_list|()
expr_stmt|;
name|elsize
operator|=
name|align
argument_list|(
name|tptr
operator|->
name|htype
argument_list|,
name|offset
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|bitoffs
operator|=
operator|+
name|t1
expr_stmt|;
return|return
operator|(
name|elsize
operator|)
return|;
block|}
name|t1
operator|=
name|getype
argument_list|(
operator|&
name|dim
argument_list|,
name|absname
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tptr
operator|->
name|hsubsp
condition|)
block|{
name|type
operator|=
name|tptr
operator|->
name|htype
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|type
operator|&
name|XTYPE
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|ARRAY
condition|)
name|dim
operator|.
name|dimens
index|[
name|dim
operator|.
name|rank
operator|++
index|]
operator|=
name|tptr
operator|->
name|hsubsp
index|[
name|a
operator|++
index|]
expr_stmt|;
name|type
operator|=
operator|>>
name|TYLEN
expr_stmt|;
block|}
block|}
name|type
operator|=
name|tptr
operator|->
name|htype
operator|&
operator|~
name|TYPE
expr_stmt|;
while|while
condition|(
name|t1
operator|&
name|XTYPE
condition|)
block|{
if|if
condition|(
name|type
operator|&
name|BIGTYPE
condition|)
block|{
name|typov
argument_list|()
expr_stmt|;
name|type
operator|=
name|t1
operator|=
literal|0
expr_stmt|;
block|}
name|type
operator|=
name|type
operator|<<
name|TYLEN
operator||
operator|(
name|t1
operator|&
name|XTYPE
operator|)
expr_stmt|;
name|t1
operator|=
operator|>>
name|TYLEN
expr_stmt|;
block|}
name|type
operator|=
operator||
name|tptr
operator|->
name|htype
operator|&
name|TYPE
expr_stmt|;
if|if
condition|(
name|absname
condition|)
name|defsym
operator|=
name|absname
expr_stmt|;
name|dsym
operator|=
name|defsym
expr_stmt|;
if|if
condition|(
name|dsym
operator|->
name|hblklev
operator|<
name|blklev
condition|)
name|pushdecl
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
if|if
condition|(
name|dim
operator|.
name|rank
operator|==
literal|0
condition|)
name|dsym
operator|->
name|subsp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|dp
operator|=
name|gblock
argument_list|(
name|dim
operator|.
name|rank
operator|*
sizeof|sizeof
argument_list|(
name|dim
operator|.
name|rank
argument_list|)
argument_list|)
expr_stmt|;
name|funcbase
operator|=
name|curbase
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|EXTERN
condition|)
name|maxdecl
operator|=
name|curbase
expr_stmt|;
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
name|dim
operator|.
name|rank
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|t1
operator|=
name|dp
index|[
name|a
index|]
operator|=
name|dim
operator|.
name|dimens
index|[
name|a
index|]
operator|)
operator|&&
operator|(
name|dsym
operator|->
name|htype
operator|&
name|XTYPE
operator|)
operator|==
name|ARRAY
operator|&&
name|dsym
operator|->
name|subsp
index|[
name|a
index|]
operator|&&
name|t1
operator|!=
name|dsym
operator|->
name|subsp
index|[
name|a
index|]
condition|)
name|redec
argument_list|()
expr_stmt|;
block|}
name|dsym
operator|->
name|subsp
operator|=
name|dp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type
operator|&
name|XTYPE
operator|)
operator|==
name|FUNC
condition|)
block|{
if|if
condition|(
name|skw
operator|==
name|AUTO
condition|)
name|skw
operator|=
name|EXTERN
expr_stmt|;
if|if
condition|(
operator|(
name|skw
operator|!=
name|EXTERN
operator|&&
name|skw
operator|!=
name|TYPEDEF
operator|)
operator|&&
name|absname
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Bad func. storage class"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|dsym
operator|->
name|hclass
operator|==
literal|0
operator|||
operator|(
operator|(
name|skw
operator|==
name|ARG
operator|||
name|skw
operator|==
name|AREG
operator|)
operator|&&
name|dsym
operator|->
name|hclass
operator|==
name|ARG1
operator|)
operator|||
operator|(
name|skw
operator|==
name|EXTERN
operator|&&
name|dsym
operator|->
name|hclass
operator|==
name|EXTERN
operator|&&
name|dsym
operator|->
name|htype
operator|==
name|type
operator|)
operator|)
condition|)
if|if
condition|(
name|skw
operator|==
name|MOS
operator|&&
name|dsym
operator|->
name|hclass
operator|==
name|MOS
operator|&&
name|dsym
operator|->
name|htype
operator|==
name|type
condition|)
name|chkoff
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|redec
argument_list|()
expr_stmt|;
goto|goto
name|syntax
goto|;
block|}
if|if
condition|(
name|dsym
operator|->
name|hclass
operator|&&
operator|(
name|dsym
operator|->
name|htype
operator|&
name|TYPE
operator|)
operator|==
name|STRUCT
operator|&&
operator|(
name|type
operator|&
name|TYPE
operator|)
operator|==
name|STRUCT
condition|)
if|if
condition|(
name|dsym
operator|->
name|hstrp
operator|!=
name|tptr
operator|->
name|hstrp
condition|)
block|{
name|error
argument_list|(
literal|"Warning: structure redeclaration"
argument_list|)
expr_stmt|;
name|nerror
operator|--
expr_stmt|;
block|}
name|dsym
operator|->
name|htype
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|tptr
operator|->
name|hstrp
condition|)
name|dsym
operator|->
name|hstrp
operator|=
name|tptr
operator|->
name|hstrp
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|TYPEDEF
condition|)
block|{
name|dsym
operator|->
name|hclass
operator|=
name|TYPEDEF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|absname
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|skw
operator|==
name|ARG1
condition|)
block|{
if|if
condition|(
name|paraml
operator|==
literal|0
condition|)
name|paraml
operator|=
name|dsym
expr_stmt|;
else|else
name|parame
operator|->
name|hoffset
operator|=
name|dsym
expr_stmt|;
name|parame
operator|=
name|dsym
expr_stmt|;
name|dsym
operator|->
name|hclass
operator|=
name|skw
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|elsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|MOS
condition|)
block|{
name|elsize
operator|=
name|length
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peeksym
operator|=
name|symbol
argument_list|()
operator|)
operator|==
name|COLON
condition|)
block|{
name|elsize
operator|=
literal|0
expr_stmt|;
name|peeksym
operator|=
operator|-
literal|1
expr_stmt|;
name|t1
operator|=
name|conexp
argument_list|()
expr_stmt|;
name|a
operator|=
name|align
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsym
operator|->
name|hflag
operator|&
name|FFIELD
condition|)
block|{
if|if
condition|(
name|dsym
operator|->
name|hstrp
operator|->
name|bitoffs
operator|!=
name|bitoffs
operator|||
name|dsym
operator|->
name|hstrp
operator|->
name|flen
operator|!=
name|t1
condition|)
name|redec
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dsym
operator|->
name|hstrp
operator|=
name|gblock
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fldp
argument_list|)
argument_list|)
expr_stmt|;
name|funcbase
operator|=
name|curbase
expr_stmt|;
block|}
name|dsym
operator|->
name|hflag
operator|=
operator||
name|FFIELD
expr_stmt|;
name|dsym
operator|->
name|hstrp
operator|->
name|bitoffs
operator|=
name|bitoffs
expr_stmt|;
name|dsym
operator|->
name|hstrp
operator|->
name|flen
operator|=
name|t1
expr_stmt|;
name|bitoffs
operator|=
operator|+
name|t1
expr_stmt|;
block|}
else|else
name|a
operator|=
name|align
argument_list|(
name|type
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elsize
operator|=
operator|+
name|a
expr_stmt|;
name|offset
operator|=
operator|+
name|a
expr_stmt|;
if|if
condition|(
operator|++
name|nmems
operator|>=
name|NMEMS
condition|)
block|{
name|error
argument_list|(
literal|"Too many structure members"
argument_list|)
expr_stmt|;
name|nmems
operator|=
operator|-
name|NMEMS
operator|/
literal|2
expr_stmt|;
name|memlist
operator|=
operator|-
name|NMEMS
operator|/
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|a
condition|)
operator|*
name|memlist
operator|++
operator|=
operator|&
name|structhole
expr_stmt|;
if|if
condition|(
name|chkoff
operator|&&
name|dsym
operator|->
name|hoffset
operator|!=
name|offset
condition|)
name|redec
argument_list|()
expr_stmt|;
name|dsym
operator|->
name|hoffset
operator|=
name|offset
expr_stmt|;
operator|*
name|memlist
operator|++
operator|=
name|dsym
expr_stmt|;
block|}
if|if
condition|(
name|skw
operator|==
name|REG
condition|)
if|if
condition|(
operator|(
name|dsym
operator|->
name|hoffset
operator|=
name|goodreg
argument_list|(
name|dsym
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|skw
operator|=
name|AUTO
expr_stmt|;
name|dsym
operator|->
name|hclass
operator|=
name|skw
expr_stmt|;
name|isinit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|COMMA
operator|&&
name|a
operator|!=
name|SEMI
operator|&&
name|a
operator|!=
name|RBRACE
condition|)
name|isinit
operator|++
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|ASSIGN
condition|)
name|peeksym
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|skw
operator|==
name|AUTO
condition|)
block|{
comment|/*	if (STAUTO< 0) {	*/
name|autolen
operator|=
operator|-
name|rlength
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|hoffset
operator|=
name|autolen
expr_stmt|;
if|if
condition|(
name|autolen
operator|<
name|maxauto
condition|)
name|maxauto
operator|=
name|autolen
expr_stmt|;
comment|/*	} else { 			*/
comment|/*		dsym->hoffset = autolen;	*/
comment|/*		autolen =+ rlength(dsym);	*/
comment|/*		if (autolen> maxauto)		*/
comment|/*			maxauto = autolen;	*/
comment|/*	}			*/
if|if
condition|(
name|isinit
condition|)
name|cinit
argument_list|(
name|dsym
argument_list|,
literal|0
argument_list|,
name|AUTO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skw
operator|==
name|STATIC
condition|)
block|{
name|dsym
operator|->
name|hoffset
operator|=
name|isn
expr_stmt|;
if|if
condition|(
name|isinit
condition|)
block|{
name|outcode
argument_list|(
literal|"BBN"
argument_list|,
name|DATA
argument_list|,
name|LABEL
argument_list|,
name|isn
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinit
argument_list|(
name|dsym
argument_list|,
literal|1
argument_list|,
name|STATIC
argument_list|)
operator|&
name|ALIGN
condition|)
name|outcode
argument_list|(
literal|"B"
argument_list|,
name|EVEN
argument_list|)
expr_stmt|;
block|}
else|else
name|outcode
argument_list|(
literal|"BBNBN"
argument_list|,
name|BSS
argument_list|,
name|LABEL
argument_list|,
name|isn
operator|++
argument_list|,
name|SSPACE
argument_list|,
name|rlength
argument_list|(
name|dsym
argument_list|)
argument_list|)
expr_stmt|;
name|outcode
argument_list|(
literal|"B"
argument_list|,
name|PROG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skw
operator|==
name|REG
operator|&&
name|isinit
condition|)
name|cinit
argument_list|(
name|dsym
argument_list|,
literal|0
argument_list|,
name|REG
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|skw
operator|==
name|ENUM
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"Illegal enumeration %.8s"
argument_list|,
name|dsym
operator|->
name|name
argument_list|)
expr_stmt|;
name|dsym
operator|->
name|hclass
operator|=
name|ENUMCON
expr_stmt|;
name|dsym
operator|->
name|hoffset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|isinit
condition|)
name|cinit
argument_list|(
name|dsym
argument_list|,
literal|0
argument_list|,
name|ENUMCON
argument_list|)
expr_stmt|;
name|elsize
operator|=
name|dsym
operator|->
name|hoffset
operator|-
name|offset
operator|+
literal|1
expr_stmt|;
block|}
name|prste
argument_list|(
name|dsym
argument_list|)
expr_stmt|;
name|syntax
label|:
return|return
operator|(
name|elsize
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Push down an outer-block declaration  * after redeclaration in an inner block.  */
end_comment

begin_macro
name|pushdecl
argument_list|(
argument|asp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|phshtab
modifier|*
name|asp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|phshtab
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|sp
operator|=
name|asp
expr_stmt|;
name|nsp
operator|=
name|gblock
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nsp
argument_list|)
argument_list|)
expr_stmt|;
name|maxdecl
operator|=
name|funcbase
operator|=
name|curbase
expr_stmt|;
name|cpysymb
argument_list|(
name|nsp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|hclass
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|hflag
operator|=
operator|&
operator|(
name|FKEYW
operator||
name|FMOS
operator|)
expr_stmt|;
name|sp
operator|->
name|htype
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|hoffset
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|hblklev
operator|=
name|blklev
expr_stmt|;
name|sp
operator|->
name|hpdown
operator|=
name|nsp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Copy the non-name part of a symbol  */
end_comment

begin_macro
name|cpysymb
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|phshtab
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|phshtab
modifier|*
name|rs1
decl_stmt|,
modifier|*
name|rs2
decl_stmt|;
name|rs1
operator|=
name|s1
expr_stmt|;
name|rs2
operator|=
name|s2
expr_stmt|;
name|rs1
operator|->
name|hclass
operator|=
name|rs2
operator|->
name|hclass
expr_stmt|;
name|rs1
operator|->
name|hflag
operator|=
name|rs2
operator|->
name|hflag
expr_stmt|;
name|rs1
operator|->
name|htype
operator|=
name|rs2
operator|->
name|htype
expr_stmt|;
name|rs1
operator|->
name|hoffset
operator|=
name|rs2
operator|->
name|hoffset
expr_stmt|;
name|rs1
operator|->
name|hsubsp
operator|=
name|rs2
operator|->
name|hsubsp
expr_stmt|;
name|rs1
operator|->
name|hstrp
operator|=
name|rs2
operator|->
name|hstrp
expr_stmt|;
name|rs1
operator|->
name|hblklev
operator|=
name|rs2
operator|->
name|hblklev
expr_stmt|;
name|rs1
operator|->
name|hpdown
operator|=
name|rs2
operator|->
name|hpdown
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Read a declarator and get the implied type  */
end_comment

begin_macro
name|getype
argument_list|(
argument|adimp
argument_list|,
argument|absname
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tdim
modifier|*
name|adimp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hshtab
modifier|*
name|absname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|hshtab
name|argtype
decl_stmt|;
name|int
name|type
decl_stmt|;
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|struct
name|hshtab
modifier|*
name|ds
decl_stmt|;
specifier|register
name|struct
name|tdim
modifier|*
name|dimp
decl_stmt|;
name|ds
operator|=
name|defsym
expr_stmt|;
name|dimp
operator|=
name|adimp
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|o
operator|=
name|symbol
argument_list|()
condition|)
block|{
case|case
name|TIMES
case|:
name|type
operator|=
name|getype
argument_list|(
name|dimp
argument_list|,
name|absname
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|type
operator|)
return|;
if|if
condition|(
name|type
operator|&
name|BIGTYPE
condition|)
block|{
name|typov
argument_list|()
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|<<
name|TYLEN
operator||
name|PTR
operator|)
return|;
case|case
name|LPARN
case|:
if|if
condition|(
name|absname
operator|==
name|NULL
operator|||
name|nextchar
argument_list|()
operator|!=
literal|')'
condition|)
block|{
name|type
operator|=
name|getype
argument_list|(
name|dimp
argument_list|,
name|absname
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|type
operator|)
return|;
name|ds
operator|=
name|defsym
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RPARN
condition|)
goto|goto
name|syntax
goto|;
goto|goto
name|getf
goto|;
block|}
default|default:
name|peeksym
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|absname
condition|)
block|{
name|defsym
operator|=
name|ds
operator|=
name|absname
expr_stmt|;
name|absname
operator|=
name|NULL
expr_stmt|;
goto|goto
name|getf
goto|;
block|}
break|break;
case|case
name|NAME
case|:
name|defsym
operator|=
name|ds
operator|=
name|csym
expr_stmt|;
name|getf
label|:
switch|switch
condition|(
name|o
operator|=
name|symbol
argument_list|()
condition|)
block|{
case|case
name|LPARN
case|:
if|if
condition|(
name|blklev
operator|==
literal|0
condition|)
block|{
name|blklev
operator|++
expr_stmt|;
name|ds
operator|=
name|defsym
expr_stmt|;
name|declare
argument_list|(
name|ARG1
argument_list|,
operator|&
name|argtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defsym
operator|=
name|ds
expr_stmt|;
name|blklev
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RPARN
condition|)
goto|goto
name|syntax
goto|;
if|if
condition|(
name|type
operator|&
name|BIGTYPE
condition|)
block|{
name|typov
argument_list|()
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
name|type
operator|=
name|type
operator|<<
name|TYLEN
operator||
name|FUNC
expr_stmt|;
goto|goto
name|getf
goto|;
case|case
name|LBRACK
case|:
if|if
condition|(
name|dimp
operator|->
name|rank
operator|>=
literal|5
condition|)
block|{
name|error
argument_list|(
literal|"Rank too large"
argument_list|)
expr_stmt|;
name|dimp
operator|->
name|rank
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACK
condition|)
block|{
name|peeksym
operator|=
name|o
expr_stmt|;
name|cval
operator|=
name|conexp
argument_list|()
expr_stmt|;
name|defsym
operator|=
name|ds
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|symbol
argument_list|()
operator|)
operator|!=
name|RBRACK
condition|)
goto|goto
name|syntax
goto|;
block|}
else|else
block|{
if|if
condition|(
name|dimp
operator|->
name|rank
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Null dimension"
argument_list|)
expr_stmt|;
name|cval
operator|=
literal|0
expr_stmt|;
block|}
name|dimp
operator|->
name|dimens
index|[
name|dimp
operator|->
name|rank
operator|++
index|]
operator|=
name|cval
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|BIGTYPE
condition|)
block|{
name|typov
argument_list|()
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
name|type
operator|=
name|type
operator|<<
name|TYLEN
operator||
name|ARRAY
expr_stmt|;
goto|goto
name|getf
goto|;
block|}
name|peeksym
operator|=
name|o
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
name|syntax
label|:
name|decsyn
argument_list|(
name|o
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * More bits required for type than allowed.  */
end_comment

begin_macro
name|typov
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Type is too complicated"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Enforce alignment restrictions in structures,  * including bit-field considerations.  */
end_comment

begin_macro
name|align
argument_list|(
argument|type
argument_list|,
argument|offset
argument_list|,
argument|aflen
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|a
operator|,
name|t
operator|,
name|flen
expr_stmt|;
name|char
modifier|*
name|ftl
decl_stmt|;
name|flen
operator|=
name|aflen
expr_stmt|;
name|a
operator|=
name|offset
expr_stmt|;
name|t
operator|=
name|type
expr_stmt|;
name|ftl
operator|=
literal|"Field too long"
expr_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|a
operator|=
operator|+
operator|(
name|NBPC
operator|+
name|bitoffs
operator|-
literal|1
operator|)
operator|/
name|NBPC
expr_stmt|;
name|bitoffs
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|t
operator|&
name|XTYPE
operator|)
operator|==
name|ARRAY
condition|)
name|t
operator|=
name|decref
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|CHAR
condition|)
block|{
name|a
operator|=
operator|(
name|a
operator|+
name|ALIGN
operator|)
operator|&
operator|~
name|ALIGN
expr_stmt|;
if|if
condition|(
name|a
operator|>
name|offset
condition|)
name|bitoffs
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flen
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|INT
operator|||
name|type
operator|==
name|UNSIGN
condition|)
block|{
if|if
condition|(
name|flen
operator|>
name|NBPW
condition|)
name|error
argument_list|(
name|ftl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|+
name|bitoffs
operator|>
name|NBPW
condition|)
block|{
name|bitoffs
operator|=
literal|0
expr_stmt|;
name|a
operator|=
operator|+
name|NCPW
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CHAR
condition|)
block|{
if|if
condition|(
name|flen
operator|>
name|NBPC
condition|)
name|error
argument_list|(
name|ftl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|+
name|bitoffs
operator|>
name|NBPC
condition|)
block|{
name|bitoffs
operator|=
literal|0
expr_stmt|;
name|a
operator|=
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"Bad type for field"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|-
name|offset
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Complain about syntax error in declaration  */
end_comment

begin_macro
name|decsyn
argument_list|(
argument|o
argument_list|)
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"Declaration syntax"
argument_list|)
expr_stmt|;
name|errflush
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Complain about a redeclaration  */
end_comment

begin_macro
name|redec
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"%.8s redeclared"
argument_list|,
name|defsym
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Determine if a variable is suitable for storage in  * a register; if so return the register number  */
end_comment

begin_macro
name|goodreg
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshtab
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
name|type
operator|=
name|hp
operator|->
name|htype
expr_stmt|;
comment|/* 	 * Special dispensation for unions 	 */
if|if
condition|(
name|type
operator|==
name|STRUCT
operator|&&
name|length
argument_list|(
name|hp
argument_list|)
operator|<=
name|SZINT
condition|)
name|type
operator|=
name|INT
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|INT
operator|&&
name|type
operator|!=
name|CHAR
operator|&&
name|type
operator|!=
name|UNSIGN
operator|&&
operator|(
name|type
operator|&
name|XTYPE
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|type
operator|&
name|XTYPE
operator|)
operator|>
name|PTR
operator|||
name|regvar
operator|<
literal|3
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|--
name|regvar
operator|)
return|;
block|}
end_block

end_unit

