begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|CONN
end_define

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_define
define|#
directive|define
name|F_NAME
value|0
end_define

begin_define
define|#
directive|define
name|F_TIME
value|1
end_define

begin_define
define|#
directive|define
name|F_LINE
value|2
end_define

begin_define
define|#
directive|define
name|F_SPEED
value|3
end_define

begin_define
define|#
directive|define
name|F_PHONE
value|4
end_define

begin_define
define|#
directive|define
name|F_LOGIN
value|5
end_define

begin_decl_stmt
name|jmp_buf
name|Sjbuf
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INVOKE
parameter_list|(
name|a
parameter_list|,
name|r
parameter_list|)
value|ret = a; if (ret<0) return(r);
end_define

begin_comment
comment|/*******  *	conn(system)  *	char *system;  *  *	conn - place a telephone call to system and  *	login, etc.  *  *	return codes:  *		CF_SYSTEM: don't know system  *		CF_TIME: wrong time to call  *		CF_DIAL: call failed  *		CF_LOGIN: login/password dialog failed  *  *>0  - file no.  -  connect ok  *  */
end_comment

begin_macro
name|conn
argument_list|(
argument|system
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|system
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|,
name|nf
decl_stmt|;
name|int
name|fn
decl_stmt|;
name|char
modifier|*
name|flds
index|[
literal|50
index|]
decl_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"gdial %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
name|INVOKE
argument_list|(
argument|gdial()
argument_list|,
argument|CF_DIAL
argument_list|)
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"finds %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
name|INVOKE
argument_list|(
argument|nf = finds(system, flds)
argument_list|,
argument|nf
argument_list|)
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"getto %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
name|INVOKE
argument_list|(
argument|fn = getto(flds)
argument_list|,
argument|CF_DIAL
argument_list|)
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"login %s\n"
argument_list|,
literal|"called"
argument_list|)
expr_stmt|;
name|INVOKE
argument_list|(
argument|login(nf, flds, fn)
argument_list|,
argument|CF_LOGIN
argument_list|)
return|return
operator|(
name|fn
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	char *  *	lastc(s)	return pointer to last character  *	char *s;  *  */
end_comment

begin_function
name|char
modifier|*
name|lastc
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXDEV
value|10
end_define

begin_define
define|#
directive|define
name|MAXDCH
value|MAXDEV*20
end_define

begin_define
define|#
directive|define
name|MAXCODE
value|30
end_define

begin_define
define|#
directive|define
name|MAXCCH
value|MAXCODE*20
end_define

begin_comment
comment|/* This array tells us about possible acu's, etc. */
end_comment

begin_struct
struct|struct
name|Devices
block|{
name|char
modifier|*
name|D_line
decl_stmt|;
name|char
modifier|*
name|D_acu
decl_stmt|;
name|int
name|D_speed
decl_stmt|;
block|}
name|Devs
index|[
name|MAXDEV
index|]
struct|;
end_struct

begin_decl_stmt
name|char
name|Devbuff
index|[
name|MAXDCH
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|Codes
block|{
name|char
modifier|*
name|C_locs
decl_stmt|;
name|char
modifier|*
name|C_prefix
decl_stmt|;
block|}
name|Dialcodes
index|[
name|MAXCODE
index|]
struct|;
end_struct

begin_decl_stmt
name|char
name|Codebuff
index|[
name|MAXCCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Dcfull
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***  *	gdial()		get device and dial info  *  *	return codes:  0  |  FAIL  */
end_comment

begin_macro
name|gdial
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|flds
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|lt
decl_stmt|;
name|char
modifier|*
name|lb
init|=
name|Devbuff
decl_stmt|;
name|char
modifier|*
name|lc
init|=
name|Codebuff
decl_stmt|;
name|FILE
modifier|*
name|fn
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|struct
name|Devices
modifier|*
name|pd
decl_stmt|;
name|struct
name|Codes
modifier|*
name|pc
decl_stmt|;
if|if
condition|(
name|Dcfull
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fn
operator|=
name|fopen
argument_list|(
name|Devfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fn
operator|!=
name|NULL
argument_list|,
literal|"CAN'T OPEN %s"
argument_list|,
name|Devfile
argument_list|)
expr_stmt|;
for|for
control|(
name|pd
operator|=
name|Devs
init|;
name|fgets
argument_list|(
name|lb
argument_list|,
literal|200
argument_list|,
name|fn
argument_list|)
condition|;
name|pd
operator|++
control|)
block|{
name|lt
operator|=
name|lastc
argument_list|(
name|lb
argument_list|)
expr_stmt|;
name|nr
operator|=
name|getargs
argument_list|(
name|lb
argument_list|,
name|flds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nr
operator|==
literal|3
argument_list|,
literal|"BAD LINE %s"
argument_list|,
name|lb
argument_list|)
expr_stmt|;
name|pd
operator|->
name|D_line
operator|=
name|flds
index|[
literal|0
index|]
expr_stmt|;
name|pd
operator|->
name|D_acu
operator|=
name|flds
index|[
literal|1
index|]
expr_stmt|;
name|pd
operator|->
name|D_speed
operator|=
name|atoi
argument_list|(
name|flds
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|lb
operator|=
name|lt
expr_stmt|;
name|ASSERT
argument_list|(
name|lb
operator|<
name|Devbuff
operator|+
name|MAXDCH
argument_list|,
literal|"TOO LONG %s"
argument_list|,
name|Devbuff
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pd
operator|<
name|Devs
operator|+
name|MAXDEV
argument_list|,
literal|"TOO MANY DEVICES %d"
argument_list|,
name|MAXCODE
argument_list|)
expr_stmt|;
block|}
name|pd
operator|->
name|D_line
operator|=
name|NULL
expr_stmt|;
name|fclose
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pd
operator|>
name|Devs
argument_list|,
literal|"BAD FILE %s"
argument_list|,
name|Devfile
argument_list|)
expr_stmt|;
comment|/* Now dialcodes, same way */
name|fn
operator|=
name|fopen
argument_list|(
name|Dialfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fn
operator|!=
name|NULL
argument_list|,
literal|"CAN'T OPEN %s"
argument_list|,
name|Dialfile
argument_list|)
expr_stmt|;
for|for
control|(
name|pc
operator|=
name|Dialcodes
init|;
name|fgets
argument_list|(
name|lc
argument_list|,
literal|200
argument_list|,
name|fn
argument_list|)
condition|;
name|pc
operator|++
control|)
block|{
name|lt
operator|=
name|lastc
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|nr
operator|=
name|getargs
argument_list|(
name|lc
argument_list|,
name|flds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|==
literal|1
condition|)
name|flds
index|[
name|nr
operator|++
index|]
operator|=
literal|""
expr_stmt|;
name|ASSERT
argument_list|(
name|nr
operator|==
literal|2
argument_list|,
literal|"BAD LINE %s"
argument_list|,
name|lc
argument_list|)
expr_stmt|;
name|pc
operator|->
name|C_locs
operator|=
name|flds
index|[
literal|0
index|]
expr_stmt|;
name|pc
operator|->
name|C_prefix
operator|=
name|flds
index|[
literal|1
index|]
expr_stmt|;
name|lc
operator|=
name|lt
expr_stmt|;
name|ASSERT
argument_list|(
name|lc
operator|<
name|Codebuff
operator|+
name|MAXCCH
argument_list|,
literal|"TOO LONG %s"
argument_list|,
name|Codebuff
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pc
operator|<
name|Dialcodes
operator|+
name|MAXCODE
argument_list|,
literal|"MANY DEVICES %d"
argument_list|,
name|MAXCODE
argument_list|)
expr_stmt|;
block|}
name|pc
operator|->
name|C_locs
operator|=
literal|0
expr_stmt|;
name|fclose
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	ckdev(type, speed, ndev)  *	char *type, *speed;  *	int ndev;  *  *	ckdev  -  return the device number in table Devs for  *	a device with proper attributes.  *  *	return codes:>= 0 (ok)  |  FAIL  */
end_comment

begin_macro
name|ckdev
argument_list|(
argument|type
argument_list|,
argument|speed
argument_list|,
argument|ndev
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|,
modifier|*
name|speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ndev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sp
decl_stmt|,
name|acu
decl_stmt|;
name|struct
name|Devices
modifier|*
name|pd
decl_stmt|;
name|sp
operator|=
name|atoi
argument_list|(
name|speed
argument_list|)
expr_stmt|;
name|acu
operator|=
operator|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"ACU"
argument_list|)
operator|==
name|SAME
operator|)
expr_stmt|;
for|for
control|(
name|pd
operator|=
operator|&
name|Devs
index|[
name|ndev
index|]
init|;
name|pd
operator|->
name|D_line
operator|!=
name|NULL
condition|;
name|pd
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|!=
name|pd
operator|->
name|D_speed
condition|)
continue|continue;
if|if
condition|(
name|acu
operator|&&
operator|(
name|strcmp
argument_list|(
name|pd
operator|->
name|D_acu
argument_list|,
literal|"0"
argument_list|)
operator|!=
name|SAME
operator|)
operator|&&
operator|!
name|mlock
argument_list|(
name|pd
operator|->
name|D_line
argument_list|)
condition|)
return|return
operator|(
name|ndev
operator|=
name|pd
operator|-
name|Devs
operator|)
return|;
if|if
condition|(
operator|!
name|acu
operator|&&
operator|(
name|strcmp
argument_list|(
name|pd
operator|->
name|D_line
argument_list|,
name|type
argument_list|)
operator|==
name|SAME
operator|)
operator|&&
operator|!
name|mlock
argument_list|(
name|type
argument_list|)
condition|)
return|return
operator|(
name|ndev
operator|=
name|pd
operator|-
name|Devs
operator|)
return|;
block|}
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	getto(flds)		connect to remote machine  *	char *flds[];  *  *	return codes:  *>0  -  file number - ok  *		FAIL  -  failed  */
end_comment

begin_macro
name|getto
argument_list|(
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEBUG
argument_list|(
name|F_PHONE
argument_list|,
literal|"call: no. %s "
argument_list|,
name|flds
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"for sys %s "
argument_list|,
name|flds
index|[
name|F_NAME
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
literal|"ACU"
argument_list|)
operator|==
name|SAME
condition|)
return|return
operator|(
name|call
argument_list|(
name|flds
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|direct
argument_list|(
name|flds
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	call(flds)		call remote machine  *	char *flds[];  *  *	"flds" contains the call information (name, date, type, speed,  *	phone no. ...  *	Ndev has the device no.  *  *	return codes:  *>0  -  file number  -  ok  *		FAIL  -  failed  */
end_comment

begin_macro
name|call
argument_list|(
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pno
decl_stmt|,
name|pref
index|[
literal|20
index|]
decl_stmt|,
name|phone
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|dcr
decl_stmt|;
name|struct
name|Codes
modifier|*
name|pc
decl_stmt|;
name|pno
operator|=
name|flds
index|[
name|F_PHONE
index|]
expr_stmt|;
name|s1
operator|=
name|pref
expr_stmt|;
name|s2
operator|=
name|pno
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|s2
argument_list|)
condition|)
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|pc
operator|=
name|Dialcodes
init|;
name|pc
operator|->
name|C_locs
condition|;
name|pc
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|pc
operator|->
name|C_locs
argument_list|,
name|pref
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|s1
operator|=
name|pc
operator|->
name|C_prefix
expr_stmt|;
break|break;
block|}
name|sprintf
argument_list|(
name|phone
argument_list|,
literal|"%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Dial %s\n"
argument_list|,
name|phone
argument_list|)
expr_stmt|;
name|dcr
operator|=
name|dialup
argument_list|(
name|phone
argument_list|,
name|flds
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dcr returned as %d\n"
argument_list|,
name|dcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcr
operator|==
name|FAIL
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
return|return
operator|(
name|dcr
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  file descriptor for call unit  */
end_comment

begin_decl_stmt
name|int
name|Dnf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***  *	dialup(ph, flds)	dial remote machine  *	char *ph;  *	char *flds[];  *  *	return codes:  *		file descriptor  -  succeeded  *		FAIL  -  failed  */
end_comment

begin_macro
name|dialup
argument_list|(
argument|ph
argument_list|,
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|,
name|dnname
index|[
literal|20
index|]
decl_stmt|,
name|phone
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|Devices
modifier|*
name|pd
decl_stmt|;
name|int
name|nw
decl_stmt|,
name|lt
decl_stmt|,
name|pid
decl_stmt|,
name|dcf
decl_stmt|,
name|ndev
decl_stmt|;
specifier|extern
name|int
name|Error
decl_stmt|;
extern|extern alarmtr(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_for
for|for
control|(
name|ndev
operator|=
literal|0
init|;
condition|;
name|ndev
operator|++
control|)
block|{
name|ndev
operator|=
name|ckdev
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
name|flds
index|[
name|F_SPEED
index|]
argument_list|,
name|ndev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndev
operator|<
literal|0
condition|)
block|{
name|logent
argument_list|(
literal|"AVAILABLE DEVICE"
argument_list|,
literal|"NO"
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"NO AVAILABLE DEVICE %s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|pd
operator|=
operator|&
name|Devs
index|[
name|ndev
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|dnname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|pd
operator|->
name|D_acu
argument_list|)
expr_stmt|;
comment|/*  open call unit  */
name|Dnf
operator|=
name|open
argument_list|(
name|dnname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dnf
operator|>=
literal|0
condition|)
break|break;
name|delock
argument_list|(
name|pd
operator|->
name|D_line
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|pd
operator|->
name|D_line
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sprintf
argument_list|(
name|phone
argument_list|,
literal|"%s%s"
argument_list|,
name|ph
argument_list|,
name|ACULAST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dc - %s, "
argument_list|,
name|dcname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"acu - %s\n"
argument_list|,
name|dnname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"DN write %s\n"
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DIALUP DN write"
argument_list|,
literal|"TIMEOUT"
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Dnf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|nw
operator|=
name|write
argument_list|(
name|Dnf
argument_list|,
name|phone
argument_list|,
name|lt
operator|=
name|strlen
argument_list|(
name|phone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nw
operator|!=
name|lt
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"ACU write %s\n"
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DIALUP ACU write"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ACU write ok%s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/*  open line - will return on carrier */
end_comment

begin_expr_stmt
name|dcf
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"dcf is %d\n"
argument_list|,
name|dcf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dcf
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Line open %s\n"
argument_list|,
literal|"failed"
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"DIALUP LINE open"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|ioctl
argument_list|(
name|dcf
argument_list|,
name|TIOCHPCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nw
operator|=
name|wait
argument_list|(
operator|&
name|lt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fixline
argument_list|(
name|dcf
argument_list|,
name|pd
operator|->
name|D_speed
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Forked %d "
argument_list|,
name|pid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Wait got %d "
argument_list|,
name|nw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Status %o\n"
argument_list|,
name|lt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lt
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|dcf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_if

begin_return
return|return
operator|(
name|dcf
operator|)
return|;
end_return

begin_comment
unit|}
comment|/***  *	clsacu()	close call unit  *  *	return codes:  none  */
end_comment

begin_expr_stmt
unit|clsacu
operator|(
operator|)
block|{
if|if
condition|(
name|Dnf
operator|>
literal|0
condition|)
block|{
name|close
argument_list|(
name|Dnf
argument_list|)
expr_stmt|;
name|Dnf
operator|=
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return;
end_return

begin_comment
unit|}
comment|/***  *	direct(flds)	connect to hardware line  *	char *flds[];  *  *	return codes:  *>0  -  file number  -  ok  *		FAIL  -  failed  */
end_comment

begin_expr_stmt
unit|direct
operator|(
name|flds
operator|)
name|char
operator|*
name|flds
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|dcr
decl_stmt|,
name|ndev
decl_stmt|;
name|char
name|dcname
index|[
literal|20
index|]
decl_stmt|;
name|ndev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ndev
operator|=
name|ckdev
argument_list|(
name|flds
index|[
name|F_LINE
index|]
argument_list|,
name|flds
index|[
name|F_SPEED
index|]
argument_list|,
name|ndev
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|logent
argument_list|(
literal|"DEVICE"
argument_list|,
literal|"NOT AVAILABLE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|dcname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|Devs
index|[
name|ndev
index|]
operator|.
name|D_line
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|dcr
operator|=
name|open
argument_list|(
name|dcname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* read/write */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcr
operator|<
literal|0
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fixline
argument_list|(
name|dcr
argument_list|,
name|Devs
index|[
name|ndev
index|]
operator|.
name|D_speed
argument_list|)
expr_stmt|;
return|return
operator|(
name|dcr
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXC
value|300
end_define

begin_comment
comment|/***  *	finds(sysnam, flds)	set system attribute vector  *	char *sysnam, *flds[];  *  *	return codes:  *>0  -  number of arguments in vector - succeeded  *		CF_SYSTEM  -  system name not found  *		CF_TIME  -  wrong time to call  */
end_comment

begin_macro
name|finds
argument_list|(
argument|sysnam
argument_list|,
argument|flds
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sysnam
decl_stmt|,
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fsys
decl_stmt|;
specifier|static
name|char
name|info
index|[
name|MAXC
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|fnp
decl_stmt|;
name|int
name|na
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
for|for
control|(
name|fnp
operator|=
name|Sysfiles
init|;
operator|*
name|fnp
operator|!=
name|NULL
operator|&&
operator|!
name|fnd
condition|;
name|fnp
operator|++
control|)
block|{
name|fsys
operator|=
name|fopen
argument_list|(
operator|*
name|fnp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsys
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
operator|!
name|fnd
operator|&&
operator|(
name|fgets
argument_list|(
name|info
argument_list|,
name|MAXC
argument_list|,
name|fsys
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|na
operator|=
name|getargs
argument_list|(
name|info
argument_list|,
name|flds
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
name|sysnam
argument_list|,
name|flds
index|[
name|F_NAME
index|]
argument_list|)
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fsys
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fnd
operator|==
literal|0
condition|)
return|return
operator|(
name|CF_SYSTEM
operator|)
return|;
comment|/* format of fields 	 *	0 name; 	 *	1 time 	 *	2 acu/hardwired 	 *	3 speed 	 *	etc 	 */
if|if
condition|(
name|ifdate
argument_list|(
name|flds
index|[
name|F_TIME
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Wrong time to call %s\n"
argument_list|,
name|sysnam
argument_list|)
expr_stmt|;
name|logent
argument_list|(
name|sysnam
argument_list|,
literal|"WRONG TIME TO CALL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CF_TIME
operator|)
return|;
block|}
return|return
operator|(
name|na
operator|)
return|;
block|}
end_block

begin_comment
comment|/***  *	login(nf, flds, dcr)		do log conversation  *	char *flds[];  *	int nf;  *  *	return codes:  0  |  FAIL  */
end_comment

begin_macro
name|login
argument_list|(
argument|nf
argument_list|,
argument|flds
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flds
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nf
decl_stmt|,
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|want
decl_stmt|,
modifier|*
name|altern
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|int
name|k
decl_stmt|,
name|ok
decl_stmt|;
name|ASSERT
argument_list|(
name|nf
operator|>
literal|4
argument_list|,
literal|"TOO FEW LOG FIELDS %d"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|F_LOGIN
init|;
name|k
operator|<
name|nf
condition|;
name|k
operator|+=
literal|2
control|)
block|{
name|want
operator|=
name|flds
index|[
name|k
index|]
expr_stmt|;
name|ok
operator|=
name|FAIL
expr_stmt|;
while|while
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
name|altern
operator|=
name|index
argument_list|(
name|want
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|altern
operator|!=
name|NULL
condition|)
operator|*
name|altern
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"wanted %s "
argument_list|,
name|want
argument_list|)
expr_stmt|;
name|ok
operator|=
name|expect
argument_list|(
name|want
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"got %s\n"
argument_list|,
name|ok
condition|?
literal|"?"
else|:
literal|"that"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|altern
operator|==
name|NULL
condition|)
block|{
name|logent
argument_list|(
literal|"LOGIN"
argument_list|,
literal|"FAILED"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|want
operator|=
name|index
argument_list|(
name|altern
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|want
operator|!=
name|NULL
condition|)
operator|*
name|want
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sendthem
argument_list|(
name|altern
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sendthem
argument_list|(
name|flds
index|[
name|k
operator|+
literal|1
index|]
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_struct
struct|struct
name|sg_spds
block|{
name|int
name|sp_val
decl_stmt|,
name|sp_name
decl_stmt|;
block|}
name|spds
index|[]
init|=
block|{
block|{
literal|300
block|,
name|B300
block|}
block|,
block|{
literal|1200
block|,
name|B1200
block|}
block|,
block|{
literal|4800
block|,
name|B4800
block|}
block|,
block|{
literal|9600
block|,
name|B9600
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/***  *	fixline(tty, spwant)	set speed/echo/mode...  *	int tty, spwant;  *  *	return codes:  none  */
end_comment

begin_macro
name|fixline
argument_list|(
argument|tty
argument_list|,
argument|spwant
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tty
decl_stmt|,
name|spwant
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sgttyb
name|ttbuf
decl_stmt|;
name|struct
name|sg_spds
modifier|*
name|ps
decl_stmt|;
name|int
name|speed
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
name|ps
operator|=
name|spds
init|;
name|ps
operator|->
name|sp_val
condition|;
name|ps
operator|++
control|)
if|if
condition|(
name|ps
operator|->
name|sp_val
operator|==
name|spwant
condition|)
name|speed
operator|=
name|ps
operator|->
name|sp_name
expr_stmt|;
name|ASSERT
argument_list|(
name|speed
operator|>=
literal|0
argument_list|,
literal|"BAD SPEED %d"
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_flags
operator||=
operator|(
name|ANYP
operator||
name|RAW
operator|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|ECHO
operator||
name|ALLDELAY
operator|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_ispeed
operator|=
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|speed
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Speed: want %d "
argument_list|,
name|spwant
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"use %o "
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ps %d\n"
argument_list|,
name|ps
operator|-
name|spds
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|>=
literal|0
argument_list|,
literal|"RETURN FROM STTY %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCHPCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCEXCL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_define
define|#
directive|define
name|MR
value|300
end_define

begin_decl_stmt
name|int
name|Error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***  *	expect(str, fn)	look for expected string  *	char *str;  *  *	return codes:  *		0  -  found  *		FAIL  -  lost line or too many characters read  *		some character  -  timed out  */
end_comment

begin_macro
name|expect
argument_list|(
argument|str
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|rdvec
index|[
name|MR
index|]
decl_stmt|;
extern|extern alarmtr(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|char
modifier|*
name|rp
init|=
name|rdvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nextch
init|=
literal|0
decl_stmt|,
name|kr
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"\"\""
argument_list|)
operator|==
name|SAME
condition|)
return|return
operator|(
literal|0
operator|)
return|;
end_if

begin_expr_stmt
operator|*
name|rp
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|setjmp
argument_list|(
name|Sjbuf
argument_list|)
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarmtr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|notin
argument_list|(
name|str
argument_list|,
name|rdvec
argument_list|)
condition|)
block|{
name|alarm
argument_list|(
name|MAXCHARTIME
argument_list|)
expr_stmt|;
name|kr
operator|=
name|read
argument_list|(
name|fn
argument_list|,
operator|&
name|nextch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kr
operator|<=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"kr - %d\n"
argument_list|,
name|kr
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"lost line kr - %d, "
argument_list|,
name|kr
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"fn - %d\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|logent
argument_list|(
literal|"LOGIN"
argument_list|,
literal|"LOST LINE"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|nextch
operator|&
literal|0177
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%c"
argument_list|,
name|c
operator|>
literal|040
condition|?
name|c
else|:
literal|'_'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|rp
operator|=
name|nextch
operator|&
literal|0177
operator|)
operator|!=
literal|'\0'
condition|)
name|rp
operator|++
expr_stmt|;
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rp
operator|>=
name|rdvec
operator|+
name|MR
condition|)
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
end_while

begin_expr_stmt
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/***  *	alarmtr()  -  catch alarm routine for "expect".  */
end_comment

begin_expr_stmt
unit|alarmtr
operator|(
operator|)
block|{
name|longjmp
argument_list|(
name|Sjbuf
argument_list|,
literal|1
argument_list|)
block|; }
comment|/***  *	sendthem(str, fn)	send line of login sequence  *	char *str;  *  *	return codes:  none  */
name|sendthem
argument_list|(
argument|str
argument_list|,
argument|fn
argument_list|)
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|nw
decl_stmt|,
name|ns
decl_stmt|;
name|int
name|nulls
decl_stmt|;
if|if
condition|(
name|prefix
argument_list|(
literal|"BREAK"
argument_list|,
name|str
argument_list|)
condition|)
block|{
name|sscanf
argument_list|(
operator|&
name|str
index|[
literal|5
index|]
argument_list|,
literal|"%1d"
argument_list|,
operator|&
name|nulls
argument_list|)
expr_stmt|;
if|if
condition|(
name|nulls
operator|<=
literal|0
operator|||
name|nulls
operator|>
literal|10
condition|)
name|nulls
operator|=
literal|3
expr_stmt|;
comment|/* send break */
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s,"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%d\n"
argument_list|,
name|nulls
argument_list|)
expr_stmt|;
name|genbrk
argument_list|(
name|fn
argument_list|,
name|Bspeed
argument_list|,
name|nulls
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"EOT"
argument_list|)
operator|==
name|SAME
condition|)
block|{
name|write
argument_list|(
name|fn
argument_list|,
name|EOTMSG
argument_list|,
name|strlen
argument_list|(
name|EOTMSG
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
operator|!=
name|SAME
condition|)
block|{
name|nw
operator|=
name|write
argument_list|(
name|fn
argument_list|,
name|str
argument_list|,
name|ns
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nw
operator|==
name|ns
argument_list|,
literal|"BAD WRITE $s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|fn
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	genbrk(fn)	send equivalent to break  *  *	return codes;  none  */
end_comment

begin_macro
name|genbrk
argument_list|(
argument|fn
argument_list|,
argument|bspeed
argument_list|,
argument|bnulls
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fn
decl_stmt|,
name|bspeed
decl_stmt|,
name|bnulls
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sgttyb
name|ttbuf
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|sospeed
decl_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"ioctl ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|sospeed
operator|=
name|ttbuf
operator|.
name|sg_ospeed
expr_stmt|;
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|bspeed
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|5
argument_list|,
literal|"ioctl ret %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fn
argument_list|,
literal|"\0\0\0\0\0\0\0\0\0\0\0\0"
argument_list|,
name|bnulls
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|>
literal|0
argument_list|,
literal|"BAD WRITE genbrk %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ttbuf
operator|.
name|sg_ospeed
operator|=
name|sospeed
expr_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fn
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fn
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|>
literal|0
argument_list|,
literal|"BAD WRITE genbrk %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"sent BREAK nulls - %d\n"
argument_list|,
name|bnulls
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/***  *	notin(sh, lg)	check for occurrence of substring "sh"  *	char *sh, *lg;  *  *	return codes:  *		0  -  found the string  *		1  -  not in the string  */
end_comment

begin_macro
name|notin
argument_list|(
argument|sh
argument_list|,
argument|lg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sh
decl_stmt|,
modifier|*
name|lg
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|lg
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|prefix
argument_list|(
name|sh
argument_list|,
name|lg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|lg
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******  *	ifdate(s)  *	char *s;  *  *	ifdate  -  this routine will check a string (s)  *	like "MoTu0800-1730" to see if the present  *	time is within the given limits.  *  *	String alternatives:  *		Wk - Mo thru Fr  *		zero or one time means all day  *		Any - any day  *  *	return codes:  *		0  -  not within limits  *		1  -  within limits  */
end_comment

begin_macro
name|ifdate
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|days
index|[]
init|=
block|{
literal|"Su"
block|,
literal|"Mo"
block|,
literal|"Tu"
block|,
literal|"We"
block|,
literal|"Th"
block|,
literal|"Fr"
block|,
literal|"Sa"
block|,
literal|0
block|}
decl_stmt|;
name|long
name|clock
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tl
decl_stmt|,
name|th
decl_stmt|,
name|tn
decl_stmt|,
name|dayok
init|=
literal|0
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|days
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prefix
argument_list|(
name|days
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
condition|)
if|if
condition|(
name|tp
operator|->
name|tm_wday
operator|==
name|i
condition|)
name|dayok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prefix
argument_list|(
literal|"Wk"
argument_list|,
name|s
argument_list|)
condition|)
if|if
condition|(
name|tp
operator|->
name|tm_wday
operator|>=
literal|1
operator|&&
name|tp
operator|->
name|tm_wday
operator|<=
literal|5
condition|)
name|dayok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prefix
argument_list|(
literal|"Any"
argument_list|,
name|s
argument_list|)
condition|)
name|dayok
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dayok
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|i
operator|=
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%d-%d"
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|th
argument_list|)
expr_stmt|;
name|tn
operator|=
name|tp
operator|->
name|tm_hour
operator|*
literal|100
operator|+
name|tp
operator|->
name|tm_min
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|tn
operator|>=
name|tl
operator|&&
name|tn
operator|<=
name|th
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

