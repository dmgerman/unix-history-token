begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)mail.c	4.2	5/8/81"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DELIVERMAIL
value|"/etc/delivermail"
end_define

begin_comment
comment|/*copylet flags */
end_comment

begin_comment
comment|/*remote mail, add rmtmsg */
end_comment

begin_define
define|#
directive|define
name|REMOTE
value|1
end_define

begin_comment
comment|/* zap header and trailing empty line */
end_comment

begin_define
define|#
directive|define
name|ZAP
value|3
end_define

begin_define
define|#
directive|define
name|ORDINARY
value|2
end_define

begin_define
define|#
directive|define
name|FORWARD
value|4
end_define

begin_define
define|#
directive|define
name|LSIZE
value|256
end_define

begin_define
define|#
directive|define
name|MAXLET
value|300
end_define

begin_comment
comment|/* maximum number of letters */
end_comment

begin_define
define|#
directive|define
name|MAILMODE
value|(~0644)
end_define

begin_comment
comment|/* mode of created mail */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DELIVERMAIL
end_ifndef

begin_define
define|#
directive|define
name|RMAIL
value|"/usr/net/bin/sendberkmail"
end_define

begin_define
define|#
directive|define
name|LOCNAM1
value|"csvax"
end_define

begin_define
define|#
directive|define
name|LOCNAM2
value|"ucbvax"
end_define

begin_define
define|#
directive|define
name|LOCNAM3
value|"vax"
end_define

begin_define
define|#
directive|define
name|LOCNAM4
value|"v"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|line
index|[
name|LSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|resp
index|[
name|LSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|let
block|{
name|long
name|adr
decl_stmt|;
name|char
name|change
decl_stmt|;
block|}
name|let
index|[
name|MAXLET
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|nlet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|lfil
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|iop
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|lettmp
index|[]
init|=
literal|"/tmp/maXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|maildir
index|[]
init|=
literal|"/usr/spool/mail/"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mailfile
index|[]
init|=
literal|"/usr/spool/mail/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dead
index|[]
init|=
literal|"dead.letter"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|thissys
init|=
name|sysname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|netname
init|=
literal|"vax"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|forwmsg
index|[]
init|=
literal|" forwarded\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|tmpf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|malf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|my_name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|changed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|forward
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|from
index|[]
init|=
literal|"From "
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|ftell
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|delete
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|flgf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flgp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hseqno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rmail
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|char
name|sobuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|sobuf
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|my_name
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|my_name
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|my_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|pwent
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
operator|==
name|NULL
condition|)
name|my_name
operator|=
literal|"???"
expr_stmt|;
else|else
name|my_name
operator|=
name|pwent
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
name|done
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|setsig
argument_list|(
name|i
argument_list|,
name|delete
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: cannot open %s for writing\n"
argument_list|,
name|lettmp
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
name|rmail
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
comment|/* no favors for rmail*/
operator|(
name|argc
operator|==
literal|1
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|!
name|any
argument_list|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|"rhd"
argument_list|)
operator|)
condition|)
name|printmail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|sendmail
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|setsig
argument_list|(
argument|i
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|any
argument_list|(
name|c
argument_list|,
name|str
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|str
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|str
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|printmail
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|flg
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|print
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|getarg
argument_list|()
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|cat
argument_list|(
name|mailfile
argument_list|,
name|maildir
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|mailfile
argument_list|,
operator|&
name|statb
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|strcat
argument_list|(
name|mailfile
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|mailfile
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|argc
operator|>
literal|1
condition|;
name|argv
operator|++
operator|,
name|argc
operator|--
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'q'
condition|)
name|delflg
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
name|flgp
operator|++
expr_stmt|;
name|delflg
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|argc
operator|>=
literal|3
condition|)
block|{
name|strcpy
argument_list|(
name|mailfile
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
name|forward
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
name|forward
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: unknown option %c\n"
argument_list|,
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"No mail.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lock
argument_list|(
name|mailfile
argument_list|)
expr_stmt|;
name|copymt
argument_list|(
name|malf
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|print
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlet
condition|;
control|)
block|{
name|j
operator|=
name|forward
condition|?
name|i
else|:
name|nlet
operator|-
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
block|{
name|print
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|print
condition|)
name|copylet
argument_list|(
name|j
argument_list|,
name|stdout
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|print
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flgp
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|resp
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|resp
index|[
literal|0
index|]
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage\n"
argument_list|)
expr_stmt|;
case|case
literal|'?'
case|:
name|print
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"q\tquit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"x\texit without changing mail\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"p\tprint\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"s[file]\tsave (default mbox)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"w[file]\tsame without header\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-\tprint previous\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"d\tdelete\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+\tnext (no delete)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"m user\tmail to user\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"! cmd\texecute cmd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'n'
case|:
case|case
literal|'\n'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|changed
operator|=
literal|0
expr_stmt|;
case|case
literal|'q'
case|:
goto|goto
name|donep
goto|;
case|case
literal|'p'
case|:
break|break;
case|case
literal|'^'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
operator|--
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
case|case
literal|'s'
case|:
name|flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|!=
literal|'\n'
operator|&&
name|resp
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"illegal\n"
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|resp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
name|cat
argument_list|(
name|resp
operator|+
literal|1
argument_list|,
name|p
argument_list|,
literal|"/mbox"
argument_list|)
expr_stmt|;
else|else
name|cat
argument_list|(
name|resp
operator|+
literal|1
argument_list|,
literal|""
argument_list|,
literal|"mbox"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|resp
operator|+
literal|1
init|;
operator|(
name|p
operator|=
name|getarg
argument_list|(
name|lfil
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|malf
operator|=
name|fopen
argument_list|(
name|lfil
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: cannot append to %s\n"
argument_list|,
name|lfil
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
continue|continue;
block|}
name|copylet
argument_list|(
name|j
argument_list|,
name|malf
argument_list|,
name|resp
index|[
literal|0
index|]
operator|==
literal|'w'
condition|?
name|ZAP
else|:
name|ORDINARY
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flg
condition|)
name|print
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
name|flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|resp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"invalid command\n"
argument_list|)
expr_stmt|;
name|flg
operator|++
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|p
operator|=
name|resp
operator|+
literal|1
init|;
operator|(
name|p
operator|=
name|getarg
argument_list|(
name|lfil
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|!
name|sendrmt
argument_list|(
name|j
argument_list|,
name|lfil
argument_list|,
literal|"/bin/mail"
argument_list|)
condition|)
comment|/* couldn't send it */
name|flg
operator|++
expr_stmt|;
if|if
condition|(
name|flg
condition|)
name|print
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
name|system
argument_list|(
name|resp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"!\n"
argument_list|)
expr_stmt|;
name|print
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|let
index|[
name|j
index|]
operator|.
name|change
operator|=
literal|'d'
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|resp
index|[
literal|1
index|]
operator|==
literal|'q'
condition|)
goto|goto
name|donep
goto|;
break|break;
block|}
block|}
name|donep
label|:
if|if
condition|(
name|changed
condition|)
name|copyback
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|copyback
argument_list|()
end_macro

begin_comment
comment|/* copy temp or whatever back to /usr/spool/mail */
end_comment

begin_block
block|{
specifier|register
name|i
operator|,
name|n
operator|,
name|c
expr_stmt|;
name|int
name|new
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|lock
argument_list|(
name|mailfile
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|mailfile
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_size
operator|!=
name|let
index|[
name|nlet
index|]
operator|.
name|adr
condition|)
block|{
comment|/* new mail has arrived */
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: can't re-read %s\n"
argument_list|,
name|mailfile
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|fseek
argument_list|(
name|malf
argument_list|,
name|let
index|[
name|nlet
index|]
operator|.
name|adr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|tmpf
argument_list|,
name|let
index|[
name|nlet
index|]
operator|.
name|adr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|malf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|let
index|[
operator|++
name|nlet
index|]
operator|.
name|adr
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|new
operator|=
literal|1
expr_stmt|;
block|}
name|malf
operator|=
name|fopen
argument_list|(
name|mailfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: can't rewrite %s\n"
argument_list|,
name|lfil
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlet
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|let
index|[
name|i
index|]
operator|.
name|change
operator|!=
literal|'d'
condition|)
block|{
name|copylet
argument_list|(
name|i
argument_list|,
name|malf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"new mail arrived\n"
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|copymt
argument_list|(
argument|f1
argument_list|,
argument|f2
argument_list|)
end_macro

begin_comment
comment|/* copy mail (f1) to temp (f2) */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|nextadr
decl_stmt|;
name|nlet
operator|=
name|nextadr
operator|=
literal|0
expr_stmt|;
name|let
index|[
literal|0
index|]
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|f1
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isfrom
argument_list|(
name|line
argument_list|)
condition|)
name|let
index|[
name|nlet
operator|++
index|]
operator|.
name|adr
operator|=
name|nextadr
expr_stmt|;
name|nextadr
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
name|let
index|[
name|nlet
index|]
operator|.
name|adr
operator|=
name|nextadr
expr_stmt|;
comment|/* last plus 1 */
block|}
end_block

begin_macro
name|copylet
argument_list|(
argument|n
argument_list|,
argument|f
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|,
name|k
decl_stmt|;
name|fseek
argument_list|(
name|tmpf
argument_list|,
name|let
index|[
name|n
index|]
operator|.
name|adr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|let
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|adr
operator|-
name|let
index|[
name|n
index|]
operator|.
name|adr
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
operator|&&
operator|(
name|ch
operator|=
name|fgetc
argument_list|(
name|tmpf
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|type
operator|!=
name|ZAP
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|REMOTE
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" remote from %s\n"
argument_list|,
name|thissys
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|FORWARD
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
name|forwmsg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ORDINARY
condition|)
name|fputc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|k
operator|--
operator|>
literal|1
condition|)
name|fputc
argument_list|(
name|ch
operator|=
name|fgetc
argument_list|(
name|tmpf
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ZAP
operator|||
name|ch
operator|!=
literal|'\n'
condition|)
name|fputc
argument_list|(
name|fgetc
argument_list|(
name|tmpf
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|isfrom
argument_list|(
name|lp
argument_list|)
specifier|register
name|char
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|from
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|lp
operator|++
operator|!=
operator|*
name|p
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|sendmail
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|truename
index|[
literal|100
index|]
decl_stmt|;
name|int
name|first
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|gaver
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DELIVERMAIL
name|char
modifier|*
name|newargv
index|[
literal|1000
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|int
name|dflag
decl_stmt|;
name|dflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"puke\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|argv
operator|,
name|ap
operator|=
name|newargv
operator|+
literal|1
init|;
operator|(
operator|*
name|ap
operator|=
operator|*
name|vp
operator|++
operator|)
operator|!=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ap
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'d'
condition|)
name|dflag
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dflag
condition|)
block|{
comment|/* give it to delivermail, rah rah! */
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|ap
operator|=
name|newargv
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|rmail
condition|)
operator|*
name|ap
operator|--
operator|=
literal|"-s"
expr_stmt|;
operator|*
name|ap
operator|=
literal|"-delivermail"
expr_stmt|;
name|execv
argument_list|(
name|DELIVERMAIL
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|DELIVERMAIL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DELIVERMAIL
name|truename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * When we fall out of this, argv[1] should be first name, 	 * argc should be number of names + 1. 	 */
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|argc
operator|--
expr_stmt|;
switch|switch
condition|(
name|cp
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|gaver
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|truename
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmpn
argument_list|(
literal|"From"
argument_list|,
name|line
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
name|hseqno
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DELIVERMAIL
case|case
literal|'d'
case|:
break|break;
endif|#
directive|endif
endif|DELIVERMAIL
default|default:
name|usage
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|gaver
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|truename
argument_list|,
name|my_name
argument_list|)
expr_stmt|;
comment|/* 	if (argc> 4&& strcmp(argv[1], "-r") == 0) { 		strcpy(truename, argv[2]); 		argc -= 2; 		argv += 2; 		fgets(line, LSIZE, stdin); 		if (strcmpn("From", line, 4) == 0) 			line[0] = '\0'; 	} else 		strcpy(truename, my_name); 	*/
name|time
argument_list|(
operator|&
name|iop
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmpf
argument_list|,
literal|"%s%s %s"
argument_list|,
name|from
argument_list|,
name|truename
argument_list|,
name|ctime
argument_list|(
operator|&
name|iop
argument_list|)
argument_list|)
expr_stmt|;
name|iop
operator|=
name|ftell
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|flgf
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|first
operator|=
literal|1
init|;
condition|;
name|first
operator|=
literal|0
control|)
block|{
if|if
condition|(
name|first
operator|&&
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|!
name|first
operator|&&
name|fgets
argument_list|(
name|line
argument_list|,
name|LSIZE
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|isfrom
argument_list|(
name|line
argument_list|)
condition|)
name|fputs
argument_list|(
literal|">"
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|flgf
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|tmpf
argument_list|)
expr_stmt|;
name|nlet
operator|=
literal|1
expr_stmt|;
name|let
index|[
literal|0
index|]
operator|.
name|adr
operator|=
literal|0
expr_stmt|;
name|let
index|[
literal|1
index|]
operator|.
name|adr
operator|=
name|ftell
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
if|if
condition|(
name|flgf
condition|)
return|return;
name|tmpf
operator|=
name|fopen
argument_list|(
name|lettmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: cannot reopen %s for reading\n"
argument_list|,
name|lettmp
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|send
argument_list|(
literal|0
argument_list|,
operator|*
operator|++
name|argv
argument_list|,
name|truename
argument_list|)
condition|)
name|error
operator|++
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fopen
argument_list|(
name|dead
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: cannot open %s\n"
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
return|return;
block|}
name|copylet
argument_list|(
literal|0
argument_list|,
name|malf
argument_list|,
name|ZAP
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Mail saved in %s\n"
argument_list|,
name|dead
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sendrmt
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|rcmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rcmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|rmf
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|rsys
index|[
literal|64
index|]
decl_stmt|,
name|cmd
index|[
literal|64
index|]
decl_stmt|;
specifier|register
name|local
operator|,
name|pid
expr_stmt|;
name|int
name|sts
decl_stmt|;
name|local
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'^'
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'!'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"researc"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|rsys
argument_list|,
literal|"research"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|!=
literal|'!'
condition|)
operator|--
name|name
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'!'
condition|)
name|name
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|rsys
init|;
operator|*
name|name
operator|!=
literal|'!'
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|name
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|local
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|local
operator|&&
operator|*
name|name
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|local
operator|&&
operator|*
name|rsys
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"null name\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|skip
label|:
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mail: can't create proc for remote\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pid
condition|)
block|{
while|while
condition|(
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|wait
argument_list|(
operator|&
name|sts
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|!
name|sts
operator|)
return|;
block|}
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s %s"
argument_list|,
name|rcmd
argument_list|,
name|rsys
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|index
argument_list|(
name|name
operator|+
literal|1
argument_list|,
literal|'!'
argument_list|)
condition|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"uux - %s!rmail \\(%s\\)"
argument_list|,
name|rsys
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"uux - %s!rmail %s"
argument_list|,
name|rsys
argument_list|,
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rmf
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|copylet
argument_list|(
name|n
argument_list|,
name|rmf
argument_list|,
name|local
condition|?
operator|!
name|strcmp
argument_list|(
name|rcmd
argument_list|,
literal|"/bin/mail"
argument_list|)
condition|?
name|FORWARD
else|:
name|ORDINARY
else|:
name|REMOTE
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|rmf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|DELIVERMAIL
end_ifndef

begin_comment
comment|/*  * Send mail on the Berkeley network.  * Sorry Bill, sendrmt() is so awful we just gave up.  */
end_comment

begin_macro
name|sendberkmail
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|fromaddr
argument_list|)
end_macro

begin_decl_stmt
name|char
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|fromaddr
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmd
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|cmdf
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s -h %d -f %s -t %s"
argument_list|,
name|RMAIL
argument_list|,
name|hseqno
argument_list|,
name|fromaddr
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmdf
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|RMAIL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|copylet
argument_list|(
name|n
argument_list|,
name|cmdf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|cmdf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|9
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: mail [ -f ] people . . .\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|send
argument_list|(
argument|n
argument_list|,
argument|name
argument_list|,
argument|fromaddr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fromaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|file
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|mask
expr_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|;
name|struct
name|stat
name|statb
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|f
decl_stmt|;
ifndef|#
directive|ifndef
name|DELIVERMAIL
name|stripfx
argument_list|(
name|LOCNAM1
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|stripfx
argument_list|(
name|LOCNAM2
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|stripfx
argument_list|(
name|LOCNAM3
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|stripfx
argument_list|(
name|LOCNAM4
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|':'
condition|)
name|name
operator|++
expr_stmt|;
comment|/* skip colon in to-name */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'^'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* if(*p == ':') return(sendrmt(n, name, RMAIL)); */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
return|return
operator|(
name|sendberkmail
argument_list|(
name|n
argument_list|,
name|name
argument_list|,
name|fromaddr
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"msgs"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sendrmt
argument_list|(
name|n
argument_list|,
literal|"-s"
argument_list|,
literal|"/usr/ucb/msgs"
argument_list|)
operator|)
return|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'^'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
operator|||
operator|*
name|p
operator|==
literal|'^'
condition|)
return|return
operator|(
name|sendrmt
argument_list|(
name|n
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: can't send to %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cat
argument_list|(
name|file
argument_list|,
name|maildir
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statb
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|strcat
argument_list|(
name|file
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|umask
argument_list|(
name|MAILMODE
argument_list|)
expr_stmt|;
name|malf
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|malf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"mail: cannot append to %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lock
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|chown
argument_list|(
name|file
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
block|{
name|f
operator|=
name|open
argument_list|(
literal|"/dev/mail"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s@%d\n"
argument_list|,
name|name
argument_list|,
name|ftell
argument_list|(
name|malf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|copylet
argument_list|(
name|n
argument_list|,
name|malf
argument_list|,
name|ORDINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|malf
argument_list|)
expr_stmt|;
name|unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|delete
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
name|setsig
argument_list|(
name|i
argument_list|,
name|delete
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delflg
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Lock the specified mail file by setting the file mailfile.lock.  * We must, of course, be careful to unlink the lock file by a call  * to unlock before we stop.  The algorithm used here is to see if  * the lock exists, and if it does, to check its modify time.  If it  * is older than 30 seconds, we assume error and set our own file.  * Otherwise, we wait for 5 seconds and try again.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|maillock
init|=
literal|".lock"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lock suffix for mailname */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lockname
init|=
literal|"/usr/spool/mail/tmXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|locktmp
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Usable lock temporary */
end_comment

begin_decl_stmt
name|char
name|curlock
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last used name of lock */
end_comment

begin_decl_stmt
name|int
name|locked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To note that we locked it */
end_comment

begin_macro
name|lock
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|long
name|curtime
decl_stmt|;
name|int
name|statfailed
decl_stmt|;
if|if
condition|(
name|locked
operator|||
name|flgf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|strcpy
argument_list|(
name|curlock
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|curlock
argument_list|,
name|maillock
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|locktmp
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|locktmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|locktmp
argument_list|)
expr_stmt|;
name|statfailed
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|f
operator|=
name|lock1
argument_list|(
name|locktmp
argument_list|,
name|curlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|locked
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|curlock
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|statfailed
operator|++
operator|>
literal|5
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|statfailed
operator|=
literal|0
expr_stmt|;
name|time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|curtime
operator|<
name|sbuf
operator|.
name|st_ctime
operator|+
literal|30
condition|)
block|{
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unlink
argument_list|(
name|curlock
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Remove the mail lock, and note that we no longer  * have it locked.  */
end_comment

begin_macro
name|unlock
argument_list|()
end_macro

begin_block
block|{
name|unlink
argument_list|(
name|curlock
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Attempt to set the lock by creating the temporary file,  * then doing a link/unlink.  If it fails, return -1 else 0  */
end_comment

begin_macro
name|lock1
argument_list|(
argument|tempfile
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
name|tempfile
index|[]
decl_stmt|,
name|name
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|creat
argument_list|(
name|tempfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|tempfile
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|unlink
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|done
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|locked
condition|)
name|unlock
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|lettmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|locktmp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|to
argument_list|,
argument|from1
argument_list|,
argument|from2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from1
decl_stmt|,
modifier|*
name|from2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|from1
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from1
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|from2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|to
index|[
name|j
operator|++
index|]
operator|=
name|from2
index|[
name|i
index|]
expr_stmt|;
name|to
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|getarg
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
comment|/* copy p... into s, update p */
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|p
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|DELIVERMAIL
end_ifndef

begin_comment
comment|/* 	stripfx(prefix string, pointer to string)  	takes a ptr to string and compares it to prefix string. 	may be called multiple times */
end_comment

begin_macro
name|stripfx
argument_list|(
argument|pfx
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|pfx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|*
name|name
decl_stmt|;
while|while
condition|(
operator|*
name|pfx
operator|&&
operator|(
operator|*
name|cp
operator|==
operator|*
name|pfx
operator|||
operator|*
name|cp
operator|==
name|toupper
argument_list|(
operator|*
name|pfx
argument_list|)
operator|)
condition|)
name|cp
operator|++
operator|,
name|pfx
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|':'
operator|||
operator|*
name|pfx
operator|!=
literal|0
condition|)
return|return;
operator|*
name|name
operator|=
name|cp
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

