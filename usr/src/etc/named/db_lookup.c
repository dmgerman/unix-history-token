begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1986 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)db_lookup.c	4.15 (Berkeley) 6/18/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Table lookup routines.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|"db.h"
end_include

begin_decl_stmt
name|struct
name|hashbuf
modifier|*
name|hashtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root hash table */
end_comment

begin_decl_stmt
name|struct
name|hashbuf
modifier|*
name|fcachetab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table of cache read from file */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|ddt
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * Lookup 'name' and return a pointer to the namebuf;  * NULL otherwise. If 'insert', insert name into tables.  * Wildcard lookups are handled.  */
end_comment

begin_function
name|struct
name|namebuf
modifier|*
name|nlookup
parameter_list|(
name|name
parameter_list|,
name|htpp
parameter_list|,
name|fname
parameter_list|,
name|insert
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|hashbuf
modifier|*
modifier|*
name|htpp
decl_stmt|;
name|char
modifier|*
modifier|*
name|fname
decl_stmt|;
name|int
name|insert
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|hval
decl_stmt|;
specifier|register
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|parent
init|=
name|NULL
decl_stmt|;
name|htp
operator|=
operator|*
name|htpp
expr_stmt|;
name|hval
operator|=
literal|0
expr_stmt|;
operator|*
name|fname
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|parent
operator|=
name|np
operator|=
name|nlookup
argument_list|(
name|cp
argument_list|,
name|htpp
argument_list|,
name|fname
argument_list|,
name|insert
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|fname
operator|!=
name|cp
condition|)
return|return
operator|(
name|np
operator|)
return|;
if|if
condition|(
operator|(
name|htp
operator|=
name|np
operator|->
name|n_hash
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|insert
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|np
operator|->
name|n_dname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|fname
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
name|htp
operator|=
name|savehash
argument_list|(
operator|(
expr|struct
name|hashbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|htp
expr_stmt|;
block|}
operator|*
name|htpp
operator|=
name|htp
expr_stmt|;
break|break;
block|}
name|hval
operator|<<=
name|HASHSHIFT
expr_stmt|;
name|hval
operator|+=
name|c
operator|&
name|HASHMASK
expr_stmt|;
block|}
name|c
operator|=
operator|*
operator|--
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Lookup this label in current hash table. 	 */
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
name|hval
operator|%
name|htp
operator|->
name|h_size
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
comment|/* Note: at this point, if np->n_data is NULL, we could be in 		   one of two situations: Either we have come across a name 		   for which all the RRs have been (dynamically) deleted, or 		   else we have come across a name which has no RRs 		   associated with it because it is just a place holder 		   (e.g., EDU).  In the former case, we would like to delete 		   the namebuf, since it is no longer of use, but in the 		   latter case we need to hold on to it, so future lookups 		   that depend on it don't fail.  The only way I can see of 		   doing this is to always leave the namebufs around 		   (although then the memory usage continues to grow whenever 		   names are added, and can never shrink back down completely 		   when all their associated RRs are deleted). */
endif|#
directive|endif
endif|ALLOW_UPDATES
if|if
condition|(
name|np
operator|->
name|n_hashval
operator|==
name|hval
operator|&&
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|np
operator|->
name|n_dname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|fname
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|insert
condition|)
block|{
comment|/* 		 * look for wildcard in this hash table 		 */
name|hval
operator|=
operator|(
literal|'*'
operator|&
name|HASHMASK
operator|)
operator|%
name|htp
operator|->
name|h_size
expr_stmt|;
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
name|hval
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|np
operator|->
name|n_dname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|fname
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
block|}
operator|*
name|cp
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|parent
operator|)
return|;
block|}
name|np
operator|=
name|savename
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_parent
operator|=
name|parent
expr_stmt|;
name|np
operator|->
name|n_hashval
operator|=
name|hval
expr_stmt|;
name|hval
operator|%=
name|htp
operator|->
name|h_size
expr_stmt|;
name|np
operator|->
name|n_next
operator|=
name|htp
operator|->
name|h_tab
index|[
name|hval
index|]
expr_stmt|;
name|htp
operator|->
name|h_tab
index|[
name|hval
index|]
operator|=
name|np
expr_stmt|;
comment|/* increase hash table size */
if|if
condition|(
operator|++
name|htp
operator|->
name|h_cnt
operator|>
name|htp
operator|->
name|h_size
operator|*
literal|2
condition|)
block|{
operator|*
name|htpp
operator|=
name|savehash
argument_list|(
name|htp
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htp
operator|==
name|hashtab
condition|)
name|hashtab
operator|=
operator|*
name|htpp
expr_stmt|;
else|else
name|fcachetab
operator|=
operator|*
name|htpp
expr_stmt|;
block|}
else|else
name|parent
operator|->
name|n_hash
operator|=
operator|*
name|htpp
expr_stmt|;
name|htp
operator|=
operator|*
name|htpp
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|fname
operator|=
name|name
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Does the data record match the class and type?  */
end_comment

begin_expr_stmt
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|databuf
operator|*
name|dp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"match(0x%x, %d, %d) %d, %d\n"
argument_list|,
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|type
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

