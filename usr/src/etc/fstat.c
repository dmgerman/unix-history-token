begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1987 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fstat.c	5.13 (Berkeley) 6/18/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  *  fstat   */
end_comment

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/text.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmac.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ULTRIX
end_ifdef

begin_comment
comment|/* UFS -> GFS */
end_comment

begin_define
define|#
directive|define
name|inode
value|gnode
end_define

begin_define
define|#
directive|define
name|x_iptr
value|x_gptr
end_define

begin_define
define|#
directive|define
name|i_dev
value|g_dev
end_define

begin_define
define|#
directive|define
name|i_number
value|g_number
end_define

begin_define
define|#
directive|define
name|i_mode
value|g_mode
end_define

begin_define
define|#
directive|define
name|i_size
value|g_size
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|N_KMEM
value|"/dev/kmem"
end_define

begin_define
define|#
directive|define
name|N_MEM
value|"/dev/mem"
end_define

begin_define
define|#
directive|define
name|N_SWAP
value|"/dev/drum"
end_define

begin_define
define|#
directive|define
name|N_UNIX
value|"/vmunix"
end_define

begin_define
define|#
directive|define
name|TEXT
value|-2
end_define

begin_define
define|#
directive|define
name|WD
value|-1
end_define

begin_typedef
typedef|typedef
struct|struct
name|devs
block|{
name|struct
name|devs
modifier|*
name|next
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|inum
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|DEVS
typedef|;
end_typedef

begin_decl_stmt
name|DEVS
modifier|*
name|devs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|X_PROC
value|0
block|{
literal|"_Usrptmap"
block|}
block|,
define|#
directive|define
name|X_USRPTMA
value|1
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|X_NPROC
value|2
block|{
literal|"_usrpt"
block|}
block|,
define|#
directive|define
name|X_USRPT
value|3
block|{
literal|""
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|mproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|Usrptma
decl_stmt|,
modifier|*
name|usrpt
decl_stmt|;
end_decl_stmt

begin_union
union|union
block|{
name|struct
name|user
name|user
decl_stmt|;
name|char
name|upages
index|[
name|UPAGES
index|]
index|[
name|NBPG
index|]
decl_stmt|;
block|}
name|user
union|;
end_union

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fflg
decl_stmt|,
name|vflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kmem
decl_stmt|,
name|mem
decl_stmt|,
name|nproc
decl_stmt|,
name|swap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|uname
decl_stmt|;
end_decl_stmt

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|passwd
decl_stmt|;
specifier|register
name|int
name|pflg
decl_stmt|,
name|pid
decl_stmt|,
name|uflg
decl_stmt|,
name|uid
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwnam
argument_list|()
decl_stmt|,
modifier|*
name|getpwuid
argument_list|()
decl_stmt|;
name|long
name|lgetw
parameter_list|()
function_decl|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|pflg
operator|=
name|uflg
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"p:u:v"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'p'
case|:
if|if
condition|(
name|pflg
operator|++
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|optarg
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"fstat: -p option requires a process id.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|pid
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|uflg
operator|++
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|passwd
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown uid\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|uid
operator|=
name|passwd
operator|->
name|pw_uid
expr_stmt|;
name|uname
operator|=
name|passwd
operator|->
name|pw_name
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* undocumented: print read error messages */
name|vflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|argv
operator|+=
name|optind
operator|)
condition|)
block|{
for|for
control|(
init|;
operator|*
name|argv
condition|;
operator|++
name|argv
control|)
block|{
if|if
condition|(
name|getfname
argument_list|(
operator|*
name|argv
argument_list|)
condition|)
name|fflg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fflg
condition|)
comment|/* file(s) specified, but none accessable */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|openfiles
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlist
argument_list|(
name|N_UNIX
argument_list|,
name|nl
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|nl
index|[
literal|0
index|]
operator|.
name|n_type
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No namelist\n"
argument_list|,
name|N_UNIX
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Usrptma
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPTMA
index|]
operator|.
name|n_value
expr_stmt|;
name|usrpt
operator|=
operator|(
expr|struct
name|pte
operator|*
operator|)
name|nl
index|[
name|X_USRPT
index|]
operator|.
name|n_value
expr_stmt|;
name|nproc
operator|=
operator|(
name|int
operator|)
name|lgetw
argument_list|(
operator|(
name|off_t
operator|)
name|nl
index|[
name|X_NPROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
name|lgetw
argument_list|(
operator|(
name|off_t
operator|)
name|nl
index|[
name|X_PROC
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|size
operator|=
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mproc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fstat: out of space.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mproc
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
name|rerr1
argument_list|(
literal|"proc table"
argument_list|,
name|N_KMEM
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"USER\t CMD\t      PID    FD\tDEVICE\tINODE\t  SIZE TYPE%s\n"
argument_list|,
name|fflg
condition|?
literal|" NAME"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nproc
operator|--
condition|;
operator|++
name|mproc
control|)
block|{
if|if
condition|(
name|mproc
operator|->
name|p_stat
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pflg
operator|&&
name|mproc
operator|->
name|p_pid
operator|!=
name|pid
condition|)
continue|continue;
if|if
condition|(
name|uflg
condition|)
block|{
if|if
condition|(
name|mproc
operator|->
name|p_uid
operator|!=
name|uid
condition|)
continue|continue;
block|}
else|else
name|uname
operator|=
operator|(
name|passwd
operator|=
name|getpwuid
argument_list|(
name|mproc
operator|->
name|p_uid
argument_list|)
operator|)
condition|?
name|passwd
operator|->
name|pw_name
else|:
literal|"unknown"
expr_stmt|;
if|if
condition|(
name|mproc
operator|->
name|p_stat
operator|!=
name|SZOMB
operator|&&
name|getu
argument_list|()
operator|==
literal|0
condition|)
continue|continue;
name|dotext
argument_list|()
expr_stmt|;
name|readf
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|getu
argument_list|()
block|{ 	struct
name|pte
operator|*
name|pteaddr
block|,
name|apte
block|; 	struct
name|pte
name|arguutl
index|[
name|UPAGES
operator|+
name|CLSIZE
index|]
block|;
specifier|register
name|int
name|i
block|;
name|int
name|ncl
block|;
if|if
condition|(
operator|(
name|mproc
operator|->
name|p_flag
operator|&
name|SLOAD
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|swap
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|swap
argument_list|,
operator|(
name|off_t
operator|)
name|dtob
argument_list|(
name|mproc
operator|->
name|p_swaddr
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|swap
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|user
operator|.
name|user
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fstat: can't read u for pid %d from %s\n"
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|N_SWAP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_expr_stmt
unit|} 	pteaddr
operator|=
operator|&
name|Usrptma
index|[
name|btokmx
argument_list|(
name|mproc
operator|->
name|p_p0br
argument_list|)
operator|+
name|mproc
operator|->
name|p_szpt
operator|-
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|pteaddr
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|apte
argument_list|,
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|apte
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fstat: can't read indir pte to get u for pid %d from %s\n"
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|N_SWAP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|off_t
operator|)
name|ctob
argument_list|(
name|apte
operator|.
name|pg_pfnum
operator|+
literal|1
argument_list|)
operator|-
operator|(
name|UPAGES
operator|+
name|CLSIZE
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pte
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arguutl
argument_list|,
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|arguutl
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"fstat: can't read page table for u of pid %d from %s\n"
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|N_KMEM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|ncl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|+
name|NBPG
operator|*
name|CLSIZE
operator|-
literal|1
operator|)
operator|/
operator|(
name|NBPG
operator|*
name|CLSIZE
operator|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|ncl
operator|>=
literal|0
condition|)
block|{
name|i
operator|=
name|ncl
operator|*
name|CLSIZE
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|mem
argument_list|,
operator|(
name|off_t
operator|)
name|ctob
argument_list|(
name|arguutl
index|[
name|CLSIZE
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|mem
argument_list|,
name|user
operator|.
name|upages
index|[
name|i
index|]
argument_list|,
name|CLSIZE
operator|*
name|NBPG
argument_list|)
operator|!=
name|CLSIZE
operator|*
name|NBPG
condition|)
block|{
name|printf
argument_list|(
literal|"fstat: can't read page %u of u of pid %d from %s\n"
argument_list|,
name|arguutl
index|[
name|CLSIZE
operator|+
name|i
index|]
operator|.
name|pg_pfnum
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|,
name|N_MEM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_while

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_macro
unit|}  static
name|dotext
argument_list|()
end_macro

begin_block
block|{
name|struct
name|text
name|text
decl_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|mproc
operator|->
name|p_textp
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|text
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|text
argument_list|)
condition|)
block|{
name|rerr1
argument_list|(
literal|"text table"
argument_list|,
name|N_KMEM
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|text
operator|.
name|x_flag
condition|)
name|itrans
argument_list|(
name|DTYPE_INODE
argument_list|,
name|text
operator|.
name|x_iptr
argument_list|,
name|TEXT
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|itrans
argument_list|(
argument|ftype
argument_list|,
argument|g
argument_list|,
argument|fno
argument_list|)
name|int
name|ftype
operator|,
name|fno
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|inode
modifier|*
name|g
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if ftype is inode */
end_comment

begin_block
block|{
name|struct
name|inode
name|inode
decl_stmt|;
name|dev_t
name|idev
decl_stmt|;
name|char
modifier|*
name|comm
decl_stmt|,
modifier|*
name|itype
argument_list|()
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* set by devmatch() on a match */
if|if
condition|(
name|g
operator|||
name|fflg
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|g
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inode
argument_list|,
sizeof|sizeof
argument_list|(
name|inode
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|inode
argument_list|)
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|g
argument_list|,
literal|"inode"
argument_list|)
expr_stmt|;
return|return;
block|}
name|idev
operator|=
name|inode
operator|.
name|i_dev
expr_stmt|;
if|if
condition|(
name|fflg
operator|&&
operator|!
name|devmatch
argument_list|(
name|idev
argument_list|,
name|inode
operator|.
name|i_number
argument_list|,
operator|&
name|name
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
name|mproc
operator|->
name|p_pid
operator|==
literal|0
condition|)
name|comm
operator|=
literal|"swapper"
expr_stmt|;
elseif|else
if|if
condition|(
name|mproc
operator|->
name|p_pid
operator|==
literal|2
condition|)
name|comm
operator|=
literal|"pagedaemon"
expr_stmt|;
else|else
name|comm
operator|=
name|user
operator|.
name|user
operator|.
name|u_comm
expr_stmt|;
name|printf
argument_list|(
literal|"%-8.8s %-10.10s %5d  "
argument_list|,
name|uname
argument_list|,
name|comm
argument_list|,
name|mproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fno
condition|)
block|{
case|case
name|WD
case|:
name|printf
argument_list|(
literal|"  wd"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXT
case|:
name|printf
argument_list|(
literal|"text"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%4d"
argument_list|,
name|fno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"* (deallocated)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ftype
condition|)
block|{
case|case
name|DTYPE_INODE
case|:
name|printf
argument_list|(
literal|"\t%2d, %2d\t%5lu\t%6ld\t%3s %s\n"
argument_list|,
name|major
argument_list|(
name|inode
operator|.
name|i_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|inode
operator|.
name|i_dev
argument_list|)
argument_list|,
name|inode
operator|.
name|i_number
argument_list|,
name|inode
operator|.
name|i_mode
operator|==
name|IFSOCK
condition|?
literal|0
else|:
name|inode
operator|.
name|i_size
argument_list|,
name|itype
argument_list|(
name|inode
operator|.
name|i_mode
argument_list|)
argument_list|,
name|name
condition|?
name|name
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTYPE_SOCKET
case|:
name|socktrans
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
name|g
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DTYPE_PORT
case|case
name|DTYPE_PORT
case|:
name|printf
argument_list|(
literal|"* (fifo / named pipe)\n"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"* (unknown file type)\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|itype
parameter_list|(
name|mode
parameter_list|)
name|u_short
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFCHR
case|:
return|return
operator|(
literal|"chr"
operator|)
return|;
case|case
name|IFDIR
case|:
return|return
operator|(
literal|"dir"
operator|)
return|;
case|case
name|IFBLK
case|:
return|return
operator|(
literal|"blk"
operator|)
return|;
case|case
name|IFREG
case|:
return|return
operator|(
literal|"reg"
operator|)
return|;
case|case
name|IFLNK
case|:
return|return
operator|(
literal|"lnk"
operator|)
return|;
case|case
name|IFSOCK
case|:
return|return
operator|(
literal|"soc"
operator|)
return|;
default|default:
return|return
operator|(
literal|"unk"
operator|)
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_expr_stmt
specifier|static
name|socktrans
argument_list|(
argument|sock
argument_list|)
expr|struct
name|socket
operator|*
name|sock
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|stypename
index|[]
init|=
block|{
literal|"unused"
block|,
comment|/* 0 */
literal|"stream"
block|,
comment|/* 1 */
literal|"dgram"
block|,
comment|/* 2 */
literal|"raw"
block|,
comment|/* 3 */
literal|"rdm"
block|,
comment|/* 4 */
literal|"seqpak"
comment|/* 5 */
block|}
decl_stmt|;
define|#
directive|define
name|STYPEMAX
value|5
name|struct
name|socket
name|so
decl_stmt|;
name|struct
name|protosw
name|proto
decl_stmt|;
name|struct
name|domain
name|dom
decl_stmt|;
name|struct
name|inpcb
name|inpcb
decl_stmt|;
name|struct
name|unpcb
name|unpcb
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|dname
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
comment|/* fill in socket */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|sock
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|sock
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fill in protosw entry */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|so
operator|.
name|so_proto
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|proto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|protosw
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|protosw
argument_list|)
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_proto
argument_list|,
literal|"protosw"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fill in domain */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|proto
operator|.
name|pr_domain
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dom
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|domain
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|domain
argument_list|)
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|proto
operator|.
name|pr_domain
argument_list|,
literal|"domain"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * grab domain name 	 * kludge "internet" --> "inet" for brevity 	 */
if|if
condition|(
name|dom
operator|.
name|dom_family
operator|==
name|AF_INET
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dname
argument_list|,
literal|"inet"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|dom
operator|.
name|dom_name
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|kmem
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|dom
operator|.
name|dom_name
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
name|dname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|dname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|u_short
operator|)
name|so
operator|.
name|so_type
operator|>
name|STYPEMAX
condition|)
name|printf
argument_list|(
literal|"* (%s unk%d %x"
argument_list|,
name|dname
argument_list|,
name|so
operator|.
name|so_type
argument_list|,
name|so
operator|.
name|so_state
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"* (%s %s %x"
argument_list|,
name|dname
argument_list|,
name|stypename
index|[
name|so
operator|.
name|so_type
index|]
argument_list|,
name|so
operator|.
name|so_state
argument_list|)
expr_stmt|;
comment|/*  	 * protocol specific formatting 	 * 	 * Try to find interesting things to print.  For tcp, the interesting 	 * thing is the address of the tcpcb, for udp and others, just the 	 * inpcb (socket pcb).  For unix domain, its the address of the socket 	 * pcb and the address of the connected pcb (if connected).  Otherwise 	 * just print the protocol number and address of the socket itself. 	 * The idea is not to duplicate netstat, but to make available enough 	 * information for further analysis. 	 */
switch|switch
condition|(
name|dom
operator|.
name|dom_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|getinetproto
argument_list|(
name|proto
operator|.
name|pr_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|.
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|so
operator|.
name|so_pcb
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|so
operator|.
name|so_pcb
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inpcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inpcb
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|inpcb
argument_list|)
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|,
literal|"inpcb"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|(
name|int
operator|)
name|inpcb
operator|.
name|inp_ppcb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|so
operator|.
name|so_pcb
condition|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_UNIX
case|:
comment|/* print address of pcb and connected pcb */
if|if
condition|(
name|so
operator|.
name|so_pcb
condition|)
block|{
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|so
operator|.
name|so_pcb
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unpcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
condition|)
block|{
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|so
operator|.
name|so_pcb
argument_list|,
literal|"unpcb"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unpcb
operator|.
name|unp_conn
condition|)
block|{
name|char
name|shoconn
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|shoconn
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|so
operator|.
name|so_state
operator|&
name|SS_CANTRCVMORE
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'<'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|so
operator|.
name|so_state
operator|&
name|SS_CANTSENDMORE
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|" %s %x"
argument_list|,
name|shoconn
argument_list|,
operator|(
name|int
operator|)
name|unpcb
operator|.
name|unp_conn
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* print protocol number and socket address */
name|printf
argument_list|(
literal|" %d %x"
argument_list|,
name|proto
operator|.
name|pr_protocol
argument_list|,
operator|(
name|int
operator|)
name|sock
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * getinetproto --  *	print name of protocol number  */
end_comment

begin_expr_stmt
specifier|static
name|getinetproto
argument_list|(
argument|number
argument_list|)
name|int
name|number
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|number
condition|)
block|{
case|case
name|IPPROTO_IP
case|:
name|cp
operator|=
literal|"ip"
expr_stmt|;
break|break;
case|case
name|IPPROTO_ICMP
case|:
name|cp
operator|=
literal|"icmp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_GGP
case|:
name|cp
operator|=
literal|"ggp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|cp
operator|=
literal|"tcp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_EGP
case|:
name|cp
operator|=
literal|"egp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_PUP
case|:
name|cp
operator|=
literal|"pup"
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|cp
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_IDP
case|:
name|cp
operator|=
literal|"idp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_RAW
case|:
name|cp
operator|=
literal|"raw"
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|number
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|readf
argument_list|()
block|{ 	struct
name|file
name|lfile
block|;
name|int
name|i
block|;
name|itrans
argument_list|(
name|DTYPE_INODE
argument_list|,
name|user
operator|.
name|user
operator|.
name|u_cdir
argument_list|,
name|WD
argument_list|)
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|user
operator|.
name|user
operator|.
name|u_ofile
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|user
operator|.
name|user
operator|.
name|u_ofile
index|[
name|i
index|]
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lfile
argument_list|,
sizeof|sizeof
argument_list|(
name|lfile
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lfile
argument_list|)
condition|)
block|{
name|rerr1
argument_list|(
literal|"file"
argument_list|,
name|N_KMEM
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|itrans
argument_list|(
name|lfile
operator|.
name|f_type
argument_list|,
operator|(
expr|struct
name|inode
operator|*
operator|)
name|lfile
operator|.
name|f_data
argument_list|,
name|i
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
specifier|static
name|devmatch
argument_list|(
argument|idev
argument_list|,
argument|inum
argument_list|,
argument|name
argument_list|)
name|dev_t
name|idev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ino_t
name|inum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DEVS
modifier|*
name|d
decl_stmt|;
for|for
control|(
name|d
operator|=
name|devs
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|next
control|)
if|if
condition|(
name|d
operator|->
name|dev
operator|==
name|idev
operator|&&
operator|(
name|d
operator|->
name|inum
operator|==
literal|0
operator|||
name|d
operator|->
name|inum
operator|==
name|inum
operator|)
condition|)
block|{
operator|*
name|name
operator|=
name|d
operator|->
name|name
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|getfname
argument_list|(
argument|filename
argument_list|)
name|char
operator|*
name|filename
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|DEVS
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cur
operator|=
operator|(
name|DEVS
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEVS
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fstat: out of space.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cur
operator|->
name|next
operator|=
name|devs
expr_stmt|;
name|devs
operator|=
name|cur
expr_stmt|;
comment|/* if file is block special, look for open files on it */
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFBLK
condition|)
block|{
name|cur
operator|->
name|inum
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
name|cur
operator|->
name|dev
operator|=
name|statbuf
operator|.
name|st_dev
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|->
name|inum
operator|=
literal|0
expr_stmt|;
name|cur
operator|->
name|dev
operator|=
name|statbuf
operator|.
name|st_rdev
expr_stmt|;
block|}
name|cur
operator|->
name|name
operator|=
name|filename
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|openfiles
argument_list|()
block|{
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
name|N_KMEM
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|N_KMEM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|mem
operator|=
name|open
argument_list|(
name|N_MEM
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|N_MEM
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|swap
operator|=
name|open
argument_list|(
name|N_SWAP
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|N_SWAP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_macro
unit|}  static
name|rerr1
argument_list|(
argument|what
argument_list|,
argument|fromwhat
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|fromwhat
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|vflg
condition|)
name|printf
argument_list|(
literal|"fstat: error reading %s from %s"
argument_list|,
name|what
argument_list|,
name|fromwhat
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|rerr2
argument_list|(
argument|err
argument_list|,
argument|address
argument_list|,
argument|what
argument_list|)
name|int
name|err
operator|,
name|address
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|what
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|vflg
condition|)
name|printf
argument_list|(
literal|"error %d reading %s at %x from kmem\n"
argument_list|,
name|errno
argument_list|,
name|what
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|long
name|lgetw
parameter_list|(
name|loc
parameter_list|)
name|off_t
name|loc
decl_stmt|;
block|{
name|long
name|word
decl_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|off_t
operator|)
name|loc
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|word
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|word
argument_list|)
condition|)
name|rerr2
argument_list|(
name|errno
argument_list|,
operator|(
name|int
operator|)
name|loc
argument_list|,
literal|"word"
argument_list|)
expr_stmt|;
return|return
operator|(
name|word
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|usage
argument_list|()
block|{
name|fputs
argument_list|(
literal|"usage: fstat [-v] [-u user] [-p pid] [filename ...]\n"
argument_list|,
name|stderr
argument_list|)
block|;
name|exit
argument_list|(
literal|1
argument_list|)
block|; }
end_expr_stmt

end_unit

