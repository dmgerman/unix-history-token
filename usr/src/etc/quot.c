begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)quot.c	4.14 (Berkeley) 88/04/18"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * quot  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_define
define|#
directive|define
name|ISIZ
value|(MAXBSIZE/sizeof(struct dinode))
end_define

begin_union
union|union
block|{
name|struct
name|fs
name|u_sblock
decl_stmt|;
name|char
name|dummy
index|[
name|SBSIZE
index|]
decl_stmt|;
block|}
name|sb_un
union|;
end_union

begin_define
define|#
directive|define
name|sblock
value|sb_un.u_sblock
end_define

begin_decl_stmt
name|struct
name|dinode
name|itab
index|[
name|MAXBSIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dinode
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|du
block|{
name|struct
name|du
modifier|*
name|next
decl_stmt|;
name|long
name|blocks
decl_stmt|;
name|long
name|blocks30
decl_stmt|;
name|long
name|blocks60
decl_stmt|;
name|long
name|blocks90
decl_stmt|;
name|long
name|nfiles
decl_stmt|;
name|int
name|uid
decl_stmt|;
define|#
directive|define
name|NDU
value|2048
block|}
name|du
index|[
name|NDU
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|ndu
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DUHASH
value|8209
end_define

begin_comment
comment|/* smallest prime>= 4 * NDU */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|u
parameter_list|)
value|((u) % DUHASH)
end_define

begin_decl_stmt
name|struct
name|du
modifier|*
name|duhash
index|[
name|DUHASH
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TSIZE
value|500
end_define

begin_decl_stmt
name|int
name|sizes
index|[
name|TSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|overflow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|now
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|ino
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|time_t
name|time
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cfhnv"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
operator|(
name|char
operator|)
name|ch
condition|)
block|{
case|case
literal|'c'
case|:
name|cflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* undocumented */
name|hflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* undocumented */
name|vflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|fputs
argument_list|(
literal|"usage: quot [-cfn] [filesystem ...]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
condition|)
for|for
control|(
init|;
operator|*
name|argv
condition|;
operator|++
name|argv
control|)
block|{
if|if
condition|(
name|check
argument_list|(
operator|*
name|argv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|report
argument_list|()
expr_stmt|;
block|}
else|else
name|quotall
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_macro
name|quotall
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|fstab
modifier|*
name|fs
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|dev
index|[
name|MAXNAMLEN
operator|+
literal|10
index|]
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
while|while
condition|(
name|fs
operator|=
name|getfsent
argument_list|()
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_type
argument_list|,
name|FSTAB_RO
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_type
argument_list|,
name|FSTAB_RW
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_type
argument_list|,
name|FSTAB_RQ
argument_list|)
condition|)
continue|continue;
name|cp
operator|=
name|rindex
argument_list|(
name|fs
operator|->
name|fs_spec
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dev
argument_list|,
literal|"/dev/r%s"
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
argument_list|(
name|dev
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
operator|==
literal|0
condition|)
name|report
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|check
argument_list|(
argument|file
argument_list|,
argument|fsdir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fsdir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nfiles
decl_stmt|;
specifier|register
name|struct
name|du
modifier|*
modifier|*
name|dp
decl_stmt|;
name|daddr_t
name|iblk
decl_stmt|;
name|long
name|dev_bsize
decl_stmt|;
name|int
name|c
decl_stmt|,
name|fd
decl_stmt|;
comment|/* 	 * Initialize tables between checks; 	 * because of the qsort done in report() 	 * the hash tables must be rebuilt each time. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSIZE
condition|;
name|i
operator|++
control|)
name|sizes
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|duhash
init|;
name|dp
operator|<
operator|&
name|duhash
index|[
name|DUHASH
index|]
condition|;
name|dp
operator|++
control|)
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
name|ndu
operator|=
literal|0
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"quot: "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsdir
operator|==
name|NULL
condition|)
block|{
specifier|register
name|struct
name|fstab
modifier|*
name|fs
init|=
name|getfsspec
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|!=
name|NULL
condition|)
name|fsdir
operator|=
name|fs
operator|->
name|fs_file
expr_stmt|;
block|}
if|if
condition|(
name|fsdir
operator|!=
name|NULL
operator|&&
operator|*
name|fsdir
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|fsdir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
name|bread
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|SBOFF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sblock
argument_list|,
name|SBSIZE
argument_list|)
expr_stmt|;
name|dev_bsize
operator|=
name|sblock
operator|.
name|fs_fsize
operator|/
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflg
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
operator|=
name|getchar
argument_list|()
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|nfiles
operator|=
name|sblock
operator|.
name|fs_ipg
operator|*
name|sblock
operator|.
name|fs_ncg
expr_stmt|;
for|for
control|(
name|ino
operator|=
literal|0
init|;
name|ino
operator|<
name|nfiles
condition|;
control|)
block|{
name|iblk
operator|=
name|fsbtodb
argument_list|(
operator|&
name|sblock
argument_list|,
name|itod
argument_list|(
operator|&
name|sblock
argument_list|,
name|ino
argument_list|)
argument_list|)
expr_stmt|;
name|bread
argument_list|(
name|fd
argument_list|,
name|iblk
operator|*
name|dev_bsize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|itab
argument_list|,
operator|(
name|int
operator|)
name|sblock
operator|.
name|fs_bsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|INOPB
argument_list|(
operator|&
name|sblock
argument_list|)
operator|&&
name|ino
operator|<
name|nfiles
condition|;
name|j
operator|++
operator|,
name|ino
operator|++
control|)
block|{
if|if
condition|(
name|ino
operator|<
name|ROOTINO
condition|)
continue|continue;
name|acct
argument_list|(
operator|&
name|itab
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|acct
argument_list|(
name|ip
argument_list|)
specifier|register
expr|struct
name|dinode
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|du
modifier|*
name|dp
decl_stmt|;
name|struct
name|du
modifier|*
modifier|*
name|hp
decl_stmt|;
name|long
name|blks
decl_stmt|,
name|frags
decl_stmt|,
name|size
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|static
name|fino
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * By default, take block count in inode.  Otherwise (-h), 	 * take the size field and estimate the blocks allocated. 	 * The latter does not account for holes in files. 	 */
if|if
condition|(
operator|!
name|hflg
condition|)
name|size
operator|=
name|ip
operator|->
name|di_blocks
operator|/
literal|2
expr_stmt|;
else|else
block|{
name|blks
operator|=
name|lblkno
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
operator|->
name|di_size
argument_list|)
expr_stmt|;
name|frags
operator|=
name|blks
operator|*
name|sblock
operator|.
name|fs_frag
operator|+
name|numfrags
argument_list|(
operator|&
name|sblock
argument_list|,
name|dblksize
argument_list|(
operator|&
name|sblock
argument_list|,
name|ip
argument_list|,
name|blks
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|frags
operator|*
name|sblock
operator|.
name|fs_fsize
operator|/
literal|1024
expr_stmt|;
block|}
if|if
condition|(
name|cflg
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFDIR
operator|&&
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|!=
name|IFREG
condition|)
return|return;
if|if
condition|(
name|size
operator|>=
name|TSIZE
condition|)
block|{
name|overflow
operator|+=
name|size
expr_stmt|;
name|size
operator|=
name|TSIZE
operator|-
literal|1
expr_stmt|;
block|}
name|sizes
index|[
name|size
index|]
operator|++
expr_stmt|;
return|return;
block|}
name|hp
operator|=
operator|&
name|duhash
index|[
name|HASH
argument_list|(
name|ip
operator|->
name|di_uid
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|*
name|hp
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
if|if
condition|(
name|dp
operator|->
name|uid
operator|==
name|ip
operator|->
name|di_uid
condition|)
break|break;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ndu
operator|>=
name|NDU
condition|)
return|return;
name|dp
operator|=
operator|&
name|du
index|[
name|ndu
operator|++
index|]
expr_stmt|;
name|dp
operator|->
name|next
operator|=
operator|*
name|hp
expr_stmt|;
operator|*
name|hp
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|uid
operator|=
name|ip
operator|->
name|di_uid
expr_stmt|;
name|dp
operator|->
name|nfiles
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|blocks
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|blocks30
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|blocks60
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|blocks90
operator|=
literal|0
expr_stmt|;
block|}
name|dp
operator|->
name|blocks
operator|+=
name|size
expr_stmt|;
define|#
directive|define
name|DAY
value|(60 * 60 * 24)
comment|/* seconds per day */
if|if
condition|(
name|now
operator|-
name|ip
operator|->
name|di_atime
operator|>
literal|30
operator|*
name|DAY
condition|)
name|dp
operator|->
name|blocks30
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|ip
operator|->
name|di_atime
operator|>
literal|60
operator|*
name|DAY
condition|)
name|dp
operator|->
name|blocks60
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|ip
operator|->
name|di_atime
operator|>
literal|90
operator|*
name|DAY
condition|)
name|dp
operator|->
name|blocks90
operator|+=
name|size
expr_stmt|;
name|dp
operator|->
name|nfiles
operator|++
expr_stmt|;
while|while
condition|(
name|nflg
condition|)
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|fino
operator|==
literal|0
condition|)
if|if
condition|(
name|scanf
argument_list|(
literal|"%d"
argument_list|,
operator|&
name|fino
argument_list|)
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|fino
operator|>
name|ino
condition|)
return|return;
if|if
condition|(
name|fino
operator|<
name|ino
condition|)
block|{
while|while
condition|(
operator|(
name|n
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|n
operator|!=
name|EOF
condition|)
empty_stmt|;
name|fino
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|np
operator|=
name|getname
argument_list|(
name|dp
operator|->
name|uid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%.7s\t"
argument_list|,
name|np
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%u\t"
argument_list|,
name|ip
operator|->
name|di_uid
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|n
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|putchar
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|!=
name|EOF
operator|&&
name|n
operator|!=
literal|'\n'
condition|)
block|{
name|n
operator|=
name|getchar
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|fino
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_macro
name|bread
argument_list|(
argument|fd
argument_list|,
argument|bno
argument_list|,
argument|buf
argument_list|,
argument|cnt
argument_list|)
end_macro

begin_decl_stmt
name|long
name|bno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|off_t
name|lseek
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
name|bno
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
operator|!=
name|cnt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"quot: read error at block %ld\n"
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|qcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
specifier|register
expr|struct
name|du
operator|*
name|p1
operator|,
operator|*
name|p2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
if|if
condition|(
name|p1
operator|->
name|blocks
operator|>
name|p2
operator|->
name|blocks
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|p1
operator|->
name|blocks
operator|<
name|p2
operator|->
name|blocks
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s1
operator|=
name|getname
argument_list|(
name|p1
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s2
operator|=
name|getname
argument_list|(
name|p2
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|report
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|du
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|nflg
condition|)
return|return;
if|if
condition|(
name|cflg
condition|)
block|{
specifier|register
name|long
name|t
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSIZE
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sizes
index|[
name|i
index|]
condition|)
block|{
name|t
operator|+=
name|i
operator|*
name|sizes
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%d\t%d\t%ld\n"
argument_list|,
name|i
argument_list|,
name|sizes
index|[
name|i
index|]
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d\t%d\t%ld\n"
argument_list|,
name|TSIZE
operator|-
literal|1
argument_list|,
name|sizes
index|[
name|TSIZE
operator|-
literal|1
index|]
argument_list|,
name|overflow
operator|+
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
name|qsort
argument_list|(
name|du
argument_list|,
name|ndu
argument_list|,
sizeof|sizeof
argument_list|(
name|du
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|qcmp
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|du
init|;
name|dp
operator|<
operator|&
name|du
index|[
name|ndu
index|]
condition|;
name|dp
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|blocks
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"%5D\t"
argument_list|,
name|dp
operator|->
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflg
condition|)
name|printf
argument_list|(
literal|"%5D\t"
argument_list|,
name|dp
operator|->
name|nfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|getname
argument_list|(
name|dp
operator|->
name|uid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%-8.8s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"#%-8d"
argument_list|,
name|dp
operator|->
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflg
condition|)
name|printf
argument_list|(
literal|"\t%5D\t%5D\t%5D"
argument_list|,
name|dp
operator|->
name|blocks30
argument_list|,
name|dp
operator|->
name|blocks60
argument_list|,
name|dp
operator|->
name|blocks90
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* rest should be done with nameserver or database */
end_comment

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMAX
value|(sizeof (utmp.ut_name))
end_define

begin_define
define|#
directive|define
name|SCPYN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strncpy(a, b, NMAX)
end_define

begin_define
define|#
directive|define
name|NUID
value|64
end_define

begin_comment
comment|/* power of 2 */
end_comment

begin_define
define|#
directive|define
name|UIDMASK
value|0x3f
end_define

begin_struct
struct|struct
name|ncache
block|{
name|int
name|uid
decl_stmt|;
name|char
name|name
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|nc
index|[
name|NUID
index|]
struct|;
end_struct

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|uid
parameter_list|)
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
specifier|extern
name|int
name|_pw_stayopen
decl_stmt|;
specifier|register
name|int
name|cp
decl_stmt|;
name|_pw_stayopen
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|uid
operator|&
name|UIDMASK
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
literal|0
operator|&&
name|nc
index|[
name|cp
index|]
operator|.
name|uid
operator|==
name|uid
operator|&&
name|nc
index|[
name|cp
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|nc
index|[
name|cp
index|]
operator|.
name|name
operator|)
return|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nc
index|[
name|cp
index|]
operator|.
name|uid
operator|=
name|uid
expr_stmt|;
name|SCPYN
argument_list|(
name|nc
index|[
name|cp
index|]
operator|.
name|name
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nc
index|[
name|cp
index|]
operator|.
name|name
operator|)
return|;
block|}
end_function

end_unit

