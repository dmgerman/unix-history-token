begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"constants.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)retrieve.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  RETRIEVE.C -- ret_list struct handlers ** **	The Ret_list is a structure where references to C variables, **	and their types, used in a target list of a "tupret" are kept **	for outputting in the while loop generated. */
end_comment

begin_comment
comment|/* **  ENTER_RET -- enter a variable in a ret_list **	Concatenatest the strings in disp the calls add_ret **	to add the new string to Ret_list. ** **	Parameters: **		disp -- display containing the reference to the variable **		type -- type of the variable */
end_comment

begin_macro
name|enter_ret
argument_list|(
argument|disp
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|display
modifier|*
name|disp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXSTRING
operator|+
literal|2
index|]
decl_stmt|;
comment|/*&buf [1] is the start 						      * of the concatenated 						      * strings 						      */
specifier|register
name|char
modifier|*
name|srce
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|struct
name|disp_node
modifier|*
name|d
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|dest
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|d
operator|=
name|disp
operator|->
name|disp_first
init|;
name|d
condition|;
name|d
operator|=
name|d
operator|->
name|d_next
control|)
block|{
for|for
control|(
name|srce
operator|=
name|d
operator|->
name|d_elm
init|;
operator|*
name|srce
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|<
name|MAXSTRING
condition|)
block|{
name|i
operator|+=
literal|1
expr_stmt|;
operator|*
operator|++
name|dest
operator|=
operator|*
name|srce
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|MAXSTRING
condition|)
block|{
name|yysemerr
argument_list|(
literal|"reference to a variable too long, ']' probably missing from array subscription"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
operator|++
name|dest
operator|=
literal|'\0'
expr_stmt|;
name|add_ret
argument_list|(
name|salloc
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ADD_RET -- add a string (reference to a variable) to the Ret_list ** **	Parameters: **		s -- string to add **		type -- type of variable being added */
end_comment

begin_macro
name|add_ret
argument_list|(
argument|s
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ret_list
modifier|*
name|list
decl_stmt|;
specifier|register
name|struct
name|ret_var
modifier|*
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|s
operator|=
literal|"ERROR_TOKEN"
expr_stmt|;
name|yysemerr
argument_list|(
literal|"alloc error"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
operator|&
name|Ret_list
expr_stmt|;
name|node
operator|=
operator|(
expr|struct
name|ret_var
operator|*
operator|)
name|nalloc
argument_list|(
sizeof|sizeof
expr|*
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|yysemerr
argument_list|(
literal|"alloc error"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|node
operator|->
name|r_elm
operator|=
name|s
expr_stmt|;
name|node
operator|->
name|r_next
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|r_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|ret_first
operator|==
literal|0
condition|)
name|list
operator|->
name|ret_first
operator|=
name|list
operator|->
name|ret_last
operator|=
name|node
expr_stmt|;
else|else
block|{
name|list
operator|->
name|ret_last
operator|->
name|r_next
operator|=
name|node
expr_stmt|;
name|list
operator|->
name|ret_last
operator|=
name|node
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  W_RET -- Generates the IIn_get() calls for the Ret_list ** **	Any variable whose type is not string gets an '&' **	(adress of) operand prepended. */
end_comment

begin_macro
name|w_ret
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ret_var
modifier|*
name|node
decl_stmt|;
name|char
name|type
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|node
operator|=
name|Ret_list
operator|.
name|ret_first
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|r_next
control|)
block|{
name|w_op
argument_list|(
literal|"IIn_ret("
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|r_type
operator|!=
name|opSTRING
condition|)
name|w_op
argument_list|(
literal|"&"
argument_list|)
expr_stmt|;
name|w_op
argument_list|(
name|node
operator|->
name|r_elm
argument_list|)
expr_stmt|;
name|w_op
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|itoa
argument_list|(
name|node
operator|->
name|r_type
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|w_op
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|w_op
argument_list|(
literal|");"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FRE_RET -- Free up the storage used by the Ret_list */
end_comment

begin_macro
name|free_ret
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|ret_list
modifier|*
name|list
decl_stmt|;
specifier|register
name|struct
name|ret_var
modifier|*
name|n
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|list
operator|=
operator|&
name|Ret_list
expr_stmt|;
for|for
control|(
name|f
operator|=
name|list
operator|->
name|ret_first
init|;
name|f
condition|;
name|f
operator|=
name|n
control|)
block|{
name|n
operator|=
name|f
operator|->
name|r_next
expr_stmt|;
name|xfree
argument_list|(
name|f
operator|->
name|r_elm
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|list
operator|->
name|ret_first
operator|=
name|list
operator|->
name|ret_last
operator|=
literal|0
expr_stmt|;
block|}
end_block

end_unit

