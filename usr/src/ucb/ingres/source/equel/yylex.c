begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"constants.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)yylex.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  YYLEX -- Lexical analyzer **	Yylex controls the return to the parser of lexemes, **	and the copying out of C_CODE on the all to yylex  **	after yylex() returned the C_CODE. ** **	Returns: **		Lexical tokens. ** **	Side Effects: **		Copies C code out on call after seeing it. **		Puts terminals in symbol space. ** **	Called By: **		Yacc internals (yyparse()). */
end_comment

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|rtval
decl_stmt|;
specifier|register
name|char
name|chr
decl_stmt|;
comment|/* get next token */
name|rtval
operator|=
name|CONTINUE
expr_stmt|;
while|while
condition|(
name|rtval
operator|==
name|CONTINUE
condition|)
block|{
if|if
condition|(
name|C_code_flg
condition|)
block|{
name|copy_c_code
argument_list|()
expr_stmt|;
name|Newline
operator|=
literal|1
expr_stmt|;
block|}
name|Pre_proc_flg
operator|=
literal|0
expr_stmt|;
comment|/* END OF FILE ? */
if|if
condition|(
operator|(
name|chr
operator|=
name|getch
argument_list|()
operator|)
operator|==
name|EOF_TOK
condition|)
block|{
ifdef|#
directive|ifdef
name|xDEBUG
if|if
condition|(
name|Lex_debug
condition|)
name|printf
argument_list|(
literal|"end of file\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Test for a line of C code */
if|if
condition|(
name|Newline
operator|&&
name|if_c_code
argument_list|(
name|chr
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_code_flg
condition|)
continue|continue;
name|rtval
operator|=
name|Tokens
operator|.
name|sp_c_code
expr_stmt|;
name|C_code_flg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|C_code_flg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Newline
condition|)
block|{
name|Newline
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* CARRIAGE CONTROL ? */
name|Newline
operator|=
name|chr
operator|==
literal|'\n'
expr_stmt|;
switch|switch
condition|(
name|Cmap
index|[
name|chr
index|]
condition|)
block|{
case|case
name|PUNCT
case|:
continue|continue;
case|case
name|OPATR
case|:
name|rtval
operator|=
name|operator
argument_list|(
name|chr
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMBR
case|:
name|rtval
operator|=
name|number
argument_list|(
name|chr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA
case|:
name|rtval
operator|=
name|name
argument_list|(
name|chr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|Lex_debug
condition|)
name|printf
argument_list|(
literal|"YYLEX : '%s'\n"
argument_list|,
name|yylval
operator|.
name|u_dn
condition|?
name|yylval
operator|.
name|u_dn
operator|->
name|d_elm
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  COPY_C_CODE -- Copies out a line of C code **	The test for Charcnt != 0 is beacuse if a C pre-processor **	line follows an equel line, and equate_lines() puts out no **	newline, the initial '#' will not be on the beginning of  **	the line. As is, if this should happen, then the line **	with the '#' will be one line in the output ahead of  **	where it should be. */
end_comment

begin_macro
name|copy_c_code
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
index|[
literal|2
index|]
decl_stmt|;
name|ch
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|equate_lines
argument_list|()
expr_stmt|;
if|if
condition|(
name|Pre_proc_flg
condition|)
block|{
if|if
condition|(
name|Charcnt
operator|!=
literal|0
condition|)
name|w_raw
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|w_raw
argument_list|(
literal|"#"
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|ch
operator|=
name|getch
argument_list|()
operator|)
operator|==
name|EOF_TOK
condition|)
return|return;
name|w_raw
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|ch
operator|!=
literal|'\n'
condition|)
do|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  IF_C_CODE -- Test to see if a line is C code ** **	Sees if a line begins with "##" to see if it is equel. ** **	Parameters: **		chr -- first char of line ** **	Returns: **		0 -- Quel line **		1 -- C line **	 **	Called By: **		yylex() */
end_comment

begin_macro
name|if_c_code
argument_list|(
argument|chr
argument_list|)
end_macro

begin_decl_stmt
name|char
name|chr
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|chr
operator|!=
literal|'#'
condition|)
block|{
name|backup
argument_list|(
name|chr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|Pre_proc_flg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|chr
operator|=
name|getch
argument_list|()
operator|)
operator|==
name|EOF_TOK
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|chr
operator|!=
literal|'#'
condition|)
block|{
name|backup
argument_list|(
name|chr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_block

end_unit

