begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_typedef
typedef|typedef
name|char
name|bool
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|short
modifier|*
name|tT
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|relation
block|{
name|char
name|relid
index|[
literal|12
index|]
decl_stmt|;
name|char
name|relowner
index|[
literal|2
index|]
decl_stmt|;
name|char
name|relspec
decl_stmt|;
name|char
name|relindxd
decl_stmt|;
name|short
name|relstat2
decl_stmt|;
name|short
name|relstat
decl_stmt|;
name|long
name|relsave
decl_stmt|;
name|long
name|reltups
decl_stmt|;
name|short
name|relatts
decl_stmt|;
name|short
name|relwid
decl_stmt|;
name|long
name|relprim
decl_stmt|;
name|long
name|relfree
decl_stmt|;
name|long
name|relstamp
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|attribute
block|{
name|char
name|attrelid
index|[
literal|12
index|]
decl_stmt|;
name|char
name|attowner
index|[
literal|2
index|]
decl_stmt|;
name|short
name|attid
decl_stmt|;
name|char
name|attname
index|[
literal|12
index|]
decl_stmt|;
name|short
name|attoff
decl_stmt|;
name|char
name|attfrmt
decl_stmt|;
name|char
name|attfrml
decl_stmt|;
name|char
name|attxtra
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tup_id
block|{
name|char
name|line_id
decl_stmt|,
name|pg2
decl_stmt|,
name|pg1
decl_stmt|,
name|pg0
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|tup_id
name|TID
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|long
name|ltid
decl_stmt|;
name|TID
name|s_tupid
decl_stmt|;
block|}
name|tid_type
typedef|;
end_typedef

begin_struct
struct|struct
name|descriptor
block|{
name|struct
name|relation
name|reldum
decl_stmt|;
name|char
name|relvname
index|[
literal|12
index|]
decl_stmt|;
name|short
name|relfp
decl_stmt|;
name|short
name|relopn
decl_stmt|;
name|tid_type
name|reltid
decl_stmt|;
name|long
name|reladds
decl_stmt|;
name|short
name|reloff
index|[
literal|50
index|]
decl_stmt|;
name|char
name|relfrmt
index|[
literal|50
index|]
decl_stmt|;
name|char
name|relfrml
index|[
literal|50
index|]
decl_stmt|;
name|char
name|relxtra
index|[
literal|50
index|]
decl_stmt|;
name|char
name|relgiven
index|[
literal|50
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|descriptor
name|DESC
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|DESC
modifier|*
name|rngvdesc
decl_stmt|;
name|bool
name|rngvmark
decl_stmt|;
block|}
name|RANGEV
typedef|;
end_typedef

begin_union
union|union
name|anytype
block|{
name|char
name|i1type
decl_stmt|;
name|short
name|i2type
decl_stmt|;
name|long
name|i4type
decl_stmt|;
name|float
name|f4type
decl_stmt|;
name|double
name|f8type
decl_stmt|;
name|char
name|c0type
index|[
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|cptype
decl_stmt|;
name|char
modifier|*
modifier|*
name|cpptype
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|anytype
name|ANYTYPE
typedef|;
end_typedef

begin_struct
struct|struct
name|accessparam
block|{
name|short
name|mode
decl_stmt|;
name|short
name|sec_index
decl_stmt|;
name|char
name|keydno
index|[
literal|50
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|desxx
block|{
name|char
modifier|*
name|cach_relname
decl_stmt|;
name|DESC
modifier|*
name|cach_desc
decl_stmt|;
name|DESC
modifier|*
name|cach_alias
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Usercode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Pathname
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|out_arg
block|{
name|int
name|c0width
decl_stmt|;
name|int
name|i1width
decl_stmt|;
name|int
name|i2width
decl_stmt|;
name|int
name|i4width
decl_stmt|;
name|int
name|f4width
decl_stmt|;
name|int
name|f8width
decl_stmt|;
name|int
name|f4prec
decl_stmt|;
name|int
name|f8prec
decl_stmt|;
name|char
name|f4style
decl_stmt|;
name|char
name|f8style
decl_stmt|;
name|int
name|linesperpage
decl_stmt|;
name|char
name|coldelim
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lockreq
block|{
name|char
name|lract
decl_stmt|;
name|char
name|lrtype
decl_stmt|;
name|char
name|lrmod
decl_stmt|;
name|char
name|dbnode
index|[
literal|4
index|]
decl_stmt|;
name|char
name|lrel
index|[
literal|4
index|]
decl_stmt|;
name|char
name|lpage
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|char
name|Acclock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Alockdes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Lockrel
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|accbuf
block|{
name|long
name|mainpg
decl_stmt|;
name|long
name|ovflopg
decl_stmt|;
name|short
name|nxtlino
decl_stmt|;
name|char
name|firstup
index|[
literal|1024
operator|-
literal|12
index|]
decl_stmt|;
name|short
name|linetab
index|[
literal|1
index|]
decl_stmt|;
name|long
name|rel_tupid
decl_stmt|;
name|long
name|thispage
decl_stmt|;
name|int
name|filedesc
decl_stmt|;
name|struct
name|accbuf
modifier|*
name|modf
decl_stmt|;
name|struct
name|accbuf
modifier|*
name|modb
decl_stmt|;
name|int
name|bufstatus
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|char
name|acc_buf
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|accbuf
modifier|*
name|Acc_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|accbuf
modifier|*
name|Acc_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|accbuf
name|Acc_buf
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|adminhdr
block|{
name|char
name|adowner
index|[
literal|2
index|]
decl_stmt|;
name|short
name|adflags
decl_stmt|;
name|short
name|adlength
decl_stmt|;
name|short
name|adversion
decl_stmt|;
name|short
name|adreldsz
decl_stmt|;
name|short
name|adattdsz
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|admin
block|{
name|struct
name|adminhdr
name|adhdr
decl_stmt|;
name|struct
name|descriptor
name|adreld
decl_stmt|;
name|struct
name|descriptor
name|adattd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|admin
name|Admin
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pgtuple
block|{
name|struct
name|tup_id
name|childtid
decl_stmt|;
name|char
name|childtup
index|[
literal|1010
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|long
name|Accuread
decl_stmt|,
name|Accuwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Acctuple
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern		Accerror;
end_extern

begin_decl_stmt
specifier|extern
name|char
name|Accanon
index|[
literal|1010
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|batchbuf
block|{
name|char
name|file_id
index|[
literal|6
index|]
decl_stmt|;
name|char
name|bbuf
index|[
literal|506
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|si_doms
block|{
name|short
name|rel_off
decl_stmt|;
name|short
name|tupo_off
decl_stmt|;
name|short
name|dom_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|batchhd
block|{
name|char
name|db_name
index|[
literal|15
index|]
decl_stmt|;
name|char
name|rel_name
index|[
literal|13
index|]
decl_stmt|;
name|char
name|userid
index|[
literal|2
index|]
decl_stmt|;
name|long
name|num_updts
decl_stmt|;
name|short
name|mode_up
decl_stmt|;
name|short
name|tido_size
decl_stmt|;
name|short
name|tupo_size
decl_stmt|;
name|short
name|tupn_size
decl_stmt|;
name|short
name|tidn_size
decl_stmt|;
name|short
name|si_dcount
decl_stmt|;
name|struct
name|si_doms
name|si
index|[
literal|50
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|short
name|Batch_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Batch_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Batch_dirty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Batch_lread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|Batch_recovery
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Fileset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|batchbuf
name|Batchbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|batchhd
name|Batchhd
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|pv_type
decl_stmt|;
name|short
name|pv_len
decl_stmt|;
union|union
block|{
name|short
name|pv_int
decl_stmt|;
name|struct
name|querytree
modifier|*
name|pv_qtree
decl_stmt|;
name|char
modifier|*
name|pv_str
decl_stmt|;
name|char
modifier|*
name|pv_tuple
decl_stmt|;
block|}
name|pv_val
union|;
block|}
name|PARM
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|Sccsid
index|[]
init|=
literal|"@(#)sysmod.c	7.1	2/5/81"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|tTdbu
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Fileset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Noupdt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Dummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Xparams
init|=
operator|&
name|Dummy
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|modtabl
block|{
name|char
modifier|*
name|rname
decl_stmt|;
name|char
modifier|*
modifier|*
name|parvec
decl_stmt|;
name|int
name|goahead
decl_stmt|;
name|int
name|normgo
decl_stmt|;
name|int
name|optn
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|char
modifier|*
name|Relpar
index|[]
init|=
block|{
literal|"relation"
block|,
literal|"hash"
block|,
literal|"name"
block|,
literal|"relid"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Attpar
index|[]
init|=
block|{
literal|"attribute"
block|,
literal|"hash"
block|,
literal|"name"
block|,
literal|"attrelid"
block|,
literal|"attowner"
block|,
literal|"#attid"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Indpar
index|[]
init|=
block|{
literal|"indexes"
block|,
literal|"hash"
block|,
literal|"name"
block|,
literal|"irelidp"
block|,
literal|"iownerp"
block|,
literal|""
block|,
literal|"minpages"
block|,
literal|"5"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Trepar
index|[]
init|=
block|{
literal|"tree"
block|,
literal|"hash"
block|,
literal|"name"
block|,
literal|"treerelid"
block|,
literal|"treeowner"
block|,
literal|"treetype"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Propar
index|[]
init|=
block|{
literal|"protect"
block|,
literal|"hash"
block|,
literal|"name"
block|,
literal|"prorelid"
block|,
literal|"prorelown"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Intpar
index|[]
init|=
block|{
literal|"integrities"
block|,
literal|"hash"
block|,
literal|"name"
block|,
literal|"intrelid"
block|,
literal|"intrelowner"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|modtabl
name|Modtabl
index|[]
init|=
block|{
literal|"relation"
block|,
operator|&
name|Relpar
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"attribute"
block|,
operator|&
name|Attpar
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"indexes"
block|,
operator|&
name|Indpar
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"tree"
block|,
operator|&
name|Trepar
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"protect"
block|,
operator|&
name|Propar
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|"integrities"
block|,
operator|&
name|Intpar
index|[
literal|0
index|]
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|PARM
name|newpvec
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|char
name|fileset
index|[
literal|10
index|]
decl_stmt|,
name|proctab
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Parmvect
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Flagvect
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Dbpath
decl_stmt|;
name|int
name|superuser
decl_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|tTrace
argument_list|(
name|argv
argument_list|,
literal|'T'
argument_list|,
name|tTdbu
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|itoa
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|fileset
argument_list|)
expr_stmt|;
name|Fileset
operator|=
name|fileset
expr_stmt|;
name|i
operator|=
name|initucode
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|5
case|:
break|break;
case|case
literal|1
case|:
case|case
literal|6
case|:
name|printf
argument_list|(
literal|"Database %s does not exist\n"
argument_list|,
name|Parmvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"You are not authorized for database %s\n"
argument_list|,
name|Parmvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"You are not a valid INGRES user\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"No database name specified\n"
argument_list|)
expr_stmt|;
name|usage
label|:
name|printf
argument_list|(
literal|"Usage: sysmod [-s] [+-w] dbname [relation ...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
name|syserr
argument_list|(
literal|"initucode %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|concat
argument_list|(
name|Pathname
argument_list|,
literal|"/bin/ksort"
argument_list|,
name|proctab
argument_list|)
expr_stmt|;
name|Dummy
operator|=
name|proctab
expr_stmt|;
name|superuser
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|av
operator|=
name|Flagvect
init|;
operator|(
name|p
operator|=
operator|*
name|av
operator|)
operator|!=
literal|0
condition|;
name|av
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|badflag
label|:
name|printf
argument_list|(
literal|"Bad flag: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|Status
operator|&
literal|0100000
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Only INGRES can use the -s flag\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|superuser
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
break|break;
default|default:
goto|goto
name|badflag
goto|;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|Dbpath
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"data base %s does not exist\n"
argument_list|,
name|Parmvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|superuser
condition|)
name|bmove
argument_list|(
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
name|Usercode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"you are not the dba for %s\n"
argument_list|,
name|Parmvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Parmvect
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|Parmvect
index|[
literal|2
index|]
operator|==
literal|0
operator|)
operator|&&
name|sequal
argument_list|(
name|Parmvect
index|[
literal|1
index|]
argument_list|,
literal|"all"
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Modtabl
index|[
name|i
index|]
operator|.
name|rname
condition|;
name|i
operator|++
control|)
name|Modtabl
index|[
name|i
index|]
operator|.
name|goahead
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|av
operator|=
operator|&
name|Parmvect
index|[
literal|1
index|]
init|;
operator|(
name|p
operator|=
operator|*
name|av
operator|)
operator|!=
literal|0
condition|;
name|av
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|Modtabl
index|[
name|j
index|]
operator|.
name|rname
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sequal
argument_list|(
name|p
argument_list|,
name|Modtabl
index|[
name|j
index|]
operator|.
name|rname
argument_list|)
condition|)
block|{
if|if
condition|(
name|Modtabl
index|[
name|j
index|]
operator|.
name|goahead
condition|)
block|{
name|printf
argument_list|(
literal|"%s duplicate relation name\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Modtabl
index|[
name|j
index|]
operator|.
name|goahead
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|Modtabl
index|[
name|j
index|]
operator|.
name|rname
condition|)
block|{
name|printf
argument_list|(
literal|"%s is not a system relation\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Modtabl
index|[
name|i
index|]
operator|.
name|rname
condition|;
name|i
operator|++
control|)
name|Modtabl
index|[
name|i
index|]
operator|.
name|goahead
operator|=
name|Modtabl
index|[
name|i
index|]
operator|.
name|normgo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Modtabl
index|[
name|i
index|]
operator|.
name|rname
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Modtabl
index|[
name|i
index|]
operator|.
name|goahead
operator|==
literal|0
operator|||
name|optn_rel
argument_list|(
operator|&
name|Modtabl
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|printf
argument_list|(
literal|"modifying %s\n"
argument_list|,
name|Modtabl
index|[
name|i
index|]
operator|.
name|rname
argument_list|)
expr_stmt|;
name|av
operator|=
name|Modtabl
index|[
name|i
index|]
operator|.
name|parvec
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
literal|0
condition|)
block|{
name|newpvec
index|[
name|j
index|]
operator|.
name|pv_type
operator|=
literal|2
expr_stmt|;
name|newpvec
index|[
name|j
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|=
operator|*
name|av
expr_stmt|;
name|newpvec
index|[
name|j
index|]
operator|.
name|pv_len
operator|=
name|length
argument_list|(
operator|*
name|av
argument_list|)
operator|+
literal|1
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
name|newpvec
index|[
name|j
index|]
operator|.
name|pv_type
operator|=
literal|0
expr_stmt|;
name|smove
argument_list|(
name|Fileset
argument_list|,
name|Batchbuf
operator|.
name|file_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
literal|0
operator|<
literal|0
operator|)
condition|?
name|tT
index|[
literal|1
index|]
else|:
operator|(
name|tT
index|[
literal|1
index|]
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|prvect
argument_list|(
name|j
argument_list|,
name|newpvec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|=
name|modify
argument_list|(
name|j
argument_list|,
name|newpvec
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error %d on %s\n"
argument_list|,
name|retval
argument_list|,
name|Modtabl
index|[
name|i
index|]
operator|.
name|rname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"sysmod done\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|optn_rel
argument_list|(
argument|mx
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|modtabl
modifier|*
name|mx
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|modtabl
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
name|struct
name|descriptor
name|des
decl_stmt|;
name|m
operator|=
name|mx
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|optn
condition|)
block|{
if|if
condition|(
name|openr
argument_list|(
operator|&
name|des
argument_list|,
operator|-
literal|1
argument_list|,
name|m
operator|->
name|rname
argument_list|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_macro
name|rubproc
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"sysmod interrupted\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

