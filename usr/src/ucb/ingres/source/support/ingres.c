begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_line
line|#
directive|line
number|2
file|"ingres.y"
end_line

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<version.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<ctlmod.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_comment
comment|/* **  INGRES -- INGRES startup ** **	This program starts up the entire system. ** **	Parameters: **		1 -- database name **		2 -- optional process table name **		x -- flags of the form +x or -x may be freely inter- **			sperced in the argument list. ** **	Return: **		none if successful **		1 -- user error (no database, etc) **		-1 -- system error ** **	Flags: **		-&xxxx -- EQUEL flag: xxxx are file descriptors for the **			status return pipe, the command write pipe, the **			data return pipe, and the data transfer pipe **			respectively. **		-@xxxx -- xxxx is same as EQUEL flag, but no flags **			are set. **		-*?? -- Masterid flag. Gives the siteid of the master **			site in a distributed ingres. (Used in dist. **			ingres' initproc() function.) **		-|xxxx -- Network flag.  This flag is just passed to **			the other processes, to be processed by the **			DBU's. **		-uusername -- set effective user to be username.  You **			must be INGRES or the DBA for the database to **			use this option. **		-cN -- set minimum character field output width to be **			N, default 6.  This is the fewest number of **			characters which may be output in any "c" type **			field. **		-inN -- integer output width.  this is the width of **			an integer field.  The small "n" is the size **			of the internal field ("1", "2", or "4") and **			N is the width of the field for that flag. **			The defaults are -i16, -i26, and -i413. **		-fnxN.M -- floating point output width and precision. **			Small "n" is the internal width in bytes ("4" **			or "8"), x is the format (f, F, g, G, e, E, **			n, or N), N is the field width, and M is the **			precision (number of digits after the decimal **			point).  The formats are: **			"f" or "F": FORTRAN-style F format: digits, **				decimal point, digits, no exponent. **			"e" or "E": FORTRAN-style E format: digits, **				decimal point, digits, letter "e" (or **				"E", depending on "x" in the param- **				eter), and an exponent.  The scaling **				factor is always one, that is, there **				is always one digit before the decimal **				point. **			"g" or "G": F format if it will fit in the **				field, otherwise E format.  Space is **				always left at the right of the field **				for the exponent, so that decimal **				points will align. **			"n" or "N": like G, except that space is not **				left for the decimal point in F style **				format (useful if you expect everything **				to fit, but you're not sure). **			The default is -fn10.3. **		-vx -- set vertical seperator for print operations **			and retrieves to the terminal to be "x".  The **			default is vertical bar ("|"). **		+w -- database wait state.  If set ("+w"), you will **			wait until the database is not busy.  If clear, **			you will be informed if the database is busy. **			If not specified, the same operations take **			place depending on whether or not you are **			running in background (determined by whether **			or not your input is a teletype).  If in fore- **			ground, you are informed; if in background, **			you wait. **		-M -- monitor trace flag **		-P -- parser trace flag **		-O -- ovqp trace flag **		-Q -- qrymod trace flag **		-D -- decomp trace flag **		-Z -- dbu trace flag.  These flags require the 020 bit **			in the status field of the users file to be **			set.  The syntax is loose and is described **			elsewhere.  Briefly, "-Z" sets all flags except **			the last 20, "-Z4" sets flag 4, and "-Z5/7" **			sets all flags from 5 through 7. **		+L -- enable/disable upper to lower case mapping in the **			parser.  Used for debugging. **		-rmode -- retrieve into mode **		-nmode -- index mode.  These flags give the default **			modify mode for retrieve into and index.  They **			default to cheapsort and isam.  "Mode" can be **			any mode to modify except "truncated". **		+a -- enable/disable autoclear function in monitor. **			Default on. **		+b -- enable/disable batch update.  Default on. **			The 02 bit is needed to clear this flag. **		+d -- enable/disable printing of the dayfile.  Default **			on. **		+s -- enable/disable printing of almost everything from **			the monitor. **		+U -- enable/disable direct update of system catalogs. **			Default off.  The 04 bit is needed to set this **			option. ** **	Files: **		.../files/usage -- to print a "usage: ..." message. **		.../data/base/<database>/admin -- to determine **			existance and some info about<database>. **		.../files/dayfile<VERSION> -- dayfile (printed by **			monitor). **		.../files/users -- file with UNIX uid -> INGRES code **			mapping, plus a pile of other information about **			the user. **		.../files/proctab<VERSION> -- default process table */
end_comment

begin_macro
name|SCCSID
argument_list|(
argument|@(#)ingres.y
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_define
define|#
directive|define
name|MAXOPTNS
value|10
end_define

begin_comment
comment|/* maximum number of options you can specify */
end_comment

begin_define
define|#
directive|define
name|MAXPROCS
value|10
end_define

begin_comment
comment|/* maximum number of processes in the system */
end_comment

begin_define
define|#
directive|define
name|EQUELFLAG
value|'&'
end_define

begin_define
define|#
directive|define
name|NETFLAG
value|'|'
end_define

begin_comment
comment|/* network slave flag */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|'?'
end_define

begin_decl_stmt
name|char
name|Fileset
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Database
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Dbpath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in initucode */
end_comment

begin_decl_stmt
name|struct
name|admin
name|Admin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set in initucode */
end_comment

begin_decl_stmt
name|struct
name|lockreq
name|Lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ProcFile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fildes for the process table */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DefProcTab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default process table name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Opt
index|[
name|MAXOPTNS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nopts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|No_exec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, don't execute */
end_comment

begin_decl_stmt
name|int
name|NumProcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of processes this system */
end_comment

begin_comment
comment|/* **  Internal form of process descriptions. */
end_comment

begin_struct
struct|struct
name|proc
block|{
name|short
name|prstat
decl_stmt|;
comment|/* status bits, see below */
name|char
name|prmpipe
decl_stmt|;
comment|/* initial pipe to this process */
name|char
name|prtflag
decl_stmt|;
comment|/* trace flag for CM this proc */
name|char
name|prpath
index|[
literal|50
index|]
decl_stmt|;
comment|/* pathname of this process */
name|struct
name|_cm_t
name|prcm
decl_stmt|;
comment|/* cm info passed to this proc */
block|}
struct|;
end_struct

begin_comment
comment|/* bits for prstat */
end_comment

begin_define
define|#
directive|define
name|PR_REALUID
value|0001
end_define

begin_comment
comment|/* run as the user, not INGRES */
end_comment

begin_define
define|#
directive|define
name|PR_NOCHDIR
value|0002
end_define

begin_comment
comment|/* don't chdir into database */
end_comment

begin_define
define|#
directive|define
name|PR_CLSSIN
value|0004
end_define

begin_comment
comment|/* close standard input */
end_comment

begin_define
define|#
directive|define
name|PR_CLSDOUT
value|0010
end_define

begin_comment
comment|/* close diagnostic output */
end_comment

begin_decl_stmt
name|struct
name|proc
name|ProcTab
index|[
name|CM_MAXPROC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Open pipe info. */
end_comment

begin_struct
struct|struct
name|pipeinfo
block|{
name|char
name|pip_rfd
decl_stmt|;
comment|/* read file descriptor */
name|char
name|pip_wfd
decl_stmt|;
comment|/* write file descriptor */
name|short
name|pip_rcnt
decl_stmt|;
comment|/* read reference count */
name|short
name|pip_wcnt
decl_stmt|;
comment|/* write reference count */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pipeinfo
name|Pipe
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Macro definitions */
end_comment

begin_decl_stmt
name|char
name|Macro
index|[
literal|26
index|]
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system error messages, etc. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* globals used by the grammar. */
end_comment

begin_decl_stmt
name|struct
name|proc
modifier|*
name|Proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|state_t
modifier|*
name|StateP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|proc_t
modifier|*
name|ProcP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ProcNo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|RemStat
decl_stmt|;
end_decl_stmt

begin_line
line|#
directive|line
number|215
file|"ingres.y"
end_line

begin_typedef
typedef|typedef
union|union
block|{
name|int
name|yyint
decl_stmt|;
comment|/* integer */
name|char
modifier|*
name|yystr
decl_stmt|;
comment|/* string */
name|char
name|yypip
decl_stmt|;
comment|/* pipe id */
name|char
name|yychar
decl_stmt|;
comment|/* single character */
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_define
define|#
directive|define
name|INT
value|257
end_define

begin_define
define|#
directive|define
name|STR
value|258
end_define

begin_define
define|#
directive|define
name|yyclearin
value|yychar = -1
end_define

begin_define
define|#
directive|define
name|yyerrok
value|yyerrflag = 0
end_define

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|YYMAXDEPTH
end_ifndef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|150
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|,
name|yyval
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_line
line|#
directive|line
number|416
file|"ingres.y"
end_line

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Proc_name
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|extern
name|int
name|Status
decl_stmt|;
name|char
modifier|*
name|proctab
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Flagvect
index|[]
decl_stmt|;
comment|/* defined in initucode.c */
specifier|extern
name|char
modifier|*
name|Parmvect
index|[]
decl_stmt|;
comment|/* ditto */
name|char
modifier|*
name|uservect
index|[
literal|4
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
name|Proc_name
operator|=
literal|"INGRES"
expr_stmt|;
name|itoa
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|Fileset
argument_list|)
expr_stmt|;
name|proctab
operator|=
name|NULL
expr_stmt|;
name|Database
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Initialize everything, like Flagvect, Parmvect, Usercode, 	**	etc. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_rfd
operator|=
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_wfd
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|initucode
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|TRUE
argument_list|,
name|uservect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
comment|/* ok */
case|case
literal|5
case|:
break|break;
case|case
literal|1
case|:
comment|/* database does not exist */
case|case
literal|6
case|:
name|printf
argument_list|(
literal|"Database %s does not exist\n"
argument_list|,
name|Parmvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
case|case
literal|2
case|:
comment|/* you are not authorized */
name|printf
argument_list|(
literal|"You may not access database %s\n"
argument_list|,
name|Database
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
case|case
literal|3
case|:
comment|/* not a valid user */
name|printf
argument_list|(
literal|"You are not a valid INGRES user\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
case|case
literal|4
case|:
comment|/* no database name specified */
name|printf
argument_list|(
literal|"No database name specified\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
default|default:
name|syserr
argument_list|(
literal|"initucode %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Extract database name and process table name from 	**	parameter vector. 	**  Initialize the $P macro. 	*/
name|Database
operator|=
name|Parmvect
index|[
literal|0
index|]
expr_stmt|;
name|proctab
operator|=
name|Parmvect
index|[
literal|1
index|]
expr_stmt|;
name|smove
argument_list|(
name|Pathname
argument_list|,
name|Macro
index|[
literal|'P'
operator|-
literal|'A'
index|]
argument_list|)
expr_stmt|;
comment|/* scan flags in users file */
for|for
control|(
name|p
operator|=
name|uservect
index|[
literal|0
index|]
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* skip initial blanks and tabs */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
continue|continue;
name|ptr
operator|=
name|p
expr_stmt|;
comment|/* find end of flag and null-terminate it */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|i
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* process the flag */
name|doflag
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'\0'
condition|)
break|break;
block|}
comment|/* scan flags on command line */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|Flagvect
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|doflag
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* check for query modification specified for this database */
if|if
condition|(
operator|(
name|Admin
operator|.
name|adhdr
operator|.
name|adflags
operator|&
name|A_QRYMOD
operator|)
operator|==
literal|0
condition|)
name|doflag
argument_list|(
literal|"-q"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* close any extraneous files, being careful not to close anything we need */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|'0'
init|;
name|j
operator|<=
literal|'9'
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|Pipe
index|[
name|j
index|]
operator|.
name|pip_wfd
operator|==
name|i
operator|||
name|Pipe
index|[
name|j
index|]
operator|.
name|pip_rfd
operator|==
name|i
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>
literal|'9'
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* determine process table */
if|if
condition|(
name|proctab
operator|==
name|NULL
condition|)
block|{
comment|/* use default proctab */
if|if
condition|(
name|DefProcTab
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
name|length
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'x'
condition|)
name|DefProcTab
operator|=
literal|"=procx"
expr_stmt|;
else|else
name|DefProcTab
operator|=
literal|"=proctab"
expr_stmt|;
name|proctab
operator|=
name|uservect
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|proctab
operator|==
name|NULL
operator|||
name|proctab
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* no proctab in users file */
name|concat
argument_list|(
name|DefProcTab
argument_list|,
name|VERSION
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|proctab
operator|=
name|buf
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* proctab specified; check permissions */
if|if
condition|(
operator|(
name|Status
operator|&
operator|(
name|proctab
index|[
literal|0
index|]
operator|==
literal|'='
condition|?
name|U_EPROCTAB
else|:
name|U_APROCTAB
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"You may not specify this process table\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
block|}
comment|/* expand process table name */
if|if
condition|(
name|proctab
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
block|{
name|smove
argument_list|(
name|ztack
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/files/"
argument_list|)
argument_list|,
operator|&
name|proctab
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|proctab
operator|=
name|buf
expr_stmt|;
block|}
comment|/* open and read the process table */
if|if
condition|(
operator|(
name|ProcFile
operator|=
name|fopen
argument_list|(
name|proctab
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Proctab %s: %s\n"
argument_list|,
name|proctab
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
comment|/* build internal form of the process table */
if|if
condition|(
name|yyparse
argument_list|()
condition|)
name|No_exec
operator|++
expr_stmt|;
comment|/* don't bother executing if we have found errors */
if|if
condition|(
name|No_exec
condition|)
block|{
name|usage
label|:
comment|/* cat .../files/usage */
name|cat
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/files/usage"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ProcFile
argument_list|)
expr_stmt|;
comment|/* set locks on the database */
name|dolocks
argument_list|()
expr_stmt|;
comment|/* satisfy process table (never returns) */
name|satisfypt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Process rubouts (just exit) */
end_comment

begin_macro
name|rubproc
argument_list|()
end_macro

begin_block
block|{
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DOFLAG -- process flag ** **	Parameters: **		flag -- the flag (as a string) **		where -- where it is called from **			-1 -- internally inserted **			0 -- on user command line **			1 -- from users file ** **	Return: **		none ** **	Side effects: **		All flags are inserted on the end of the **		"Flaglist" vector for passing to the processes. **		The "No_exec" flag is set if the flag is bad or you **		are not authorized to use it. ** **	Requires: **		Status -- to get the status bits set for this user. **		syserr -- for the obvious **		printf -- to print errors **		atoi -- to check syntax on numerically-valued flags ** **	Defines: **		doflag() **		Flagok -- a list of legal flags and attributes (for **			local use only). **		Relmode -- a list of legal relation modes. ** **	Called by: **		main ** **	History: **		11/6/79 (6.2/8) (eric) -- -u flag processing dropped, **			since initucode does it anyhow.  -E flag **			removed (what is it?).  F_USER code dropped. **			F_DROP is still around; we may need it some- **			day.  Also, test of U_SUPER flag and/or DBA **			status was wrong. **		7/5/78 (eric) -- NETFLAG added to list. **		3/27/78 (eric) -- EQUELFLAG added to the list. **		1/29/78 -- do_u_flag broken off by eric **		1/4/78 -- written by eric */
end_comment

begin_struct
struct|struct
name|flag
block|{
name|char
name|flagname
decl_stmt|;
comment|/* name of the flag */
name|char
name|flagstat
decl_stmt|;
comment|/* status of flag (see below) */
name|int
name|flagsyntx
decl_stmt|;
comment|/* syntax code for this flag */
name|int
name|flagperm
decl_stmt|;
comment|/* status bits needed to use this flag */
name|char
modifier|*
name|flagpt
decl_stmt|;
comment|/* default proctab to use with this flag */
block|}
struct|;
end_struct

begin_comment
comment|/* status bits for flag */
end_comment

begin_define
define|#
directive|define
name|F_PLOK
value|01
end_define

begin_comment
comment|/* allow +x form */
end_comment

begin_define
define|#
directive|define
name|F_PLD
value|02
end_define

begin_comment
comment|/* defaults to +x */
end_comment

begin_define
define|#
directive|define
name|F_DBA
value|04
end_define

begin_comment
comment|/* must be the DBA to use */
end_comment

begin_define
define|#
directive|define
name|F_DROP
value|010
end_define

begin_comment
comment|/* don't save in Flaglist */
end_comment

begin_comment
comment|/* syntax codes */
end_comment

begin_define
define|#
directive|define
name|F_ACCPT
value|1
end_define

begin_comment
comment|/* always accept */
end_comment

begin_define
define|#
directive|define
name|F_C_SPEC
value|3
end_define

begin_comment
comment|/* -cN spec */
end_comment

begin_define
define|#
directive|define
name|F_I_SPEC
value|4
end_define

begin_comment
comment|/* -inN spec */
end_comment

begin_define
define|#
directive|define
name|F_F_SPEC
value|5
end_define

begin_comment
comment|/* -fnxN.M spec */
end_comment

begin_define
define|#
directive|define
name|F_CHAR
value|6
end_define

begin_comment
comment|/* single character */
end_comment

begin_define
define|#
directive|define
name|F_MODE
value|7
end_define

begin_comment
comment|/* a modify mode */
end_comment

begin_define
define|#
directive|define
name|F_INTERNAL
value|8
end_define

begin_comment
comment|/* internal flag, e.g., -q */
end_comment

begin_define
define|#
directive|define
name|F_EQUEL
value|9
end_define

begin_comment
comment|/* EQUEL flag */
end_comment

begin_decl_stmt
name|struct
name|flag
name|Flagok
index|[]
init|=
block|{
literal|'a'
block|,
name|F_PLD
operator||
name|F_PLOK
block|,
name|F_ACCPT
block|,
literal|0
block|,
name|NULL
block|,
literal|'b'
block|,
name|F_PLD
operator||
name|F_PLOK
block|,
name|F_ACCPT
block|,
name|U_DRCTUPDT
block|,
name|NULL
block|,
literal|'c'
block|,
literal|0
block|,
name|F_C_SPEC
block|,
literal|0
block|,
name|NULL
block|,
literal|'d'
block|,
name|F_PLD
operator||
name|F_PLOK
block|,
name|F_ACCPT
block|,
literal|0
block|,
name|NULL
block|,
literal|'f'
block|,
literal|0
block|,
name|F_F_SPEC
block|,
literal|0
block|,
name|NULL
block|,
literal|'i'
block|,
literal|0
block|,
name|F_I_SPEC
block|,
literal|0
block|,
name|NULL
block|,
literal|'n'
block|,
literal|0
block|,
name|F_MODE
block|,
literal|0
block|,
name|NULL
block|,
literal|'q'
block|,
name|F_PLD
operator||
name|F_PLOK
block|,
name|F_INTERNAL
block|,
literal|0
block|,
name|NULL
block|,
literal|'r'
block|,
literal|0
block|,
name|F_MODE
block|,
literal|0
block|,
name|NULL
block|,
literal|'s'
block|,
name|F_PLD
operator||
name|F_PLOK
block|,
name|F_ACCPT
block|,
literal|0
block|,
name|NULL
block|,
literal|'v'
block|,
literal|0
block|,
name|F_CHAR
block|,
literal|0
block|,
name|NULL
block|,
literal|'w'
block|,
name|F_PLOK
operator||
name|F_DROP
block|,
name|F_ACCPT
block|,
literal|0
block|,
name|NULL
block|,
literal|'D'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
literal|'L'
block|,
name|F_PLOK
block|,
name|F_ACCPT
block|,
literal|0
block|,
name|NULL
block|,
literal|'M'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
literal|'O'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
literal|'P'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
literal|'Q'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
literal|'T'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
literal|'U'
block|,
name|F_PLOK
block|,
name|F_ACCPT
block|,
name|U_UPSYSCAT
block|,
name|NULL
block|,
literal|'Z'
block|,
literal|0
block|,
name|F_ACCPT
block|,
name|U_TRACE
block|,
name|NULL
block|,
name|EQUELFLAG
block|,
literal|0
block|,
name|F_EQUEL
block|,
literal|0
block|,
literal|"=equel"
block|,
name|NETFLAG
block|,
literal|0
block|,
name|F_EQUEL
block|,
literal|0
block|,
literal|"=slave"
block|,
literal|'@'
block|,
literal|0
block|,
name|F_EQUEL
block|,
literal|0
block|,
name|NULL
block|,
literal|'*'
block|,
literal|0
block|,
name|F_ACCPT
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of valid retrieve into or index modes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Relmode
index|[]
init|=
block|{
literal|"isam"
block|,
literal|"cisam"
block|,
literal|"hash"
block|,
literal|"chash"
block|,
literal|"heap"
block|,
literal|"cheap"
block|,
literal|"heapsort"
block|,
literal|"cheapsort"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|doflag
argument_list|(
argument|flag
argument_list|,
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|flag
modifier|*
name|f
decl_stmt|;
specifier|auto
name|int
name|intxx
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
specifier|extern
name|int
name|Status
decl_stmt|;
name|p
operator|=
name|flag
expr_stmt|;
comment|/* check for valid flag format (begin with + or -) */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
goto|goto
name|badflag
goto|;
comment|/* check for flag in table */
for|for
control|(
name|f
operator|=
name|Flagok
init|;
name|f
operator|->
name|flagname
operator|!=
name|p
index|[
literal|1
index|]
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
operator|->
name|flagname
operator|==
literal|0
condition|)
goto|goto
name|badflag
goto|;
block|}
comment|/* check for +x form allowed */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
operator|(
name|f
operator|->
name|flagstat
operator|&
name|F_PLOK
operator|)
operator|==
literal|0
condition|)
goto|goto
name|badflag
goto|;
comment|/* check for permission to use the flag */
if|if
condition|(
operator|(
name|f
operator|->
name|flagperm
operator|!=
literal|0
operator|&&
operator|(
name|Status
operator|&
name|f
operator|->
name|flagperm
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|f
operator|->
name|flagstat
operator|&
name|F_PLD
operator|)
operator|==
literal|0
operator|)
condition|?
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'+'
operator|)
else|:
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|f
operator|->
name|flagstat
operator|&
name|F_DBA
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|Status
operator|&
name|U_SUPER
operator|)
operator|==
literal|0
operator|&&
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"You are not authorized to use the %s flag\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|No_exec
operator|++
expr_stmt|;
block|}
comment|/* check syntax */
switch|switch
condition|(
name|f
operator|->
name|flagsyntx
condition|)
block|{
case|case
name|F_ACCPT
case|:
break|break;
case|case
name|F_C_SPEC
case|:
if|if
condition|(
name|atoi
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
operator|&
name|intxx
argument_list|)
operator|||
name|intxx
operator|>
name|MAXFIELD
condition|)
goto|goto
name|badflag
goto|;
break|break;
case|case
name|F_I_SPEC
case|:
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|'1'
operator|&&
name|p
index|[
literal|2
index|]
operator|!=
literal|'2'
operator|&&
name|p
index|[
literal|2
index|]
operator|!=
literal|'4'
condition|)
goto|goto
name|badflag
goto|;
if|if
condition|(
name|atoi
argument_list|(
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
operator|&
name|intxx
argument_list|)
operator|||
name|intxx
operator|>
name|MAXFIELD
condition|)
goto|goto
name|badflag
goto|;
break|break;
case|case
name|F_F_SPEC
case|:
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
literal|'4'
operator|&&
name|p
index|[
literal|2
index|]
operator|!=
literal|'8'
condition|)
goto|goto
name|badflag
goto|;
switch|switch
condition|(
name|p
index|[
literal|3
index|]
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
break|break;
default|default:
goto|goto
name|badflag
goto|;
block|}
name|ptr
operator|=
operator|&
name|p
index|[
literal|4
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'.'
condition|)
if|if
condition|(
operator|*
name|ptr
operator|==
literal|0
condition|)
goto|goto
name|badflag
goto|;
else|else
name|ptr
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
operator|&
name|p
index|[
literal|4
index|]
argument_list|,
operator|&
name|intxx
argument_list|)
operator|||
name|intxx
operator|>
name|MAXFIELD
condition|)
goto|goto
name|badflag
goto|;
operator|*
name|ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|ptr
argument_list|,
operator|&
name|intxx
argument_list|)
operator|||
name|intxx
operator|>
name|MAXFIELD
condition|)
goto|goto
name|badflag
goto|;
break|break;
case|case
name|F_CHAR
case|:
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
goto|goto
name|badflag
goto|;
break|break;
case|case
name|F_MODE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ptr
operator|=
name|Relmode
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sequal
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|ptr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|badflag
goto|;
break|break;
case|case
name|F_INTERNAL
case|:
if|if
condition|(
name|where
operator|>=
literal|0
condition|)
goto|goto
name|badflag
goto|;
break|break;
case|case
name|F_EQUEL
case|:
name|ptr
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
name|CLOSED
condition|)
continue|continue;
if|if
condition|(
operator|*
name|ptr
operator|<
literal|0100
operator|||
operator|*
name|ptr
operator|>=
literal|0100
operator|+
name|NOFILE
condition|)
break|break;
name|j
operator|=
operator|(
name|i
operator|/
literal|2
operator|)
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|01
operator|)
operator|==
literal|0
condition|)
block|{
name|Pipe
index|[
name|j
index|]
operator|.
name|pip_rfd
operator|=
operator|*
name|ptr
operator|&
literal|077
expr_stmt|;
block|}
else|else
block|{
name|Pipe
index|[
name|j
index|]
operator|.
name|pip_wfd
operator|=
operator|*
name|ptr
operator|&
literal|077
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"doflag: syntx %d"
argument_list|,
name|f
operator|->
name|flagsyntx
argument_list|)
expr_stmt|;
block|}
comment|/* save flag */
if|if
condition|(
name|Nopts
operator|>=
name|MAXOPTNS
condition|)
block|{
name|printf
argument_list|(
literal|"Too many options to INGRES\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|->
name|flagstat
operator|&
name|F_DROP
operator|)
operator|==
literal|0
condition|)
name|Opt
index|[
name|Nopts
operator|++
index|]
operator|=
name|p
expr_stmt|;
comment|/* change to new process table as appropriate */
if|if
condition|(
name|f
operator|->
name|flagpt
operator|!=
name|NULL
condition|)
name|DefProcTab
operator|=
name|f
operator|->
name|flagpt
expr_stmt|;
return|return;
name|badflag
label|:
name|printf
argument_list|(
literal|"Bad flag format: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|No_exec
operator|++
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DOLOCKS -- set database lock ** **	A lock is set on the database. */
end_comment

begin_macro
name|dolocks
argument_list|()
end_macro

begin_block
block|{
name|db_lock
argument_list|(
name|flagval
argument_list|(
literal|'E'
argument_list|)
operator|>
literal|0
condition|?
name|M_EXCL
else|:
name|M_SHARE
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Alockdes
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FLAGVAL -- return value of flag ** **	Parameter: **		flag -- the name of the flag ** **	Return: **		-1 -- flag is de-asserted (-x) **		0 -- flag is not specified **		1 -- flag is asserted (+x) ** **	Requires: **		Opt -- to scan the flags ** **	Defines: **		flagval ** **	Called by: **		buildint **		dolocks ** **	History: **		3/27/78 (eric) -- changed to handle EQUEL flag **			normally. **		1/4/78 -- written by eric */
end_comment

begin_macro
name|flagval
argument_list|(
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|char
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|o
decl_stmt|;
name|f
operator|=
name|flag
expr_stmt|;
comment|/* start scanning option list */
for|for
control|(
name|p
operator|=
name|Opt
init|;
operator|(
name|o
operator|=
operator|*
name|p
operator|)
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|o
index|[
literal|1
index|]
operator|==
name|f
condition|)
if|if
condition|(
name|o
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SATISFYPT -- satisfy the process table ** **	Well folks, now that you've read this far, this is it!!!  I **	mean, this one really does it!!!  It takes the internal form **	built by the parser and creates pipes as necessary, forks, and **	execs the INGRES processes.  Isn't that neat? ** **	Parameters: **		none ** **	Returns: **		never ** **	Requires: **		Proctab -- the internal form **		ingexec -- to actually exec the process **		pipe -- to create the pipe **		syserr -- for the obvious **		fillpipe -- to extend a newly opened pipe through all **			further references to it. **		checkpipes -- to see if a given pipe will ever be **			referenced again. **		fork -- to create a new process ** **	Defines: **		satisfypt ** **	Called by: **		main ** **	History: **		3/14/80 (eric) -- changed for version 7.0. **		7/24/78 (eric) -- Actual file descriptors stored in **			'prpipes' are changed to have the 0100 bit **			set internally (as well as externally), so **			fd 0 will work correctly. **		1/4/78 -- written by eric */
end_comment

begin_macro
name|satisfypt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|pr
decl_stmt|;
specifier|register
name|proc_t
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|procno
decl_stmt|;
specifier|register
name|int
name|pip
decl_stmt|;
comment|/* scan the process table */
for|for
control|(
name|procno
operator|=
name|CM_MAXPROC
operator|-
literal|1
init|;
name|procno
operator|>=
literal|0
condition|;
name|procno
operator|--
control|)
block|{
name|pr
operator|=
operator|&
name|ProcTab
index|[
name|procno
index|]
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|prpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* scan pipe vector, creating new pipes as needed */
name|pipeopen
argument_list|(
name|pr
operator|->
name|prmpipe
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pipeopen
argument_list|(
name|pr
operator|->
name|prcm
operator|.
name|cm_input
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pipeopen
argument_list|(
name|pr
operator|->
name|prcm
operator|.
name|cm_rinput
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CM_MAXPROC
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
operator|&
name|pr
operator|->
name|prcm
operator|.
name|cm_proc
index|[
name|i
index|]
expr_stmt|;
name|pipeopen
argument_list|(
name|pp
operator|->
name|pr_file
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pipeopen
argument_list|(
name|pp
operator|->
name|pr_ninput
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* substitute real file descriptors throughout */
name|pipexlat
argument_list|(
operator|&
name|pr
operator|->
name|prmpipe
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pipexlat
argument_list|(
operator|&
name|pr
operator|->
name|prcm
operator|.
name|cm_input
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pipexlat
argument_list|(
operator|&
name|pr
operator|->
name|prcm
operator|.
name|cm_rinput
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CM_MAXPROC
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
operator|&
name|pr
operator|->
name|prcm
operator|.
name|cm_proc
index|[
name|i
index|]
expr_stmt|;
name|pipexlat
argument_list|(
operator|&
name|pp
operator|->
name|pr_file
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pipexlat
argument_list|(
operator|&
name|pp
operator|->
name|pr_ninput
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* fork if necessary */
if|if
condition|(
operator|--
name|NumProcs
operator|<=
literal|0
operator|||
operator|(
name|i
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* child!! */
name|ingexec
argument_list|(
name|procno
argument_list|)
expr_stmt|;
block|}
comment|/* parent */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"satisfypt: fork"
argument_list|)
expr_stmt|;
comment|/* scan pipes.  close all not used in the future */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|CLOSED
condition|)
continue|continue;
if|if
condition|(
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_rcnt
operator|<=
literal|0
operator|&&
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_rfd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_rfd
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"satisfypt: close-r(%d)"
argument_list|,
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_rfd
argument_list|)
expr_stmt|;
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_rfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_wcnt
operator|<=
literal|0
operator|&&
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_wfd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_wfd
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"satisfypt: close-w(%d)"
argument_list|,
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_wfd
argument_list|)
expr_stmt|;
name|Pipe
index|[
name|i
index|]
operator|.
name|pip_wfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
name|syserr
argument_list|(
literal|"satisfypt: fell out"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PIPEOPEN -- open pipe if necessary. */
end_comment

begin_macro
name|pipeopen
argument_list|(
argument|pipid
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|char
name|pipid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pipeinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|pipex
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipid
operator|==
literal|'\0'
condition|)
return|return;
name|pi
operator|=
operator|&
name|Pipe
index|[
name|pipid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rw
condition|?
name|pi
operator|->
name|pip_wfd
else|:
name|pi
operator|->
name|pip_rfd
operator|)
operator|>=
literal|0
condition|)
return|return;
if|if
condition|(
name|pi
operator|->
name|pip_rfd
operator|>=
literal|0
operator|||
name|pi
operator|->
name|pip_wfd
operator|>=
literal|0
condition|)
name|syserr
argument_list|(
literal|"pipeopen %o %d: rfd=%d, wfd=%d"
argument_list|,
name|pipid
argument_list|,
name|rw
argument_list|,
name|pi
operator|->
name|pip_rfd
argument_list|,
name|pi
operator|->
name|pip_wfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipid
operator|==
name|CLOSED
condition|)
name|pi
operator|->
name|pip_rfd
operator|=
name|pi
operator|->
name|pip_wfd
operator|=
name|CLOSED
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pipex
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"pipeopen: pipe"
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pip_rfd
operator|=
name|pipex
index|[
literal|0
index|]
expr_stmt|;
name|pi
operator|->
name|pip_wfd
operator|=
name|pipex
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHECKPIPES -- check for pipe referenced in the future ** **	Parameters: **		proc -- point in the process table to start looking **			from. **		fd -- the file descriptor to look for. ** **	Return: **		zero -- it will be referenced in the future. **		one -- it is never again referenced. ** **	Requires: **		nothing ** **	Defines: **		checkpipes ** **	Called by: **		satisfypt ** **	History: **		7/24/78 (eric) -- 0100 bit on file descriptors handled. **		1/4/78 -- written by eric */
end_comment

begin_macro
name|checkpipes
argument_list|(
argument|proc
argument_list|,
argument|fd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|proc
modifier|*
name|pr
decl_stmt|;
specifier|register
name|proc_t
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|pr
operator|=
name|proc
init|;
name|pr
operator|<
operator|&
name|ProcTab
index|[
name|CM_MAXPROC
index|]
condition|;
name|pr
operator|++
control|)
block|{
if|if
condition|(
name|pr
operator|->
name|prpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CM_MAXPROC
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
operator|&
name|pr
operator|->
name|prcm
operator|.
name|cm_proc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|pr_file
operator|==
name|fd
operator|||
name|pp
operator|->
name|pr_ninput
operator|==
name|fd
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INGEXEC -- execute INGRES process ** **	This routine handles all the setup of the argument vector **	and then executes a process. ** **	Parameters: **		process -- a pointer to the process table entry which **			describes this process. ** **	Returns: **		never ** **	Side Effects: **		never returns, but starts up a new overlay.  Notice **			that it does NOT fork. ** **	Requires: **		none ** **	Called By: **		satisfypt ** **	Trace Flags: **		none ** **	Diagnostics: **		none ** **	Syserrs: **		chdir %s -- could not change directory into the data- **			base. **		creat %s -- could not create the redirected standard **			output file. **		%s not executable -- could not execute the process. ** **	History: **		8/9/78 (eric) -- changed "prparam" to be a colon- **			separated list of parameters (so the number **			is variable); also, moved parameter expansion **			into this routine from buildint() so that **			the colons in the dbu part of the proctab **			would not confuse things. **		7/24/78 (eric) -- changed the technique of closing **			files 0& 2 so that they will never be closed **			(even if requested in the status field) **			if they are mentioned in the pipe vector. **			Also, some fiddling is done to handle the **			0100 bit on file descriptors correctly. */
end_comment

begin_macro
name|ingexec
argument_list|(
argument|procno
argument_list|)
end_macro

begin_decl_stmt
name|int
name|procno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|vect
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
modifier|*
name|opt
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|pr
decl_stmt|;
specifier|register
name|proc_t
modifier|*
name|pp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|outfd
decl_stmt|;
name|char
name|closeit
index|[
name|NOFILE
index|]
decl_stmt|;
name|char
name|fdbuf
index|[
literal|3
index|]
decl_stmt|;
name|v
operator|=
name|vect
expr_stmt|;
name|pr
operator|=
operator|&
name|ProcTab
index|[
name|procno
index|]
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|pr
operator|->
name|prpath
expr_stmt|;
name|fdbuf
index|[
literal|0
index|]
operator|=
name|pr
operator|->
name|prcm
operator|.
name|cm_rinput
operator||
literal|0100
expr_stmt|;
name|fdbuf
index|[
literal|1
index|]
operator|=
name|pr
operator|->
name|prtflag
expr_stmt|;
name|fdbuf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|fdbuf
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|Fileset
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|Usercode
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|Database
expr_stmt|;
operator|*
name|v
operator|++
operator|=
name|Pathname
expr_stmt|;
comment|/* insert flag parameters */
for|for
control|(
name|opt
operator|=
name|Opt
init|;
operator|*
name|opt
condition|;
name|opt
operator|++
control|)
operator|*
name|v
operator|++
operator|=
operator|*
name|opt
expr_stmt|;
operator|*
name|v
operator|=
literal|0
expr_stmt|;
comment|/* set up 'closeit' to tell which pipes to close */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
name|closeit
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|closeit
index|[
name|pr
operator|->
name|prmpipe
operator|&
literal|077
index|]
operator|=
name|FALSE
expr_stmt|;
name|closeit
index|[
name|pr
operator|->
name|prcm
operator|.
name|cm_input
operator|&
literal|077
index|]
operator|=
name|FALSE
expr_stmt|;
name|closeit
index|[
name|pr
operator|->
name|prcm
operator|.
name|cm_rinput
operator|&
literal|077
index|]
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CM_MAXPROC
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
operator|&
name|pr
operator|->
name|prcm
operator|.
name|cm_proc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|pr_ninput
operator|!=
name|CLOSED
condition|)
name|closeit
index|[
name|pp
operator|->
name|pr_ninput
operator|&
literal|077
index|]
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|pr_file
operator|!=
name|CLOSED
condition|)
name|closeit
index|[
name|pp
operator|->
name|pr_file
operator|&
literal|077
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
name|closeit
index|[
literal|1
index|]
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|pr
operator|->
name|prstat
operator|&
name|PR_CLSSIN
operator|)
operator|==
literal|0
condition|)
name|closeit
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|pr
operator|->
name|prstat
operator|&
name|PR_CLSDOUT
operator|)
operator|==
literal|0
condition|)
name|closeit
index|[
literal|2
index|]
operator|=
name|FALSE
expr_stmt|;
comment|/* close extra pipes (those not used by this process) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|closeit
index|[
name|i
index|]
condition|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* change to the correct directory */
if|if
condition|(
operator|(
name|pr
operator|->
name|prstat
operator|&
name|PR_NOCHDIR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|Dbpath
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ingexec: chdir %s"
argument_list|,
name|Dbpath
argument_list|)
expr_stmt|;
block|}
comment|/* change to normal userid/groupid if a non-dangerous process */
if|if
condition|(
operator|(
name|pr
operator|->
name|prstat
operator|&
name|PR_REALUID
operator|)
operator|!=
literal|0
condition|)
block|{
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|xB_UNIX
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|LEAVEOUT
comment|/* change standard output if specified in proctab */
name|p
operator|=
name|pr
operator|->
name|prstdout
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
comment|/* chew up fd 0 (just in case) */
name|outfd
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|creat
argument_list|(
name|p
argument_list|,
literal|0666
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* restore standard output and print error */
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|outfd
argument_list|)
expr_stmt|;
comment|/* better go into slot 1 */
name|syserr
argument_list|(
literal|"ingexec: creat %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|outfd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|LEAVEOUT
comment|/* 	**  PLEASE NOTE THE TRICKERY USED HERE. 	**	In this code I depend on UNIX buffering pipes at least 	**	enough to handle one "CM" struct.  If not, the following 	**	write will hang before the exec will call the process 	**	that will read it. 	** 	**	The "correct" way to do this is to fork& have the 	**	parent write the CM struct.  But how do I handle the 	**	last one (that does not fork)?  I could also do an 	**	extra fork of a process to do the write.  But some 	**	systems have a limit on processes, and besides, it 	**	seems like a lot of overhead for such a little thing. 	** 	**	Perhaps I should encode the CM struct into argv 	**	instead& do it "right". 	*/
comment|/* output the control structure to the awaiting process... */
name|write
argument_list|(
name|pr
operator|->
name|prmpipe
operator|&
literal|077
argument_list|,
operator|&
name|pr
operator|->
name|prcm
argument_list|,
sizeof|sizeof
name|pr
operator|->
name|prcm
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pr
operator|->
name|prmpipe
operator|&
literal|077
argument_list|)
expr_stmt|;
comment|/* give it the old college (or in this case, University) try */
name|execv
argument_list|(
name|vect
index|[
literal|0
index|]
argument_list|,
name|vect
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"\"%s\" not executable"
argument_list|,
name|vect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pipexlat
argument_list|(
argument|ppip
argument_list|,
argument|rw
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ppip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pipeinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|*
name|ppip
operator|==
literal|'\0'
operator|||
operator|*
name|ppip
operator|==
name|CLOSED
condition|)
return|return;
name|pi
operator|=
operator|&
name|Pipe
index|[
operator|*
name|ppip
index|]
expr_stmt|;
if|if
condition|(
name|rw
condition|)
block|{
name|cnt
operator|=
operator|--
operator|(
name|pi
operator|->
name|pip_wcnt
operator|)
expr_stmt|;
name|fd
operator|=
name|pi
operator|->
name|pip_wfd
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
operator|--
operator|(
name|pi
operator|->
name|pip_rcnt
operator|)
expr_stmt|;
name|fd
operator|=
name|pi
operator|->
name|pip_rfd
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"pipexlat: cnt=%d: %o %d"
argument_list|,
name|cnt
argument_list|,
operator|*
name|ppip
argument_list|,
name|rw
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|fd
operator|>
name|NOFILE
condition|)
name|syserr
argument_list|(
literal|"pipexlat: fd=%d: %o %d"
argument_list|,
name|fd
argument_list|,
operator|*
name|ppip
argument_list|,
name|rw
argument_list|)
expr_stmt|;
operator|*
name|ppip
operator|=
name|fd
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  YYLEX -- Return next token from proctab ** **	Parameters: **		none ** **	Returns: **		Next token ** **	Side Effects: **		Input from proctab */
end_comment

begin_define
define|#
directive|define
name|BOLSTATE
value|0
end_define

begin_comment
comment|/* beginning of line */
end_comment

begin_define
define|#
directive|define
name|NORMSTATE
value|1
end_define

begin_comment
comment|/* normal token */
end_comment

begin_define
define|#
directive|define
name|EOFSTATE
value|2
end_define

begin_comment
comment|/* end of file */
end_comment

begin_decl_stmt
name|int
name|LineNo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number */
end_comment

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|state
decl_stmt|;
specifier|static
name|char
modifier|*
name|ptp
decl_stmt|;
specifier|auto
name|int
name|ix
decl_stmt|;
specifier|static
name|char
name|line
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|EOFSTATE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|BOLSTATE
case|:
name|ptp
operator|=
name|line
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|LineNo
operator|++
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|ProcFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|state
operator|=
name|EOFSTATE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
case|case
literal|'#'
case|:
case|case
literal|'\n'
case|:
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ProcFile
argument_list|)
operator|)
operator|>
literal|0
condition|)
continue|continue;
break|break;
case|case
literal|':'
case|:
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ProcFile
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* regular line, return header */
name|state
operator|=
name|NORMSTATE
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
case|case
name|NORMSTATE
case|:
name|yylval
operator|.
name|yystr
operator|=
name|ptp
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|ProcFile
argument_list|)
operator|)
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|>
literal|0
condition|)
block|{
operator|*
name|ptp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|ProcFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|'A'
operator|||
name|c
operator|>
literal|'Z'
condition|)
operator|*
name|ptp
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|ptp
operator|--
expr_stmt|;
for|for
control|(
name|p
operator|=
name|Macro
index|[
name|c
operator|-
literal|'A'
index|]
init|;
operator|(
operator|*
name|ptp
operator|++
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
control|)
continue|continue;
name|ptp
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* compute next state */
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
name|state
operator|=
name|BOLSTATE
expr_stmt|;
operator|*
name|ptp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|yylval
operator|.
name|yystr
argument_list|,
operator|&
name|ix
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|yylval
operator|.
name|yystr
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
name|ix
operator|=
name|oatoi
argument_list|(
name|yylval
operator|.
name|yystr
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|yyint
operator|=
name|ix
expr_stmt|;
return|return
operator|(
name|INT
operator|)
return|;
block|}
else|else
return|return
operator|(
name|STR
operator|)
return|;
default|default:
name|syserr
argument_list|(
literal|"yylex: state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|syserr
argument_list|(
literal|"Line %d: Yacc error: %s"
argument_list|,
name|LineNo
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|usrerr
argument_list|(
argument|f
argument_list|,
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|p3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"Line %d: "
argument_list|,
name|LineNo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|f
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|p3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|short
name|yyexca
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
literal|0
block|, 	}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYNPROD
value|27
end_define

begin_define
define|#
directive|define
name|YYLAST
value|55
end_define

begin_decl_stmt
name|short
name|yyact
index|[]
init|=
block|{
literal|45
block|,
literal|38
block|,
literal|34
block|,
literal|27
block|,
literal|26
block|,
literal|19
block|,
literal|29
block|,
literal|22
block|,
literal|36
block|,
literal|17
block|,
literal|13
block|,
literal|7
block|,
literal|28
block|,
literal|37
block|,
literal|21
block|,
literal|16
block|,
literal|15
block|,
literal|10
block|,
literal|3
block|,
literal|30
block|,
literal|23
block|,
literal|8
block|,
literal|14
block|,
literal|6
block|,
literal|12
block|,
literal|11
block|,
literal|5
block|,
literal|20
block|,
literal|9
block|,
literal|4
block|,
literal|2
block|,
literal|24
block|,
literal|1
block|,
literal|44
block|,
literal|18
block|,
literal|33
block|,
literal|25
block|,
literal|32
block|,
literal|31
block|,
literal|35
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|39
block|,
literal|0
block|,
literal|0
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|0
block|,
literal|43
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yypact
index|[]
init|=
block|{
operator|-
literal|57
block|,
operator|-
literal|1000
block|,
operator|-
literal|57
block|,
operator|-
literal|1000
block|,
operator|-
literal|66
block|,
operator|-
literal|1000
block|,
operator|-
literal|248
block|,
operator|-
literal|253
block|,
operator|-
literal|1000
block|,
operator|-
literal|66
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|250
block|,
operator|-
literal|1000
block|,
operator|-
literal|248
block|,
operator|-
literal|254
block|,
operator|-
literal|1000
block|,
operator|-
literal|255
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|251
block|,
operator|-
literal|1000
block|,
operator|-
literal|250
block|,
operator|-
literal|251
block|,
operator|-
literal|256
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|249
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|257
block|,
operator|-
literal|257
block|,
operator|-
literal|1000
block|,
operator|-
literal|250
block|,
operator|-
literal|1000
block|,
operator|-
literal|257
block|,
operator|-
literal|1000
block|,
operator|-
literal|251
block|,
operator|-
literal|1000
block|,
operator|-
literal|251
block|,
operator|-
literal|258
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|,
operator|-
literal|1000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yypgo
index|[]
init|=
block|{
literal|0
block|,
literal|15
block|,
literal|14
block|,
literal|39
block|,
literal|12
block|,
literal|36
block|,
literal|35
block|,
literal|13
block|,
literal|34
block|,
literal|33
block|,
literal|32
block|,
literal|30
block|,
literal|18
block|,
literal|29
block|,
literal|28
block|,
literal|26
block|,
literal|17
block|,
literal|25
block|,
literal|24
block|,
literal|22
block|,
literal|20
block|,
literal|19
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yyr1
index|[]
init|=
block|{
literal|0
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|14
block|,
literal|16
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|15
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|9
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yyr2
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|7
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|2
block|,
literal|6
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yychk
index|[]
init|=
block|{
operator|-
literal|1000
block|,
operator|-
literal|10
block|,
operator|-
literal|11
block|,
operator|-
literal|12
block|,
operator|-
literal|13
block|,
operator|-
literal|15
block|,
literal|80
block|,
literal|68
block|,
operator|-
literal|12
block|,
operator|-
literal|14
block|,
operator|-
literal|16
block|,
operator|-
literal|17
block|,
operator|-
literal|18
block|,
literal|76
block|,
operator|-
literal|19
block|,
literal|82
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|8
block|,
literal|258
block|,
operator|-
literal|16
block|,
operator|-
literal|2
block|,
literal|257
block|,
operator|-
literal|20
block|,
operator|-
literal|1
block|,
operator|-
literal|5
block|,
literal|258
block|,
literal|258
block|,
operator|-
literal|4
block|,
literal|257
block|,
operator|-
literal|21
block|,
operator|-
literal|2
block|,
operator|-
literal|4
block|,
operator|-
literal|6
block|,
literal|258
block|,
operator|-
literal|3
block|,
literal|257
block|,
operator|-
literal|7
block|,
literal|258
block|,
operator|-
literal|7
block|,
operator|-
literal|2
block|,
operator|-
literal|7
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|9
block|,
literal|258
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yydef
index|[]
init|=
block|{
literal|0
block|,
operator|-
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|,
literal|0
block|,
literal|14
block|,
literal|0
block|,
literal|0
block|,
literal|18
block|,
literal|0
block|,
literal|26
block|,
literal|8
block|,
literal|0
block|,
literal|19
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
literal|17
block|,
literal|0
block|,
literal|25
block|,
literal|15
block|,
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|22
block|,
literal|0
block|,
literal|20
block|,
literal|0
block|,
literal|23
block|,
literal|0
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|13
block|,
literal|6
block|,
literal|24
block|}
decl_stmt|;
end_decl_stmt

begin_empty
empty|#
end_empty

begin_define
define|#
directive|define
name|YYFLAG
value|-1000
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|return(0)
end_define

begin_define
define|#
directive|define
name|YYABORT
value|return(1)
end_define

begin_comment
comment|/*	parser for yacc output	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYDEBUG
end_ifdef

begin_decl_stmt
name|int
name|yydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 for debugging */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|YYSTYPE
name|yyv
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the values are stored */
end_comment

begin_decl_stmt
name|int
name|yychar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input token number */
end_comment

begin_decl_stmt
name|int
name|yynerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors */
end_comment

begin_decl_stmt
name|short
name|yyerrflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error recovery flag */
end_comment

begin_macro
name|yyparse
argument_list|()
end_macro

begin_block
block|{
name|short
name|yys
index|[
name|YYMAXDEPTH
index|]
decl_stmt|;
name|short
name|yyj
decl_stmt|,
name|yym
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yypvt
decl_stmt|;
specifier|register
name|short
name|yystate
decl_stmt|,
modifier|*
name|yyps
decl_stmt|,
name|yyn
decl_stmt|;
specifier|register
name|YYSTYPE
modifier|*
name|yypv
decl_stmt|;
specifier|register
name|short
modifier|*
name|yyxi
decl_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yyps
operator|=
operator|&
name|yys
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yypv
operator|=
operator|&
name|yyv
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|yystack
label|:
comment|/* put a state and value onto the stack */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"state %d, char 0%o\n"
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|yyps
operator|>
operator|&
name|yys
index|[
name|YYMAXDEPTH
index|]
condition|)
block|{
name|yyerror
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|yyps
operator|=
name|yystate
expr_stmt|;
operator|++
name|yypv
expr_stmt|;
operator|*
name|yypv
operator|=
name|yyval
expr_stmt|;
name|yynewstate
label|:
name|yyn
operator|=
name|yypact
index|[
name|yystate
index|]
expr_stmt|;
if|if
condition|(
name|yyn
operator|<=
name|YYFLAG
condition|)
goto|goto
name|yydefault
goto|;
comment|/* simple state */
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|<
literal|0
operator|||
name|yyn
operator|>=
name|YYLAST
condition|)
goto|goto
name|yydefault
goto|;
if|if
condition|(
name|yychk
index|[
name|yyn
operator|=
name|yyact
index|[
name|yyn
index|]
index|]
operator|==
name|yychar
condition|)
block|{
comment|/* valid shift */
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
name|yyval
operator|=
name|yylval
expr_stmt|;
name|yystate
operator|=
name|yyn
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yystack
goto|;
block|}
name|yydefault
label|:
comment|/* default state action */
if|if
condition|(
operator|(
name|yyn
operator|=
name|yydef
index|[
name|yystate
index|]
operator|)
operator|==
operator|-
literal|2
condition|)
block|{
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
comment|/* look through exception table */
for|for
control|(
name|yyxi
operator|=
name|yyexca
init|;
operator|(
operator|*
name|yyxi
operator|!=
operator|(
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|yyxi
index|[
literal|1
index|]
operator|!=
name|yystate
operator|)
condition|;
name|yyxi
operator|+=
literal|2
control|)
empty_stmt|;
comment|/* VOID */
while|while
condition|(
operator|*
operator|(
name|yyxi
operator|+=
literal|2
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|yyxi
operator|==
name|yychar
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yyxi
index|[
literal|1
index|]
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* accept */
block|}
if|if
condition|(
name|yyn
operator|==
literal|0
condition|)
block|{
comment|/* error */
comment|/* error ... attempt to resume parsing */
switch|switch
condition|(
name|yyerrflag
condition|)
block|{
case|case
literal|0
case|:
comment|/* brand new error */
name|yyerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
name|yyerrlab
label|:
operator|++
name|yynerrs
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|2
case|:
comment|/* incompletely recovered error ... try again */
name|yyerrflag
operator|=
literal|3
expr_stmt|;
comment|/* find a state where "error" is a legal shift action */
while|while
condition|(
name|yyps
operator|>=
name|yys
condition|)
block|{
name|yyn
operator|=
name|yypact
index|[
operator|*
name|yyps
index|]
operator|+
name|YYERRCODE
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|0
operator|&&
name|yyn
operator|<
name|YYLAST
operator|&&
name|yychk
index|[
name|yyact
index|[
name|yyn
index|]
index|]
operator|==
name|YYERRCODE
condition|)
block|{
name|yystate
operator|=
name|yyact
index|[
name|yyn
index|]
expr_stmt|;
comment|/* simulate a shift of "error" */
goto|goto
name|yystack
goto|;
block|}
name|yyn
operator|=
name|yypact
index|[
operator|*
name|yyps
index|]
expr_stmt|;
comment|/* the current yyps has no shift onn "error", pop stack */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"error recovery pops state %d, uncovers %d\n"
argument_list|,
operator|*
name|yyps
argument_list|,
name|yyps
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|yyps
expr_stmt|;
operator|--
name|yypv
expr_stmt|;
block|}
comment|/* there is no state on the stack with an error shift ... abort */
name|yyabort
label|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|3
case|:
comment|/* no shift yet; clobber input char */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"error recovery discards char %d\n"
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyabort
goto|;
comment|/* don't discard EOF, quit */
name|yychar
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|yynewstate
goto|;
comment|/* try again in the same state */
block|}
block|}
comment|/* reduction by production yyn */
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"reduce %d\n"
argument_list|,
name|yyn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yyps
operator|-=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yypvt
operator|=
name|yypv
expr_stmt|;
name|yypv
operator|-=
name|yyr2
index|[
name|yyn
index|]
expr_stmt|;
name|yyval
operator|=
name|yypv
index|[
literal|1
index|]
expr_stmt|;
name|yym
operator|=
name|yyn
expr_stmt|;
comment|/* consult goto table to find next state */
name|yyn
operator|=
name|yyr1
index|[
name|yyn
index|]
expr_stmt|;
name|yyj
operator|=
name|yypgo
index|[
name|yyn
index|]
operator|+
operator|*
name|yyps
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|yyj
operator|>=
name|YYLAST
operator|||
name|yychk
index|[
name|yystate
operator|=
name|yyact
index|[
name|yyj
index|]
index|]
operator|!=
operator|-
name|yyn
condition|)
name|yystate
operator|=
name|yyact
index|[
name|yypgo
index|[
name|yyn
index|]
index|]
expr_stmt|;
switch|switch
condition|(
name|yym
condition|)
block|{
case|case
literal|6
case|:
line|#
directive|line
number|265
file|"ingres.y"
block|{
name|NumProcs
operator|++
expr_stmt|;
name|Proc
operator|=
operator|&
name|ProcTab
index|[
name|yypvt
index|[
operator|-
literal|5
index|]
operator|.
name|yyint
index|]
expr_stmt|;
name|smove
argument_list|(
name|yypvt
index|[
operator|-
literal|4
index|]
operator|.
name|yystr
argument_list|,
name|Proc
operator|->
name|prpath
argument_list|)
expr_stmt|;
name|Proc
operator|->
name|prmpipe
operator|=
name|Proc
operator|->
name|prcm
operator|.
name|cm_input
operator|=
name|Proc
operator|->
name|prcm
operator|.
name|cm_rinput
operator|=
name|Proc
operator|->
name|prcm
operator|.
name|cm_proc
index|[
name|yypvt
index|[
operator|-
literal|5
index|]
operator|.
name|yyint
index|]
operator|.
name|pr_ninput
operator|=
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|yypip
expr_stmt|;
name|smove
argument_list|(
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|yystr
argument_list|,
name|Proc
operator|->
name|prcm
operator|.
name|cm_myname
argument_list|)
expr_stmt|;
name|Proc
operator|->
name|prcm
operator|.
name|cm_myproc
operator|=
name|yypvt
index|[
operator|-
literal|5
index|]
operator|.
name|yyint
expr_stmt|;
name|Proc
operator|->
name|prstat
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|yyint
expr_stmt|;
name|Proc
operator|->
name|prtflag
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yychar
expr_stmt|;
name|Pipe
index|[
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|yypip
index|]
operator|.
name|pip_rcnt
operator|+=
literal|3
expr_stmt|;
name|Pipe
index|[
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|yypip
index|]
operator|.
name|pip_wcnt
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|289
file|"ingres.y"
block|{
name|StateP
operator|=
operator|&
name|Proc
operator|->
name|prcm
operator|.
name|cm_state
index|[
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|yyint
index|]
expr_stmt|;
name|StateP
operator|->
name|st_type
operator|=
name|ST_LOCAL
expr_stmt|;
name|StateP
operator|->
name|st_stat
operator|=
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|yyint
expr_stmt|;
name|StateP
operator|->
name|st_v
operator|.
name|st_loc
operator|.
name|st_funcno
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|yyint
expr_stmt|;
name|StateP
operator|->
name|st_v
operator|.
name|st_loc
operator|.
name|st_next
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
expr_stmt|;
block|}
break|break;
case|case
literal|13
case|:
line|#
directive|line
number|302
file|"ingres.y"
block|{
name|ProcNo
operator|=
name|yypvt
index|[
operator|-
literal|4
index|]
operator|.
name|yyint
expr_stmt|;
name|ProcP
operator|=
operator|&
name|Proc
operator|->
name|prcm
operator|.
name|cm_proc
index|[
name|ProcNo
index|]
expr_stmt|;
name|RemStat
operator|=
name|yypvt
index|[
operator|-
literal|3
index|]
operator|.
name|yyint
expr_stmt|;
name|ProcP
operator|->
name|pr_file
operator|=
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|yypip
expr_stmt|;
name|ProcP
operator|->
name|pr_ninput
operator|=
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|yypip
expr_stmt|;
name|ProcP
operator|->
name|pr_stat
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
expr_stmt|;
name|Pipe
index|[
name|yypvt
index|[
operator|-
literal|2
index|]
operator|.
name|yypip
index|]
operator|.
name|pip_wcnt
operator|++
expr_stmt|;
name|Pipe
index|[
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|yypip
index|]
operator|.
name|pip_rcnt
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|319
file|"ingres.y"
block|{
name|StateP
operator|=
operator|&
name|Proc
operator|->
name|prcm
operator|.
name|cm_state
index|[
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
index|]
expr_stmt|;
name|StateP
operator|->
name|st_type
operator|=
name|ST_REMOT
expr_stmt|;
name|StateP
operator|->
name|st_stat
operator|=
name|RemStat
expr_stmt|;
name|StateP
operator|->
name|st_v
operator|.
name|st_rem
operator|.
name|st_proc
operator|=
name|ProcNo
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
line|#
directive|line
number|332
file|"ingres.y"
block|{
name|smove
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
argument_list|,
name|Macro
index|[
name|yypvt
index|[
operator|-
literal|1
index|]
operator|.
name|yychar
operator|-
literal|'A'
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|18
case|:
line|#
directive|line
number|341
file|"ingres.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
operator|<
literal|0
operator|||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
operator|>=
name|CM_MAXPROC
condition|)
block|{
name|usrerr
argument_list|(
literal|"Illegal proc number %d"
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
argument_list|)
expr_stmt|;
name|YYERROR
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|19
case|:
line|#
directive|line
number|351
file|"ingres.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
operator|<
literal|0
operator|||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
operator|>=
name|CM_MAXST
condition|)
block|{
name|usrerr
argument_list|(
literal|"Illegal state number %d"
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
argument_list|)
expr_stmt|;
name|YYERROR
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|20
case|:
line|#
directive|line
number|361
file|"ingres.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
operator|<
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Illegal funcno %d"
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yyint
argument_list|)
expr_stmt|;
name|YYERROR
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|23
case|:
line|#
directive|line
number|377
file|"ingres.y"
block|{
if|if
condition|(
operator|(
name|islower
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
argument_list|)
operator|||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
operator|==
name|CLOSED
operator|)
operator|&&
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|yyval
operator|.
name|yypip
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
operator|==
literal|'|'
operator|&&
name|isdigit
argument_list|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|1
index|]
argument_list|)
operator|&&
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|yyval
operator|.
name|yypip
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|usrerr
argument_list|(
literal|"Invalid pipe id \"%s\""
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
argument_list|)
expr_stmt|;
name|YYERROR
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|24
case|:
line|#
directive|line
number|391
file|"ingres.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid trace flag \"%s\""
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
argument_list|)
expr_stmt|;
name|YYERROR
expr_stmt|;
block|}
else|else
name|yyval
operator|.
name|yychar
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|26
case|:
line|#
directive|line
number|406
file|"ingres.y"
block|{
if|if
condition|(
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
operator|<
literal|'A'
operator|||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
operator|>
literal|'Z'
operator|||
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|usrerr
argument_list|(
literal|"Invalid macro name \"%s\""
argument_list|,
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
argument_list|)
expr_stmt|;
name|YYERROR
expr_stmt|;
block|}
else|else
name|yyval
operator|.
name|yychar
operator|=
name|yypvt
index|[
operator|-
literal|0
index|]
operator|.
name|yystr
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
block|}
goto|goto
name|yystack
goto|;
comment|/* stack new state and value */
block|}
end_block

end_unit

