begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)att_fcn.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** fake attribute stash entries for tid nodes (and sid in dist version) **	these are provided by the system to a program only for debugging **	the system source and do not have well defined (over time) meanings. */
end_comment

begin_decl_stmt
name|struct
name|atstash
name|Faketid
init|=
block|{
literal|0
block|,
name|INT
block|,
literal|4
block|,
literal|"tid"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DISTRIB
end_ifdef

begin_struct
struct|struct
name|atstash
name|Fakesid
block|{
literal|0
operator|,
name|INT
operator|,
literal|4
operator|,
literal|"sid"
operator|,
literal|0
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|atstash
name|Attable
index|[
name|MAXATT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* attrib stash space, turned into a list later */
end_comment

begin_decl_stmt
name|struct
name|atstash
modifier|*
name|Freeatt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free list of attrib stash */
end_comment

begin_comment
comment|/* **  ATT_FCN.C  --  attribute list manipulation routines ** **	ATT_FCN ~~ trace flags = 40, 41 ** **	Defines: **		Attable **		Freeatt **		attinit() **		attlookup() **		attadd() **		attfnd() **		attcheck() **		attfree() **		attalloc() **		attcount() ** **	History: **		modified for 6.3 (jiw) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **   ATTINIT -- initializes attribute table ** **	Parameters: **		none ** **	Trace Flags: **		attinit ~~ 40.0 */
end_comment

begin_macro
name|attinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|atstash
modifier|*
name|atptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|,
literal|"attinit"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atptr
operator|=
name|Attable
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXATT
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|atptr
operator|->
name|atbnext
operator|=
name|atptr
operator|+
literal|1
expr_stmt|;
name|atptr
operator|++
expr_stmt|;
block|}
name|atptr
operator|->
name|atbnext
operator|=
name|NULL
expr_stmt|;
name|Freeatt
operator|=
name|Attable
expr_stmt|;
comment|/* the first attribute in chain */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ATTLOOKUP -- finds attribute entry ** **	Attlookup looks up atribute 'attrib' in the att stash **	for range table entry 'slot'.  If the attrib is not **	in the stash it is entered. ** **	Parameters: **		attrib -- the name of the attribute to find **		slot -- the number of the range variable ** **	Returns: **		pointer to the attstash element ** **	Trace Flags: **		attlookup ~~ 40.4, 40.5 */
end_comment

begin_function
name|struct
name|atstash
modifier|*
name|attlookup
parameter_list|(
name|slot
parameter_list|,
name|attrib
parameter_list|)
name|int
name|slot
decl_stmt|;
name|char
modifier|*
name|attrib
decl_stmt|;
block|{
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|struct
name|atstash
modifier|*
name|current
decl_stmt|;
name|int
name|ik
decl_stmt|;
name|struct
name|attribute
name|tuple
decl_stmt|;
specifier|register
name|struct
name|attribute
modifier|*
name|ktuple
decl_stmt|;
name|struct
name|attribute
name|ktup
decl_stmt|;
name|TID
name|tid
decl_stmt|;
specifier|extern
name|struct
name|atstash
modifier|*
name|attfind
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|atstash
modifier|*
name|attadd
parameter_list|()
function_decl|;
specifier|extern
name|DESC
name|Attdes
decl_stmt|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
name|rptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
name|ktuple
operator|=
operator|&
name|ktup
expr_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|,
literal|"attlookup: att = %s and rel= %s\n"
argument_list|,
name|attrib
argument_list|,
name|trim_relname
argument_list|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* attribute called "tid" is phantom attribute, use fake */
if|if
condition|(
name|sequal
argument_list|(
literal|"tid"
argument_list|,
name|attrib
argument_list|)
condition|)
return|return
operator|(
operator|&
name|Faketid
operator|)
return|;
ifdef|#
directive|ifdef
name|DISTRIB
if|if
condition|(
name|sequal
argument_list|(
literal|"sid"
argument_list|,
name|attrib
argument_list|)
condition|)
return|return
operator|(
operator|&
name|Fakesid
operator|)
return|;
endif|#
directive|endif
comment|/* check to see if attrib is in stash */
if|if
condition|(
operator|(
name|current
operator|=
name|attfind
argument_list|(
name|slot
argument_list|,
name|attrib
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|current
operator|)
return|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|40
argument_list|,
literal|5
argument_list|,
literal|"getting att info from relation\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* rel name, owner, attname is unique ident */
name|clearkeys
argument_list|(
operator|&
name|Attdes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
name|ktuple
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|ATTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
name|ktuple
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
name|ATTOWNER
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
name|ktuple
argument_list|,
name|attrib
argument_list|,
name|ATTNAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ik
operator|=
name|getequal
argument_list|(
operator|&
name|Attdes
argument_list|,
name|ktuple
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tid
argument_list|)
operator|)
condition|)
block|{
comment|/* put attrib stuff into att stash */
name|current
operator|=
name|attadd
argument_list|(
name|slot
argument_list|,
operator|&
name|tuple
argument_list|)
expr_stmt|;
return|return
operator|(
name|current
operator|)
return|;
block|}
if|if
condition|(
name|ik
operator|==
literal|1
condition|)
comment|/* attribute not in relation */
name|par_error
argument_list|(
name|NOATTRIN
argument_list|,
name|WARN
argument_list|,
name|attrib
argument_list|,
name|trim_relname
argument_list|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"fatal error in getequal, ret: %d"
argument_list|,
name|ik
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ATTADD -- add an attribute to the list for a particular range variable ** **	Parameters: **		slot -- the number of the range variable to use **		tuple -- the attribute tuple to add ** **	Returns: **		pointer to the attribute added ** **	Trace Flags: **		attadd ~~ 40.8 */
end_comment

begin_function
name|struct
name|atstash
modifier|*
name|attadd
parameter_list|(
name|slot
parameter_list|,
name|tuple
parameter_list|)
name|int
name|slot
decl_stmt|;
name|struct
name|attribute
modifier|*
name|tuple
decl_stmt|;
block|{
specifier|register
name|struct
name|atstash
modifier|*
name|current
decl_stmt|;
specifier|register
name|struct
name|atstash
modifier|*
name|aptr
decl_stmt|;
specifier|register
name|struct
name|atstash
modifier|*
name|bptr
decl_stmt|;
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|struct
name|atstash
modifier|*
name|attalloc
parameter_list|()
function_decl|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|40
argument_list|,
literal|8
argument_list|,
literal|"attadd slot %d, %12s\n"
argument_list|,
name|slot
argument_list|,
name|tuple
operator|->
name|attname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
name|current
operator|=
name|attalloc
argument_list|()
expr_stmt|;
name|current
operator|->
name|atbid
operator|=
name|tuple
operator|->
name|attid
expr_stmt|;
name|current
operator|->
name|atbfrmt
operator|=
name|tuple
operator|->
name|attfrmt
expr_stmt|;
name|current
operator|->
name|atbfrml
operator|=
name|tuple
operator|->
name|attfrml
expr_stmt|;
name|bmove
argument_list|(
name|tuple
operator|->
name|attname
argument_list|,
name|current
operator|->
name|atbname
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNAME
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|current
operator|->
name|atbname
index|[
name|i
index|]
operator|==
literal|' '
condition|)
name|current
operator|->
name|atbname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|aptr
operator|=
name|rptr
operator|->
name|attlist
expr_stmt|;
name|bptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|aptr
operator|->
name|atbid
operator|>
name|current
operator|->
name|atbid
condition|)
break|break;
name|bptr
operator|=
name|aptr
expr_stmt|;
name|aptr
operator|=
name|aptr
operator|->
name|atbnext
expr_stmt|;
block|}
if|if
condition|(
name|bptr
operator|==
literal|0
condition|)
name|rptr
operator|->
name|attlist
operator|=
name|current
expr_stmt|;
else|else
name|bptr
operator|->
name|atbnext
operator|=
name|current
expr_stmt|;
name|current
operator|->
name|atbnext
operator|=
name|aptr
expr_stmt|;
return|return
operator|(
name|current
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ATTFIND -- finds attribute in stash ** **	Attfind looks in attribute stash to see if attrib info already there **	return pointer to attribute in attribute table else NULL. ** **	Parameters: **		slot -- the number of the entry in range table **		attrib -- the attribute name to find ** **	Returns: **		pointer to entry or NULL if not in stash ** **	Trace Flags: **		attfind ~~ 40.12 */
end_comment

begin_function
name|struct
name|atstash
modifier|*
name|attfind
parameter_list|(
name|slot
parameter_list|,
name|attrib
parameter_list|)
name|int
name|slot
decl_stmt|;
specifier|register
name|char
modifier|*
name|attrib
decl_stmt|;
block|{
specifier|register
name|struct
name|atstash
modifier|*
name|aptr
decl_stmt|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR1
name|tTfp
argument_list|(
literal|40
argument_list|,
literal|12
argument_list|,
literal|"attadd\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|aptr
operator|=
name|Parrng
index|[
name|slot
index|]
operator|.
name|attlist
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|scompare
argument_list|(
name|attrib
argument_list|,
name|MAXNAME
argument_list|,
name|aptr
operator|->
name|atbname
argument_list|,
name|MAXNAME
argument_list|)
condition|)
return|return
operator|(
name|aptr
operator|)
return|;
name|aptr
operator|=
name|aptr
operator|->
name|atbnext
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ATTCHECK -- checks for conflicts in attributes ** **	Attcheck checks for type conflicts in the current query domain and **	attable entry ** **	Parameters: **		aptr -- pointer to current atttibute ** **	Returns: **		nothing ** **	Requires: **		Trfrmt -- for current format ** **	Trace Flags: **		attcheck ~~ 41.0 */
end_comment

begin_expr_stmt
name|attcheck
argument_list|(
name|aptr
argument_list|)
specifier|register
expr|struct
name|atstash
operator|*
name|aptr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|char
name|Trfrmt
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR1
name|tTfp
argument_list|(
literal|41
argument_list|,
literal|0
argument_list|,
literal|"attcheck\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|Trfrmt
operator|==
name|CHAR
operator|)
operator|!=
operator|(
name|aptr
operator|->
name|atbfrmt
operator|==
name|CHAR
operator|)
condition|)
comment|/* function type does not match attrib */
name|par_error
argument_list|(
name|RESTYPE
argument_list|,
name|WARN
argument_list|,
name|aptr
operator|->
name|atbname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ATTFREE -- puts a list of attrib space back on the free list ** **	Parameters: **		aptr -- pointer to list of attstash entries ** **	Returns: **		nothing ** **	Requires: **		Freeatt ** **	Trace Flags: **		attfree ~~ 41.4 */
end_comment

begin_macro
name|attfree
argument_list|(
argument|aptr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|atstash
modifier|*
name|aptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|atstash
modifier|*
name|att
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR1
name|tTfp
argument_list|(
literal|41
argument_list|,
literal|4
argument_list|,
literal|"attfree\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|att
operator|=
name|aptr
operator|)
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|att
operator|->
name|atbnext
operator|!=
name|NULL
condition|)
name|att
operator|=
name|att
operator|->
name|atbnext
expr_stmt|;
name|att
operator|->
name|atbnext
operator|=
name|Freeatt
expr_stmt|;
name|Freeatt
operator|=
name|aptr
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ATTALLOC -- returns a pointer to a atstash type structure ** **	Attalloc checks the freelist (Freeatt) for attstash entries, **	if some is there, one is removed.  If the freelist is empty, **	attstashes are removed from range table entries until an free **	element is found. ** **	Parameters: **		none ** **	Returns: **		a pointer to an atstash element ** **	Requires: **		Rngback **		Freeatt **		 **	Trace Flags: **		attalloc ~~ 41.8, 41.9 */
end_comment

begin_function
name|struct
name|atstash
modifier|*
name|attalloc
parameter_list|()
block|{
specifier|register
name|struct
name|atstash
modifier|*
name|aptr
decl_stmt|;
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
specifier|extern
name|PARRNG
modifier|*
name|Rngback
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|41
argument_list|,
literal|8
argument_list|,
literal|"attalloc Freeatt %d\n"
argument_list|,
name|Freeatt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Note: the following loop doesn't happen if Freeatt != NULL */
for|for
control|(
name|rptr
operator|=
name|Rngback
init|;
name|Freeatt
operator|==
name|NULL
condition|;
name|rptr
operator|=
name|rptr
operator|->
name|frontpt
control|)
block|{
comment|/* 		** search least recently used vbles for attrib stash space 		** until at least one entry is found 		*/
ifdef|#
directive|ifdef
name|xPTR3
name|tTfp
argument_list|(
literal|41
argument_list|,
literal|9
argument_list|,
literal|"attalloc: freeing %12s\n"
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|relvname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rptr
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"attalloc: no att space."
argument_list|)
expr_stmt|;
name|Freeatt
operator|=
name|rptr
operator|->
name|attlist
expr_stmt|;
name|rptr
operator|->
name|attlist
operator|=
name|NULL
expr_stmt|;
block|}
name|aptr
operator|=
name|Freeatt
expr_stmt|;
name|Freeatt
operator|=
name|Freeatt
operator|->
name|atbnext
expr_stmt|;
name|aptr
operator|->
name|atbnext
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|aptr
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ATTCOUNT -- counts atstash elems ** **	Attcount returns a count fof the number of attributes already in the **	attrib stash. ** **	Parameter: **		slot -- the range table entry to count ** **	Returns: **		count of the attributes ** **	Trace Flags: **		attcount ~~ 41.12 */
end_comment

begin_function
name|int
name|attcount
parameter_list|(
name|slot
parameter_list|)
name|int
name|slot
decl_stmt|;
block|{
specifier|register
name|int
name|cntr
decl_stmt|;
specifier|register
name|struct
name|atstash
modifier|*
name|aptr
decl_stmt|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR1
name|tTfp
argument_list|(
literal|41
argument_list|,
literal|12
argument_list|,
literal|"attcount\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cntr
operator|=
literal|0
expr_stmt|;
name|aptr
operator|=
name|Parrng
index|[
name|slot
index|]
operator|.
name|attlist
expr_stmt|;
while|while
condition|(
name|aptr
operator|!=
name|NULL
condition|)
block|{
name|cntr
operator|++
expr_stmt|;
name|aptr
operator|=
name|aptr
operator|->
name|atbnext
expr_stmt|;
block|}
return|return
operator|(
name|cntr
operator|)
return|;
block|}
end_function

end_unit

