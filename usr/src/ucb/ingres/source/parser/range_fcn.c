begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<range.h>
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)range_fcn.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	Range table variables */
end_comment

begin_decl_stmt
name|PARRNG
name|Parrng
index|[
name|MAXRANGE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table for keeping track of atts */
end_comment

begin_comment
comment|/* and allocation of range vars */
end_comment

begin_decl_stmt
name|int
name|Resrng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result reln slot */
end_comment

begin_decl_stmt
name|PARRNG
modifier|*
name|Rngfront
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the front of Rnga */
end_comment

begin_decl_stmt
name|PARRNG
modifier|*
name|Rngback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the back of Qt.qt_rangev */
end_comment

begin_comment
comment|/* **  RANGE_FCN.C -- functions for manipulating the range table ** **	Trace Flags: **		RANGE_FCN.C ~~ 66, 67 */
end_comment

begin_macro
name|ctlmod_decl
argument_list|(
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
name|Qt
operator|.
name|qt_rangev
index|[
name|slot
index|]
operator|.
name|rngvdesc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|declare
argument_list|(
name|slot
argument_list|,
operator|&
name|Parrng
index|[
name|slot
index|]
operator|.
name|vardesc
argument_list|)
operator|!=
name|slot
condition|)
name|syserr
argument_list|(
literal|"declare misdeclared"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RNGINIT **	initializes the pointers in the range table **	it should be called prior to starting the parsing **	it also initializes the attrib stash stuff because **	the attrib stash is really part of the range table ** **	Trace Flags: **		rnginit ~~ 66.0 */
end_comment

begin_macro
name|rnginit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|slot
decl_stmt|;
specifier|register
name|PARRNG
modifier|*
name|parrngptr
decl_stmt|;
specifier|register
name|RANGEV
modifier|*
name|rngptr
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|66
argument_list|,
literal|0
argument_list|,
literal|"rnginit\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Rngfront
operator|=
operator|&
name|Parrng
index|[
name|MAXVAR
operator|-
literal|1
index|]
expr_stmt|;
comment|/* ptr to head of range table */
name|parrngptr
operator|=
name|Parrng
expr_stmt|;
comment|/* initialize first element */
name|parrngptr
operator|->
name|attlist
operator|=
name|NULL
expr_stmt|;
name|parrngptr
operator|->
name|backpt
operator|=
name|NULL
expr_stmt|;
name|parrngptr
operator|->
name|frontpt
operator|=
operator|&
name|Parrng
index|[
literal|1
index|]
expr_stmt|;
name|rngptr
operator|=
name|Qt
operator|.
name|qt_rangev
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
operator|,
name|parrngptr
operator|=
operator|&
name|Parrng
index|[
literal|1
index|]
init|;
name|slot
operator|<
name|MAXVAR
condition|;
name|slot
operator|++
operator|,
name|parrngptr
operator|++
control|)
block|{
name|parrngptr
operator|->
name|attlist
operator|=
name|NULL
expr_stmt|;
name|parrngptr
operator|->
name|frontpt
operator|=
name|parrngptr
operator|+
literal|1
expr_stmt|;
name|parrngptr
operator|->
name|backpt
operator|=
name|parrngptr
operator|-
literal|1
expr_stmt|;
block|}
name|Rngback
operator|=
name|Parrng
expr_stmt|;
name|parrngptr
operator|=
operator|&
name|Parrng
index|[
name|MAXVAR
operator|-
literal|1
index|]
expr_stmt|;
name|parrngptr
operator|->
name|frontpt
operator|=
name|NULL
expr_stmt|;
comment|/* MAXVAR SLOT = Resultvar */
operator|(
operator|++
name|parrngptr
operator|)
operator|->
name|attlist
operator|=
name|NULL
expr_stmt|;
name|parrngptr
operator|->
name|frontpt
operator|=
name|parrngptr
operator|->
name|backpt
operator|=
name|NULL
expr_stmt|;
name|Rngfront
operator|->
name|frontpt
operator|=
name|NULL
expr_stmt|;
name|clrrange
argument_list|()
expr_stmt|;
name|attinit
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** RNGLOOK **	returns a pointer to the range table entry else 0 **	type = LOOKREL	lookup relation **	type = LOOKVAR	lookup variable ** **	Trace Flags: **		rnglook ~~ 66.4, 66.5, 66.6 */
end_comment

begin_function
name|int
name|rnglook
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|int
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|66
argument_list|,
literal|4
argument_list|,
literal|"rnglook:\ttype = %s\tname = %s\n"
argument_list|,
operator|(
name|type
operator|==
name|LOOKVAR
condition|?
literal|"variable"
else|:
literal|"relation"
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|66
argument_list|,
literal|5
argument_list|)
condition|)
name|printtable
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|rptr
operator|=
name|Parrng
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|MAXVAR
condition|;
name|slot
operator|++
operator|,
name|rptr
operator|++
control|)
comment|/* search external vbles only */
block|{
if|if
condition|(
name|rptr
operator|->
name|relvused
operator|&&
name|scompare
argument_list|(
name|name
argument_list|,
name|MAXNAME
argument_list|,
operator|(
name|type
operator|==
name|LOOKVAR
condition|?
name|rptr
operator|->
name|vardesc
operator|.
name|relvname
else|:
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
operator|)
argument_list|,
name|MAXNAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Qt
operator|.
name|qt_rangev
index|[
name|slot
index|]
operator|.
name|rngvmark
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|66
argument_list|,
literal|6
argument_list|,
literal|"fnd '%s' at '%d'\n"
argument_list|,
name|name
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rngfront
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|slot
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RNGENT ** **	Insert variable and relation in range table. ** **	Trace Flags: **		 rngent ~~ 66.8 */
end_comment

begin_function
name|int
name|rngent
parameter_list|(
name|type
parameter_list|,
name|var
parameter_list|,
name|desc
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
specifier|register
name|DESC
modifier|*
name|desc
decl_stmt|;
block|{
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|int
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|66
argument_list|,
literal|8
argument_list|,
literal|"rngent:\ttype=%s\tvar=%s\n"
argument_list|,
operator|(
name|type
operator|==
name|R_INTERNAL
condition|?
literal|"internal"
else|:
literal|"external"
operator|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|R_INTERNAL
condition|)
name|slot
operator|=
name|MAXVAR
expr_stmt|;
comment|/* the internal variable */
else|else
block|{
if|if
condition|(
operator|(
name|slot
operator|=
name|rnglook
argument_list|(
name|var
argument_list|,
name|LOOKVAR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* not in range table */
name|slot
operator|=
name|rngold
argument_list|()
expr_stmt|;
block|}
name|rngfront
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|rptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
if|if
condition|(
name|scompare
argument_list|(
name|desc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|attfree
argument_list|(
name|rptr
operator|->
name|attlist
argument_list|)
expr_stmt|;
name|rptr
operator|->
name|attlist
operator|=
name|NULL
expr_stmt|;
block|}
name|rptr
operator|->
name|relvused
operator|=
literal|1
expr_stmt|;
name|bmove
argument_list|(
name|desc
argument_list|,
operator|&
name|rptr
operator|->
name|vardesc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|pmove
argument_list|(
name|var
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|relvname
argument_list|,
name|MAXNAME
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|ctlmod_decl
argument_list|(
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|slot
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** RNGDEL **	removes an entry from the range table **	removes all variables for the relation name ** **	Trace Flags: **		 rngdel ~~ 66.12 */
end_comment

begin_expr_stmt
name|rngdel
argument_list|(
name|rel
argument_list|)
specifier|register
name|char
operator|*
name|rel
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|slot
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|66
argument_list|,
literal|12
argument_list|,
literal|"rngdel: %12s\n"
argument_list|,
name|rel
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|slot
operator|=
name|rnglook
argument_list|(
name|rel
argument_list|,
name|LOOKREL
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|Parrng
index|[
name|slot
index|]
operator|.
name|relvused
operator|=
literal|0
expr_stmt|;
name|rngback
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|attfree
argument_list|(
name|Parrng
index|[
name|slot
index|]
operator|.
name|attlist
argument_list|)
expr_stmt|;
name|Parrng
index|[
name|slot
index|]
operator|.
name|attlist
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** RNGFRONT **	move entry 'r' to head of range table list ** **	Trace Flags: **		 rngfront ~~ 67.0  */
end_comment

begin_macro
name|rngfront
argument_list|(
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARRNG
modifier|*
name|fptr
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|0
argument_list|,
literal|"rngfront:\tslot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rngget
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|fptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
name|fptr
operator|->
name|frontpt
operator|=
name|NULL
expr_stmt|;
name|fptr
operator|->
name|backpt
operator|=
name|Rngfront
expr_stmt|;
name|Rngfront
operator|->
name|frontpt
operator|=
name|fptr
expr_stmt|;
name|Rngfront
operator|=
name|fptr
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** RNGBACK **	move entry 'r' to back of range table list ** **	Trace Flags: **		rngback ~~ 67.4 */
end_comment

begin_macro
name|rngback
argument_list|(
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARRNG
modifier|*
name|bptr
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|4
argument_list|,
literal|"rngback:\tslot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rngget
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|bptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
name|bptr
operator|->
name|backpt
operator|=
name|NULL
expr_stmt|;
name|bptr
operator|->
name|frontpt
operator|=
name|Rngback
expr_stmt|;
name|Rngback
operator|->
name|backpt
operator|=
name|bptr
expr_stmt|;
name|Rngback
operator|=
name|bptr
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RNGGET -- get a descriptor from range table ** **	Trace Flags: **		rngget ~~ 67.8 */
end_comment

begin_macro
name|rngget
argument_list|(
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARRNG
modifier|*
name|slotptr
decl_stmt|;
specifier|register
name|PARRNG
modifier|*
name|forward
decl_stmt|;
specifier|register
name|PARRNG
modifier|*
name|backward
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|8
argument_list|,
literal|"rngget:\tslot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|slotptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
name|forward
operator|=
name|slotptr
operator|->
name|frontpt
expr_stmt|;
name|backward
operator|=
name|slotptr
operator|->
name|backpt
expr_stmt|;
if|if
condition|(
name|slotptr
operator|==
name|Rngfront
condition|)
block|{
name|Rngfront
operator|=
name|backward
expr_stmt|;
name|backward
operator|->
name|frontpt
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slotptr
operator|==
name|Rngback
condition|)
block|{
name|Rngback
operator|=
name|forward
expr_stmt|;
name|forward
operator|->
name|backpt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|forward
operator|->
name|backpt
operator|=
name|backward
expr_stmt|;
name|backward
operator|->
name|frontpt
operator|=
name|forward
expr_stmt|;
block|}
name|slotptr
operator|->
name|backpt
operator|=
name|slotptr
operator|->
name|frontpt
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RNGOLD -- find least recently used vble entry ** **	Trace Flags: **		rngold ~~ 67.9 */
end_comment

begin_function
name|int
name|rngold
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|9
argument_list|,
literal|"rngold %d.\n"
argument_list|,
name|Rngback
operator|-
operator|(
name|PARRNG
operator|*
operator|)
name|Parrng
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Rngback
operator|-
operator|(
name|PARRNG
operator|*
operator|)
name|Parrng
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** RNGRESET **	reset the used marks to '0' ** **	Trace Flags: **		rngreset ~~ 67.10 */
end_comment

begin_macro
name|rngreset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|RANGEV
modifier|*
name|rangevptr
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|10
argument_list|,
literal|"rngreset().\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rangevptr
operator|=
name|Qt
operator|.
name|qt_rangev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXVAR
condition|;
name|i
operator|++
operator|,
name|rangevptr
operator|++
control|)
comment|/* only do external ones */
name|rangevptr
operator|->
name|rngvmark
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** CHECKUPD **	checks to make sure that the user can update the relation 'name1' **	the 'open' parameter is set if 'Reldesc' contains the openr info **	for the relation in question. ** **	Trace Flags: **		checkupd ~~ 67.11 */
end_comment

begin_macro
name|checkupd
argument_list|(
argument|entnum
argument_list|)
end_macro

begin_decl_stmt
name|int
name|entnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|Noupdt
decl_stmt|;
specifier|extern
name|PARRNG
name|Parrng
index|[]
decl_stmt|;
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|11
argument_list|,
literal|"checkupd(%d).\n"
argument_list|,
name|entnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rptr
operator|=
operator|&
name|Parrng
index|[
name|entnum
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|Noupdt
condition|)
return|return;
if|if
condition|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_NOUPDT
condition|)
comment|/* no updates allowed on this relation */
name|par_error
argument_list|(
name|CANTUPDATE
argument_list|,
name|WARN
argument_list|,
name|trim_relname
argument_list|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** RNGFRESH -- check the range table relstat information for accuracy ** **	If the command specified could have changed the relstat info **	make the appropriate adjustments to the range table */
end_comment

begin_macro
name|rngfresh
argument_list|(
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|int
name|slot
decl_stmt|;
name|DESC
name|desc
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR2
name|tTfp
argument_list|(
literal|67
argument_list|,
literal|11
argument_list|,
literal|"rngfresh %d.\n"
argument_list|,
name|op
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* search the entire table! */
for|for
control|(
name|slot
operator|=
literal|0
operator|,
name|rptr
operator|=
name|Parrng
init|;
name|slot
operator|<=
name|MAXVAR
condition|;
name|slot
operator|++
operator|,
name|rptr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|rptr
operator|->
name|relvused
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|mdDESTROY
case|:
if|if
condition|(
operator|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|&
operator|(
name|S_VBASE
operator||
name|S_INTEG
operator||
name|S_PROTUPS
operator||
name|S_INDEX
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fixordel
label|:
comment|/* 				** openr the relation, if it doesn't exist make 				** sure that all range table entries are gone 				*/
if|if
condition|(
operator|!
name|openr
argument_list|(
operator|&
name|desc
argument_list|,
operator|-
literal|1
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
condition|)
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|=
name|desc
operator|.
name|reldum
operator|.
name|relstat
expr_stmt|;
else|else
block|{
comment|/* relation not there, purge table */
name|rngdel
argument_list|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|mdVIEW
case|:
if|if
condition|(
operator|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_VBASE
operator|)
operator|==
literal|0
condition|)
block|{
name|fixorerr
label|:
comment|/* 				** if the relation doesn't exist then it is 				** a syserr, otherwise, copy the bits. 				*/
if|if
condition|(
operator|!
name|openr
argument_list|(
operator|&
name|desc
argument_list|,
operator|-
literal|1
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
condition|)
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|=
name|desc
operator|.
name|reldum
operator|.
name|relstat
expr_stmt|;
else|else
block|{
comment|/* not there, syserr */
name|syserr
argument_list|(
literal|"RNGFRESH: extra entry: %s"
argument_list|,
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|mdPROT
case|:
if|if
condition|(
operator|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTUPS
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fixorerr
goto|;
break|break;
case|case
name|mdINTEG
case|:
if|if
condition|(
operator|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_INTEG
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fixorerr
goto|;
break|break;
case|case
name|mdMODIFY
case|:
if|if
condition|(
operator|(
name|rptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_INDEX
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fixordel
goto|;
break|break;
default|default:
return|return;
comment|/* command ok, dont waste time on rest of table */
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|printtable
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|PARRNG
modifier|*
name|rptr
decl_stmt|;
name|int
name|slot
index|[
name|MAXRANGE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Range table:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
name|slot
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rptr
operator|=
name|Rngfront
init|;
name|rptr
operator|!=
name|NULL
condition|;
name|rptr
operator|=
name|rptr
operator|->
name|backpt
control|)
block|{
name|i
operator|=
name|rptr
operator|-
operator|(
name|PARRNG
operator|*
operator|)
name|Parrng
expr_stmt|;
name|slot
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|printslot
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\nEntries not in list:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|slot
index|[
name|i
index|]
condition|)
block|{
name|printslot
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|printslot
argument_list|(
argument|slot
argument_list|)
end_macro

begin_decl_stmt
name|int
name|slot
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|RANGEV
modifier|*
name|rptr
decl_stmt|;
specifier|register
name|PARRNG
modifier|*
name|auxptr
decl_stmt|;
name|rptr
operator|=
operator|&
name|Qt
operator|.
name|qt_rangev
index|[
name|slot
index|]
expr_stmt|;
name|auxptr
operator|=
operator|&
name|Parrng
index|[
name|slot
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"slot:\t%d\n{\trvar:\t%.12s,\trelnm:\t%.12s.\n"
argument_list|,
name|slot
argument_list|,
name|auxptr
operator|->
name|vardesc
operator|.
name|relvname
argument_list|,
name|auxptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tRELVUSED: %d, RELVSEND %d.\n"
argument_list|,
name|auxptr
operator|->
name|relvused
argument_list|,
name|rptr
operator|->
name|rngvmark
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tratts: %d, attlist: %d.\n}\n"
argument_list|,
name|auxptr
operator|->
name|vardesc
operator|.
name|reldum
operator|.
name|relatts
argument_list|,
name|auxptr
operator|->
name|attlist
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

