begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"parser.h"
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)par_util.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  PAR_UTIL -- parser utility functions ** **	These functions are generally unrelated except that they are **	needed to operate the parser and are too small to be considered **	seperate modules. ** **	Defined Constants: ** **	Defines: **		timeofday	-- convert arguments to minutes since midnight **		tlprepend	-- attach two target list components **		header		-- prints the header for a retrieve to terminal **		patmat		-- converts pattern matching characters in a string **		permcom		-- adds a command to the permit command vector ** **	Requires: **		nothing ** **	Required By: **		y.tab.c		-- the grammar ** **	Files: **		none ** **	Compilation Flags: **		none ** **	Trace Flags: **		PAR_UTIL.C ~~ 62, 63 ** **	History: **		20 Dec 1978	-- written (rick) */
end_comment

begin_comment
comment|/* **  TIMEOFDAY -- convert 2 integers to minutes since midnight ** **	Converts the hours and minutes parameters to minutes since midnight **	performing some error (bounds) checking on the time. ** **	To answer the question about what is midnight, both 0:00 and 24:00 **	are handled, but not the same way.  The former is zero minutes from **	midnight and the latter is 1440 minutes from midnight.  (1440 is **	24 hrs times 60 minutes, or 1 minute past the end of the day.) ** **	Parameters: **		hrs		-- an integer pointer to the hour **		mins		-- an integer pointer to the minutes ** **	Returns: **		integer time since midnight ** **	Side Effects: **		may detect an error and call par_error which never returns. ** **	Requires: **		that the pointers be on integer boundaries ** **	Called By: **		y.tab.c		-- the grammar ** **	Trace Flags: **		none ** **	Diagnostics: **		BADHOURS	-- No such hour **		BADMINS		-- No such minute **		BAD24TIME	-- only 24:00 allowed ** **	Syserrs: **		none ** **	History: **		20 Dec 1978 	-- written (rick) */
end_comment

begin_macro
name|timeofday
argument_list|(
argument|hrs
argument_list|,
argument|mins
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|hrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|mins
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|h
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|int
name|rtval
decl_stmt|;
name|h
operator|=
operator|*
name|hrs
expr_stmt|;
name|m
operator|=
operator|*
name|mins
expr_stmt|;
if|if
condition|(
name|h
operator|>
literal|24
operator|||
name|h
operator|<
literal|0
condition|)
comment|/* no such hour */
name|par_error
argument_list|(
name|BADHOURS
argument_list|,
name|WARN
argument_list|,
name|iocv
argument_list|(
name|h
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>
literal|59
operator|||
name|h
operator|<
literal|0
condition|)
comment|/* no such minute */
name|par_error
argument_list|(
name|BADMINS
argument_list|,
name|WARN
argument_list|,
name|iocv
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|24
condition|)
block|{
name|h
operator|=
literal|1440
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
comment|/* can only use 24:00 */
name|par_error
argument_list|(
name|BAD24TIME
argument_list|,
name|WARN
argument_list|,
name|iocv
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rtval
operator|=
operator|(
name|h
operator|*
literal|60
operator|)
operator|+
name|m
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
end_block

begin_comment
comment|/* **  TLPREPEND -- combine two target list components ** **	Attach two target list components to each other. **	Neither component need be a single element.  The **	'a' component will be attached at the extreme left **	of the 'b' component. ** **	Parameters: **		a		-- tl component to attach **		b		-- tl base for attaching ** **	Returns: **		nothing ** **	Side Effects: **		this routine is a side effect.  It attaches a to b **		and when it returns a is attached to b but the pointer **		to b never changes (neither does the pointer to a) ** **	Requires: **		nothing ** **	Called By: **		y.tab.c		-- the grammar ** **	Trace Flags: **		tlprepend ~~ 62.4 ** **	Diagnostics: **		none ** **	Syserrs: **		none ** **	History: **		20 Dec 1978	-- written (rick) */
end_comment

begin_function
name|QTREE
modifier|*
name|tlprepend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|QTREE
modifier|*
name|a
decl_stmt|;
name|QTREE
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|xPTR1
name|tTfp
argument_list|(
literal|62
argument_list|,
literal|4
argument_list|,
literal|"tlprepend\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* scan to the left end of b */
for|for
control|(
name|q
operator|=
name|b
init|;
name|q
operator|->
name|left
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|left
control|)
empty_stmt|;
comment|/* no action */
comment|/* attach a to the end of b */
name|q
operator|->
name|left
operator|=
name|a
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  HEADER.C -- print header for retrieve to terminal ** **	"setp" to reconstruct the field names and types and passing **	them to the normal printhdr etc. ** **	Defines: **		header() ** **	Requires: **		printhdr	- utility lib **		beginhdr	- utility lib **		printeol	- utility lib **		printeh		- utility lib **		atoi		- utility lib **		Dc		- vble, number of params in list **		Dv		- vble, list of parameters ** **	Trace Flags: **		none ** **	History: **		written (ancient history) (rick) */
end_comment

begin_macro
name|header
argument_list|(
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|PARM
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|beginhdr
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|pv
operator|->
name|pv_type
operator|!=
name|PV_EOF
condition|;
name|pv
operator|+=
literal|2
control|)
block|{
name|atoi
argument_list|(
operator|&
name|pv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|1
index|]
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|printhdr
argument_list|(
name|pv
index|[
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|0
index|]
operator|&
name|I1MASK
argument_list|,
name|len
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
block|}
name|printeol
argument_list|()
expr_stmt|;
name|printeh
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  PATMAT -- converts pattern matching characters in a string ** **	Searches a string up to a null byte for one of the pattern **	matching characters '*', '?', '[', and ']'. It then converts **	these characters to their internal control character equivalents. ** **	Parameters: **		str		-- the string to search ** **	Returns: **		0		-- no pattern matching in string **		1		-- at least one pattern matching character ** **	Side Effects: **		none ** **	Requires: **		symbol.h ** **	Called By: **		y.tab.c		-- grammar ** **	Trace Flags: **		none ** **	Diagnostics: **		none ** **	Syserrs: **		none ** **	History: **		written (ancient history) (rick) */
end_comment

begin_comment
comment|/* ** PATMAT **	hunts through a string and converts the pattern matching **	characters and replaces with the corresponding cntrl chars */
end_comment

begin_macro
name|patmat
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|str
expr_stmt|;
for|for
control|(
name|p
operator|=
name|str
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'*'
case|:
operator|*
name|q
operator|++
operator|=
name|PAT_ANY
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'?'
case|:
operator|*
name|q
operator|++
operator|=
name|PAT_ONE
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
operator|*
name|q
operator|++
operator|=
name|PAT_LBRAC
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|']'
case|:
operator|*
name|q
operator|++
operator|=
name|PAT_RBRAC
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|flag
operator|)
return|;
block|}
end_block

begin_comment
comment|/* **  PERMCOM -- map command allowed into protection catalog bits ** **	translates the QMODE type symbols into the appropriate counterparts **	for the permit statement allowed command vector.  The manifest **	constants are designed to be inclusive or'd together to form a **	composite bit map of OK actions. ** **	Parameters: **		a		-- the QMODE type symbol for the command to add ** **	Returns: **		none ** **	Side Effects: **		changes the variable Permcomd to reflect the additional permission ** **	Requires: **		Permcomd must be define globally **		catalog.h for the proper constants ** **	Called By: **		y.tab.c		-- the grammar ** **	Trace Flags: **		none ** **	Diagnostics: **		none ** **	Syserrs: **		bad QMODE(%d)	-- a bad symbol has been passed for mapping ** **	History: **		28 Dec 1978	-- written (rick) */
end_comment

begin_macro
name|permcom
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|Permcomd
decl_stmt|;
switch|switch
condition|(
name|a
condition|)
block|{
case|case
name|mdRETR
case|:
name|Permcomd
operator||=
name|PRO_RETR
expr_stmt|;
break|break;
case|case
name|mdAPP
case|:
name|Permcomd
operator||=
name|PRO_APP
expr_stmt|;
break|break;
case|case
name|mdREPL
case|:
name|Permcomd
operator||=
name|PRO_REPL
expr_stmt|;
break|break;
case|case
name|mdDEL
case|:
name|Permcomd
operator||=
name|PRO_DEL
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|Permcomd
operator||=
literal|0177777
expr_stmt|;
comment|/* all bits set */
break|break;
default|default:
name|syserr
argument_list|(
literal|"permcom: bad QMODE(%d)"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
name|char
modifier|*
name|makestr
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|length
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|need
argument_list|(
name|Qbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|str
argument_list|,
name|result
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

