begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)decision.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** DECISION -- This file contains code related to deciding how to **	process the remaining query. The main routine is decision() **	and the other routines are called only by decision. The routine **	in this file include: ** **	Decision -- Decides how to process a query. ** **	Fixtl     -- Determines the target list for each component. ** **	Fixresult -- Determines the result relation for the next query ** **	Fixrange  -- Adjust the range table after a query ** **	Fixovlap  -- Fixes trees in cases where reduction is used ** **	Rmovlap   -- Restores trees in cases where reduction was used. ** **	Listcomp  -- Debugging routine. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **	Decision is given a subquery and decides how to process it. **	The choices are: **		Disjoint pieces -- The original query had disjoint components. **					Do each component separately. **		Reduction       -- The query is joined by a single variable. **					Reduce the query on that joining variable **					and do each component separately. **		Substitution    -- The query is neither disjoint nor reducible. **					Process by tuple substitution. ** **	Notice that decision() is recursive and will call itself on each **	subcomponent it decides to do. Decision calls various support **	routines in the file "reduction.c". */
end_comment

begin_macro
name|decision
argument_list|(
argument|root
argument_list|,
argument|qmode
argument_list|,
argument|result_num
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|result_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
modifier|*
name|qp
decl_stmt|;
specifier|register
name|struct
name|complist
modifier|*
name|clist
decl_stmt|;
specifier|register
name|int
name|ovlapvar
decl_stmt|;
name|struct
name|complist
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|onepiece
decl_stmt|,
name|qtrue
decl_stmt|,
name|map
decl_stmt|;
name|int
name|mark
decl_stmt|,
name|mark1
decl_stmt|,
name|cand_map
decl_stmt|;
name|QTREE
modifier|*
name|tree
decl_stmt|,
modifier|*
name|newtree
decl_stmt|;
name|QTREE
modifier|*
name|qlist
index|[
name|MAXRANGE
index|]
decl_stmt|;
name|int
name|newqmode
decl_stmt|;
name|int
name|ovlaprelnum
decl_stmt|,
name|newr
decl_stmt|;
name|int
name|locrange
index|[
name|MAXRANGE
index|]
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|copy_ands
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|complist
modifier|*
name|buildlist
argument_list|()
decl_stmt|,
modifier|*
name|order
argument_list|()
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|construct
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"DECISION root=%x,vc=%d,res=%d\n"
argument_list|,
name|root
argument_list|,
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mark
operator|=
name|markbuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|<
literal|3
condition|)
block|{
comment|/* setup to do as one single piece */
name|onepiece
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* break the query apart if possible */
comment|/* build component list */
name|clist
operator|=
name|buildlist
argument_list|(
name|root
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|2
argument_list|)
condition|)
name|listcomp
argument_list|(
name|clist
argument_list|,
literal|"Original Comp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* is query completely connected or disjoint */
name|map
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
expr_stmt|;
name|onepiece
operator|=
name|algorithm
argument_list|(
name|clist
argument_list|,
name|map
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Orig query %s\n"
argument_list|,
name|onepiece
condition|?
literal|"connected"
else|:
literal|"disjoint"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* assume there is no joining variable */
name|ovlapvar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|onepiece
condition|)
block|{
comment|/* 			** Try to reduce a single connected piece. 			** In turn each variable will be logically 			** removed from the query and a test will 			** be made to see if the query is still 			** connected. 			*/
name|cand_map
operator|=
name|map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|cand_map
condition|;
name|i
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|cand_map
operator|&
name|i
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|cand_map
operator|&=
operator|~
name|i
expr_stmt|;
name|freebuf
argument_list|(
name|buf
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|clist
operator|=
name|buildlist
argument_list|(
name|root
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|algorithm
argument_list|(
name|clist
argument_list|,
name|map
operator|&
operator|~
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ovlapvar
operator|=
name|bitpos
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|ovlaprelnum
operator|=
name|De
operator|.
name|de_rangev
index|[
name|ovlapvar
index|]
operator|.
name|relnum
expr_stmt|;
name|onepiece
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|ovlapvar
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Query not reducible\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Query Reducible on %d\n"
argument_list|,
name|ovlapvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|3
argument_list|)
condition|)
name|listcomp
argument_list|(
name|clist
argument_list|,
literal|"After reduct"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* 		** If query is more than one piece, build trees 		** for each piece. 		*/
if|if
condition|(
operator|!
name|onepiece
condition|)
block|{
comment|/* order pieces */
name|clist
operator|=
name|order
argument_list|(
name|clist
argument_list|,
name|ovlapvar
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|4
argument_list|)
condition|)
name|listcomp
argument_list|(
name|clist
argument_list|,
literal|"After ordering"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|clist
expr_stmt|;
name|qp
operator|=
name|qlist
expr_stmt|;
do|do
block|{
operator|*
name|qp
operator|++
operator|=
name|construct
argument_list|(
name|root
argument_list|,
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cp
operator|=
name|cp
operator|->
name|nextcomp
condition|)
do|;
operator|*
name|qp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	** The query is now either the one original piece or 	** is in multiple pieces. The information in clist 	** has been thrown away and now the ordered pieces 	** will be processed. 	*/
if|if
condition|(
name|onepiece
condition|)
block|{
name|freebuf
argument_list|(
name|buf
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|qtrue
operator|=
name|decompy
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the query is in pieces. prepare to process */
name|newquery
argument_list|(
name|locrange
argument_list|)
expr_stmt|;
comment|/* save state of range table */
comment|/* determine the target list for each piece of the query */
for|for
control|(
name|qp
operator|=
name|qlist
init|;
name|tree
operator|=
operator|*
name|qp
operator|++
condition|;
control|)
name|fixtl
argument_list|(
name|tree
argument_list|,
name|qp
argument_list|,
name|ovlapvar
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* adjust refs to ovlapvar since domain #'s could have changed */
name|fixovlap
argument_list|(
name|qlist
argument_list|,
name|ovlapvar
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* now process each component */
name|mark1
operator|=
name|markbuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|qlist
init|;
name|tree
operator|=
operator|*
name|qp
operator|++
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"next piece\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* determine result relation name */
name|newr
operator|=
name|fixresult
argument_list|(
name|root
argument_list|,
name|tree
argument_list|,
operator|&
name|newqmode
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
comment|/* 			** Run the query. If reduction is being 			** performed, the actual tree given to 			** the decision routine must be a copy 			** to protect from the recursive call changing 			** the tree. Any work done at this level, 			** must be to the original tree 			*/
name|newtree
operator|=
name|tree
expr_stmt|;
if|if
condition|(
name|ovlapvar
operator|!=
operator|-
literal|1
condition|)
block|{
name|freebuf
argument_list|(
name|buf
argument_list|,
name|mark1
argument_list|)
expr_stmt|;
name|newtree
operator|=
name|copy_ands
argument_list|(
name|tree
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|qtrue
operator|=
name|decision
argument_list|(
name|newtree
argument_list|,
name|newqmode
argument_list|,
name|newr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* fix up the range table */
name|fixrange
argument_list|(
name|root
argument_list|,
name|tree
argument_list|,
name|ovlapvar
argument_list|,
name|ovlaprelnum
argument_list|,
name|newr
argument_list|)
expr_stmt|;
comment|/* if last piece was false then done */
if|if
condition|(
operator|!
name|qtrue
condition|)
break|break;
block|}
comment|/* restore the trees */
name|rmovlap
argument_list|(
name|qlist
argument_list|,
name|ovlapvar
argument_list|)
expr_stmt|;
comment|/* restore range table back to original */
name|endquery
argument_list|(
name|locrange
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* reopen previous range */
comment|/* return any buffer space used */
name|freebuf
argument_list|(
name|buf
argument_list|,
name|mark
argument_list|)
expr_stmt|;
block|}
comment|/* all done with query */
return|return
operator|(
name|qtrue
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Fixresult -- Determine result relation for "tree" query. **	If "tree" is the original target list piece then use the **		original relation and mode. **	If "tree" is a reduction piece then create a temporary relation **		for it. **	If "tree" is a disjoint piece then there is no target list nor **		result relation. ** **	Return: **		result relation number **	Side Effects: **		*newmode is set to the query mode of the next piece */
end_comment

begin_macro
name|fixresult
argument_list|(
argument|root
argument_list|,
argument|tree1
argument_list|,
argument|newmode
argument_list|,
argument|origmode
argument_list|,
argument|resnum
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|tree1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|newmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|origmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|tree
decl_stmt|;
specifier|register
name|int
name|newresult
decl_stmt|;
name|tree
operator|=
name|tree1
expr_stmt|;
operator|*
name|newmode
operator|=
name|mdRETR
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
if|if
condition|(
name|tree
operator|!=
name|root
condition|)
block|{
comment|/* make new result for reduction step */
name|newresult
operator|=
name|mak_t_rel
argument_list|(
name|tree
argument_list|,
literal|"r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* final piece with original result and mode */
name|newresult
operator|=
name|resnum
expr_stmt|;
operator|*
name|newmode
operator|=
name|origmode
expr_stmt|;
block|}
block|}
else|else
name|newresult
operator|=
name|NORESULT
expr_stmt|;
return|return
operator|(
name|newresult
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Update range table after a reduction has been processed. **	Only the intermediate reductions will affect the range **	table. The last piece does not. */
end_comment

begin_macro
name|fixrange
argument_list|(
argument|root
argument_list|,
argument|tree
argument_list|,
argument|ovlapvar
argument_list|,
argument|reductnum
argument_list|,
argument|newrelnum
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovlapvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reductnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newrelnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|old
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|DESC
modifier|*
name|openr1
parameter_list|()
function_decl|;
if|if
condition|(
name|root
operator|!=
name|tree
condition|)
block|{
comment|/* this is an intermediate piece */
name|i
operator|=
name|ovlapvar
expr_stmt|;
if|if
condition|(
name|newrelnum
operator|>=
literal|0
condition|)
block|{
name|old
operator|=
name|new_range
argument_list|(
name|i
argument_list|,
name|newrelnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|reductnum
condition|)
name|dstr_rel
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|openr1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Fixovlap -- Adjust subsequent trees which reference the reduction var ** **	If the first query in list redefines the reduction variable **	(if any) then each subsequent query which references the **	reduction variable is adjusted. **	Since there may be multiple pieces, **	subsequence redefinitions are done without **	reallocating buffer space. ** */
end_comment

begin_macro
name|fixovlap
argument_list|(
argument|qlist
argument_list|,
argument|ovlapvar
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|qlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovlapvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
modifier|*
name|qp
decl_stmt|,
modifier|*
name|piece
decl_stmt|,
modifier|*
modifier|*
name|qp1
decl_stmt|;
name|QTREE
modifier|*
name|next
decl_stmt|;
name|int
name|ovmap
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
modifier|*
name|mksqlist
parameter_list|()
function_decl|;
name|ovmap
operator|=
literal|1
operator|<<
name|ovlapvar
expr_stmt|;
comment|/* for each piece, if it redefines ovlapvar, then fix up rest */
for|for
control|(
name|qp
operator|=
name|qlist
init|;
name|piece
operator|=
operator|*
name|qp
operator|++
condition|;
control|)
block|{
if|if
condition|(
name|piece
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator|&
name|ovmap
condition|)
block|{
for|for
control|(
name|qp1
operator|=
name|qp
init|;
name|next
operator|=
operator|*
name|qp1
operator|++
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|next
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|next
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|)
operator|&
name|ovmap
condition|)
block|{
name|tempvar
argument_list|(
name|next
argument_list|,
name|mksqlist
argument_list|(
name|piece
argument_list|,
name|ovlapvar
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/* do not allocate on subsequent refs */
block|}
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Rmovlap -- Restore query trees back to their original state. ** **	Rmovlap undoes the effect of fixovlap(). Any references **	to the reduction variable which were adjusted are now **	reverted back to the original reference. Note that the **	first piece is not effected by fixovlap. */
end_comment

begin_macro
name|rmovlap
argument_list|(
argument|qlist
argument_list|,
argument|ovlapvar
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|qlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovlapvar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
modifier|*
name|qp
decl_stmt|,
modifier|*
name|tree
decl_stmt|;
name|int
name|ovmap
decl_stmt|;
if|if
condition|(
name|ovmap
operator|=
operator|(
literal|1
operator|<<
name|ovlapvar
operator|)
condition|)
block|{
comment|/* for each piece, remove any tempvars */
for|for
control|(
name|qp
operator|=
operator|&
name|qlist
index|[
literal|1
index|]
init|;
name|tree
operator|=
operator|*
name|qp
operator|++
condition|;
control|)
block|{
name|origvar
argument_list|(
name|tree
argument_list|,
name|mksqlist
argument_list|(
name|tree
argument_list|,
name|ovlapvar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Fixtl -- Determine what the target list of each tree should be. ** **	Fixtl takes each query which references the reduction variable **	and looks for references to that variable in subsequent queries. **	Dfind will build a target list which includes every domain **	which will later be referenced. */
end_comment

begin_macro
name|fixtl
argument_list|(
argument|tree1
argument_list|,
argument|qp1
argument_list|,
argument|ovlapvar
argument_list|,
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|tree1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|qp1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ovlapvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|tree
decl_stmt|,
modifier|*
modifier|*
name|qp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|var
decl_stmt|,
name|map
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
modifier|*
name|mksqlist
parameter_list|()
function_decl|;
name|tree
operator|=
name|tree1
expr_stmt|;
name|var
operator|=
name|ovlapvar
expr_stmt|;
name|map
operator|=
literal|1
operator|<<
name|var
expr_stmt|;
comment|/* 	** if the last tree referenced the overlap variable then 	** try to fix next tree 	*/
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|&
name|map
condition|)
block|{
name|qp
operator|=
name|qp1
expr_stmt|;
while|while
condition|(
name|next
operator|=
operator|*
name|qp
operator|++
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|next
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|)
operator|&
name|map
condition|)
name|dfind
argument_list|(
name|next
argument_list|,
name|buf
argument_list|,
name|mksqlist
argument_list|(
name|tree
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|xDTR1
end_ifdef

begin_comment
comment|/* **	This is strictly a debuggin routine used for **	printing component lists. */
end_comment

begin_macro
name|listcomp
argument_list|(
argument|list
argument_list|,
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|complist
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|complist
modifier|*
name|c
decl_stmt|,
modifier|*
name|cl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|list
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|nextcomp
control|)
block|{
name|i
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Component %d:map=%o\n"
argument_list|,
name|i
argument_list|,
name|cl
operator|->
name|bitmap
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cl
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|linkcomp
control|)
block|{
name|printf
argument_list|(
literal|"%x, "
argument_list|,
name|c
operator|->
name|clause
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|37
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|treepr
argument_list|(
name|c
operator|->
name|clause
operator|->
name|left
argument_list|)
expr_stmt|;
name|nodepr
argument_list|(
name|c
operator|->
name|clause
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

