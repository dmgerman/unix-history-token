begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)call_ovqp.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** CALL_OVQP -- Routines which interface to the One Variable Query Processor. ** **	This file contains the routines associated with sending queries **	and receiving results from OVQP. The interface to these routines is **	still messy. Call_ovqp is given the query, mode, and result relation **	as parameters and gets the source relation, and two flags **	(De.de_newq, De.de_newr) as globals. The routines include: ** **	Call_ovqp -- Sends a One-var query to ovqp and flushes the pipe. ** **	Readresult -- Reads the result from a one-var query. ** **	Endovqp    -- Informs ovqp that the query is over. Helps to synchronize **			the batch file (if any). ** **	Trace Flags: **		61 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ** Call_ovqp -- send query down pipe to ovqp and flush pipe. **	Inputs are: **		mode		retrieve, append, etc. **		resultnum	result relation id **		tree		the query **		De.de_sourcevar	(global) if>= 0 then source var **		De.de_newq		send NEWQ symbol **		De.de_newr		send NEWR symbol */
end_comment

begin_expr_stmt
name|call_ovqp
argument_list|(
name|tree
argument_list|,
name|mode
argument_list|,
name|resultnum
argument_list|)
specifier|register
name|QTREE
operator|*
name|tree
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|resultnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|rangename
parameter_list|()
function_decl|;
specifier|extern
name|int
name|derror
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|Batchupd
decl_stmt|;
specifier|extern
name|DESC
name|Inddes
decl_stmt|;
name|char
name|ovqpbuf
index|[
name|LBUFSIZE
index|]
decl_stmt|;
name|DESC
modifier|*
name|readopen
parameter_list|()
function_decl|;
specifier|extern
name|DESC
modifier|*
name|specopen
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rnum_convert
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xOTM
if|if
condition|(
name|tTf
argument_list|(
literal|90
argument_list|,
literal|1
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|61
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTf
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"CALL_OVQP-\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|61
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|de_newq
condition|)
block|{
name|printf
argument_list|(
literal|"new query to ovqp\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"query same as previous\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTf
argument_list|(
literal|61
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"De.de_sourcevar=%d\t"
argument_list|,
name|De
operator|.
name|de_sourcevar
argument_list|)
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|de_sourcevar
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"relid=%s\t"
argument_list|,
name|rangename
argument_list|(
name|De
operator|.
name|de_sourcevar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"De.ov_resultname=%s"
argument_list|,
name|rnum_convert
argument_list|(
name|resultnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rootuser
condition|)
name|printf
argument_list|(
literal|", userqry"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* assign mode of this query */
name|De
operator|.
name|de_qmode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|de_newr
condition|)
block|{
name|De
operator|.
name|de_newr
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|resultnum
operator|>=
literal|0
condition|)
block|{
name|De
operator|.
name|ov_result
operator|=
name|specopen
argument_list|(
name|resultnum
argument_list|)
expr_stmt|;
block|}
else|else
name|De
operator|.
name|ov_result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|de_sourcevar
operator|>=
literal|0
condition|)
name|De
operator|.
name|ov_source
operator|=
name|readopen
argument_list|(
name|De
operator|.
name|de_sourcevar
argument_list|)
expr_stmt|;
else|else
name|De
operator|.
name|ov_source
operator|=
name|NULL
expr_stmt|;
comment|/* assume this will be direct update */
name|De
operator|.
name|ov_userqry
operator|=
name|De
operator|.
name|de_buflag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rootuser
condition|)
block|{
name|De
operator|.
name|ov_userqry
operator|=
name|TRUE
expr_stmt|;
comment|/* handle batch file */
if|if
condition|(
name|De
operator|.
name|ov_result
operator|&&
name|De
operator|.
name|de_qmode
operator|!=
name|mdRETR
condition|)
block|{
if|if
condition|(
name|Batchupd
operator|||
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relindxd
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|ov_bopen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relindxd
operator|>
literal|0
condition|)
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|openbatch
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
operator|&
name|Inddes
argument_list|,
name|De
operator|.
name|de_qmode
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"call_ovqp:opn batch %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|De
operator|.
name|ov_bopen
operator|=
name|TRUE
expr_stmt|;
block|}
name|De
operator|.
name|de_buflag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/*  now write the query list itself  */
if|if
condition|(
name|De
operator|.
name|de_newq
condition|)
block|{
name|De
operator|.
name|ov_ovqpbuf
operator|=
name|ovqpbuf
expr_stmt|;
name|initbuf
argument_list|(
name|De
operator|.
name|ov_ovqpbuf
argument_list|,
name|LBUFSIZE
argument_list|,
name|LISTFULL
argument_list|,
name|derror
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_qvptr
operator|=
literal|0
expr_stmt|;
name|De
operator|.
name|ov_alist
operator|=
name|De
operator|.
name|ov_bylist
operator|=
name|De
operator|.
name|ov_qlist
operator|=
name|De
operator|.
name|ov_tlist
operator|=
name|NULL
expr_stmt|;
name|De
operator|.
name|ov_targvc
operator|=
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
expr_stmt|;
name|De
operator|.
name|ov_qualvc
operator|=
name|bitcnt
argument_list|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
argument_list|)
expr_stmt|;
name|De
operator|.
name|ov_agcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|type
operator|==
name|AGHEAD
condition|)
block|{
name|De
operator|.
name|ov_alist
operator|=
operator|&
name|De
operator|.
name|de_qvect
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|BYHEAD
condition|)
block|{
name|mklist
argument_list|(
name|tree
operator|->
name|left
operator|->
name|right
argument_list|)
expr_stmt|;
name|ovqpnod
argument_list|(
name|tree
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* BYHEAD node */
name|De
operator|.
name|ov_bylist
operator|=
operator|&
name|De
operator|.
name|de_qvect
index|[
name|De
operator|.
name|de_qvptr
index|]
expr_stmt|;
name|mklist
argument_list|(
name|tree
operator|->
name|left
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
else|else
name|mklist
argument_list|(
name|tree
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tree
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
name|De
operator|.
name|ov_tlist
operator|=
operator|&
name|De
operator|.
name|de_qvect
index|[
literal|0
index|]
expr_stmt|;
name|mklist
argument_list|(
name|tree
operator|->
name|left
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now for the qualification */
name|ovqpnod
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* ROOT node */
if|if
condition|(
name|tree
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|De
operator|.
name|ov_qlist
operator|=
operator|&
name|De
operator|.
name|de_qvect
index|[
name|De
operator|.
name|de_qvptr
index|]
expr_stmt|;
name|mklist
argument_list|(
name|tree
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
name|ovqpnod
argument_list|(
name|De
operator|.
name|de_qle
argument_list|)
expr_stmt|;
comment|/* QLEND node */
block|}
comment|/* Now call ovqp */
if|if
condition|(
name|strategy
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|xOTM
if|if
condition|(
name|tTf
argument_list|(
literal|90
argument_list|,
literal|2
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|9
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|scan
argument_list|()
expr_stmt|;
comment|/* scan the relation */
ifdef|#
directive|ifdef
name|xOTM
if|if
condition|(
name|tTf
argument_list|(
literal|90
argument_list|,
literal|2
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|i
operator|=
name|EMPTY
expr_stmt|;
ifdef|#
directive|ifdef
name|xOTM
if|if
condition|(
name|tTf
argument_list|(
literal|90
argument_list|,
literal|1
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return result of query */
return|return
operator|(
name|i
operator|==
name|NONEMPTY
operator|)
return|;
comment|/* TRUE if tuple satisfied */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Endovqp -- Inform ovqp that processing is complete. "Ack" indicates **	whether to wait for an acknowledgement from ovqp. The overall **	mode of the query is sent followed by an EXIT command. ** **	Ovqp decides whether to use batch update or not. If ack == ACK **	then endovqp will read a RETVAL symbol from ovqp and return **	a token which specifies whether to call the update processor or not. */
end_comment

begin_macro
name|endovqp
argument_list|(
argument|ack
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ack
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ack
operator|!=
name|RUBACK
condition|)
block|{
if|if
condition|(
name|Equel
operator|&&
name|De
operator|.
name|de_qry_mode
operator|==
name|mdRETTERM
condition|)
name|equeleol
argument_list|(
name|EXIT
argument_list|)
expr_stmt|;
comment|/* signal end of retrieve to equel process */
block|}
name|i
operator|=
name|NOUPDATE
expr_stmt|;
if|if
condition|(
name|ack
operator|==
name|ACK
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|ov_bopen
condition|)
block|{
name|closebatch
argument_list|()
expr_stmt|;
name|De
operator|.
name|ov_bopen
operator|=
name|FALSE
expr_stmt|;
name|i
operator|=
name|UPDATE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|De
operator|.
name|ov_bopen
condition|)
block|{
name|rmbatch
argument_list|()
expr_stmt|;
name|De
operator|.
name|ov_bopen
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|closecatalog
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Add node q to ovqp's list */
end_comment

begin_expr_stmt
name|ovqpnod
argument_list|(
name|q
argument_list|)
specifier|register
name|QTREE
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|SYMBOL
modifier|*
name|s
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|ckvar
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
specifier|register
name|int
name|i
decl_stmt|;
name|s
operator|=
operator|&
name|q
operator|->
name|sym
expr_stmt|;
comment|/* VAR nodes must be specially processed */
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|VAR
condition|)
block|{
comment|/* locate currently active VAR */
name|q
operator|=
name|ckvar
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Allocate an ovqp var node for the VAR */
name|s
operator|=
operator|(
name|SYMBOL
operator|*
operator|)
name|need
argument_list|(
name|De
operator|.
name|ov_ovqpbuf
argument_list|,
name|SYM_HDR_SIZ
operator|+
sizeof|sizeof
name|s
operator|->
name|value
operator|.
name|sym_var
argument_list|)
expr_stmt|;
name|s
operator|->
name|len
operator|=
sizeof|sizeof
name|s
operator|->
name|value
operator|.
name|sym_var
expr_stmt|;
name|s
operator|->
name|value
operator|.
name|sym_var
operator|.
name|attno
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
expr_stmt|;
name|s
operator|->
name|value
operator|.
name|sym_var
operator|.
name|varfrmt
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varfrmt
expr_stmt|;
name|s
operator|->
name|value
operator|.
name|sym_var
operator|.
name|varfrml
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varfrml
expr_stmt|;
comment|/* If VAR has been substituted for, get value */
if|if
condition|(
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|valptr
condition|)
block|{
comment|/* This is a substituted variable */
if|if
condition|(
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|==
name|De
operator|.
name|de_sourcevar
condition|)
name|syserr
argument_list|(
literal|"ovqpnod:bd sub %d,%d"
argument_list|,
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
argument_list|,
name|De
operator|.
name|de_sourcevar
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|S_VAR
expr_stmt|;
name|s
operator|->
name|value
operator|.
name|sym_var
operator|.
name|valptr
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|valptr
expr_stmt|;
block|}
else|else
block|{
comment|/* Var for one variable query */
if|if
condition|(
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|!=
name|De
operator|.
name|de_sourcevar
condition|)
name|syserr
argument_list|(
literal|"ovqpnod:src var %d,%d"
argument_list|,
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
argument_list|,
name|De
operator|.
name|de_sourcevar
argument_list|)
expr_stmt|;
name|s
operator|->
name|type
operator|=
name|VAR
expr_stmt|;
name|i
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|s
operator|->
name|value
operator|.
name|sym_var
operator|.
name|valptr
operator|=
operator|(
name|ANYTYPE
operator|*
operator|)
operator|(
name|De
operator|.
name|ov_intup
operator|+
name|De
operator|.
name|ov_source
operator|->
name|reloff
index|[
name|i
index|]
operator|)
expr_stmt|;
else|else
name|s
operator|->
name|value
operator|.
name|sym_var
operator|.
name|valptr
operator|=
operator|(
name|ANYTYPE
operator|*
operator|)
operator|&
name|De
operator|.
name|ov_intid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|AOP
condition|)
name|De
operator|.
name|ov_agcount
operator|++
expr_stmt|;
comment|/* add symbol to list */
if|if
condition|(
name|De
operator|.
name|de_qvptr
operator|>
name|MAXNODES
operator|-
literal|1
condition|)
name|ov_err
argument_list|(
name|NODOVFLOW
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_qvect
index|[
name|De
operator|.
name|de_qvptr
operator|++
index|]
operator|=
name|s
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  READAGG_RESULT */
end_comment

begin_macro
name|readagg_result
argument_list|(
argument|result
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|result
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
modifier|*
name|r
decl_stmt|,
modifier|*
name|aop
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|De
operator|.
name|ov_tend
operator|=
name|De
operator|.
name|ov_outtup
expr_stmt|;
name|r
operator|=
name|result
expr_stmt|;
while|while
condition|(
name|aop
operator|=
operator|*
name|r
operator|++
condition|)
block|{
name|i
operator|=
name|aop
operator|->
name|sym
operator|.
name|len
operator|&
name|I1MASK
expr_stmt|;
if|if
condition|(
name|aop
operator|->
name|sym
operator|.
name|type
operator|==
name|CHAR
condition|)
name|pad
argument_list|(
name|De
operator|.
name|ov_tend
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|De
operator|.
name|ov_tend
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|aop
operator|->
name|sym
operator|.
name|value
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|De
operator|.
name|ov_tend
operator|+=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|61
argument_list|,
literal|3
argument_list|)
condition|)
name|nodepr
argument_list|(
name|aop
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_macro
name|ov_err
argument_list|(
argument|code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|derror
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|DESC
modifier|*
name|openindex
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|varno
decl_stmt|;
name|DESC
modifier|*
name|readopen
parameter_list|()
function_decl|;
name|varno
operator|=
name|SECINDVAR
expr_stmt|;
name|De
operator|.
name|de_rangev
index|[
name|varno
index|]
operator|.
name|relnum
operator|=
name|rnum_assign
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|=
name|readopen
argument_list|(
name|varno
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **	Use "closer()" for closing relations. See **	desc_close in openrs.c for details. */
end_comment

begin_function_decl
specifier|extern
name|int
name|closer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|Des_closefunc
function_decl|)
parameter_list|()
init|=
name|closer
function_decl|;
end_function_decl

begin_macro
name|init_decomp
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|struct
name|accbuf
name|xtrabufs
index|[
literal|12
index|]
decl_stmt|;
name|set_so_buf
argument_list|()
expr_stmt|;
name|acc_addbuf
argument_list|(
name|xtrabufs
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|startdecomp
argument_list|()
end_macro

begin_block
block|{
comment|/* called at the start of each user query */
name|initrange
argument_list|()
expr_stmt|;
name|rnum_init
argument_list|()
expr_stmt|;
name|startovqp
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

