begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)exec_sq.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** DECOMP2 -- Routines for executing detached sub-queries appearing **	in sqlist. These routines include: ** **	exec_sq -- execute sub-queries and update range table. ** **	undo_sq -- restore range table and destroy temp rels. ** **	reset_sq - restore range table and reset temp rels. ** **	execsq1 -- call ovqp with subquery. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  EXEC_SQ ** **	Execute the subqueries in sqlist. Associated with **	each sub-query is a relation number stored in sqrange. **	If the sub-query has a non-null target list, the range **	table is updated to reflect the new range of the relation. ** **	If any sub-query is false, all subsequent ones are ignored **	by ovqp and exec_sq returns the var number of the false subquery. ** **	As a side effect, "disj" is incremented for each disjoint sub-query ** **	Trace Flags: **		35 */
end_comment

begin_macro
name|exec_sq
argument_list|(
argument|sqlist
argument_list|,
argument|sqrange
argument_list|,
argument|disj
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|sqlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sqrange
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|disj
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|sq
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|qualfound
decl_stmt|;
specifier|extern
name|DESC
modifier|*
name|openr1
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|35
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"EXEC_SQ--\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|disj
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sq
operator|=
name|sqlist
index|[
name|i
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|35
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sq[%d]=%x\n"
argument_list|,
name|i
argument_list|,
name|sq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qualfound
operator|=
name|execsq1
argument_list|(
name|sq
argument_list|,
name|i
argument_list|,
name|sqrange
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|35
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"qualfound=%d\n"
argument_list|,
name|qualfound
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qualfound
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
block|}
if|if
condition|(
name|sq
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
comment|/* 				** Update the range table and open 				** the relation's restricted replacement. 				*/
name|new_range
argument_list|(
name|i
argument_list|,
name|sqrange
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|openr1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|disj
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  UNDO_SQ ** **	Undo the effects of one variable detachment on **	the range table. The two parameters "limit" and **	"maxlimit" describe how far down the list of **	subqueries were processed.  Maxlimit represents **	the furthest every attained and limit represents **	the last variable processed the last time. ** **	Trace Flags: **		36 */
end_comment

begin_macro
name|undo_sq
argument_list|(
argument|sqlist
argument_list|,
argument|locrang
argument_list|,
argument|sqrange
argument_list|,
argument|limit
argument_list|,
argument|maxlimit
argument_list|,
argument|reopen
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|sqlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locrang
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sqrange
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxlimit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reopen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|sq
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|bool
name|dstr_flag
decl_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"UNDO_SQ--\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initp
argument_list|()
expr_stmt|;
comment|/* setup parm vector for destroys */
name|lim
operator|=
name|limit
operator|==
operator|-
literal|1
condition|?
name|MAXRANGE
else|:
name|limit
expr_stmt|;
if|if
condition|(
name|maxlimit
operator|==
operator|-
literal|1
condition|)
name|maxlimit
operator|=
name|MAXRANGE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sq
operator|=
name|sqlist
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|sq
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|lim
condition|)
block|{
comment|/* The query was run. Close the temp rel */
name|closer1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* mark the temporary to be destroyed */
name|dstr_mark
argument_list|(
name|sqrange
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dstr_flag
operator|=
name|TRUE
expr_stmt|;
comment|/* reopen the original relation. If maxlimit 				** never reached the variable "i" then the 				** original relation was never closed and thus 				** doesn't need to be reopened. 				*/
name|rstrang
argument_list|(
name|locrang
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|reopen
operator|&&
name|i
operator|<
name|maxlimit
condition|)
name|openr1
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only call destroy if there's something to destroy */
if|if
condition|(
name|dstr_flag
condition|)
name|call_dbu
argument_list|(
name|mdDESTROY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|resetp
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Execsq1 -- call ovqp with mdRETR on temp relation */
end_comment

begin_macro
name|execsq1
argument_list|(
argument|sq
argument_list|,
argument|var
argument_list|,
argument|relnum
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|sq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|var
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|relnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|qualfound
decl_stmt|;
name|De
operator|.
name|de_sourcevar
operator|=
name|var
expr_stmt|;
name|De
operator|.
name|de_newq
operator|=
literal|1
expr_stmt|;
name|qualfound
operator|=
name|call_ovqp
argument_list|(
name|sq
argument_list|,
name|mdRETR
argument_list|,
name|relnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|qualfound
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Reset each relation until limit. **	Reset will remove all tuples from the **	relation but not destroy the relation. **	The descriptor for the relation will be removed **	from the cache. ** **	The original relation is returned to **	the range table. ** **	If limit is -1 then all relations are done. */
end_comment

begin_macro
name|reset_sq
argument_list|(
argument|sqlist
argument_list|,
argument|locrang
argument_list|,
argument|limit
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|sqlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locrang
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|limit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|sq
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
name|int
name|old
decl_stmt|,
name|reset
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rnum_convert
parameter_list|()
function_decl|;
name|lim
operator|=
name|limit
operator|==
operator|-
literal|1
condition|?
name|MAXRANGE
else|:
name|limit
expr_stmt|;
name|reset
operator|=
name|FALSE
expr_stmt|;
name|initp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|sq
operator|=
name|sqlist
index|[
name|i
index|]
operator|)
operator|&&
name|sq
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
name|old
operator|=
name|new_range
argument_list|(
name|i
argument_list|,
name|locrang
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|rnum_convert
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
name|specclose
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|reset
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|reset
condition|)
block|{
comment|/* 		** Guarantee that OVQP will not reuse old 		** page of relation being reset 		*/
name|De
operator|.
name|de_newr
operator|=
name|TRUE
expr_stmt|;
name|call_dbu
argument_list|(
name|mdRESETREL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|resetp
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

