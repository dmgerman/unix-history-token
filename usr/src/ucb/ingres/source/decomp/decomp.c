begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)decomp.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** DECOMP -- Process a query given a query tree and range table. ** **	Decomp processes any arbitrary query by converting it into **	a sequence of "one variable queries"; eg. queries involving **	at most one source relation. This file and decision.c contain **	the principle decision making routines. ** **	Decomp() is called with a pointer to a query tree, the mode **	of the query (retrieve, append, etc.), and the internal name **	of the result relation (if any). The routines included are: ** **	Decomp  -- Opens the source relations and decides whether the **			query is multi-variable or single/zero variable. ** **	Decompx -- Takes a multivariable query, removes and executes any **			one-var restrictions and passes the remaining query **			to decompz (if one/zero variable) or decision(). ** **	Decompy -- Performs "tuple substitution" on a multi-var query, **			does any new one-var restrictions and passes the **			remaining query to decompz (if one/zero variable) **			or decision(). ** **	Decompz -- Executes a one/zero variable query by calling call_ovqp(). */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **	Process query by calling either decompx for multivar **	or decompz for 0 or 1 var query. Decomp() must guarantee **	that the range table is the same upon exiting as it was **	when entered. Newquery() and endquery() perform that function. ** **	Trace Flags: **		30 */
end_comment

begin_macro
name|decomp
argument_list|(
argument|q
argument_list|,
argument|qmode
argument_list|,
argument|result_num
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|result_num
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|root
decl_stmt|;
specifier|register
name|int
name|vc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|locrange
index|[
name|MAXRANGE
index|]
decl_stmt|;
name|root
operator|=
name|q
expr_stmt|;
name|vc
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|30
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"DECOMP: %d-var query, result_num=%d\n"
argument_list|,
name|vc
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|30
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"DECOMP\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|openrs
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc
operator|>
literal|1
condition|)
block|{
name|newquery
argument_list|(
name|locrange
argument_list|)
expr_stmt|;
name|i
operator|=
name|decompx
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
name|endquery
argument_list|(
name|locrange
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* don't reopen previous range */
block|}
else|else
block|{
name|De
operator|.
name|de_newq
operator|=
literal|1
expr_stmt|;
name|De
operator|.
name|de_sourcevar
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|decompz
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Decompx -- Initialize for multi-variable query. **	All one-variable subqueries are run. **	If the remaining query is still multi-var **	then decision() is called; else decompz() **	is called. The range table is restored **	after the query is complete. **	The tempvars from the exec_sq() are left on the **	tree since it is presumed that the tree will be discarded **	anyway. ** **	Trace Flags: **		31 */
end_comment

begin_macro
name|decompx
argument_list|(
argument|root
argument_list|,
argument|qmode
argument_list|,
argument|result_num
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|result_num
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|vc
decl_stmt|;
name|int
name|disj
decl_stmt|;
name|char
name|sqbuf
index|[
name|SQSIZ
index|]
decl_stmt|;
name|QTREE
modifier|*
name|sqlist
index|[
name|MAXRANGE
index|]
decl_stmt|;
name|int
name|locrang
index|[
name|MAXRANGE
index|]
decl_stmt|,
name|sqrange
index|[
name|MAXRANGE
index|]
decl_stmt|;
specifier|extern
name|int
name|derror
parameter_list|()
function_decl|;
name|vc
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
expr_stmt|;
name|initbuf
argument_list|(
name|sqbuf
argument_list|,
name|SQSIZ
argument_list|,
name|SQBUFFULL
argument_list|,
name|derror
argument_list|)
expr_stmt|;
name|pull_sq
argument_list|(
name|root
argument_list|,
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqrange
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|exec_sq
argument_list|(
name|sqlist
argument_list|,
name|sqrange
argument_list|,
operator|&
name|disj
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|undo_sq
argument_list|(
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqrange
argument_list|,
name|i
argument_list|,
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|vc
operator|-=
name|disj
expr_stmt|;
name|tempvar
argument_list|(
name|root
argument_list|,
name|sqlist
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pull_const
argument_list|(
name|root
argument_list|,
name|sqbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|vc
operator|<=
literal|1
condition|)
block|{
name|De
operator|.
name|de_sourcevar
operator|=
operator|-
literal|1
expr_stmt|;
name|De
operator|.
name|de_newq
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|decompz
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
operator|)
return|;
block|}
name|i
operator|=
name|decision
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
name|undo_sq
argument_list|(
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqrange
argument_list|,
name|MAXRANGE
argument_list|,
name|MAXRANGE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Decompy -- decompose a multi-variable query by tuple substitution. **	First a variable is selected **	for substitution. Then for each tuple in the **	selected variable, all one variable restrictions **	are done (exec_sq) and the remaining query is **	solved by calling either decompz() or recursively **	decision(). ** **	The original tree and range table are guaranteed to **	be the same on entry and exit (modulo the effects of **	reformat()). ** **	Trace Flags: **		32 */
end_comment

begin_macro
name|decompy
argument_list|(
argument|q
argument_list|,
argument|qmode
argument_list|,
argument|result_num
argument_list|,
argument|sqbuf
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|result_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sqbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|root
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|vc
decl_stmt|;
name|DESC
modifier|*
name|d
decl_stmt|;
name|QTREE
modifier|*
name|newroot
decl_stmt|;
name|int
name|constl
decl_stmt|,
name|sqcnt
decl_stmt|,
name|var
decl_stmt|,
name|srcvar
decl_stmt|,
name|maxsqcnt
decl_stmt|;
name|int
name|disj
decl_stmt|,
name|tc
decl_stmt|,
name|qtrue
decl_stmt|;
name|TID
name|tid
decl_stmt|,
name|hitid
decl_stmt|;
name|char
modifier|*
name|tuple
decl_stmt|;
name|QTREE
modifier|*
name|sqlist
index|[
name|MAXRANGE
index|]
decl_stmt|;
name|int
name|sqmark
decl_stmt|,
name|sqmark1
decl_stmt|;
name|int
name|locrang
index|[
name|MAXRANGE
index|]
decl_stmt|,
name|sqrange
index|[
name|MAXRANGE
index|]
decl_stmt|;
specifier|extern
name|DESC
modifier|*
name|readopen
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|need
argument_list|()
decl_stmt|,
modifier|*
name|rangename
argument_list|()
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|copy_ands
parameter_list|()
function_decl|;
name|root
operator|=
name|q
expr_stmt|;
name|vc
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|32
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"DECOMPY:%x,vc=%d\n"
argument_list|,
name|root
argument_list|,
name|vc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sqmark
operator|=
name|markbuf
argument_list|(
name|sqbuf
argument_list|)
expr_stmt|;
name|constl
operator|=
operator|!
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarc
expr_stmt|;
name|qtrue
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|=
name|selectv
argument_list|(
name|root
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|qtrue
operator|)
return|;
name|d
operator|=
name|readopen
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* gets full descriptor for setvar& get */
name|tuple
operator|=
name|need
argument_list|(
name|sqbuf
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relwid
argument_list|)
expr_stmt|;
name|setvar
argument_list|(
name|root
argument_list|,
name|var
argument_list|,
operator|&
name|tid
argument_list|,
name|tuple
argument_list|)
expr_stmt|;
name|pull_sq
argument_list|(
name|root
argument_list|,
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqrange
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
name|tempvar
argument_list|(
name|root
argument_list|,
name|sqlist
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
name|reformat
argument_list|(
name|var
argument_list|,
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqbuf
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|vc
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR2
if|if
condition|(
name|tTf
argument_list|(
literal|32
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"DECOMPY:&tup=%x, "
argument_list|,
name|tuple
argument_list|)
expr_stmt|;
name|printdesc
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|xDTR2
comment|/* HERE FOR MULTI-VAR SUBSTITUTION */
name|sqmark1
operator|=
name|markbuf
argument_list|(
name|sqbuf
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_newq
operator|=
literal|1
expr_stmt|;
name|tc
operator|=
literal|0
expr_stmt|;
name|sqcnt
operator|=
name|maxsqcnt
operator|=
literal|0
expr_stmt|;
name|srcvar
operator|=
operator|-
literal|1
expr_stmt|;
name|De
operator|.
name|de_sourcevar
operator|=
operator|-
literal|1
expr_stmt|;
name|find
argument_list|(
name|readopen
argument_list|(
name|var
argument_list|)
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|hitid
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|j
operator|=
name|get
argument_list|(
name|readopen
argument_list|(
name|var
argument_list|)
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|hitid
argument_list|,
name|tuple
argument_list|,
name|NXTTUP
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|32
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Subst:"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
name|readopen
argument_list|(
name|var
argument_list|)
argument_list|,
name|tuple
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tc
operator|++
expr_stmt|;
if|if
condition|(
name|vc
operator|>
literal|1
condition|)
block|{
name|reset_sq
argument_list|(
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sqcnt
operator|=
name|exec_sq
argument_list|(
name|sqlist
argument_list|,
name|sqrange
argument_list|,
operator|&
name|disj
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|maxsqcnt
operator|=
name|sqcnt
expr_stmt|;
name|vc
operator|-=
name|disj
expr_stmt|;
if|if
condition|(
name|vc
operator|<=
literal|1
condition|)
block|{
name|De
operator|.
name|de_sourcevar
operator|=
name|srcvar
expr_stmt|;
name|qtrue
operator||=
name|decompz
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
name|srcvar
operator|=
name|De
operator|.
name|de_sourcevar
expr_stmt|;
block|}
else|else
block|{
name|freebuf
argument_list|(
name|sqbuf
argument_list|,
name|sqmark1
argument_list|)
expr_stmt|;
name|newroot
operator|=
name|copy_ands
argument_list|(
name|root
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
name|qtrue
operator||=
name|decision
argument_list|(
name|newroot
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|,
name|sqbuf
argument_list|)
expr_stmt|;
block|}
name|vc
operator|+=
name|disj
expr_stmt|;
block|}
else|else
name|qtrue
operator||=
name|decompz
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
comment|/* check for early termination on constant Target list */
if|if
condition|(
name|constl
operator|&&
name|qtrue
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"decompy: bad get %d on %.12s"
argument_list|,
name|j
argument_list|,
name|readopen
argument_list|(
name|var
argument_list|)
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
comment|/* undo the effect of pulling the sub queries */
name|origvar
argument_list|(
name|root
argument_list|,
name|sqlist
argument_list|)
expr_stmt|;
name|undo_sq
argument_list|(
name|sqlist
argument_list|,
name|locrang
argument_list|,
name|sqrange
argument_list|,
name|sqcnt
argument_list|,
name|maxsqcnt
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* undo the setvar on the main tree and all subtrees */
name|clearvar
argument_list|(
name|root
argument_list|,
name|var
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXRANGE
condition|;
name|j
operator|++
control|)
name|clearvar
argument_list|(
name|sqlist
index|[
name|j
index|]
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* return any used buffer space */
name|freebuf
argument_list|(
name|sqbuf
argument_list|,
name|sqmark
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|32
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tc[%.12s]=%d,qtrue=%d\n"
argument_list|,
name|rangename
argument_list|(
name|var
argument_list|)
argument_list|,
name|tc
argument_list|,
name|qtrue
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|qtrue
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Decompz processes a one variable query **	by calling call_ovqp(). ** **	Trace Flags: **		33 */
end_comment

begin_macro
name|decompz
argument_list|(
argument|q
argument_list|,
argument|qmode
argument_list|,
argument|result_num
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|qmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|result_num
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|root
decl_stmt|;
specifier|register
name|int
name|qualfound
decl_stmt|;
name|root
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|de_sourcevar
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|De
operator|.
name|de_sourcevar
operator|=
name|selectv
argument_list|(
name|root
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
name|De
operator|.
name|de_sourcevar
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|qualfound
operator|=
name|call_ovqp
argument_list|(
name|root
argument_list|,
name|qmode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
name|De
operator|.
name|de_newq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|qualfound
operator|)
return|;
block|}
end_block

end_unit

