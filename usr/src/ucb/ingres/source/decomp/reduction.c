begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)reduction.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	Reduction -- This file contains routines related to the **	reduction algorithm. The routines are all called by **	decision(). ** **	Included are: ** **		algorithm -- groups clauses according to common variables ** **		buildlist -- build linked list of clauses from a query tree ** **		construct -- build query trees from link lists of clauses ** **		order     -- order a linked list of clauses into the prefered **				execution sequence */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **	Algorithm - determine whether query is connected or not ** **	Algorithm takes a linked list of query components **	and groups them according to the variables involved **	in each component. If the query is fully interconnected **	then algorithm returns TRUE else it returns FALSE. ** **	By definition a constant clause (one involving zero variables) **	is considered to use all variables. Without this rule, **	a query with a null target list would always break into **	two pieces. ** **	Whether a query is fully connected is independent **	of whether there are any one variable components **	or not. This includes the target list. After applying **	the algorithm, a scan is made to see how many multi-var **	components are present. If there are two or more multi-var **	components then the query is disconnected. ** **	Trace Flags: **		38 */
end_comment

begin_macro
name|algorithm
argument_list|(
argument|clist
argument_list|,
argument|varmap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|complist
modifier|*
name|clist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|varmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|complist
modifier|*
name|chead
decl_stmt|,
modifier|*
name|cnext
decl_stmt|;
specifier|register
name|int
name|var
decl_stmt|;
name|int
name|vmap
decl_stmt|;
name|struct
name|complist
modifier|*
name|cprev
decl_stmt|,
modifier|*
name|cl
decl_stmt|;
name|vmap
operator|=
name|varmap
expr_stmt|;
for|for
control|(
name|var
operator|=
literal|1
init|;
name|vmap
condition|;
name|var
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|vmap
operator|&
name|var
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|vmap
operator|&=
operator|~
name|var
expr_stmt|;
comment|/* remove var */
comment|/* done if query is already a single piece */
if|if
condition|(
name|clist
operator|->
name|nextcomp
operator|==
literal|0
condition|)
break|break;
comment|/* find first component using variable var */
for|for
control|(
name|chead
operator|=
name|clist
init|;
name|chead
condition|;
name|chead
operator|=
name|chead
operator|->
name|nextcomp
control|)
block|{
if|if
condition|(
name|chead
operator|->
name|bitmap
operator|==
literal|0
operator|||
operator|(
name|chead
operator|->
name|bitmap
operator|&
name|var
operator|)
condition|)
block|{
comment|/* this component uses variable var */
name|cprev
operator|=
name|chead
expr_stmt|;
comment|/* look for other components using variable var */
for|for
control|(
name|cnext
operator|=
name|chead
operator|->
name|nextcomp
init|;
name|cnext
condition|;
name|cnext
operator|=
name|cnext
operator|->
name|nextcomp
control|)
block|{
if|if
condition|(
name|cnext
operator|->
name|bitmap
operator|==
literal|0
operator|||
operator|(
name|cnext
operator|->
name|bitmap
operator|&
name|var
operator|)
condition|)
block|{
comment|/* 						** Found a component. Remove it from "next" 						** link and put it with head piece 						*/
comment|/* remove piece */
name|cprev
operator|->
name|nextcomp
operator|=
name|cnext
operator|->
name|nextcomp
expr_stmt|;
comment|/* fix up bit map */
name|chead
operator|->
name|bitmap
operator||=
name|cnext
operator|->
name|bitmap
expr_stmt|;
comment|/* find end of head component */
for|for
control|(
name|cl
operator|=
name|chead
init|;
name|cl
operator|->
name|linkcomp
condition|;
name|cl
operator|=
name|cl
operator|->
name|linkcomp
control|)
empty_stmt|;
comment|/* connect with head piece */
name|cl
operator|->
name|linkcomp
operator|=
name|cnext
expr_stmt|;
block|}
else|else
name|cprev
operator|=
name|cnext
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* return whether connected or not connected */
for|for
control|(
name|var
operator|=
literal|0
operator|,
name|chead
operator|=
name|clist
init|;
name|chead
condition|;
name|chead
operator|=
name|chead
operator|->
name|nextcomp
control|)
if|if
condition|(
name|bitcnt
argument_list|(
name|chead
operator|->
name|bitmap
argument_list|)
operator|>
literal|1
condition|)
name|var
operator|++
expr_stmt|;
comment|/* this component involves 2 or more vars */
return|return
operator|(
name|var
operator|<
literal|2
operator|)
return|;
comment|/* return TRUE if zero or one component multi-var */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Buildlist -- Build a component list from a query tree. ** **	Each ROOT and AND node is treated as a separate component **	and a linked list is built connecting them. The ROOT node **	MUST be the first element. This list will later be manipulated **	by algorithm() to determine the structure of the query. ** **	Returns: **		Head of the list */
end_comment

begin_function
name|struct
name|complist
modifier|*
name|buildlist
parameter_list|(
name|root1
parameter_list|,
name|buf
parameter_list|)
name|QTREE
modifier|*
name|root1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|struct
name|complist
modifier|*
name|head
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|root
decl_stmt|;
name|struct
name|complist
modifier|*
name|ret
decl_stmt|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
name|ret
operator|=
operator|(
expr|struct
name|complist
operator|*
operator|)
name|need
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|root
operator|=
name|root1
init|;
name|root
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|;
name|root
operator|=
name|root
operator|->
name|right
control|)
block|{
name|next
operator|=
operator|(
expr|struct
name|complist
operator|*
operator|)
name|need
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|->
name|clause
operator|=
name|root
expr_stmt|;
name|next
operator|->
name|nextcomp
operator|=
name|next
operator|->
name|linkcomp
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|bitmap
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
expr_stmt|;
if|if
condition|(
name|head
condition|)
name|head
operator|->
name|nextcomp
operator|=
name|next
expr_stmt|;
name|head
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Construct -- construct a tree from a list component ** **	Construct takes a list head and builds a querytree **	from the components in the list. If the head component **	is the ROOT of the original query, then **	the original ROOT node is reused. ** */
end_comment

begin_function
name|QTREE
modifier|*
name|construct
parameter_list|(
name|root
parameter_list|,
name|listhead
parameter_list|,
name|buf
parameter_list|)
name|QTREE
modifier|*
name|root
decl_stmt|;
name|struct
name|complist
modifier|*
name|listhead
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|ret
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|complist
modifier|*
name|clist
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|makroot
parameter_list|()
function_decl|;
name|clist
operator|=
name|listhead
expr_stmt|;
comment|/* determine ROOT of tree */
if|if
condition|(
name|root
operator|==
name|clist
operator|->
name|clause
condition|)
block|{
name|q
operator|=
name|root
expr_stmt|;
name|clist
operator|=
name|clist
operator|->
name|linkcomp
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|makroot
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
name|clist
condition|;
name|clist
operator|=
name|clist
operator|->
name|linkcomp
control|)
block|{
name|q
operator|->
name|right
operator|=
name|clist
operator|->
name|clause
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|right
expr_stmt|;
block|}
name|q
operator|->
name|right
operator|=
name|De
operator|.
name|de_qle
expr_stmt|;
name|mapvar
argument_list|(
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|38
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Construct\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Order -- order a link list set of query components. ** **	Takes a list of components and orders them: **		first - disjoint components **		second - reduction pieces **		last - the original target list piece ** **	Return: **		new head of list */
end_comment

begin_function
name|struct
name|complist
modifier|*
name|order
parameter_list|(
name|clist
parameter_list|,
name|ovlapvar
parameter_list|)
name|struct
name|complist
modifier|*
name|clist
decl_stmt|;
name|int
name|ovlapvar
decl_stmt|;
block|{
specifier|register
name|struct
name|complist
modifier|*
name|cl
decl_stmt|,
modifier|*
name|joint
decl_stmt|,
modifier|*
name|disjoint
decl_stmt|;
name|struct
name|complist
modifier|*
name|xd
decl_stmt|,
modifier|*
name|xj
decl_stmt|,
modifier|*
name|tlpiece
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|QTREE
modifier|*
name|tmp
decl_stmt|;
name|int
name|map
decl_stmt|;
name|tlpiece
operator|=
name|clist
expr_stmt|;
comment|/* target list piece always first */
name|disjoint
operator|=
name|joint
operator|=
literal|0
expr_stmt|;
name|map
operator|=
name|ovlapvar
operator|>=
literal|0
condition|?
literal|1
operator|<<
name|ovlapvar
else|:
literal|0
expr_stmt|;
comment|/* examine each irreducible component for disjointness */
for|for
control|(
name|cl
operator|=
name|tlpiece
operator|->
name|nextcomp
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|nextcomp
control|)
block|{
if|if
condition|(
name|cl
operator|->
name|bitmap
operator|&
name|map
condition|)
block|{
comment|/* joint piece */
if|if
condition|(
name|joint
operator|==
literal|0
condition|)
block|{
name|joint
operator|=
name|cl
expr_stmt|;
name|xj
operator|=
name|cl
expr_stmt|;
block|}
else|else
block|{
name|joint
operator|->
name|nextcomp
operator|=
name|cl
expr_stmt|;
name|joint
operator|=
name|cl
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* disjoint piece */
if|if
condition|(
name|disjoint
operator|==
literal|0
condition|)
block|{
name|disjoint
operator|=
name|cl
expr_stmt|;
name|xd
operator|=
name|cl
expr_stmt|;
block|}
else|else
block|{
name|disjoint
operator|->
name|nextcomp
operator|=
name|cl
expr_stmt|;
name|disjoint
operator|=
name|cl
expr_stmt|;
block|}
block|}
block|}
comment|/* we now have all disjoint, joint and tl pieces */
comment|/* order them in order (1) xd, (2) xj, (3) tlpiece */
name|ret
operator|=
name|tlpiece
expr_stmt|;
name|tlpiece
operator|->
name|nextcomp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|joint
condition|)
block|{
name|ret
operator|=
name|xj
expr_stmt|;
name|joint
operator|->
name|nextcomp
operator|=
name|tlpiece
expr_stmt|;
if|if
condition|(
operator|(
name|tlpiece
operator|->
name|bitmap
operator|&
operator|(
operator|~
name|map
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			** This is the special case of the target list 			** being one (or zero) variable and that variable 			** is the overlap variable. If left as is, the 			** reduction will take one step more than is 			** necessary. The target list piece is combined 			** with the last joint piece and processed together. 			** 			** An example of when this will happen is: 			** ret(p.a) : p.b = s.b ^ p.c = y.c 			** 			** Reduction would split this up into 			** (1) ret (p.a,p.b) : p.c = y.c 			** (2) ret (p.a) : p.b = s.b 			** (3) ret (p.a) 			** 			** Here we are allowing pieces (2)& (3) to be done together 			*/
for|for
control|(
name|cl
operator|=
name|joint
init|;
name|cl
operator|->
name|linkcomp
condition|;
name|cl
operator|=
name|cl
operator|->
name|linkcomp
control|)
empty_stmt|;
name|cl
operator|->
name|linkcomp
operator|=
name|tlpiece
expr_stmt|;
name|joint
operator|->
name|nextcomp
operator|=
literal|0
expr_stmt|;
comment|/* switch tl clause to top of complist */
name|tmp
operator|=
name|joint
operator|->
name|clause
expr_stmt|;
name|joint
operator|->
name|clause
operator|=
name|tlpiece
operator|->
name|clause
expr_stmt|;
name|tlpiece
operator|->
name|clause
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|disjoint
condition|)
block|{
name|ret
operator|=
name|xd
expr_stmt|;
name|disjoint
operator|->
name|nextcomp
operator|=
name|joint
condition|?
name|xj
else|:
name|tlpiece
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

