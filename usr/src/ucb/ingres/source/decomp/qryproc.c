begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<resp.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)qryproc.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* Control Module configuration information structure */
end_comment

begin_function_decl
specifier|extern
name|int
name|de_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|de_rubproc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|qryproc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fn_def
name|DeOvqpFn
init|=
block|{
literal|"DECOMP/OVQP"
block|,
name|qryproc
block|,
name|de_init
block|,
name|de_rubproc
block|,
operator|(
name|char
operator|*
operator|)
operator|&
name|De
block|,
sizeof|sizeof
name|De
block|,
name|tTdecomp
block|,
literal|100
block|,
literal|'D'
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|qryproc
argument_list|(
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|root
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|result_num
decl_stmt|,
name|retr_uniq
decl_stmt|;
specifier|extern
name|long
name|Accuread
decl_stmt|,
name|Accuwrite
decl_stmt|,
name|Accusread
decl_stmt|;
specifier|extern
name|int
name|derror
parameter_list|()
function_decl|;
name|char
name|loc_qbuf
index|[
name|QBUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|xDTM
if|if
condition|(
name|tTf
argument_list|(
literal|90
argument_list|,
literal|1
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|50
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|Accuread
operator|=
literal|0
expr_stmt|;
name|Accusread
operator|=
literal|0
expr_stmt|;
name|Accuwrite
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|De
operator|.
name|de_qbuf
operator|=
name|loc_qbuf
expr_stmt|;
name|initbuf
argument_list|(
name|loc_qbuf
argument_list|,
name|QBUFSIZ
argument_list|,
name|QBUFFULL
argument_list|,
name|derror
argument_list|)
expr_stmt|;
comment|/* init various variables in decomp for start of this query */
name|startdecomp
argument_list|()
expr_stmt|;
comment|/* Read in query, range table and mode */
if|if
condition|(
name|pv
index|[
literal|0
index|]
operator|.
name|pv_type
operator|!=
name|PV_QTREE
condition|)
name|syserr
argument_list|(
literal|"qryproc: bad parameter"
argument_list|)
expr_stmt|;
name|root
operator|=
name|pv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_qtree
expr_stmt|;
comment|/* a john fix (below) 	root->sym.value.sym_root.rootuser = TRUE; */
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|50
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"qryproc\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* initialize qt parameters */
name|mode
operator|=
name|De
operator|.
name|de_qmode
operator|=
name|Qt
operator|.
name|qt_qmode
expr_stmt|;
name|De
operator|.
name|de_resultvar
operator|=
name|Qt
operator|.
name|qt_resvar
expr_stmt|;
comment|/* 	** Initialize range table. This code should eventually 	** be changed to take advantage of the fact that all 	** the openrs are already done by the control module. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|!=
name|NULL
condition|)
block|{
name|De
operator|.
name|de_rangev
index|[
name|i
index|]
operator|.
name|relnum
operator|=
name|rnum_assign
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize relation descriptors */
name|initdesc
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* locate pointers to QLEND and TREE nodes */
for|for
control|(
name|q
operator|=
name|root
operator|->
name|right
init|;
name|q
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|;
name|q
operator|=
name|q
operator|->
name|right
control|)
continue|continue;
name|De
operator|.
name|de_qle
operator|=
name|q
expr_stmt|;
for|for
control|(
name|q
operator|=
name|root
operator|->
name|left
init|;
name|q
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|q
operator|=
name|q
operator|->
name|left
control|)
continue|continue;
name|De
operator|.
name|de_tr
operator|=
name|q
expr_stmt|;
comment|/* map the complete tree */
name|mapvar
argument_list|(
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set logical locks */
if|if
condition|(
name|Lockrel
condition|)
name|lockit
argument_list|(
name|root
argument_list|,
name|De
operator|.
name|de_resultvar
argument_list|)
expr_stmt|;
comment|/* If there is no result variable then this must be a retrieve to the terminal */
name|De
operator|.
name|de_qry_mode
operator|=
name|De
operator|.
name|de_resultvar
operator|<
literal|0
condition|?
name|mdRETTERM
else|:
name|mode
expr_stmt|;
comment|/* if the mode is retrieve_unique, then make a result rel */
name|retr_uniq
operator|=
name|mode
operator|==
name|mdRET_UNI
expr_stmt|;
if|if
condition|(
name|retr_uniq
condition|)
block|{
name|mk_unique
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mdRETR
expr_stmt|;
block|}
comment|/* get id of result relation */
if|if
condition|(
name|De
operator|.
name|de_resultvar
operator|<
literal|0
condition|)
name|result_num
operator|=
name|NORESULT
expr_stmt|;
else|else
name|result_num
operator|=
name|De
operator|.
name|de_rangev
index|[
name|De
operator|.
name|de_resultvar
index|]
operator|.
name|relnum
expr_stmt|;
comment|/* evaluate aggregates in query */
name|aggregate
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* decompose and process aggregate free query */
name|decomp
argument_list|(
name|root
argument_list|,
name|mode
argument_list|,
name|result_num
argument_list|)
expr_stmt|;
comment|/* If this is a retrieve unique, then retrieve results */
if|if
condition|(
name|retr_uniq
condition|)
name|pr_unique
argument_list|(
name|root
argument_list|,
name|De
operator|.
name|de_resultvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|mdRETR
condition|)
name|i
operator|=
name|ACK
expr_stmt|;
else|else
name|i
operator|=
name|NOACK
expr_stmt|;
name|i
operator|=
name|endovqp
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|50
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"DECOMP read %ld pages,"
argument_list|,
name|Accuread
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ld catalog pages,"
argument_list|,
name|Accusread
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wrote %ld pages\n"
argument_list|,
name|Accuwrite
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* call update processor if batch mode */
if|if
condition|(
name|i
operator|==
name|UPDATE
condition|)
block|{
name|initp
argument_list|()
expr_stmt|;
name|call_dbu
argument_list|(
name|mdUPDATE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xDTM
if|if
condition|(
name|tTf
argument_list|(
literal|90
argument_list|,
literal|1
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* clean decomp */
name|reinit
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|UPDATE
condition|)
name|Resp
operator|.
name|resp_tups
operator|=
name|De
operator|.
name|ov_tupsfound
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

