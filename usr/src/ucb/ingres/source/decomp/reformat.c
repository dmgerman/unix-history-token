begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)reformat.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	REFORMAT.C -- "reformat" module of DECOMPOSITION ** **	reformat() examines each relation which will be **	involved in a one variable subquery to see if it **	is cost effective to modify the relation to a more **	usefull structure. Included in this file are all the **	routines associated with reformat: ** **		reformat -- reformats each relation if cost effective ** **		findlinks -- determines what one variable clauses (if any) **				are associated with the current variable **				and the substitution variable. ** **		rangrf    -- decides whether to actually reformat and does it. ** **		primrf    -- performs a projection on a user relation ** **		ckpkey    -- determines if relation is already structured usefully. ** **		findwid   -- determines width of target list. ** **		rel_tup   -- returns how many tuples fit on one page */
end_comment

begin_escape
end_escape

begin_comment
comment|/* ** Reformat -- Examine each variable to see if it should be reformated. ** **	The algorithm is: **	(1) Find all variables for which, after tuple substitution, **	    will have one variable equality clauses on them. **	(2) Estimate how much it will cost to execute them. **	(3) Ignore those relations which are already keyed usefully. **	(4) If it is a user relation, determine if it will be less costly **	    to first project (and possibly) modify the relation. **	(5) If it is a _SYS relation, determine if it will be less costly **	    to modify the relation to hash on the linking domains. */
end_comment

begin_macro
name|reformat
argument_list|(
argument|var
argument_list|,
argument|sqlist
argument_list|,
argument|locrang
argument_list|,
argument|buf
argument_list|,
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|int
name|var
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|sqlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locrang
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|sq
decl_stmt|;
specifier|register
name|char
modifier|*
name|lmap
decl_stmt|;
specifier|register
name|int
name|mainvar
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|linkmap
index|[
name|MAXDOM
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"REFORMAT: subvar=%d\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if the main tree is single var then put it in sq list */
name|mainvar
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|tvarc
operator|==
literal|1
condition|)
block|{
name|mainvar
operator|=
name|bitpos
argument_list|(
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqlist
index|[
name|mainvar
index|]
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"help reformat"
argument_list|)
expr_stmt|;
name|sqlist
index|[
name|mainvar
index|]
operator|=
name|tree
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"including var %d\n"
argument_list|,
name|mainvar
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sq
operator|=
name|sqlist
index|[
name|i
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Sqlist[%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lmap
operator|=
name|linkmap
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXDOM
condition|;
name|j
operator|++
control|)
operator|*
name|lmap
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|findlinks
argument_list|(
name|sq
operator|->
name|right
argument_list|,
name|var
argument_list|,
name|i
argument_list|,
name|linkmap
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|1
argument_list|)
condition|)
name|prlinks
argument_list|(
literal|"Findlinks found"
argument_list|,
name|linkmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rangrf
argument_list|(
name|i
argument_list|,
name|var
argument_list|,
name|sq
argument_list|,
name|buf
argument_list|,
name|linkmap
argument_list|,
name|tree
argument_list|,
name|locrang
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mainvar
operator|>=
literal|0
condition|)
name|sqlist
index|[
name|mainvar
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Findlinks -- Determine whether there are any equalify clauses **	between the "linkv" and the variable selected for tuple **	substitution "selv". ** **	Return: **		TRUE if there is a linking variable **		FALSE if not ** **	Side Effects: **		The linkmap is set to 1 for each linking domains. **		ie. if domains 3 is a linking domains then **		linkmap[3] = 1. */
end_comment

begin_macro
name|findlinks
argument_list|(
argument|node
argument_list|,
argument|selv
argument_list|,
argument|linkv
argument_list|,
argument|linkmap
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|selv
decl_stmt|,
name|linkv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|linkmap
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|b
decl_stmt|,
modifier|*
name|a
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|QTREE
modifier|*
name|temp
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|ckvar
parameter_list|()
function_decl|;
name|a
operator|=
name|node
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FINDLINKS:"
argument_list|)
expr_stmt|;
name|nodepr
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|sym
operator|.
name|type
operator|==
name|QLEND
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|findlinks
argument_list|(
name|a
operator|->
name|right
argument_list|,
name|selv
argument_list|,
name|linkv
argument_list|,
name|linkmap
argument_list|)
expr_stmt|;
comment|/* 	** This mess is looking for a clause of the form: 	**		EQ 	**	Var		Var 	**	linkv		selv 	** Where the VARS can be in either order 	*/
if|if
condition|(
operator|(
name|b
operator|=
name|a
operator|->
name|left
operator|)
operator|->
name|sym
operator|.
name|type
operator|!=
name|BOP
operator|||
name|b
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|!=
name|opEQ
operator|||
name|b
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|!=
name|VAR
operator|||
name|b
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|VAR
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|a
operator|=
name|ckvar
argument_list|(
name|b
operator|->
name|left
argument_list|)
expr_stmt|;
name|b
operator|=
name|ckvar
argument_list|(
name|b
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|==
name|linkv
condition|)
block|{
name|temp
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|!=
name|linkv
operator|||
operator|(
name|selv
operator|>=
literal|0
operator|&&
name|b
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|!=
name|selv
operator|)
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|linkmap
index|[
name|a
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"found:attno=%d\n"
argument_list|,
name|a
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Rangrf -- reformat the variable "var" if it is cost effective. ** **	Rangrf does the actual work of reformat. If the relation is **	already keyed usefully then rangrf does nothing. **	Otherwise rangrf is split into two decisions: **	A user relation must first be projected and then modified; **	a _SYS relation can be modified directly. ** **	It may be cost effective to just project a user relation. */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rangrf
argument_list|(
argument|var
argument_list|,
argument|substvar
argument_list|,
argument|sq
argument_list|,
argument|buf
argument_list|,
argument|linkmap
argument_list|,
argument|tree
argument_list|,
argument|locrang
argument_list|)
end_macro

begin_decl_stmt
name|int
name|var
decl_stmt|,
name|substvar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|sq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|linkmap
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locrang
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|rang_tab
modifier|*
name|r
decl_stmt|,
modifier|*
name|rs
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|char
name|nums
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|newwid
decl_stmt|;
name|QTREE
modifier|*
name|pq
decl_stmt|;
name|long
name|npages
decl_stmt|,
name|newpages
decl_stmt|;
name|long
name|origcost
decl_stmt|,
name|modcost
decl_stmt|,
name|projcost
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rangename
parameter_list|()
function_decl|;
specifier|extern
name|long
name|rel_pages
argument_list|()
decl_stmt|,
name|hashcost
argument_list|()
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|makroot
parameter_list|()
function_decl|;
specifier|extern
name|DESC
modifier|*
name|openr1
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
modifier|*
name|mksqlist
parameter_list|()
function_decl|;
name|r
operator|=
operator|&
name|De
operator|.
name|de_rangev
index|[
name|var
index|]
expr_stmt|;
name|rs
operator|=
operator|&
name|De
operator|.
name|de_rangev
index|[
name|substvar
index|]
expr_stmt|;
name|npages
operator|=
name|rel_pages
argument_list|(
name|r
operator|->
name|rtcnt
argument_list|,
name|r
operator|->
name|rtwid
argument_list|)
expr_stmt|;
comment|/* calculate original cost of substitution */
name|origcost
operator|=
name|rs
operator|->
name|rtcnt
operator|*
name|npages
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"eval of mod for var %d. orig cost=%ld\n"
argument_list|,
name|var
argument_list|,
name|origcost
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if relation is already keyed usefully, just return */
if|if
condition|(
name|i
operator|=
name|ckpkey
argument_list|(
name|linkmap
argument_list|,
name|var
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"already keyed ok %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* if this is a primary relation, a projection must be done 	** before any modify can be performed */
if|if
condition|(
operator|!
name|rnum_temp
argument_list|(
name|r
operator|->
name|relnum
argument_list|)
condition|)
block|{
comment|/* evaluation for primary, user relation */
comment|/* to save some time, don't evaluate if origcost is very small */
if|if
condition|(
name|origcost
operator|<
name|OVHDP
operator|+
literal|1
operator|+
name|npages
condition|)
return|return;
name|j
operator|=
name|markbuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* build a projection tree but don't actually create the projection */
name|pq
operator|=
name|makroot
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|dfind
argument_list|(
name|sq
argument_list|,
name|buf
argument_list|,
name|mksqlist
argument_list|(
name|pq
argument_list|,
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|newwid
operator|=
name|findwid
argument_list|(
name|pq
argument_list|)
expr_stmt|;
name|newpages
operator|=
name|rel_pages
argument_list|(
name|r
operator|->
name|rtcnt
argument_list|,
name|newwid
argument_list|)
expr_stmt|;
comment|/* 		** Calculate cost of projection + new cost of substitution 		** projcost = readoldpages + writenewpages + runquery + overhead 		*/
name|projcost
operator|=
name|npages
operator|+
name|newpages
operator|+
name|rs
operator|->
name|rtcnt
operator|*
name|newpages
operator|+
name|OVHDP
expr_stmt|;
comment|/*  CALCULATE COST OF MODIFY = COST OF PROJECTION + COST OF MODIFY 		 *  	AND NEW COST OF SUBSTITUTION AFTER MODIFY    */
name|modcost
operator|=
operator|(
name|npages
operator|+
name|newpages
operator|)
operator|+
name|hashcost
argument_list|(
name|newpages
argument_list|)
operator|+
name|rs
operator|->
name|rtcnt
operator|+
name|OVHDP
operator|+
name|OVHDM
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"primary rel: proj cost=%ld\t"
argument_list|,
name|projcost
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mod cost=%ld\n"
argument_list|,
name|modcost
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|origcost
operator|<=
name|modcost
condition|)
if|if
condition|(
name|origcost
operator|<=
name|projcost
condition|)
block|{
name|freebuf
argument_list|(
name|buf
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"doing projection\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* i will be TRUE if the proj was aborted */
name|i
operator|=
name|primrf
argument_list|(
name|var
argument_list|,
name|pq
argument_list|,
name|locrang
argument_list|)
expr_stmt|;
name|freebuf
argument_list|(
name|buf
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|projcost
operator|<=
name|modcost
operator|)
operator|||
name|i
condition|)
return|return;
block|}
comment|/*  IF THIS IS A TEMPORARY RELATION, A MODIFY CAN BE DONE DIRECTLY  */
else|else
block|{
comment|/*  CALCULATE MODIFY COST (which does not include a projection) 		 *  AND NEW COST OF SUBSTITUTION				  */
name|modcost
operator|=
name|hashcost
argument_list|(
name|npages
argument_list|)
operator|+
name|rs
operator|->
name|rtcnt
operator|+
name|OVHDM
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"temp rel: mod cost=%ld\n"
argument_list|,
name|modcost
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|origcost
operator|<=
name|modcost
condition|)
return|return;
block|}
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"doing modify\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initp
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|rangename
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"hash"
argument_list|)
expr_stmt|;
comment|/* modify to hash */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"num"
argument_list|)
expr_stmt|;
comment|/* passing domain numbers - not names */
name|nums
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXDOM
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|linkmap
index|[
name|j
index|]
condition|)
block|{
operator|*
name|nums
operator|=
name|j
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|nums
argument_list|)
expr_stmt|;
block|}
comment|/* fill relation completely */
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"fillfactor"
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"100"
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"minpages"
argument_list|)
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|closer1
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|call_dbu
argument_list|(
name|mdMODIFY
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* re-open modified range to get accurate descriptor */
name|openr1
argument_list|(
name|var
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Primrf -- Replace a user relation with a projection of the needed domains. ** **	Primrf retrieves into a temporary relation, the domains **	specified by the "pq" tree. The range table is updated to **	reflect the new range. ** **	In fact a projection is not an accurate way to describe what **	happens. In order to avoid changing any attribute numbers in **	the query, the needed domains are projected and the domains **	inbetween are created as type "c0". This way they occupy **	no space and the attribute numbering is unchanged. Of course, **	any attributes beyond the last one needed are simply discarded. ** **	In previous versions attempts were made to project only the needed **	domains and to renumber the query tree. This proved to be very **	expensive and difficult and was not always as optimal as this **	method. ** **	The routines newquery() and endquery() will undo the effects **	of primrf and restore the range table back to its original state. */
end_comment

begin_macro
name|primrf
argument_list|(
argument|var
argument_list|,
argument|pq
argument_list|,
argument|locrang
argument_list|)
end_macro

begin_decl_stmt
name|int
name|var
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|pq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|locrang
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|maxresno
decl_stmt|,
name|rnum
decl_stmt|;
name|QTREE
modifier|*
name|node1
index|[
name|MAXDOM
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|node2
index|[
name|MAXDOM
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|czero
index|[
name|QT_HDR_SIZ
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|resdomnode
argument_list|)
index|]
decl_stmt|;
comment|/* a dummy resdom */
specifier|extern
name|DESC
modifier|*
name|openr1
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rnum_convert
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PRIMRF:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* renumber RESDOMs to match their VARs */
for|for
control|(
name|q
operator|=
name|pq
operator|->
name|left
init|;
name|q
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|q
operator|=
name|q
operator|->
name|left
control|)
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|=
name|q
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
expr_stmt|;
comment|/* form list of RESDOMs from outermost inward */
name|node1
index|[
name|lnode
argument_list|(
name|pq
operator|->
name|left
argument_list|,
name|node1
argument_list|,
literal|0
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
comment|/* form a dummy RESDOM with type CHAR and length 0 */
name|q
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|czero
expr_stmt|;
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resfrmt
operator|=
name|CHAR
expr_stmt|;
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resfrml
operator|=
literal|0
expr_stmt|;
comment|/* zero node2 */
for|for
control|(
name|np
operator|=
name|node2
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXDOM
operator|+
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|np
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* sort RESDOMs into node2 */
name|maxresno
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|node1
init|;
name|q
operator|=
operator|*
name|np
operator|++
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* abort. Tid is referenced */
if|if
condition|(
name|i
operator|>
name|maxresno
condition|)
name|maxresno
operator|=
name|i
expr_stmt|;
name|node2
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|q
expr_stmt|;
block|}
comment|/* fill missing RESDOMs with czero */
for|for
control|(
name|np
operator|=
name|node2
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxresno
condition|;
name|i
operator|++
operator|,
name|np
operator|++
control|)
if|if
condition|(
operator|*
name|np
operator|==
literal|0
condition|)
operator|*
name|np
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|czero
expr_stmt|;
comment|/* set up params for the create */
name|initp
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
comment|/* initial relstat field */
name|rnum
operator|=
name|rnum_alloc
argument_list|()
expr_stmt|;
name|setp
argument_list|(
name|PV_STR
argument_list|,
name|rnum_convert
argument_list|(
name|rnum
argument_list|)
argument_list|)
expr_stmt|;
name|domnam
argument_list|(
name|node2
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
name|call_dbu
argument_list|(
name|mdCREATE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* now run projection */
name|i
operator|=
name|var
expr_stmt|;
name|execsq1
argument_list|(
name|pq
argument_list|,
name|i
argument_list|,
name|rnum
argument_list|)
expr_stmt|;
name|new_range
argument_list|(
name|i
argument_list|,
name|rnum
argument_list|)
expr_stmt|;
comment|/* save the name of the new relation */
name|savrang
argument_list|(
name|locrang
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|openr1
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Ckpkey -- determine if a relation is already keyed usefully. ** **	Ckpkey gets the key structure from paramd() and compares **	it to the linkmap. If the relation is ISAM and the first keyed **	domain is in linkmap, or if it is HASH and all keyed domains **	are in the linkmap, then ckpkey() returns>0, else **	ckpkey looks for secondary indexes which are usable. **	if none, then ckpkey() returns 0. ** **	The value returned is an estimate of the number of **	pages which must be read to satisfy a query given **	equality clauses on the linkmap domains and the **	structure of the relation. The (crude) estimates are: **		hash	1 page **		isam	2 pages **		hash sec index	2 pages **		isam sec index	3 pages */
end_comment

begin_macro
name|ckpkey
argument_list|(
argument|linkmap
argument_list|,
argument|var
argument_list|)
end_macro

begin_decl_stmt
name|char
name|linkmap
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|index
name|itup
decl_stmt|;
name|struct
name|accessparam
name|ap
decl_stmt|;
name|TID
name|lotid
decl_stmt|,
name|hitid
decl_stmt|;
specifier|extern
name|DESC
modifier|*
name|readopen
argument_list|()
decl_stmt|,
modifier|*
name|openr1
argument_list|()
decl_stmt|,
name|Inddes
decl_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|11
argument_list|)
condition|)
name|printf
argument_list|(
literal|"CKPKEY:%s\n"
argument_list|,
name|rangename
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if relation is an unindexed heap, then it cannot be keyed usefully */
name|d
operator|=
name|openr1
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|reldum
operator|.
name|relspec
operator|!=
name|M_HEAP
operator|||
name|d
operator|->
name|reldum
operator|.
name|relindxd
operator|>
literal|0
condition|)
block|{
name|d
operator|=
name|readopen
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* open relation if it hasn't been already */
name|paramd
argument_list|(
name|d
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckpkey1
argument_list|(
name|linkmap
argument_list|,
operator|&
name|ap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ap
operator|.
name|mode
operator|==
name|EXACTKEY
condition|?
literal|1
else|:
literal|2
operator|)
return|;
comment|/* success */
if|if
condition|(
name|d
operator|->
name|reldum
operator|.
name|relindxd
operator|>
literal|0
condition|)
block|{
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|IRELIDP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Inddes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"ckpkey:find %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|itup
operator|.
name|irelidp
argument_list|,
name|d
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
condition|)
continue|continue;
name|parami
argument_list|(
operator|&
name|itup
argument_list|,
operator|&
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ckpkey1
argument_list|(
name|linkmap
argument_list|,
operator|&
name|ap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ap
operator|.
name|mode
operator|==
name|EXACTKEY
condition|?
literal|2
else|:
literal|3
operator|)
return|;
comment|/* success */
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure. no useful structure */
block|}
end_block

begin_macro
name|ckpkey1
argument_list|(
argument|linkmap
argument_list|,
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|char
name|linkmap
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|accessparam
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|anykey
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|mode
operator|==
name|NOKEY
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|anykey
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|k
operator|=
name|ap
operator|->
name|keydno
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|linkmap
index|[
name|k
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|mode
operator|==
name|EXACTKEY
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
break|break;
block|}
name|anykey
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|anykey
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* ** Findwid -- scan the target list of the projection tree **	to determine the resultant tuple size. ** **	Return: **		Size of projected tuple. */
end_comment

begin_macro
name|findwid
argument_list|(
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|nod
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|wid
decl_stmt|;
name|wid
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|tree
expr_stmt|;
for|for
control|(
name|nod
operator|=
name|t
operator|->
name|left
init|;
name|nod
operator|&&
name|nod
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|;
name|nod
operator|=
name|nod
operator|->
name|left
control|)
block|{
name|wid
operator|+=
name|nod
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varfrml
operator|&
literal|0377
expr_stmt|;
block|}
return|return
operator|(
name|wid
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  HASHCOST -- determine cost to modify to hash ** **	Estimates the cost to modify the relation to hash. **	The estimate is crude since it assumes that there **	are no duplicates and that a "unix" page will be **	the same size as an "ingres" page. ** **	The cost is based on the parameters which signify **	the size of the in-core sort buffer and the n-way **	merge sort plus the cost to read the sorted file **	and write the new relation twice (that's the was it works!). ** **	Parameters: **		npages - the number of pages (estimate) which the **				relation currently occupies. ** **	Returns: **		the cost to hash the relation. ** **	Side Effects: **		none ** **	Called By: **		rangrf */
end_comment

begin_define
define|#
directive|define
name|COREBUFSIZE
value|32767 / PGSIZE
end_define

begin_define
define|#
directive|define
name|MERGESIZE
value|7
end_define

begin_function
name|long
name|hashcost
parameter_list|(
name|npages
parameter_list|)
name|long
name|npages
decl_stmt|;
block|{
name|long
name|sortpages
decl_stmt|,
name|total
decl_stmt|;
specifier|register
name|int
name|nfiles
decl_stmt|;
name|nfiles
operator|=
name|npages
operator|/
name|COREBUFSIZE
expr_stmt|;
name|sortpages
operator|=
literal|2
operator|*
name|npages
expr_stmt|;
while|while
condition|(
name|nfiles
operator|>
literal|1
condition|)
block|{
name|nfiles
operator|=
operator|(
name|nfiles
operator|+
name|MERGESIZE
operator|-
literal|1
operator|)
operator|/
name|MERGESIZE
expr_stmt|;
name|sortpages
operator|+=
literal|2
operator|*
name|npages
expr_stmt|;
block|}
name|total
operator|=
name|sortpages
operator|+
name|npages
operator|+
name|npages
operator|+
name|npages
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|39
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"hashcost is %ld\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

end_unit

