begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|"globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)aggregate.c
literal|7.2
literal|3
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	AGGREGATE - replace aggregates with their values ** **	Aggregate attempts to optimize aggregate processing **	wherever possible. It replaces aggregates with their **	values, and links aggregate functions which have **	identical by-lists together. ** **	Note that for the sake of this code, A "prime" **	aggregate is one in which duplicates are removed. **	These are COUNTU, SUMU, and AVGU. ** **	Aggregate first forms a list of all aggregates in **	the order they should be processed. ** **	For each aggregate, it looks at all other aggregates **	to see if there are two simple aggregates **	or if there is another aggregate funtion with the **	same by-list. ** **	An attempt is made to run **	as many aggregates as possible at once. This can be **	done only if two or more aggregates have the same **	qualifications and in the case of aggregate functions, **	they must have identical by-lists. **	Even then, certain combinations **	of aggregates cannot occure together. The list is **	itemized later in the code. ** **	Aggregate calls BYEVAL or AGEVAL to actually process **	aggregate functions or aggregates respectively. ** **	Trace Flags: **		40 */
end_comment

begin_macro
name|aggregate
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|agglist
name|alist
index|[
name|MAXAGG
operator|+
literal|1
index|]
decl_stmt|;
name|QTREE
modifier|*
name|rlist
index|[
name|MAXAGG
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|agglist
modifier|*
name|al
decl_stmt|,
modifier|*
name|al1
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|agg
decl_stmt|,
modifier|*
name|aop1
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|QTREE
modifier|*
name|aop
decl_stmt|,
modifier|*
name|agg1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|simple_agg
decl_stmt|,
name|varmap
decl_stmt|;
name|int
name|attcnt
decl_stmt|,
name|anyagg
decl_stmt|,
name|attoff
decl_stmt|,
name|twidth
decl_stmt|;
name|QTREE
modifier|*
name|makavar
argument_list|()
decl_stmt|,
modifier|*
name|agspace
argument_list|()
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rangename
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|ageval
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|byeval
parameter_list|()
function_decl|;
name|al
operator|=
name|alist
expr_stmt|;
name|De
operator|.
name|de_aggnext
operator|=
name|al
expr_stmt|;
name|De
operator|.
name|de_agglim
operator|=
operator|&
name|al
index|[
name|MAXAGG
index|]
expr_stmt|;
name|findagg
argument_list|(
operator|&
name|root
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|/* generate list of all aggregates */
name|De
operator|.
name|de_aggnext
operator|->
name|agpoint
operator|=
literal|0
expr_stmt|;
comment|/* mark end of the list */
name|anyagg
operator|=
literal|0
expr_stmt|;
name|varmap
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
expr_stmt|;
comment|/* process each aggregate */
for|for
control|(
init|;
name|agg
operator|=
name|al
operator|->
name|agpoint
condition|;
name|al
operator|++
control|)
block|{
comment|/* is this still an aggregate? */
if|if
condition|(
name|agg
operator|->
name|sym
operator|.
name|type
operator|!=
name|AGHEAD
condition|)
continue|continue;
name|mapvar
argument_list|(
name|agg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* map the aggregate tree */
name|anyagg
operator|++
expr_stmt|;
name|De
operator|.
name|de_sourcevar
operator|=
name|bitpos
argument_list|(
name|agg
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|agg
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"De.de_sourcevar=%d,rel=%s\n"
argument_list|,
name|De
operator|.
name|de_sourcevar
argument_list|,
name|rangename
argument_list|(
name|De
operator|.
name|de_sourcevar
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|simple_agg
operator|=
operator|(
name|agg
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|AOP
operator|)
expr_stmt|;
comment|/* TRUE if no bylist */
name|aop
operator|=
name|agg
operator|->
name|left
expr_stmt|;
comment|/* assume it was TRUE */
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|simple_agg
condition|?
literal|"agg"
else|:
literal|"agg-func"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|simple_agg
condition|)
block|{
comment|/* simple aggregate */
name|rlist
index|[
literal|0
index|]
operator|=
name|agspace
argument_list|(
name|aop
argument_list|)
expr_stmt|;
name|twidth
operator|=
name|aop
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opfrml
operator|&
name|I1MASK
expr_stmt|;
comment|/* init width to the width of the aggregate */
block|}
else|else
block|{
name|attoff
operator|=
name|agg
operator|->
name|left
operator|->
name|left
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|+
literal|2
expr_stmt|;
name|aop
operator|=
name|aop
operator|->
name|right
expr_stmt|;
comment|/* find the AOP node */
comment|/* assign  new source variable for aggregate */
name|al
operator|->
name|agvarno
operator|=
name|getrange
argument_list|(
operator|&
name|varmap
argument_list|)
expr_stmt|;
comment|/* compute width of bylist + count field */
name|twidth
operator|=
name|findwid
argument_list|(
name|agg
operator|->
name|left
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* make sure the aggregate does not exceed max dimensions */
if|if
condition|(
name|chkwidth
argument_list|(
name|aop
argument_list|,
operator|&
name|twidth
argument_list|,
name|attoff
argument_list|)
condition|)
name|derror
argument_list|(
name|AGFTOBIG
argument_list|)
expr_stmt|;
block|}
name|attcnt
operator|=
literal|1
expr_stmt|;
comment|/* one aggregate so far */
comment|/* look for another identical aggregate */
for|for
control|(
name|al1
operator|=
name|al
operator|+
literal|1
init|;
name|agg1
operator|=
name|al1
operator|->
name|agpoint
condition|;
name|al1
operator|++
control|)
block|{
comment|/* if agg is nested inside agg1 then ignore it */
if|if
condition|(
name|al
operator|->
name|agfather
operator|==
name|agg1
operator|||
name|agg1
operator|->
name|sym
operator|.
name|type
operator|!=
name|AGHEAD
condition|)
block|{
continue|continue;
block|}
comment|/* split aggs and agg-func apart */
comment|/* check for identical aggregate */
if|if
condition|(
name|simple_agg
condition|)
block|{
name|aop1
operator|=
name|agg1
operator|->
name|left
expr_stmt|;
comment|/* find AOP node */
if|if
condition|(
name|aop1
operator|->
name|sym
operator|.
name|type
operator|!=
name|AOP
condition|)
continue|continue;
comment|/* not a simple agg */
comment|/* make sure they can be run together */
if|if
condition|(
name|checkagg
argument_list|(
name|agg
argument_list|,
name|aop
argument_list|,
name|agg1
argument_list|,
name|aop1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|i
operator|=
name|sameagg
argument_list|(
name|agg
argument_list|,
name|aop1
argument_list|,
name|attcnt
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* found identical aggregate to rlist[i] */
name|r
operator|=
name|rlist
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* put this agg in with the others */
comment|/* first make sure it won't exceed tuple length */
if|if
condition|(
name|chkwidth
argument_list|(
name|aop1
argument_list|,
operator|&
name|twidth
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* can't be included */
name|r
operator|=
name|rlist
index|[
name|attcnt
operator|++
index|]
operator|=
name|agspace
argument_list|(
name|aop1
argument_list|)
expr_stmt|;
comment|/* connect into tree */
name|aop1
operator|->
name|left
operator|=
name|agg
operator|->
name|left
expr_stmt|;
name|agg
operator|->
name|left
operator|=
name|aop1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* aggregate function */
if|if
condition|(
operator|!
name|sameafcn
argument_list|(
name|agg
operator|->
name|left
operator|->
name|left
argument_list|,
name|agg1
operator|->
name|left
operator|->
name|left
argument_list|)
condition|)
continue|continue;
name|aop1
operator|=
name|agg1
operator|->
name|left
operator|->
name|right
expr_stmt|;
comment|/* find AOP */
if|if
condition|(
name|checkagg
argument_list|(
name|agg
argument_list|,
name|aop
argument_list|,
name|agg1
argument_list|,
name|aop1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* same by-lists but they can't be run together */
continue|continue;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|sameagg
argument_list|(
name|agg
argument_list|,
name|aop1
argument_list|,
name|attcnt
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* make sure there is room */
if|if
condition|(
name|chkwidth
argument_list|(
name|aop1
argument_list|,
operator|&
name|twidth
argument_list|,
name|attcnt
operator|+
name|attoff
argument_list|)
condition|)
continue|continue;
comment|/* add aggregate into tree */
name|i
operator|=
name|attcnt
operator|++
expr_stmt|;
name|aop1
operator|->
name|left
operator|=
name|agg
operator|->
name|left
operator|->
name|right
expr_stmt|;
name|agg
operator|->
name|left
operator|->
name|right
operator|=
name|aop1
expr_stmt|;
block|}
name|r
operator|=
name|makavar
argument_list|(
name|aop1
argument_list|,
name|al
operator|->
name|agvarno
argument_list|,
name|i
operator|+
name|attoff
argument_list|)
expr_stmt|;
block|}
comment|/* replace aggregate in original tree with its value */
operator|*
operator|(
name|al1
operator|->
name|father
operator|)
operator|=
name|r
expr_stmt|;
comment|/* remove aggregate from local list */
name|agg1
operator|->
name|sym
operator|.
name|type
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"including aghead %x\n"
argument_list|,
name|agg1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* process aggregate */
if|if
condition|(
name|simple_agg
condition|)
block|{
name|rlist
index|[
name|attcnt
index|]
operator|=
literal|0
expr_stmt|;
name|ageval
argument_list|(
name|agg
argument_list|,
name|rlist
argument_list|)
expr_stmt|;
comment|/* pass tree and result list */
name|r
operator|=
name|rlist
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|opt_bylist
argument_list|(
name|alist
argument_list|,
name|agg
argument_list|)
expr_stmt|;
name|byeval
argument_list|(
name|al
operator|->
name|agfather
argument_list|,
name|agg
argument_list|,
name|al
operator|->
name|agvarno
argument_list|)
expr_stmt|;
name|r
operator|=
name|makavar
argument_list|(
name|aop
argument_list|,
name|al
operator|->
name|agvarno
argument_list|,
name|attoff
argument_list|)
expr_stmt|;
block|}
comment|/* 		** Link result into tree. al->father hold the address 		**&(tree->left) or&(tree->right). 		*/
operator|*
operator|(
name|al
operator|->
name|father
operator|)
operator|=
name|r
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"agg value\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
operator|*
operator|(
name|al
operator|->
name|father
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|anyagg
condition|)
block|{
name|opt_bylist
argument_list|(
name|alist
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|mapvar
argument_list|(
name|root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* remap main tree */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	findagg builds a list of all aggregates **	in the tree. It finds them by leftmost **	innermost first. ** **	The parameters represent: **		nodep:	the address of the node pointing to you **				eg.&(tree->left) or&(tree->right) **		agf:	the root node. or if we are inside **			a nested aggregate, the AGHEAD node */
end_comment

begin_macro
name|findagg
argument_list|(
argument|nodep
argument_list|,
argument|agf
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
modifier|*
name|nodep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|agf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|,
modifier|*
name|f
decl_stmt|;
specifier|register
name|struct
name|agglist
modifier|*
name|list
decl_stmt|;
name|int
name|agg
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
operator|*
name|nodep
operator|)
operator|==
name|NULL
condition|)
return|return;
name|f
operator|=
name|agf
expr_stmt|;
if|if
condition|(
name|agg
operator|=
operator|(
name|q
operator|->
name|sym
operator|.
name|type
operator|==
name|AGHEAD
operator|)
condition|)
name|f
operator|=
name|q
expr_stmt|;
comment|/* this aggregate is now the father root */
comment|/* find all aggregates below */
name|findagg
argument_list|(
operator|&
operator|(
name|q
operator|->
name|left
operator|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|findagg
argument_list|(
operator|&
operator|(
name|q
operator|->
name|right
operator|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* if this is an aggregate, put it on the list */
if|if
condition|(
name|agg
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|de_aggnext
operator|>=
name|De
operator|.
name|de_agglim
condition|)
name|derror
argument_list|(
name|TOOMANYAGGS
argument_list|)
expr_stmt|;
name|list
operator|=
name|De
operator|.
name|de_aggnext
expr_stmt|;
name|list
operator|->
name|father
operator|=
name|nodep
expr_stmt|;
name|list
operator|->
name|agpoint
operator|=
name|q
expr_stmt|;
name|list
operator|->
name|agfather
operator|=
name|agf
expr_stmt|;
name|De
operator|.
name|de_aggnext
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Agspace allocates space for the result of **	a simple aggregate. */
end_comment

begin_function
name|QTREE
modifier|*
name|agspace
parameter_list|(
name|aop
parameter_list|)
name|QTREE
modifier|*
name|aop
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|a
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
name|a
operator|=
name|aop
expr_stmt|;
name|length
operator|=
name|a
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opfrml
operator|&
name|I1MASK
expr_stmt|;
name|r
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|need
argument_list|(
name|De
operator|.
name|de_qbuf
argument_list|,
name|length
operator|+
name|QT_HDR_SIZ
argument_list|)
expr_stmt|;
name|r
operator|->
name|left
operator|=
name|r
operator|->
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sym
operator|.
name|type
operator|=
name|a
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opfrmt
expr_stmt|;
name|r
operator|->
name|sym
operator|.
name|len
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ** Chkwidth -- make sure that the inclusion of another aggregate will **	not exceed the system limit. This means that the total width **	cannot exceed MAXTUP and the number of domains cannot exceed MAXDOM-1 */
end_comment

begin_macro
name|chkwidth
argument_list|(
argument|aop
argument_list|,
argument|widthp
argument_list|,
argument|domno
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|aop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|widthp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|domno
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|width
decl_stmt|;
name|width
operator|=
operator|*
name|widthp
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"agg width %d,dom %d\n"
argument_list|,
name|width
argument_list|,
name|domno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|width
operator|+=
operator|(
name|aop
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opfrml
operator|&
name|I1MASK
operator|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|MAXTUP
operator|||
name|domno
operator|>
name|MAXDOM
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|widthp
operator|=
name|width
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Determine whether an aggregate is prime **	or a don't care aggregate. Returns TRUE **	if COUNTU,SUMU,AVGU,MIN,MAX,ANY. **	Returns false if COUNT,SUM,AVG. */
end_comment

begin_macro
name|cprime
argument_list|(
argument|aop
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|aop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|aop
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
condition|)
block|{
case|case
name|opCOUNT
case|:
case|case
name|opSUM
case|:
case|case
name|opAVG
case|:
name|i
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Getrange find a free slot in the range table **	for an aggregate function. ** **	If there are no free slots,derror is called */
end_comment

begin_macro
name|getrange
argument_list|(
argument|varmap
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|varmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|map
decl_stmt|,
name|bit
decl_stmt|;
name|map
operator|=
operator|*
name|varmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
block|{
comment|/* if slot is used, continue */
if|if
condition|(
operator|(
name|bit
operator|=
literal|1
operator|<<
name|i
operator|)
operator|&
name|map
condition|)
continue|continue;
name|map
operator||=
name|bit
expr_stmt|;
comment|/* "or" bit into the map */
operator|*
name|varmap
operator|=
name|map
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Assn var %d, map %o\n"
argument_list|,
name|i
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|i
operator|)
return|;
block|}
name|derror
argument_list|(
name|NODESCAG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|checkagg
argument_list|(
argument|aghead1
argument_list|,
argument|aop1
argument_list|,
argument|aghead2
argument_list|,
argument|aop2
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|aghead1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|aop1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|aghead2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|aop2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|aop_1
decl_stmt|,
modifier|*
name|aop_2
decl_stmt|,
modifier|*
name|agg1
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* two aggregate functions can be run together 	** according to the following table: 	** 	**		prime	!prime	don't care 	** 	** prime	afcn?	never	afcn? 	** !prime	never	always	always 	** don't care	afcn?	always	always 	** 	** don't care includes: ANY, MIN, MAX 	** afcn? means only if a-fcn's are identical 	*/
name|aop_1
operator|=
name|aop1
expr_stmt|;
name|aop_2
operator|=
name|aop2
expr_stmt|;
name|agg1
operator|=
name|aghead1
expr_stmt|;
if|if
condition|(
operator|!
name|prime
argument_list|(
name|aop_1
argument_list|)
operator|&&
operator|!
name|prime
argument_list|(
name|aop_2
argument_list|)
condition|)
name|ok
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|sameafcn
argument_list|(
name|aop_1
operator|->
name|right
argument_list|,
name|aop_2
operator|->
name|right
argument_list|)
condition|)
name|ok
operator|=
name|cprime
argument_list|(
name|aop_1
argument_list|)
operator|&&
name|cprime
argument_list|(
name|aop_2
argument_list|)
expr_stmt|;
else|else
name|ok
operator|=
name|FALSE
expr_stmt|;
comment|/* The two aggregates must range over the same variables */
if|if
condition|(
operator|(
name|agg1
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|agg1
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|)
operator|!=
operator|(
name|aghead2
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|aghead2
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
operator|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
comment|/* check the qualifications */
if|if
condition|(
name|ok
condition|)
name|ok
operator|=
name|sameafcn
argument_list|(
name|agg1
operator|->
name|right
argument_list|,
name|aghead2
operator|->
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|ok
operator|)
return|;
block|}
end_block

begin_macro
name|sameagg
argument_list|(
argument|aghead
argument_list|,
argument|newaop
argument_list|,
argument|agg_depth
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|aghead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|newaop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|agg_depth
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|agg
decl_stmt|,
modifier|*
name|newa
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|agg
operator|=
name|aghead
expr_stmt|;
name|newa
operator|=
name|newaop
expr_stmt|;
name|agg
operator|=
name|agg
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|agg
operator|->
name|sym
operator|.
name|type
operator|==
name|BYHEAD
condition|)
name|agg
operator|=
name|agg
operator|->
name|right
expr_stmt|;
comment|/* agg now points to first aggregate */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|agg
condition|;
name|agg
operator|=
name|agg
operator|->
name|left
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|sameafcn
argument_list|(
name|agg
operator|->
name|right
argument_list|,
name|newa
operator|->
name|right
argument_list|)
operator|&&
name|agg
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|==
name|newa
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"found identical aop %x\n"
argument_list|,
name|newa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|agg_depth
operator|-
name|i
operator|)
return|;
block|}
comment|/* no match */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|opt_bylist
argument_list|(
argument|alist
argument_list|,
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|agglist
modifier|*
name|alist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|agglist
modifier|*
name|al
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|agg
decl_stmt|;
specifier|register
name|struct
name|hitlist
modifier|*
name|hl
decl_stmt|;
name|QTREE
modifier|*
modifier|*
name|tpr
decl_stmt|,
modifier|*
name|tree
decl_stmt|,
modifier|*
name|lnodv
index|[
name|MAXDOM
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|hitlist
name|hlist
index|[
literal|30
index|]
decl_stmt|;
name|int
name|anyop
decl_stmt|,
name|i
decl_stmt|,
name|usedmap
decl_stmt|,
name|vars
decl_stmt|,
name|treemap
decl_stmt|;
comment|/* compute bitmap of all possible vars in tree (can include xtra vars) */
name|treemap
operator|=
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|lvarm
operator||
name|root
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rvarm
expr_stmt|;
name|anyop
operator|=
name|FALSE
expr_stmt|;
comment|/* scan the list of aggregates looking for one nested in root */
for|for
control|(
name|al
operator|=
name|alist
init|;
operator|(
name|agg
operator|=
name|al
operator|->
name|agpoint
operator|)
operator|&&
name|agg
operator|!=
name|root
condition|;
name|al
operator|++
control|)
block|{
if|if
condition|(
name|agg
operator|->
name|sym
operator|.
name|type
operator|==
name|AGHEAD
operator|&&
name|agg
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|BYHEAD
operator|&&
name|al
operator|->
name|agfather
operator|==
name|root
condition|)
block|{
comment|/* this aggregate function is nested in root */
comment|/* make sure it has some vars of interest */
if|if
condition|(
operator|(
name|treemap
operator|&
name|varfind
argument_list|(
name|agg
operator|->
name|left
operator|->
name|left
argument_list|,
operator|(
name|QTREE
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"nested agg\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|agg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* form list of bydomains */
name|lnodv
index|[
name|lnode
argument_list|(
name|agg
operator|->
name|left
operator|->
name|left
argument_list|,
name|lnodv
argument_list|,
literal|0
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|usedmap
operator|=
literal|0
expr_stmt|;
name|De
operator|.
name|de_hnext
operator|=
operator|&
name|hlist
index|[
literal|0
index|]
expr_stmt|;
name|De
operator|.
name|de_hlimit
operator|=
operator|&
name|hlist
index|[
literal|30
index|]
expr_stmt|;
comment|/* find all possible replacements */
name|vars
operator|=
name|modtree
argument_list|(
operator|&
name|root
argument_list|,
name|lnodv
argument_list|,
operator|&
name|usedmap
argument_list|)
expr_stmt|;
comment|/* 			** All references to a variable must be replaced 			** in order to use this aggregates by-domains. 			*/
if|if
condition|(
name|usedmap
operator|&&
operator|(
operator|(
name|vars
operator|&
name|usedmap
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Committed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* success. Committ the tree changes */
name|De
operator|.
name|de_hnext
operator|->
name|trepr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|hl
operator|=
operator|&
name|hlist
index|[
literal|0
index|]
init|;
name|tpr
operator|=
name|hl
operator|->
name|trepr
condition|;
name|hl
operator|++
control|)
block|{
comment|/* get bydomain number */
name|i
operator|=
name|hl
operator|->
name|byno
expr_stmt|;
comment|/* get node being replaced */
name|tree
operator|=
operator|*
name|tpr
expr_stmt|;
comment|/* if it is already a var, just change it */
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|type
operator|==
name|VAR
condition|)
block|{
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|=
name|al
operator|->
name|agvarno
expr_stmt|;
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
else|else
operator|*
name|tpr
operator|=
name|makavar
argument_list|(
name|lnodv
index|[
name|i
index|]
argument_list|,
name|al
operator|->
name|agvarno
argument_list|,
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
name|anyop
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"modified tree\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
operator|*
name|tpr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
comment|/* vars is now a map of the variables in the root */
name|treemap
operator|=
name|vars
expr_stmt|;
block|}
block|}
comment|/* if any changes were made, get rid of the unnecessary links */
if|if
condition|(
name|anyop
condition|)
name|chklink
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|modtree
argument_list|(
argument|pnode
argument_list|,
argument|lnodv
argument_list|,
argument|replmap
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
modifier|*
name|pnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|lnodv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|replmap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|tree
decl_stmt|;
specifier|register
name|int
name|vars
decl_stmt|,
name|i
decl_stmt|;
name|QTREE
modifier|*
name|afcn
decl_stmt|;
comment|/* point up current node */
if|if
condition|(
operator|(
name|tree
operator|=
operator|*
name|pnode
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* examine each by-list for match on this subtree */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|afcn
operator|=
name|lnodv
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sameafcn
argument_list|(
name|tree
argument_list|,
name|afcn
operator|->
name|right
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|9
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"potential Jackpot"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|vars
operator|=
name|varfind
argument_list|(
name|tree
argument_list|,
operator|(
name|QTREE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|de_hnext
operator|==
name|De
operator|.
name|de_hlimit
condition|)
return|return
operator|(
name|vars
operator|)
return|;
comment|/* no more room */
comment|/* record what needs to be done */
name|De
operator|.
name|de_hnext
operator|->
name|trepr
operator|=
name|pnode
expr_stmt|;
name|De
operator|.
name|de_hnext
operator|->
name|byno
operator|=
name|i
expr_stmt|;
name|De
operator|.
name|de_hnext
operator|++
expr_stmt|;
operator|*
name|replmap
operator||=
name|vars
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tree
operator|->
name|sym
operator|.
name|type
operator|==
name|VAR
condition|)
return|return
operator|(
literal|01
operator|<<
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|)
return|;
comment|/* try the subtrees */
name|vars
operator|=
name|modtree
argument_list|(
operator|&
operator|(
name|tree
operator|->
name|left
operator|)
argument_list|,
name|lnodv
argument_list|,
name|replmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vars
operator|&
operator|*
name|replmap
operator|)
operator|==
literal|0
condition|)
name|vars
operator||=
name|modtree
argument_list|(
operator|&
operator|(
name|tree
operator|->
name|right
operator|)
argument_list|,
name|lnodv
argument_list|,
name|replmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|vars
operator|)
return|;
block|}
end_block

begin_macro
name|chklink
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|r
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|root
expr_stmt|;
for|for
control|(
name|r
operator|=
name|last
operator|->
name|right
init|;
name|r
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|;
name|r
operator|=
name|r
operator|->
name|right
control|)
block|{
comment|/* if this is an EQ node then check for an unnecessary compare */
if|if
condition|(
operator|(
name|b
operator|=
name|r
operator|->
name|left
operator|)
operator|->
name|sym
operator|.
name|type
operator|==
name|BOP
operator|&&
name|b
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|==
name|opEQ
condition|)
block|{
if|if
condition|(
name|sameafcn
argument_list|(
name|b
operator|->
name|left
argument_list|,
name|b
operator|->
name|right
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xDTR1
if|if
condition|(
name|tTf
argument_list|(
literal|40
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"unnec clause\n"
argument_list|)
expr_stmt|;
name|treepr
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|last
operator|->
name|right
operator|=
name|r
operator|->
name|right
expr_stmt|;
continue|continue;
block|}
block|}
name|last
operator|=
name|r
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|sameafcn
argument_list|(
argument|q1
argument_list|,
argument|q2
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
name|t1
operator|=
name|q1
expr_stmt|;
name|t2
operator|=
name|q2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t1
operator|&&
name|t2
operator|)
condition|)
return|return
operator|(
operator|!
operator|(
name|t1
operator|||
name|t2
operator|)
operator|)
return|;
name|len
operator|=
operator|(
name|t1
operator|->
name|sym
operator|.
name|len
operator|&
literal|0377
operator|)
operator|+
name|SYM_HDR_SIZ
expr_stmt|;
name|type
operator|=
name|t1
operator|->
name|sym
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VAR
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|varnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|AND
condition|)
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|t1
operator|->
name|sym
operator|.
name|type
argument_list|,
operator|&
name|t2
operator|->
name|sym
operator|.
name|type
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|sameafcn
argument_list|(
name|t1
operator|->
name|left
argument_list|,
name|t2
operator|->
name|left
argument_list|)
operator|&&
name|sameafcn
argument_list|(
name|t1
operator|->
name|right
argument_list|,
name|t2
operator|->
name|right
argument_list|)
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	varfind -- find all variables in the tree pointed to by "root". **		Examine all parts of the tree except aggregates. For **		aggregates, ignore simple aggregate and look only **		at the by-lists of aggregate functions. If the aggregate **		is "aghead" then ignore it. There is no reason to look **		at yourself!!!! **		This routine is called by byeval() to determine **		whether to link the aggregate to the root tree. ** **	Curiosity note: since the tree being examined has not been **	processed by decomp yet, ckvar does not need to be called **	since the var could not have been altered. */
end_comment

begin_macro
name|varfind
argument_list|(
argument|root
argument_list|,
argument|aghead
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QTREE
modifier|*
name|aghead
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|tree
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|tree
operator|=
name|root
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|type
operator|=
name|tree
operator|->
name|sym
operator|.
name|type
operator|)
operator|==
name|AGHEAD
condition|)
block|{
comment|/* ignore if it matches aghead */
if|if
condition|(
name|tree
operator|==
name|aghead
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* if this is an aggregate function, look at bylist */
name|tree
operator|=
name|tree
operator|->
name|left
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|tree
operator|->
name|sym
operator|.
name|type
operator|)
operator|!=
name|BYHEAD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|VAR
condition|)
return|return
operator|(
literal|1
operator|<<
name|tree
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
operator|)
return|;
return|return
operator|(
name|varfind
argument_list|(
name|tree
operator|->
name|left
argument_list|,
name|aghead
argument_list|)
operator||
name|varfind
argument_list|(
name|tree
operator|->
name|right
argument_list|,
name|aghead
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

