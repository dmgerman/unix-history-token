begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"../decomp/globs.h"
end_include

begin_include
include|#
directive|include
file|"strategy.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)strategy.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* ** STRATEGY ** **	Attempts to limit access scan to less than the entire De.ov_source **	relation by finding a key which can be used for associative **	access to the De.ov_source reln or an index thereon.  The key is **	constructed from domain-value specifications found in the **	clauses of the qualification list using sub-routine findsimp **	in findsimp.c and other subroutines in file key.c */
end_comment

begin_macro
name|strategy
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|allexact
decl_stmt|;
name|struct
name|accessparam
name|sourceparm
decl_stmt|,
name|indexparm
decl_stmt|;
name|struct
name|index
name|itup
decl_stmt|,
name|rtup
decl_stmt|;
name|struct
name|key
name|lowikey
index|[
name|MAXKEYS
operator|+
literal|1
index|]
decl_stmt|,
name|highikey
index|[
name|MAXKEYS
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
name|DESC
modifier|*
name|openindex
parameter_list|()
function_decl|;
specifier|extern
name|DESC
name|Inddes
decl_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|70
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"STRATEGY\tSource=%.12s\tNewq = %d\n"
argument_list|,
name|De
operator|.
name|ov_source
condition|?
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relid
else|:
literal|"(none)"
argument_list|,
name|De
operator|.
name|de_newq
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|De
operator|.
name|de_newq
condition|)
comment|/* if De.de_newq=TRUE then compute a new strategy */
comment|/* NOTE: This while loop is executed only once */
block|{
name|De
operator|.
name|ov_scanr
operator|=
name|De
operator|.
name|ov_source
expr_stmt|;
if|if
condition|(
operator|!
name|De
operator|.
name|ov_scanr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return immediately if there is no source relation */
name|De
operator|.
name|ov_fmode
operator|=
name|NOKEY
expr_stmt|;
comment|/* assume a find mode with no key */
if|if
condition|(
operator|!
name|De
operator|.
name|ov_qlist
condition|)
break|break;
comment|/* if no qualification then you must scan entire rel */
comment|/* copy structure of source relation into sourceparm */
name|paramd
argument_list|(
name|De
operator|.
name|ov_source
argument_list|,
operator|&
name|sourceparm
argument_list|)
expr_stmt|;
comment|/* if source is unkeyed and has no sec index then give up */
if|if
condition|(
name|sourceparm
operator|.
name|mode
operator|==
name|NOKEY
operator|&&
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relindxd
operator|<=
literal|0
condition|)
break|break;
comment|/* find all simple clauses if any */
if|if
condition|(
operator|!
name|findsimps
argument_list|()
condition|)
break|break;
comment|/* break if there are no simple clauses */
comment|/* Four steps are now performed to try and find a key. 		** First if the relation is hashed then an exact key is search for 		** 		** Second if there are secondary indexes, then a search is made 		** for an exact key. If that fails then a  check is made for 		** a range key. The result of the rangekey check is saved. 		** 		** Third if the relation is an ISAM a check is  made for 		** an exact key or a range key. 		** 		** Fourth if there is a secondary index, then if step two 		** found a key, that key is used. 		** 		**  Lastly, give up and scan the  entire relation 		*/
comment|/* step one. Try to find exact key on primary */
if|if
condition|(
name|exactkey
argument_list|(
operator|&
name|sourceparm
argument_list|,
name|De
operator|.
name|ov_lkey_struct
argument_list|)
condition|)
block|{
name|De
operator|.
name|ov_fmode
operator|=
name|EXACTKEY
expr_stmt|;
break|break;
block|}
comment|/* step two. If there is an index, try to find an exactkey on one of them */
if|if
condition|(
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relindxd
condition|)
block|{
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|itup
argument_list|,
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|IRELIDP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|itup
argument_list|,
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Inddes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|De
operator|.
name|ov_lotid
argument_list|,
operator|&
name|De
operator|.
name|ov_hitid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"strategy:find indexes %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|De
operator|.
name|ov_lotid
argument_list|,
operator|&
name|De
operator|.
name|ov_hitid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|,
name|NXTTUP
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|70
argument_list|,
literal|3
argument_list|)
condition|)
name|printup
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|itup
operator|.
name|irelidp
argument_list|,
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
argument_list|)
operator|||
operator|!
name|bequal
argument_list|(
name|itup
operator|.
name|iownerp
argument_list|,
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
continue|continue;
name|parami
argument_list|(
operator|&
name|itup
argument_list|,
operator|&
name|indexparm
argument_list|)
expr_stmt|;
if|if
condition|(
name|exactkey
argument_list|(
operator|&
name|indexparm
argument_list|,
name|De
operator|.
name|ov_lkey_struct
argument_list|)
condition|)
block|{
name|De
operator|.
name|ov_fmode
operator|=
name|EXACTKEY
expr_stmt|;
name|d
operator|=
name|openindex
argument_list|(
name|itup
operator|.
name|irelidi
argument_list|)
expr_stmt|;
comment|/* temp check for 6.0 index */
if|if
condition|(
operator|(
name|int
operator|)
name|d
operator|->
name|reldum
operator|.
name|relindxd
operator|==
operator|-
literal|1
condition|)
name|ov_err
argument_list|(
name|BADSECINDX
argument_list|)
expr_stmt|;
name|De
operator|.
name|ov_scanr
operator|=
name|d
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|==
name|LRANGEKEY
condition|)
continue|continue;
comment|/* a range key on a s.i. has already been found */
if|if
condition|(
name|allexact
operator|=
name|rangekey
argument_list|(
operator|&
name|indexparm
argument_list|,
name|lowikey
argument_list|,
name|highikey
argument_list|)
condition|)
block|{
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|itup
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rtup
argument_list|,
sizeof|sizeof
name|itup
argument_list|)
expr_stmt|;
comment|/* save tuple */
name|De
operator|.
name|ov_fmode
operator|=
name|LRANGEKEY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"stragery:bad get from index-rel %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If an exactkey on a secondary index was found, look no more. */
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|==
name|EXACTKEY
condition|)
break|break;
block|}
comment|/* step three. Look for a range key on primary */
if|if
condition|(
name|i
operator|=
name|rangekey
argument_list|(
operator|&
name|sourceparm
argument_list|,
name|De
operator|.
name|ov_lkey_struct
argument_list|,
name|De
operator|.
name|ov_hkey_struct
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|De
operator|.
name|ov_fmode
operator|=
name|EXACTKEY
expr_stmt|;
else|else
name|De
operator|.
name|ov_fmode
operator|=
name|LRANGEKEY
expr_stmt|;
break|break;
block|}
comment|/* last step. If a secondary index range key was found, use it */
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|==
name|LRANGEKEY
condition|)
block|{
if|if
condition|(
name|allexact
operator|<
literal|0
condition|)
name|De
operator|.
name|ov_fmode
operator|=
name|EXACTKEY
expr_stmt|;
name|d
operator|=
name|openindex
argument_list|(
name|rtup
operator|.
name|irelidi
argument_list|)
expr_stmt|;
comment|/* temp check for 6.0 index */
if|if
condition|(
operator|(
name|int
operator|)
name|d
operator|->
name|reldum
operator|.
name|relindxd
operator|==
operator|-
literal|1
condition|)
name|ov_err
argument_list|(
name|BADSECINDX
argument_list|)
expr_stmt|;
name|De
operator|.
name|ov_scanr
operator|=
name|d
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lowikey
argument_list|,
operator|(
name|char
operator|*
operator|)
name|De
operator|.
name|ov_lkey_struct
argument_list|,
sizeof|sizeof
name|lowikey
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|highikey
argument_list|,
operator|(
name|char
operator|*
operator|)
name|De
operator|.
name|ov_hkey_struct
argument_list|,
sizeof|sizeof
name|highikey
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* nothing will work. give up! */
break|break;
block|}
comment|/* check for De.de_newq = FALSE and no source relation */
if|if
condition|(
operator|!
name|De
operator|.
name|ov_scanr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	** At this point the strategy is determined. 	** 	** If De.ov_fmode is EXACTKEY then De.ov_lkey_struct contains 	** the pointers to the keys. 	** 	** If De.ov_fmode is LRANGEKEY then De.ov_lkey_struct contains 	** the pointers to the low keys and De.ov_hkey_struct 	** contains pointers to the high keys. 	** 	** If De.ov_fmode is NOKEY, then a full scan will be performed 	*/
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|70
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"De.ov_fmode= %d\n"
argument_list|,
name|De
operator|.
name|ov_fmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set up the key tuples */
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|!=
name|NOKEY
condition|)
block|{
if|if
condition|(
name|setallkey
argument_list|(
name|De
operator|.
name|ov_lkey_struct
argument_list|,
name|De
operator|.
name|ov_keyl
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* query false. There is a simple 					** clause which can never be satisfied. 					** These simple clauses can be choosey! 					*/
block|}
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|,
name|De
operator|.
name|ov_fmode
argument_list|,
operator|&
name|De
operator|.
name|ov_lotid
argument_list|,
operator|&
name|De
operator|.
name|ov_hitid
argument_list|,
name|De
operator|.
name|ov_keyl
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"strategy:find1 %.12s, %d"
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_fmode
operator|==
name|LRANGEKEY
condition|)
block|{
name|setallkey
argument_list|(
name|De
operator|.
name|ov_hkey_struct
argument_list|,
name|De
operator|.
name|ov_keyh
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|,
name|HRANGEKEY
argument_list|,
operator|&
name|De
operator|.
name|ov_lotid
argument_list|,
operator|&
name|De
operator|.
name|ov_hitid
argument_list|,
name|De
operator|.
name|ov_keyh
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"strategy:find2 %.12s, %d"
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|70
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Lo"
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|De
operator|.
name|ov_lotid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Hi"
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|De
operator|.
name|ov_hitid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

end_unit

