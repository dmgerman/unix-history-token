begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"../decomp/globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)interp1.c
literal|7.2
literal|3
argument|/
literal|6
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	INTERP1.C ** **	symbol I/O utility routines for OVQP interpreter. ** */
end_comment

begin_comment
comment|/* ** GETSYMBOL ** **	Gets (type, len, value) symbols from list **	A ptr to the list is advanced after **	call.  Symbols are moved to a target location **	(typically a slot on the interpreter's De.ov_stack). **	Legality of symbol type and length is checked. **	Returns		1  if no more symbols in list **			0 otherwise ** */
end_comment

begin_macro
name|getsymbol
argument_list|(
argument|ts
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|SYMBOL
modifier|*
name|ts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target location (on stack) */
end_comment

begin_decl_stmt
name|SYMBOL
modifier|*
modifier|*
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to list */
end_comment

begin_block
block|{
name|int
name|len
decl_stmt|;
comment|/*length of target symbol*/
specifier|register
name|union
name|symvalue
modifier|*
name|d
decl_stmt|;
comment|/* ptr to data for target symbol */
specifier|register
name|SYMBOL
modifier|*
name|cp
decl_stmt|;
comment|/* the item in the list */
specifier|register
name|SYMBOL
modifier|*
name|tops
decl_stmt|;
comment|/* target location on stack */
specifier|register
name|union
name|symvalue
modifier|*
name|val
decl_stmt|;
name|tops
operator|=
name|ts
expr_stmt|;
comment|/* copy stack pointer */
name|cp
operator|=
operator|*
operator|*
name|p
expr_stmt|;
comment|/* get list pointer */
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|84
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"GETSYM: "
argument_list|)
expr_stmt|;
name|prsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tops
operator|>=
operator|(
name|SYMBOL
operator|*
operator|)
operator|&
name|De
operator|.
name|ov_stack
index|[
name|STACKSIZ
index|]
condition|)
name|ov_err
argument_list|(
name|STACKOVER
argument_list|)
expr_stmt|;
name|val
operator|=
operator|&
name|cp
operator|->
name|value
expr_stmt|;
comment|/* decomp will put the s_var's value in the right place  	 * if this is the case 	 */
if|if
condition|(
name|cp
operator|->
name|type
operator|==
name|VAR
operator|||
name|cp
operator|->
name|type
operator|==
name|S_VAR
condition|)
block|{
name|tops
operator|->
name|type
operator|=
name|val
operator|->
name|sym_var
operator|.
name|varfrmt
expr_stmt|;
name|len
operator|=
name|tops
operator|->
name|len
operator|=
name|val
operator|->
name|sym_var
operator|.
name|varfrml
expr_stmt|;
name|d
operator|=
operator|(
expr|union
name|symvalue
operator|*
operator|)
name|val
operator|->
name|sym_var
operator|.
name|valptr
expr_stmt|;
block|}
else|else
block|{
name|tops
operator|->
name|type
operator|=
name|cp
operator|->
name|type
expr_stmt|;
name|len
operator|=
name|tops
operator|->
name|len
operator|=
name|cp
operator|->
name|len
expr_stmt|;
name|len
operator|&=
literal|0377
expr_stmt|;
name|d
operator|=
operator|&
name|cp
operator|->
name|value
expr_stmt|;
block|}
comment|/* advance De.ov_qvect sequencing pointer p */
operator|*
name|p
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|tops
operator|->
name|type
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
name|tops
operator|->
name|value
operator|.
name|sym_data
operator|.
name|i2type
operator|=
name|d
operator|->
name|sym_data
operator|.
name|i1type
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|4
case|:
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tops
operator|->
name|value
operator|.
name|sym_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"getsym:bad int len %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|4
case|:
name|tops
operator|->
name|value
operator|.
name|sym_data
operator|.
name|f8type
operator|=
name|d
operator|->
name|sym_data
operator|.
name|f4type
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|tops
operator|->
name|value
operator|.
name|sym_data
operator|.
name|f8type
operator|=
name|d
operator|->
name|sym_data
operator|.
name|f8type
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"getsym:bad FLOAT len %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHAR
case|:
name|tops
operator|->
name|value
operator|.
name|sym_data
operator|.
name|cptype
operator|=
name|d
operator|->
name|sym_data
operator|.
name|c0type
expr_stmt|;
break|break;
case|case
name|AOP
case|:
case|case
name|BOP
case|:
case|case
name|UOP
case|:
case|case
name|COP
case|:
name|tops
operator|->
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|d
operator|->
name|sym_op
operator|.
name|opno
expr_stmt|;
break|break;
case|case
name|RESDOM
case|:
name|tops
operator|->
name|value
operator|.
name|sym_resdom
operator|.
name|resno
operator|=
name|d
operator|->
name|sym_resdom
operator|.
name|resno
expr_stmt|;
break|break;
case|case
name|AND
case|:
case|case
name|OR
case|:
break|break;
case|case
name|AGHEAD
case|:
case|case
name|BYHEAD
case|:
case|case
name|ROOT
case|:
case|case
name|QLEND
case|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all these are delimitors between lists */
default|default:
name|syserr
argument_list|(
literal|"getsym:bad type %d"
argument_list|,
name|tops
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TOUT ** **	Copies a symbol value into the Output tuple buffer. ** 	Used to write target **	list elements or aggregate values into the output tuple.
comment|*/
end_comment

begin_expr_stmt
name|tout
argument_list|(
name|s
argument_list|,
name|offp
argument_list|,
name|rlen
argument_list|)
specifier|register
name|SYMBOL
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|offp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|slen
decl_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|84
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"TOUT: s="
argument_list|)
expr_stmt|;
name|prstack
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  offset=%d, rlen=%d\n"
argument_list|,
name|offp
operator|-
name|De
operator|.
name|ov_outtup
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|CHAR
condition|)
block|{
name|slen
operator|=
name|s
operator|->
name|len
operator|&
literal|0377
expr_stmt|;
name|rlen
operator|&=
literal|0377
expr_stmt|;
name|i
operator|=
name|rlen
operator|-
name|slen
expr_stmt|;
comment|/* compute difference between sizes */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|bmove
argument_list|(
name|s
operator|->
name|value
operator|.
name|sym_data
operator|.
name|cptype
argument_list|,
name|offp
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|s
operator|->
name|value
operator|.
name|sym_data
operator|.
name|cptype
expr_stmt|;
name|bmove
argument_list|(
name|p
argument_list|,
name|offp
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|offp
index|[
name|slen
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* blank out remainder */
block|}
block|}
else|else
block|{
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|s
operator|->
name|value
argument_list|,
name|offp
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RCVT */
end_comment

begin_expr_stmt
name|rcvt
argument_list|(
name|tos
argument_list|,
name|restype
argument_list|,
name|reslen
argument_list|)
specifier|register
name|SYMBOL
operator|*
name|tos
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|restype
decl_stmt|,
name|reslen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|rtype
decl_stmt|,
name|rlen
decl_stmt|;
name|int
name|stype
decl_stmt|,
name|slen
decl_stmt|;
name|rtype
operator|=
name|restype
expr_stmt|;
name|rlen
operator|=
name|reslen
expr_stmt|;
name|stype
operator|=
name|tos
operator|->
name|type
expr_stmt|;
name|slen
operator|=
name|tos
operator|->
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|84
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"RCVT:type="
argument_list|)
expr_stmt|;
name|xputchar
argument_list|(
name|rtype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%3d, tos="
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
name|prstack
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rtype
operator|!=
name|stype
condition|)
block|{
if|if
condition|(
name|rtype
operator|==
name|CHAR
operator|||
name|stype
operator|==
name|CHAR
condition|)
name|ov_err
argument_list|(
name|BADCONV
argument_list|)
expr_stmt|;
comment|/* bad char to numeric conversion requested */
if|if
condition|(
name|rtype
operator|==
name|FLOAT
condition|)
name|itof
argument_list|(
name|tos
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rlen
operator|==
literal|4
condition|)
name|ftoi4
argument_list|(
name|tos
argument_list|)
expr_stmt|;
else|else
name|ftoi2
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
name|tos
operator|->
name|len
operator|=
name|rlen
expr_stmt|;
comment|/* handles conversion to i1 or f4 */
block|}
else|else
block|{
if|if
condition|(
name|rtype
operator|!=
name|CHAR
operator|&&
name|rlen
operator|!=
name|slen
condition|)
block|{
if|if
condition|(
name|rtype
operator|==
name|INT
condition|)
block|{
if|if
condition|(
name|rlen
operator|==
literal|4
condition|)
name|i2toi4
argument_list|(
name|tos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slen
operator|==
literal|4
condition|)
name|i4toi2
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
name|tos
operator|->
name|len
operator|=
name|rlen
expr_stmt|;
comment|/* handles conversion to i1 or f4 */
block|}
block|}
ifdef|#
directive|ifdef
name|xOTR3
if|if
condition|(
name|tTf
argument_list|(
literal|84
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"RCVT rets: symbol: "
argument_list|)
expr_stmt|;
name|prsym
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

end_unit

