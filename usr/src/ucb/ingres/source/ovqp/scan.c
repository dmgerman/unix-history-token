begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|"../decomp/globs.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)scan.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **	SCAN ** **	performs tuple by tuple scan of source reln or index reln **	within limits found by strategy routine.  **	When the source reln tuple is obtained the interpreter is invoked **	to continue further processing ** */
end_comment

begin_macro
name|scan
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|j
operator|,
name|mode
operator|,
name|domno
expr_stmt|;
name|struct
name|symbol
modifier|*
modifier|*
name|rlist
decl_stmt|;
comment|/* "result" list of query */
name|long
name|count
decl_stmt|;
name|long
name|tid
decl_stmt|,
name|temptid
decl_stmt|;
name|char
name|agtup
index|[
name|MAXTUP
index|]
decl_stmt|,
name|outtup1
index|[
name|MAXTUP
index|]
decl_stmt|;
name|int
name|qualfound
decl_stmt|,
name|ok
decl_stmt|;
name|struct
name|symbol
modifier|*
name|interpret
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SCAN\tScanr=%.12s\n"
argument_list|,
name|De
operator|.
name|ov_scanr
condition|?
name|De
operator|.
name|ov_scanr
operator|->
name|reldum
operator|.
name|relid
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tDe.ov_result %x\n"
argument_list|,
name|De
operator|.
name|ov_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|" De.ov_alist=%x, De.ov_bylist=%x, De.ov_tlist=%x, De.ov_qlist=%x\n"
argument_list|,
name|De
operator|.
name|ov_alist
argument_list|,
name|De
operator|.
name|ov_bylist
argument_list|,
name|De
operator|.
name|ov_tlist
argument_list|,
name|De
operator|.
name|ov_qlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_result
condition|)
name|printdesc
argument_list|(
name|De
operator|.
name|ov_result
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|De
operator|.
name|ov_result
operator|||
name|De
operator|.
name|ov_alist
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|ov_result
condition|)
block|{
name|clr_tuple
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|MAXTUP
expr_stmt|;
while|while
condition|(
name|j
operator|--
condition|)
name|De
operator|.
name|ov_outtup
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|qualfound
operator|=
name|EMPTY
expr_stmt|;
name|mode
operator|=
name|De
operator|.
name|de_qmode
expr_stmt|;
comment|/* 	** Check for identical source and result relations. 	** For modes mdREPL and mdDEL, De.ov_origtup must point 	** to the original (unmodified result tuple). 	** 	** If there is no De.ov_source or De.ov_result relations then 	** the code has no effect. 	*/
if|if
condition|(
name|De
operator|.
name|ov_source
operator|==
name|NULL
operator|||
operator|!
name|bequal
argument_list|(
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
argument_list|)
condition|)
block|{
name|De
operator|.
name|ov_diffrel
operator|=
name|TRUE
expr_stmt|;
name|De
operator|.
name|ov_origtup
operator|=
name|outtup1
expr_stmt|;
block|}
else|else
block|{
name|De
operator|.
name|ov_diffrel
operator|=
name|FALSE
expr_stmt|;
name|De
operator|.
name|ov_origtup
operator|=
name|De
operator|.
name|ov_intup
expr_stmt|;
block|}
comment|/*  determine type of result list */
comment|/* the only valid combinations are: 	** 	** De.ov_tlist=no	De.ov_alist=no	De.ov_bylist=no 	** De.ov_tlist=yes	De.ov_alist=no	De.ov_bylist=no 	** De.ov_tlist=no	De.ov_alist=yes	De.ov_bylist=no 	** De.ov_tlist=no	De.ov_alist=yes	De.ov_bylist=yes 	*/
name|rlist
operator|=
operator|(
name|De
operator|.
name|ov_tlist
condition|?
name|De
operator|.
name|ov_tlist
else|:
name|De
operator|.
name|ov_alist
operator|)
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_bylist
condition|)
name|rlist
operator|=
literal|0
expr_stmt|;
name|De
operator|.
name|ov_counter
operator|=
operator|&
name|count
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_bylist
condition|)
block|{
comment|/* 		** For aggregate functions the result relation 		** is in the format: 		** domain 1 = I4 (used as a counter) 		** domain 2 through relatts - De.ov_agcount (by-domains) 		** remaining domains (the actual aggregate values) 		*/
comment|/* set up keys for the getequal */
comment|/* domno must end with the domain number of the first aggregate */
for|for
control|(
name|domno
operator|=
literal|2
init|;
name|domno
operator|<=
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relatts
operator|-
name|De
operator|.
name|ov_agcount
condition|;
name|domno
operator|++
control|)
name|De
operator|.
name|ov_result
operator|->
name|relgiven
index|[
name|domno
index|]
operator|=
literal|1
expr_stmt|;
name|De
operator|.
name|ov_counter
operator|=
operator|(
name|long
operator|*
operator|)
name|De
operator|.
name|ov_outtup
expr_stmt|;
comment|/* first four bytes of De.ov_outtup is counter for De.ov_bylist */
block|}
comment|/* 	** check for constant qualification. 	** If the constant qual is true then remove 	** the qual to save reprocessing it. 	** If it is false then block further processing. 	*/
name|ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_qlist
operator|&&
name|De
operator|.
name|ov_qualvc
operator|==
literal|0
condition|)
if|if
condition|(
name|interpret
argument_list|(
name|De
operator|.
name|ov_qlist
argument_list|)
operator|->
name|value
operator|.
name|sym_data
operator|.
name|i2type
condition|)
name|De
operator|.
name|ov_qlist
operator|=
literal|0
expr_stmt|;
comment|/* qual always true */
else|else
name|ok
operator|=
name|FALSE
expr_stmt|;
comment|/* qual always false */
comment|/* if no source relation, interpret target list */
if|if
condition|(
operator|!
name|De
operator|.
name|ov_scanr
operator|&&
name|ok
condition|)
block|{
comment|/* there is no source relation and the qual is true */
name|qualfound
operator|=
name|NONEMPTY
expr_stmt|;
name|De
operator|.
name|ov_tend
operator|=
name|De
operator|.
name|ov_outtup
expr_stmt|;
comment|/* if there is a rlist then process it. (There should always be one) */
if|if
condition|(
name|rlist
condition|)
block|{
operator|(
operator|*
name|De
operator|.
name|ov_counter
operator|)
operator|++
expr_stmt|;
name|interpret
argument_list|(
name|rlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|De
operator|.
name|ov_tlist
condition|)
name|dispose
argument_list|(
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|De
operator|.
name|ov_userqry
condition|)
name|De
operator|.
name|ov_tupsfound
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|De
operator|.
name|ov_scanr
operator|&&
name|ok
condition|)
block|{
comment|/* There is a source relation. Iterate through each tuple */
while|while
condition|(
operator|!
operator|(
name|j
operator|=
name|get
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|,
operator|&
name|De
operator|.
name|ov_lotid
argument_list|,
operator|&
name|De
operator|.
name|ov_hitid
argument_list|,
name|De
operator|.
name|ov_intup
argument_list|,
name|NXTTUP
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|De
operator|.
name|ov_scanr
operator|!=
name|De
operator|.
name|ov_source
condition|)
name|printf
argument_list|(
literal|"Sec Index:"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"De.ov_intup:"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
name|De
operator|.
name|ov_scanr
argument_list|,
name|De
operator|.
name|ov_intup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|De
operator|.
name|ov_intid
operator|=
name|De
operator|.
name|ov_lotid
expr_stmt|;
if|if
condition|(
name|De
operator|.
name|ov_scanr
operator|!=
name|De
operator|.
name|ov_source
condition|)
block|{
comment|/* make sure index tuple is part of the solution */
if|if
condition|(
operator|!
name|indexcheck
argument_list|()
condition|)
comment|/* index keys don't match what we want */
continue|continue;
name|bmove
argument_list|(
name|De
operator|.
name|ov_intup
operator|+
name|De
operator|.
name|ov_scanr
operator|->
name|reldum
operator|.
name|relwid
operator|-
name|TIDLEN
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tid
argument_list|,
name|TIDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|=
name|get
argument_list|(
name|De
operator|.
name|ov_source
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|temptid
argument_list|,
name|De
operator|.
name|ov_intup
argument_list|,
name|CURTUP
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"scan:indx get %d %.12s"
argument_list|,
name|j
argument_list|,
name|De
operator|.
name|ov_scanr
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"De.ov_intup:"
argument_list|)
expr_stmt|;
name|printup
argument_list|(
name|De
operator|.
name|ov_source
argument_list|,
name|De
operator|.
name|ov_intup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|De
operator|.
name|ov_intid
operator|=
name|tid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|De
operator|.
name|ov_qlist
operator|||
name|interpret
argument_list|(
name|De
operator|.
name|ov_qlist
argument_list|)
operator|->
name|value
operator|.
name|sym_data
operator|.
name|i2type
condition|)
block|{
name|qualfound
operator|=
name|NONEMPTY
expr_stmt|;
name|De
operator|.
name|ov_tend
operator|=
name|De
operator|.
name|ov_outtup
expr_stmt|;
if|if
condition|(
name|rlist
condition|)
block|{
operator|(
operator|*
name|De
operator|.
name|ov_counter
operator|)
operator|++
expr_stmt|;
name|interpret
argument_list|(
name|rlist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|De
operator|.
name|ov_tlist
condition|)
name|dispose
argument_list|(
name|mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|De
operator|.
name|ov_userqry
condition|)
name|De
operator|.
name|ov_tupsfound
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|De
operator|.
name|ov_targvc
condition|)
comment|/* constant Target list */
break|break;
comment|/* process De.ov_bylist if any */
if|if
condition|(
name|De
operator|.
name|ov_bylist
condition|)
block|{
name|interpret
argument_list|(
name|De
operator|.
name|ov_bylist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|getequal
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|,
name|agtup
argument_list|,
operator|&
name|De
operator|.
name|ov_uptid
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"scan:getequal %d,%.12s"
argument_list|,
name|j
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|j
condition|)
block|{
comment|/* match on bylist */
name|bmove
argument_list|(
name|agtup
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relwid
argument_list|)
expr_stmt|;
name|mode
operator|=
name|mdREPL
expr_stmt|;
operator|(
operator|*
name|De
operator|.
name|ov_counter
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* first of this bylist */
name|mode
operator|=
name|mdAPP
expr_stmt|;
operator|*
name|De
operator|.
name|ov_counter
operator|=
literal|1
expr_stmt|;
block|}
name|De
operator|.
name|ov_tend
operator|=
name|De
operator|.
name|ov_outtup
operator|+
name|De
operator|.
name|ov_result
operator|->
name|reloff
index|[
name|domno
index|]
expr_stmt|;
name|interpret
argument_list|(
name|De
operator|.
name|ov_alist
argument_list|)
expr_stmt|;
name|dispose
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"scan:get prim %d %.12s"
argument_list|,
name|j
argument_list|,
name|De
operator|.
name|ov_source
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|De
operator|.
name|ov_result
condition|)
block|{
if|if
condition|(
name|j
operator|=
name|noclose
argument_list|(
name|De
operator|.
name|ov_result
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"scan:noclose %d %.12s"
argument_list|,
name|j
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|qualfound
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DISPOSE */
end_comment

begin_macro
name|dispose
argument_list|(
argument|mode
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|De
operator|.
name|ov_result
condition|)
block|{
if|if
condition|(
name|Equel
condition|)
name|equeleol
argument_list|(
name|EOTUP
argument_list|)
expr_stmt|;
else|else
name|printeol
argument_list|()
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|xOTR1
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"mode=%d,"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
literal|2
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|mdREPL
operator|||
name|mode
operator|==
name|mdDEL
operator|)
condition|)
name|printf
argument_list|(
literal|"De.ov_uptid:%ld, "
argument_list|,
name|De
operator|.
name|ov_uptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|71
argument_list|,
literal|3
argument_list|)
condition|)
if|if
condition|(
name|mode
operator|==
name|mdDEL
condition|)
name|printup
argument_list|(
name|De
operator|.
name|ov_source
argument_list|,
name|De
operator|.
name|ov_intup
argument_list|)
expr_stmt|;
else|else
name|printup
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SPOOL UPDATES OF EXISTING USER RELNS TO BATCH PROCESSOR */
if|if
condition|(
name|De
operator|.
name|de_buflag
condition|)
block|{
name|addbatch
argument_list|(
operator|&
name|De
operator|.
name|ov_uptid
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|,
name|De
operator|.
name|ov_origtup
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PERFORM ALL OTHER OPERATIONS DIRECTLY */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|mdRETR
case|:
case|case
name|mdAPP
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|insert
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
operator|&
name|De
operator|.
name|ov_uptid
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|,
name|NODUPS
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"dispose:insert %d %.12s"
argument_list|,
name|i
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
break|break;
case|case
name|mdREPL
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|replace
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
operator|&
name|De
operator|.
name|ov_uptid
argument_list|,
name|De
operator|.
name|ov_outtup
argument_list|,
name|NODUPS
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"dispose:replace %d %.12s"
argument_list|,
name|i
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
break|break;
case|case
name|mdDEL
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|delete
argument_list|(
name|De
operator|.
name|ov_result
argument_list|,
operator|&
name|De
operator|.
name|ov_uptid
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"dispose:delete %d %.12s"
argument_list|,
name|i
argument_list|,
name|De
operator|.
name|ov_result
operator|->
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"dispose:bad mode %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|De
operator|.
name|ov_userqry
operator|&&
name|i
operator|==
literal|0
condition|)
name|De
operator|.
name|ov_tupsfound
operator|++
expr_stmt|;
block|}
end_block

end_unit

