begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ctlmod.h"
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)setp.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  SETP -- set parameter ** **	Sets a parameter, to be later sent by 'call' to whomever. ** **	Parameters: **		type -- parameter type. **			PV_STRING -- a string, 'len' is ignored. **			PV_TUPLE -- a tuple of length 'len'. **			PV_QTREE -- a query tree pointer, 'len' **				is ignored. **			PV_INT -- an integer, 'len' is ignored. **		val -- the value (real value if PV_INT, pointer **			otherwise). **		len -- the length of the tuple in PV_TUPLE mode. ** **	Returns: **		none ** **	Side Effects: **		Adjusts Ctx.ctx_pc& Ctx.ctx_pv. ** **	Trace Flags: **		4.8 - 4.15 */
end_comment

begin_expr_stmt
name|setp
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
specifier|register
name|int
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARM
modifier|*
name|pp
decl_stmt|;
specifier|register
name|char
modifier|*
name|newp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
comment|/* 	**  Check the magic bounds. 	*/
if|if
condition|(
operator|!
name|Ctx
operator|.
name|ctx_init
condition|)
comment|/* 		pp =&Resp.resp_rval; */
name|syserr
argument_list|(
literal|"setp: no initp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Ctx
operator|.
name|ctx_pc
operator|>=
name|PV_MAXPC
condition|)
name|syserr
argument_list|(
literal|"setp: overflow"
argument_list|)
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|Ctx
operator|.
name|ctx_pv
index|[
name|Ctx
operator|.
name|ctx_pc
operator|++
index|]
expr_stmt|;
comment|/* 	**  Figure out the length from the type. 	*/
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PV_STR
case|:
name|len
operator|=
name|length
argument_list|(
name|val
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newp
operator|=
name|need
argument_list|(
name|Qbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|val
argument_list|,
name|newp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pv_val
operator|.
name|pv_str
operator|=
name|newp
expr_stmt|;
break|break;
case|case
name|PV_TUPLE
case|:
name|pp
operator|->
name|pv_val
operator|.
name|pv_tuple
operator|=
operator|(
name|char
operator|*
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|PV_QTREE
case|:
name|len
operator|=
sizeof|sizeof
name|pp
operator|->
name|pv_val
operator|.
name|pv_qtree
expr_stmt|;
name|pp
operator|->
name|pv_val
operator|.
name|pv_qtree
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|PV_INT
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pv_val
operator|.
name|pv_int
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"setp: type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Set up the parameter. 	*/
name|pp
operator|->
name|pv_type
operator|=
name|type
expr_stmt|;
name|pp
operator|->
name|pv_len
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|4
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"setp: "
argument_list|)
expr_stmt|;
name|pr_parm
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

end_unit

