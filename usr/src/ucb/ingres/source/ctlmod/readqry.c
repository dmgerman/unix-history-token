begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ctlmod.h"
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)readqry.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_define
define|#
directive|define
name|STACKFULL
value|3701
end_define

begin_comment
comment|/* trbuild stack ovflo error */
end_comment

begin_comment
comment|/* ** READQRY ** ** 	Reads in query symbols from input pipe into core **	locations and sets up information needed for later  **	processing. ** **	Returns ptr to root of querytree ** **	Locbuf is a 'struct srcid' since that is the largest node of **	a QMODE, SOURCEID, or RESULTVAR node. */
end_comment

begin_decl_stmt
name|QTREE
modifier|*
name|readqry
argument_list|(
name|rdfn
argument_list|,
name|fnparam
argument_list|,
name|initialize
argument_list|)
name|int
argument_list|(
operator|*
name|rdfn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tree read function */
end_comment

begin_decl_stmt
name|int
name|fnparam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* parameter to pass to rdfn */
end_comment

begin_decl_stmt
name|bool
name|initialize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, initialize Qbuf */
end_comment

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|rtval
decl_stmt|;
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|readtree
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|xalloc
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|trbuild
parameter_list|()
function_decl|;
name|int
name|mark
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|readsym
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"READQRY:\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|initialize
condition|)
block|{
comment|/* initialize for new query block */
name|clrrange
argument_list|()
expr_stmt|;
name|Qt
operator|.
name|qt_resvar
operator|=
operator|-
literal|1
expr_stmt|;
name|Qt
operator|.
name|qt_qmode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXRANGE
condition|;
name|i
operator|++
control|)
name|Qt
operator|.
name|qt_remap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|mark
operator|=
name|markbuf
argument_list|(
name|Qbuf
argument_list|)
expr_stmt|;
comment|/* read symbols from input */
for|for
control|(
init|;
condition|;
control|)
block|{
name|freebuf
argument_list|(
name|Qbuf
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|q
operator|=
name|readsym
argument_list|(
name|rdfn
argument_list|,
name|fnparam
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|q
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|QMODE
case|:
if|if
condition|(
name|Qt
operator|.
name|qt_qmode
operator|!=
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"readqry: two qmodes"
argument_list|)
expr_stmt|;
name|Qt
operator|.
name|qt_qmode
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i2type
expr_stmt|;
break|break;
case|case
name|RESULTVAR
case|:
if|if
condition|(
name|Qt
operator|.
name|qt_resvar
operator|!=
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"readqry: two resultvars"
argument_list|)
expr_stmt|;
name|Qt
operator|.
name|qt_resvar
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i2type
expr_stmt|;
break|break;
case|case
name|SOURCEID
case|:
name|d
operator|=
operator|(
name|DESC
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_srcid
operator|.
name|srcdesc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
expr|*
name|d
argument_list|)
expr_stmt|;
name|i
operator|=
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_srcid
operator|.
name|srcvar
expr_stmt|;
name|j
operator|=
name|declare
argument_list|(
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|i
operator|&&
name|initialize
condition|)
name|syserr
argument_list|(
literal|"readqry: declare(%d)=%d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|Qt
operator|.
name|qt_remap
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
break|break;
case|case
name|TREE
case|:
comment|/* beginning of tree, no more other stuff */
name|q
operator|=
name|readtree
argument_list|(
name|q
argument_list|,
name|rdfn
argument_list|,
name|fnparam
argument_list|)
expr_stmt|;
name|rtval
operator|=
name|trbuild
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtval
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|STACKFULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
default|default:
name|syserr
argument_list|(
literal|"readqry: bad symbol %d"
argument_list|,
name|q
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  READSYM **	reads in one symbol from pipe into symbol struct. */
end_comment

begin_decl_stmt
name|QTREE
modifier|*
name|readsym
argument_list|(
name|rdfn
argument_list|,
name|fnparam
argument_list|)
name|int
argument_list|(
operator|*
name|rdfn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tree read function */
end_comment

begin_decl_stmt
name|char
modifier|*
name|fnparam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
name|int
name|rlen
decl_stmt|;
name|q
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|need
argument_list|(
name|Qbuf
argument_list|,
name|QT_HDR_SIZ
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|rdfn
call|)
argument_list|(
name|fnparam
argument_list|,
operator|&
name|q
operator|->
name|sym
argument_list|,
name|TYP_LEN_SIZ
argument_list|)
operator|<
name|TYP_LEN_SIZ
condition|)
name|syserr
argument_list|(
literal|"readsym: read sym"
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|len
operator|=
name|q
operator|->
name|sym
operator|.
name|len
operator|&
name|I1MASK
expr_stmt|;
name|t
operator|=
name|q
operator|->
name|sym
operator|.
name|type
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|AND
case|:
if|if
condition|(
name|len
operator|<
literal|6
condition|)
name|len
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|ROOT
case|:
case|case
name|AGHEAD
case|:
if|if
condition|(
name|len
operator|<
literal|8
condition|)
name|len
operator|=
literal|8
expr_stmt|;
break|break;
block|}
name|q
operator|->
name|sym
operator|.
name|len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
comment|/* this will be contiguous with above need call */
name|need
argument_list|(
name|Qbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|rdfn
call|)
argument_list|(
name|fnparam
argument_list|,
operator|&
name|q
operator|->
name|sym
operator|.
name|value
argument_list|,
name|rlen
argument_list|)
operator|<
name|rlen
condition|)
name|syserr
argument_list|(
literal|"readsym: read val (sym=%d,%d)"
argument_list|,
name|t
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ROOT
case|:
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rootuser
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|AGHEAD
case|:
name|q
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_root
operator|.
name|rootuser
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|xCTR1
if|if
condition|(
name|tTf
argument_list|(
literal|10
argument_list|,
literal|9
argument_list|)
condition|)
name|nodepr
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|xCTR1
return|return
operator|(
name|q
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  READTREE ** ** 	reads in tree symbols into a buffer up to a root (end) symbol ** */
end_comment

begin_decl_stmt
name|QTREE
modifier|*
name|readtree
argument_list|(
name|tresym
argument_list|,
name|rdfn
argument_list|,
name|fnparam
argument_list|)
name|QTREE
modifier|*
name|tresym
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|rdfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|fnparam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|q
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|rtval
decl_stmt|;
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
name|rtval
operator|=
name|tresym
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* space for left& right pointers */
name|q
operator|=
name|readsym
argument_list|(
name|rdfn
argument_list|,
name|fnparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|sym
operator|.
name|type
operator|==
name|ROOT
condition|)
return|return
operator|(
name|rtval
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TRBUILD -- Rebuild a tree in memory ** **	Trbuild is called with a pointer to the TREE node of **	a query already in memory. It rebuilds the pointer **	structure assuming the querytree is in postfix order. ** **	Parameters: **		bufptr - a pointer to the TREE node ** **	Returns: **		NULL - Internal stack overflow (STACKSIZ) **		pointer to the ROOT node ** **	Side Effects: **		All left& right pointers are rebuilt. ** **	Called By: **		readqry ** **	Syserrs: **		syserr if there are too many leaf nodes or too **		few child nodes */
end_comment

begin_function
name|QTREE
modifier|*
name|trbuild
parameter_list|(
name|bufptr
parameter_list|)
name|QTREE
modifier|*
name|bufptr
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
modifier|*
name|stackptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|SYMBOL
modifier|*
name|s
decl_stmt|;
name|QTREE
modifier|*
name|treestack
index|[
name|STACKSIZ
index|]
decl_stmt|;
specifier|extern
name|bool
name|leaf
parameter_list|()
function_decl|;
name|stackptr
operator|=
name|treestack
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|bufptr
init|;
condition|;
name|p
operator|+=
name|QT_HDR_SIZ
operator|+
operator|(
operator|(
name|s
operator|->
name|len
operator|+
literal|1
operator|)
operator|&
literal|0376
operator|)
control|)
block|{
name|s
operator|=
operator|&
operator|(
operator|(
name|QTREE
operator|*
operator|)
name|p
operator|)
operator|->
name|sym
expr_stmt|;
operator|(
operator|(
name|QTREE
operator|*
operator|)
name|p
operator|)
operator|->
name|left
operator|=
operator|(
operator|(
name|QTREE
operator|*
operator|)
name|p
operator|)
operator|->
name|right
operator|=
literal|0
expr_stmt|;
comment|/* reunite p with left and right children on stack, if any*/
if|if
condition|(
operator|!
name|leaf
argument_list|(
operator|(
name|QTREE
operator|*
operator|)
name|p
argument_list|)
condition|)
comment|/* this node has children */
block|{
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|UOP
condition|)
if|if
condition|(
name|stackptr
operator|<=
name|treestack
condition|)
block|{
name|err
label|:
name|syserr
argument_list|(
literal|"trbuild:too few nodes"
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
operator|(
name|QTREE
operator|*
operator|)
name|p
operator|)
operator|->
name|right
operator|=
operator|*
operator|(
operator|--
name|stackptr
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|type
operator|!=
name|AOP
condition|)
if|if
condition|(
name|stackptr
operator|<=
name|treestack
condition|)
goto|goto
name|err
goto|;
else|else
operator|(
operator|(
name|QTREE
operator|*
operator|)
name|p
operator|)
operator|->
name|left
operator|=
operator|*
operator|(
operator|--
name|stackptr
operator|)
expr_stmt|;
block|}
comment|/* 		** If this is a ROOT node then the tree is complete. 		** verify that there are no extra nodes in the 		** treestack. 		*/
if|if
condition|(
name|s
operator|->
name|type
operator|==
name|ROOT
condition|)
comment|/* root node */
block|{
if|if
condition|(
name|stackptr
operator|!=
name|treestack
condition|)
name|syserr
argument_list|(
literal|"trbuild:xtra nodes"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|QTREE
operator|*
operator|)
name|p
operator|)
return|;
block|}
comment|/* stack p */
if|if
condition|(
name|stackptr
operator|-
name|treestack
operator|>=
name|STACKSIZ
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* error:stack full */
operator|*
operator|(
name|stackptr
operator|++
operator|)
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|p
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|leaf
parameter_list|(
name|p
parameter_list|)
name|QTREE
modifier|*
name|p
decl_stmt|;
block|{
switch|switch
condition|(
name|p
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|VAR
case|:
case|case
name|TREE
case|:
case|case
name|QLEND
case|:
case|case
name|INT
case|:
case|case
name|FLOAT
case|:
case|case
name|CHAR
case|:
case|case
name|COP
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

end_unit

