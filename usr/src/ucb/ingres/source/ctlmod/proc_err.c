begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ctlmod.h"
end_include

begin_include
include|#
directive|include
file|"pipes.h"
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)proc_err.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  PROC_ERR -- Process error message ** **	This routine processes an error.  It searches back through **	the chain of contexts until it finds one that is willing to **	process this error, or it finds that it must transfer the **	error to another process to handle it. ** **	It also unwinds the tree of **	activations.  It leaves us in the context that processes **	the error, or the state that should be reading the **	input pipe. ** **	The local error handling function returns zero if the **	error should be ignored, anything else otherwise. ** **	Parameters: **		pc -- error parameter count. **		pv -- error parameter vector. **		ppb -- a pointer to a pipe block to use in **			sending this error. ** **	Returns: **		none. ** **	Side Effects: **		Unwinds the list of activations. **		The input pipe can be changed under certain **			circumstances. ** **	Trace Flags: **		6.8 - 6.15 */
end_comment

begin_macro
name|proc_err
argument_list|(
argument|ppb
argument_list|,
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|pb_t
modifier|*
name|ppb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
name|pv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|fn_def
modifier|*
name|f
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Proc_name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ctx_t
modifier|*
name|ctx
decl_stmt|;
specifier|extern
name|pb_t
modifier|*
name|MonPpb
decl_stmt|;
ifdef|#
directive|ifdef
name|xCTR2
if|if
condition|(
name|tTf
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"proc_err: new = %d\n"
argument_list|,
name|Ctx
operator|.
name|ctx_new
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pb_prime
argument_list|(
name|ppb
argument_list|,
name|PB_ERR
argument_list|)
expr_stmt|;
comment|/* 	**  Scan back on the list of context dependencies. 	**	If we come to someone who can process this message, 	**	we go ahead and do it.  We also take this 	**	opportunity to unwind the context list& call the 	**	cleanup functions. 	*/
for|for
control|(
name|ctx
operator|=
operator|&
name|Ctx
init|;
name|ctx
operator|!=
name|NULL
condition|;
name|ctx
operator|=
name|ctx
operator|->
name|ctx_link
control|)
block|{
name|Proc_name
operator|=
name|ctx
operator|->
name|ctx_name
expr_stmt|;
name|f
operator|=
name|ctx
operator|->
name|ctx_fn
expr_stmt|;
ifdef|#
directive|ifdef
name|xCTR2
if|if
condition|(
name|tTf
argument_list|(
literal|6
argument_list|,
literal|9
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"proc_err: unwinding %s: errfn=%x, ppb=%x, link=%x, resp=%d, fn=%x\n"
argument_list|,
name|Proc_name
argument_list|,
name|ctx
operator|->
name|ctx_errfn
argument_list|,
name|ctx
operator|->
name|ctx_ppb
argument_list|,
name|ctx
operator|->
name|ctx_link
argument_list|,
name|ctx
operator|->
name|ctx_resp
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  Do the actual error processing. */
name|ppb
operator|->
name|pb_proc
operator|=
name|ctx
operator|->
name|ctx_resp
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ctx_errfn
operator|!=
name|NULL
condition|)
name|i
operator|=
call|(
modifier|*
name|ctx
operator|->
name|ctx_errfn
call|)
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|xCTR2
if|if
condition|(
name|tTf
argument_list|(
literal|6
argument_list|,
literal|11
argument_list|)
condition|)
name|lprintf
argument_list|(
literal|"proc_err: errcode %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* turn into nonfatal error */
name|ppb
operator|->
name|pb_stat
operator||=
name|PB_INFO
expr_stmt|;
name|ppb
operator|->
name|pb_proc
operator|=
name|PB_FRONT
expr_stmt|;
block|}
else|else
block|{
comment|/* call the cleanup function */
if|if
condition|(
name|f
operator|!=
name|NULL
operator|&&
name|f
operator|->
name|fn_active
operator|>
literal|0
condition|)
call|(
modifier|*
name|f
operator|->
name|fn_cleanup
call|)
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* arrange to leave if parent not in this process */
if|if
condition|(
name|ppb
operator|->
name|pb_proc
operator|!=
name|Cm
operator|.
name|cm_myproc
condition|)
block|{
name|send_off
argument_list|(
name|ppb
argument_list|,
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|pb_flush
argument_list|(
name|ppb
argument_list|)
expr_stmt|;
comment|/* throw away dead contexts and exit */
break|break;
block|}
block|}
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"proc_err: no parent"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xCTR3
if|if
condition|(
name|tTf
argument_list|(
literal|6
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|lprintf
argument_list|(
literal|"proc_err: cleanup: ctx=%x, ->_link=%x, MonPpb = "
argument_list|,
name|ctx
argument_list|,
name|ctx
operator|->
name|ctx_link
argument_list|)
expr_stmt|;
name|pb_dump
argument_list|(
name|MonPpb
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* pop contexts down to ctx and exit */
name|ctx
operator|=
name|ctx
operator|->
name|ctx_link
expr_stmt|;
while|while
condition|(
name|Ctx
operator|.
name|ctx_link
operator|!=
name|ctx
condition|)
block|{
if|if
condition|(
name|Ctx
operator|.
name|ctx_link
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"proc_err: underflow"
argument_list|)
expr_stmt|;
name|Ctx
operator|.
name|ctx_new
operator|=
name|TRUE
expr_stmt|;
name|resetp
argument_list|()
expr_stmt|;
block|}
comment|/* 	**  Flush input pipe. 	**	THIS CODE IS ONLY NEEDED TO MAKE READMON WORK, AND 	**	SHOULD BE REMOVED WHEN READMON GOES AWAY!! 	*/
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|Cm
operator|.
name|cm_input
operator|=
name|Cm
operator|.
name|cm_rinput
expr_stmt|;
while|while
condition|(
operator|!
name|bitset
argument_list|(
name|PB_EOF
argument_list|,
name|MonPpb
operator|->
name|pb_stat
argument_list|)
condition|)
name|pb_read
argument_list|(
name|MonPpb
argument_list|)
expr_stmt|;
name|MonPpb
operator|->
name|pb_st
operator|=
name|PB_UNKNOWN
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|Ctx
operator|.
name|ctx_jbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

