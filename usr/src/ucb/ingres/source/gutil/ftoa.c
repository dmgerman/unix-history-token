begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)ftoa.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_define
define|#
directive|define
name|MAXDIG
value|25
end_define

begin_comment
comment|/* **  FLOATING POINT TO ASCII CONVERSION ** **	'Value' is converted to an ascii character string and stored **	into 'ascii'.  Ascii should have room for at least 'width' + 1 **	characters.  'Width' is the width of the output field (max). **	'Prec' is the number of characters to put after the decimal **	point.  The format of the output string is controlled by **	'format'. ** **	'Format' can be: **		e or E: "E" format output **		f or F:  "F" format output **		g or G:  "F" format output if it will fit, otherwise **			use "E" format. **		n or N:  same as G, but decimal points will not always **			be aligned. ** **	If 'format' is upper case, the "E" comes out in upper case; **	otherwise it comes out in lower case. ** **	When the field width is not big enough, it fills the field with **	stars ("*****") and returns zero.  Normal return is the width **	of the output field (sometimes shorter than 'width'). */
end_comment

begin_macro
name|ftoa
argument_list|(
argument|value
argument_list|,
argument|ascii
argument_list|,
argument|width
argument_list|,
argument|prec1
argument_list|,
argument|format
argument_list|)
end_macro

begin_decl_stmt
name|double
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ascii
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|width
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prec1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|auto
name|int
name|expon
decl_stmt|;
specifier|auto
name|int
name|sign
decl_stmt|;
specifier|register
name|int
name|avail
decl_stmt|;
specifier|register
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|mode
decl_stmt|;
name|int
name|lowercase
decl_stmt|;
name|int
name|prec
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ecvt
argument_list|()
decl_stmt|,
modifier|*
name|fcvt
argument_list|()
decl_stmt|;
name|prec
operator|=
name|prec1
expr_stmt|;
name|mode
operator|=
name|format
expr_stmt|;
name|lowercase
operator|=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
if|if
condition|(
name|mode
operator|>=
literal|'a'
condition|)
name|mode
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
else|else
name|lowercase
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|'E'
condition|)
block|{
comment|/* try 'F' style output */
name|p
operator|=
name|fcvt
argument_list|(
name|value
argument_list|,
name|prec
argument_list|,
operator|&
name|expon
argument_list|,
operator|&
name|sign
argument_list|)
expr_stmt|;
name|avail
operator|=
name|width
expr_stmt|;
name|a
operator|=
name|ascii
expr_stmt|;
comment|/* output sign */
if|if
condition|(
name|sign
condition|)
block|{
name|avail
operator|--
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
comment|/* output '0' before the decimal point */
if|if
condition|(
name|expon
operator|<=
literal|0
condition|)
block|{
operator|*
name|a
operator|++
operator|=
literal|'0'
expr_stmt|;
name|avail
operator|--
expr_stmt|;
block|}
comment|/* compute space length left after dec pt and fraction */
name|avail
operator|-=
name|prec
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|'G'
condition|)
name|avail
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|avail
operator|>=
name|expon
condition|)
block|{
comment|/* it fits.  output */
while|while
condition|(
name|expon
operator|>
literal|0
condition|)
block|{
comment|/* output left of dp */
name|expon
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|a
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|a
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
comment|/* output fraction (right of dec pt) */
name|avail
operator|=
name|expon
expr_stmt|;
goto|goto
name|frac_out
goto|;
block|}
comment|/* won't fit; let's hope for G format */
block|}
if|if
condition|(
name|mode
operator|!=
literal|'F'
condition|)
block|{
comment|/* try to do E style output */
name|p
operator|=
name|ecvt
argument_list|(
name|value
argument_list|,
name|prec
operator|+
literal|1
argument_list|,
operator|&
name|expon
argument_list|,
operator|&
name|sign
argument_list|)
expr_stmt|;
name|avail
operator|=
name|width
operator|-
literal|5
expr_stmt|;
name|a
operator|=
name|ascii
expr_stmt|;
comment|/* output the sign */
if|if
condition|(
name|sign
condition|)
block|{
operator|*
name|a
operator|++
operator|=
literal|'-'
expr_stmt|;
name|avail
operator|--
expr_stmt|;
block|}
block|}
comment|/* check for field too small */
if|if
condition|(
name|mode
operator|==
literal|'F'
operator|||
name|avail
operator|<
name|prec
condition|)
block|{
comment|/* sorry joker, you lose */
name|a
operator|=
name|ascii
expr_stmt|;
for|for
control|(
name|avail
operator|=
name|width
init|;
name|avail
operator|>
literal|0
condition|;
name|avail
operator|--
control|)
operator|*
name|a
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|a
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* it fits; output the number */
name|mode
operator|=
literal|'E'
expr_stmt|;
comment|/* output the LHS single digit */
operator|*
name|a
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|expon
operator|--
expr_stmt|;
comment|/* output the rhs */
name|avail
operator|=
literal|1
expr_stmt|;
name|frac_out
label|:
operator|*
name|a
operator|++
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
name|prec
operator|>
literal|0
condition|)
block|{
name|prec
operator|--
expr_stmt|;
if|if
condition|(
name|avail
operator|<
literal|0
condition|)
block|{
name|avail
operator|++
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|a
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
else|else
operator|*
name|a
operator|++
operator|=
literal|'0'
expr_stmt|;
block|}
block|}
comment|/* output the exponent */
if|if
condition|(
name|mode
operator|==
literal|'E'
condition|)
block|{
operator|*
name|a
operator|++
operator|=
literal|'E'
operator|+
name|lowercase
expr_stmt|;
if|if
condition|(
name|expon
operator|<
literal|0
condition|)
block|{
operator|*
name|a
operator|++
operator|=
literal|'-'
expr_stmt|;
name|expon
operator|=
operator|-
name|expon
expr_stmt|;
block|}
else|else
operator|*
name|a
operator|++
operator|=
literal|'+'
expr_stmt|;
operator|*
name|a
operator|++
operator|=
operator|(
name|expon
operator|/
literal|10
operator|)
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
operator|*
name|a
operator|++
operator|=
name|expon
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
comment|/* output spaces on the end in G format */
if|if
condition|(
name|mode
operator|==
literal|'G'
condition|)
block|{
operator|*
name|a
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* finally, we can return */
operator|*
name|a
operator|=
literal|0
expr_stmt|;
name|avail
operator|=
name|a
operator|-
name|ascii
expr_stmt|;
return|return
operator|(
name|avail
operator|)
return|;
block|}
end_block

end_unit

