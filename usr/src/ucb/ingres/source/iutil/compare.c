begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)compare.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_macro
name|icompare
argument_list|(
argument|ax
argument_list|,
argument|bx
argument_list|,
argument|frmt
argument_list|,
argument|frml
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ax
decl_stmt|,
modifier|*
name|bx
decl_stmt|,
name|frmt
decl_stmt|,
name|frml
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ANYTYPE
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
name|ANYTYPE
name|atemp
decl_stmt|,
name|btemp
decl_stmt|;
name|length
operator|=
name|frml
operator|&
name|I1MASK
expr_stmt|;
if|if
condition|(
name|frmt
operator|==
name|CHAR
condition|)
return|return
operator|(
name|scompare
argument_list|(
name|ax
argument_list|,
name|length
argument_list|,
name|bx
argument_list|,
name|length
argument_list|)
operator|)
return|;
name|a
operator|=
operator|&
name|atemp
expr_stmt|;
name|b
operator|=
operator|&
name|btemp
expr_stmt|;
name|bmove
argument_list|(
name|ax
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|bx
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|bequal
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
name|length
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|frmt
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
name|a
operator|->
name|i1type
operator|-
name|b
operator|->
name|i1type
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|a
operator|->
name|i2type
operator|-
name|b
operator|->
name|i2type
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|a
operator|->
name|i4type
operator|>
name|b
operator|->
name|i4type
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|frml
operator|==
literal|4
condition|)
return|return
operator|(
name|a
operator|->
name|f4type
operator|>
name|b
operator|->
name|f4type
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|a
operator|->
name|f8type
operator|>
name|b
operator|->
name|f8type
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
break|break;
block|}
name|syserr
argument_list|(
literal|"compare: t=%d,l=%d"
argument_list|,
name|frmt
argument_list|,
name|frml
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  KCOMPARE -- key compare ** **	compares all domains indicated by SETKEY in the tuple to the **	corressponding domains in the key. **	the comparison is done according to the format of the domain **	as specified in the descriptor. ** **	function values: **<0 tuple< key ** 		=0 tuple = key **>0 tuple> key */
end_comment

begin_macro
name|kcompare
argument_list|(
argument|dx
argument_list|,
argument|tuple
argument_list|,
argument|key
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|dx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*relation descriptor	*/
end_comment

begin_decl_stmt
name|char
name|tuple
index|[
name|MAXTUP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*tuple to be compared	*/
end_comment

begin_decl_stmt
name|char
name|key
index|[
name|MAXTUP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*second tuple or key	*/
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|tmp
decl_stmt|;
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
name|d
operator|=
name|dx
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|d
operator|->
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|relgiven
index|[
name|i
index|]
condition|)
if|if
condition|(
name|tmp
operator|=
name|icompare
argument_list|(
operator|&
name|tuple
index|[
name|d
operator|->
name|reloff
index|[
name|i
index|]
index|]
argument_list|,
operator|&
name|key
index|[
name|d
operator|->
name|reloff
index|[
name|i
index|]
index|]
argument_list|,
name|d
operator|->
name|relfrmt
index|[
name|i
index|]
argument_list|,
name|d
operator|->
name|relfrml
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
operator|(
name|tmp
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

