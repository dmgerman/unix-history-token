begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)mcall.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  MCALL -- call a macro ** **	This takes care of springing a macro and processing it for **	any side effects.  Replacement text is saved away in a static **	buffer and returned. ** **	Parameters: **		mac -- the macro to spring. ** **	Returns: **		replacement text. ** **	Side Effects: **		Any side effects of the macro. ** **	Trace Flags: **		51 */
end_comment

begin_function
name|char
modifier|*
name|mcall
parameter_list|(
name|mac
parameter_list|)
name|char
modifier|*
name|mac
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
specifier|extern
name|char
name|macsget
parameter_list|()
function_decl|;
name|m
operator|=
name|mac
expr_stmt|;
ifdef|#
directive|ifdef
name|xMTR2
name|tTfp
argument_list|(
literal|51
argument_list|,
operator|-
literal|1
argument_list|,
literal|"mcall('%s')\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set up to process the macro */
name|macinit
argument_list|(
name|macsget
argument_list|,
operator|&
name|mac
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* process it -- throw away result */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|c
operator|=
name|macgetch
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|xMTR2
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|1
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|<
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

