begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<useful.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)mac.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_define
define|#
directive|define
name|TRACE
value|if (FALSE) printf
end_define

begin_comment
comment|/* **  MACRO PROCESSOR */
end_comment

begin_define
define|#
directive|define
name|ANYDELIM
value|'\020'
end_define

begin_comment
comment|/* \| -- zero or more delims */
end_comment

begin_define
define|#
directive|define
name|ONEDELIM
value|'\021'
end_define

begin_comment
comment|/* \^ -- exactly one delim */
end_comment

begin_define
define|#
directive|define
name|CHANGE
value|'\022'
end_define

begin_comment
comment|/* \& -- token change */
end_comment

begin_define
define|#
directive|define
name|PARAMN
value|'\023'
end_define

begin_comment
comment|/* $ -- non-preprocessed param */
end_comment

begin_define
define|#
directive|define
name|PARAMP
value|'\024'
end_define

begin_comment
comment|/* $$ -- preprocessed param */
end_comment

begin_define
define|#
directive|define
name|PRESCANENABLE
value|'@'
end_define

begin_comment
comment|/* character to enable prescan */
end_comment

begin_define
define|#
directive|define
name|LBRACE
value|'{'
end_define

begin_comment
comment|/* left brace */
end_comment

begin_define
define|#
directive|define
name|RBRACE
value|'}'
end_define

begin_comment
comment|/* right brace */
end_comment

begin_define
define|#
directive|define
name|BACKSLASH
value|'\\'
end_define

begin_comment
comment|/* backslash */
end_comment

begin_define
define|#
directive|define
name|LQUOTE
value|'`'
end_define

begin_comment
comment|/* left quote */
end_comment

begin_define
define|#
directive|define
name|RQUOTE
value|'\''
end_define

begin_comment
comment|/* right quote */
end_comment

begin_define
define|#
directive|define
name|SPACE
value|' '
end_define

begin_define
define|#
directive|define
name|TAB
value|'\t'
end_define

begin_define
define|#
directive|define
name|NEWLINE
value|'\n'
end_define

begin_define
define|#
directive|define
name|QUOTED
value|0200
end_define

begin_comment
comment|/* pass right through bit */
end_comment

begin_define
define|#
directive|define
name|CHARMASK
value|0177
end_define

begin_comment
comment|/* character part */
end_comment

begin_define
define|#
directive|define
name|BYTEMASK
value|0377
end_define

begin_comment
comment|/* one byte */
end_comment

begin_define
define|#
directive|define
name|ITERTHRESH
value|100
end_define

begin_comment
comment|/* iteration limit */
end_comment

begin_define
define|#
directive|define
name|NPRIMS
value|(sizeof Macprims / sizeof Macprims[0])
end_define

begin_comment
comment|/* token modes, used to compute token changes */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_comment
comment|/* guarantees a token change */
end_comment

begin_define
define|#
directive|define
name|ID
value|1
end_define

begin_comment
comment|/* identifier */
end_comment

begin_define
define|#
directive|define
name|NUMBER
value|2
end_define

begin_comment
comment|/* number (int or float) */
end_comment

begin_define
define|#
directive|define
name|DELIM
value|3
end_define

begin_comment
comment|/* delimiter, guarantees a token change */
end_comment

begin_define
define|#
directive|define
name|QUOTEMODE
value|4
end_define

begin_comment
comment|/* quoted construct */
end_comment

begin_define
define|#
directive|define
name|OP
value|5
end_define

begin_comment
comment|/* operator */
end_comment

begin_define
define|#
directive|define
name|NOCHANGE
value|6
end_define

begin_comment
comment|/* guarantees no token change */
end_comment

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_comment
comment|/* headers for buffer manip */
end_comment

begin_comment
comment|/* macro definitions */
end_comment

begin_struct
struct|struct
name|macro
block|{
name|struct
name|macro
modifier|*
name|nextm
decl_stmt|;
comment|/* pointer to next macro header */
name|char
modifier|*
name|template
decl_stmt|;
comment|/* pointer to macro template */
name|char
modifier|*
name|substitute
decl_stmt|;
comment|/* pointer to substitution text */
block|}
struct|;
end_struct

begin_comment
comment|/* primitive declarations */
end_comment

begin_decl_stmt
name|struct
name|macro
name|Macprims
index|[]
init|=
block|{
operator|&
name|Macprims
index|[
literal|1
index|]
block|,
literal|"{define;\020\024t;\020\024s}"
block|,
operator|(
name|char
operator|*
operator|)
literal|1
block|,
operator|&
name|Macprims
index|[
literal|2
index|]
block|,
literal|"{rawdefine;\020\024t;\020\024s}"
block|,
operator|(
name|char
operator|*
operator|)
literal|2
block|,
operator|&
name|Macprims
index|[
literal|3
index|]
block|,
literal|"{remove;\020\024t}"
block|,
operator|(
name|char
operator|*
operator|)
literal|3
block|,
operator|&
name|Macprims
index|[
literal|4
index|]
block|,
literal|"{dump}"
block|,
operator|(
name|char
operator|*
operator|)
literal|4
block|,
operator|&
name|Macprims
index|[
literal|5
index|]
block|,
literal|"{type\020\024m}"
block|,
operator|(
name|char
operator|*
operator|)
literal|5
block|,
operator|&
name|Macprims
index|[
literal|6
index|]
block|,
literal|"{read\020\024m}"
block|,
operator|(
name|char
operator|*
operator|)
literal|6
block|,
operator|&
name|Macprims
index|[
literal|7
index|]
block|,
literal|"{readdefine;\020\024n;\020\024m}"
block|,
operator|(
name|char
operator|*
operator|)
literal|7
block|,
operator|&
name|Macprims
index|[
literal|8
index|]
block|,
literal|"{ifsame;\020\024a;\020\024b;\020\023t;\020\023f}"
block|,
operator|(
name|char
operator|*
operator|)
literal|8
block|,
operator|&
name|Macprims
index|[
literal|9
index|]
block|,
literal|"{ifeq;\020\024a;\020\024b;\020\023t;\020\023f}"
block|,
operator|(
name|char
operator|*
operator|)
literal|9
block|,
operator|&
name|Macprims
index|[
literal|10
index|]
block|,
literal|"{ifgt;\020\024a;\020\024b;\020\023t;\020\023f}"
block|,
operator|(
name|char
operator|*
operator|)
literal|10
block|,
operator|&
name|Macprims
index|[
literal|11
index|]
block|,
literal|"{eval\020\024e}"
block|,
operator|(
name|char
operator|*
operator|)
literal|11
block|,
operator|&
name|Macprims
index|[
literal|12
index|]
block|,
literal|"{substr;\020\024f;\020\024t;\024s}"
block|,
operator|(
name|char
operator|*
operator|)
literal|12
block|,
operator|&
name|Macprims
index|[
literal|13
index|]
block|,
literal|"{dnl}"
block|,
operator|(
name|char
operator|*
operator|)
literal|13
block|,
operator|&
name|Macprims
index|[
literal|14
index|]
block|,
literal|"{remove}"
block|,
operator|(
name|char
operator|*
operator|)
literal|3
block|,
literal|0
block|,
literal|"{dump;\020\024n}"
block|,
operator|(
name|char
operator|*
operator|)
literal|4
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|macro
modifier|*
name|Machead
init|=
operator|&
name|Macprims
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of macro list */
end_comment

begin_comment
comment|/* parameters */
end_comment

begin_struct
struct|struct
name|param
block|{
name|struct
name|param
modifier|*
name|nextp
decl_stmt|;
name|char
name|mode
decl_stmt|;
name|char
name|name
decl_stmt|;
name|char
modifier|*
name|paramt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* the environment */
end_comment

begin_struct
struct|struct
name|env
block|{
name|struct
name|env
modifier|*
name|nexte
decl_stmt|;
comment|/* next environment */
name|int
function_decl|(
modifier|*
name|rawget
function_decl|)
parameter_list|()
function_decl|;
comment|/* raw character get routine */
name|char
modifier|*
modifier|*
name|rawpar
decl_stmt|;
comment|/* a parameter to that routine */
name|char
name|prevchar
decl_stmt|;
comment|/* previous character read */
name|char
name|tokenmode
decl_stmt|;
comment|/* current token mode */
name|char
name|change
decl_stmt|;
comment|/* token change flag */
name|char
name|eof
decl_stmt|;
comment|/* eof flag */
name|char
name|newline
decl_stmt|;
comment|/* set if bol */
name|char
name|rawnewline
decl_stmt|;
comment|/* same for raw input */
name|struct
name|buf
modifier|*
name|pbuf
decl_stmt|;
comment|/* peek buffer */
name|struct
name|buf
modifier|*
name|mbuf
decl_stmt|;
comment|/* macro buffer */
name|char
name|endtrap
decl_stmt|;
comment|/* endtrap flag */
name|char
name|pass
decl_stmt|;
comment|/* pass flag */
name|char
name|pdelim
decl_stmt|;
comment|/* current parameter delimiter */
name|struct
name|param
modifier|*
name|params
decl_stmt|;
comment|/* parameter list */
name|int
name|itercount
decl_stmt|;
comment|/* iteration count */
name|int
name|quotelevel
decl_stmt|;
comment|/* quote nesting level */
block|}
struct|;
end_struct

begin_comment
comment|/* current environment pointer */
end_comment

begin_decl_stmt
name|struct
name|env
modifier|*
name|Macenv
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  MACINIT -- initialize for macro processing ** **	*** EXTERNAL INTERFACE *** ** **	The macro processor is initialized.  Any crap left over from **	previous processing (which will never occur normally, but may **	happen on an interrupt, for instance) will be cleaned up.  The **	raw input is defined, and the 'endtrap' parameter tells whether **	this is "primary" processing or not; in other words, it tells **	whether to spring {begintrap} and {endtrap}. ** **	This routine must always be called prior to any processing. */
end_comment

begin_macro
name|macinit
argument_list|(
argument|rawget
argument_list|,
argument|rawpar
argument_list|,
argument|endtrap
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|rawget
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rawpar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|endtrap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|env
name|env
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|f
decl_stmt|;
comment|/* clear out old crap */
for|for
control|(
name|e
operator|=
name|Macenv
init|;
name|e
operator|!=
literal|0
condition|;
name|e
operator|=
name|f
control|)
block|{
name|bufpurge
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|macpflush
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|f
operator|=
name|e
operator|->
name|nexte
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|0
condition|)
name|buffree
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* set up the primary environment */
name|Macenv
operator|=
name|e
operator|=
operator|&
name|env
expr_stmt|;
name|clrmem
argument_list|(
name|e
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|rawget
operator|=
name|rawget
expr_stmt|;
name|e
operator|->
name|rawpar
operator|=
name|rawpar
expr_stmt|;
name|e
operator|->
name|endtrap
operator|=
name|endtrap
expr_stmt|;
name|e
operator|->
name|newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|endtrap
condition|)
name|macspring
argument_list|(
literal|"{begintrap}"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACGETCH -- get character after macro processing ** **	*** EXTERNAL INTERFACE ROUTINE *** ** **	The macro processor must have been previously initialized by a **	call to macinit(). */
end_comment

begin_macro
name|macgetch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get an input character */
name|c
operator|=
name|macgch
argument_list|()
expr_stmt|;
comment|/* check for end-of-file processing */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* check to see if we should spring {endtrap} */
if|if
condition|(
name|e
operator|->
name|endtrap
condition|)
block|{
name|e
operator|->
name|endtrap
operator|=
literal|0
expr_stmt|;
name|macspring
argument_list|(
literal|"{endtrap}"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* don't spring endtrap -- real end of file */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* not an end of file -- check for pass character through */
if|if
condition|(
name|e
operator|->
name|pass
condition|)
block|{
name|e
operator|->
name|pass
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|change
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|&
name|QUOTED
operator|)
operator|!=
literal|0
operator|||
operator|!
name|e
operator|->
name|change
operator|||
name|e
operator|->
name|tokenmode
operator|==
name|DELIM
condition|)
block|{
comment|/* the character is to be passed through */
comment|/* reset iteration count and purge macro buffer */
name|e
operator|->
name|itercount
operator|=
literal|0
expr_stmt|;
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|e
operator|->
name|newline
operator|=
operator|(
name|c
operator|==
name|NEWLINE
operator|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
name|CHARMASK
operator|)
return|;
block|}
comment|/* this character is a candidate for macro processing */
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
comment|/* check for infinite loop */
if|if
condition|(
name|e
operator|->
name|itercount
operator|>
name|ITERTHRESH
condition|)
block|{
name|printf
argument_list|(
literal|"Infinite loop in macro\n"
argument_list|)
expr_stmt|;
name|e
operator|->
name|pass
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* see if we have a macro match */
if|if
condition|(
name|macallscan
argument_list|()
condition|)
block|{
comment|/* yep -- count iterations and rescan it */
name|e
operator|->
name|itercount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* nope -- pass the next token through raw */
name|e
operator|->
name|pass
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACGCH -- get input character, knowing about tokens ** **	The next input character is returned.  In addition, the quote **	level info is maintained and the QUOTED bit is set if the **	returned character is (a) quoted or (b) backslash escaped. **	As a side effect the change flag is maintained.  Also, the **	character is saved in mbuf. */
end_comment

begin_macro
name|macgch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get virtual raw character, save in mbuf, and set change */
name|c
operator|=
name|macfetch
argument_list|(
name|e
operator|->
name|quotelevel
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* test for magic frotz */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* end of file */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|LQUOTE
case|:
if|if
condition|(
name|e
operator|->
name|quotelevel
operator|++
operator|==
literal|0
condition|)
continue|continue;
break|break;
case|case
name|RQUOTE
case|:
if|if
condition|(
name|e
operator|->
name|quotelevel
operator|==
literal|0
condition|)
return|return
operator|(
name|c
operator|)
return|;
if|if
condition|(
operator|--
name|e
operator|->
name|quotelevel
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
break|break;
case|case
name|BACKSLASH
case|:
if|if
condition|(
name|e
operator|->
name|quotelevel
operator|>
literal|0
condition|)
break|break;
name|c
operator|=
name|macfetch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* handle special cases */
if|if
condition|(
name|c
operator|==
name|e
operator|->
name|pdelim
condition|)
break|break;
comment|/* do translations */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SPACE
case|:
comment|/* space */
case|case
name|TAB
case|:
comment|/* tab */
case|case
name|NEWLINE
case|:
comment|/* newline */
case|case
name|RQUOTE
case|:
case|case
name|LQUOTE
case|:
case|case
literal|'$'
case|:
case|case
name|LBRACE
case|:
case|case
name|RBRACE
case|:
case|case
name|BACKSLASH
case|:
break|break;
default|default:
comment|/* take character as is (unquoted) */
name|c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
break|break;
comment|/* not an escapable character -- treat it normally */
name|macunget
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|BACKSLASH
expr_stmt|;
comment|/* do default character processing on backslash */
default|default:
if|if
condition|(
name|e
operator|->
name|quotelevel
operator|>
literal|0
condition|)
break|break;
return|return
operator|(
name|c
operator|)
return|;
block|}
comment|/* the character is quoted */
return|return
operator|(
name|c
operator||
name|QUOTED
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACFETCH -- fetch virtual raw character ** **	A character is fetched from the peek buffer.  If that buffer is **	empty, it is fetched from the raw input.  The character is then **	saved away, and the change flag is set accordingly. **	The QUOTED bit on the character is set if the 'quote' flag **	parameter is set; used for backslash escapes. **	Note that the QUOTED bit appears only on the character which **	goes into the macro buffer; the character returned is normal. */
end_comment

begin_macro
name|macfetch
argument_list|(
argument|quote
argument_list|)
end_macro

begin_decl_stmt
name|int
name|quote
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|escapech
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|escapech
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get character from peek buffer */
name|c
operator|=
name|bufget
argument_list|(
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* peek buffer is empty */
comment|/* check for already raw eof */
if|if
condition|(
operator|!
name|e
operator|->
name|eof
condition|)
block|{
comment|/* note that c must be int so that the QUOTED bit is not negative */
name|c
operator|=
call|(
modifier|*
name|e
operator|->
name|rawget
call|)
argument_list|(
name|e
operator|->
name|rawpar
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|eof
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|rawnewline
condition|)
name|e
operator|->
name|prevchar
operator|=
name|NEWLINE
expr_stmt|;
name|e
operator|->
name|rawnewline
operator|=
operator|(
name|c
operator|==
name|NEWLINE
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* test for escapable character */
if|if
condition|(
name|escapech
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'t'
case|:
comment|/* become quoted tab */
name|c
operator|=
name|TAB
operator||
name|QUOTED
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* become quoted newline */
name|c
operator|=
name|NEWLINE
operator||
name|QUOTED
expr_stmt|;
break|break;
default|default:
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|c
operator|=
name|BACKSLASH
expr_stmt|;
block|}
name|escapech
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
name|BACKSLASH
condition|)
block|{
name|escapech
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
comment|/* quote the character if appropriate to mask change flag */
comment|/* ('escapech' now becomes the maybe quoted character) */
name|escapech
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|quote
operator|&&
name|c
operator|!=
literal|0
condition|)
name|escapech
operator||=
name|QUOTED
expr_stmt|;
comment|/* set change flag */
name|macschng
argument_list|(
name|escapech
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
comment|/* save the character in the macro buffer */
name|bufput
argument_list|(
name|escapech
argument_list|,
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACSCHNG -- set change flag and compute token type ** **	The change flag and token type is set.  This does some tricky **	stuff to determine just when a new token begins.  Most notably, **	notice that quoted stuff IS scanned, but the change flag is **	reset in a higher level routine so that quoted stuff looks **	like a single token, but any begin/end quote causes a token **	change. */
end_comment

begin_macro
name|macschng
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|thismode
decl_stmt|;
name|int
name|changeflag
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|c
operator|=
name|ch
expr_stmt|;
name|changeflag
operator|=
literal|0
expr_stmt|;
name|thismode
operator|=
name|macmode
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|tokenmode
condition|)
block|{
case|case
name|NONE
case|:
comment|/* always cause token change */
break|break;
case|case
name|QUOTEMODE
case|:
comment|/* change only on initial entry to quotes */
break|break;
case|case
name|DELIM
case|:
name|changeflag
operator|++
expr_stmt|;
break|break;
case|case
name|ID
case|:
comment|/* take any sequence of letters and numerals */
if|if
condition|(
name|thismode
operator|==
name|NUMBER
condition|)
name|thismode
operator|=
name|ID
expr_stmt|;
break|break;
case|case
name|NUMBER
case|:
comment|/* take string of digits and decimal points */
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|thismode
operator|=
name|NUMBER
expr_stmt|;
break|break;
case|case
name|OP
case|:
switch|switch
condition|(
name|e
operator|->
name|prevchar
condition|)
block|{
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'!'
case|:
if|if
condition|(
name|c
operator|!=
literal|'='
condition|)
name|changeflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|c
operator|!=
literal|'/'
condition|)
name|changeflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|changeflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|thismode
operator|==
name|NUMBER
condition|)
name|e
operator|->
name|tokenmode
operator|=
name|thismode
expr_stmt|;
break|break;
default|default:
name|changeflag
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NOCHANGE
case|:
comment|/* never cause token change */
name|e
operator|->
name|tokenmode
operator|=
name|thismode
expr_stmt|;
break|break;
block|}
name|e
operator|->
name|prevchar
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|thismode
operator|!=
name|e
operator|->
name|tokenmode
condition|)
name|changeflag
operator|++
expr_stmt|;
name|e
operator|->
name|tokenmode
operator|=
name|thismode
expr_stmt|;
name|e
operator|->
name|change
operator|=
name|changeflag
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACMODE -- return mode of a character */
end_comment

begin_macro
name|macmode
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|c
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|QUOTED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|QUOTEMODE
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
condition|)
return|return
operator|(
name|ID
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|NUMBER
operator|)
return|;
if|if
condition|(
name|c
operator|==
name|SPACE
operator|||
name|c
operator|==
name|TAB
operator|||
name|c
operator|==
name|NEWLINE
condition|)
return|return
operator|(
name|DELIM
operator|)
return|;
return|return
operator|(
name|OP
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACALLSCAN -- scan to see if input matches a macro ** **	Returns true if there was a match, false if not.  In any case, **	the virtual raw input (i.e., the peek buffer) will contain **	either the old raw input, or the substituted macro. */
end_comment

begin_macro
name|macallscan
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|Machead
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|nextm
control|)
block|{
comment|/* check to see if it matches this macro */
if|if
condition|(
name|macscan
argument_list|(
name|m
argument_list|)
condition|)
block|{
comment|/* it does -- substituted value is in mbuf */
name|macrescan
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* it doesn't match this macro -- try the next one */
name|macrescan
argument_list|()
expr_stmt|;
block|}
comment|/* it doesn't match any of them -- tough luck */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACSCAN -- scan a single macro for a match ** **	As is scans it also collects parameters for possible future **	substitution.  If it finds a match, it takes responsibility **	for doing the substitution. */
end_comment

begin_macro
name|macscan
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|macro
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|char
name|pname
decl_stmt|,
name|pdelim
decl_stmt|;
name|m
operator|=
name|mac
expr_stmt|;
comment|/* check for anchored mode */
name|temp
operator|=
name|m
operator|->
name|template
expr_stmt|;
if|if
condition|(
operator|*
name|temp
operator|==
name|ONEDELIM
condition|)
block|{
if|if
condition|(
operator|!
name|Macenv
operator|->
name|newline
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|temp
operator|++
expr_stmt|;
block|}
comment|/* scan the template */
for|for
control|(
init|;
name|c
operator|=
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|PARAMN
operator|||
name|c
operator|==
name|PARAMP
condition|)
block|{
comment|/* we have a parameter */
name|pname
operator|=
operator|*
operator|++
name|temp
expr_stmt|;
name|pdelim
operator|=
operator|*
operator|++
name|temp
expr_stmt|;
if|if
condition|(
name|macparam
argument_list|(
name|c
argument_list|,
name|pname
argument_list|,
name|pdelim
argument_list|)
condition|)
block|{
comment|/* parameter ok */
continue|continue;
block|}
comment|/* failure on parameter scan */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|macmatch
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* failure on literal match */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* it matches!!  substitute the macro */
name|macsubs
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACPARAM -- collect a parameter ** **	The parameter is collected and stored away "somewhere" with **	name 'name'.  The delimiter is taken to be 'delim'.  'Mode' **	tells whether to prescan the parameter (done immediately before **	substitute time to avoid side effects if the macro actually **	turns out to not match). */
end_comment

begin_macro
name|macparam
argument_list|(
argument|mode
argument_list|,
argument|name
argument_list|,
argument|delim
argument_list|)
end_macro

begin_decl_stmt
name|char
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|delim
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|param
modifier|*
name|p
decl_stmt|;
name|int
name|bracecount
decl_stmt|;
specifier|extern
name|char
modifier|*
name|bufalloc
argument_list|()
decl_stmt|,
modifier|*
name|bufcrunch
argument_list|()
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|pdelim
operator|=
name|delim
expr_stmt|;
name|TRACE
argument_list|(
literal|"\nmacparam(%d, %c, %c):\n"
argument_list|,
name|mode
argument_list|,
name|name
argument_list|,
name|delim
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PARAMP
condition|)
block|{
comment|/* check for REALLY prescan */
name|c
operator|=
name|macgch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|PRESCANENABLE
condition|)
block|{
name|mode
operator|=
name|PARAMN
expr_stmt|;
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bracecount
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|tokenmode
operator|=
name|NOCHANGE
expr_stmt|;
while|while
condition|(
operator|!
name|macmatch
argument_list|(
name|delim
argument_list|)
condition|)
block|{
do|do
block|{
name|c
operator|=
name|macgch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
name|NEWLINE
condition|)
block|{
name|e
operator|->
name|pdelim
operator|=
literal|0
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"macparam fails\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|LBRACE
condition|)
name|bracecount
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|RBRACE
operator|&&
name|bracecount
operator|>
literal|0
condition|)
name|bracecount
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|bracecount
operator|>
literal|0
condition|)
do|;
block|}
name|e
operator|->
name|pdelim
operator|=
literal|0
expr_stmt|;
comment|/* allocate and store the parameter */
name|p
operator|=
operator|(
expr|struct
name|param
operator|*
operator|)
name|bufalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|nextp
operator|=
name|e
operator|->
name|params
expr_stmt|;
name|e
operator|->
name|params
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|paramt
operator|=
name|bufcrunch
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"macparam: |%s|\n"
argument_list|,
name|p
operator|->
name|paramt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACMATCH -- test for a match between template character and input. ** **	The parameter is the character from the template to match on. **	The input is read.  The template character may be a meta- **	character.  In all cases if the match occurs the input is **	thrown away; if no match occurs the input is left unchanged. ** **	Return value is true for a match, false for no match. */
end_comment

begin_macro
name|macmatch
argument_list|(
argument|template
argument_list|)
end_macro

begin_decl_stmt
name|char
name|template
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|t
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|t
operator|=
name|template
expr_stmt|;
name|TRACE
argument_list|(
literal|"\tmacmatch(%c)"
argument_list|,
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ANYDELIM
case|:
comment|/* match zero or more delimiters */
comment|/* chew and chuck delimiters */
while|while
condition|(
name|macdelim
argument_list|()
condition|)
empty_stmt|;
comment|/* as a side effect, must match a token change */
if|if
condition|(
operator|!
name|macckch
argument_list|()
condition|)
block|{
name|TRACE
argument_list|(
literal|" fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TRACE
argument_list|(
literal|" succeed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|ONEDELIM
case|:
comment|/* match exactly one delimiter */
name|TRACE
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|macdelim
argument_list|()
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
case|case
name|CHANGE
case|:
comment|/* match a token change */
case|case
literal|0
case|:
comment|/* end of template */
name|TRACE
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|macckch
argument_list|()
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
default|default:
comment|/* must have exact character match */
name|c
operator|=
name|macgch
argument_list|()
expr_stmt|;
name|TRACE
argument_list|(
literal|" against %c "
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|t
condition|)
block|{
name|TRACE
argument_list|(
literal|"succeed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* failure */
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACDELIM -- test for next input character a delimiter ** **	Returns true if the next input character is a delimiter, false **	otherwise.  Delimiters are chewed. */
end_comment

begin_macro
name|macdelim
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|c
operator|=
name|macgch
argument_list|()
expr_stmt|;
name|TRACE
argument_list|(
literal|"\t\tmacdelim against %c: "
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|macmode
argument_list|(
name|c
argument_list|)
operator|==
name|DELIM
condition|)
block|{
name|TRACE
argument_list|(
literal|"succeed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACCKCH -- check for token change ** **	Returns true if a token change occurs between this and the next **	character.  No characters are ever chewed, however, the token **	change (if it exists) is always chewed. */
end_comment

begin_macro
name|macckch
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|change
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|tokenmode
operator|==
name|NONE
condition|)
block|{
comment|/* then last character has been ungotten: take old change */
name|change
operator|=
name|e
operator|->
name|change
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|macgch
argument_list|()
expr_stmt|;
name|change
operator|=
name|Macenv
operator|->
name|change
expr_stmt|;
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|TRACE
argument_list|(
literal|"macckch got %c ret %d\n"
argument_list|,
name|c
argument_list|,
name|change
argument_list|)
expr_stmt|;
comment|/* chew the change and return */
name|e
operator|->
name|tokenmode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
name|change
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACSUBS -- substitute in macro substitution ** **	This routine prescans appropriate parameters and then either **	loads the substitution into the macro buffer or calls the **	correct primitive routine. */
end_comment

begin_macro
name|macsubs
argument_list|(
argument|mac
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|macro
modifier|*
name|mac
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|param
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|macprim
parameter_list|()
function_decl|;
name|e
operator|=
name|Macenv
expr_stmt|;
for|for
control|(
name|p
operator|=
name|e
operator|->
name|params
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
comment|/* check to see if we should prescan */
if|if
condition|(
name|p
operator|->
name|mode
operator|!=
name|PARAMP
condition|)
block|{
continue|continue;
block|}
comment|/* prescan parameter */
name|macprescan
argument_list|(
operator|&
name|p
operator|->
name|paramt
argument_list|)
expr_stmt|;
name|p
operator|->
name|mode
operator|=
name|PARAMN
expr_stmt|;
block|}
name|s
operator|=
name|mac
operator|->
name|substitute
expr_stmt|;
comment|/* clear out the macro call */
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<=
operator|(
name|char
operator|*
operator|)
name|NPRIMS
condition|)
block|{
comment|/* it is a primitive */
name|macload
argument_list|(
name|macprim
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it is a user-defined macro */
name|macload
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACPRESCAN -- prescan a parameter ** **	The parameter pointed to by 'pp' is fed once through the macro **	processor and replaced with the new version. */
end_comment

begin_macro
name|macprescan
argument_list|(
argument|pp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|extern
name|int
name|macsget
parameter_list|()
function_decl|;
name|b
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* set up a new environment */
name|macnewev
argument_list|(
name|macsget
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
comment|/* scan the parameter */
while|while
condition|(
operator|(
name|c
operator|=
name|macgetch
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* free the old parameter */
name|buffree
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* move in the new one */
operator|*
name|pp
operator|=
name|bufcrunch
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* restore the old environment */
name|macpopev
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACNEWEV -- set up new environment ** **	Parameters are raw get routine and parameter */
end_comment

begin_macro
name|macnewev
argument_list|(
argument|rawget
argument_list|,
argument|rawpar
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|rawget
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rawpar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|extern
name|char
modifier|*
name|bufalloc
parameter_list|()
function_decl|;
name|e
operator|=
operator|(
expr|struct
name|env
operator|*
operator|)
name|bufalloc
argument_list|(
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|rawget
operator|=
name|rawget
expr_stmt|;
name|e
operator|->
name|rawpar
operator|=
name|rawpar
expr_stmt|;
name|e
operator|->
name|nexte
operator|=
name|Macenv
expr_stmt|;
name|e
operator|->
name|newline
operator|=
literal|1
expr_stmt|;
name|Macenv
operator|=
name|e
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACPOPEV -- pop an environment ** **	Makes sure all buffers and stuff are purged */
end_comment

begin_macro
name|macpopev
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|macpflush
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Macenv
operator|=
name|e
operator|->
name|nexte
expr_stmt|;
name|buffree
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACPFLUSH -- flush all parameters ** **	Used to deallocate all parameters in a given environment. */
end_comment

begin_macro
name|macpflush
argument_list|(
argument|env
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|env
modifier|*
name|env
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|struct
name|param
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|param
modifier|*
name|q
decl_stmt|;
name|e
operator|=
name|env
expr_stmt|;
for|for
control|(
name|p
operator|=
name|e
operator|->
name|params
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|q
control|)
block|{
name|buffree
argument_list|(
name|p
operator|->
name|paramt
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
name|buffree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|params
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACSGET -- get from string ** **	Works like a getchar from a string.  Used by macprescan(). **	The parameter is a pointer to the string. */
end_comment

begin_macro
name|macsget
argument_list|(
argument|pp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
name|c
operator|=
operator|*
operator|*
name|p
operator|&
name|BYTEMASK
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACLOAD -- load a string into the macro buffer ** **	The parameters are a pointer to a string to be appended to **	the macro buffer and a flag telling whether parameter substi- **	tution can occur. */
end_comment

begin_macro
name|macload
argument_list|(
argument|str
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|macplkup
parameter_list|()
function_decl|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|PARAMN
condition|)
name|macload
argument_list|(
name|macplkup
argument_list|(
operator|*
name|s
operator|++
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|bufput
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|,
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACRESCAN -- rescan the macro buffer ** **	Copies the macro buffer into the peek buffer so that it will be **	reread.  Also deallocates any parameters which may happen to be **	stored away. */
end_comment

begin_macro
name|macrescan
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|bufget
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
operator|&
name|CHARMASK
operator|)
operator|!=
literal|0
condition|)
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|e
operator|->
name|quotelevel
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|tokenmode
operator|=
name|NONE
expr_stmt|;
name|macpflush
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACUNGET -- unget a character ** **	Moves one character from the macro buffer to the peek buffer. **	If 'mask' is set, the character has the quote bit stripped off. */
end_comment

begin_macro
name|macunget
argument_list|(
argument|mask
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|prevchar
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|bufget
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|c
operator|&=
name|CHARMASK
expr_stmt|;
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|e
operator|->
name|tokenmode
operator|=
name|NONE
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACPLKUP -- look up parameter ** **	Returns a pointer to the named parameter.  Returns null **	if the parameter is not found ("cannot happen"). */
end_comment

begin_function
name|char
modifier|*
name|macplkup
parameter_list|(
name|name
parameter_list|)
name|char
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|param
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|Macenv
operator|->
name|params
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
if|if
condition|(
name|p
operator|->
name|name
operator|==
name|name
condition|)
return|return
operator|(
name|p
operator|->
name|paramt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MACSPRING -- spring a trap ** **	The named trap is sprung, in other words, if the named macro is **	defined it is called, otherwise there is no replacement text. */
end_comment

begin_macro
name|macspring
argument_list|(
argument|trap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|trap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|macro
parameter_list|()
function_decl|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
comment|/* fetch the macro */
name|p
operator|=
name|macro
argument_list|(
name|trap
argument_list|)
expr_stmt|;
comment|/* if not defined, don't bother */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
comment|/* load the trap */
name|macload
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* insert a newline after the trap */
name|bufput
argument_list|(
literal|'\n'
argument_list|,
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|macrescan
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACPRIM -- do primitives ** **	The parameter is the primitive to execute. */
end_comment

begin_function
name|char
modifier|*
name|macprim
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|extern
name|char
modifier|*
name|macplkup
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|macsstr
parameter_list|()
function_decl|;
name|e
operator|=
name|Macenv
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
comment|/* {define; $t; $s} */
name|macdnl
argument_list|()
expr_stmt|;
name|macdefine
argument_list|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
argument_list|,
name|macplkup
argument_list|(
literal|'s'
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* {rawdefine; $t; $s} */
name|macdnl
argument_list|()
expr_stmt|;
name|macdefine
argument_list|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
argument_list|,
name|macplkup
argument_list|(
literal|'s'
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* {remove $t} */
name|macdnl
argument_list|()
expr_stmt|;
name|macremove
argument_list|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* {dump} */
comment|/* {dump; $n} */
name|macdnl
argument_list|()
expr_stmt|;
name|macdump
argument_list|(
name|macplkup
argument_list|(
literal|'n'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* {type $m} */
name|macdnl
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|macplkup
argument_list|(
literal|'m'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* {read $m} */
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|macplkup
argument_list|(
literal|'m'
argument_list|)
argument_list|)
expr_stmt|;
name|macread
argument_list|()
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* {read; $n; $m} */
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|macplkup
argument_list|(
literal|'m'
argument_list|)
argument_list|)
expr_stmt|;
name|macread
argument_list|()
expr_stmt|;
name|macdefine
argument_list|(
name|macplkup
argument_list|(
literal|'n'
argument_list|)
argument_list|,
name|bufcrunch
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"{readcount}"
operator|)
return|;
case|case
literal|8
case|:
comment|/* {ifsame; $a; $b; $t; $f} */
if|if
condition|(
name|sequal
argument_list|(
name|macplkup
argument_list|(
literal|'a'
argument_list|)
argument_list|,
name|macplkup
argument_list|(
literal|'b'
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|macplkup
argument_list|(
literal|'f'
argument_list|)
operator|)
return|;
case|case
literal|9
case|:
comment|/* {ifeq; $a; $b; $t; $f} */
if|if
condition|(
name|macnumber
argument_list|(
name|macplkup
argument_list|(
literal|'a'
argument_list|)
argument_list|)
operator|==
name|macnumber
argument_list|(
name|macplkup
argument_list|(
literal|'b'
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|macplkup
argument_list|(
literal|'f'
argument_list|)
operator|)
return|;
case|case
literal|10
case|:
comment|/* {ifgt; $a; $b; $t; $f} */
if|if
condition|(
name|macnumber
argument_list|(
name|macplkup
argument_list|(
literal|'a'
argument_list|)
argument_list|)
operator|>
name|macnumber
argument_list|(
name|macplkup
argument_list|(
literal|'b'
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|macplkup
argument_list|(
literal|'f'
argument_list|)
operator|)
return|;
case|case
literal|12
case|:
comment|/* {substr; $f; $t; $s} */
return|return
operator|(
name|macsstr
argument_list|(
name|macnumber
argument_list|(
name|macplkup
argument_list|(
literal|'f'
argument_list|)
argument_list|)
argument_list|,
name|macnumber
argument_list|(
name|macplkup
argument_list|(
literal|'t'
argument_list|)
argument_list|)
argument_list|,
name|macplkup
argument_list|(
literal|'s'
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|13
case|:
comment|/* {dnl} */
name|macdnl
argument_list|()
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"macro: bad primitive %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MACDNL -- delete to newline ** **	Used in general after macro definitions to avoid embarrassing **	newlines.  Just reads input until a newline character, and **	then throws it away. */
end_comment

begin_macro
name|macdnl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|macgch
argument_list|()
operator|)
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|NEWLINE
condition|)
empty_stmt|;
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACDEFINE -- define primitive ** **	This function defines a macro.  The parameters are the **	template, the substitution string, and a flag telling whether **	this is a raw define or not.  Syntax checking is done. */
end_comment

begin_macro
name|macdefine
argument_list|(
argument|template
argument_list|,
argument|subs
argument_list|,
argument|raw
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|template
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|subs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|raw
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
name|char
name|paramdefined
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
name|d
decl_stmt|;
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|extern
name|int
name|macsget
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|bufalloc
argument_list|()
decl_stmt|,
modifier|*
name|bufcrunch
argument_list|()
decl_stmt|;
name|char
modifier|*
name|mactcvt
parameter_list|()
function_decl|;
name|int
name|escapech
decl_stmt|;
comment|/* remove any old macro definition */
name|macremove
argument_list|(
name|template
argument_list|)
expr_stmt|;
comment|/* get a new environment */
name|macnewev
argument_list|(
name|macsget
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
comment|/* undefine all parameters */
name|clrmem
argument_list|(
name|paramdefined
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* avoid an initial token change */
name|e
operator|->
name|tokenmode
operator|=
name|NOCHANGE
expr_stmt|;
name|escapech
operator|=
literal|1
expr_stmt|;
comment|/* allocate macro header and template */
name|m
operator|=
operator|(
expr|struct
name|macro
operator|*
operator|)
name|bufalloc
argument_list|(
sizeof|sizeof
expr|*
name|m
argument_list|)
expr_stmt|;
comment|/* scan and convert template, collect available parameters */
name|p
operator|=
name|template
expr_stmt|;
name|m
operator|->
name|template
operator|=
name|mactcvt
argument_list|(
name|raw
argument_list|,
name|paramdefined
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|template
operator|==
literal|0
condition|)
block|{
comment|/* some sort of syntax error */
name|buffree
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|macpopev
argument_list|()
expr_stmt|;
return|return;
block|}
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bufflush
argument_list|(
operator|&
name|e
operator|->
name|pbuf
argument_list|)
expr_stmt|;
name|e
operator|->
name|eof
operator|=
literal|0
expr_stmt|;
comment|/* scan substitute string */
for|for
control|(
name|p
operator|=
name|subs
init|;
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'$'
condition|)
block|{
comment|/* substitute non-parameters literally */
name|bufput
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* it's a parameter */
name|bufput
argument_list|(
name|PARAMN
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* check to see if name is supplied */
if|if
condition|(
name|paramdefined
index|[
name|c
index|]
operator|==
literal|0
condition|)
block|{
comment|/* nope, it's not */
name|printf
argument_list|(
literal|"define: parameter %c referenced but not defined\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|buffree
argument_list|(
name|m
operator|->
name|template
argument_list|)
expr_stmt|;
name|buffree
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|macpopev
argument_list|()
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return;
block|}
name|bufput
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* allocate substitution string */
name|m
operator|->
name|substitute
operator|=
name|bufcrunch
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* allocate it as a macro */
name|m
operator|->
name|nextm
operator|=
name|Machead
expr_stmt|;
name|Machead
operator|=
name|m
expr_stmt|;
comment|/* finished... */
name|macpopev
argument_list|()
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACTCVT -- convert template to internal form ** **	Converts the template from external form to internal form. ** **	Parameters: **	raw -- set if only raw type conversion should take place. **	paramdefined -- a map of flags to determine declaration of **		parameters, etc.  If zero, no parameters are allowed. ** **	Return value: **	A character pointer off into mystic space. ** **	The characters of the template are read using macfetch, so **	a new environment should be created which will arrange to **	get this. */
end_comment

begin_function
name|char
modifier|*
name|mactcvt
parameter_list|(
name|raw
parameter_list|,
name|paramdefined
parameter_list|)
name|int
name|raw
decl_stmt|;
name|char
name|paramdefined
index|[
literal|128
index|]
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
name|d
decl_stmt|;
specifier|register
name|int
name|escapech
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|b
operator|=
literal|0
expr_stmt|;
name|escapech
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* parameter */
if|if
condition|(
name|escapech
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"define: every parameter needs a delimiter\n"
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* skip delimiters before parameter in non-raw */
if|if
condition|(
name|Macenv
operator|->
name|change
operator|&&
operator|!
name|escapech
operator|&&
operator|!
name|raw
condition|)
name|bufput
argument_list|(
name|ANYDELIM
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|escapech
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
name|PARAMN
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
comment|/* prescanned parameter */
name|d
operator|=
name|PARAMP
expr_stmt|;
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* process parameter name */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* no parameter name */
name|printf
argument_list|(
literal|"define: null parameter name\n"
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bufput
argument_list|(
name|d
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|escapech
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* check for legal parameter */
if|if
condition|(
name|paramdefined
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|paramdefined
index|[
name|c
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"define: parameter %c redeclared\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|paramdefined
index|[
name|c
index|]
operator|++
expr_stmt|;
comment|/* get parameter delimiter */
break|break;
case|case
name|BACKSLASH
case|:
comment|/* a backslash escape */
name|escapech
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'|'
case|:
name|c
operator|=
name|ANYDELIM
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|c
operator|=
name|ONEDELIM
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|c
operator|=
name|CHANGE
expr_stmt|;
break|break;
default|default:
name|escapech
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|BACKSLASH
expr_stmt|;
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NEWLINE
operator||
name|QUOTED
case|:
case|case
name|TAB
operator||
name|QUOTED
case|:
case|case
name|SPACE
operator||
name|QUOTED
case|:
if|if
condition|(
name|escapech
operator|<
literal|0
condition|)
name|c
operator|&=
name|CHARMASK
expr_stmt|;
name|escapech
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* change delimiters to ANYDELIM */
if|if
condition|(
name|macmode
argument_list|(
name|c
argument_list|)
operator|==
name|DELIM
operator|&&
operator|!
name|raw
condition|)
block|{
while|while
condition|(
name|macmode
argument_list|(
name|c
operator|=
name|macfetch
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|==
name|DELIM
condition|)
empty_stmt|;
name|macunget
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
name|ONEDELIM
expr_stmt|;
else|else
name|c
operator|=
name|ANYDELIM
expr_stmt|;
name|escapech
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Macenv
operator|->
name|change
operator|&&
operator|!
name|escapech
condition|)
block|{
name|bufput
argument_list|(
name|ANYDELIM
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|escapech
operator|<
literal|0
condition|)
block|{
comment|/* parameter: don't allow quoted delimiters */
name|c
operator|&=
name|CHARMASK
expr_stmt|;
block|}
name|escapech
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|escapech
operator|<=
literal|0
condition|)
name|bufput
argument_list|(
name|CHANGE
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|p
operator|=
name|bufcrunch
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
literal|"mactcvt: '%s'\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MACREMOVE -- remove macro ** **	The named macro is looked up.  If it is found it is removed **	from the macro list. */
end_comment

begin_macro
name|macremove
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|macro
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|extern
name|int
name|macsget
parameter_list|()
function_decl|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cname
decl_stmt|;
name|struct
name|macro
modifier|*
name|macmlkup
parameter_list|()
function_decl|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
block|{
comment|/* convert name to internal format */
name|macnewev
argument_list|(
name|macsget
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
name|cname
operator|=
name|mactcvt
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macpopev
argument_list|()
expr_stmt|;
if|if
condition|(
name|cname
operator|==
literal|0
condition|)
block|{
comment|/* some sort of syntax error */
return|return;
block|}
block|}
comment|/* find macro */
while|while
condition|(
name|name
operator|==
literal|0
condition|?
operator|(
operator|(
name|m
operator|=
name|Machead
operator|)
operator|->
name|substitute
operator|>
operator|(
name|char
operator|*
operator|)
name|NPRIMS
operator|)
else|:
operator|(
operator|(
name|m
operator|=
name|macmlkup
argument_list|(
name|cname
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* remove macro from list */
name|mp
operator|=
operator|&
name|Machead
expr_stmt|;
comment|/* find it's parent */
while|while
condition|(
operator|*
name|mp
operator|!=
name|m
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|nextm
expr_stmt|;
comment|/* remove macro from list */
operator|*
name|mp
operator|=
name|m
operator|->
name|nextm
expr_stmt|;
name|buffree
argument_list|(
name|m
operator|->
name|template
argument_list|)
expr_stmt|;
name|buffree
argument_list|(
name|m
operator|->
name|substitute
argument_list|)
expr_stmt|;
name|buffree
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|buffree
argument_list|(
name|cname
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACMLKUP -- look up macro ** **	The named macro is looked up and a pointer to the macro header **	is returned.  Zero is returned if the macro is not found. **	The name must be in internal form. */
end_comment

begin_function
name|struct
name|macro
modifier|*
name|macmlkup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|name
expr_stmt|;
comment|/* scan the macro list for it */
for|for
control|(
name|m
operator|=
name|Machead
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|nextm
control|)
block|{
if|if
condition|(
name|macmmatch
argument_list|(
name|n
argument_list|,
name|m
operator|->
name|template
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|m
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MACMMATCH -- check for macro name match ** **	The given 'name' and 'temp' are compared for equality.  If they **	match true is returned, else false. **	Both must be converted to internal format before the call is **	given. ** **	"Match" is defined as two macros which might scan as equal. ** **	'Flag' is set to indicate that the macros must match exactly, **	that is, neither may have any parameters and must end with both **	at end-of-template.  This mode is used for getting traps and **	such. */
end_comment

begin_macro
name|macmmatch
argument_list|(
argument|name
argument_list|,
argument|temp
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|temp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|ac
decl_stmt|;
specifier|register
name|char
name|bc
decl_stmt|;
name|char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|ap
operator|=
name|name
expr_stmt|;
name|bp
operator|=
name|temp
expr_stmt|;
comment|/* scan character by character */
for|for
control|(
init|;
condition|;
name|ap
operator|++
operator|,
name|bp
operator|++
control|)
block|{
name|ac
operator|=
operator|*
name|ap
expr_stmt|;
name|bc
operator|=
operator|*
name|bp
expr_stmt|;
name|TRACE
argument_list|(
literal|"macmmatch: ac=%c/%u, bc=%c/%u\n"
argument_list|,
name|ac
argument_list|,
name|ap
argument_list|,
name|bc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|==
name|ANYDELIM
condition|)
block|{
if|if
condition|(
name|macmmchew
argument_list|(
operator|&
name|ap
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
switch|switch
condition|(
name|ac
condition|)
block|{
case|case
name|SPACE
case|:
case|case
name|NEWLINE
case|:
case|case
name|TAB
case|:
if|if
condition|(
name|ac
operator|==
name|bc
operator|||
name|bc
operator|==
name|ONEDELIM
condition|)
continue|continue;
break|break;
case|case
name|ONEDELIM
case|:
if|if
condition|(
name|ac
operator|==
name|bc
operator|||
name|macmode
argument_list|(
name|bc
argument_list|)
operator|==
name|DELIM
condition|)
continue|continue;
break|break;
case|case
name|ANYDELIM
case|:
if|if
condition|(
name|macmmchew
argument_list|(
operator|&
name|bp
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|PARAMP
case|:
case|case
name|PARAMN
case|:
case|case
literal|0
case|:
if|if
condition|(
name|bc
operator|==
name|PARAMN
operator|||
name|bc
operator|==
name|PARAMP
operator|||
name|bc
operator|==
literal|0
operator|||
name|bc
operator|==
name|ANYDELIM
operator|||
name|bc
operator|==
name|ONEDELIM
operator|||
name|bc
operator|==
name|CHANGE
operator|||
name|macmode
argument_list|(
name|bc
argument_list|)
operator|==
name|DELIM
condition|)
block|{
comment|/* success */
if|if
condition|(
operator|!
name|flag
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ac
operator|==
literal|0
operator|&&
name|bc
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|ac
operator|==
name|bc
condition|)
continue|continue;
break|break;
block|}
block|}
comment|/* failure */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACMMCHEW -- chew nonspecific match characters ** **	The pointer passed as parameter is scanned so as to skip over **	delimiters and pseudocharacters. **	At least one character must match. */
end_comment

begin_macro
name|macmmchew
argument_list|(
argument|pp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|matchflag
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
for|for
control|(
name|matchflag
operator|=
literal|0
init|;
condition|;
name|matchflag
operator|++
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ANYDELIM
operator|&&
name|c
operator|!=
name|ONEDELIM
operator|&&
name|c
operator|!=
name|CHANGE
operator|&&
name|macmode
argument_list|(
name|c
argument_list|)
operator|!=
name|DELIM
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|matchflag
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACREAD -- read a terminal input line ** **	Reads one line from the user.  Returns the line into mbuf, **	and a count of the number of characters read into the macro **	"{readcount}" (-1 for end of file). */
end_comment

begin_macro
name|macread
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|env
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|e
operator|=
name|Macenv
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NEWLINE
condition|)
break|break;
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|e
operator|->
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|macdefine
argument_list|(
literal|"{readcount}"
argument_list|,
name|iocv
argument_list|(
name|count
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACNUMBER -- return converted number ** **	This procedure is essentially identical to the system atoi **	routine, in that it does no syntax checking whatsoever. */
end_comment

begin_macro
name|macnumber
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
name|int
name|minus
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
name|minus
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|SPACE
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|minus
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
name|SPACE
condition|)
empty_stmt|;
block|}
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|result
operator|=
name|result
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|minus
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACSUBSTR -- substring primitive ** **	The substring of 'string' from 'from' to 'to' is extracted. **	A pointer to the result is returned.  Note that macsstr **	in the general case modifies 'string' in place. */
end_comment

begin_function
name|char
modifier|*
name|macsstr
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|string
parameter_list|)
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|f
decl_stmt|;
name|int
name|l
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|s
operator|=
name|string
expr_stmt|;
name|t
operator|=
name|to
expr_stmt|;
name|f
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|1
condition|)
name|f
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|>=
name|t
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|l
operator|=
name|length
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|l
condition|)
name|s
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|s
index|[
name|f
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MACDUMP -- dump a macro definition to the terminal ** **	All macros matching 'name' are output to the buffer.  If **	'name' is the null pointer, all macros are printed. */
end_comment

begin_macro
name|macdump
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|macsget
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|macmocv
parameter_list|()
function_decl|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|n
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|macnewev
argument_list|(
name|macsget
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|mactcvt
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macpopev
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
block|}
for|for
control|(
name|m
operator|=
name|Machead
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|nextm
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|macmmatch
argument_list|(
name|n
argument_list|,
name|m
operator|->
name|template
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|substitute
operator|<=
operator|(
name|char
operator|*
operator|)
name|NPRIMS
condition|)
continue|continue;
name|p
operator|=
name|macmocv
argument_list|(
name|m
operator|->
name|template
argument_list|)
expr_stmt|;
name|macload
argument_list|(
literal|"`{rawdefine; "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macload
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macload
argument_list|(
literal|"; "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|macmocv
argument_list|(
name|m
operator|->
name|substitute
argument_list|)
expr_stmt|;
name|macload
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macload
argument_list|(
literal|"}'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|buffree
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MACMOCV -- macro output conversion ** **	This routine converts the internal format of the named macro **	to an unambigous external representation. ** **	Note that much work can be done to this routine to make it **	produce cleaner output, for example, translate "\|" to " " **	in most cases. */
end_comment

begin_function
name|char
modifier|*
name|macmocv
parameter_list|(
name|m
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
specifier|static
name|char
modifier|*
name|lastbuf
decl_stmt|;
specifier|extern
name|char
modifier|*
name|bufcrunch
parameter_list|()
function_decl|;
name|p
operator|=
name|m
expr_stmt|;
comment|/* release last used buffer (as appropriate) */
if|if
condition|(
name|lastbuf
operator|!=
literal|0
condition|)
block|{
name|buffree
argument_list|(
name|lastbuf
argument_list|)
expr_stmt|;
name|lastbuf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<=
operator|(
name|char
operator|*
operator|)
name|NPRIMS
condition|)
block|{
comment|/* we have a primitive */
name|p
operator|=
literal|"Primitive xxx"
expr_stmt|;
name|itoa
argument_list|(
name|m
argument_list|,
operator|&
name|p
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|b
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|;
name|pc
operator|=
name|c
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|BACKSLASH
case|:
case|case
literal|'|'
case|:
case|case
literal|'&'
case|:
case|case
literal|'^'
case|:
break|break;
case|case
name|ANYDELIM
case|:
name|c
operator|=
literal|'\\|'
expr_stmt|;
break|break;
case|case
name|ONEDELIM
case|:
name|c
operator|=
literal|'\\^'
expr_stmt|;
break|break;
case|case
name|CHANGE
case|:
name|c
operator|=
literal|'\\&'
expr_stmt|;
break|break;
case|case
name|PARAMN
case|:
name|c
operator|=
literal|'$'
expr_stmt|;
break|break;
case|case
name|PARAMP
case|:
name|c
operator|=
literal|'$$'
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|c
operator|=
literal|'\\$'
expr_stmt|;
break|break;
case|case
name|NEWLINE
case|:
name|c
operator|=
operator|(
literal|'\\'
operator||
name|QUOTED
operator|)
operator||
operator|(
literal|'\n'
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
default|default:
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pc
operator|==
name|BACKSLASH
condition|)
name|bufput
argument_list|(
name|pc
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|pc
operator|=
name|c
operator|&
name|CHARMASK
expr_stmt|;
name|bufput
argument_list|(
name|pc
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
name|CHARMASK
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|pc
expr_stmt|;
name|bufput
argument_list|(
name|c
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|=
name|bufcrunch
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|bufpurge
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|lastbuf
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MACRO -- get macro substitution value ** **	***  EXTERNAL INTERFACE  *** ** **	This routine handles the rather specialized case of looking **	up a macro and returning the substitution value.  The name **	must match EXACTLY, character for character. ** **	The null pointer is returned if the macro is not defined. */
end_comment

begin_function
name|char
modifier|*
name|macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|macro
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|macsget
parameter_list|()
function_decl|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* convert macro name to internal format */
name|macnewev
argument_list|(
name|macsget
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
name|n
operator|=
name|mactcvt
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|macpopev
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* some sort of syntax error */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|m
operator|=
name|Machead
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|nextm
control|)
block|{
if|if
condition|(
name|macmmatch
argument_list|(
name|n
argument_list|,
name|m
operator|->
name|template
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|buffree
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|->
name|substitute
operator|)
return|;
block|}
block|}
name|buffree
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

