begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)norml.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_function_decl
specifier|extern
name|QTREE
modifier|*
name|treedup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|need
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* ** NORML **	this routine passes the qualification clause portion of the query **	tree to the routines for depressing nots and for conjunctive  **	normalization.  It also calls a routine to place an and with one **	null branch at the rightmost end of the tree. */
end_comment

begin_function
name|QTREE
modifier|*
name|norml
parameter_list|(
name|ptr
parameter_list|)
name|QTREE
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|extern
name|QTREE
modifier|*
name|nnorm
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|travers
parameter_list|()
function_decl|;
specifier|extern
name|QTREE
modifier|*
name|tree
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|xQTR2
if|if
condition|(
name|tTf
argument_list|(
literal|73
argument_list|,
literal|0
argument_list|)
condition|)
name|treepr
argument_list|(
name|ptr
argument_list|,
literal|"->NORML"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|tree
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QLEND
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* push through the 'nots' as far a possible */
name|ptr
operator|=
name|nnorm
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* make tree into conjunctive normal form */
name|ptr
operator|=
name|travers
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* terminate the list on the rightmost branch */
name|adjust
argument_list|(
operator|&
name|ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR3
if|if
condition|(
name|tTf
argument_list|(
literal|73
argument_list|,
literal|2
argument_list|)
condition|)
name|treepr
argument_list|(
name|ptr
argument_list|,
literal|"before mvands"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* make 'ands' into a linear list */
name|mvands
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xQTR2
if|if
condition|(
name|tTf
argument_list|(
literal|73
argument_list|,
literal|1
argument_list|)
condition|)
name|treepr
argument_list|(
name|ptr
argument_list|,
literal|"<-NORML"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** NORM **	this routine takes a tree which has nots only at the lower ends, and **	places it into conjunctive normal form by repeatedly applying the **	replacement rule: A or (B and C) ==> (A or B) and (A or C) */
end_comment

begin_function
name|QTREE
modifier|*
name|norm
parameter_list|(
name|p1
parameter_list|)
name|QTREE
modifier|*
name|p1
decl_stmt|;
block|{
specifier|extern
name|QTREE
modifier|*
name|tree
parameter_list|()
function_decl|;
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|lptr
decl_stmt|;
specifier|register
name|QTREE
modifier|*
name|rptr
decl_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|AND
case|:
name|p
operator|->
name|left
operator|=
name|norm
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|norm
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|==
name|AND
condition|)
block|{
name|andright
label|:
comment|/* 			** combine left subtree with each subtree of the 			** right subtree 			*/
comment|/* 			** use copy first so that the copy is guaranteed to be 			** the same as the original 			*/
name|lptr
operator|=
name|tree
argument_list|(
name|treedup
argument_list|(
name|p
operator|->
name|left
argument_list|)
argument_list|,
name|p
operator|->
name|right
operator|->
name|left
argument_list|,
name|OR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rptr
operator|=
name|tree
argument_list|(
name|p
operator|->
name|left
argument_list|,
name|p
operator|->
name|right
operator|->
name|right
argument_list|,
name|OR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lptr
operator|=
name|norm
argument_list|(
name|lptr
argument_list|)
expr_stmt|;
name|rptr
operator|=
name|norm
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
comment|/* change node type to AND from OR */
name|p
operator|->
name|left
operator|=
name|lptr
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|rptr
expr_stmt|;
name|p
operator|->
name|sym
operator|.
name|type
operator|=
name|AND
expr_stmt|;
comment|/* length is same */
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|AND
condition|)
block|{
name|andleft
label|:
comment|/* 			** combine right subtree with each subtree of the 			** left subtree 			*/
comment|/* 			** again, the copy should be used first 			*/
name|lptr
operator|=
name|tree
argument_list|(
name|p
operator|->
name|left
operator|->
name|left
argument_list|,
name|treedup
argument_list|(
name|p
operator|->
name|right
argument_list|)
argument_list|,
name|OR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rptr
operator|=
name|tree
argument_list|(
name|p
operator|->
name|left
operator|->
name|right
argument_list|,
name|p
operator|->
name|right
argument_list|,
name|OR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lptr
operator|=
name|norm
argument_list|(
name|lptr
argument_list|)
expr_stmt|;
name|rptr
operator|=
name|norm
argument_list|(
name|rptr
argument_list|)
expr_stmt|;
comment|/* change node type to AND from OR */
name|p
operator|->
name|left
operator|=
name|lptr
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|rptr
expr_stmt|;
name|p
operator|->
name|sym
operator|.
name|type
operator|=
name|AND
expr_stmt|;
break|break;
block|}
comment|/* 		** when TRAVERS is being used to optomize the normalization 		** order there should never be (I think) an OR as a child 		** of the OR in the parent.  Since TRAVERS works bottom up 		** in the tree the second OR level should be gone. 		*/
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|==
name|OR
condition|)
block|{
comment|/* skip this (p->sym.type) "or" and normalize the right subtree */
name|p
operator|->
name|right
operator|=
name|norm
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
comment|/* now re-try the current node */
if|if
condition|(
name|p
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|==
name|AND
condition|)
goto|goto
name|andright
goto|;
break|break;
block|}
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|OR
condition|)
block|{
comment|/* skip this "or" and normalize the left subtree */
name|p
operator|->
name|left
operator|=
name|norm
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
comment|/* now re-try the current node */
if|if
condition|(
name|p
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|AND
condition|)
goto|goto
name|andleft
goto|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** TRAVERS **	traverse the tree so that conversion of ORs of ANDs can **	take place at the innermost clauses first.  IE, normalize **	before replication rather than after replication. ** **	This routine need not be used.  The NORM routine will completely **	traverse the tree and normalize it but...    TRAVERS finds **	the lowest subtree to normalize first so that sub-trees can **	be normalized before replication, hence reducing the time required **	to normalize large trees.  It will also make OR-less trees faster **	to normalize (since nothing need be done to it). */
end_comment

begin_function
name|QTREE
modifier|*
name|travers
parameter_list|(
name|p1
parameter_list|)
name|QTREE
modifier|*
name|p1
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
specifier|extern
name|QTREE
modifier|*
name|norm
parameter_list|()
function_decl|;
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
operator|!=
name|NULL
condition|)
name|p
operator|->
name|right
operator|=
name|travers
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|left
operator|!=
name|NULL
condition|)
name|p
operator|->
name|left
operator|=
name|travers
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sym
operator|.
name|type
operator|==
name|OR
condition|)
name|p
operator|=
name|norm
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** NNORM **	this routine depresses nots in the query tree to the lowest possible **	nodes.  It may also affect arithmetic operators in this procedure */
end_comment

begin_function
name|QTREE
modifier|*
name|nnorm
parameter_list|(
name|p1
parameter_list|)
name|QTREE
modifier|*
name|p1
decl_stmt|;
block|{
specifier|extern
name|QTREE
modifier|*
name|notpush
parameter_list|()
function_decl|;
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|sym
operator|.
name|type
operator|==
name|AGHEAD
condition|)
block|{
comment|/* 		** don't need to continue past an AGHEAD 		** actually, it causes problems if you do 		** because the qualification on the agg 		** has already been normalized and the 		** QLEND needs to stay put 		*/
return|return
operator|(
name|p
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|sym
operator|.
name|type
operator|==
name|UOP
operator|)
operator|&&
operator|(
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|==
name|opNOT
operator|)
condition|)
block|{
comment|/* skip not node */
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|=
name|notpush
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|left
operator|!=
name|NULL
condition|)
name|p
operator|->
name|left
operator|=
name|nnorm
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|right
operator|!=
name|NULL
condition|)
name|p
operator|->
name|right
operator|=
name|nnorm
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** NOTPUSH **	this routine decides what to do once a not has been found in the **	query tree */
end_comment

begin_function
name|QTREE
modifier|*
name|notpush
parameter_list|(
name|p1
parameter_list|)
name|QTREE
modifier|*
name|p1
decl_stmt|;
block|{
specifier|extern
name|QTREE
modifier|*
name|nnorm
parameter_list|()
function_decl|;
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|AND
case|:
name|p
operator|->
name|sym
operator|.
name|type
operator|=
name|OR
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|notpush
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|notpush
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|p
operator|->
name|sym
operator|.
name|type
operator|=
name|AND
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|notpush
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|p
operator|->
name|right
operator|=
name|notpush
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOP
case|:
switch|switch
condition|(
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
condition|)
block|{
case|case
name|opEQ
case|:
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opNE
expr_stmt|;
break|break;
case|case
name|opNE
case|:
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opEQ
expr_stmt|;
break|break;
case|case
name|opLT
case|:
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opGE
expr_stmt|;
break|break;
case|case
name|opGE
case|:
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opLT
expr_stmt|;
break|break;
case|case
name|opLE
case|:
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opGT
expr_stmt|;
break|break;
case|case
name|opGT
case|:
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|=
name|opLE
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"strange BOP in notpush '%d'"
argument_list|,
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UOP
case|:
if|if
condition|(
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|==
name|opNOT
condition|)
block|{
comment|/* skip not node */
name|p
operator|=
name|p
operator|->
name|right
expr_stmt|;
name|p
operator|=
name|nnorm
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|syserr
argument_list|(
literal|"strange UOP in notpush '%d'"
argument_list|,
name|p
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"unrecognizable node type in notpush '%d'"
argument_list|,
name|p
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** ADJUST **	terminate qual with an AND and a QLEND at the rightmost branch */
end_comment

begin_macro
name|adjust
argument_list|(
argument|pp
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|QTREE
modifier|*
name|tree
parameter_list|()
function_decl|;
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|AND
case|:
name|adjust
argument_list|(
operator|&
operator|(
name|p
operator|->
name|right
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
default|default:
operator|*
name|pp
operator|=
name|tree
argument_list|(
name|p
argument_list|,
name|tree
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|QLEND
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|AND
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_function
name|QTREE
modifier|*
name|treedup
parameter_list|(
name|p
parameter_list|)
specifier|register
name|QTREE
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|QTREE
modifier|*
name|np
decl_stmt|;
specifier|extern
name|char
name|Qbuf
index|[]
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|np
operator|=
operator|(
name|QTREE
operator|*
operator|)
name|need
argument_list|(
name|Qbuf
argument_list|,
operator|(
name|p
operator|->
name|sym
operator|.
name|len
operator|&
name|I1MASK
operator|)
operator|+
name|QT_HDR_SIZ
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|p
argument_list|,
name|np
argument_list|,
operator|(
name|p
operator|->
name|sym
operator|.
name|len
operator|&
name|I1MASK
operator|)
operator|+
name|QT_HDR_SIZ
argument_list|)
expr_stmt|;
name|np
operator|->
name|left
operator|=
name|treedup
argument_list|(
name|p
operator|->
name|left
argument_list|)
expr_stmt|;
name|np
operator|->
name|right
operator|=
name|treedup
argument_list|(
name|p
operator|->
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **	MVANDS -- pushes all AND's in Qual into linear list */
end_comment

begin_macro
name|mvands
argument_list|(
argument|andp
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|andp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|ap
decl_stmt|,
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|ap
operator|=
name|andp
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|sym
operator|.
name|type
operator|==
name|QLEND
condition|)
return|return;
name|rp
operator|=
name|ap
operator|->
name|right
expr_stmt|;
name|lp
operator|=
name|ap
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|sym
operator|.
name|type
operator|==
name|AND
condition|)
block|{
name|ap
operator|->
name|left
operator|=
name|lp
operator|->
name|right
expr_stmt|;
name|ap
operator|->
name|right
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|right
operator|=
name|rp
expr_stmt|;
name|mvands
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
else|else
name|mvands
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

