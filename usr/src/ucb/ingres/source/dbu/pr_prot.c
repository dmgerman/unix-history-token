begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)pr_prot.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  PR_PROT.C -- Print out a protection query ** **	Trace Flags: **		51 */
end_comment

begin_function_decl
specifier|extern
name|QTREE
modifier|*
name|gettree
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* gets a tree from "tree" catalog [readtree.c] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Days
index|[]
init|=
block|{
literal|"sunday"
block|,
literal|"monday"
block|,
literal|"tuesday"
block|,
literal|"wednesday"
block|,
literal|"thursday"
block|,
literal|"friday"
block|,
literal|"saturday"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rngtab
block|{
name|char
name|relid
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|rowner
index|[
literal|2
index|]
decl_stmt|;
name|char
name|rused
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* **  PR_PROT -- print out protection info on a relation ** **	Prints out a "define permit" statement for  **	each permission on a relation. **	First calls pr_spec_permit() to print permissions **	indicated in the relation.relstat bits. Lower level pr_?? **	routines look for these bits, so in the calls to pr_permit **	for tuples actually gotten from the "protect" catalog, **	pr_prot sets the relstat bits, thereby suppressing their special **	meaning (they are inverse bits: 0 means on). ** **	Parameters: **		relid -- non-unique relation name used by user in DBU call **		r -- ptr to relation tuple ** **	Returns: **		0 -- some permissions on rel **		1 -- no permissions on rel ** **	Side Effects: **		reads trees from protection catalog ** **	Trace Flags: **		39, 0 */
end_comment

begin_macro
name|pr_prot
argument_list|(
argument|relid
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|relid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|relation
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Prodes
decl_stmt|;
name|TID
name|hitid
decl_stmt|,
name|lotid
decl_stmt|;
name|struct
name|protect
name|key
decl_stmt|,
name|tuple
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* indicates whether a special case occurred */
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_prot: relation \"%s\" owner \"%s\"relstat 0%o\n"
argument_list|,
name|r
operator|->
name|relid
argument_list|,
name|r
operator|->
name|relowner
argument_list|,
name|r
operator|->
name|relstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|relstat
operator|&
name|S_PROTUPS
operator|||
operator|!
operator|(
name|r
operator|->
name|relstat
operator|&
name|S_PROTALL
operator|)
operator|||
operator|!
operator|(
name|r
operator|->
name|relstat
operator|&
name|S_PROTRET
operator|)
condition|)
name|printf
argument_list|(
literal|"Permissions on %s are:\n\n"
argument_list|,
name|relid
argument_list|)
expr_stmt|;
comment|/* print out special permissions, if any */
name|flag
operator|+=
name|pr_spec_permit
argument_list|(
name|r
argument_list|,
name|S_PROTALL
argument_list|)
expr_stmt|;
name|flag
operator|+=
name|pr_spec_permit
argument_list|(
name|r
argument_list|,
name|S_PROTRET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|relstat
operator|&
name|S_PROTUPS
operator|)
condition|)
if|if
condition|(
name|flag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
name|opencatalog
argument_list|(
literal|"protect"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get protect catalog tuples for "r", "owner" */
name|clearkeys
argument_list|(
operator|&
name|Prodes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|key
argument_list|,
name|r
operator|->
name|relid
argument_list|,
name|PRORELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|key
argument_list|,
name|r
operator|->
name|relowner
argument_list|,
name|PRORELOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Prodes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|key
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"pr_prot: find %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* ready for pr_user call to getuser() */
name|getuser
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|tuple
argument_list|,
name|TRUE
argument_list|)
condition|)
break|break;
comment|/* print out protection info */
if|if
condition|(
name|kcompare
argument_list|(
operator|&
name|Prodes
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|key
argument_list|)
operator|==
literal|0
condition|)
comment|/* permission from real protect tuple, concoct 			 * neutral relstat 			 */
name|pr_permit
argument_list|(
operator|&
name|tuple
argument_list|,
name|r
operator|->
name|relstat
operator||
name|S_PROTALL
operator||
name|S_PROTRET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|syserr
argument_list|(
literal|"pr_prot: get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* close user file opened by pr_user call to getuser */
name|getuser
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_SPEC_PERMIT -- Print out special permissions **	Prints out permissios indicated by the relation.relstat field bits. **	Concocts a protection tuple for the permission and assigns a  **	propermid-like number to it for printing. Passes to pr_permit() **	the concocted tuple, together with a relstat where the appropriate **	bit is 0, so that the special printing at the lower level pr_???  **	routines takes place. ** **	Parameters: **		r -- relation relation tuple for the permitted relation **		relst_bit -- if this bit is 0 inthe relstat, prints the query **				{S_PROTALL, S_PROTRET} ** **	Returns: **		1 -- if prints **		0 -- otherwise */
end_comment

begin_expr_stmt
name|pr_spec_permit
argument_list|(
name|r
argument_list|,
name|relst_bit
argument_list|)
specifier|register
expr|struct
name|relation
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|relst_bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|protect
modifier|*
name|p
decl_stmt|;
name|struct
name|protect
name|prot
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|relstat
operator|&
name|relst_bit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
operator|&
name|prot
expr_stmt|;
name|clrmem
argument_list|(
name|p
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|protree
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|relst_bit
operator|==
name|S_PROTALL
condition|)
name|p
operator|->
name|propermid
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|relst_bit
operator|==
name|S_PROTRET
condition|)
name|p
operator|->
name|propermid
operator|=
literal|1
expr_stmt|;
else|else
name|syserr
argument_list|(
literal|"pr_spec_permit(relst_bit == 0%o)"
argument_list|,
name|relst_bit
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|r
operator|->
name|relid
argument_list|,
name|p
operator|->
name|prorelid
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
literal|"  "
argument_list|,
name|p
operator|->
name|prouser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pmove
argument_list|(
literal|""
argument_list|,
name|p
operator|->
name|proterm
argument_list|,
sizeof|sizeof
name|p
operator|->
name|proterm
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|pr_permit
argument_list|(
name|p
argument_list|,
operator|(
name|r
operator|->
name|relstat
operator||
name|S_PROTRET
operator||
name|S_PROTALL
operator|)
operator|&
operator|~
name|relst_bit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_PERMIT -- print out a DEFINE PERMIT query for a protection tuple ** **	Parameters: **		p -- ptr to protection tuple **		relstat -- relstat from relation ** **	Returns: **		none ** **	Side Effects: **		reads in a tree from the "tree" catalog **		prints out a query */
end_comment

begin_expr_stmt
name|pr_permit
argument_list|(
name|p
argument_list|,
name|relstat
argument_list|)
specifier|register
expr|struct
name|protect
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|relstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|QTREE
modifier|*
name|t
decl_stmt|;
specifier|extern
name|DESC
name|Prodes
decl_stmt|;
name|DESC
name|pdesc
decl_stmt|;
comment|/*  	 * if there is a qualification then 	 * clear range table, then read in protect tree,  	 * the print out range statements 	 * else create single entry range table. 	 */
name|clrrange
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|protree
operator|>=
literal|0
condition|)
block|{
name|t
operator|=
name|gettree
argument_list|(
name|p
operator|->
name|prorelid
argument_list|,
name|p
operator|->
name|prorelown
argument_list|,
name|mdPROT
argument_list|,
name|p
operator|->
name|protree
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
literal|0
expr_stmt|;
name|bmove
argument_list|(
name|p
operator|->
name|prorelid
argument_list|,
name|pdesc
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|p
operator|->
name|prorelown
argument_list|,
name|pdesc
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|declare
argument_list|(
literal|0
argument_list|,
operator|&
name|pdesc
argument_list|)
expr_stmt|;
name|p
operator|->
name|proresvar
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Permission %d -\n\n"
argument_list|,
name|p
operator|->
name|propermid
argument_list|)
expr_stmt|;
name|pr_range
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pr_permit: prot="
argument_list|)
expr_stmt|;
name|printup
argument_list|(
operator|&
name|Prodes
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", Qt.qt_resvar=%d\n"
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* print out query */
name|printf
argument_list|(
literal|"define permit "
argument_list|)
expr_stmt|;
name|pr_ops
argument_list|(
name|p
operator|->
name|proopset
argument_list|,
name|relstat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"on "
argument_list|)
expr_stmt|;
name|pr_rv
argument_list|(
name|Qt
operator|.
name|qt_resvar
operator|=
name|p
operator|->
name|proresvar
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pr_doms
argument_list|(
name|p
operator|->
name|prodomset
argument_list|,
name|relstat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|pr_user
argument_list|(
name|p
operator|->
name|prouser
argument_list|)
expr_stmt|;
name|pr_term
argument_list|(
name|p
operator|->
name|proterm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|relstat
operator|&
name|S_PROTRET
operator|)
operator|&&
operator|(
name|relstat
operator|&
name|S_PROTALL
operator|)
condition|)
block|{
comment|/* not special case */
name|pr_time
argument_list|(
name|p
operator|->
name|protodbgn
argument_list|,
name|p
operator|->
name|protodend
argument_list|)
expr_stmt|;
name|pr_day
argument_list|(
name|p
operator|->
name|prodowbgn
argument_list|,
name|p
operator|->
name|prodowend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|&&
name|t
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|printf
argument_list|(
literal|"\nwhere "
argument_list|)
expr_stmt|;
name|pr_qual
argument_list|(
name|t
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\n\n"
argument_list|)
expr_stmt|;
comment|/* clear up the old range table */
name|clrrange
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_OPS -- Prints the the operation list defined by a protection opset ** **	Eliminates the appropriate bits from a copy of the opset while printing **	out the appropriate operation list. ** **	Parameters: **		opset -- protection.opset for the relation **		relstat ** **	Returns: **		none ** **	Side Effects: **		printing of permitted op list */
end_comment

begin_macro
name|pr_ops
argument_list|(
argument|opset
argument_list|,
argument|relstat
argument_list|)
end_macro

begin_decl_stmt
name|int
name|opset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|relstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|op
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_ops(0%o)\n"
argument_list|,
name|opset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|relstat
operator|&
name|S_PROTALL
operator|)
operator|||
name|opset
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"all "
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|relstat
operator|&
name|S_PROTRET
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"retrieve "
argument_list|)
expr_stmt|;
return|return;
block|}
name|op
operator|=
operator|(
name|opset
operator|&
operator|~
name|PRO_AGGR
operator|&
operator|~
name|PRO_TEST
operator|)
operator|&
literal|077
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|op
operator|&
operator|(
name|j
operator|=
name|PRO_RETR
operator|)
condition|)
name|printf
argument_list|(
literal|"retrieve"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|&
operator|(
name|j
operator|=
name|PRO_REPL
operator|)
condition|)
name|printf
argument_list|(
literal|"replace"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|&
operator|(
name|j
operator|=
name|PRO_DEL
operator|)
condition|)
name|printf
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|&
operator|(
name|j
operator|=
name|PRO_APP
operator|)
condition|)
name|printf
argument_list|(
literal|"append"
argument_list|)
expr_stmt|;
name|op
operator|^=
name|j
expr_stmt|;
if|if
condition|(
name|op
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_DOMS -- Print domains in permit target list ** **	Parameters: **		doms -- an 8 byte integer array; a bit map of the domains **			if all 8 integers are -1, then "all" is printed fo **			for the target list **		relstat ** **	Returns: **		none ** **	Side Effects: **		prints out target list */
end_comment

begin_macro
name|pr_doms
argument_list|(
argument|doms
argument_list|,
argument|relstat
argument_list|)
end_macro

begin_decl_stmt
name|short
name|doms
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|relstat
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|short
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|flag
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|word
decl_stmt|;
name|char
modifier|*
name|rel
decl_stmt|;
name|word
operator|=
name|shift
operator|=
literal|0
expr_stmt|;
name|d
operator|=
name|doms
expr_stmt|;
name|rel
operator|=
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pr_doms: rel=\"%s\" "
argument_list|,
name|rel
argument_list|)
expr_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
literal|8
condition|;
control|)
name|printf
argument_list|(
literal|"0%o "
argument_list|,
name|d
index|[
name|word
operator|++
index|]
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|relstat
operator|&
name|S_PROTALL
operator|)
operator|||
operator|!
operator|(
name|relstat
operator|&
name|S_PROTRET
operator|)
condition|)
return|return;
name|flag
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|word
operator|=
literal|0
init|;
name|word
operator|<
literal|8
condition|;
name|word
operator|++
control|)
if|if
condition|(
operator|*
name|d
operator|++
operator|!=
operator|-
literal|1
condition|)
block|{
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|flag
condition|)
block|{
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|doms
operator|,
name|word
operator|=
literal|0
init|;
name|word
operator|<
literal|8
condition|;
name|word
operator|++
operator|,
name|d
operator|++
control|)
block|{
for|for
control|(
name|shift
operator|=
literal|0
init|;
name|shift
operator|<
literal|16
condition|;
name|shift
operator|++
operator|,
operator|*
name|d
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|&
literal|01
condition|)
block|{
if|if
condition|(
name|flag
operator|++
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|pr_attname
argument_list|(
name|rel
argument_list|,
name|word
operator|*
literal|16
operator|+
name|shift
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_USER -- prints out permitted user's name ** **	Parameters: **		user -- 2 char array, user's usercode as in **			users file ** **	Returns: **		none ** **	Side Effects: **		prints users name or "all" if user was "  " */
end_comment

begin_macro
name|pr_user
argument_list|(
argument|user
argument_list|)
end_macro

begin_decl_stmt
name|char
name|user
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
expr_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|u
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_user(\"%c%c\")\n"
argument_list|,
name|user
index|[
literal|0
index|]
argument_list|,
name|user
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|buf
expr_stmt|;
name|u
operator|=
name|user
expr_stmt|;
name|printf
argument_list|(
literal|"to "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bequal
argument_list|(
name|u
argument_list|,
literal|"  "
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"all "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|getuser
argument_list|(
name|u
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%c%c "
argument_list|,
name|u
index|[
literal|0
index|]
argument_list|,
name|u
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|c
operator|!=
literal|':'
operator|&&
operator|*
name|c
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
operator|*
name|c
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_TIME -- Prints out clock time range access is allowed ** **	Parameters: **		bgn, end -- begin end times in seconds (if all day, returns) ** **	Returns: **		none ** **	Side Effects: **		prints out time */
end_comment

begin_macro
name|pr_time
argument_list|(
argument|bgn
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|bgn
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|time
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|b
decl_stmt|,
name|e
decl_stmt|;
name|t
operator|=
name|time
expr_stmt|;
name|b
operator|=
name|bgn
expr_stmt|;
name|e
operator|=
name|end
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_time(bgn=%d, end=%d)\n"
argument_list|,
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|b
operator|==
literal|0
operator|&&
name|e
operator|==
literal|24
operator|*
literal|60
condition|)
return|return;
name|printf
argument_list|(
literal|"from %d:"
argument_list|,
name|b
operator|/
literal|60
argument_list|)
expr_stmt|;
name|itoa
argument_list|(
name|b
operator|%
literal|60
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
index|[
literal|1
index|]
condition|)
name|putchar
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s to %d:"
argument_list|,
name|t
argument_list|,
name|e
operator|/
literal|60
argument_list|)
expr_stmt|;
name|itoa
argument_list|(
name|e
operator|%
literal|60
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
index|[
literal|1
index|]
condition|)
name|putchar
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_DAY -- Prints day range permitted ** **	Parameters: **		bgn, end -- bgn end days [0..6] (if all week returns) ** **	Returns: **		none ** **	Side Effects: **		prints days or nothing */
end_comment

begin_macro
name|pr_day
argument_list|(
argument|bgn
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|bgn
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_day(bgn=%d, end=%d)\n"
argument_list|,
name|bgn
argument_list|,
name|end
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bgn
operator|==
literal|0
operator|&&
name|end
operator|>=
literal|6
condition|)
return|return;
name|printf
argument_list|(
literal|"on %s to %s "
argument_list|,
name|Days
index|[
name|bgn
index|]
argument_list|,
name|Days
index|[
name|end
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_TERM -- Print terminal from which access permitted ** **	Parameters: **		term -- 1 char terminal id as in /etc/tty* (if ' ' the returns) ** **	Returns: **		none ** **	Side Effects: **		prints terminal or nothing */
end_comment

begin_macro
name|pr_term
argument_list|(
argument|term
argument_list|)
end_macro

begin_decl_stmt
name|char
name|term
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|51
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_term(term='%.8s')\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|term
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
name|printf
argument_list|(
literal|"at %8.8s "
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

