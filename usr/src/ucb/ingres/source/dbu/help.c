begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<catalog.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)help.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_decl_stmt
specifier|extern
name|short
name|tTdbu
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|help
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|null_fn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fn_def
name|HelpFn
init|=
block|{
literal|"HELP"
block|,
name|help
block|,
name|null_fn
block|,
comment|/* initialization function */
name|null_fn
block|,
name|NULL
block|,
literal|0
block|,
name|tTdbu
block|,
literal|100
block|,
literal|'Z'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  HELP - Provide Information to User ** **	Arguments: **		pv[i] - code **			0 - print relation information **			1 - print manual section **			2 - print relation list **			3 - print relation info for all accessible relations **		pv[i+1] - name of entity for modes 0 or 1 ** **	Trace Flags: **		44 */
end_comment

begin_macro
name|help
argument_list|(
argument|parmc
argument_list|,
argument|parmv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|parmc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
name|parmv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DESC
name|des
decl_stmt|;
name|int
name|mode
decl_stmt|;
specifier|register
name|PARM
modifier|*
name|pv
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|44
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|">>help\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTf
argument_list|(
literal|44
argument_list|,
literal|0
argument_list|)
condition|)
name|prvect
argument_list|(
name|parmc
argument_list|,
name|parmv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ret
operator|=
literal|0
expr_stmt|;
name|pv
operator|=
name|parmv
expr_stmt|;
name|getuser
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* init getuser for modes 1& 2 */
while|while
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_EOF
condition|)
block|{
name|atoi
argument_list|(
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|2
operator|&&
name|pv
operator|->
name|pv_type
operator|==
name|PV_EOF
condition|)
name|syserr
argument_list|(
literal|"help: mode %d no val"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|44
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"help %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|2
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* help relation */
if|if
condition|(
operator|!
name|openr
argument_list|(
operator|&
name|des
argument_list|,
operator|-
literal|1
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
condition|)
block|{
name|rel_fmt
argument_list|(
operator|&
name|des
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
operator|=
name|NULL
expr_stmt|;
block|}
name|pv
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* help manual section */
if|if
condition|(
name|man
argument_list|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
condition|)
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
operator|=
name|NULL
expr_stmt|;
name|pv
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|relpr
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"HELP: mode %d"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
name|getuser
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* close getuser in case mode 1 or 2 */
comment|/* now rescan for error messages */
name|pv
operator|=
name|parmv
expr_stmt|;
while|while
condition|(
name|pv
operator|->
name|pv_type
operator|!=
name|PV_EOF
condition|)
block|{
name|atoi
argument_list|(
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|nferror
argument_list|(
literal|5401
operator|+
name|mode
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pv
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_comment
comment|/* **  Nroff Manual Section ** **	The manual section given by 'name' is nroff'ed.  Returns one **	on success, zero if the manual section is not found. ** **	Uses trace flag 11 */
end_comment

begin_function
name|int
name|man
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|manual
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|char
name|name_nr
index|[
literal|18
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|naa
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ztack
parameter_list|()
function_decl|;
if|if
condition|(
name|length
argument_list|(
name|name
argument_list|)
operator|>
literal|14
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* a null manual name gives table of contents */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|smove
argument_list|(
literal|"../toc.nr"
argument_list|,
name|name_nr
argument_list|)
expr_stmt|;
else|else
name|concat
argument_list|(
name|name
argument_list|,
literal|".nr"
argument_list|,
name|name_nr
argument_list|)
expr_stmt|;
name|concat
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/doc/quel/"
argument_list|)
argument_list|,
name|name_nr
argument_list|,
name|manual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|manual
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* try a unix command instead */
name|concat
argument_list|(
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/doc/unix/"
argument_list|)
argument_list|,
name|name_nr
argument_list|,
name|manual
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|manual
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|i
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"cannot close %s"
argument_list|,
name|manual
argument_list|)
expr_stmt|;
name|ruboff
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for child's death if rubout occures */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|signal
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* die on rubout */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|xB_UNIX
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|naa
operator|=
name|ztack
argument_list|(
name|Pathname
argument_list|,
literal|"/doc/iaa"
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/nroff"
argument_list|,
literal|"nroff"
argument_list|,
name|naa
argument_list|,
name|manual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/bin/nroff"
argument_list|,
literal|"nroff"
argument_list|,
name|naa
argument_list|,
name|manual
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"help: exec: nroff"
argument_list|)
expr_stmt|;
block|}
comment|/* wait for nroff if fork succeeded */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fullwait
argument_list|(
name|i
argument_list|,
literal|"help: nroff"
argument_list|)
expr_stmt|;
name|rubon
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  PRINT DATABASE INFORMATION ** **	Prints a list of all the relations in the database, together **	with their owner. ** **	Uses trace flag 12 */
end_comment

begin_macro
name|relpr
argument_list|(
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|DESC
name|Reldes
decl_stmt|;
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|tup_id
name|limtid
decl_stmt|,
name|tid
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|lastuser
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|relation
name|rel
decl_stmt|;
name|opencatalog
argument_list|(
literal|"relation"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|=
operator|&
name|Reldes
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
name|d
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"help: relpr: find %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lastuser
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"\n relation name     relation owner\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
name|d
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|rel
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|lastuser
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|getuser
argument_list|(
name|rel
operator|.
name|relowner
argument_list|,
name|buf
argument_list|)
condition|)
block|{
comment|/* cant find user code */
name|bmove
argument_list|(
literal|"  "
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|cp
index|[
literal|2
index|]
expr_stmt|;
name|bmove
argument_list|(
name|rel
operator|.
name|relowner
argument_list|,
name|cp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|cp
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
operator|!=
literal|':'
condition|;
name|cp
operator|++
control|)
empty_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|bmove
argument_list|(
name|rel
operator|.
name|relowner
argument_list|,
name|lastuser
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" %.12s      %s\n"
argument_list|,
name|rel
operator|.
name|relid
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rel
operator|.
name|relstat
operator|&
name|S_CATALOG
operator|)
operator|||
name|bequal
argument_list|(
literal|"_SYS"
argument_list|,
name|rel
operator|.
name|relid
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
operator|||
name|bequal
argument_list|(
name|Admin
operator|.
name|adhdr
operator|.
name|adowner
argument_list|,
name|rel
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
name|rel_fmt
argument_list|(
operator|&
name|rel
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"help: relpr: get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* **  Print Relation Information ** **	Prints detailed information regarding the relation. ** **	Uses trace flag 13 */
end_comment

begin_expr_stmt
name|rel_fmt
argument_list|(
name|r
argument_list|)
specifier|register
expr|struct
name|relation
operator|*
name|r
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tup_id
name|limtid
decl_stmt|,
name|tid
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|attribute
name|att
decl_stmt|;
name|struct
name|index
name|indkey
decl_stmt|,
name|ind
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
specifier|extern
name|DESC
name|Attdes
decl_stmt|,
name|Inddes
decl_stmt|;
name|char
modifier|*
name|trim_relname
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"\nRelation:\t\t%s\n"
argument_list|,
name|trim_relname
argument_list|(
name|r
operator|->
name|relid
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|getuser
argument_list|(
name|r
operator|->
name|relowner
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|smove
argument_list|(
literal|"(xx)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
name|r
operator|->
name|relowner
argument_list|,
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
operator|!=
literal|':'
condition|;
name|i
operator|++
control|)
continue|continue;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Owner:\t\t\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Tuple width:\t\t%d\n"
argument_list|,
name|r
operator|->
name|relwid
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|relsave
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Saved until:\t\t%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|r
operator|->
name|relsave
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|->
name|relstat
operator|&
name|S_VIEW
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Number of tuples:\t%ld\n"
argument_list|,
name|r
operator|->
name|reltups
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Storage structure:\t"
argument_list|)
expr_stmt|;
name|i
operator|=
name|r
operator|->
name|relspec
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"compressed "
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|M_HEAP
case|:
name|printf
argument_list|(
literal|"paged heap\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_ISAM
case|:
name|printf
argument_list|(
literal|"ISAM file\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_HASH
case|:
name|printf
argument_list|(
literal|"random hash\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown structure %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"Relation type:\t\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|relstat
operator|&
name|S_CATALOG
condition|)
name|printf
argument_list|(
literal|"system catalog\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|relstat
operator|&
name|S_VIEW
condition|)
name|printf
argument_list|(
literal|"view\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|relindxd
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"secondary index on "
argument_list|)
expr_stmt|;
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indkey
argument_list|,
name|r
operator|->
name|relowner
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indkey
argument_list|,
name|r
operator|->
name|relid
argument_list|,
name|IRELIDI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getequal
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indkey
argument_list|,
operator|&
name|ind
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|trim_relname
argument_list|(
name|ind
operator|.
name|irelidp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown relation\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|r
operator|->
name|relstat
operator|&
name|S_DISTRIBUTED
condition|)
name|printf
argument_list|(
literal|"distributed "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"user relation\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|relindxd
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Secondary Indices:\t"
argument_list|)
expr_stmt|;
name|opencatalog
argument_list|(
literal|"indexes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indkey
argument_list|,
name|r
operator|->
name|relid
argument_list|,
name|IRELIDP
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|indkey
argument_list|,
name|r
operator|->
name|relowner
argument_list|,
name|IOWNERP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
operator|&
name|Inddes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|indkey
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"help: find %d indexes"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Inddes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|ind
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|indkey
argument_list|,
operator|&
name|ind
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|j
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|j
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|trim_relname
argument_list|(
name|ind
operator|.
name|irelidi
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"help:get indexes %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|j
condition|)
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|opencatalog
argument_list|(
literal|"attribute"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n attribute name    type  length  keyno.\n\n"
argument_list|)
expr_stmt|;
name|seq_init
argument_list|(
operator|&
name|Attdes
argument_list|,
name|r
argument_list|)
expr_stmt|;
while|while
condition|(
name|seq_attributes
argument_list|(
operator|&
name|Attdes
argument_list|,
name|r
argument_list|,
operator|&
name|att
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" %.12s	    %c%8d"
argument_list|,
name|att
operator|.
name|attname
argument_list|,
name|att
operator|.
name|attfrmt
argument_list|,
name|att
operator|.
name|attfrml
operator|&
literal|0377
argument_list|)
expr_stmt|;
if|if
condition|(
name|att
operator|.
name|attxtra
condition|)
name|printf
argument_list|(
literal|"%7d"
argument_list|,
name|att
operator|.
name|attxtra
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

