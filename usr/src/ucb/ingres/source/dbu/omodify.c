begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<batch.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<opsys.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|<version.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)modify.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_decl_stmt
specifier|extern
name|short
name|tTdbu
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|modify
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|null_fn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fn_def
name|ModifyFn
init|=
block|{
literal|"MODIFY"
block|,
name|modify
block|,
name|null_fn
block|,
name|null_fn
block|,
name|NULL
block|,
literal|0
block|,
name|tTdbu
block|,
literal|100
block|,
literal|'Z'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  MODIFY -- converts any relation to the specified **		storage structure ** **	arguments: **	0 - relation name **	1 - storage structure ("heap", "cheap", "hash", "chash", **		"isam", "cisam") **	2 - "name" for attribute names, or "num" for numbers **	3 - key1 **	4 - key2 **	    . **	    . **	i - null **	i+1 - option name (e.g., "fillfactor") **	i+2 - option value **	    . **	    . ** **	If all the options default, parameter i -> pc are omitted. **	If no keys are provided, parameter 2 is omitted. */
end_comment

begin_decl_stmt
name|int
name|F_fac
decl_stmt|,
name|Mn_pages
decl_stmt|,
name|Mx_pages
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|modtab
block|{
name|char
modifier|*
name|type
decl_stmt|;
name|char
name|newrelspec
decl_stmt|;
name|char
name|yeskeys
decl_stmt|;
name|char
name|sortit
decl_stmt|;
name|char
name|yes_seq
decl_stmt|;
name|int
name|f_fac
decl_stmt|;
name|int
name|mn_pages
decl_stmt|;
name|int
name|mx_pages
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|modtab
name|Modtab
index|[]
init|=
block|{
comment|/* type		spec	keys	sort	seq	ffac	min	max */
literal|"heap"
block|,
name|M_HEAP
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"cheap"
block|,
operator|-
name|M_HEAP
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"hash"
block|,
name|M_HASH
block|,
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|50
block|,
literal|10
block|,
operator|-
literal|1
block|,
literal|"chash"
block|,
operator|-
name|M_HASH
block|,
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|75
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|"isam"
block|,
name|M_ISAM
block|,
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|80
block|,
literal|0
block|,
literal|0
block|,
literal|"cisam"
block|,
operator|-
name|M_ISAM
block|,
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|100
block|,
literal|0
block|,
literal|0
block|,
literal|"heapsort"
block|,
name|M_HEAP
block|,
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"cheapsort"
block|,
operator|-
name|M_HEAP
block|,
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"truncated"
block|,
name|M_TRUNC
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mod_info
block|{
name|char
name|outfile
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
comment|/* result file filled by ksort */
name|char
name|formfile
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
comment|/* file with descriptor for ksort */
name|char
name|infile
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
comment|/* input file for ksort (relation itself */
name|char
name|reltemp
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
comment|/* file holding new relation */
name|char
name|spfile
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|,
name|spflag
decl_stmt|;
comment|/* isam spool file for overflow */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mod_info
name|Mod_info
decl_stmt|;
end_decl_stmt

begin_macro
name|modify
argument_list|(
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|rname
decl_stmt|;
specifier|register
name|struct
name|modtab
modifier|*
name|mp
decl_stmt|;
name|int
name|sorted
decl_stmt|;
name|DESC
name|dold
decl_stmt|,
name|dnew
decl_stmt|;
name|long
name|temptid
decl_stmt|;
specifier|extern
name|int
name|Noupdt
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|34
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"enter modify\n"
argument_list|)
expr_stmt|;
name|prvect
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pv
index|[
name|pc
index|]
operator|.
name|pv_val
operator|.
name|pv_str
operator|=
name|NULL
expr_stmt|;
comment|/* check for nice parameters */
if|if
condition|(
name|pc
operator|<
literal|2
condition|)
name|syserr
argument_list|(
literal|"MODIFY: pc %d"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* save relation name for error messages */
name|rname
operator|=
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
expr_stmt|;
comment|/* *pv now pointes to storage spec */
comment|/* check for good relation */
name|i
operator|=
name|openr
argument_list|(
operator|&
name|dold
argument_list|,
literal|0
argument_list|,
name|rname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|AMOPNVIEW_ERR
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5519
argument_list|,
name|rname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
comment|/* reln does not exist */
return|return
operator|(
name|error
argument_list|(
literal|5500
argument_list|,
name|rname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"MODIFY: openr (%.14s) %d"
argument_list|,
name|rname
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* can only modify a relation you own and isn't a sys rel */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|dold
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|i
operator|=
literal|5501
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dold
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_CATALOG
operator|)
operator|&&
name|Noupdt
condition|)
block|{
name|i
operator|=
literal|5504
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|closer
argument_list|(
operator|&
name|dold
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
argument_list|(
name|i
argument_list|,
name|rname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* 	** Form descriptor for new relation. Here we need to 	** separate the pages from the old and new relations. 	** Since pages are identified by the TID of the relation 	** relation tuple, both old and new have the same identifiers. 	** To avoid this problem, a special TID is hand crafted for 	** the new relation. 	*/
name|bmove
argument_list|(
operator|&
name|dold
argument_list|,
operator|&
name|dnew
argument_list|,
sizeof|sizeof
name|dnew
argument_list|)
expr_stmt|;
name|dnew
operator|.
name|reltid
operator|.
name|s_tupid
operator|.
name|line_id
operator|=
operator|(
name|char
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* choose impossible reltid */
comment|/* In case of an interrupt from a previous modify, 	** there might be pages around. Get rid of them. 	*/
name|cleanrel
argument_list|(
operator|&
name|dnew
argument_list|)
expr_stmt|;
name|ingresname
argument_list|(
name|dold
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|dold
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
name|Mod_info
operator|.
name|infile
argument_list|)
expr_stmt|;
comment|/* scan for entry in relspec table */
for|for
control|(
name|mp
operator|=
name|Modtab
init|;
name|mp
operator|->
name|type
condition|;
name|mp
operator|++
control|)
if|if
condition|(
name|sequal
argument_list|(
name|mp
operator|->
name|type
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|)
condition|)
break|break;
comment|/* if not found, error */
if|if
condition|(
operator|!
name|mp
operator|->
name|type
condition|)
block|{
name|closer
argument_list|(
operator|&
name|dold
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
argument_list|(
literal|5510
argument_list|,
name|rname
argument_list|,
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* bad relspec */
block|}
name|dnew
operator|.
name|reldum
operator|.
name|relspec
operator|=
name|mp
operator|->
name|newrelspec
expr_stmt|;
if|if
condition|(
name|dnew
operator|.
name|reldum
operator|.
name|relspec
operator|==
name|M_TRUNC
condition|)
name|dnew
operator|.
name|reldum
operator|.
name|relspec
operator|=
name|M_HEAP
expr_stmt|;
name|pv
operator|++
expr_stmt|;
comment|/* now points to first parameter */
name|F_fac
operator|=
name|mp
operator|->
name|f_fac
expr_stmt|;
name|Mn_pages
operator|=
name|mp
operator|->
name|mn_pages
expr_stmt|;
name|Mx_pages
operator|=
name|mp
operator|->
name|mx_pages
expr_stmt|;
comment|/* get the key domains information */
if|if
condition|(
name|i
operator|=
name|getkeys
argument_list|(
operator|&
name|pv
argument_list|,
name|rname
argument_list|,
operator|&
name|dnew
argument_list|,
name|mp
argument_list|)
condition|)
block|{
name|closer
argument_list|(
operator|&
name|dold
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
comment|/* user error */
block|}
comment|/* get fillfactor and other options if any */
if|if
condition|(
name|i
operator|=
name|getfill
argument_list|(
name|pv
argument_list|,
name|rname
argument_list|,
name|mp
argument_list|)
condition|)
block|{
name|closer
argument_list|(
operator|&
name|dold
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
comment|/* user error */
block|}
comment|/* lock the relation relation */
if|if
condition|(
name|Lockrel
condition|)
block|{
name|get_p_tid
argument_list|(
operator|&
name|dold
argument_list|,
operator|&
name|temptid
argument_list|)
expr_stmt|;
name|setrll
argument_list|(
name|A_SLP
argument_list|,
name|temptid
argument_list|,
name|M_EXCL
argument_list|)
expr_stmt|;
block|}
comment|/* compute new relation parameters& build descriptor */
name|make_newrel
argument_list|(
operator|&
name|dnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorted
operator|=
operator|(
name|mp
operator|->
name|sortit
operator|&&
operator|(
name|dold
operator|.
name|reldum
operator|.
name|reltups
operator|!=
literal|0
operator|)
operator|)
condition|)
name|sortrel
argument_list|(
operator|&
name|dold
argument_list|,
operator|&
name|dnew
argument_list|)
expr_stmt|;
comment|/* physically create the new relation */
if|if
condition|(
name|formatpg
argument_list|(
operator|&
name|dnew
argument_list|,
name|dnew
operator|.
name|reldum
operator|.
name|relprim
argument_list|)
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"modify: formatpg"
argument_list|)
expr_stmt|;
comment|/* clear relgiven field; if heap remove any keys */
name|clearkeys
argument_list|(
operator|&
name|dnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|dnew
operator|.
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_HEAP
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dnew
operator|.
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
name|dnew
operator|.
name|relxtra
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|newrelspec
operator|!=
name|M_TRUNC
condition|)
name|fill_rel
argument_list|(
operator|&
name|dold
argument_list|,
operator|&
name|dnew
argument_list|,
name|sorted
argument_list|)
expr_stmt|;
name|closer
argument_list|(
operator|&
name|dold
argument_list|)
expr_stmt|;
comment|/* error return is impossible */
if|if
condition|(
name|abs
argument_list|(
name|dnew
operator|.
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_ISAM
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|bldindex
argument_list|(
operator|&
name|dnew
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"bldindex: %.14s %d"
argument_list|,
name|dnew
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unspool
argument_list|(
operator|&
name|dnew
argument_list|)
expr_stmt|;
block|}
comment|/* 	** New relation is now complete. The system relations need to 	** be updated. First destroy all buffers with pages from the 	** new relation. 	*/
if|if
condition|(
name|i
operator|=
name|cleanrel
argument_list|(
operator|&
name|dnew
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"modify:clean new %d,%.14s"
argument_list|,
name|i
argument_list|,
name|dnew
operator|.
name|reldum
operator|.
name|relid
argument_list|)
expr_stmt|;
name|fill_batch
argument_list|(
operator|&
name|dold
argument_list|,
operator|&
name|dnew
argument_list|)
expr_stmt|;
comment|/* 	** Close the file for the new relation. This must be 	** done after the fill_batch in case we are modifing 	** the attribute relation. 	*/
name|close
argument_list|(
name|dnew
operator|.
name|relfp
argument_list|)
expr_stmt|;
name|dnew
operator|.
name|relopn
operator|=
literal|0
expr_stmt|;
name|ruboff
argument_list|(
literal|"modify"
argument_list|)
expr_stmt|;
name|modupdate
argument_list|()
expr_stmt|;
name|rubon
argument_list|()
expr_stmt|;
if|if
condition|(
name|Lockrel
condition|)
name|unlrl
argument_list|(
name|temptid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTM
if|if
condition|(
name|tTf
argument_list|(
literal|35
argument_list|,
literal|1
argument_list|)
condition|)
name|timtrace
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|getkeys
argument_list|(
argument|ppv
argument_list|,
argument|relname
argument_list|,
argument|d
argument_list|,
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|PARM
modifier|*
modifier|*
name|ppv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|relname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|DESC
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|modtab
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARM
modifier|*
name|pv
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|namemode
decl_stmt|,
name|sort_only
decl_stmt|,
name|as_ds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|keyno
decl_stmt|,
name|keywid
decl_stmt|;
name|struct
name|attribute
name|attkey
decl_stmt|,
name|atttup
decl_stmt|;
name|TID
name|tid
decl_stmt|;
specifier|extern
name|DESC
name|Attdes
decl_stmt|;
name|pv
operator|=
operator|*
name|ppv
expr_stmt|;
comment|/* copy list of params */
comment|/* zero key info */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|d
operator|->
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
name|d
operator|->
name|relxtra
index|[
name|i
index|]
operator|=
name|d
operator|->
name|relgiven
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* determine whether there are any keys at all */
name|keyno
operator|=
literal|0
expr_stmt|;
name|keywid
operator|=
literal|0
expr_stmt|;
name|sort_only
operator|=
name|FALSE
expr_stmt|;
name|cp
operator|=
name|pv
operator|->
name|pv_val
operator|.
name|pv_str
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|*
name|cp
operator|==
name|NULL
condition|)
block|{
comment|/* no key information. default as needed */
if|if
condition|(
name|mp
operator|->
name|yeskeys
condition|)
block|{
name|cp
operator|=
literal|"\1"
expr_stmt|;
comment|/* default to first key */
name|namemode
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|pv
operator|++
expr_stmt|;
comment|/* point one to far */
block|}
else|else
block|{
comment|/* check for name mode */
if|if
condition|(
name|namemode
operator|=
name|sequal
argument_list|(
name|cp
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
comment|/* check attribute names, and convert them to numbers */
name|opencatalog
argument_list|(
literal|"attribute"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|attkey
argument_list|,
name|Mod_info
operator|.
name|infile
argument_list|,
name|ATTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|attkey
argument_list|,
name|Usercode
argument_list|,
name|ATTOWNER
argument_list|)
expr_stmt|;
block|}
name|pv
operator|++
expr_stmt|;
comment|/* inc to next key */
name|cp
operator|=
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
expr_stmt|;
block|}
comment|/* scan for attribute names */
for|for
control|(
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
control|)
block|{
comment|/* check for separator between keys& options */
if|if
condition|(
operator|*
name|cp
operator|==
name|NULL
condition|)
block|{
name|pv
operator|++
expr_stmt|;
comment|/* point two past NULL */
break|break;
block|}
if|if
condition|(
name|namemode
condition|)
block|{
comment|/* check for "sort only" attribute */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'#'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
comment|/* inc to start of name */
name|sort_only
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* check for ascending/descending modifier */
if|if
condition|(
operator|(
name|as_ds
operator|=
name|modseqkey
argument_list|(
name|cp
argument_list|,
name|relname
argument_list|,
name|mp
operator|->
name|yes_seq
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
name|as_ds
operator|)
return|;
comment|/* error */
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|attkey
argument_list|,
name|cp
argument_list|,
name|ATTNAME
argument_list|)
expr_stmt|;
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|attkey
argument_list|,
operator|&
name|atttup
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"MODIFY: geteq(att) %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|error
argument_list|(
literal|5511
argument_list|,
name|relname
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* bad att name */
block|}
name|i
operator|=
name|atttup
operator|.
name|attid
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|*
name|cp
expr_stmt|;
name|as_ds
operator|=
literal|0
expr_stmt|;
block|}
comment|/* add new key to descriptor */
name|keyno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|sort_only
condition|)
block|{
name|d
operator|->
name|relxtra
index|[
name|i
index|]
operator|=
name|keyno
expr_stmt|;
name|keywid
operator|+=
operator|(
name|d
operator|->
name|relfrml
index|[
name|i
index|]
operator|&
name|I1MASK
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|relgiven
index|[
name|i
index|]
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5507
argument_list|,
name|relname
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* duplicate attribute */
name|d
operator|->
name|relgiven
index|[
name|i
index|]
operator|=
name|as_ds
operator|==
literal|0
condition|?
name|keyno
else|:
operator|-
name|keyno
expr_stmt|;
block|}
name|pv
operator|--
expr_stmt|;
comment|/* back up one to point to "-1" terminator */
if|if
condition|(
name|abs
argument_list|(
name|d
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_ISAM
operator|&&
name|keywid
operator|>
operator|(
name|MAXTUP
operator|/
literal|2
operator|-
literal|4
operator|)
condition|)
block|{
return|return
operator|(
name|error
argument_list|(
literal|5508
argument_list|,
name|relname
argument_list|,
name|iocv
argument_list|(
name|keywid
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* if a heap, there can be no keys */
if|if
condition|(
operator|!
name|mp
operator|->
name|yeskeys
operator|&&
name|keyno
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
argument_list|(
literal|5502
argument_list|,
name|relname
argument_list|,
name|mp
operator|->
name|type
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* no keys allowed on heap */
block|}
comment|/* fill out default sort on remainder of keys */
if|if
condition|(
name|mp
operator|->
name|yeskeys
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|d
operator|->
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|relgiven
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|d
operator|->
name|relgiven
index|[
name|i
index|]
operator|=
operator|++
name|keyno
expr_stmt|;
operator|*
name|ppv
operator|=
name|pv
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|modseqkey
argument_list|(
argument|domain
argument_list|,
argument|relname
argument_list|,
argument|seq_ok
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|relname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|seq_ok
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|domain
init|;
name|c
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
comment|/* replace ":" with null */
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* verify sequence is valid */
if|if
condition|(
operator|!
name|seq_ok
condition|)
name|ret
operator|=
name|error
argument_list|(
literal|5520
argument_list|,
name|relname
argument_list|,
name|cp
argument_list|,
name|domain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sequal
argument_list|(
literal|"descending"
argument_list|,
name|cp
argument_list|)
operator|||
name|sequal
argument_list|(
literal|"d"
argument_list|,
name|cp
argument_list|)
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|sequal
argument_list|(
literal|"ascending"
argument_list|,
name|cp
argument_list|)
operator|||
name|sequal
argument_list|(
literal|"a"
argument_list|,
name|cp
argument_list|)
operator|)
condition|)
name|ret
operator|=
name|error
argument_list|(
literal|5518
argument_list|,
name|relname
argument_list|,
name|cp
argument_list|,
name|domain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	GETFILL -- Get fill factor and minimum pages parameters **		from argument list, convert them from ascii to integer **		and store them in global variables.  If the global **		variable for the corresponding parameter is zero, **		it means that that parameter is not allowed and an **		error is generated. */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|getfill
argument_list|(
name|pv
argument_list|,
name|rel
argument_list|,
name|mp
argument_list|)
specifier|register
name|PARM
operator|*
name|pv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|rel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|modtab
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|int
name|fill_flag
decl_stmt|,
name|min_flag
decl_stmt|,
name|max_flag
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|fill_flag
operator|=
name|min_flag
operator|=
name|max_flag
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|p1
operator|=
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p2
operator|=
operator|(
name|pv
operator|++
operator|)
operator|->
name|pv_val
operator|.
name|pv_str
expr_stmt|;
if|if
condition|(
name|sequal
argument_list|(
name|p1
argument_list|,
literal|"fillfactor"
argument_list|)
condition|)
block|{
if|if
condition|(
name|F_fac
operator|==
literal|0
operator|||
name|fill_flag
condition|)
block|{
name|err
operator|=
literal|5512
expr_stmt|;
break|break;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
name|atoi
argument_list|(
name|p1
argument_list|,
operator|&
name|F_fac
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_fac
operator|>
literal|100
operator|||
name|F_fac
operator|<
literal|1
condition|)
block|{
name|err
operator|=
literal|5513
expr_stmt|;
break|break;
block|}
name|fill_flag
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sequal
argument_list|(
name|p1
argument_list|,
literal|"minpages"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Mn_pages
operator|==
literal|0
operator|||
name|min_flag
condition|)
block|{
name|err
operator|=
literal|5512
expr_stmt|;
break|break;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
name|atoi
argument_list|(
name|p1
argument_list|,
operator|&
name|Mn_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mn_pages
operator|<
literal|1
condition|)
block|{
name|err
operator|=
literal|5514
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|max_flag
operator|&&
operator|(
name|Mn_pages
operator|>
name|Mx_pages
operator|)
condition|)
block|{
name|err
operator|=
literal|5517
expr_stmt|;
break|break;
block|}
name|min_flag
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sequal
argument_list|(
name|p1
argument_list|,
literal|"maxpages"
argument_list|)
condition|)
block|{
if|if
condition|(
name|Mx_pages
operator|==
literal|0
operator|||
name|max_flag
condition|)
block|{
name|err
operator|=
literal|5512
expr_stmt|;
break|break;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
name|atoi
argument_list|(
name|p1
argument_list|,
operator|&
name|Mx_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mx_pages
operator|<
literal|1
condition|)
block|{
name|err
operator|=
literal|5516
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|min_flag
operator|&&
operator|(
name|Mn_pages
operator|>
name|Mx_pages
operator|)
condition|)
block|{
name|err
operator|=
literal|5517
expr_stmt|;
break|break;
block|}
name|max_flag
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|err
operator|=
literal|5515
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|error
argument_list|(
name|err
argument_list|,
name|rel
argument_list|,
name|p1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKE_NEWREL -- Create a file for the modified relation **	and build one or more primary pages for the **	relation based on its storage structure and the **	number of tuples it must hold. */
end_comment

begin_expr_stmt
name|make_newrel
argument_list|(
name|desc
argument_list|)
specifier|register
name|DESC
operator|*
name|desc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|tups_p_page
decl_stmt|;
name|concat
argument_list|(
name|MODTEMP
argument_list|,
name|Fileset
argument_list|,
name|Mod_info
operator|.
name|reltemp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|Mod_info
operator|.
name|reltemp
argument_list|,
name|FILEMODE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|relfp
operator|=
name|open
argument_list|(
name|Mod_info
operator|.
name|reltemp
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"MAKE_NEWREL: open %.14s %d"
argument_list|,
name|Mod_info
operator|.
name|reltemp
argument_list|,
name|desc
operator|->
name|relfp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|relopn
operator|=
operator|(
name|desc
operator|->
name|relfp
operator|+
literal|1
operator|)
operator|*
operator|-
literal|5
expr_stmt|;
name|desc
operator|->
name|reldum
operator|.
name|relprim
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|desc
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_HASH
operator|&&
name|F_fac
operator|>
literal|0
operator|&&
name|Mn_pages
operator|>
literal|0
condition|)
block|{
comment|/* 		** Determine the number of primary pages. The following 		** first determines the number of tuples/page which the 		** relation should have in order to get the requested 		** fillfactor. Then that number is divided into the 		** number of tuples to get the number of primary pages. 		** To avoid round off, it must guaranteed that the 		** number of tuples per page must be at least 1. 		** 		** primary_pages = #tuples / (#tuples/page * fillfactor) 		*/
name|tups_p_page
operator|=
operator|(
operator|(
operator|(
name|MAXTUP
operator|+
literal|2
operator|)
operator|/
operator|(
name|desc
operator|->
name|reldum
operator|.
name|relwid
operator|+
literal|2
operator|)
operator|)
operator|*
name|F_fac
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|tups_p_page
operator|==
literal|0
condition|)
name|tups_p_page
operator|=
literal|1
expr_stmt|;
comment|/* we add one to simulate a ceiling function */
name|desc
operator|->
name|reldum
operator|.
name|relprim
operator|=
name|desc
operator|->
name|reldum
operator|.
name|reltups
operator|/
name|tups_p_page
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|reldum
operator|.
name|relprim
operator|<
name|Mn_pages
condition|)
name|desc
operator|->
name|reldum
operator|.
name|relprim
operator|=
name|Mn_pages
expr_stmt|;
if|if
condition|(
name|Mx_pages
operator|>
literal|0
operator|&&
name|desc
operator|->
name|reldum
operator|.
name|relprim
operator|>
name|Mx_pages
condition|)
name|desc
operator|->
name|reldum
operator|.
name|relprim
operator|=
name|Mx_pages
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"using %ld prim pages\n"
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relprim
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|desc
operator|->
name|reldum
operator|.
name|reltups
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	SORTREL - Call KSORT to sort the given relation.  SORTREL **		sets up the descriptor struct specifying the sort **		keys and tells KSORT whether or not the hash key should **		be included as a sort key. */
end_comment

begin_macro
name|sortrel
argument_list|(
argument|odesc
argument_list|,
argument|desc
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|odesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|DESC
modifier|*
name|desc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|Pathname
decl_stmt|;
specifier|register
name|int
name|fp
decl_stmt|,
name|i
decl_stmt|;
name|char
name|savespec
decl_stmt|;
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|concat
argument_list|(
name|ISAM_SORTED
argument_list|,
name|Fileset
argument_list|,
name|Mod_info
operator|.
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|creat
argument_list|(
name|Mod_info
operator|.
name|outfile
argument_list|,
name|FILEMODE
argument_list|)
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"SORTREL: creat %.14s"
argument_list|,
name|Mod_info
operator|.
name|outfile
argument_list|)
expr_stmt|;
name|concat
argument_list|(
name|ISAM_DESC
argument_list|,
name|Fileset
argument_list|,
name|Mod_info
operator|.
name|formfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|creat
argument_list|(
name|Mod_info
operator|.
name|formfile
argument_list|,
name|FILEMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"SORTREL: creat %.14s %d"
argument_list|,
name|Mod_info
operator|.
name|formfile
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|desc
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
operator|==
name|M_HASH
condition|)
block|{
comment|/* sort on hash bucket first */
name|desc
operator|->
name|relgiven
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|desc
operator|->
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
name|desc
operator|->
name|relgiven
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
name|savespec
operator|=
name|desc
operator|->
name|reldum
operator|.
name|relspec
expr_stmt|;
name|desc
operator|->
name|reldum
operator|.
name|relspec
operator|=
name|odesc
operator|->
name|reldum
operator|.
name|relspec
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sortrel: "
argument_list|)
expr_stmt|;
name|printdesc
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|write
argument_list|(
name|fp
argument_list|,
name|desc
argument_list|,
sizeof|sizeof
expr|*
name|desc
argument_list|)
operator|!=
sizeof|sizeof
expr|*
name|desc
condition|)
name|syserr
argument_list|(
literal|"SORTREL: desc write err"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|reldum
operator|.
name|relspec
operator|=
name|savespec
expr_stmt|;
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"SORTREL: fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|NOFILE
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KSORTPATH
name|smove
argument_list|(
name|KSORTPATH
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|concat
argument_list|(
name|Pathname
argument_list|,
name|ztack
argument_list|(
literal|"/bin/ksort"
argument_list|,
name|VERSION
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|KSORTPATH
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Calling ksort, args:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbuf = `%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tFileset = `%s'\n"
argument_list|,
name|Fileset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttTf = `%s'\n"
argument_list|,
name|iocv
argument_list|(
name|tTf
argument_list|(
literal|37
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tformfile = `%s'\n"
argument_list|,
name|Mod_info
operator|.
name|formfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tinfile = `%s'\n"
argument_list|,
name|Mod_info
operator|.
name|infile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\toutfile = `%s'\n"
argument_list|,
name|Mod_info
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|xZTR2
name|execl
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
name|Fileset
argument_list|,
name|iocv
argument_list|(
name|tTf
argument_list|(
literal|37
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
name|Mod_info
operator|.
name|formfile
argument_list|,
name|Mod_info
operator|.
name|infile
argument_list|,
name|Mod_info
operator|.
name|outfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"SORTREL: exec %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|xZTR1
name|tTfp
argument_list|(
literal|36
argument_list|,
literal|9
argument_list|,
literal|"SORTREL: after execl; pid = %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fp
operator|=
name|fullwait
argument_list|(
name|i
argument_list|,
literal|"modify"
argument_list|)
condition|)
comment|/* wait for ksort to complete */
name|syserr
argument_list|(
literal|"modify:ksort failed %d"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
name|tTfp
argument_list|(
literal|36
argument_list|,
literal|10
argument_list|,
literal|"SORTREL: after fullwait\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unlink
argument_list|(
name|Mod_info
operator|.
name|formfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	FILL_REL -- Fill the new relation with tuples from either **		the old relation or the output file of KSORT. */
end_comment

begin_expr_stmt
name|fill_rel
argument_list|(
name|sdesc
argument_list|,
name|desc
argument_list|,
name|sortit
argument_list|)
specifier|register
name|DESC
operator|*
name|sdesc
operator|,
operator|*
name|desc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|sortit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tup_buf
index|[
name|MAXTUP
index|]
decl_stmt|,
name|last_tup
index|[
name|MAXTUP
index|]
decl_stmt|;
name|char
name|junk
index|[
literal|4
index|]
decl_stmt|,
name|newreltype
decl_stmt|,
name|anytups
decl_stmt|,
name|chkdups
decl_stmt|;
name|int
name|need
decl_stmt|,
name|j
decl_stmt|;
name|long
name|lnum
decl_stmt|;
name|TID
name|tid
decl_stmt|,
name|stid
decl_stmt|,
name|stidlim
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|spfp
decl_stmt|;
name|newreltype
operator|=
name|abs
argument_list|(
name|desc
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortit
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|Mod_info
operator|.
name|outfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: fopen %.14s"
argument_list|,
name|Mod_info
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cleanrel
argument_list|(
name|sdesc
argument_list|)
expr_stmt|;
comment|/* make sure each page is read fresh */
name|find
argument_list|(
name|sdesc
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|stid
argument_list|,
operator|&
name|stidlim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newreltype
operator|==
name|M_ISAM
condition|)
block|{
name|lnum
operator|=
literal|0
expr_stmt|;
name|stuff_page
argument_list|(
operator|&
name|tid
argument_list|,
operator|&
name|lnum
argument_list|)
expr_stmt|;
name|tid
operator|.
name|line_id
operator|=
literal|0
expr_stmt|;
name|get_page
argument_list|(
name|desc
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
name|concat
argument_list|(
name|ISAM_SPOOL
argument_list|,
name|Fileset
argument_list|,
name|Mod_info
operator|.
name|spfile
argument_list|)
expr_stmt|;
comment|/* assume that spool file is not needed */
name|spfp
operator|=
name|NULL
expr_stmt|;
name|Mod_info
operator|.
name|spflag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|F_fac
operator|==
literal|0
condition|)
name|F_fac
operator|=
literal|100
expr_stmt|;
comment|/* setup relgiven field for kcompare later on */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|desc
operator|->
name|reldum
operator|.
name|relatts
condition|;
name|i
operator|++
control|)
name|desc
operator|->
name|relgiven
index|[
name|i
index|]
operator|=
name|desc
operator|->
name|relxtra
index|[
name|i
index|]
expr_stmt|;
block|}
name|desc
operator|->
name|reladds
operator|=
literal|0
expr_stmt|;
name|anytups
operator|=
name|FALSE
expr_stmt|;
name|chkdups
operator|=
operator|!
name|sortit
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"  FILLREL: "
argument_list|)
expr_stmt|;
name|printdesc
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sortit
condition|)
block|{
name|i
operator|=
name|fread
argument_list|(
name|tup_buf
argument_list|,
literal|1
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relwid
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|desc
operator|->
name|reldum
operator|.
name|relwid
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: fread A %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreltype
operator|==
name|M_HASH
condition|)
if|if
condition|(
name|fread
argument_list|(
name|junk
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|fp
argument_list|)
operator|!=
literal|4
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: fread B"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FILL_REL: stid "
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|stid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FILL_REL: stidlim "
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|stidlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|get
argument_list|(
name|sdesc
argument_list|,
operator|&
name|stid
argument_list|,
operator|&
name|stidlim
argument_list|,
name|tup_buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FILLREL: get %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printup
argument_list|(
name|sdesc
argument_list|,
name|tup_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: get %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|newreltype
operator|!=
name|M_ISAM
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|insert
argument_list|(
name|desc
argument_list|,
operator|&
name|tid
argument_list|,
name|tup_buf
argument_list|,
name|chkdups
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: insert %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|36
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FILL_REL: insert "
argument_list|)
expr_stmt|;
name|printup
argument_list|(
name|desc
argument_list|,
name|tup_buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FILL_REL: insert ret %d at"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dumptid
argument_list|(
operator|&
name|tid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|anytups
condition|)
name|i
operator|=
name|kcompare
argument_list|(
name|desc
argument_list|,
name|tup_buf
argument_list|,
name|last_tup
argument_list|)
expr_stmt|;
else|else
block|{
name|anytups
operator|=
name|TRUE
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|bmove
argument_list|(
name|tup_buf
argument_list|,
name|last_tup
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relwid
argument_list|)
expr_stmt|;
name|need
operator|=
name|canonical
argument_list|(
name|desc
argument_list|,
name|tup_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|need
operator|>
name|space_left
argument_list|(
name|Acc_head
argument_list|)
condition|)
block|{
comment|/* spool out this tuple. will go on overflow page later */
if|if
condition|(
name|spfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|spfp
operator|=
name|fopen
argument_list|(
name|Mod_info
operator|.
name|spfile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: fopen %.14s"
argument_list|,
name|Mod_info
operator|.
name|spfile
argument_list|)
expr_stmt|;
name|Mod_info
operator|.
name|spflag
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|tup_buf
argument_list|,
literal|1
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relwid
argument_list|,
name|spfp
argument_list|)
operator|!=
name|desc
operator|->
name|reldum
operator|.
name|relwid
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: putb spool"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|j
operator|=
operator|(
literal|100
operator|-
name|F_fac
operator|)
operator|*
name|MAXTUP
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|need
condition|)
name|j
operator|=
name|need
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|j
operator|>
name|space_left
argument_list|(
name|Acc_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|add_prim
argument_list|(
name|desc
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"FILL_REL: force ovflo %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|tid
operator|.
name|line_id
operator|=
name|newlino
argument_list|(
name|need
argument_list|)
expr_stmt|;
name|put_tuple
argument_list|(
operator|&
name|tid
argument_list|,
name|Acctuple
argument_list|,
name|need
argument_list|)
expr_stmt|;
name|desc
operator|->
name|reladds
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sortit
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|Mod_info
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newreltype
operator|==
name|M_ISAM
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|pageflush
argument_list|(
name|Acc_head
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"fill_rel:pg clean %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|spfp
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|spfp
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|reldum
operator|.
name|reltups
operator|=
name|desc
operator|->
name|reladds
expr_stmt|;
name|desc
operator|->
name|reladds
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|bldindex
argument_list|(
name|d
argument_list|)
specifier|register
name|DESC
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|TID
modifier|*
name|tid
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
name|TID
name|tidx
decl_stmt|;
name|struct
name|accbuf
name|dirbuf
decl_stmt|;
name|int
name|keywid
decl_stmt|,
name|level
decl_stmt|,
name|savespec
decl_stmt|,
name|keyx
index|[
name|MAXDOM
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|len
decl_stmt|;
name|char
name|tuple
index|[
name|MAXTUP
index|]
decl_stmt|,
name|temptup
index|[
name|MAXTUP
index|]
decl_stmt|,
modifier|*
name|key
decl_stmt|;
name|long
name|pageid
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|,
name|newstart
decl_stmt|,
name|newstop
decl_stmt|;
name|tid
operator|=
operator|&
name|tidx
expr_stmt|;
name|keywid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|MAXDOM
condition|;
name|tmp
operator|++
control|)
name|keyx
index|[
name|tmp
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|1
init|;
name|tmp
operator|<=
name|d
operator|->
name|reldum
operator|.
name|relatts
condition|;
name|tmp
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|relxtra
index|[
name|tmp
index|]
operator|>
literal|0
condition|)
block|{
name|keyx
index|[
name|d
operator|->
name|relxtra
index|[
name|tmp
index|]
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|keywid
operator|+=
name|d
operator|->
name|relfrml
index|[
name|tmp
index|]
operator|&
name|I1MASK
expr_stmt|;
block|}
comment|/* Determine the last page of the relation. This will 	** only work if all pages have been written out. Fill_rel 	** must guarantee that all pages have been written 	*/
name|level
operator|=
literal|0
expr_stmt|;
name|last_page
argument_list|(
name|d
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pluck_page
argument_list|(
name|tid
argument_list|,
operator|&
name|stop
argument_list|)
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|dirbuf
operator|.
name|filedesc
operator|=
name|d
operator|->
name|relfp
expr_stmt|;
name|dirbuf
operator|.
name|rel_tupid
operator|=
name|d
operator|->
name|reltid
operator|.
name|ltid
expr_stmt|;
name|savespec
operator|=
name|d
operator|->
name|reldum
operator|.
name|relspec
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|38
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"isam: level %d\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dirbuf
operator|.
name|ovflopg
operator|=
name|start
expr_stmt|;
name|dirbuf
operator|.
name|mainpg
operator|=
name|level
expr_stmt|;
name|dirbuf
operator|.
name|thispage
operator|=
name|stop
operator|+
literal|1
expr_stmt|;
name|dirbuf
operator|.
name|linetab
index|[
literal|0
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|dirbuf
operator|.
name|firstup
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
name|offset
operator|=
name|dirbuf
operator|.
name|linetab
index|[
literal|0
index|]
expr_stmt|;
name|dirbuf
operator|.
name|bufstatus
operator|=
name|BUF_DIRTY
operator||
name|BUF_DIRECT
expr_stmt|;
name|dirbuf
operator|.
name|nxtlino
operator|=
literal|0
expr_stmt|;
name|newstart
operator|=
name|stop
operator|+
literal|1
expr_stmt|;
name|newstop
operator|=
name|newstart
expr_stmt|;
for|for
control|(
name|pageid
operator|=
name|start
init|;
name|pageid
operator|<=
name|stop
condition|;
name|pageid
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|xZTR2
if|if
condition|(
name|tTf
argument_list|(
literal|38
argument_list|,
literal|8
argument_list|)
condition|)
name|printf
argument_list|(
literal|"isam:get key from %ld\n"
argument_list|,
name|pageid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stuff_page
argument_list|(
name|tid
argument_list|,
operator|&
name|pageid
argument_list|)
expr_stmt|;
name|tid
operator|->
name|line_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmp
operator|=
name|get
argument_list|(
name|d
argument_list|,
name|tid
argument_list|,
name|tid
argument_list|,
name|tuple
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
comment|/* 				** If the relation is empty, then page 0 will 				** return AMINVL_ERR on a get(). Form a blank tuple 				** and use it to create a one tuple directory 				*/
if|if
condition|(
name|pageid
operator|==
literal|0
operator|&&
name|tmp
operator|==
name|AMINVL_ERR
condition|)
block|{
name|clr_tuple
argument_list|(
name|d
argument_list|,
name|tuple
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
comment|/* 			** If this is the first level then form the tuple 			** from the mainpage of the relation. Otherwise 			** the tuple is the first tuple of a directory page 			** and it is already correctly formed. 			*/
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
name|key
operator|=
name|temptup
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|keyx
index|[
name|tmp
index|]
operator|!=
literal|0
condition|;
name|tmp
operator|++
control|)
block|{
name|len
operator|=
name|d
operator|->
name|relfrml
index|[
name|keyx
index|[
name|tmp
index|]
index|]
operator|&
name|I1MASK
expr_stmt|;
name|bmove
argument_list|(
operator|&
name|tuple
index|[
name|d
operator|->
name|reloff
index|[
name|keyx
index|[
name|tmp
index|]
index|]
index|]
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|key
operator|+=
name|len
expr_stmt|;
block|}
name|key
operator|=
name|temptup
expr_stmt|;
block|}
else|else
name|key
operator|=
name|tuple
expr_stmt|;
if|if
condition|(
name|keywid
operator|>
name|space_left
argument_list|(
operator|&
name|dirbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|pageflush
argument_list|(
operator|&
name|dirbuf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
name|dirbuf
operator|.
name|thispage
operator|++
expr_stmt|;
name|newstop
operator|=
name|dirbuf
operator|.
name|thispage
expr_stmt|;
name|dirbuf
operator|.
name|ovflopg
operator|=
name|pageid
expr_stmt|;
name|dirbuf
operator|.
name|linetab
index|[
literal|0
index|]
operator|=
call|(
name|short
call|)
argument_list|(
name|dirbuf
operator|.
name|firstup
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
name|offset
operator|=
name|dirbuf
operator|.
name|linetab
index|[
literal|0
index|]
expr_stmt|;
name|dirbuf
operator|.
name|bufstatus
operator|=
name|BUF_DIRTY
expr_stmt|;
name|dirbuf
operator|.
name|nxtlino
operator|=
literal|0
expr_stmt|;
block|}
comment|/* copy key to directory page */
name|bmove
argument_list|(
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dirbuf
operator|+
name|offset
argument_list|,
name|keywid
argument_list|)
expr_stmt|;
comment|/* update next line number */
name|offset
operator|+=
name|keywid
expr_stmt|;
name|dirbuf
operator|.
name|nxtlino
operator|++
expr_stmt|;
name|dirbuf
operator|.
name|linetab
index|[
operator|-
name|dirbuf
operator|.
name|nxtlino
index|]
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|pageflush
argument_list|(
operator|&
name|dirbuf
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|4
operator|)
return|;
if|if
condition|(
name|newstart
operator|==
name|newstop
condition|)
break|break;
name|d
operator|->
name|reldum
operator|.
name|relspec
operator|=
name|abs
argument_list|(
name|d
operator|->
name|reldum
operator|.
name|relspec
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
name|start
operator|=
name|newstart
expr_stmt|;
name|stop
operator|=
name|newstop
expr_stmt|;
block|}
name|d
operator|->
name|reldum
operator|.
name|relspec
operator|=
name|savespec
expr_stmt|;
name|d
operator|->
name|reldum
operator|.
name|relprim
operator|=
name|newstart
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	UNSPOOL -- Take tuples saved in spool file and insert them **		in new relation.  This is only for ISAM relations. */
end_comment

begin_expr_stmt
name|unspool
argument_list|(
name|desc
argument_list|)
specifier|register
name|DESC
operator|*
name|desc
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TID
name|tid
decl_stmt|;
name|char
name|tup_buf
index|[
name|MAXTUP
index|]
decl_stmt|;
name|FILE
modifier|*
name|spfp
decl_stmt|;
if|if
condition|(
name|Mod_info
operator|.
name|spflag
condition|)
block|{
if|if
condition|(
operator|(
name|spfp
operator|=
name|fopen
argument_list|(
name|Mod_info
operator|.
name|spfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"UNSPOOL: fopen spool"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|fread
argument_list|(
name|tup_buf
argument_list|,
literal|1
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relwid
argument_list|,
name|spfp
argument_list|)
operator|)
operator|==
name|desc
operator|->
name|reldum
operator|.
name|relwid
condition|)
if|if
condition|(
operator|(
name|i
operator|=
name|insert
argument_list|(
name|desc
argument_list|,
operator|&
name|tid
argument_list|,
name|tup_buf
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"UNSPOOL: insert %.14s %d"
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|syserr
argument_list|(
literal|"UNSPOOL: read %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|spfp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|Mod_info
operator|.
name|spfile
argument_list|)
expr_stmt|;
block|}
name|desc
operator|->
name|reldum
operator|.
name|reltups
operator|+=
name|desc
operator|->
name|reladds
expr_stmt|;
name|desc
operator|->
name|reladds
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	FILL_BATCH -- Create and fill a batch file containing the **		updates for the system catalog so that MODIFY will **		be recoverable if the system crashes. */
end_comment

begin_macro
name|fill_batch
argument_list|(
argument|odesc
argument_list|,
argument|desc
argument_list|)
end_macro

begin_decl_stmt
name|DESC
modifier|*
name|odesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|DESC
modifier|*
name|desc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DESC
modifier|*
name|dessys
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|relation
name|reltup
decl_stmt|,
name|rkey
decl_stmt|;
name|TID
name|tid
decl_stmt|,
name|lotid
decl_stmt|,
name|hitid
decl_stmt|;
name|struct
name|attribute
name|atttup
decl_stmt|,
name|akey
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|prebatch
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|,
name|modbatch
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|bequal
argument_list|(
name|desc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
literal|"relation    "
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|clearkeys
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|desc
argument_list|,
operator|&
name|rkey
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|RELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|desc
argument_list|,
operator|&
name|rkey
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|RELOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|getequal
argument_list|(
name|desc
argument_list|,
operator|&
name|rkey
argument_list|,
operator|&
name|reltup
argument_list|,
operator|&
name|tid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"FILL_BATCH: geteq rel rel %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|&
name|tid
argument_list|,
operator|&
name|desc
operator|->
name|reltid
argument_list|,
sizeof|sizeof
name|desc
operator|->
name|reltid
argument_list|)
expr_stmt|;
block|}
else|else
name|bmove
argument_list|(
operator|&
name|odesc
operator|->
name|reltid
argument_list|,
operator|&
name|desc
operator|->
name|reltid
argument_list|,
sizeof|sizeof
name|desc
operator|->
name|reltid
argument_list|)
expr_stmt|;
name|resetacc
argument_list|(
name|Acc_head
argument_list|)
expr_stmt|;
name|concat
argument_list|(
name|MOD_PREBATCH
argument_list|,
name|Fileset
argument_list|,
name|prebatch
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|prebatch
argument_list|,
name|FILEMODE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Batch_fp
operator|=
name|open
argument_list|(
name|prebatch
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"FILL_BATCH: open %.14s %d"
argument_list|,
name|prebatch
argument_list|,
name|Batch_fp
argument_list|)
expr_stmt|;
name|smove
argument_list|(
name|Fileset
argument_list|,
name|Batchbuf
operator|.
name|file_id
argument_list|)
expr_stmt|;
name|Batch_cnt
operator|=
literal|0
expr_stmt|;
name|wrbatch
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
expr|*
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bequal
argument_list|(
name|desc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
literal|"attribute   "
argument_list|,
literal|12
argument_list|)
condition|)
name|dessys
operator|=
name|desc
expr_stmt|;
else|else
name|dessys
operator|=
operator|&
name|Admin
operator|.
name|adattd
expr_stmt|;
name|clearkeys
argument_list|(
name|dessys
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|dessys
argument_list|,
operator|&
name|akey
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|ATTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
name|dessys
argument_list|,
operator|&
name|akey
argument_list|,
name|desc
operator|->
name|reldum
operator|.
name|relowner
argument_list|,
name|ATTOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|=
name|find
argument_list|(
name|dessys
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|akey
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"FILL_BATCH: find %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|j
operator|=
name|desc
operator|->
name|reldum
operator|.
name|relatts
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|i
operator|=
name|get
argument_list|(
name|dessys
argument_list|,
operator|&
name|lotid
argument_list|,
operator|&
name|hitid
argument_list|,
operator|&
name|atttup
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|&&
name|j
operator|>
literal|0
condition|)
if|if
condition|(
operator|!
name|kcompare
argument_list|(
name|dessys
argument_list|,
operator|&
name|akey
argument_list|,
operator|&
name|atttup
argument_list|)
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|atttup
operator|.
name|attxtra
operator|=
name|desc
operator|->
name|relxtra
index|[
name|atttup
operator|.
name|attid
index|]
expr_stmt|;
name|wrbatch
argument_list|(
operator|&
name|lotid
argument_list|,
sizeof|sizeof
name|lotid
argument_list|)
expr_stmt|;
name|wrbatch
argument_list|(
operator|&
name|atttup
argument_list|,
sizeof|sizeof
name|atttup
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|j
operator|>
literal|0
condition|)
name|syserr
argument_list|(
literal|"FILL_BATCH: get att %d count %d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* get rid of attribute pages */
name|cleanrel
argument_list|(
name|dessys
argument_list|)
expr_stmt|;
name|flushbatch
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|Batch_fp
argument_list|)
expr_stmt|;
name|concat
argument_list|(
name|MODBATCH
argument_list|,
name|Fileset
argument_list|,
name|modbatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|prebatch
argument_list|,
name|modbatch
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"FILL_BATCH: can't link %.14s %.14s"
argument_list|,
name|prebatch
argument_list|,
name|modbatch
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|prebatch
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

