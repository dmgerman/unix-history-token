begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<func.h>
end_include

begin_include
include|#
directive|include
file|<pv.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<lock.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)copy.c
literal|7.3
literal|4
argument|/
literal|7
argument|/
literal|82
argument_list|)
end_macro

begin_comment
comment|/* **  COPY -- Performs an ingres COPY. ** **	Trace Flags: **		30 */
end_comment

begin_define
define|#
directive|define
name|MAXMAP
value|3 * MAXDOM
end_define

begin_define
define|#
directive|define
name|DUMMY
value|'d'
end_define

begin_define
define|#
directive|define
name|ESCAPE
value|'\\'
end_define

begin_decl_stmt
specifier|extern
name|short
name|tTdbu
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|copy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|null_fn
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fn_def
name|CopyFn
init|=
block|{
literal|"COPY"
block|,
name|copy
block|,
name|null_fn
block|,
name|null_fn
block|,
name|NULL
block|,
literal|0
block|,
name|tTdbu
block|,
literal|100
block|,
literal|'Z'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|map
block|{
name|char
name|name
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* attribute name */
name|char
name|ftype
decl_stmt|;
comment|/* attfrmt of file domain */
name|char
name|rtype
decl_stmt|;
comment|/* attfrmt of relation domain */
name|int
name|flen
decl_stmt|;
comment|/* attfrml of file domain */
name|int
name|rlen
decl_stmt|;
comment|/* attfrml of relation domain */
name|int
name|roffset
decl_stmt|;
comment|/* attoff of relation domain */
name|int
name|used
decl_stmt|;
comment|/* tag for duplicate checking */
name|char
modifier|*
name|fdelim
decl_stmt|;
comment|/* pointer to list of file param delims */
name|char
modifier|*
name|paramname
decl_stmt|;
comment|/* pointer to original parameter name */
comment|/* used for supplying domain name in case of error */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|map
name|Map
index|[
name|MAXMAP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one entry for each user 				   specified domain in copy statement. */
end_comment

begin_decl_stmt
name|int
name|Mapcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of Map entries   */
end_comment

begin_decl_stmt
name|DESC
name|Des
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* descriptor for copied relation     */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|out_arg
name|Out_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user defined formats for numeric output */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|File_iop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i/o file pointer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to file name */
end_comment

begin_decl_stmt
name|int
name|Into
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* into is one if this is a copy into file */
end_comment

begin_decl_stmt
name|char
name|Inbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input holder */
end_comment

begin_decl_stmt
name|char
name|Outbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output holder */
end_comment

begin_decl_stmt
name|long
name|Tupcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of tuples processed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Relname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of relation */
end_comment

begin_decl_stmt
name|long
name|Duptuple
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of duplicate tuples */
end_comment

begin_decl_stmt
name|long
name|Baddoms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of domains with control chars */
end_comment

begin_decl_stmt
name|long
name|Truncount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of truncations on a c0 field */
end_comment

begin_decl_stmt
name|int
name|Piped
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pipe descriptor for copy communication */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Cpdomains
index|[]
init|=
comment|/* dummy domain names for copy "into" */
block|{
literal|"nl"
block|,
literal|"\n"
block|,
literal|"tab"
block|,
literal|"\t"
block|,
literal|"sp"
block|,
literal|" "
block|,
literal|"nul"
block|,
literal|"\0"
block|,
literal|"null"
block|,
literal|"\0"
block|,
literal|"comma"
block|,
literal|","
block|,
literal|"colon"
block|,
literal|":"
block|,
literal|"dash"
block|,
literal|"-"
block|,
literal|"lparen"
block|,
literal|"("
block|,
literal|"rparen"
block|,
literal|")"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Delimitor
index|[]
init|=
literal|",\n\t"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default delims for c0& d0 */
end_comment

begin_macro
name|copy
argument_list|(
argument|pc
argument_list|,
argument|pv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PARM
name|pv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|char
modifier|*
name|Usercode
decl_stmt|;
specifier|extern
name|int
name|Noupdt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|pid
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|int
name|copydone
parameter_list|()
function_decl|;
name|int
name|op
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|30
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"entered copy\n"
argument_list|)
expr_stmt|;
name|prvect
argument_list|(
name|pc
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|Duptuple
operator|=
literal|0
expr_stmt|;
name|Truncount
operator|=
literal|0
expr_stmt|;
name|Tupcount
operator|=
literal|0
expr_stmt|;
name|Baddoms
operator|=
literal|0
expr_stmt|;
name|Relname
operator|=
name|pv
index|[
literal|0
index|]
operator|.
name|pv_val
operator|.
name|pv_str
expr_stmt|;
name|Into
operator|=
operator|(
name|pv
index|[
name|pc
operator|-
literal|2
index|]
operator|.
name|pv_val
operator|.
name|pv_str
index|[
literal|0
index|]
operator|==
literal|'i'
operator|)
expr_stmt|;
name|Filename
operator|=
name|pv
index|[
name|pc
operator|-
literal|1
index|]
operator|.
name|pv_val
operator|.
name|pv_str
expr_stmt|;
comment|/* relation must exist and not be a system relation */
comment|/* in addition a copy "from" can't be done if the user */
comment|/* doesn't own the relation */
comment|/* and furthermore it can't have an index */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* assume all is well */
if|if
condition|(
name|op
operator|=
name|openr
argument_list|(
operator|&
name|Des
argument_list|,
literal|2
argument_list|,
name|Relname
argument_list|)
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|AMOPNVIEW_ERR
condition|)
name|i
operator|=
literal|5818
expr_stmt|;
else|else
block|{
if|if
condition|(
name|op
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"COPY: openr 1 (%.14s) %d"
argument_list|,
name|Relname
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
comment|/* non-existant relation */
name|i
operator|=
literal|5800
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Into
condition|)
block|{
if|if
condition|(
operator|(
name|Des
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTALL
operator|)
operator|&&
operator|(
name|Des
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_PROTRET
operator|)
operator|&&
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|Des
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
name|i
operator|=
literal|5822
expr_stmt|;
block|}
else|else
block|{
comment|/* extra checking if this is a copy "from" */
comment|/* must be owned by the user */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Usercode
argument_list|,
name|Des
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
literal|2
argument_list|)
condition|)
name|i
operator|=
literal|5814
expr_stmt|;
elseif|else
comment|/* must be updateable */
if|if
condition|(
operator|(
name|Des
operator|.
name|reldum
operator|.
name|relstat
operator|&
name|S_NOUPDT
operator|)
operator|&&
name|Noupdt
condition|)
name|i
operator|=
literal|5813
expr_stmt|;
elseif|else
comment|/* must not be indexed */
if|if
condition|(
name|Des
operator|.
name|reldum
operator|.
name|relindxd
operator|>
literal|0
condition|)
name|i
operator|=
literal|5812
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
condition|)
block|{
name|closer
argument_list|(
operator|&
name|Des
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
argument_list|(
name|i
argument_list|,
name|Relname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* relation doesn't exist for this user */
block|}
comment|/* check that file name begins with a "/" */
name|cp
operator|=
name|Filename
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
block|{
name|closer
argument_list|(
operator|&
name|Des
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
argument_list|(
literal|5816
argument_list|,
name|Filename
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
comment|/* fill map structures with transfer information */
if|if
condition|(
name|i
operator|=
name|mapfill
argument_list|(
operator|&
name|pv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|closer
argument_list|(
operator|&
name|Des
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
comment|/* error in user semantics */
block|}
comment|/* fork a child process which will run as the real user */
comment|/* that child will complete the copy and exit */
if|if
condition|(
name|pipe
argument_list|(
name|Piped
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"copy:can't make pipe"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"copy:can't fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
comment|/* the ingres parent */
name|close
argument_list|(
name|Piped
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ruboff
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* interrupts off */
name|stat
operator|=
name|fullwait
argument_list|(
name|pid
argument_list|,
literal|"copy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|Piped
index|[
literal|0
index|]
argument_list|,
operator|&
name|Des
operator|.
name|reladds
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
name|syserr
argument_list|(
literal|"copy:can't read pipe"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|Piped
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|closer
argument_list|(
operator|&
name|Des
argument_list|)
expr_stmt|;
comment|/* close the rel */
name|rubon
argument_list|()
expr_stmt|;
comment|/* if stat is != 0 then add on 5800 for error */
if|if
condition|(
name|stat
condition|)
name|stat
operator|+=
literal|5800
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
comment|/* done */
block|}
comment|/* the child. change to run as the real user */
if|if
condition|(
name|signal
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|signal
argument_list|(
literal|2
argument_list|,
name|copydone
argument_list|)
expr_stmt|;
comment|/* clean up on rubout */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|xB_UNIX
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Into
condition|)
comment|/* from relation into file */
block|{
if|if
condition|(
operator|(
name|File_iop
operator|=
name|fopen
argument_list|(
name|Filename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* create file for user */
name|i
operator|=
name|nferror
argument_list|(
literal|5806
argument_list|,
name|Filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cant create file */
else|else
block|{
if|if
condition|(
name|Lockrel
condition|)
comment|/* set a shared lock on relation*/
name|setrll
argument_list|(
name|A_SLP
argument_list|,
name|Des
operator|.
name|reltid
operator|.
name|ltid
argument_list|,
name|M_SHARE
argument_list|)
expr_stmt|;
name|i
operator|=
name|rel_file
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|/* from UNIX file into relation */
block|{
if|if
condition|(
operator|(
name|File_iop
operator|=
name|fopen
argument_list|(
name|Filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|i
operator|=
name|nferror
argument_list|(
literal|5805
argument_list|,
name|Filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cant open user file */
else|else
block|{
if|if
condition|(
name|Lockrel
condition|)
comment|/* set an exclusive lock on relat*/
name|setrll
argument_list|(
name|A_SLP
argument_list|,
name|Des
operator|.
name|reltid
operator|.
name|ltid
argument_list|,
name|M_EXCL
argument_list|)
expr_stmt|;
name|i
operator|=
name|file_rel
argument_list|()
expr_stmt|;
if|if
condition|(
name|Duptuple
condition|)
name|nferror
argument_list|(
literal|5819
argument_list|,
name|locv
argument_list|(
name|Duptuple
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* warning only */
if|if
condition|(
name|Baddoms
condition|)
name|nferror
argument_list|(
literal|5820
argument_list|,
name|locv
argument_list|(
name|Baddoms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* warning only */
block|}
block|}
name|copydone
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Finish up and exit after a copy or interrupt ** **	I is the return code. Since only a byte can be **	returned, only the least significant 2 decimal **	digits are returned. i is either 0 or a number like 58?? */
end_comment

begin_macro
name|copydone
argument_list|(
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Lockrel
condition|)
comment|/* unlock relation */
name|unlrl
argument_list|(
name|Des
operator|.
name|reltid
operator|.
name|ltid
argument_list|)
expr_stmt|;
if|if
condition|(
name|Truncount
condition|)
name|nferror
argument_list|(
literal|5821
argument_list|,
name|locv
argument_list|(
name|Truncount
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* warning only */
comment|/*  force the updates to be flushed */
name|cleanrel
argument_list|(
operator|&
name|Des
argument_list|)
expr_stmt|;
if|if
condition|(
name|File_iop
condition|)
name|fclose
argument_list|(
name|File_iop
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|Piped
index|[
literal|1
index|]
argument_list|,
operator|&
name|Des
operator|.
name|reladds
argument_list|,
literal|4
argument_list|)
operator|!=
literal|4
condition|)
name|syserr
argument_list|(
literal|"copyc:can't writepipe"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  REL_FILE -- copy from relation to file */
end_comment

begin_macro
name|rel_file
argument_list|()
end_macro

begin_block
block|{
name|int
name|j
decl_stmt|;
name|struct
name|tup_id
name|tid
decl_stmt|,
name|limtid
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|save
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
comment|/* set scan limits to scan the entire relation */
if|if
condition|(
name|find
argument_list|(
operator|&
name|Des
argument_list|,
name|NOKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"find error"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Des
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
name|Inbuf
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mp
operator|=
name|Map
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Mapcount
condition|;
name|i
operator|++
control|)
block|{
comment|/* For cases of char to numeric conversion, 			   there must be a null byte at the end of the 			   string. The character just past the current 			   domain is saved an a null byte inserted */
name|cp
operator|=
operator|&
name|Inbuf
index|[
name|mp
operator|->
name|roffset
operator|+
name|mp
operator|->
name|rlen
index|]
expr_stmt|;
comment|/* compute address */
name|save
operator|=
operator|*
name|cp
expr_stmt|;
comment|/* get the character */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* insert a null */
name|j
operator|=
name|transfer
argument_list|(
operator|&
name|Inbuf
index|[
name|mp
operator|->
name|roffset
index|]
argument_list|,
name|mp
operator|->
name|rtype
argument_list|,
name|mp
operator|->
name|rlen
argument_list|,
name|mp
operator|->
name|ftype
argument_list|,
name|mp
operator|->
name|flen
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* bad ascii to numeric conversion or field length too small */
return|return
operator|(
name|nferror
argument_list|(
name|j
argument_list|,
name|mp
operator|->
name|paramname
argument_list|,
operator|&
name|Inbuf
index|[
name|mp
operator|->
name|roffset
index|]
argument_list|,
name|locv
argument_list|(
name|Tupcount
argument_list|)
argument_list|,
name|Relname
argument_list|,
name|Filename
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
operator|*
name|cp
operator|=
name|save
expr_stmt|;
comment|/* restore the saved character */
name|offset
operator|+=
name|mp
operator|->
name|flen
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
name|Tupcount
operator|++
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|Outbuf
argument_list|,
literal|1
argument_list|,
name|offset
argument_list|,
name|File_iop
argument_list|)
operator|!=
name|offset
condition|)
name|syserr
argument_list|(
literal|"copy:cant write to user file %s"
argument_list|,
name|Filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"bad get from rel %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	file_rel is called to transfer tuples from **	the input file and append them to the relation ** **	Char domains are initialized to blank and numeric **	domains are initialized to zero. */
end_comment

begin_macro
name|file_rel
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
name|struct
name|tup_id
name|tid
decl_stmt|;
name|clr_tuple
argument_list|(
operator|&
name|Des
argument_list|,
name|Outbuf
argument_list|)
expr_stmt|;
comment|/* copy domains until an end of file or an error */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mp
operator|=
name|Map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Mapcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|=
name|bread
argument_list|(
name|mp
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
comment|/* force an error */
name|j
operator|=
literal|5815
expr_stmt|;
comment|/* unterminated string */
block|}
else|else
name|j
operator|=
literal|5810
expr_stmt|;
comment|/* end of file */
if|if
condition|(
name|i
condition|)
comment|/* error only if end of file during a tuple or unterminated string */
block|{
name|i
operator|=
name|nferror
argument_list|(
name|j
argument_list|,
name|mp
operator|->
name|paramname
argument_list|,
name|locv
argument_list|(
name|Tupcount
argument_list|)
argument_list|,
name|Filename
argument_list|,
name|Relname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
name|j
operator|=
name|transfer
argument_list|(
name|Inbuf
argument_list|,
name|mp
operator|->
name|ftype
argument_list|,
name|mp
operator|->
name|flen
argument_list|,
name|mp
operator|->
name|rtype
argument_list|,
name|mp
operator|->
name|rlen
argument_list|,
name|mp
operator|->
name|roffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* bad ascii to numeric or field length too small */
return|return
operator|(
name|nferror
argument_list|(
name|j
argument_list|,
name|mp
operator|->
name|paramname
argument_list|,
name|Inbuf
argument_list|,
name|locv
argument_list|(
name|Tupcount
argument_list|)
argument_list|,
name|Filename
argument_list|,
name|Relname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
name|mp
operator|++
expr_stmt|;
block|}
name|Tupcount
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|insert
argument_list|(
operator|&
name|Des
argument_list|,
operator|&
name|tid
argument_list|,
name|Outbuf
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"insert error %d rel=%s"
argument_list|,
name|j
argument_list|,
name|Relname
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
name|Duptuple
operator|++
expr_stmt|;
name|mp
operator|++
expr_stmt|;
block|}
comment|/*  	** This statement was here -- i don'T think it does anything, but we'll see 	** return (0);  	*/
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	transfer copies data from "*in" to **	Outbuf doing conversions whenever **	necessary */
end_comment

begin_macro
name|transfer
argument_list|(
argument|in
argument_list|,
argument|sf
argument_list|,
argument|sl
argument_list|,
argument|df
argument_list|,
argument|dl
argument_list|,
argument|doff
argument_list|)
end_macro

begin_decl_stmt
name|ANYTYPE
modifier|*
name|in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to input chars */
end_comment

begin_decl_stmt
name|char
name|sf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source format */
end_comment

begin_decl_stmt
name|int
name|sl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source length */
end_comment

begin_decl_stmt
name|char
name|df
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination format */
end_comment

begin_decl_stmt
name|int
name|dl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination length */
end_comment

begin_decl_stmt
name|int
name|doff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* destination offset */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|outp
decl_stmt|;
specifier|register
name|ANYTYPE
modifier|*
name|inp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|temp
index|[
name|MAXFIELD
index|]
decl_stmt|;
comment|/* holds char during conversions to ascii */
name|float
name|f
decl_stmt|;
name|double
name|d
decl_stmt|;
name|long
name|l
decl_stmt|;
name|outp
operator|=
operator|&
name|Outbuf
index|[
name|doff
index|]
expr_stmt|;
name|inp
operator|=
name|in
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|DUMMY
condition|)
comment|/* if source format is a dummy fields then 		   nothing else need be done */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|df
operator|==
name|DUMMY
condition|)
block|{
comment|/* fill field with dummy domain character */
name|i
operator|=
name|dl
expr_stmt|;
comment|/* i equals the number of chars */
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|outp
operator|++
operator|=
name|sf
expr_stmt|;
comment|/* sf holds dummy char */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sf
operator|!=
name|CHAR
condition|)
block|{
if|if
condition|(
name|df
operator|==
name|CHAR
condition|)
comment|/* numeric to char conversion */
block|{
switch|switch
condition|(
name|sl
condition|)
block|{
comment|/* int of size 1 or 2 */
case|case
literal|1
case|:
name|itoa
argument_list|(
name|inp
operator|->
name|i1type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|itoa
argument_list|(
name|inp
operator|->
name|i2type
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* convert to ascii */
break|break;
comment|/* int or float of size 4 */
case|case
literal|4
case|:
if|if
condition|(
name|sf
operator|==
name|INT
condition|)
block|{
name|smove
argument_list|(
name|locv
argument_list|(
name|inp
operator|->
name|i4type
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* convert and copy */
block|}
else|else
block|{
name|ftoa
argument_list|(
name|inp
operator|->
name|f4type
argument_list|,
name|temp
argument_list|,
name|dl
argument_list|,
name|Out_arg
operator|.
name|f4prec
argument_list|,
name|Out_arg
operator|.
name|f4style
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* float of size 8 */
case|case
literal|8
case|:
name|ftoa
argument_list|(
name|inp
operator|->
name|f8type
argument_list|,
name|temp
argument_list|,
name|dl
argument_list|,
name|Out_arg
operator|.
name|f8prec
argument_list|,
name|Out_arg
operator|.
name|f8style
argument_list|)
expr_stmt|;
break|break;
comment|/* there is no possible default */
default|default:
name|syserr
argument_list|(
literal|"bad domain length %d"
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|length
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|dl
operator|-
name|j
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|5808
operator|)
return|;
comment|/* field won't fit */
comment|/* blank pad from left. Number will be right justified */
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|outp
operator|++
operator|=
literal|' '
expr_stmt|;
name|bmove
argument_list|(
name|temp
argument_list|,
name|outp
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|convert
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
name|sf
argument_list|,
name|sl
argument_list|,
name|df
argument_list|,
name|dl
argument_list|)
condition|)
comment|/* numeric to numeric transfer */
return|return
operator|(
literal|5808
operator|)
return|;
comment|/* numeric truncation error */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* character to numeric conversion */
comment|/* and character to character conversion */
switch|switch
condition|(
name|df
condition|)
block|{
case|case
name|CHAR
case|:
name|i
operator|=
name|sl
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|i
operator|=
name|length
argument_list|(
name|inp
operator|->
name|c0type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|dl
condition|)
name|i
operator|=
name|dl
expr_stmt|;
if|if
condition|(
name|charmove
argument_list|(
name|inp
operator|->
name|c0type
argument_list|,
name|outp
argument_list|,
name|i
argument_list|)
condition|)
name|Baddoms
operator|++
expr_stmt|;
for|for
control|(
name|outp
operator|+=
name|i
init|;
name|i
operator|<
name|dl
condition|;
name|i
operator|++
control|)
operator|*
name|outp
operator|++
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FLOAT
case|:
if|if
condition|(
name|atof
argument_list|(
name|inp
operator|->
name|c0type
argument_list|,
operator|&
name|d
argument_list|)
condition|)
return|return
operator|(
literal|5809
operator|)
return|;
comment|/* bad conversion to numeric */
if|if
condition|(
name|dl
operator|==
literal|8
condition|)
name|bmove
argument_list|(
operator|&
name|d
argument_list|,
name|outp
argument_list|,
name|dl
argument_list|)
expr_stmt|;
else|else
block|{
name|f
operator|=
name|d
expr_stmt|;
comment|/* f8 to f4 conversion */
name|bmove
argument_list|(
operator|&
name|f
argument_list|,
name|outp
argument_list|,
name|dl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|INT
case|:
if|if
condition|(
name|dl
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|atol
argument_list|(
name|inp
operator|->
name|c0type
argument_list|,
operator|&
name|l
argument_list|)
condition|)
return|return
operator|(
literal|5809
operator|)
return|;
name|bmove
argument_list|(
operator|&
name|l
argument_list|,
name|outp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|atoi
argument_list|(
name|inp
operator|->
name|c0type
argument_list|,
operator|&
name|j
argument_list|)
condition|)
return|return
operator|(
literal|5809
operator|)
return|;
if|if
condition|(
operator|(
name|dl
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|j
operator|<
operator|-
literal|128
operator|)
operator|||
operator|(
name|j
operator|>
literal|127
operator|)
operator|)
condition|)
return|return
operator|(
literal|5809
operator|)
return|;
name|bmove
argument_list|(
operator|&
name|j
argument_list|,
name|outp
argument_list|,
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	moves a character string from "in" **	to "out" removing any control characters. **	returns true if any control characters were found */
end_comment

begin_macro
name|charmove
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ip
decl_stmt|,
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
name|int
name|bad
decl_stmt|;
name|bad
operator|=
name|FALSE
expr_stmt|;
name|ip
operator|=
name|in
expr_stmt|;
name|op
operator|=
name|out
expr_stmt|;
name|l
operator|=
name|length
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
if|if
condition|(
operator|(
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
operator|)
operator|<
literal|' '
condition|)
block|{
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|=
literal|' '
expr_stmt|;
name|bad
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|bad
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Mapfill fills the Map structure with the list **	of user supplied attributes. It then reads **	the list of relation attributes and checks **	for matching attribute names. ** **	if an error occures then mapfill returns -1 **		else it returns 0 ** **	Mapfill performs special processing on **	dummy domains. ** **	If no user attributes are given, then "given"=FALSE **	and each attribute in the relation is set up to be **	copied in the formats and order in which they **	exist in the relation */
end_comment

begin_macro
name|mapfill
argument_list|(
argument|aptr
argument_list|)
end_macro

begin_decl_stmt
name|PARM
name|aptr
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PARM
modifier|*
name|ap
decl_stmt|;
specifier|register
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|DESC
name|Attdes
decl_stmt|;
name|struct
name|attribute
name|att
decl_stmt|;
name|struct
name|tup_id
name|tid
decl_stmt|,
name|limtid
decl_stmt|;
name|int
name|given
decl_stmt|,
name|cnt
decl_stmt|;
name|char
modifier|*
name|zcheck
parameter_list|()
function_decl|;
name|char
modifier|*
name|dumvalue
parameter_list|()
function_decl|;
name|Mapcount
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|Map
expr_stmt|;
name|ap
operator|=
name|aptr
expr_stmt|;
comment|/* Gather list of user supplied attributes */
while|while
condition|(
operator|*
operator|(
name|ap
operator|->
name|pv_val
operator|.
name|pv_str
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* check for overflow */
if|if
condition|(
name|Mapcount
operator|==
name|MAXMAP
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5803
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* more than MAXMAP specifiers */
name|mp
operator|->
name|paramname
operator|=
operator|(
name|ap
operator|->
name|pv_val
operator|)
operator|.
name|pv_str
expr_stmt|;
comment|/* save pointer to user supplied name */
name|pmove
argument_list|(
operator|(
operator|(
name|ap
operator|++
operator|)
operator|->
name|pv_val
operator|)
operator|.
name|pv_str
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|MAXNAME
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
operator|(
name|ap
operator|++
operator|)
operator|->
name|pv_val
operator|)
operator|.
name|pv_str
expr_stmt|;
comment|/* fp points to format string */
name|mp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
comment|/* zero in case this is a dummy domain */
name|mp
operator|->
name|roffset
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|fdelim
operator|=
literal|0
expr_stmt|;
comment|/* check domain type in *fp */
switch|switch
condition|(
operator|*
name|fp
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
name|i
operator|=
name|CHAR
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|fdelim
operator|=
name|zcheck
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bad delimitor */
break|break;
case|case
literal|'f'
case|:
name|i
operator|=
name|FLOAT
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|i
operator|=
name|INT
expr_stmt|;
break|break;
case|case
name|DUMMY
case|:
name|i
operator|=
name|DUMMY
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|fdelim
operator|=
name|zcheck
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|error
argument_list|(
literal|5811
argument_list|,
name|mp
operator|->
name|paramname
argument_list|,
operator|--
name|fp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
name|mp
operator|->
name|ftype
operator|=
name|i
expr_stmt|;
comment|/* convert format length to binary */
if|if
condition|(
name|atoi
argument_list|(
name|fp
argument_list|,
operator|&
name|mp
operator|->
name|flen
argument_list|)
operator|||
name|mp
operator|->
name|flen
operator|<
literal|0
operator|||
name|mp
operator|->
name|flen
operator|>
literal|511
operator|||
operator|(
name|mp
operator|->
name|ftype
operator|==
name|FLOAT
operator|&&
name|mp
operator|->
name|flen
operator|!=
literal|4
operator|&&
name|mp
operator|->
name|flen
operator|!=
literal|8
operator|)
operator|||
operator|(
name|mp
operator|->
name|ftype
operator|==
name|INT
operator|&&
name|mp
operator|->
name|flen
operator|!=
literal|1
operator|&&
name|mp
operator|->
name|flen
operator|!=
literal|2
operator|&&
name|mp
operator|->
name|flen
operator|!=
literal|4
operator|)
condition|)
block|{
return|return
operator|(
name|error
argument_list|(
literal|5804
argument_list|,
name|mp
operator|->
name|paramname
argument_list|,
operator|--
name|fp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* bad length for attribute */
block|}
comment|/* process dummy domain if any */
if|if
condition|(
name|Into
operator|&&
name|mp
operator|->
name|ftype
operator|==
name|DUMMY
operator|&&
name|mp
operator|->
name|flen
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|dumvalue
argument_list|(
name|mp
operator|->
name|paramname
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|5807
operator|)
return|;
comment|/* bad dummy name */
name|mp
operator|->
name|rtype
operator|=
operator|*
name|fp
expr_stmt|;
comment|/* use first char of string */
block|}
comment|/* check for format of type "c0delim" on copy "into" */
if|if
condition|(
name|Into
operator|&&
name|mp
operator|->
name|flen
operator|==
literal|0
operator|&&
name|mp
operator|->
name|fdelim
operator|!=
name|Delimitor
condition|)
block|{
name|fp
operator|=
name|mp
operator|->
name|fdelim
expr_stmt|;
comment|/* is there room for a dummy domain? */
name|mp
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|Mapcount
operator|==
name|MAXMAP
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5803
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* no room */
comment|/* create a dummy entry */
name|mp
operator|->
name|ftype
operator|=
name|DUMMY
expr_stmt|;
name|mp
operator|->
name|flen
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|rtype
operator|=
operator|*
name|fp
expr_stmt|;
name|mp
operator|->
name|roffset
operator|=
name|mp
operator|->
name|rlen
operator|=
literal|0
expr_stmt|;
block|}
name|mp
operator|++
expr_stmt|;
name|Mapcount
operator|++
expr_stmt|;
block|}
comment|/* if no atributes were given, set flag */
if|if
condition|(
name|Mapcount
condition|)
name|given
operator|=
name|TRUE
expr_stmt|;
else|else
name|given
operator|=
name|FALSE
expr_stmt|;
comment|/* open attribute relation and prepare for scan */
name|opencatalog
argument_list|(
literal|"attribute"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|att
argument_list|,
name|Des
operator|.
name|reldum
operator|.
name|relid
argument_list|,
name|ATTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|att
argument_list|,
name|Des
operator|.
name|reldum
operator|.
name|relowner
argument_list|,
name|ATTOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
operator|&
name|Attdes
argument_list|,
name|EXACTKEY
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|att
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"find error for att-rel"
argument_list|)
expr_stmt|;
comment|/* scan Map for each relation attribute */
while|while
condition|(
operator|(
name|i
operator|=
name|get
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|tid
argument_list|,
operator|&
name|limtid
argument_list|,
operator|&
name|att
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|Des
argument_list|,
operator|&
name|att
argument_list|,
name|MAXNAME
operator|+
literal|2
argument_list|)
condition|)
continue|continue;
comment|/* if no user attributes were supplied, fake an entry */
if|if
condition|(
operator|!
name|given
condition|)
block|{
name|Mapcount
operator|++
expr_stmt|;
name|mp
operator|=
operator|&
name|Map
index|[
name|att
operator|.
name|attid
operator|-
literal|1
index|]
expr_stmt|;
name|mp
operator|->
name|rtype
operator|=
name|mp
operator|->
name|ftype
operator|=
name|att
operator|.
name|attfrmt
expr_stmt|;
name|mp
operator|->
name|rlen
operator|=
name|mp
operator|->
name|flen
operator|=
name|att
operator|.
name|attfrml
operator|&
literal|0377
expr_stmt|;
name|mp
operator|->
name|roffset
operator|=
name|att
operator|.
name|attoff
expr_stmt|;
name|mp
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|paramname
operator|=
name|mp
operator|->
name|name
expr_stmt|;
comment|/* point to name */
name|bmove
argument_list|(
name|att
operator|.
name|attname
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|MAXNAME
argument_list|)
expr_stmt|;
comment|/* copy name */
continue|continue;
block|}
name|mp
operator|=
name|Map
expr_stmt|;
comment|/* check each user domain for match with relation domain */
for|for
control|(
name|i
operator|=
name|Mapcount
init|;
name|i
operator|--
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|ftype
operator|==
name|DUMMY
condition|)
continue|continue;
comment|/* ignore dummy */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|mp
operator|->
name|name
argument_list|,
name|att
operator|.
name|attname
argument_list|,
literal|12
argument_list|)
condition|)
continue|continue;
name|mp
operator|->
name|rtype
operator|=
name|att
operator|.
name|attfrmt
expr_stmt|;
name|mp
operator|->
name|rlen
operator|=
name|att
operator|.
name|attfrml
operator|&
literal|0377
expr_stmt|;
name|mp
operator|->
name|roffset
operator|=
name|att
operator|.
name|attoff
expr_stmt|;
name|mp
operator|->
name|used
operator|++
expr_stmt|;
comment|/* check for special case of C0 in a copy "into" */
if|if
condition|(
name|Into
operator|&&
operator|(
name|mp
operator|->
name|flen
operator|==
literal|0
operator|)
operator|&&
name|mp
operator|->
name|ftype
operator|==
name|CHAR
condition|)
block|{
switch|switch
condition|(
name|mp
operator|->
name|rtype
condition|)
block|{
case|case
name|CHAR
case|:
name|mp
operator|->
name|flen
operator|=
name|mp
operator|->
name|rlen
expr_stmt|;
break|break;
case|case
name|INT
case|:
switch|switch
condition|(
name|mp
operator|->
name|rlen
condition|)
block|{
case|case
literal|1
case|:
name|mp
operator|->
name|flen
operator|=
name|Out_arg
operator|.
name|i1width
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mp
operator|->
name|flen
operator|=
name|Out_arg
operator|.
name|i2width
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mp
operator|->
name|flen
operator|=
name|Out_arg
operator|.
name|i4width
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|mp
operator|->
name|rlen
operator|==
literal|4
condition|)
name|mp
operator|->
name|flen
operator|=
name|Out_arg
operator|.
name|f4width
expr_stmt|;
else|else
name|mp
operator|->
name|flen
operator|=
name|Out_arg
operator|.
name|f8width
expr_stmt|;
block|}
block|}
comment|/*  if this is a copy "from" then break 			    otherwise continue. In a copy "into" 			    an attribute might be copied more than once */
if|if
condition|(
operator|!
name|Into
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"bad get from att-rel %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* check that all user domains have been identified */
name|cnt
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|Map
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Mapcount
init|;
name|i
operator|--
condition|;
name|mp
operator|++
control|)
block|{
name|cnt
operator|+=
name|mp
operator|->
name|flen
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|ftype
operator|==
name|DUMMY
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mp
operator|->
name|used
condition|)
block|{
return|return
operator|(
name|error
argument_list|(
literal|5801
argument_list|,
name|mp
operator|->
name|paramname
argument_list|,
name|Relname
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* unrecognizable domain name */
block|}
block|}
comment|/* check that copy into doesn't exceed buffer size */
if|if
condition|(
name|Into
operator|&&
name|cnt
operator|>
name|BUFSIZ
condition|)
return|return
operator|(
name|error
argument_list|(
literal|5817
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* cnt too large */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BREAD */
end_comment

begin_macro
name|bread
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|inp
decl_stmt|;
name|char
modifier|*
name|dl
decl_stmt|;
name|int
name|esc
decl_stmt|;
comment|/* escape flag */
name|count
operator|=
name|mp
operator|->
name|flen
expr_stmt|;
name|inp
operator|=
name|Inbuf
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
comment|/* block mode. read characters */
name|i
operator|=
name|fread
argument_list|(
name|inp
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|File_iop
argument_list|)
expr_stmt|;
comment|/* null terminate */
operator|*
operator|(
name|inp
operator|+
name|count
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|i
operator|==
name|count
operator|)
return|;
comment|/* true -> normal, false ->eof */
block|}
comment|/* string mode read */
comment|/* 	** Determine the maximum size the C0 field being read can be. 	** In the case where it is being copied into a CHAR field, then 	** the size is that of the char field (+1 for the delimitor). 	** In the case of a numeric, it is limited only by the size of the 	** buffer area. 	*/
name|count
operator|=
name|mp
operator|->
name|rtype
operator|==
name|CHAR
condition|?
name|mp
operator|->
name|rlen
operator|+
literal|1
else|:
name|BUFSIZ
expr_stmt|;
name|esc
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|File_iop
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|inp
operator|==
name|Inbuf
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
comment|/* -1 -> unexpected EOF, 0 -> normal EOF */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
operator|*
name|inp
operator|++
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* determine type of overflow */
if|if
condition|(
name|mp
operator|->
name|rtype
operator|==
name|CHAR
condition|)
block|{
name|Truncount
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
comment|/* read until delim */
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|esc
condition|)
block|{
name|esc
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
name|ESCAPE
condition|)
block|{
name|esc
operator|=
name|TRUE
expr_stmt|;
comment|/* 			** If esc was stored, back it up. 			*/
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
name|inp
operator|--
expr_stmt|;
comment|/* remove escape char */
name|count
operator|++
expr_stmt|;
comment|/* restore counter */
block|}
block|}
else|else
block|{
for|for
control|(
name|dl
operator|=
name|mp
operator|->
name|fdelim
init|;
operator|*
name|dl
condition|;
name|dl
operator|++
control|)
if|if
condition|(
operator|*
name|dl
operator|==
name|i
condition|)
block|{
operator|*
operator|(
name|inp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **	Look for the existence of a param of the **	form "0nl" or "00comma" etc. ** **	Returns the correct delim list or 0 **	if there was a user error ** **	If successful, a null is inserted at the **	rightmost '0' so the subsequent atoi will work. */
end_comment

begin_function
name|char
modifier|*
name|zcheck
parameter_list|(
name|param
parameter_list|)
name|char
modifier|*
name|param
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|np
operator|=
name|param
expr_stmt|;
name|ret
operator|=
name|Delimitor
expr_stmt|;
comment|/* assume default delimitors */
if|if
condition|(
operator|*
name|np
operator|++
operator|==
literal|'0'
condition|)
block|{
comment|/* we have a starting zero. trim the rest */
while|while
condition|(
operator|*
name|np
operator|==
literal|'0'
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|>
literal|'9'
operator|||
operator|(
operator|*
name|np
operator|<
literal|'0'
operator|&&
operator|*
name|np
operator|>=
literal|' '
operator|)
condition|)
block|{
comment|/* we have a special delim on a 0 width field */
if|if
condition|(
name|ret
operator|=
name|dumvalue
argument_list|(
name|np
argument_list|)
condition|)
operator|*
operator|(
operator|--
name|np
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* 						** end string before delim 						** Do not alter delimitor but 						** instead destroy last '0'. 						*/
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **	Search list of valid dummy names looking **	for 'name'. If 'name' is a single char **	then use just that name else it is **	an error if the name is not found */
end_comment

begin_function
name|char
modifier|*
name|dumvalue
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|dp
decl_stmt|,
modifier|*
name|np
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|dp
operator|=
name|Cpdomains
expr_stmt|;
comment|/* get list of valid dummy names */
name|np
operator|=
name|name
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* first look for a matching key word */
while|while
condition|(
operator|*
name|dp
condition|)
block|{
if|if
condition|(
name|sequal
argument_list|(
name|np
argument_list|,
operator|*
name|dp
operator|++
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|*
name|dp
expr_stmt|;
break|break;
block|}
name|dp
operator|++
expr_stmt|;
block|}
comment|/* If single char, use that char */
if|if
condition|(
name|length
argument_list|(
name|np
argument_list|)
operator|==
literal|1
condition|)
name|ret
operator|=
name|np
expr_stmt|;
comment|/* use first char of name */
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|5807
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

