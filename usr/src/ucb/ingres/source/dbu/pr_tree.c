begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<symbol.h>
end_include

begin_include
include|#
directive|include
file|<ingres.h>
end_include

begin_include
include|#
directive|include
file|<tree.h>
end_include

begin_include
include|#
directive|include
file|<aux.h>
end_include

begin_include
include|#
directive|include
file|<sccs.h>
end_include

begin_macro
name|SCCSID
argument_list|(
argument|@(#)pr_tree.c
literal|7.1
literal|2
argument|/
literal|5
argument|/
literal|81
argument_list|)
end_macro

begin_comment
comment|/* **  PR_TREE.C -- Query tree printing routines ** **	Trace Flags: **		52 */
end_comment

begin_function_decl
name|char
modifier|*
name|pr_trim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|resultres
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|tab
block|{
name|char
name|t_opcode
decl_stmt|;
name|char
modifier|*
name|t_string
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|tab
name|Uop_tab
index|[]
init|=
block|{
name|opPLUS
block|,
literal|"+ "
block|,
name|opMINUS
block|,
literal|"- "
block|,
name|opNOT
block|,
literal|"not[ERROR]"
block|,
name|opATAN
block|,
literal|"atan"
block|,
name|opCOS
block|,
literal|"cos"
block|,
name|opGAMMA
block|,
literal|"gamma"
block|,
name|opLOG
block|,
literal|"log"
block|,
name|opASCII
block|,
literal|"ascii"
block|,
name|opSIN
block|,
literal|"sin"
block|,
name|opSQRT
block|,
literal|"sqrt"
block|,
name|opABS
block|,
literal|"abs"
block|,
name|opEXP
block|,
literal|"exp"
block|,
name|opINT1
block|,
literal|"int1"
block|,
name|opINT2
block|,
literal|"int2"
block|,
name|opINT4
block|,
literal|"int4"
block|,
name|opFLOAT4
block|,
literal|"float4"
block|,
name|opFLOAT8
block|,
literal|"float8"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tab
name|Bop_tab
index|[]
init|=
block|{
name|opADD
block|,
literal|"+"
block|,
name|opSUB
block|,
literal|"-"
block|,
name|opMUL
block|,
literal|"*"
block|,
name|opDIV
block|,
literal|"/"
block|,
name|opPOW
block|,
literal|"**"
block|,
name|opEQ
block|,
literal|"="
block|,
name|opNE
block|,
literal|"!="
block|,
name|opLT
block|,
literal|"<"
block|,
name|opLE
block|,
literal|"<="
block|,
name|opGT
block|,
literal|">"
block|,
name|opGE
block|,
literal|">="
block|,
name|opMOD
block|,
literal|"%"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tab
name|Cop_tab
index|[]
init|=
block|{
name|opDBA
block|,
literal|"dba"
block|,
name|opUSERCODE
block|,
literal|"usercode"
block|,
name|opDATE
block|,
literal|"date"
block|,
name|opTIME
block|,
literal|"time"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tab
name|Aop_tab
index|[]
init|=
block|{
name|opCOUNT
block|,
literal|"count"
block|,
name|opCOUNTU
block|,
literal|"countu"
block|,
name|opSUM
block|,
literal|"sum"
block|,
name|opSUMU
block|,
literal|"sumu"
block|,
name|opAVG
block|,
literal|"avg"
block|,
name|opAVGU
block|,
literal|"avgu"
block|,
name|opMIN
block|,
literal|"min"
block|,
name|opMAX
block|,
literal|"max"
block|,
name|opANY
block|,
literal|"any"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DESC
name|Attdes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Tl_elm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Dom_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Resrel
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  **  PR_TREE ** **	tree:	tl_clause ROOT tl_clause ** **	prints out a tree assuming a mdVIEW-like mode ** */
end_comment

begin_macro
name|pr_tree
argument_list|(
argument|root
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|root
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_tree: root %u Resultvar %d Resrel %s\n"
argument_list|,
name|root
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|Resrel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|pr_trim
argument_list|(
name|resultres
argument_list|()
argument_list|,
name|MAXNAME
argument_list|)
argument_list|)
expr_stmt|;
name|pr_dom_init
argument_list|()
expr_stmt|;
name|Tl_elm
operator|=
literal|0
expr_stmt|;
comment|/* print target list */
name|printf
argument_list|(
literal|"(\n"
argument_list|)
expr_stmt|;
name|pr_tl_clause
argument_list|(
name|root
operator|->
name|left
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
comment|/* print qualification */
if|if
condition|(
name|root
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|printf
argument_list|(
literal|"\nwhere "
argument_list|)
expr_stmt|;
name|pr_qual
argument_list|(
name|root
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_TL_CLAUSE ** **	tl_clause:	TREE **		|	tl_clause RESDOM expr **	 ** target_flag = "in a target list (as opposed to in a by list)" */
end_comment

begin_macro
name|pr_tl_clause
argument_list|(
argument|t_l
argument_list|,
argument|target_flag
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|t_l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|bool
name|target_flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"tl_clause target %d Tl_elm %d\n"
argument_list|,
name|target_flag
argument_list|,
name|Tl_elm
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|t_l
operator|->
name|sym
operator|.
name|type
operator|!=
name|TREE
condition|)
block|{
name|pr_tl_clause
argument_list|(
name|t_l
operator|->
name|left
argument_list|,
name|target_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tl_elm
condition|)
block|{
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_flag
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* print out info on result variable */
name|pr_resdom
argument_list|(
name|t_l
argument_list|,
name|target_flag
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|t_l
operator|->
name|right
argument_list|)
expr_stmt|;
name|Tl_elm
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_RESDOM ** **	print out info on a result attribute. **	this will be done only if the RESDOM node **	is inside a target_list and if the Qt.qt_resvar>= 0. **	Qt.qt_resvar == -1 inside a target list indicates that this is **	a retrieve to terminal. */
end_comment

begin_macro
name|pr_resdom
argument_list|(
argument|resdom
argument_list|,
argument|target_flag
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|resdom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_resdom: target_flag %d\n"
argument_list|,
name|target_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|target_flag
condition|)
block|{
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|pr_attname
argument_list|(
name|resultres
argument_list|()
argument_list|,
name|resdom
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_resdom
operator|.
name|resno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  **  PR_ATTNAME ** **	give a relation name, and the attribute number of that **	relation, looks in the attribute relation for the name of the **	attribute. */
end_comment

begin_macro
name|pr_attname
argument_list|(
argument|rel
argument_list|,
argument|attno
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|rel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|attno
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TID
name|tid
decl_stmt|;
name|struct
name|attribute
name|key
decl_stmt|,
name|tuple
decl_stmt|;
specifier|register
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_attname: rel %s attno %d\n"
argument_list|,
name|rel
argument_list|,
name|attno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|attno
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"tid"
argument_list|)
expr_stmt|;
return|return;
block|}
name|opencatalog
argument_list|(
literal|"attribute"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clearkeys
argument_list|(
operator|&
name|Attdes
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|key
argument_list|,
name|rel
argument_list|,
name|ATTRELID
argument_list|)
expr_stmt|;
name|setkey
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|attno
argument_list|,
name|ATTID
argument_list|)
expr_stmt|;
name|i
operator|=
name|getequal
argument_list|(
operator|&
name|Attdes
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|tuple
argument_list|,
operator|&
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|syserr
argument_list|(
literal|"pr_attname: bad getequal %d rel %s attno %d"
argument_list|,
name|i
argument_list|,
name|rel
argument_list|,
name|attno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|pr_trim
argument_list|(
name|tuple
operator|.
name|attname
argument_list|,
name|MAXNAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_EXPR ** **	expr:		VAR **		|	expr BOP expr **		|	expr UOP **		|	AOP AGHEAD qual **			  \ **			   expr **		|	BYHEAD	  AGHEAD qual **		        /    \ **		tl_clause     AOP **				\ **				 expr **		|	INT **		|	FLOAT **		| 	CHAR */
end_comment

begin_expr_stmt
name|pr_expr
argument_list|(
name|e
argument_list|)
specifier|register
name|QTREE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|op
decl_stmt|;
specifier|register
name|int
name|tl_elm
decl_stmt|;
switch|switch
condition|(
name|e
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|VAR
case|:
name|pr_var
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOP
case|:
if|if
condition|(
name|e
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|==
name|opCONCAT
condition|)
block|{
name|printf
argument_list|(
literal|"concat("
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|right
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|left
argument_list|)
expr_stmt|;
name|pr_op
argument_list|(
name|BOP
argument_list|,
name|e
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|right
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UOP
case|:
if|if
condition|(
operator|(
name|op
operator|=
name|e
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
operator|)
operator|==
name|opMINUS
operator|||
name|op
operator|==
name|opPLUS
operator|||
name|op
operator|==
name|opNOT
condition|)
block|{
name|pr_op
argument_list|(
name|UOP
argument_list|,
name|e
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* functional operators */
name|pr_op
argument_list|(
name|UOP
argument_list|,
name|e
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AGHEAD
case|:
if|if
condition|(
name|e
operator|->
name|left
operator|->
name|sym
operator|.
name|type
operator|==
name|AOP
condition|)
block|{
comment|/* simple aggregate */
name|pr_op
argument_list|(
name|AOP
argument_list|,
name|e
operator|->
name|left
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|left
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|printf
argument_list|(
literal|"\where "
argument_list|)
expr_stmt|;
name|pr_qual
argument_list|(
name|e
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* aggregate function */
name|pr_op
argument_list|(
name|AOP
argument_list|,
name|e
operator|->
name|left
operator|->
name|right
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_op
operator|.
name|opno
argument_list|)
expr_stmt|;
name|pr_expr
argument_list|(
name|e
operator|->
name|left
operator|->
name|right
operator|->
name|right
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" by "
argument_list|)
expr_stmt|;
comment|/* avoid counting target list elements 			 * in determining wether to put out 			 * commas after list's elements 			 */
name|tl_elm
operator|=
name|Tl_elm
expr_stmt|;
name|Tl_elm
operator|=
literal|0
expr_stmt|;
name|pr_tl_clause
argument_list|(
name|e
operator|->
name|left
operator|->
name|left
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Tl_elm
operator|=
name|tl_elm
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|printf
argument_list|(
literal|"\n\t\twhere "
argument_list|)
expr_stmt|;
name|pr_qual
argument_list|(
name|e
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INT
case|:
case|case
name|FLOAT
case|:
case|case
name|CHAR
case|:
name|pr_const
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"expr %d"
argument_list|,
name|e
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_CONST -- print constant */
end_comment

begin_expr_stmt
name|pr_const
argument_list|(
name|c
argument_list|)
specifier|register
name|QTREE
operator|*
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|double
name|d
decl_stmt|;
switch|switch
condition|(
name|c
operator|->
name|sym
operator|.
name|type
condition|)
block|{
case|case
name|INT
case|:
if|if
condition|(
name|c
operator|->
name|sym
operator|.
name|len
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i1type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|sym
operator|.
name|len
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i2type
argument_list|)
expr_stmt|;
else|else
comment|/* i4 */
name|printf
argument_list|(
literal|"%D"
argument_list|,
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|i4type
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|c
operator|->
name|sym
operator|.
name|len
operator|==
literal|4
condition|)
name|d
operator|=
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|f4type
expr_stmt|;
else|else
name|d
operator|=
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|f8type
expr_stmt|;
name|printf
argument_list|(
literal|"%-10.3f"
argument_list|,
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|f8type
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|cp
operator|=
name|c
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_data
operator|.
name|c0type
expr_stmt|;
for|for
control|(
name|i
operator|=
name|c
operator|->
name|sym
operator|.
name|len
init|;
name|i
operator|--
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|"\"\\[]*?"
argument_list|)
operator|==
name|TRUE
condition|)
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|>=
literal|' '
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* perform pattern matching character replacement */
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
name|PAT_ANY
case|:
name|ch
operator|=
literal|'*'
expr_stmt|;
break|break;
case|case
name|PAT_ONE
case|:
name|ch
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
name|PAT_LBRAC
case|:
name|ch
operator|=
literal|'['
expr_stmt|;
break|break;
case|case
name|PAT_RBRAC
case|:
name|ch
operator|=
literal|']'
expr_stmt|;
break|break;
default|default:
name|ch
operator|=
operator|*
name|cp
expr_stmt|;
block|}
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"bad constant %d"
argument_list|,
name|c
operator|->
name|sym
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_OP -- print out operator of a certain type */
end_comment

begin_macro
name|pr_op
argument_list|(
argument|op_type
argument_list|,
argument|op_code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|op_code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tab
modifier|*
name|s
decl_stmt|;
switch|switch
condition|(
name|op_type
condition|)
block|{
case|case
name|UOP
case|:
name|s
operator|=
operator|&
name|Uop_tab
index|[
name|op_code
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s("
argument_list|,
name|s
operator|->
name|t_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOP
case|:
name|s
operator|=
operator|&
name|Bop_tab
index|[
name|op_code
index|]
expr_stmt|;
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|s
operator|->
name|t_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|AOP
case|:
name|s
operator|=
operator|&
name|Aop_tab
index|[
name|op_code
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s("
argument_list|,
name|s
operator|->
name|t_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|COP
case|:
name|s
operator|=
operator|&
name|Cop_tab
index|[
name|op_code
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|s
operator|->
name|t_string
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_code
operator|!=
name|s
operator|->
name|t_opcode
condition|)
name|syserr
argument_list|(
literal|"pr_op: op in wrong place type %d, code %d"
argument_list|,
name|op_type
argument_list|,
name|s
operator|->
name|t_opcode
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_VAR ** **	print a VAR node: that is, a var.attno pair **	at present the var part is the relation name over which var **	ranges. */
end_comment

begin_macro
name|pr_var
argument_list|(
argument|var
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|var
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_var(var=%d)\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pr_rv
argument_list|(
name|var
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|pr_attname
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|var
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|varno
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|var
operator|->
name|sym
operator|.
name|value
operator|.
name|sym_var
operator|.
name|attno
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_QUAL ** **	qual:		QLEND **		|	q_clause AND qual ** */
end_comment

begin_expr_stmt
name|pr_qual
argument_list|(
name|q
argument_list|)
specifier|register
name|QTREE
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|pr_q_clause
argument_list|(
name|q
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|right
operator|->
name|sym
operator|.
name|type
operator|!=
name|QLEND
condition|)
block|{
name|printf
argument_list|(
literal|" and "
argument_list|)
expr_stmt|;
name|pr_qual
argument_list|(
name|q
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_Q_CLAUSE ** **	q_clause:	q_clause OR q_clause **		|	expr */
end_comment

begin_macro
name|pr_q_clause
argument_list|(
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|QTREE
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|q
operator|->
name|sym
operator|.
name|type
operator|==
name|OR
condition|)
block|{
name|pr_q_clause
argument_list|(
name|q
operator|->
name|left
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" or "
argument_list|)
expr_stmt|;
name|pr_q_clause
argument_list|(
name|q
operator|->
name|right
argument_list|)
expr_stmt|;
block|}
else|else
name|pr_expr
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_TRIM */
end_comment

begin_function
name|char
modifier|*
name|pr_trim
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|bmove
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
name|l
operator|&&
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
condition|;
operator|--
name|l
control|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PR_DOM_INIT */
end_comment

begin_macro
name|pr_dom_init
argument_list|()
end_macro

begin_block
block|{
name|Dom_num
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|pr_ddom
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"d%d = "
argument_list|,
name|Dom_num
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_RANGE -- print the range table */
end_comment

begin_macro
name|pr_range
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXVAR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"range of "
argument_list|)
expr_stmt|;
name|pr_rv
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" is %s\n"
argument_list|,
name|pr_trim
argument_list|(
name|Qt
operator|.
name|qt_rangev
index|[
name|i
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
argument_list|,
name|MAXNAME
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PR_RV -- print range variable */
end_comment

begin_expr_stmt
name|pr_rv
argument_list|(
name|re
argument_list|)
specifier|register
name|int
name|re
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|ch
operator|=
name|Qt
operator|.
name|qt_rangev
index|[
name|re
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pr_rv(%d) ch '%c'\n"
argument_list|,
name|re
argument_list|,
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|MAXVAR
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|Qt
operator|.
name|qt_rangev
index|[
name|j
index|]
operator|.
name|rngvdesc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|==
name|Qt
operator|.
name|qt_rangev
index|[
name|j
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
index|[
literal|0
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
name|re
condition|)
name|printf
argument_list|(
literal|"rv%d"
argument_list|,
name|re
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RESULTRES */
end_comment

begin_function
name|char
modifier|*
name|resultres
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|Resrel
decl_stmt|;
ifdef|#
directive|ifdef
name|xZTR1
if|if
condition|(
name|tTf
argument_list|(
literal|52
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"resultres: Resultvar %d, Resrel %s\n"
argument_list|,
name|Qt
operator|.
name|qt_resvar
argument_list|,
name|Resrel
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|Qt
operator|.
name|qt_resvar
operator|>
literal|0
condition|)
return|return
operator|(
name|Qt
operator|.
name|qt_rangev
index|[
name|Qt
operator|.
name|qt_resvar
index|]
operator|.
name|rngvdesc
operator|->
name|reldum
operator|.
name|relid
operator|)
return|;
if|if
condition|(
name|Resrel
operator|==
literal|0
condition|)
name|syserr
argument_list|(
literal|"resultres: Resrel == 0"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Resrel
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|any
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

end_unit

