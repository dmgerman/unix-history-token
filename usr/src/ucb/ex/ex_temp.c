begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)ex_temp.c	7.6 (Berkeley) 3/9/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_temp.h"
end_include

begin_include
include|#
directive|include
file|"ex_vis.h"
end_include

begin_include
include|#
directive|include
file|"ex_tty.h"
end_include

begin_comment
comment|/*  * Editor temporary file routines.  * Very similar to those of ed, except uses 2 input buffers.  */
end_comment

begin_define
define|#
directive|define
name|READ
value|0
end_define

begin_define
define|#
directive|define
name|WRITE
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|vms
end_ifndef

begin_define
define|#
directive|define
name|EPOSITION
value|7
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EPOSITION
value|13
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|tfname
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rfname
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|havetmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|tfile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rfile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|fileinit
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|tline
operator|==
name|INCRMT
operator|*
operator|(
name|HBLKS
operator|+
literal|2
operator|)
condition|)
return|return;
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfile
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|tline
operator|=
name|INCRMT
operator|*
operator|(
name|HBLKS
operator|+
literal|2
operator|)
expr_stmt|;
name|blocks
index|[
literal|0
index|]
operator|=
name|HBLKS
expr_stmt|;
name|blocks
index|[
literal|1
index|]
operator|=
name|HBLKS
operator|+
literal|1
expr_stmt|;
name|blocks
index|[
literal|2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|dirtcnt
operator|=
literal|0
expr_stmt|;
name|iblock
operator|=
operator|-
literal|1
expr_stmt|;
name|iblock2
operator|=
operator|-
literal|1
expr_stmt|;
name|oblock
operator|=
operator|-
literal|1
expr_stmt|;
name|CP
argument_list|(
name|tfname
argument_list|,
name|svalue
argument_list|(
name|DIRECTORY
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|vms
if|if
condition|(
name|stat
argument_list|(
name|tfname
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
else|#
directive|else
goto|goto
name|vms_no_check_dir
goto|;
endif|#
directive|endif
block|{
name|dumbness
label|:
if|if
condition|(
name|setexit
argument_list|()
operator|==
literal|0
condition|)
name|filioerr
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
else|else
name|putNFL
argument_list|()
expr_stmt|;
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ex_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|vms
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
block|{
name|errno
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|dumbness
goto|;
block|}
else|#
directive|else
name|vms_no_check_dir
label|:
endif|#
directive|endif
name|ichanged
operator|=
literal|0
expr_stmt|;
name|ichang2
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|vms
name|ignore
argument_list|(
name|strcat
argument_list|(
name|tfname
argument_list|,
literal|"/ExXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ignore
argument_list|(
name|strcat
argument_list|(
name|tfname
argument_list|,
literal|"ExXXXXX"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|strend
argument_list|(
name|tfname
argument_list|)
operator|,
name|i
operator|=
literal|5
operator|,
name|j
operator|=
name|getpid
argument_list|()
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|j
operator|/=
literal|10
control|)
operator|*
operator|--
name|p
operator|=
name|j
operator|%
literal|10
operator||
literal|'0'
expr_stmt|;
ifdef|#
directive|ifdef
name|vms
name|ignore
argument_list|(
name|strcat
argument_list|(
name|tfname
argument_list|,
literal|".txt.1"
argument_list|)
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tfile
operator|=
name|creat
argument_list|(
name|tfname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfile
operator|<
literal|0
condition|)
goto|goto
name|dumbness
goto|;
ifdef|#
directive|ifdef
name|VMUNIX
block|{
extern|extern stilinc;
comment|/* see below */
name|stilinc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|havetmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tfile
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|tfile
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfile
operator|<
literal|0
condition|)
goto|goto
name|dumbness
goto|;
ifdef|#
directive|ifdef
name|UNIX_SBRK
comment|/* 	brk((char *)fendcore); */
endif|#
directive|endif
block|}
end_block

begin_macro
name|cleanup
argument_list|(
argument|all
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|all
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|all
condition|)
block|{
name|putpad
argument_list|(
name|TE
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|havetmp
condition|)
block|{
if|if
condition|(
name|tfile
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
name|havetmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|all
operator|&&
name|rfile
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|rfile
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|rfname
argument_list|)
expr_stmt|;
name|rfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|getline
argument_list|(
name|tl
argument_list|)
name|line
name|tl
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|READ
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|tl
operator|&=
operator|~
name|OFFMSK
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|bp
operator|++
condition|)
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|INCRMT
argument_list|,
name|READ
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|putline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|line
name|tl
decl_stmt|;
name|dirtcnt
operator|++
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
name|change
argument_list|()
expr_stmt|;
name|tl
operator|=
name|tline
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|tl
operator|&=
operator|~
name|OFFMSK
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|=
operator|*
name|lp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
literal|0
expr_stmt|;
name|linebp
operator|=
name|lp
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|+=
name|INCRMT
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
name|tl
operator|=
name|tline
expr_stmt|;
name|tline
operator|+=
operator|(
operator|(
operator|(
name|lp
operator|-
name|linebuf
operator|)
operator|+
name|BNDRY
operator|-
literal|1
operator|)
operator|>>
name|SHFT
operator|)
operator|&
literal|077776
expr_stmt|;
return|return
operator|(
name|tl
operator|)
return|;
block|}
end_block

begin_function_decl
name|int
name|read
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|write
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|getblock
parameter_list|(
name|atl
parameter_list|,
name|iof
parameter_list|)
name|line
name|atl
decl_stmt|;
name|int
name|iof
decl_stmt|;
block|{
specifier|register
name|int
name|bno
decl_stmt|,
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|CRYPT
specifier|register
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
endif|#
directive|endif
name|bno
operator|=
operator|(
name|atl
operator|>>
name|OFFBTS
operator|)
operator|&
name|BLKMSK
expr_stmt|;
name|off
operator|=
operator|(
name|atl
operator|<<
name|SHFT
operator|)
operator|&
name|LBTMSK
expr_stmt|;
if|if
condition|(
name|bno
operator|>=
name|NMBLKS
condition|)
name|error
argument_list|(
literal|" Tmp file too large"
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|BUFSIZ
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|bno
operator|==
name|iblock
condition|)
block|{
name|ichanged
operator||=
name|iof
expr_stmt|;
name|hitin2
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ibuff
operator|+
name|off
operator|)
return|;
block|}
if|if
condition|(
name|bno
operator|==
name|iblock2
condition|)
block|{
name|ichang2
operator||=
name|iof
expr_stmt|;
name|hitin2
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ibuff2
operator|+
name|off
operator|)
return|;
block|}
if|if
condition|(
name|bno
operator|==
name|oblock
condition|)
return|return
operator|(
name|obuff
operator|+
name|off
operator|)
return|;
if|if
condition|(
name|iof
operator|==
name|READ
condition|)
block|{
if|if
condition|(
name|hitin2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ichang2
condition|)
block|{
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xtflag
condition|)
name|crblock
argument_list|(
name|tperm
argument_list|,
name|ibuff2
argument_list|,
name|CRSIZE
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blkio
argument_list|(
name|iblock2
argument_list|,
name|ibuff2
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
name|ichang2
operator|=
literal|0
expr_stmt|;
name|iblock2
operator|=
name|bno
expr_stmt|;
name|blkio
argument_list|(
name|bno
argument_list|,
name|ibuff2
argument_list|,
name|read
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xtflag
condition|)
name|crblock
argument_list|(
name|tperm
argument_list|,
name|ibuff2
argument_list|,
name|CRSIZE
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hitin2
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ibuff2
operator|+
name|off
operator|)
return|;
block|}
name|hitin2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ichanged
condition|)
block|{
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xtflag
condition|)
name|crblock
argument_list|(
name|tperm
argument_list|,
name|ibuff
argument_list|,
name|CRSIZE
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blkio
argument_list|(
name|iblock
argument_list|,
name|ibuff
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
name|ichanged
operator|=
literal|0
expr_stmt|;
name|iblock
operator|=
name|bno
expr_stmt|;
name|blkio
argument_list|(
name|bno
argument_list|,
name|ibuff
argument_list|,
name|read
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xtflag
condition|)
name|crblock
argument_list|(
name|tperm
argument_list|,
name|ibuff
argument_list|,
name|CRSIZE
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ibuff
operator|+
name|off
operator|)
return|;
block|}
if|if
condition|(
name|oblock
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CRYPT
if|if
condition|(
name|xtflag
condition|)
block|{
comment|/* 			 * Encrypt block before writing, so some devious 			 * person can't look at temp file while editing. 			 */
name|p1
operator|=
name|obuff
expr_stmt|;
name|p2
operator|=
name|crbuf
expr_stmt|;
name|n
operator|=
name|CRSIZE
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
name|crblock
argument_list|(
name|tperm
argument_list|,
name|crbuf
argument_list|,
name|CRSIZE
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|blkio
argument_list|(
name|oblock
argument_list|,
name|crbuf
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|blkio
argument_list|(
name|oblock
argument_list|,
name|obuff
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
name|oblock
operator|=
name|bno
expr_stmt|;
return|return
operator|(
name|obuff
operator|+
name|off
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|vms
end_ifdef

begin_define
define|#
directive|define
name|INCORB
value|32
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INCORB
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|incorb
index|[
name|INCORB
operator|+
literal|1
index|]
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|pagrnd
parameter_list|(
name|a
parameter_list|)
value|((char *)(((int)a)&~(BUFSIZ-1)))
end_define

begin_decl_stmt
name|int
name|stilinc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* up to here not written yet */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|blkio
argument_list|(
argument|b
argument_list|,
argument|buf
argument_list|,
argument|iofcn
argument_list|)
end_macro

begin_decl_stmt
name|short
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|iofcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
ifdef|#
directive|ifdef
name|VMUNIX
if|if
condition|(
name|b
operator|<
name|INCORB
condition|)
block|{
if|if
condition|(
name|iofcn
operator|==
name|read
condition|)
block|{
name|bcopy
argument_list|(
name|pagrnd
argument_list|(
name|incorb
index|[
name|b
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|pagrnd
argument_list|(
name|incorb
index|[
name|b
operator|+
literal|1
index|]
argument_list|)
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|laste
condition|)
block|{
if|if
condition|(
name|b
operator|>=
name|stilinc
condition|)
name|stilinc
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|stilinc
condition|)
name|tflush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|lseek
argument_list|(
name|tfile
argument_list|,
operator|(
name|long
operator|)
operator|(
name|unsigned
operator|)
name|b
operator|*
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|iofcn
call|)
argument_list|(
name|tfile
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|!=
name|BUFSIZ
condition|)
name|filioerr
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_macro
name|tlaste
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|stilinc
condition|)
name|dirtcnt
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|tflush
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
init|=
name|stilinc
decl_stmt|;
name|stilinc
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|tfile
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tfile
argument_list|,
name|pagrnd
argument_list|(
name|incorb
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|i
operator|*
name|BUFSIZ
argument_list|)
operator|!=
operator|(
name|i
operator|*
name|BUFSIZ
operator|)
condition|)
name|filioerr
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Synchronize the state of the temporary file in case  * a crash occurs.  */
end_comment

begin_macro
name|synctmp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|line
modifier|*
name|a
decl_stmt|;
specifier|register
name|short
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|VMUNIX
if|if
condition|(
name|stilinc
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|dol
operator|==
name|zero
condition|)
return|return;
if|if
condition|(
name|ichanged
condition|)
name|blkio
argument_list|(
name|iblock
argument_list|,
name|ibuff
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|ichanged
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ichang2
condition|)
name|blkio
argument_list|(
name|iblock2
argument_list|,
name|ibuff2
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|ichang2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oblock
operator|!=
operator|-
literal|1
condition|)
name|blkio
argument_list|(
name|oblock
argument_list|,
name|obuff
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|H
operator|.
name|Time
argument_list|)
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
operator|*
name|zero
operator|=
operator|(
name|line
operator|)
name|H
operator|.
name|Time
expr_stmt|;
for|for
control|(
name|a
operator|=
name|zero
operator|,
name|bp
operator|=
name|blocks
init|;
name|a
operator|<=
name|dol
condition|;
name|a
operator|+=
name|BUFSIZ
operator|/
sizeof|sizeof
expr|*
name|a
operator|,
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|<
literal|0
condition|)
block|{
name|tline
operator|=
operator|(
name|tline
operator|+
name|OFFMSK
operator|)
operator|&
operator|~
name|OFFMSK
expr_stmt|;
operator|*
name|bp
operator|=
operator|(
operator|(
name|tline
operator|>>
name|OFFBTS
operator|)
operator|&
name|BLKMSK
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|>
name|NMBLKS
condition|)
name|error
argument_list|(
literal|" Tmp file too large"
argument_list|)
expr_stmt|;
name|tline
operator|+=
name|INCRMT
expr_stmt|;
name|oblock
operator|=
operator|*
name|bp
operator|+
literal|1
expr_stmt|;
name|bp
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|lseek
argument_list|(
name|tfile
argument_list|,
call|(
name|long
call|)
argument_list|(
name|unsigned
argument_list|)
operator|*
name|bp
operator|*
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cnt
operator|=
operator|(
operator|(
name|dol
operator|-
name|a
operator|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|BUFSIZ
condition|)
name|cnt
operator|=
name|BUFSIZ
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
name|cnt
argument_list|)
operator|!=
name|cnt
condition|)
block|{
name|oops
label|:
operator|*
name|zero
operator|=
literal|0
expr_stmt|;
name|filioerr
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
operator|*
name|zero
operator|=
literal|0
expr_stmt|;
block|}
name|flines
operator|=
name|lineDOL
argument_list|()
expr_stmt|;
name|lseek
argument_list|(
name|tfile
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|H
argument_list|,
sizeof|sizeof
name|H
argument_list|)
operator|!=
sizeof|sizeof
name|H
condition|)
goto|goto
name|oops
goto|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * This will insure that exrecover gets as much 	 * back after a crash as is absolutely possible, 	 * but can result in pregnant pauses between commands 	 * when the TSYNC call is made, so... 	 */
ifndef|#
directive|ifndef
name|vms
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_block

begin_macro
name|TSYNC
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|dirtcnt
operator|>
name|MAXDIRT
condition|)
block|{
comment|/* mjm: 12 --> MAXDIRT */
ifdef|#
directive|ifdef
name|VMUNIX
if|if
condition|(
name|stilinc
condition|)
name|tflush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|dirtcnt
operator|=
literal|0
expr_stmt|;
name|synctmp
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Named buffer routines.  * These are implemented differently than the main buffer.  * Each named buffer has a chain of blocks in the register file.  * Each block contains roughly 508 chars of text,  * and a previous and next block number.  We also have information  * about which blocks came from deletes of multiple partial lines,  * e.g. deleting a sentence or a LISP object.  *  * We maintain a free map for the temp file.  To free the blocks  * in a register we must read the blocks to find how they are chained  * together.  *  * BUG:		The default savind of deleted lines in numbered  *		buffers may be rather inefficient; it hasn't been profiled.  */
end_comment

begin_struct
struct|struct
name|strreg
block|{
name|short
name|rg_flags
decl_stmt|;
name|short
name|rg_nleft
decl_stmt|;
name|short
name|rg_first
decl_stmt|;
name|short
name|rg_last
decl_stmt|;
block|}
name|strregs
index|[
operator|(
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
operator|)
operator|+
operator|(
literal|'9'
operator|-
literal|'0'
operator|+
literal|1
operator|)
index|]
struct|,
modifier|*
name|strp
struct|;
end_struct

begin_struct
struct|struct
name|rbuf
block|{
name|short
name|rb_prev
decl_stmt|;
name|short
name|rb_next
decl_stmt|;
name|char
name|rb_text
index|[
name|BUFSIZ
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|rbuf
struct|,
name|KILLrbuf
struct|,
name|putrbuf
struct|,
name|YANKrbuf
struct|,
name|regrbuf
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_decl_stmt
name|short
name|rused
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|short
name|rused
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|short
name|rnleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|rnext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rbufcp
decl_stmt|;
end_decl_stmt

begin_macro
name|regio
argument_list|(
argument|b
argument_list|,
argument|iofcn
argument_list|)
end_macro

begin_decl_stmt
name|short
name|b
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|iofcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|rfile
operator|==
operator|-
literal|1
condition|)
block|{
name|CP
argument_list|(
name|rfname
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
operator|*
operator|(
name|strend
argument_list|(
name|rfname
argument_list|)
operator|-
name|EPOSITION
operator|)
operator|=
literal|'R'
expr_stmt|;
name|rfile
operator|=
name|creat
argument_list|(
name|rfname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfile
operator|<
literal|0
condition|)
name|oops
label|:
name|filioerr
argument_list|(
name|rfname
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
name|rfile
operator|=
name|open
argument_list|(
name|rfname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfile
operator|<
literal|0
condition|)
goto|goto
name|oops
goto|;
block|}
name|lseek
argument_list|(
name|rfile
argument_list|,
operator|(
name|long
operator|)
name|b
operator|*
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|iofcn
call|)
argument_list|(
name|rfile
argument_list|,
name|rbuf
argument_list|,
name|BUFSIZ
argument_list|)
operator|!=
name|BUFSIZ
condition|)
goto|goto
name|oops
goto|;
name|rblock
operator|=
name|b
expr_stmt|;
block|}
end_block

begin_macro
name|REGblk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|rused
operator|/
sizeof|sizeof
name|rused
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
operator|(
name|rused
index|[
name|i
index|]
operator|^
literal|0177777
operator|)
operator|&
literal|0177777
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|m
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|j
operator|++
operator|,
name|m
operator|>>=
literal|1
expr_stmt|;
name|rused
index|[
name|i
index|]
operator||=
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RDEBUG
name|ex_printf
argument_list|(
literal|"allocating block %d\n"
argument_list|,
name|i
operator|*
literal|16
operator|+
name|j
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|i
operator|*
literal|16
operator|+
name|j
operator|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"Out of register space (ugh)"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_block

begin_function
name|struct
name|strreg
modifier|*
name|mapreg
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|?
operator|&
name|strregs
index|[
operator|(
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
index|]
else|:
operator|&
name|strregs
index|[
name|c
operator|-
literal|'a'
index|]
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
name|shread
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|KILLreg
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|strreg
modifier|*
name|sp
decl_stmt|;
name|rbuf
operator|=
operator|&
name|KILLrbuf
expr_stmt|;
name|sp
operator|=
name|mapreg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|rblock
operator|=
name|sp
operator|->
name|rg_first
expr_stmt|;
name|sp
operator|->
name|rg_first
operator|=
name|sp
operator|->
name|rg_last
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rg_flags
operator|=
name|sp
operator|->
name|rg_nleft
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rblock
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|RDEBUG
name|ex_printf
argument_list|(
literal|"freeing block %d\n"
argument_list|,
name|rblock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rused
index|[
name|rblock
operator|/
literal|16
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|rblock
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|regio
argument_list|(
name|rblock
argument_list|,
name|shread
argument_list|)
expr_stmt|;
name|rblock
operator|=
name|rbuf
operator|->
name|rb_next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*VARARGS*/
end_comment

begin_macro
name|shread
argument_list|()
end_macro

begin_block
block|{
struct|struct
name|front
block|{
name|short
name|a
decl_stmt|;
name|short
name|b
decl_stmt|;
block|}
struct|;
if|if
condition|(
name|read
argument_list|(
name|rfile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|front
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|front
argument_list|)
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|rbuf
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function_decl
name|int
name|getREG
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|putreg
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|odot
init|=
name|dot
decl_stmt|;
specifier|register
name|line
modifier|*
name|odol
init|=
name|dol
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|deletenone
argument_list|()
expr_stmt|;
name|appendnone
argument_list|()
expr_stmt|;
name|rbuf
operator|=
operator|&
name|putrbuf
expr_stmt|;
name|rnleft
operator|=
literal|0
expr_stmt|;
name|rblock
operator|=
literal|0
expr_stmt|;
name|rnext
operator|=
name|mapreg
argument_list|(
name|c
argument_list|)
operator|->
name|rg_first
expr_stmt|;
if|if
condition|(
name|rnext
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inopen
condition|)
block|{
name|splitw
operator|++
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vreg
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"Nothing in register %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inopen
operator|&&
name|partreg
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|FIXUNDO
condition|)
block|{
name|splitw
operator|++
expr_stmt|;
name|vclean
argument_list|()
expr_stmt|;
name|vgoto
argument_list|(
name|WECHO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vreg
operator|=
operator|-
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"Can't put partial line inside macro"
argument_list|)
expr_stmt|;
block|}
name|squish
argument_list|()
expr_stmt|;
name|addr1
operator|=
name|addr2
operator|=
name|dol
expr_stmt|;
block|}
name|cnt
operator|=
name|append
argument_list|(
name|getREG
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|inopen
operator|&&
name|partreg
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|unddol
operator|=
name|dol
expr_stmt|;
name|dol
operator|=
name|odol
expr_stmt|;
name|dot
operator|=
name|odot
expr_stmt|;
name|pragged
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|killcnt
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|notecnt
operator|=
name|cnt
expr_stmt|;
block|}
end_block

begin_macro
name|partreg
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|mapreg
argument_list|(
name|c
argument_list|)
operator|->
name|rg_flags
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|notpart
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|c
condition|)
name|mapreg
argument_list|(
name|c
argument_list|)
operator|->
name|rg_flags
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|getREG
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
init|=
name|linebuf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rnleft
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rnext
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|regio
argument_list|(
name|rnext
argument_list|,
name|read
argument_list|)
expr_stmt|;
name|rnext
operator|=
name|rbuf
operator|->
name|rb_next
expr_stmt|;
name|rbufcp
operator|=
name|rbuf
operator|->
name|rb_text
expr_stmt|;
name|rnleft
operator|=
sizeof|sizeof
name|rbuf
operator|->
name|rb_text
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|rbufcp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
name|rbufcp
operator|++
operator|,
operator|--
name|rnleft
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|lp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|YANKreg
argument_list|(
name|c
argument_list|)
specifier|register
name|int
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|line
modifier|*
name|addr
decl_stmt|;
specifier|register
name|struct
name|strreg
modifier|*
name|sp
decl_stmt|;
name|char
name|savelb
index|[
name|LBSIZE
index|]
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|kshift
argument_list|()
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
condition|)
name|KILLreg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|strp
operator|=
name|sp
operator|=
name|mapreg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rg_flags
operator|=
name|inopen
operator|&&
name|cursor
operator|&&
name|wcursor
expr_stmt|;
name|rbuf
operator|=
operator|&
name|YANKrbuf
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rg_last
condition|)
block|{
name|regio
argument_list|(
name|sp
operator|->
name|rg_last
argument_list|,
name|read
argument_list|)
expr_stmt|;
name|rnleft
operator|=
name|sp
operator|->
name|rg_nleft
expr_stmt|;
name|rbufcp
operator|=
operator|&
name|rbuf
operator|->
name|rb_text
index|[
sizeof|sizeof
name|rbuf
operator|->
name|rb_text
operator|-
name|rnleft
index|]
expr_stmt|;
block|}
else|else
block|{
name|rblock
operator|=
literal|0
expr_stmt|;
name|rnleft
operator|=
literal|0
expr_stmt|;
block|}
name|CP
argument_list|(
name|savelb
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|addr1
init|;
name|addr
operator|<=
name|addr2
condition|;
name|addr
operator|++
control|)
block|{
name|getline
argument_list|(
operator|*
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rg_flags
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|addr2
condition|)
operator|*
name|wcursor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|addr1
condition|)
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
block|}
name|YANKline
argument_list|()
expr_stmt|;
block|}
name|rbflush
argument_list|()
expr_stmt|;
name|killed
argument_list|()
expr_stmt|;
name|CP
argument_list|(
name|linebuf
argument_list|,
name|savelb
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|kshift
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|KILLreg
argument_list|(
literal|'9'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'8'
init|;
name|i
operator|>=
literal|'0'
condition|;
name|i
operator|--
control|)
name|copy
argument_list|(
name|mapreg
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|mapreg
argument_list|(
name|i
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|strreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|YANKline
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|lp
init|=
name|linebuf
decl_stmt|;
specifier|register
name|struct
name|rbuf
modifier|*
name|rp
init|=
name|rbuf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|rnleft
operator|==
literal|0
condition|)
block|{
name|rp
operator|->
name|rb_next
operator|=
name|REGblk
argument_list|()
expr_stmt|;
name|rbflush
argument_list|()
expr_stmt|;
name|rblock
operator|=
name|rp
operator|->
name|rb_next
expr_stmt|;
name|rp
operator|->
name|rb_next
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|rb_prev
operator|=
name|rblock
expr_stmt|;
name|rnleft
operator|=
sizeof|sizeof
name|rp
operator|->
name|rb_text
expr_stmt|;
name|rbufcp
operator|=
name|rp
operator|->
name|rb_text
expr_stmt|;
block|}
operator|*
name|rbufcp
operator|++
operator|=
name|c
expr_stmt|;
operator|--
name|rnleft
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
if|if
condition|(
name|rnleft
condition|)
operator|*
name|rbufcp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|rbflush
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|strreg
modifier|*
name|sp
init|=
name|strp
decl_stmt|;
if|if
condition|(
name|rblock
operator|==
literal|0
condition|)
return|return;
name|regio
argument_list|(
name|rblock
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rg_first
operator|==
literal|0
condition|)
name|sp
operator|->
name|rg_first
operator|=
name|rblock
expr_stmt|;
name|sp
operator|->
name|rg_last
operator|=
name|rblock
expr_stmt|;
name|sp
operator|->
name|rg_nleft
operator|=
name|rnleft
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Register c to char buffer buf of size buflen */
end_comment

begin_macro
name|regbuf
argument_list|(
argument|c
argument_list|,
argument|buf
argument_list|,
argument|buflen
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|buflen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|rbuf
operator|=
operator|&
name|regrbuf
expr_stmt|;
name|rnleft
operator|=
literal|0
expr_stmt|;
name|rblock
operator|=
literal|0
expr_stmt|;
name|rnext
operator|=
name|mapreg
argument_list|(
name|c
argument_list|)
operator|->
name|rg_first
expr_stmt|;
if|if
condition|(
name|rnext
operator|==
literal|0
condition|)
block|{
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Nothing in register %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|getREG
argument_list|()
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|lp
operator|=
name|linebuf
init|;
operator|*
name|lp
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|>=
operator|&
name|buf
index|[
name|buflen
index|]
condition|)
name|error
argument_list|(
literal|"Register too long@to fit in memory"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|partreg
argument_list|(
name|c
argument_list|)
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Encryption routines.  These are essentially unmodified from ed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CRYPT
end_ifdef

begin_comment
comment|/*  * crblock: encrypt/decrypt a block of text.  * buf is the buffer through which the text is both input and  * output. nchar is the size of the buffer. permp is a work  * buffer, and startn is the beginning of a sequence.  */
end_comment

begin_macro
name|crblock
argument_list|(
argument|permp
argument_list|,
argument|buf
argument_list|,
argument|nchar
argument_list|,
argument|startn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|permp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|startn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|n1
decl_stmt|;
name|int
name|n2
decl_stmt|;
specifier|register
name|char
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
name|t1
operator|=
name|permp
expr_stmt|;
name|t2
operator|=
operator|&
name|permp
index|[
literal|256
index|]
expr_stmt|;
name|t3
operator|=
operator|&
name|permp
index|[
literal|512
index|]
expr_stmt|;
name|n1
operator|=
name|startn
operator|&
literal|0377
expr_stmt|;
name|n2
operator|=
operator|(
name|startn
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
name|p1
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|nchar
operator|--
condition|)
block|{
operator|*
name|p1
operator|=
name|t2
index|[
operator|(
name|t3
index|[
operator|(
name|t1
index|[
operator|(
operator|*
name|p1
operator|+
name|n1
operator|)
operator|&
literal|0377
index|]
operator|+
name|n2
operator|)
operator|&
literal|0377
index|]
operator|-
name|n2
operator|)
operator|&
literal|0377
index|]
operator|-
name|n1
expr_stmt|;
name|n1
operator|++
expr_stmt|;
if|if
condition|(
name|n1
operator|==
literal|256
condition|)
block|{
name|n1
operator|=
literal|0
expr_stmt|;
name|n2
operator|++
expr_stmt|;
if|if
condition|(
name|n2
operator|==
literal|256
condition|)
name|n2
operator|=
literal|0
expr_stmt|;
block|}
name|p1
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * makekey: initialize buffers based on user key a.  */
end_comment

begin_macro
name|makekey
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
name|temp
index|[
name|KSIZE
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSIZE
condition|;
name|i
operator|++
control|)
name|temp
index|[
name|i
index|]
operator|=
operator|*
name|a
operator|++
expr_stmt|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|t
operator|+=
name|getpid
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|temp
index|[
name|i
index|]
operator|^=
operator|(
name|t
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
operator|)
operator|&
literal|0377
expr_stmt|;
name|crinit
argument_list|(
name|temp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * crinit: besides initializing the encryption machine, this routine  * returns 0 if the key is null, and 1 if it is non-null.  */
end_comment

begin_macro
name|crinit
argument_list|(
argument|keyp
argument_list|,
argument|permp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|keyp
decl_stmt|,
modifier|*
name|permp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|,
modifier|*
name|t3
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|ic
decl_stmt|,
name|k
decl_stmt|,
name|temp
decl_stmt|;
name|unsigned
name|random
decl_stmt|;
name|char
name|buf
index|[
literal|13
index|]
decl_stmt|;
name|long
name|seed
decl_stmt|;
name|t1
operator|=
name|permp
expr_stmt|;
name|t2
operator|=
operator|&
name|permp
index|[
literal|256
index|]
expr_stmt|;
name|t3
operator|=
operator|&
name|permp
index|[
literal|512
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|keyp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|keyp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|keyp
condition|)
operator|*
name|keyp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|domakekey
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|seed
operator|=
literal|123
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
name|seed
operator|=
name|seed
operator|*
name|buf
index|[
name|i
index|]
operator|+
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|t1
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|t3
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|seed
operator|=
literal|5
operator|*
name|seed
operator|+
name|buf
index|[
name|i
operator|%
literal|13
index|]
expr_stmt|;
name|random
operator|=
name|seed
operator|%
literal|65521
expr_stmt|;
name|k
operator|=
literal|256
operator|-
literal|1
operator|-
name|i
expr_stmt|;
name|ic
operator|=
operator|(
name|random
operator|&
literal|0377
operator|)
operator|%
operator|(
name|k
operator|+
literal|1
operator|)
expr_stmt|;
name|random
operator|>>=
literal|8
expr_stmt|;
name|temp
operator|=
name|t1
index|[
name|k
index|]
expr_stmt|;
name|t1
index|[
name|k
index|]
operator|=
name|t1
index|[
name|ic
index|]
expr_stmt|;
name|t1
index|[
name|ic
index|]
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|t3
index|[
name|k
index|]
operator|!=
literal|0
condition|)
continue|continue;
name|ic
operator|=
operator|(
name|random
operator|&
literal|0377
operator|)
operator|%
name|k
expr_stmt|;
while|while
condition|(
name|t3
index|[
name|ic
index|]
operator|!=
literal|0
condition|)
name|ic
operator|=
operator|(
name|ic
operator|+
literal|1
operator|)
operator|%
name|k
expr_stmt|;
name|t3
index|[
name|k
index|]
operator|=
name|ic
expr_stmt|;
name|t3
index|[
name|ic
index|]
operator|=
name|k
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|t2
index|[
name|t1
index|[
name|i
index|]
operator|&
literal|0377
index|]
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * domakekey: the following is the major nonportable part of the encryption  * mechanism. A 10 character key is supplied in buffer.  * This string is fed to makekey (an external program) which  * responds with a 13 character result. This result is placed  * in buffer.  */
end_comment

begin_macro
name|domakekey
argument_list|(
argument|buffer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pf
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pf
argument_list|)
operator|<
literal|0
condition|)
name|pf
index|[
literal|0
index|]
operator|=
name|pf
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|pf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/usr/lib/makekey"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/lib/makekey"
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ex_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|pf
index|[
literal|1
index|]
argument_list|,
name|buffer
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|read
argument_list|(
name|pf
index|[
literal|0
index|]
argument_list|,
name|buffer
argument_list|,
literal|13
argument_list|)
operator|!=
literal|13
condition|)
name|error
argument_list|(
literal|"crypt: cannot generate key"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* end of nonportable part */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

