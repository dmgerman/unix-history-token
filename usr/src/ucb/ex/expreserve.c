begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|copyright
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)expreserve.c	7.13 (Berkeley) 1/22/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"uparm.h"
end_include

begin_define
define|#
directive|define
name|TMP
value|"/tmp"
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_define
define|#
directive|define
name|HBLKS
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HBLKS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|xstr
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make loader happy */
end_comment

begin_comment
comment|/*  * Expreserve - preserve a file in usrpath(preserve)  * Bill Joy UCB November 13, 1977  *  * This routine is very naive - it doesn't remove anything from  * usrpath(preserve)... this may mean that we leave  * stuff there... the danger in doing anything with usrpath(preserve)  * is that the clock may be screwed up and we may get confused.  *  * We are called in two ways - first from the editor with no argumentss  * and the standard input open on the temp file. Second with an argument  * to preserve the entire contents of /tmp (root only).  *  * BUG: should do something about preserving Rx... (register contents)  *      temporaries.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|VMUNIX
end_ifndef

begin_define
define|#
directive|define
name|LBLKS
value|125
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LBLKS
value|900
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FNSIZE
value|128
end_define

begin_struct
struct|struct
name|header
block|{
name|time_t
name|Time
decl_stmt|;
comment|/* Time temp file last updated */
name|int
name|Uid
decl_stmt|;
comment|/* This users identity */
ifndef|#
directive|ifndef
name|VMUNIX
name|short
name|Flines
decl_stmt|;
comment|/* Number of lines in file */
else|#
directive|else
name|int
name|Flines
decl_stmt|;
endif|#
directive|endif
name|char
name|Savedfile
index|[
name|FNSIZE
index|]
decl_stmt|;
comment|/* The current file name */
name|short
name|Blocks
index|[
name|LBLKS
index|]
decl_stmt|;
comment|/* Blocks where line pointers stashed */
block|}
name|H
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_define
define|#
directive|define
name|ignore
parameter_list|(
name|a
parameter_list|)
value|Ignore(a)
end_define

begin_define
define|#
directive|define
name|ignorl
parameter_list|(
name|a
parameter_list|)
value|Ignorl(a)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ignore
parameter_list|(
name|a
parameter_list|)
value|a
end_define

begin_define
define|#
directive|define
name|ignorl
parameter_list|(
name|a
parameter_list|)
value|a
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|eq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|strcmp(a, b) == 0
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|)
name|int
name|argc
decl_stmt|;
block|{
specifier|register
name|DIR
modifier|*
name|tf
decl_stmt|;
name|struct
name|direct
modifier|*
name|dirent
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* 	 * If only one argument, then preserve the standard input. 	 */
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If not super user, then can only preserve standard input. 	 */
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NOT super user\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * ... else preserve all the stuff in /tmp, removing 	 * it as we go. 	 */
if|if
condition|(
name|chdir
argument_list|(
name|TMP
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|TMP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tf
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|TMP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dirent
operator|=
name|readdir
argument_list|(
name|tf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Ex temporaries must begin with Ex. */
if|if
condition|(
name|dirent
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'E'
operator|||
name|dirent
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'x'
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
continue|continue;
comment|/* 		 * Save the bastard. 		 */
name|ignore
argument_list|(
name|copyout
argument_list|(
name|dirent
operator|->
name|d_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|tf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|pattern
index|[]
init|=
name|usrpath
argument_list|(
name|preserve
operator|/
name|Exaa
operator|`
name|XXXXX
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copy file name into usrpath(preserve)/...  * If name is (char *) 0, then do the standard input.  * We make some checks on the input to make sure it is  * really an editor temporary, generate a name for the  * file (this is the slowest thing since we must stat  * to find a unique name), and finally copy the file.  */
end_comment

begin_macro
name|copyout
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|reenter
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	 * The first time we put in the digits of our 	 * process number at the end of the pattern. 	 */
if|if
condition|(
name|reenter
operator|==
literal|0
condition|)
block|{
name|mkdigits
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|reenter
operator|++
expr_stmt|;
block|}
comment|/* 	 * If a file name was given, make it the standard 	 * input if possible. 	 */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
block|{
name|ignore
argument_list|(
name|close
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Need read/write access for arcane reasons 		 * (see below). 		 */
if|if
condition|(
name|open
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Get the header block. 	 */
name|ignorl
argument_list|(
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|H
argument_list|,
sizeof|sizeof
name|H
argument_list|)
operator|!=
sizeof|sizeof
name|H
condition|)
block|{
name|format
label|:
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Buffer format error\t"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Consistency checsks so we don't copy out garbage. 	 */
if|if
condition|(
name|H
operator|.
name|Flines
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Negative number of lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
if|if
condition|(
name|H
operator|.
name|Blocks
index|[
literal|0
index|]
operator|!=
name|HBLKS
operator|||
name|H
operator|.
name|Blocks
index|[
literal|1
index|]
operator|!=
name|HBLKS
operator|+
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Blocks %d %d\n"
argument_list|,
name|H
operator|.
name|Blocks
index|[
literal|0
index|]
argument_list|,
name|H
operator|.
name|Blocks
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
operator|&&
name|H
operator|.
name|Uid
operator|!=
name|getuid
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Wrong user-id\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Negative number of lines\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|format
goto|;
block|}
comment|/* 	 * If no name was assigned to the file, then give it the name 	 * LOST, by putting this in the header. 	 */
if|if
condition|(
name|H
operator|.
name|Savedfile
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|H
operator|.
name|Savedfile
argument_list|,
literal|"LOST"
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|write
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|H
argument_list|,
sizeof|sizeof
name|H
argument_list|)
argument_list|)
expr_stmt|;
name|H
operator|.
name|Savedfile
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * File is good.  Get a name and create a file for the copy. 	 */
name|mknext
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|close
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|creat
argument_list|(
name|pattern
argument_list|,
literal|0600
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|perror
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Make the target be owned by the owner of the file. 	 */
name|ignore
argument_list|(
name|chown
argument_list|(
name|pattern
argument_list|,
name|H
operator|.
name|Uid
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the file. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|perror
argument_list|(
literal|"Buffer read error"
argument_list|)
expr_stmt|;
name|ignore
argument_list|(
name|unlink
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|ignore
argument_list|(
name|unlink
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|notify
argument_list|(
name|H
operator|.
name|Uid
argument_list|,
name|H
operator|.
name|Savedfile
argument_list|,
operator|(
name|int
operator|)
name|name
argument_list|,
name|H
operator|.
name|Time
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|!=
name|i
condition|)
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|perror
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Blast the last 5 characters of cp to be the process number.  */
end_comment

begin_macro
name|mkdigits
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
name|getpid
argument_list|()
operator|,
name|j
operator|=
literal|5
operator|,
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
init|;
name|j
operator|>
literal|0
condition|;
name|i
operator|/=
literal|10
operator|,
name|j
operator|--
control|)
operator|*
operator|--
name|cp
operator|=
name|i
operator|%
literal|10
operator||
literal|'0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Make the name in cp be unique by clobbering up to  * three alphabetic characters into a sequence of the form 'aab', 'aac', etc.  * Mktemp gets weird names too quickly to be useful here.  */
end_comment

begin_macro
name|mknext
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|dcp
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
name|dcp
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|dcp
argument_list|)
condition|)
name|dcp
operator|--
expr_stmt|;
name|whoops
label|:
if|if
condition|(
name|dcp
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|dcp
index|[
literal|0
index|]
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|dcp
index|[
operator|-
literal|1
index|]
operator|==
literal|'z'
condition|)
block|{
name|dcp
index|[
operator|-
literal|1
index|]
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|dcp
index|[
operator|-
literal|2
index|]
operator|==
literal|'z'
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find a name\t"
argument_list|)
expr_stmt|;
name|dcp
index|[
operator|-
literal|2
index|]
operator|++
expr_stmt|;
block|}
else|else
name|dcp
index|[
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
else|else
name|dcp
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|stb
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|whoops
goto|;
block|}
end_block

begin_comment
comment|/*  * Notify user uid that his file fname has been saved.  */
end_comment

begin_macro
name|notify
argument_list|(
argument|uid
argument_list|,
argument|fname
argument_list|,
argument|flag
argument_list|,
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|int
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|passwd
modifier|*
name|pp
init|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|mf
decl_stmt|;
name|char
name|cmd
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|hostname
index|[
literal|128
index|]
decl_stmt|;
name|char
name|croak
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|timestamp
decl_stmt|,
modifier|*
name|ctime
argument_list|()
decl_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|timestamp
operator|=
name|ctime
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|timestamp
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
comment|/* blast from seconds on */
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"/bin/mail %s"
argument_list|,
name|pp
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|mf
operator|=
name|popen
argument_list|(
name|cmd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
operator|==
name|NULL
condition|)
return|return;
name|setbuf
argument_list|(
name|mf
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* 	 *	flag says how the editor croaked: 	 * "the editor was killed" is perhaps still not an ideal 	 * error message.  Usually, either it was forcably terminated 	 * or the phone was hung up, but we don't know which. 	 */
name|sprintf
argument_list|(
name|croak
argument_list|,
name|flag
condition|?
literal|"the system went down"
else|:
literal|"the editor was killed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|fname
operator|=
literal|"LOST"
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"Subject: editor saved ``LOST''\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"You were editing a file without a name\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"at<%s> on the machine ``%s'' when %s.\n"
argument_list|,
name|timestamp
argument_list|,
name|hostname
argument_list|,
name|croak
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"Since the file had no name, it has been named \"LOST\".\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"Subject: editor saved ``%s''\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"You were editing the file \"%s\"\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"at<%s> on the machine ``%s''\n"
argument_list|,
name|timestamp
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"when %s.\n"
argument_list|,
name|croak
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"\nYou can retrieve most of your changes to this file\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"using the \"recover\" command of the editor.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"An easy way to do this is to give the command \"vi -r %s\".\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mf
argument_list|,
literal|"This method also works using \"ex\" and \"edit\".\n"
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	people making love  *	never exactly the same  *	just like a snowflake   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_macro
name|Ignore
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_macro
name|Ignorl
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|long
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|a
operator|=
name|a
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

