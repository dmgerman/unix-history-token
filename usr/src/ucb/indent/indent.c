begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * Copyright (c) 1976 Board of Trustees of the University of Illinois.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley and the University  * of Illinois, Urbana.  The name of either  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\ Copyright (c) 1976 Board of Trustees of the University of Illinois.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)indent.c	5.8 (Berkeley) 6/29/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* NAME: indent main program    FUNCTION: This is the main program of the indent program.  Indent will take a C program source and reformat it into a semi-reasonable form.    ALGORITHM: The routine lexi scans tokens and passes them back one at a time to the main routine.  The subroutine parse takes care of much of the work of figuring indentation level.      1) Call lexi 2) Enter a monster switch statement on the code returned by lexi.  If  the indentation level for the line yet to be printed should be  changed, set the variable ps.ind_level.  If the indentation level for the following line should be changed, set the variable ps.i_l_follow.  */
end_comment

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|in_name
init|=
literal|"Standard Input"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will always point to name of 					 * input file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|out_name
init|=
literal|"Standard Output"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will always point to 						 * name of output file */
end_comment

begin_decl_stmt
name|char
name|bakfile
index|[
literal|32
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|found_err
decl_stmt|;
comment|/* if any error occurred */
name|int
name|dec_ind
decl_stmt|;
comment|/* current indentation for declarations */
name|int
name|di_stack
index|[
literal|20
index|]
decl_stmt|;
comment|/* a stack of structure indentation levels */
name|int
name|flushed_nl
decl_stmt|;
comment|/* used when buffering up comments to 				 * remember that a newline was passed over */
name|int
name|force_nl
decl_stmt|;
comment|/* when true, code must be broken */
name|int
name|hd_type
decl_stmt|;
comment|/* used to store type of stmt for if 				 * (...), for (...), etc */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* local loop counter */
specifier|register
name|int
name|j
decl_stmt|;
comment|/* local loop counter */
name|int
name|scase
decl_stmt|;
comment|/* set to true when we see a case, so we 				 * will know what to do with the following 				 * colon */
name|int
name|sp_sw
decl_stmt|;
comment|/* when true, we are in the expressin of 				 * if(...), while(...), etc. */
name|int
name|squest
decl_stmt|;
comment|/* when this is positive, we have seen a ? 				 * without the matching : in a<c>?<s>:<s> 				 * construct */
specifier|register
name|char
modifier|*
name|t_ptr
decl_stmt|;
comment|/* used for copying tokens */
name|int
name|type_code
decl_stmt|;
comment|/* the type of token, returned by lexi */
name|int
name|last_else
init|=
literal|0
decl_stmt|;
comment|/* true iff last keyword was an else */
comment|/*-----------------------------------------------*\     |		      INITIALIZATION		      |     \*-----------------------------------------------*/
name|ps
operator|.
name|p_stack
index|[
literal|0
index|]
operator|=
name|stmt
expr_stmt|;
comment|/* this is the parser's stack */
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* this is true if the last thing scanned 				 * was a newline */
name|ps
operator|.
name|last_token
operator|=
name|semicolon
expr_stmt|;
name|combuf
index|[
literal|0
index|]
operator|=
name|codebuf
index|[
literal|0
index|]
operator|=
name|labbuf
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* set up code, label, and 						 * comment buffers */
name|combuf
index|[
literal|1
index|]
operator|=
name|codebuf
index|[
literal|1
index|]
operator|=
name|labbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s_lab
operator|=
name|e_lab
operator|=
name|labbuf
operator|+
literal|1
expr_stmt|;
name|s_code
operator|=
name|e_code
operator|=
name|codebuf
operator|+
literal|1
expr_stmt|;
name|s_com
operator|=
name|e_com
operator|=
name|combuf
operator|+
literal|1
expr_stmt|;
name|buf_ptr
operator|=
name|buf_end
operator|=
name|in_buffer
expr_stmt|;
name|line_no
operator|=
literal|1
expr_stmt|;
name|had_eof
operator|=
name|ps
operator|.
name|in_decl
operator|=
name|ps
operator|.
name|decl_on_line
operator|=
name|break_comma
operator|=
name|false
expr_stmt|;
name|sp_sw
operator|=
name|force_nl
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|in_or_st
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|bl_line
operator|=
name|true
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
name|di_stack
index|[
name|ps
operator|.
name|dec_nest
operator|=
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|ps
operator|.
name|in_stmt
operator|=
name|ps
operator|.
name|ind_stmt
operator|=
name|false
expr_stmt|;
name|scase
operator|=
name|ps
operator|.
name|pcase
operator|=
name|false
expr_stmt|;
name|squest
operator|=
literal|0
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
name|bp_save
operator|=
literal|0
expr_stmt|;
name|be_save
operator|=
literal|0
expr_stmt|;
name|output
operator|=
literal|0
expr_stmt|;
comment|/*--------------------------------------------------*\     |   COMMAND LINE SCAN     \*--------------------------------------------------*/
name|set_defaults
argument_list|()
expr_stmt|;
comment|/*      * Unfortunately, we must look for -npro here because the profiles      * are read before the command line arguments.      */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-npro"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
name|set_profile
argument_list|()
expr_stmt|;
name|input
operator|=
literal|0
expr_stmt|;
comment|/* cancel -st if it was in the profiles, */
name|output
operator|=
literal|0
expr_stmt|;
comment|/* as it doesn't make any sense there. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
comment|/* 	 * look thru args (if any) for changes to defaults  	 */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
comment|/* no flag on parameter */
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
comment|/* we must have the input file */
name|in_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* remember name of input file */
name|input
operator|=
name|fopen
argument_list|(
name|in_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
comment|/* check for open error */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: can't open %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|output
operator|==
literal|0
condition|)
block|{
comment|/* we have the output file */
name|out_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* remember name of output file */
if|if
condition|(
name|strcmp
argument_list|(
name|in_name
argument_list|,
name|out_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* attempt to overwrite 							 * the file */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: input and output files must be different\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|output
operator|=
name|fopen
argument_list|(
name|out_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
literal|0
condition|)
block|{
comment|/* check for create error */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: can't create %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: unknown parameter: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|set_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* end of for */
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Usage: indent file [ outfile ] [ options ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output
operator|==
literal|0
condition|)
if|if
condition|(
name|troff
condition|)
name|output
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|out_name
operator|=
name|in_name
expr_stmt|;
name|bakcopy
argument_list|()
expr_stmt|;
block|}
comment|/*      * Adjust parameters that are out of range, or set defaults if      * no values were specified.      */
if|if
condition|(
name|ps
operator|.
name|com_ind
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_ind
operator|=
literal|2
expr_stmt|;
comment|/* dont put normal comments before column 				 * 2 */
if|if
condition|(
name|block_comment_max_col
operator|<=
literal|0
condition|)
name|block_comment_max_col
operator|=
name|max_col
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|decl_com_ind
operator|<=
literal|0
condition|)
comment|/* if not specified by user, set this */
name|ps
operator|.
name|decl_com_ind
operator|=
name|ps
operator|.
name|ljust_decl
condition|?
name|ps
operator|.
name|com_ind
operator|-
literal|8
else|:
name|ps
operator|.
name|com_ind
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|decl_com_ind
operator|<=
literal|1
condition|)
name|ps
operator|.
name|decl_com_ind
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|continuation_indent
operator|==
literal|0
condition|)
name|continuation_indent
operator|=
name|ps
operator|.
name|ind_size
expr_stmt|;
name|fill_buffer
argument_list|()
expr_stmt|;
comment|/* get first batch of stuff into input 				 * buffer */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|buf_ptr
decl_stmt|;
specifier|register
name|col
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|col
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|col
operator|=
operator|(
operator|(
name|col
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
literal|9
expr_stmt|;
else|else
break|break;
name|p
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|col
operator|>
name|ps
operator|.
name|ind_size
condition|)
name|ps
operator|.
name|ind_level
operator|=
name|ps
operator|.
name|i_l_follow
operator|=
name|col
operator|/
name|ps
operator|.
name|ind_size
expr_stmt|;
block|}
if|if
condition|(
name|troff
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|in_name
decl_stmt|,
modifier|*
name|beg
init|=
name|in_name
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|beg
operator|=
name|p
expr_stmt|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|".Fn \"%s\"\n"
argument_list|,
name|beg
argument_list|)
expr_stmt|;
block|}
comment|/*      * START OF MAIN LOOP       */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* this is the main loop.  it will go 				 * until we reach eof */
name|int
name|is_procname
decl_stmt|;
name|type_code
operator|=
name|lexi
argument_list|()
expr_stmt|;
comment|/* lexi reads one token.  The actual 				 * characters read are stored in "token". 				 * lexi returns a code indicating the type 				 * of token */
name|is_procname
operator|=
name|ps
operator|.
name|procname
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * The following code moves everything following an if (), while 	 * (), else, etc. up to the start of the following stmt to a 	 * buffer.  This allows proper handling of both kinds of brace 	 * placement.  	 */
name|flushed_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|ps
operator|.
name|search_brace
condition|)
block|{
comment|/* if we scanned an if(), while(), 					 * etc., we might need to copy 					 * stuff into a buffer we must 					 * loop, copying stuff into 					 * save_com, until we find the 					 * start of the stmt which follows 					 * the if, or whatever */
switch|switch
condition|(
name|type_code
condition|)
block|{
case|case
name|newline
case|:
operator|++
name|line_no
expr_stmt|;
name|flushed_nl
operator|=
name|true
expr_stmt|;
case|case
name|form_feed
case|:
break|break;
comment|/* form feeds and newlines found here will 				 * be ignored */
case|case
name|lbrace
case|:
comment|/* this is a brace that starts the 				 * compound stmt */
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* ignore buffering if a comment 					 * wasnt stored up */
name|ps
operator|.
name|search_brace
operator|=
name|false
expr_stmt|;
goto|goto
name|check_type
goto|;
block|}
if|if
condition|(
name|btype_2
condition|)
block|{
name|save_com
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
comment|/* we either want to put 						 * the brace right after 						 * the if */
goto|goto
name|sw_buffer
goto|;
comment|/* go to common code to get out of 					 * this loop */
block|}
case|case
name|comment
case|:
comment|/* we have a comment, so we must copy it 				 * into the buffer */
if|if
condition|(
operator|!
name|flushed_nl
condition|)
block|{
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* if this is the first 						 * comment, we must set up 						 * the buffer */
name|save_com
index|[
literal|0
index|]
operator|=
name|save_com
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|sc_end
operator|=
operator|&
operator|(
name|save_com
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* add newline between 						 * comments */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
block|}
operator|*
name|sc_end
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* copy in start of 						 * comment */
operator|*
name|sc_end
operator|++
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* loop until we get to the end of 					 * the comment */
operator|*
name|sc_end
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|sc_end
operator|++
operator|==
literal|'*'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
break|break;
comment|/* we are at end of comment */
if|if
condition|(
name|sc_end
operator|>=
operator|&
operator|(
name|save_com
index|[
name|sc_size
index|]
operator|)
condition|)
block|{
comment|/* check for temp buffer 									 * overflow */
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Internal buffer overflow - Move big comment from right after if, while, or whatever."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sc_end
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* add ending slash */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* get past / in buffer */
name|fill_buffer
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
comment|/* it is the start of a normal statment */
if|if
condition|(
name|flushed_nl
condition|)
comment|/* if we flushed a newline, make 					 * sure it is put back */
name|force_nl
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|type_code
operator|==
name|sp_paren
operator|&&
operator|*
name|token
operator|==
literal|'i'
operator|&&
name|last_else
operator|&&
name|ps
operator|.
name|else_if
operator|||
name|type_code
operator|==
name|sp_nparen
operator|&&
operator|*
name|token
operator|==
literal|'e'
operator|&&
name|e_code
operator|!=
name|s_code
operator|&&
name|e_code
index|[
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
name|force_nl
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* ignore buffering if comment 					 * wasnt saved up */
name|ps
operator|.
name|search_brace
operator|=
name|false
expr_stmt|;
goto|goto
name|check_type
goto|;
block|}
if|if
condition|(
name|force_nl
condition|)
block|{
comment|/* if we should insert a nl here, 					 * put it into the buffer */
name|force_nl
operator|=
name|false
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
comment|/* this will be re-increased when 					 * the nl is read from the buffer */
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|!
name|flushed_nl
condition|)
comment|/* print error msg if 							 * the line was not 							 * already broken */
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|flushed_nl
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|sc_end
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* copy token into temp 						 * buffer */
name|sw_buffer
label|:
name|ps
operator|.
name|search_brace
operator|=
name|false
expr_stmt|;
comment|/* stop looking for start 						 * of stmt */
name|bp_save
operator|=
name|buf_ptr
expr_stmt|;
comment|/* save current input buffer */
name|be_save
operator|=
name|buf_end
expr_stmt|;
name|buf_ptr
operator|=
name|save_com
expr_stmt|;
comment|/* fix so that subsequent calls to 					 * lexi will take tokens out of 					 * save_com */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add trailing blank, just in 					 * case */
name|buf_end
operator|=
name|sc_end
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* end of switch */
if|if
condition|(
name|type_code
operator|!=
literal|0
condition|)
comment|/* we must make this check, just in case 				 * there was an unexpected EOF */
name|type_code
operator|=
name|lexi
argument_list|()
expr_stmt|;
comment|/* read another token */
name|is_procname
operator|=
name|ps
operator|.
name|procname
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* end of while (serach_brace) */
name|last_else
operator|=
literal|0
expr_stmt|;
name|check_type
label|:
if|if
condition|(
name|type_code
operator|==
literal|0
condition|)
block|{
comment|/* we got eof */
if|if
condition|(
name|s_lab
operator|!=
name|e_lab
operator|||
name|s_code
operator|!=
name|e_code
operator|||
name|s_com
operator|!=
name|e_com
condition|)
comment|/* must dump end of line */
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|tos
operator|>
literal|1
condition|)
comment|/* check for balanced braces */
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Stuff missing from end of file."
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"There were %d output lines and %d comments\n"
argument_list|,
name|ps
operator|.
name|out_lines
argument_list|,
name|ps
operator|.
name|out_coms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(Lines with comments)/(Lines with code): %6.3f\n"
argument_list|,
operator|(
literal|1.0
operator|*
name|ps
operator|.
name|com_lines
operator|)
operator|/
name|code_lines
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ps
operator|.
name|tos
operator|>
literal|1
operator|||
name|found_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type_code
operator|!=
name|comment
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|newline
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|preesc
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|form_feed
operator|)
condition|)
block|{
if|if
condition|(
name|force_nl
operator|&&
operator|(
name|type_code
operator|!=
name|semicolon
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|lbrace
operator|||
operator|!
name|btype_2
operator|)
condition|)
block|{
comment|/* we should force a broken line here */
if|if
condition|(
name|verbose
operator|&&
operator|!
name|flushed_nl
condition|)
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|flushed_nl
operator|=
name|false
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* dont insert blank at line start */
name|force_nl
operator|=
name|false
expr_stmt|;
block|}
name|ps
operator|.
name|in_stmt
operator|=
name|true
expr_stmt|;
comment|/* turn on flag which causes an extra 				 * level of indentation. this is turned 				 * off by a ; or '}' */
if|if
condition|(
name|s_com
operator|!=
name|e_com
condition|)
block|{
comment|/* the turkey has embedded a 					 * comment in a line. fix it */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|s_com
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate code sect */
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
name|e_com
operator|=
name|s_com
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type_code
operator|!=
name|comment
condition|)
comment|/* preserve force_nl thru 						 * a comment */
name|force_nl
operator|=
name|false
expr_stmt|;
comment|/* 	 * cancel forced newline after newline, form feed, etc  	 */
comment|/*----------------------------------------------------*\ 	|   do switch on type of token scanned 	\*----------------------------------------------------*/
switch|switch
condition|(
name|type_code
condition|)
block|{
comment|/* now, decide what to do with the token */
case|case
name|form_feed
case|:
comment|/* found a form feed in line */
name|ps
operator|.
name|use_ff
operator|=
name|true
expr_stmt|;
comment|/* a form feed is treated much 					 * like a newline */
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|newline
case|:
if|if
condition|(
name|ps
operator|.
name|last_token
operator|!=
name|comma
operator|||
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
operator|||
operator|!
name|ps
operator|.
name|leave_comma
operator|||
operator|!
name|break_comma
operator|||
name|s_com
operator|!=
name|e_com
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
operator|++
name|line_no
expr_stmt|;
comment|/* keep track of input line number */
break|break;
case|case
name|lparen
case|:
comment|/* got a '(' or '[' */
operator|++
name|ps
operator|.
name|p_l_follow
expr_stmt|;
comment|/* count parens to make Healy happy */
if|if
condition|(
name|ps
operator|.
name|want_blank
operator|&&
operator|*
name|token
operator|!=
literal|'['
operator|&&
operator|(
name|ps
operator|.
name|last_token
operator|!=
name|ident
operator|||
name|proc_calls_space
operator|||
operator|(
name|ps
operator|.
name|its_a_keyword
operator|&&
operator|!
name|ps
operator|.
name|sizeof_keyword
operator|)
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
if|if
condition|(
name|troff
operator|&&
operator|!
name|ps
operator|.
name|dumped_decl_indent
condition|)
block|{
name|ps
operator|.
name|dumped_decl_indent
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|e_code
argument_list|,
literal|"\\c\n.Du %dp+\200p \"%s\"\n"
argument_list|,
name|dec_ind
operator|*
literal|7
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|e_code
operator|+=
name|strlen
argument_list|(
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
name|dec_ind
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|ps
operator|.
name|paren_indents
index|[
name|ps
operator|.
name|p_l_follow
operator|-
literal|1
index|]
operator|=
name|e_code
operator|-
name|s_code
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_or_st
operator|&&
operator|*
name|token
operator|==
literal|'('
condition|)
block|{
comment|/* 		     * this is a kluge to make sure that declarations will 		     * be aligned right if proc decl has an explicit type 		     * on it, i.e. "int a(x) {..."  		     */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/* I said this was a kluge... */
name|ps
operator|.
name|in_or_st
operator|=
name|false
expr_stmt|;
comment|/* turn off flag for 						 * structure decl or 						 * initialization */
block|}
if|if
condition|(
name|ps
operator|.
name|sizeof_keyword
condition|)
name|ps
operator|.
name|sizeof_mask
operator||=
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
expr_stmt|;
break|break;
case|case
name|rparen
case|:
comment|/* got a ')' or ']' */
if|if
condition|(
name|ps
operator|.
name|cast_mask
operator|&
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|&
operator|~
name|ps
operator|.
name|sizeof_mask
condition|)
block|{
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|cast_mask
operator|&=
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|ps
operator|.
name|sizeof_mask
operator|&=
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|ps
operator|.
name|p_l_follow
operator|<
literal|0
condition|)
block|{
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Extra %c"
argument_list|,
operator|*
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e_code
operator|==
name|s_code
condition|)
comment|/* if the paren starts the line */
name|ps
operator|.
name|paren_level
operator|=
name|ps
operator|.
name|p_l_follow
expr_stmt|;
comment|/* then indent it */
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sp_sw
operator|&&
operator|(
name|ps
operator|.
name|p_l_follow
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* check for end of if 							 * (...), or some such */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* must force newline after if */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* inform lexi that a following 					 * operator is unary */
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* dont use stmt continuation 					 * indentation */
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
comment|/* let parser worry about if, or 					 * whatever */
block|}
name|ps
operator|.
name|search_brace
operator|=
name|btype_2
expr_stmt|;
comment|/* this should insure that 						 * constructs such as 						 * main(){...} and 						 * int[]{...} have their 						 * braces put in the right 						 * place */
break|break;
case|case
name|unary_op
case|:
comment|/* this could be any unary operation */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|troff
operator|&&
operator|!
name|ps
operator|.
name|dumped_decl_indent
operator|&&
name|ps
operator|.
name|in_decl
condition|)
block|{
name|sprintf
argument_list|(
name|e_code
argument_list|,
literal|"\\c\n.Du %dp+\200p \"%s\"\n"
argument_list|,
name|dec_ind
operator|*
literal|7
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|ps
operator|.
name|dumped_decl_indent
operator|=
literal|1
expr_stmt|;
name|e_code
operator|+=
name|strlen
argument_list|(
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|res
init|=
name|token
decl_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
comment|/* if this is a unary op 							 * in a declaration, we 							 * should indent this 							 * token */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|/* find length of token */
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
name|i
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* pad it */
block|}
if|if
condition|(
name|troff
operator|&&
name|token
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|token
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
name|res
operator|=
literal|"\\(->"
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|res
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
block|}
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|binary_op
case|:
comment|/* any binary operation */
name|do_binary
label|:
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|{
name|char
modifier|*
name|res
init|=
name|token
decl_stmt|;
if|if
condition|(
name|troff
condition|)
switch|switch
condition|(
name|token
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|res
operator|=
literal|"\\(<="
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|res
operator|=
literal|"\\(>="
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|res
operator|=
literal|"\\(!="
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
name|res
operator|=
literal|"\\(br\\(br"
expr_stmt|;
elseif|else
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|res
operator|=
literal|"\\(br"
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
name|res
operator|=
literal|"\\(->"
expr_stmt|;
block|}
for|for
control|(
name|t_ptr
operator|=
name|res
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* move the operator */
block|}
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|postop
case|:
comment|/* got a trailing ++ or -- */
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|1
index|]
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|question
case|:
comment|/* got a ? */
name|squest
operator|++
expr_stmt|;
comment|/* this will be used when a later colon 				 * appears so we can distinguish the 				 *<c>?<n>:<n> construct */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'?'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|casestmt
case|:
comment|/* got word 'case' or 'default' */
name|scase
operator|=
name|true
expr_stmt|;
comment|/* so we can process the later colon 				 * properly */
goto|goto
name|copy_id
goto|;
case|case
name|colon
case|:
comment|/* got a ':' */
if|if
condition|(
name|squest
operator|>
literal|0
condition|)
block|{
comment|/* it is part of the<c>?<n>:<n> 					 * construct */
operator|--
name|squest
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|':'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ps
operator|.
name|in_decl
condition|)
block|{
operator|*
name|e_code
operator|++
operator|=
literal|':'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* seeing a label does not imply 					 * we are in a stmt */
for|for
control|(
name|t_ptr
operator|=
name|s_code
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* turn everything so far into a 					 * label */
name|e_code
operator|=
name|s_code
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_lab
operator|=
literal|'\0'
expr_stmt|;
name|force_nl
operator|=
name|ps
operator|.
name|pcase
operator|=
name|scase
expr_stmt|;
comment|/* ps.pcase will be used 						 * by dump_line to decide 						 * how to indent the 						 * label. force_nl will 						 * force a case n: to be 						 * on a line by itself */
name|scase
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|semicolon
case|:
comment|/* got a ';' */
name|ps
operator|.
name|in_or_st
operator|=
name|false
expr_stmt|;
comment|/* we are not in an initialization 					 * or structure declaration */
name|scase
operator|=
name|false
expr_stmt|;
comment|/* these will only need resetting in a 				 * error */
name|squest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
condition|)
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|cast_mask
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|sizeof_mask
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|block_init
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|--
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
name|s_code
operator|==
name|e_code
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
literal|1
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|ps
operator|.
name|in_decl
operator|=
operator|(
name|ps
operator|.
name|dec_nest
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* if we were in a first 						 * level structure 						 * declaration, we arent 						 * any more */
if|if
condition|(
operator|(
operator|!
name|sp_sw
operator|||
name|hd_type
operator|!=
name|forstmt
operator|)
operator|&&
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
condition|)
block|{
comment|/* 		     * This should be true iff there were unbalanced 		     * parens in the stmt.  It is a bit complicated, 		     * because the semicolon might be in a for stmt  		     */
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Unbalanced parens"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp_sw
condition|)
block|{
comment|/* this is a check for a if, while, etc. 				 * with unbalanced parens */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
comment|/* dont lose the if, or whatever */
block|}
block|}
operator|*
name|e_code
operator|++
operator|=
literal|';'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|in_stmt
operator|=
operator|(
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* we are no longer in 							 * the middle of a stmt */
if|if
condition|(
operator|!
name|sp_sw
condition|)
block|{
comment|/* if not if for (;;) */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/* let parser know about end of 					 * stmt */
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* force newline after a end of 					 * stmt */
block|}
break|break;
case|case
name|lbrace
case|:
comment|/* got a '{' */
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* dont indent the {} */
if|if
condition|(
operator|!
name|ps
operator|.
name|block_init
condition|)
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* force other stuff on same line 					 * as '{' onto new line */
if|if
condition|(
name|s_code
operator|!=
name|e_code
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
if|if
condition|(
operator|!
name|btype_2
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|.
name|in_parameter_declaration
operator|&&
operator|!
name|ps
operator|.
name|in_or_st
condition|)
block|{
name|ps
operator|.
name|i_l_follow
operator|=
literal|0
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|in_parameter_declaration
condition|)
name|prefix_blankline_requested
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
condition|)
block|{
comment|/* check for preceding 						 * unbalanced parens */
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Unbalanced parens"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp_sw
condition|)
block|{
comment|/* check for unclosed if, for, etc. */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
name|ps
operator|.
name|ind_level
operator|=
name|ps
operator|.
name|i_l_follow
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s_code
operator|==
name|e_code
condition|)
name|ps
operator|.
name|ind_stmt
operator|=
name|false
expr_stmt|;
comment|/* dont put extra 						 * indentation on line 						 * with '{' */
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
name|ps
operator|.
name|in_or_st
condition|)
block|{
comment|/* this is either a 							 * structure declaration 							 * or an init */
name|di_stack
index|[
name|ps
operator|.
name|dec_nest
operator|++
index|]
operator|=
name|dec_ind
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|decl_on_line
operator|=
name|false
expr_stmt|;
comment|/* we cant be in the 						 * middle of a 						 * declaration, so dont do 						 * special indentation of 						 * comments */
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|0
expr_stmt|;
block|}
name|parse
argument_list|(
name|lbrace
argument_list|)
expr_stmt|;
comment|/* let parser know about this */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
comment|/* put a blank before '{' if '{' 					 * is not at start of line */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'{'
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rbrace
case|:
comment|/* got a '}' */
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
block|{
comment|/* check for unclosed if, for, 					 * else. */
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Unbalanced parens"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
name|sp_sw
operator|=
name|false
expr_stmt|;
block|}
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
comment|/* '}' must be first on 								 * line */
if|if
condition|(
name|verbose
condition|)
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|e_code
operator|++
operator|=
literal|'}'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|in_stmt
operator|=
name|ps
operator|.
name|ind_stmt
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|dec_nest
operator|>
literal|0
condition|)
block|{
comment|/* we are in multi-level structure 					 * declaration */
name|dec_ind
operator|=
name|di_stack
index|[
operator|--
name|ps
operator|.
name|dec_nest
index|]
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|dec_nest
operator|==
literal|0
operator|&&
operator|!
name|ps
operator|.
name|in_parameter_declaration
condition|)
name|ps
operator|.
name|just_saw_decl
operator|=
literal|2
expr_stmt|;
name|ps
operator|.
name|in_decl
operator|=
name|true
expr_stmt|;
block|}
name|prefix_blankline_requested
operator|=
literal|0
expr_stmt|;
name|parse
argument_list|(
name|rbrace
argument_list|)
expr_stmt|;
comment|/* let parser know about this */
name|ps
operator|.
name|search_brace
operator|=
name|cuddle_else
operator|&&
name|ps
operator|.
name|p_stack
index|[
name|ps
operator|.
name|tos
index|]
operator|==
name|ifhead
operator|&&
name|ps
operator|.
name|il
index|[
name|ps
operator|.
name|tos
index|]
operator|>=
name|ps
operator|.
name|ind_level
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|tos
operator|<=
literal|1
operator|&&
name|blanklines_after_procs
operator|&&
name|ps
operator|.
name|dec_nest
operator|<=
literal|0
condition|)
name|postfix_blankline_requested
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|swstmt
case|:
comment|/* got keyword "switch" */
name|sp_sw
operator|=
name|true
expr_stmt|;
name|hd_type
operator|=
name|swstmt
expr_stmt|;
comment|/* keep this for when we have seen 					 * the expression */
goto|goto
name|copy_id
goto|;
comment|/* go move the token into buffer */
case|case
name|sp_paren
case|:
comment|/* token is if, while, for */
name|sp_sw
operator|=
name|true
expr_stmt|;
comment|/* the interesting stuff is done after the 				 * expression is scanned */
name|hd_type
operator|=
operator|(
operator|*
name|token
operator|==
literal|'i'
condition|?
name|ifstmt
else|:
operator|(
operator|*
name|token
operator|==
literal|'w'
condition|?
name|whilestmt
else|:
name|forstmt
operator|)
operator|)
expr_stmt|;
comment|/* 		 * remember the type of header for later use by parser  		 */
goto|goto
name|copy_id
goto|;
comment|/* copy the token into line */
case|case
name|sp_nparen
case|:
comment|/* got else, do */
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|*
name|token
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|e_code
operator|!=
name|s_code
operator|&&
operator|(
operator|!
name|cuddle_else
operator|||
name|e_code
index|[
operator|-
literal|1
index|]
operator|!=
literal|'}'
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
comment|/* make sure this starts a line */
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* also, following stuff must go 					 * onto new line */
name|last_else
operator|=
literal|1
expr_stmt|;
name|parse
argument_list|(
name|elselit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e_code
operator|!=
name|s_code
condition|)
block|{
comment|/* make sure this starts a 						 * line */
if|if
condition|(
name|verbose
condition|)
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* also, following stuff must go 					 * onto new line */
name|last_else
operator|=
literal|0
expr_stmt|;
name|parse
argument_list|(
name|dolit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|copy_id
goto|;
comment|/* move the token into line */
case|case
name|decl
case|:
comment|/* we have a declaration type (int, 				 * register, etc.) */
name|parse
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* let parser worry about indentation */
if|if
condition|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
operator|&&
name|ps
operator|.
name|tos
operator|<=
literal|1
condition|)
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_parameter_declaration
operator|&&
name|ps
operator|.
name|indent_parameters
operator|&&
name|ps
operator|.
name|dec_nest
operator|==
literal|0
condition|)
block|{
name|ps
operator|.
name|ind_level
operator|=
name|ps
operator|.
name|i_l_follow
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|ind_stmt
operator|=
literal|0
expr_stmt|;
block|}
name|ps
operator|.
name|in_or_st
operator|=
name|true
expr_stmt|;
comment|/* this might be a structure or 					 * initialization declaration */
name|ps
operator|.
name|in_decl
operator|=
name|ps
operator|.
name|decl_on_line
operator|=
name|true
expr_stmt|;
if|if
condition|(
comment|/* !ps.in_or_st&& */
name|ps
operator|.
name|dec_nest
operator|<=
literal|0
condition|)
name|ps
operator|.
name|just_saw_decl
operator|=
literal|2
expr_stmt|;
name|prefix_blankline_requested
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
operator|++
index|]
condition|;
control|)
empty_stmt|;
comment|/* get length of token */
comment|/* 		 * dec_ind = e_code - s_code + (ps.decl_indent>i ? 		 * ps.decl_indent : i);  		 */
name|dec_ind
operator|=
name|ps
operator|.
name|decl_indent
operator|>
literal|0
condition|?
name|ps
operator|.
name|decl_indent
else|:
name|i
expr_stmt|;
goto|goto
name|copy_id
goto|;
case|case
name|ident
case|:
comment|/* got an identifier or constant */
if|if
condition|(
name|ps
operator|.
name|in_decl
condition|)
block|{
comment|/* if we are in a declaration, we 					 * must indent identifier */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|is_procname
operator|==
literal|0
operator|||
operator|!
name|procnames_start_line
condition|)
block|{
if|if
condition|(
operator|!
name|ps
operator|.
name|block_init
condition|)
if|if
condition|(
name|troff
operator|&&
operator|!
name|ps
operator|.
name|dumped_decl_indent
condition|)
block|{
name|sprintf
argument_list|(
name|e_code
argument_list|,
literal|"\\c\n.De %dp+\200p\n"
argument_list|,
name|dec_ind
operator|*
literal|7
argument_list|)
expr_stmt|;
name|ps
operator|.
name|dumped_decl_indent
operator|=
literal|1
expr_stmt|;
name|e_code
operator|+=
name|strlen
argument_list|(
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
name|dec_ind
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dec_ind
operator|&&
name|s_code
operator|!=
name|e_code
condition|)
name|dump_line
argument_list|()
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp_sw
operator|&&
name|ps
operator|.
name|p_l_follow
operator|==
literal|0
condition|)
block|{
name|sp_sw
operator|=
name|false
expr_stmt|;
name|force_nl
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
block|}
name|copy_id
label|:
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|troff
operator|&&
name|ps
operator|.
name|its_a_keyword
condition|)
block|{
operator|*
name|e_code
operator|++
operator|=
name|BACKSLASH
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'f'
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'B'
expr_stmt|;
block|}
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
if|if
condition|(
name|troff
operator|&&
name|ps
operator|.
name|its_a_keyword
condition|)
block|{
operator|*
name|e_code
operator|++
operator|=
name|BACKSLASH
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'f'
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'R'
expr_stmt|;
block|}
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|period
case|:
comment|/* treat a period kind of like a binary 				 * operation */
operator|*
name|e_code
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* move the period into line */
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* dont put a blank after a period */
break|break;
case|case
name|comma
case|:
name|ps
operator|.
name|want_blank
operator|=
operator|(
name|s_code
operator|!=
name|e_code
operator|)
expr_stmt|;
comment|/* only put blank after 							 * comma if comma does 							 * not start the line */
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
name|is_procname
operator|==
literal|0
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
literal|1
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|p_l_follow
operator|==
literal|0
condition|)
block|{
name|ps
operator|.
name|block_init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|break_comma
operator|&&
operator|!
name|ps
operator|.
name|leave_comma
condition|)
name|force_nl
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|preesc
case|:
comment|/* got the character '#' */
if|if
condition|(
operator|(
name|s_com
operator|!=
name|e_com
operator|)
operator|||
operator|(
name|s_lab
operator|!=
name|e_lab
operator|)
operator|||
operator|(
name|s_code
operator|!=
name|e_code
operator|)
condition|)
name|dump_line
argument_list|()
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* move whole line to 'label' buffer */
block|{
name|int
name|in_comment
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|com_start
init|=
literal|0
decl_stmt|;
name|char
name|quote
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|com_end
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|!=
literal|'\n'
operator|||
name|in_comment
condition|)
block|{
operator|*
name|e_lab
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|e_lab
operator|++
condition|)
block|{
case|case
name|BACKSLASH
case|:
if|if
condition|(
name|troff
condition|)
operator|*
name|e_lab
operator|++
operator|=
name|BACKSLASH
expr_stmt|;
if|if
condition|(
operator|!
name|in_comment
condition|)
block|{
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
operator|!
name|in_comment
operator|&&
operator|!
name|quote
condition|)
block|{
name|in_comment
operator|=
literal|1
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|com_start
operator|=
name|e_lab
operator|-
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|quote
operator|==
literal|'"'
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|quote
operator|==
literal|'\''
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
operator|&&
name|in_comment
condition|)
block|{
name|in_comment
operator|=
literal|0
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|com_end
operator|=
name|e_lab
expr_stmt|;
block|}
break|break;
block|}
block|}
while|while
condition|(
name|e_lab
operator|>
name|s_lab
operator|&&
operator|(
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|e_lab
operator|--
expr_stmt|;
if|if
condition|(
name|e_lab
operator|==
name|com_end
operator|&&
name|bp_save
operator|==
literal|0
condition|)
block|{
comment|/* comment on 								 * preprocessor line */
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
comment|/* if this is the first 						 * comment, we must set up 						 * the buffer */
name|sc_end
operator|=
operator|&
operator|(
name|save_com
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
block|{
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* add newline between 						 * comments */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|com_start
argument_list|,
name|sc_end
argument_list|,
name|com_end
operator|-
name|com_start
argument_list|)
expr_stmt|;
name|sc_end
operator|+=
name|com_end
operator|-
name|com_start
expr_stmt|;
name|e_lab
operator|=
name|com_start
expr_stmt|;
while|while
condition|(
name|e_lab
operator|>
name|s_lab
operator|&&
operator|(
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|e_lab
operator|--
expr_stmt|;
name|bp_save
operator|=
name|buf_ptr
expr_stmt|;
comment|/* save current input 						 * buffer */
name|be_save
operator|=
name|buf_end
expr_stmt|;
name|buf_ptr
operator|=
name|save_com
expr_stmt|;
comment|/* fix so that subsequent 						 * calls to lexi will take 						 * tokens out of save_com */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add trailing blank, 						 * just in case */
name|buf_end
operator|=
name|sc_end
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|e_lab
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate line */
name|ps
operator|.
name|pcase
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s_lab
argument_list|,
literal|"#if"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ifdef_level
operator|<
sizeof|sizeof
name|state_stack
operator|/
sizeof|sizeof
name|state_stack
index|[
literal|0
index|]
condition|)
block|{
name|match_state
index|[
name|ifdef_level
index|]
operator|.
name|tos
operator|=
operator|-
literal|1
expr_stmt|;
name|state_stack
index|[
name|ifdef_level
operator|++
index|]
operator|=
name|ps
expr_stmt|;
block|}
else|else
name|diag
argument_list|(
literal|1
argument_list|,
literal|"#if stack overflow"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s_lab
argument_list|,
literal|"#else"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ifdef_level
operator|<=
literal|0
condition|)
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Unmatched #else"
argument_list|)
expr_stmt|;
else|else
block|{
name|match_state
index|[
name|ifdef_level
operator|-
literal|1
index|]
operator|=
name|ps
expr_stmt|;
name|ps
operator|=
name|state_stack
index|[
name|ifdef_level
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s_lab
argument_list|,
literal|"#endif"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ifdef_level
operator|<=
literal|0
condition|)
name|diag
argument_list|(
literal|1
argument_list|,
literal|"Unmatched #endif"
argument_list|)
expr_stmt|;
else|else
block|{
name|ifdef_level
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|undef
comment|/* 			 * This match needs to be more intelligent before 			 * the message is useful  			 */
if|if
condition|(
name|match_state
index|[
name|ifdef_level
index|]
operator|.
name|tos
operator|>=
literal|0
operator|&&
name|bcmp
argument_list|(
operator|&
name|ps
argument_list|,
operator|&
name|match_state
index|[
name|ifdef_level
index|]
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
condition|)
name|diag
argument_list|(
literal|0
argument_list|,
literal|"Syntactically inconsistant #ifdef alternatives."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
comment|/* subsequent processing of the newline 				 * character will cause the line to be 				 * printed */
case|case
name|comment
case|:
comment|/* we have gotten a /*  this is a biggie */
name|proc_comment
label|:
if|if
condition|(
name|flushed_nl
condition|)
block|{
comment|/* we should force a broken line 					 * here */
name|flushed_nl
operator|=
name|false
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* dont insert blank at 						 * line start */
name|force_nl
operator|=
name|false
expr_stmt|;
block|}
name|pr_comment
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* end of big switch stmt */
operator|*
name|e_code
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure code section is null 				 * terminated */
if|if
condition|(
name|type_code
operator|!=
name|comment
operator|&&
name|type_code
operator|!=
name|newline
operator|&&
name|type_code
operator|!=
name|preesc
condition|)
name|ps
operator|.
name|last_token
operator|=
name|type_code
expr_stmt|;
block|}
comment|/* end of main while (1) loop */
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * copy input file to backup file.  If in_name is /blah/blah/blah/file, then  * backup file will be "file.BAK".  Then make the backup file the input and  * original input file the output.  */
end_comment

begin_macro
name|bakcopy
argument_list|()
end_macro

begin_block
block|{
name|int
name|n
decl_stmt|,
name|bakchn
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|in_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|in_name
expr_stmt|;
name|sprintf
argument_list|(
name|bakfile
argument_list|,
literal|"%s.BAK"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* copy in_name to backup file */
name|bakchn
operator|=
name|creat
argument_list|(
name|bakfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|bakchn
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: can't create backup file \"%s\"\n"
argument_list|,
name|bakfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|input
argument_list|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|bakchn
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: error writing backup file \"%s\"\n"
argument_list|,
name|bakfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: error reading input file \"%s\"\n"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|bakchn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|/* re-open backup file as the input file */
name|input
operator|=
name|fopen
argument_list|(
name|bakfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: can't re-open backup file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* now the original input file will be the output */
name|output
operator|=
name|fopen
argument_list|(
name|in_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"indent: can't create %s\n"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|bakfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

