begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)io.c	4.1	(Berkeley)	10/21/82"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   FILE NAME: 	io.c  PURPOSE: 	Contains routines to handle i/o related stuff for indent.  GLOBALS: 	None  FUNCTIONS: 	dump_line 	fill_buffer 	pad_output 	count_spaces 	eqin 	cmp  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	dump_line  FUNCTION: 	Does the actual printing of the stored up line  ALGORITHM: 	For each of the label, code, and comment sections which are used on  	this line:  	1) Use pad_output to get the section aligned properly. 	2) write the section  	The indentation level used for the code is set by ind_level.  After 	printing, ind_level is set to i_l_follow.  	An extra level of indentation is added if ind_stmt is 1.  After  	printing, ind_stmt is set to 1 iff the line just printed has an 	unterminated, non-declaration statement.  PARAMETERS: 	None  RETURNS: 	Nothing  GLOBALS: 	labbuf 	s_lab 	e_lab =		Reset to s_lab  	codebuf 	s_code 	e_code =	Reset to s_code  	combuf 	s_com 	e_com =		Reset to s_com  	bl_line =	Set to true iff the line was blank 	case_ind 	code_lines =	Count lines with code 	com_col 	com_lines =	Keep track of lines with comments 	decl_on_line =	Set to in_decl after line is printed 	i_l_follow 	in_decl 	in_stmt 	ind_level =	Set to i_l_follow at completion 	ind_size 	ind_stmt =	Set to in_stmt at completion if not in declaration 	out_lines =	Count output lines 	p_l_follow 	paren_level =	Set to p_l_follow at completion 	pcase 	use_ff =	Reset to false  CALLS: 	pad_output 	printf (lib) 	write (lib)  CALLED BY: 	main 	pr_comment  HISTORY: 	initial coding 	November 1976	D A Willcox of CAC  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"indent_globs.h"
include|;
end_include

begin_decl_stmt
name|int
name|ff
init|=
literal|014
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to write a form feed */
end_comment

begin_macro
name|dump_line
argument_list|()
end_macro

begin_block
block|{
comment|/* dump_line is the routine that actually 			          effects the printing of the new source. 			          It prints the label section, followed by 			          the code section with the appropriate 			          nesting level, followed by any comments  			       */
specifier|register
name|int
name|cur_col
decl_stmt|,
name|temp_col
decl_stmt|,
name|target_col
decl_stmt|;
name|bl_line
operator|=
name|true
expr_stmt|;
comment|/* if we don't find otherwise, assume a 			          blank line */
if|if
condition|(
name|ind_level
operator|==
literal|0
condition|)
name|ind_stmt
operator|=
literal|0
expr_stmt|;
comment|/* this is a class A kludge. don't do 			          additional statement indentation if we 			          are at bracket level 0 */
if|if
condition|(
name|e_lab
operator|!=
name|s_lab
operator|||
name|e_code
operator|!=
name|s_code
condition|)
operator|++
name|code_lines
expr_stmt|;
comment|/* keep count of lines with code */
if|if
condition|(
name|e_lab
operator|!=
name|s_lab
condition|)
block|{
comment|/* print lab, if any */
if|if
condition|(
name|pcase
condition|)
comment|/* if the label is really a case, we must 			          indent */
name|cur_col
operator|=
name|pad_output
argument_list|(
literal|1
argument_list|,
name|case_ind
operator|*
name|ind_size
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|s_lab
operator|==
literal|'#'
condition|)
comment|/* check for #define, etc */
name|cur_col
operator|=
literal|1
expr_stmt|;
else|else
name|cur_col
operator|=
name|pad_output
argument_list|(
literal|1
argument_list|,
name|ind_size
operator|*
operator|(
name|ind_level
operator|-
name|label_offset
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|write
argument_list|(
name|output
argument_list|,
name|s_lab
argument_list|,
name|e_lab
operator|-
name|s_lab
argument_list|)
expr_stmt|;
name|cur_col
operator|=
name|count_spaces
argument_list|(
name|cur_col
argument_list|,
name|s_lab
argument_list|)
expr_stmt|;
comment|/* count_spaces gives number of characters, considering tabs */
name|bl_line
operator|=
name|false
expr_stmt|;
comment|/* line not blank after all */
block|}
else|else
name|cur_col
operator|=
literal|1
expr_stmt|;
comment|/* there is no label section */
name|pcase
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
condition|)
block|{
comment|/* print code section, if any */
name|target_col
operator|=
name|ind_size
operator|*
operator|(
name|ind_level
operator|+
name|paren_level
operator|+
name|ind_stmt
operator|)
operator|+
literal|1
expr_stmt|;
name|cur_col
operator|=
name|pad_output
argument_list|(
name|cur_col
argument_list|,
name|target_col
argument_list|)
expr_stmt|;
comment|/* pad_output writes enough tabs and spaces to get the current char        position up to target_col */
name|write
argument_list|(
name|output
argument_list|,
name|s_code
argument_list|,
name|e_code
operator|-
name|s_code
argument_list|)
expr_stmt|;
name|cur_col
operator|=
name|count_spaces
argument_list|(
name|cur_col
argument_list|,
name|s_code
argument_list|)
expr_stmt|;
name|bl_line
operator|=
name|false
expr_stmt|;
comment|/* line not blank */
block|}
if|if
condition|(
operator|(
name|cur_col
operator|-
literal|1
operator|)
operator|>
name|max_col
operator|&&
name|output
operator|!=
literal|1
condition|)
comment|/* check for line too long */
name|printf
argument_list|(
literal|"%d: Code has %d chars, max is %d\n"
argument_list|,
name|line_no
argument_list|,
operator|(
name|cur_col
operator|-
literal|1
operator|)
argument_list|,
name|max_col
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_com
operator|!=
name|e_com
condition|)
block|{
comment|/* print comment, if any */
if|if
condition|(
name|cur_col
operator|>
name|com_col
operator|&&
name|count_spaces
argument_list|(
name|cur_col
argument_list|,
name|s_com
argument_list|)
operator|>=
name|max_col
condition|)
block|{
comment|/* if comment can't fit on this line, put it on next line */
name|write
argument_list|(
name|output
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cur_col
operator|=
literal|1
expr_stmt|;
operator|++
name|out_lines
expr_stmt|;
block|}
name|cur_col
operator|=
name|pad_output
argument_list|(
name|cur_col
argument_list|,
name|com_col
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|output
argument_list|,
name|s_com
argument_list|,
name|e_com
operator|-
name|s_com
argument_list|)
expr_stmt|;
name|cur_col
operator|=
name|count_spaces
argument_list|(
name|cur_col
argument_list|,
name|s_com
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_col
operator|-
literal|1
operator|)
operator|>
name|max_col
operator|&&
name|output
operator|!=
literal|1
condition|)
comment|/* check for too long comment */
name|printf
argument_list|(
literal|"%d: Comment goes to column %d.  Max is %d\n"
argument_list|,
name|line_no
argument_list|,
operator|(
name|cur_col
operator|-
literal|1
operator|)
argument_list|,
name|max_col
argument_list|)
expr_stmt|;
name|bl_line
operator|=
name|false
expr_stmt|;
operator|++
name|com_lines
expr_stmt|;
comment|/* count lines with comments */
block|}
if|if
condition|(
name|use_ff
condition|)
name|write
argument_list|(
name|output
argument_list|,
operator|&
name|ff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* end the output with a ff */
else|else
name|write
argument_list|(
name|output
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* or a newline */
name|use_ff
operator|=
name|false
expr_stmt|;
operator|*
operator|(
name|e_lab
operator|=
name|s_lab
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* reset buffers */
operator|*
operator|(
name|e_code
operator|=
name|s_code
operator|)
operator|=
literal|'\0'
expr_stmt|;
operator|*
operator|(
name|e_com
operator|=
name|s_com
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|ind_level
operator|=
name|i_l_follow
expr_stmt|;
name|paren_level
operator|=
name|p_l_follow
expr_stmt|;
operator|++
name|out_lines
expr_stmt|;
name|decl_on_line
operator|=
name|in_decl
expr_stmt|;
comment|/* if we are in the middle of a 			          declaration, remember that fact for 			          proper comment indentation */
name|ind_stmt
operator|=
name|in_stmt
operator|&
operator|~
name|in_decl
expr_stmt|;
comment|/* next line should be indented if we have not completed this stmt and if     we are not in the middle of a declaration */
return|return;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	fill_buffer  FUNCTION: 	Reads one block of input into input_buffer  ALGORITHM: 	Trivial  PARAMETERS: 	None  RETURNS: 	Nothing  GLOBALS: 	in_buffer = 	buf_end =	Set to 1 past last character read in 	buf_ptr =	Set to start of buffer 	be_save =	Set to zero if it was non-zero 	bp_save =	Set to zero  CALLS: 	read (lib)  CALLED BY: 	lexi 	main 	pr_comment  HISTORY: 	initial coding 	November 1976	D A Willcox of CAC 	1/7/77		D A Willcox of CAC	Added check for switch back to 						partly full input buffer from 						temporary buffer   */
end_comment

begin_escape
end_escape

begin_function
name|int
name|fill_buffer
parameter_list|()
block|{
comment|/* this routine reads stuff from the input */
name|int
name|count
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp_save
operator|!=
literal|0
condition|)
block|{
comment|/* there is a partly filled input buffer 			          left */
name|buf_ptr
operator|=
name|bp_save
expr_stmt|;
comment|/* don't read anything, just switch buffers  			       */
name|buf_end
operator|=
name|be_save
expr_stmt|;
name|bp_save
operator|=
name|be_save
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|<
name|buf_end
condition|)
return|return;
comment|/* only return if there is really something 			          in this buffer */
block|}
name|count
operator|=
name|read
argument_list|(
name|input
argument_list|,
name|in_buffer
argument_list|,
name|inp_bufs
argument_list|)
expr_stmt|;
name|buf_end
operator|=
name|in_buffer
operator|+
name|count
expr_stmt|;
name|buf_ptr
operator|=
name|in_buffer
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* count of zero means eof */
name|had_eof
operator|=
name|true
expr_stmt|;
operator|*
name|buf_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|buf_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* insert extra newline.  it will 			          eventually get indent to stop */
block|}
return|return;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	pad_output  FUNCTION: 	Writes tabs and spaces to move the current column up to the 	desired position.  ALGORITHM: 	Put tabs and/or blanks into pobuf, then write pobuf.  PARAMETERS: 	current		integer		The current column 	target		integer		The desired column  RETURNS: 	Integer value of the new column.  (If current>= target, 	no action is taken, and current is returned.  GLOBALS: 	None  CALLS: 	write (sys)  CALLED BY: 	dump_line  HISTORY: 	initial coding 	November 1976	D A Willcox of CAC  */
end_comment

begin_escape
end_escape

begin_function
name|int
name|pad_output
parameter_list|(
name|current
parameter_list|,
name|target
parameter_list|)
comment|/* writes tabs and blanks (if necessary) to 			          get the current output position up to 			          the target column */
name|int
name|current
decl_stmt|;
comment|/* the current column value */
name|int
name|target
decl_stmt|;
comment|/* position we want it at */
block|{
specifier|register
name|int
name|curr
decl_stmt|;
comment|/* internal column pointer */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer into buffer of characters to be written */
name|char
name|pobuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* pad characters are stored here before writing */
specifier|register
name|int
name|tcur
decl_stmt|;
if|if
condition|(
name|current
operator|>=
name|target
condition|)
return|return
operator|(
name|current
operator|)
return|;
comment|/* line is already long enough */
name|curr
operator|=
name|current
expr_stmt|;
name|p
operator|=
name|pobuf
expr_stmt|;
while|while
condition|(
name|curr
operator|<
name|target
condition|)
block|{
if|if
condition|(
operator|(
name|tcur
operator|=
operator|(
operator|(
name|curr
operator|-
literal|1
operator|)
operator|&
name|tabmask
operator|)
operator|+
name|tabsize
operator|+
literal|1
operator|)
operator|<=
name|target
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
comment|/* put a tab into buffer */
name|curr
operator|=
name|tcur
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curr
operator|++
operator|<
name|target
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* pad with final blanks */
block|}
block|}
name|write
argument_list|(
name|output
argument_list|,
name|pobuf
argument_list|,
name|p
operator|-
name|pobuf
argument_list|)
expr_stmt|;
comment|/* write the characters we saved */
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	count_spaces  FUNCTION: 	Find out where printing of a given string will leave the current 	character position on output.  ALGORITHM: 	Run thru input string and add appropriate values to current position.  PARAMETERS: 	current		integer		  The current line character position 	buffer		ptr to character  Pointer to input string  RETURNS: 	Integer value of position after printing "buffer" starting in 	column "current".  GLOBALS: 	None  CALLS: 	None  CALLED BY: 	pr_comment  HISTORY: 	initial coding 	November 1976	D A Willcox of CAC  */
end_comment

begin_escape
end_escape

begin_function
name|int
name|count_spaces
parameter_list|(
name|current
parameter_list|,
name|buffer
parameter_list|)
comment|/* this routine figures out where the 			          character position will be after 			          printing the text in buffer starting at 			          column "current" */
name|int
name|current
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* used to look thru buffer */
specifier|register
name|int
name|cur
decl_stmt|;
comment|/* current character counter */
name|cur
operator|=
name|current
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|buffer
init|;
operator|*
name|buf
operator|!=
literal|'\0'
condition|;
operator|++
name|buf
control|)
block|{
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'\n'
case|:
case|case
literal|014
case|:
comment|/* form feed */
name|cur
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|cur
operator|=
operator|(
operator|(
name|cur
operator|-
literal|1
operator|)
operator|&
name|tabmask
operator|)
operator|+
name|tabsize
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'
literal|'
case|:
comment|/* this is a backspace */
operator|--
name|cur
expr_stmt|;
break|break;
default|default:
operator|++
name|cur
expr_stmt|;
break|break;
block|}
comment|/* end of switch */
block|}
comment|/* end of for loop */
return|return
operator|(
name|cur
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/*  			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved   NAME: 	eqin  FUNCTION: 	Returns true if the first arg matches the beginning of the second arg.  ALGORITHM: 	Trivial  PARAMETERS: 	str1	pointer to character 	str2	pointer to character  RETURNS: 	1 if first string matches start of second string 	0 otherwise  GLOBALS: 	None  CALLS: 	None  CALLED BY: 	lexi 	main  HISTORY: 	initial coding November 1976 by D A Willcox of CAC  */
end_comment

begin_escape
end_escape

begin_macro
name|eqin
argument_list|(
argument|str1
argument_list|,
argument|str2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
comment|/* local pointer into first string */
specifier|register
name|char
modifier|*
name|s2
decl_stmt|;
comment|/* local pointer into second string */
name|s1
operator|=
name|str1
expr_stmt|;
name|s2
operator|=
name|str2
expr_stmt|;
while|while
condition|(
operator|*
name|s1
condition|)
block|{
comment|/* compare no further than end of first 			          string */
if|if
condition|(
operator|*
name|s2
operator|==
literal|0
condition|)
comment|/* check that second string isn't too short  			       */
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|*
name|s1
operator|++
operator|!=
operator|*
name|s2
operator|++
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* 			  Copyright (C) 1976 				by the 			  Board of Trustees 				of the 			University of Illinois  			 All rights reserved  NAME: 	cmp  FUNCTION: 	Compares two strings  ALGORITHM: 	Trivial  PARAMETERS: 	a	Pointer to char		First string to compare 	b	Pointer to char		Second string to compare  RETURNS: 	-1 if a< b 	 0 if a = b 	 1 if a> b  GLOBALS: 	None  CALLS: 	None  CALLED BY: 	main  HISTORY: 	1/7/77		D A Willcox of CAC	Initial Coding */
end_comment

begin_escape
end_escape

begin_function
name|int
name|cmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ta
decl_stmt|,
modifier|*
name|tb
decl_stmt|;
name|ta
operator|=
name|a
expr_stmt|;
name|tb
operator|=
name|b
expr_stmt|;
while|while
condition|(
operator|*
name|ta
condition|)
block|{
if|if
condition|(
operator|*
name|ta
operator|>
operator|*
name|tb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|ta
operator|<
operator|*
name|tb
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|++
name|ta
expr_stmt|;
operator|++
name|tb
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tb
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

