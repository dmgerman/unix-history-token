begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: inits.c,v 1.5 83/09/12 14:17:34 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 12:59:39 1983 by jkf]-  * 	inits.c				$Locker:  $  * initialization routines  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* initial  * initializes the parts of the system that cannot be automatically  * accomplished in the declarations.  */
end_comment

begin_decl_stmt
name|int
name|reborn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  flag to tell whether we are in fast-load version  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|stabf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fvirgin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|keywait
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern sigstruck
operator|,
extern|sigdelay;
end_extern

begin_macro
name|initial
argument_list|()
end_macro

begin_block
block|{
name|int
name|sigalrmh
argument_list|()
decl_stmt|,
name|sigfpeh
argument_list|()
decl_stmt|,
name|siginth
argument_list|()
decl_stmt|;
name|lispval
name|Isstatus
argument_list|()
decl_stmt|,
name|Istsrch
argument_list|()
decl_stmt|;
specifier|extern
name|int
name|hashtop
decl_stmt|;
comment|/* clear any memory of pending SIGINT's */
name|exception
operator|=
name|FALSE
expr_stmt|;
name|sigintcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
comment|/* signals SIGBUS and SIGSEGV will be set up when the status list 	   is set up when the lisp is virgin, and will be set up according 	   to the current value on the status list if the lisp is reborn 	*/
ifdef|#
directive|ifdef
name|SPISFP
block|{
specifier|extern
name|long
modifier|*
name|exsp
decl_stmt|;
name|xsp
operator|=
name|exsp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reborn
condition|)
block|{
specifier|register
name|FILE
modifier|*
name|p
init|=
name|_iob
operator|+
literal|3
decl_stmt|;
specifier|static
name|FILE
name|empty
decl_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|_iob
operator|+
name|_NFILE
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|empty
expr_stmt|;
name|np
operator|=
name|lbot
operator|=
name|orgnp
expr_stmt|;
name|stabf
operator|=
literal|0
expr_stmt|;
name|fvirgin
operator|=
literal|1
expr_stmt|;
name|loading
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|gcrebear
argument_list|()
expr_stmt|;
comment|/* set up SIGBUS and SIGSEGV from current value  		   of status flag dumpcore 		*/
name|Isstatus
argument_list|(
name|matom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|,
operator|(
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"dumpcore"
argument_list|)
argument_list|)
operator|)
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
name|makenv
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|hashtop
condition|;
name|hash
operator|++
control|)
name|hasht
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
expr_stmt|;
name|sbrk
argument_list|(
name|LBPG
operator|-
operator|(
operator|(
operator|(
name|int
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|)
operator|%
name|LBPG
operator|)
argument_list|)
expr_stmt|;
comment|/* even up the break */
name|makevals
argument_list|()
expr_stmt|;
name|orgnp
operator|=
name|np
expr_stmt|;
name|makenv
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|makenv
argument_list|()
block|{
specifier|register
name|lispval
name|env
block|,
name|temp
block|;
specifier|register
name|char
operator|*
name|p
block|,
operator|*
name|q
block|;
name|char
operator|*
operator|*
name|envp
block|,
name|envstr
index|[
name|STRBLEN
index|]
block|;
specifier|extern
name|char
operator|*
operator|*
name|environ
block|;
name|lbot
operator|=
name|np
block|;
name|env
operator|=
name|nil
block|;
name|np
operator|++
operator|->
name|val
operator|=
name|env
block|;
for|for
control|(
name|envp
operator|=
name|environ
init|;
operator|*
name|envp
operator|!=
name|NULL
condition|;
name|envp
operator|++
control|)
empty_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|envp
operator|>=
name|environ
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|*
name|envp
operator|,
name|q
operator|=
name|envstr
init|;
operator|*
name|p
operator|!=
literal|'='
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|q
operator|<
name|envstr
operator|+
name|STRBLEN
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* at this point lbot->val==env, so it is protected 		   from gc */
name|lbot
operator|->
name|val
operator|=
name|temp
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
name|env
expr_stmt|;
name|env
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|env
operator|->
name|d
operator|.
name|car
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
name|matom
argument_list|(
name|envstr
argument_list|)
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|cdr
operator|=
name|matom
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|matom
argument_list|(
literal|"environment"
argument_list|)
operator|->
name|a
operator|.
name|clb
operator|=
name|env
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|np
operator|--
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  siginth
operator|(
name|signo
operator|)
block|{
name|re_enable
argument_list|(
name|signo
argument_list|,
name|siginth
argument_list|)
block|;
name|sigstruck
operator||=
operator|(
literal|1
operator|<<
name|signo
operator|)
block|;
comment|/* handle SIGINT differently since it is the only 	   asychronous interrupt we handle		*/
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
block|{
if|if
condition|(
operator|++
name|sigintcnt
operator|==
literal|1
condition|)
block|{
comment|/* if this is the first interrupt, we just set a flag 		  which will be checked in qfuncl and eval.  This will 		  allow us to handle these interrupts when we are 		  ready. 	       */
name|exception
operator|=
name|TRUE
expr_stmt|;
comment|/*putchar('A');*/
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sigstruck
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
return|return;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|sigintcnt
operator|==
literal|2
condition|)
block|{
comment|/* the setting of  exception was ignored, we better 		  make sure that all calls from compiled code 		  go through qlinker 		*/
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* this may take a while, dont allow ints*/
name|clrtt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*putchar('B');*/
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
comment|/* ok to interrupt again */
name|sigstruck
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|signo
operator|)
expr_stmt|;
return|return;
block|}
end_elseif

begin_else
else|else
block|{
comment|/*putchar('C');*/
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
unit|}  	sigcall
operator|(
name|signo
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} sigcall
operator|(
name|which
operator|)
specifier|register
name|which
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|lispval
name|Lfuncal
parameter_list|()
function_decl|;
name|Savestack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|==
name|SIGINT
condition|)
block|{
name|sigintcnt
operator|=
literal|0
expr_stmt|;
name|exception
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sigacts
index|[
name|which
index|]
operator|!=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
condition|)
block|{
name|pbuf
name|pb
decl_stmt|;
name|int
name|mustpop
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|errp
operator|&&
name|errp
operator|->
name|class
operator|==
name|F_TO_FORT
condition|)
block|{
name|np
operator|=
name|errp
operator|->
name|svnp
expr_stmt|;
name|mustpop
operator|=
literal|1
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_TO_LISP
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
block|}
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|val
operator|=
name|sigacts
index|[
name|which
index|]
expr_stmt|;
name|INRNP
expr_stmt|;
name|np
operator|->
name|val
operator|=
name|inewint
argument_list|(
operator|(
name|long
operator|)
name|which
argument_list|)
expr_stmt|;
name|INRNP
expr_stmt|;
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|rdrsdot
operator|,
name|rdrsdot
operator|=
name|rdrsdot2
operator|,
name|rdrsdot2
operator|=
name|temp
expr_stmt|;
comment|/*KLUDGE*/
block|}
name|Lfuncal
argument_list|()
expr_stmt|;
if|if
condition|(
name|mustpop
condition|)
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
block|{
name|lispval
name|temp
decl_stmt|;
name|temp
operator|=
name|rdrsdot
operator|,
name|rdrsdot
operator|=
name|rdrsdot2
operator|,
name|rdrsdot2
operator|=
name|temp
expr_stmt|;
comment|/*KLUDGE*/
block|}
block|}
name|sigstruck
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|which
operator|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|delayoff
argument_list|()
end_macro

begin_block
block|{
name|sigdelay
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sigstruck
condition|)
name|dosig
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|dosig
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|which
decl_stmt|;
if|if
condition|(
operator|!
name|sigdelay
condition|)
for|for
control|(
name|which
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|65536
condition|;
name|which
operator|++
operator|,
name|i
operator|<<=
literal|1
control|)
block|{
name|keywait
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sigstruck
operator|&
name|i
condition|)
name|sigcall
argument_list|(
name|which
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|badmemr
argument_list|(
argument|number
argument_list|)
end_macro

begin_block
block|{
name|signal
argument_list|(
name|number
argument_list|,
name|badmemr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Internal bad memory reference, you are advised to (reset)."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|mask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s)-1))
end_define

begin_expr_stmt
specifier|static
name|re_enable
argument_list|(
argument|signo
argument_list|,
argument|handler
argument_list|)
name|int
argument_list|(
operator|*
name|handler
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|#
directive|if
name|os_4_2
name|sigsetmask
argument_list|(
name|sigblock
argument_list|(
literal|0
argument_list|)
operator|&
operator|~
name|mask
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|signo
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

end_unit

