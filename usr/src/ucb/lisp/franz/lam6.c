begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: lam6.c,v 1.5 83/09/12 14:16:37 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sun Sep  4 08:56:19 1983 by jkf]-  * 	lam6.c				$Locker:  $  * lambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_function
name|FILE
modifier|*
name|mkstFI
parameter_list|(
name|base
parameter_list|,
name|count
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
name|char
name|flag
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|p
init|=
name|stderr
decl_stmt|;
comment|/* find free file descriptor */
for|for
control|(
init|;
operator|(
name|p
operator|<
operator|&
name|_iob
index|[
name|_NFILE
index|]
operator|)
operator|&&
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOREAD
operator||
name|_IOWRT
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|>=
operator|&
name|_iob
index|[
name|_NFILE
index|]
condition|)
name|error
argument_list|(
literal|"Too many open files to do readlist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|->
name|_flag
operator|=
name|_IOSTRG
operator||
name|flag
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
name|count
expr_stmt|;
name|p
operator|->
name|_base
operator|=
name|base
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
name|base
expr_stmt|;
name|p
operator|->
name|_file
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lreadli
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|,
name|handy
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
name|lispval
name|Lread
parameter_list|()
function_decl|;
name|int
name|count
decl_stmt|;
name|pbuf
name|pb
decl_stmt|;
ifdef|#
directive|ifdef
name|SPISFP
name|Keepxs
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
block|{
comment|/*effectively, return(matom(""));*/
name|strbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|(
name|FALSE
argument_list|)
operator|)
return|;
block|}
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"readlist"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
comment|/* compute length of list */
for|for
control|(
name|work
operator|=
name|lbot
operator|->
name|val
init|;
name|TYPE
argument_list|(
name|work
argument_list|)
operator|==
name|DTPR
condition|;
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|cdr
control|)
name|count
operator|++
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|p
operator|=
name|mkstFI
argument_list|(
name|string
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|_IOREAD
argument_list|)
expr_stmt|;
for|for
control|(
name|work
operator|=
name|lbot
operator|->
name|val
init|;
name|TYPE
argument_list|(
name|work
argument_list|)
operator|==
name|DTPR
condition|;
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|handy
operator|=
name|work
operator|->
name|d
operator|.
name|car
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|SDOT
case|:
case|case
name|INT
case|:
operator|*
name|string
operator|++
operator|=
name|handy
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|ATOM
case|:
operator|*
name|string
operator|++
operator|=
operator|*
operator|(
name|handy
operator|->
name|a
operator|.
name|pname
operator|)
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
operator|*
name|string
operator|++
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|handy
expr_stmt|;
break|break;
default|default:
name|frstFI
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Non atom or int to readlist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|string
operator|=
literal|0
expr_stmt|;
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_CATCH
argument_list|,
name|Veruwpt
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* must unwind protect 						   so can deallocate p 						 */
switch|switch
condition|(
name|retval
condition|)
block|{
name|lispval
name|Lctcherr
parameter_list|()
function_decl|;
case|case
name|C_THROW
case|:
comment|/* an error has occured and we are given a chance 			   to unwind before the control goes higher 			   lispretval contains the error descriptor in 			   it's cdr 			 */
name|frstFI
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* free port */
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Freexs
argument_list|()
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|lispretval
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
comment|/* error descriptor */
return|return
operator|(
name|Lctcherr
argument_list|()
operator|)
return|;
comment|/* do a I-do-throw */
case|case
name|C_INITIAL
case|:
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|=
name|Lread
argument_list|()
expr_stmt|;
comment|/* error  could occur here */
name|Freexs
argument_list|()
expr_stmt|;
name|frstFI
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* whew.. no errors */
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
comment|/* remove unwind-protect */
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_expr_stmt
name|frstFI
argument_list|(
name|p
argument_list|)
specifier|register
name|FILE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|p
operator|->
name|_flag
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_base
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|_file
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|lispval
name|Lgetenv
parameter_list|()
block|{
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
name|char
modifier|*
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"getenv"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"argument to getenv must be atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|res
operator|=
name|getenv
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|a
operator|.
name|pname
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|strcpy
argument_list|(
name|strbuf
argument_list|,
name|res
argument_list|)
expr_stmt|;
else|else
name|strbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|(
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lboundp
parameter_list|()
block|{
specifier|register
name|lispval
name|result
decl_stmt|,
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"boundp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"argument to boundp must be symbol"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|handy
operator|=
name|lbot
operator|->
name|val
operator|)
operator|->
name|a
operator|.
name|clb
operator|==
name|CNIL
condition|)
name|result
operator|=
name|nil
expr_stmt|;
else|else
operator|(
name|result
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|cdr
operator|=
name|handy
operator|->
name|a
operator|.
name|clb
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lplist
parameter_list|()
block|{
specifier|register
name|lispval
name|atm
decl_stmt|;
comment|/* get property list of an atom or disembodied property list */
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"plist"
argument_list|)
expr_stmt|;
name|atm
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|atm
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
case|case
name|DTPR
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"Only Atoms and disembodied property lists allowed for plist"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atm
operator|==
name|nil
condition|)
return|return
operator|(
name|nilplist
operator|)
return|;
return|return
operator|(
name|atm
operator|->
name|a
operator|.
name|plist
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsetpli
parameter_list|()
block|{
comment|/* set the property list of the given atom to the given list */
specifier|register
name|lispval
name|atm
decl_stmt|,
name|vall
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"setplist"
argument_list|)
expr_stmt|;
name|atm
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|atm
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"setplist: First argument must be an symbol"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|vall
operator|=
operator|(
name|np
operator|-
literal|1
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|vall
argument_list|)
operator|!=
name|DTPR
operator|&&
name|vall
operator|!=
name|nil
condition|)
name|error
argument_list|(
literal|"setplist: Second argument must be a list"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm
operator|==
name|nil
condition|)
name|nilplist
operator|=
name|vall
expr_stmt|;
else|else
name|atm
operator|->
name|a
operator|.
name|plist
operator|=
name|vall
expr_stmt|;
return|return
operator|(
name|vall
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsignal
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|old
decl_stmt|,
name|routine
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|siginth
parameter_list|()
function_decl|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|1
case|:
name|routine
operator|=
name|nil
expr_stmt|;
comment|/* second arg defaults to nil */
break|break;
case|case
literal|2
case|:
name|routine
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
break|break;
comment|/* both args given 		*/
default|default:
name|argerr
argument_list|(
literal|"signal"
argument_list|)
expr_stmt|;
block|}
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"First arg to signal must be an int"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|i
operator|=
name|handy
operator|->
name|i
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|routine
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"Second arg to signal must be an atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|old
operator|=
name|sigacts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
condition|)
name|old
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|routine
operator|==
name|nil
condition|)
name|sigacts
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|lispval
operator|)
literal|0
operator|)
expr_stmt|;
else|else
name|sigacts
index|[
name|i
index|]
operator|=
name|routine
expr_stmt|;
if|if
condition|(
name|routine
operator|==
name|nil
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* ignore this signals */
elseif|else
if|if
condition|(
name|old
operator|==
name|nil
condition|)
name|signal
argument_list|(
name|i
argument_list|,
name|siginth
argument_list|)
expr_stmt|;
comment|/* look for this signal */
if|if
condition|(
name|i
operator|==
name|SIGINT
condition|)
name|sigintcnt
operator|=
literal|0
expr_stmt|;
comment|/* clear memory */
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lassq
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|,
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"assq"
argument_list|)
expr_stmt|;
for|for
control|(
name|work
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|,
name|handy
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
init|;
operator|(
name|work
operator|->
name|d
operator|.
name|car
operator|->
name|d
operator|.
name|car
operator|!=
name|handy
operator|)
operator|&&
operator|(
name|work
operator|!=
name|nil
operator|)
condition|;
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|cdr
control|)
empty_stmt|;
return|return
operator|(
name|work
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lkilcopy
parameter_list|()
block|{
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|lispval
name|Larg
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|offset
operator|,
name|count
expr_stmt|;
name|handy
operator|=
name|lexpr_atom
operator|->
name|a
operator|.
name|clb
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|CNIL
operator|||
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"Arg: not in context of Lexpr."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
operator|-
literal|1
operator|-
operator|(
name|long
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|lbot
operator|||
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|count
operator|+
literal|1
argument_list|)
operator|)
return|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|||
operator|(
name|offset
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
operator|-
literal|1
operator|)
operator|>
name|count
operator|||
name|offset
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Out of bounds: arg to \"Arg\""
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
expr|struct
name|argent
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|car
operator|)
index|[
name|offset
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsetarg
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|work
decl_stmt|;
specifier|register
name|limit
operator|,
name|index
expr_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"setarg"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lexpr_atom
operator|->
name|a
operator|.
name|clb
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|CNIL
operator|||
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"Arg: not in context of Lexpr."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
operator|-
literal|1
operator|-
operator|(
name|long
operator|*
operator|)
operator|(
name|work
operator|=
name|handy
operator|->
name|d
operator|.
name|car
operator|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"setarg: first argument not integer"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|=
name|handy
operator|->
name|i
operator|-
literal|1
operator|)
operator|<
literal|0
operator|||
name|index
operator|>
name|limit
condition|)
name|error
argument_list|(
literal|"setarg: index out of range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
expr|struct
name|argent
operator|*
operator|)
name|work
operator|)
index|[
name|index
index|]
operator|.
name|val
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lptime
parameter_list|()
block|{
specifier|extern
name|int
name|gctime
decl_stmt|;
name|int
name|lgctime
init|=
name|gctime
decl_stmt|;
name|struct
name|tms
name|current
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|,
name|handy
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|times
argument_list|(
operator|&
name|current
argument_list|)
expr_stmt|;
name|result
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|result
expr_stmt|;
name|protect
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|result
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|current
operator|.
name|tms_utime
argument_list|)
expr_stmt|;
name|handy
operator|=
name|result
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|lgctime
argument_list|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|gctime
operator|==
literal|0
condition|)
name|gctime
operator|=
literal|1
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (err-with-message message [value])    'message' is the error message to print.    'value' is the value to return from the errset (if present). 	it defaults to nil.     The message may not be printed if there is an (errset ... nil)     pending.  */
end_comment

begin_function
name|lispval
name|Lerr
parameter_list|()
block|{
name|lispval
name|errorh
parameter_list|()
function_decl|;
name|lispval
name|valret
init|=
name|nil
decl_stmt|;
name|char
modifier|*
name|mesg
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|valret
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
comment|/* return non nil */
case|case
literal|1
case|:
name|mesg
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"err-with-message: non atom or string arg"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|argerr
argument_list|(
literal|"err-with-message"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|errorh
argument_list|(
name|Vererr
argument_list|,
name|mesg
argument_list|,
name|valret
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  (tyi ['p_port ['g_eofval]])  * normally -1 is return on eof, but g_eofval will be returned if given.  */
end_comment

begin_function
name|lispval
name|Ltyi
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
name|eofval
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* really char but getc returns int on eof */
name|int
name|eofvalgiven
decl_stmt|;
name|handy
operator|=
name|nil
expr_stmt|;
comment|/* default port */
name|eofvalgiven
operator|=
name|FALSE
expr_stmt|;
comment|/* assume no eof value given */
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|eofval
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|eofvalgiven
operator|=
name|TRUE
expr_stmt|;
case|case
literal|1
case|:
name|handy
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
expr_stmt|;
comment|/* port to read */
case|case
literal|0
case|:
break|break;
default|default:
name|argerr
argument_list|(
literal|"tyi"
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpiport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush any pending output characters */
name|val
operator|=
name|getc
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|EOF
condition|)
block|{
name|clearerr
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigintcnt
operator|>
literal|0
condition|)
name|sigcall
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
comment|/* eof might mean int */
if|if
condition|(
name|eofvalgiven
condition|)
return|return
operator|(
name|eofval
operator|)
return|;
else|else
return|return
operator|(
name|inewint
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Untyi (added by DNC Feb. '80) - (untyi number port) puts the    character with ascii code number in the front of the input buffer of    port.  Note that this buffer is limited to 1 character.  That buffer is    also written by tyipeek, so a peek followed by an untyi will result in    the loss of the peeked char.  */
end_comment

begin_function
name|lispval
name|Luntyi
parameter_list|()
block|{
name|lispval
name|port
decl_stmt|,
name|ch
decl_stmt|;
name|port
operator|=
name|nil
expr_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|port
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
case|case
literal|1
case|:
name|ch
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
expr_stmt|;
break|break;
default|default:
name|argerr
argument_list|(
literal|"untyi"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE
argument_list|(
name|ch
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"untyi: expects fixnum character "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|ch
operator|->
name|i
argument_list|,
name|okport
argument_list|(
name|port
argument_list|,
name|okport
argument_list|(
name|Vpiport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdin
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltyipeek
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|0
case|:
name|handy
operator|=
name|nil
expr_stmt|;
comment|/* default port */
break|break;
case|case
literal|1
case|:
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
break|break;
default|default:
name|argerr
argument_list|(
literal|"tyipeek"
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpiport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush any pending output characters */
name|val
operator|=
name|getc
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|EOF
condition|)
name|clearerr
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|val
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltyo
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|,
name|where
decl_stmt|;
name|char
name|val
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|1
case|:
name|where
operator|=
name|nil
expr_stmt|;
comment|/* default port */
break|break;
case|case
literal|2
case|:
name|where
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
break|break;
default|default:
name|argerr
argument_list|(
literal|"tyo"
argument_list|)
expr_stmt|;
block|}
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"Tyo demands number for 1st arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|val
operator|=
name|handy
operator|->
name|i
expr_stmt|;
name|port
operator|=
operator|(
name|FILE
operator|*
operator|)
name|okport
argument_list|(
name|where
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|val
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Imkrtab
parameter_list|(
name|current
parameter_list|)
block|{
specifier|extern
struct|struct
name|rtab
block|{
name|unsigned
name|char
name|ctable
index|[
literal|132
index|]
decl_stmt|;
block|}
name|initread
struct|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|extern
name|lispval
name|lastrtab
decl_stmt|;
specifier|static
name|int
name|cycle
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|nextfree
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cycle
operator|++
operator|)
operator|%
literal|3
operator|==
literal|0
condition|)
block|{
name|nextfree
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|STRNG
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mrtabspace
operator|=
operator|(
name|lispval
operator|)
name|nextfree
expr_stmt|;
comment|/* need to protect partially allocated read tables 		   from garbage collection. */
block|}
name|handy
operator|=
name|newarray
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|handy
operator|->
name|ar
operator|.
name|data
operator|=
name|nextfree
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
operator|*
operator|(
expr|struct
name|rtab
operator|*
operator|)
name|nextfree
operator|=
name|initread
expr_stmt|;
else|else
block|{
specifier|register
name|index
operator|=
literal|0
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|nextfree
decl_stmt|;
name|lispval
name|c
decl_stmt|;
operator|*
operator|(
expr|struct
name|rtab
operator|*
operator|)
name|cp
operator|=
operator|*
operator|(
expr|struct
name|rtab
operator|*
operator|)
name|ctable
expr_stmt|;
for|for
control|(
init|;
name|index
operator|<
literal|128
condition|;
name|index
operator|++
control|)
block|{
switch|switch
condition|(
name|synclass
argument_list|(
name|cp
index|[
name|index
index|]
argument_list|)
condition|)
block|{
case|case
name|CSPL
case|:
case|case
name|CSSPL
case|:
case|case
name|CMAC
case|:
case|case
name|CSMAC
case|:
case|case
name|CINF
case|:
case|case
name|CSINF
case|:
name|strbuf
index|[
literal|0
index|]
operator|=
name|index
expr_stmt|;
name|strbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
expr_stmt|;
name|Iputprop
argument_list|(
name|c
argument_list|,
name|Iget
argument_list|(
name|c
argument_list|,
name|lastrtab
argument_list|)
argument_list|,
name|handy
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|handy
operator|->
name|ar
operator|.
name|delta
operator|=
name|inewint
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|handy
operator|->
name|ar
operator|.
name|length
operator|=
name|inewint
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|handy
operator|->
name|ar
operator|.
name|accfun
operator|=
name|handy
operator|->
name|ar
operator|.
name|aux
operator|=
name|nil
expr_stmt|;
name|nextfree
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|rtab
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* makereadtable - arg : t or nil 	returns a readtable, t means return a copy of the initial readtable  			     nil means return a copy of the current readtable */
end_comment

begin_function
name|lispval
name|Lmakertbl
parameter_list|()
block|{
name|lispval
name|handy
init|=
name|Vreadtable
operator|->
name|a
operator|.
name|clb
decl_stmt|;
name|lispval
name|value
decl_stmt|;
name|chkrtab
argument_list|(
name|handy
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|value
operator|=
name|nil
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE
argument_list|(
name|value
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
argument_list|)
operator|!=
name|ATOM
condition|)
name|error
argument_list|(
literal|"makereadtable: arg must be atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|nil
condition|)
return|return
operator|(
name|Imkrtab
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|Imkrtab
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcpy1
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
init|=
name|lbot
operator|->
name|val
decl_stmt|,
name|result
init|=
name|handy
decl_stmt|;
name|top
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|result
operator|=
name|inewint
argument_list|(
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUE
case|:
operator|(
name|result
operator|=
name|newval
argument_list|()
operator|)
operator|->
name|l
operator|=
name|handy
operator|->
name|l
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|handy
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|lbot
operator|->
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad arg to cpy1"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|67
argument_list|,
name|handy
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copyint* . This returns a copy of its integer argument.  The copy will  *	 be a fresh integer cell, and will not point into the read only  *	 small integer table.  */
end_comment

begin_function
name|lispval
name|Lcopyint
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
init|=
name|lbot
operator|->
name|val
decl_stmt|;
specifier|register
name|lispval
name|ret
decl_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|handy
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"copyint* : non integer arg"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|handy
argument_list|)
expr_stmt|;
block|}
operator|(
name|ret
operator|=
name|newint
argument_list|()
operator|)
operator|->
name|i
operator|=
name|handy
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

