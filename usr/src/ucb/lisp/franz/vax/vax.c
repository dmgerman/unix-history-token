begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: vax.c,v 1.4 83/09/12 14:06:22 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Mon Mar 21 19:35:50 1983 by jkf]-  * 	vax.c				$Locker:  $  * vax specific functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"vaxframe.h"
end_include

begin_comment
comment|/* exarith(a,b,c,lo,hi)  * int a,b,c;  * int *lo, *hi;  * Exact arithmetic.  * a,b and c are 32 bit 2's complement integers  * calculates x=a*b+c to twice the precision of an int.  * In the vax version, the 30 low bits only are returned  * in *lo,and the next 32 bits of precision are returned in * hi.  * this works since exarith is used either for calculating the sum of  * two 32 bit numbers, (which is at most 33 bits), or  * multiplying a 30 bit number by a 32 bit numbers,  * which has a maximum precision of 62 bits.  * If *phi is 0 or -1 then  * x doesn't need any more than 31 bits plus sign to describe, so we  * place the sign in the high two bits of *lo and return 0 from this  * routine.  A non zero return indicates that x requires more than 31 bits  * to describe.  */
end_comment

begin_macro
name|exarith
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|phi
argument_list|,
argument|plo
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|phi
decl_stmt|,
modifier|*
name|plo
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("	emul	4(ap),8(ap),12(ap),r2	#r2 = a*b + c to 64 bits");
asm|asm("	extzv	$0,$30,r2,*20(ap)	#get new lo");
asm|asm("	extv	$30,$32,r2,r0		#get new carry");
asm|asm("	beql	out			# hi = 0, no work necessary");
asm|asm("	movl	r0,*16(ap)		# save hi");
asm|asm("	mcoml	r0,r0			# Is hi = -1 (it'll fit in one word)");
asm|asm("	bneq	out			# it doesn't");
asm|asm("	bisl2	$0xc0000000,*20(ap)	# alter low so that it is ok.");
asm|asm("out:	ret");
block|}
end_block

begin_macro
name|mmuladd
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm ("emul	4(ap),8(ap),12(ap),r0");
asm|asm ("ediv	16(ap),r0,r2,r0");
block|}
end_block

begin_macro
name|Imuldiv
argument_list|()
end_macro

begin_block
block|{
asm|asm("	emul	4(ap),8(ap),12(ap),r0");
asm|asm("	ediv	16(ap),r0,*20(ap),*24(ap)");
block|}
end_block

begin_macro
name|callg_
argument_list|(
argument|funct
argument_list|,
argument|arglist
argument_list|)
end_macro

begin_function_decl
name|lispval
function_decl|(
modifier|*
name|funct
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("	callg	*8(ap),*4(ap)");
block|}
end_block

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|WRITE
value|4
end_define

begin_define
define|#
directive|define
name|READ
value|3
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|os_vms
end_ifdef

begin_define
define|#
directive|define
name|_read
value|_$real_read
end_define

begin_define
define|#
directive|define
name|_write
value|_$real_write
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_read
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|syscall(READ,a,b,c)
end_define

begin_define
define|#
directive|define
name|_write
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|syscall(WRITE,a,b,c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*C library -- write   nwritten = write(file, buffer, count);   nwritten == -1 means error */
end_comment

begin_macro
name|write
argument_list|(
argument|file
argument_list|,
argument|buffer
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|!=
literal|1
operator|)
operator|||
operator|(
name|Vcntlw
operator|->
name|a
operator|.
name|clb
operator|==
name|nil
operator|)
condition|)
goto|goto
name|top
goto|;
comment|/* since ^w is non nil, we do not want to print to the terminal, 	   but we must be sure to return a correct value from the write 	   in case there is no write to ptport 	*/
name|retval
operator|=
name|count
expr_stmt|;
goto|goto
name|skipit
goto|;
name|top
label|:
name|retval
operator|=
name|_write
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|skipit
label|:
if|if
condition|(
name|file
operator|==
literal|1
condition|)
block|{
name|handy
operator|=
name|Vptport
operator|->
name|a
operator|.
name|clb
expr_stmt|;
if|if
condition|(
name|handy
operator|!=
name|nil
operator|&&
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|PORT
operator|&&
name|handy
operator|->
name|p
operator|->
name|_file
operator|!=
literal|1
condition|)
block|{
name|fflush
argument_list|(
name|handy
operator|->
name|p
argument_list|)
expr_stmt|;
name|file
operator|=
name|handy
operator|->
name|p
operator|->
name|_file
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  *nread = read(file, buffer, count);  *nread ==0 means eof; nread == -1 means error  *  */
end_comment

begin_macro
name|read
argument_list|(
argument|file
argument_list|,
argument|buffer
argument_list|,
argument|count
argument_list|)
end_macro

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|register
name|int
name|Size
decl_stmt|;
name|again
label|:
name|Size
operator|=
name|_read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Size
operator|>=
literal|0
operator|)
operator|||
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
return|return
operator|(
name|Size
operator|)
return|;
if|if
condition|(
name|sigintcnt
operator|>
literal|0
condition|)
name|sigcall
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_function
name|lispval
name|Lpolyev
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|double
modifier|*
name|handy
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
name|Keepxs
argument_list|()
expr_stmt|;
name|count
operator|=
literal|2
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|-
operator|(
name|int
operator|)
name|lbot
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|8
condition|)
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
name|base
operator|=
name|handy
operator|=
operator|(
name|double
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|type
operator|=
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|DOUB
operator|&&
name|type
operator|!=
name|INT
condition|)
name|argp
operator|->
name|val
operator|=
operator|(
name|lispval
operator|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"%%machine-polyev:non-real arg"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|73
argument_list|,
name|lbot
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
block|}
else|else
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|r
expr_stmt|;
block|}
name|count
operator|=
name|count
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|2
expr_stmt|;
asm|asm("polyd	(r9),r11,8(r9)");
asm|asm("movd	r0,(r9)");
name|result
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|result
operator|->
name|r
operator|=
operator|*
name|base
expr_stmt|;
name|Freexs
argument_list|()
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrot
parameter_list|()
block|{
specifier|register
name|rot
operator|,
name|val
expr_stmt|;
comment|/* these must be the first registers */
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"rot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"Non ints to rot"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|mylbot
operator|->
name|val
argument_list|,
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|mylbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|rot
operator|%
literal|32
expr_stmt|;
comment|/* bring it down below one byte in size */
asm|asm(" rotl r11,r10,r10 ");
comment|/* rotate val by rot and put back in val */
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* new version of showstack, 	We will set fp to point where the register fp points. 	Then fp+2 = saved ap 	     fp+4 = saved pc 	     fp+3 = saved fp 	     ap+1 = first arg 	If we find that the saved pc is somewhere in the routine eval,    then we print the first argument to that eval frame. This is done    by looking one beyond the saved ap. */
end_comment

begin_function
name|lispval
name|Lshostk
parameter_list|()
block|{
name|lispval
name|isho
parameter_list|()
function_decl|;
return|return
operator|(
name|isho
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lispval
name|isho
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* this must be the first local */
name|int
name|virgin
init|=
literal|1
decl_stmt|;
name|lispval
name|linterp
parameter_list|()
function_decl|;
name|lispval
name|_qfuncl
argument_list|()
decl_stmt|,
name|tynames
argument_list|()
decl_stmt|;
comment|/* locations in qfuncl */
specifier|extern
name|int
name|plevel
decl_stmt|,
name|plength
decl_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plevel
operator|=
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plevel
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlength
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plength
operator|=
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plength
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Forms in evaluation:\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Backtrace:\n\n"
argument_list|)
expr_stmt|;
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* point to current frame */
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|myfp
operator|->
name|pc
operator|>
name|eval
operator|&&
comment|/* interpreted code */
name|myfp
operator|->
name|pc
operator|<
name|popnames
operator|)
operator|||
operator|(
name|myfp
operator|->
name|pc
operator|>
name|Lfuncal
operator|&&
comment|/* compiled code */
name|myfp
operator|->
name|pc
operator|<
name|linterp
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|myfp
operator|->
name|ap
index|[
literal|0
index|]
operator|)
operator|==
literal|1
condition|)
comment|/* only if arg given */
block|{
name|handy
operator|=
operator|(
name|myfp
operator|->
name|ap
index|[
literal|1
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|1
condition|)
name|printr
argument_list|(
name|handy
argument_list|,
name|stdout
argument_list|)
operator|,
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|virgin
condition|)
name|virgin
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" -- "
argument_list|)
expr_stmt|;
name|printr
argument_list|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|?
name|handy
operator|->
name|d
operator|.
name|car
else|:
name|handy
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
break|break;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  *	(baktrace)  *  * baktrace will print the names of all functions being evaluated  * from the current one (baktrace) down to the first one.  * currently it only prints the function name.  Planned is a  * list of local variables in all stack frames.  * written by jkf.  *  */
end_comment

begin_function
name|lispval
name|Lbaktrace
parameter_list|()
block|{
name|isho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * (int:showstack 'stack_pointer)  * return  *   nil if at the end of the stack or illegal  *   ( expresssion . next_stack_pointer) otherwise  *   where expression is something passed to eval  * very vax specific  */
end_comment

begin_function
name|lispval
name|LIshowstack
parameter_list|()
block|{
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* must be the first local variable */
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
name|lispval
name|retval
decl_stmt|,
name|Lfuncal
argument_list|()
decl_stmt|,
name|Ifuncal
argument_list|()
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"int:showstack"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|&&
operator|(
name|handy
operator|!=
name|nil
operator|)
condition|)
name|error
argument_list|(
literal|"int:showstack non fixnum arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|handy
operator|->
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|*
operator|*
operator|*
operator|)
name|myfp
operator|<=
operator|&
name|fp
condition|)
name|error
argument_list|(
literal|"int:showstack illegal stack value"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|myfp
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|myfp
operator|->
name|pc
operator|>
name|eval
operator|&&
comment|/* interpreted code */
name|myfp
operator|->
name|pc
operator|<
name|popnames
operator|)
operator|||
operator|(
name|myfp
operator|->
name|pc
operator|>
name|Ifuncal
operator|&&
comment|/* compiled code */
name|myfp
operator|->
name|pc
operator|<
name|Lfuncal
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|myfp
operator|->
name|ap
index|[
literal|0
index|]
operator|)
operator|==
literal|1
condition|)
comment|/* only if arg given */
block|{
name|handy
operator|=
call|(
name|lispval
call|)
argument_list|(
name|myfp
operator|->
name|ap
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* arg to eval */
name|protect
argument_list|(
name|retval
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|->
name|d
operator|.
name|car
operator|=
name|handy
expr_stmt|;
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
name|myfp
operator|=
literal|0
expr_stmt|;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
name|retval
operator|->
name|d
operator|.
name|cdr
operator|=
name|inewint
argument_list|(
name|myfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
name|myfp
operator|=
literal|0
expr_stmt|;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPISFP
end_ifdef

begin_function
name|char
modifier|*
name|alloca
parameter_list|(
name|howmuch
parameter_list|)
specifier|register
name|int
name|howmuch
decl_stmt|;
block|{
name|howmuch
operator|+=
literal|3
expr_stmt|;
name|howmuch
operator|>>=
literal|2
expr_stmt|;
name|xsp
operator|-=
name|howmuch
if|if
condition|(
name|xsp
operator|<
name|xstack
condition|)
block|{
name|xsp
operator|+=
name|howmuch
expr_stmt|;
name|xserr
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|xsp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

