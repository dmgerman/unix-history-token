begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: lam8.c,v 1.16 85/03/24 11:04:31 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Thu Sep 29 22:24:10 1983 by jkf]-  * 	lam8.c				$Locker:  $  * lambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* various functions from the c math library */
end_comment

begin_decl_stmt
name|double
name|sin
argument_list|()
decl_stmt|,
name|cos
argument_list|()
decl_stmt|,
name|asin
argument_list|()
decl_stmt|,
name|acos
argument_list|()
decl_stmt|,
name|atan2
argument_list|()
decl_stmt|,
name|sqrt
argument_list|()
decl_stmt|,
name|log
argument_list|()
decl_stmt|,
name|exp
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current
decl_stmt|;
end_decl_stmt

begin_function_decl
name|lispval
name|Imath
function_decl|(
name|func
function_decl|)
name|double
argument_list|(
argument|*func
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|double
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"Math functions"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
operator|=
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|res
operator|=
name|func
argument_list|(
operator|(
name|double
operator|)
name|handy
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|res
operator|=
name|func
argument_list|(
name|handy
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum to math function"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|handy
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|handy
operator|->
name|r
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Lsin
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|sin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcos
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|cos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lasin
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|asin
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lacos
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|acos
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsqrt
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|sqrt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lexp
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|exp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llog
parameter_list|()
block|{
return|return
operator|(
name|Imath
argument_list|(
name|log
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* although we call this atan, it is really atan2 to the c-world,    that is, it takes two args  */
end_comment

begin_function
name|lispval
name|Latan
parameter_list|()
block|{
specifier|register
name|lispval
name|arg
decl_stmt|;
specifier|register
name|double
name|arg1v
decl_stmt|;
specifier|register
name|double
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"arctan"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|arg
operator|=
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|arg1v
operator|=
operator|(
name|double
operator|)
name|arg
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|arg1v
operator|=
name|arg
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum arg to atan2"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|TYPE
argument_list|(
name|arg
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|res
operator|=
name|atan2
argument_list|(
name|arg1v
argument_list|,
operator|(
name|double
operator|)
name|arg
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|res
operator|=
name|atan2
argument_list|(
name|arg1v
argument_list|,
name|arg
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Non fixnum or flonum to atan2"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|arg
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|arg
operator|->
name|r
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|arg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (random) returns a fixnum in the range -2**30 to 2**30 -1    (random fixnum) returns a fixnum in the range 0 to fixnum-1  */
end_comment

begin_function
name|lispval
name|Lrandom
parameter_list|()
block|{
specifier|register
name|int
name|curval
decl_stmt|;
name|float
name|pow
parameter_list|()
function_decl|;
name|curval
operator|=
name|rand
argument_list|()
expr_stmt|;
comment|/* get numb from 0 to 2**31-1 */
if|if
condition|(
name|np
operator|==
name|lbot
condition|)
return|return
operator|(
name|inewint
argument_list|(
name|curval
operator|-
operator|(
name|int
operator|)
name|pow
argument_list|(
operator|(
name|double
operator|)
literal|2
argument_list|,
operator|(
name|double
operator|)
literal|30
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<=
literal|0
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"random: non fixnum arg:"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|curval
operator|%
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lmakunb
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"makunbound"
argument_list|)
expr_stmt|;
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|nil
operator|||
operator|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|!=
name|ATOM
operator|)
condition|)
return|return
operator|(
name|work
operator|)
return|;
name|work
operator|->
name|a
operator|.
name|clb
operator|=
name|CNIL
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfseek
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|offset
decl_stmt|,
name|whence
decl_stmt|;
name|lispval
name|retp
decl_stmt|;
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"fseek"
argument_list|)
expr_stmt|;
comment|/* Make sure there are three arguments*/
name|f
operator|=
name|lbot
operator|->
name|val
operator|->
name|p
expr_stmt|;
comment|/* Get first argument into f */
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|PORT
condition|)
comment|/* Check type of first */
name|error
argument_list|(
literal|"fseek: First argument must be a port."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
comment|/* Get second argument */
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"fseek: Second argument must be an integer."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|whence
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
comment|/* Get last arg	*/
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"fseek: Third argument must be an integer."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
name|offset
argument_list|,
operator|(
name|int
operator|)
name|whence
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"fseek: Illegal parameters."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retp
operator|=
name|inewint
argument_list|(
name|ftell
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|retp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* function hashtabstat  : return list of number of members in  each bucket */
end_comment

begin_function
name|lispval
name|Lhashst
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|cur
decl_stmt|;
specifier|register
name|struct
name|atom
modifier|*
name|pnt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
specifier|extern
name|int
name|hashtop
decl_stmt|;
name|Savestack
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|handy
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|cur
operator|=
name|handy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hashtop
condition|;
name|i
operator|++
control|)
block|{
name|pnt
operator|=
name|hasht
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|pnt
operator|!=
operator|(
expr|struct
name|atom
operator|*
operator|)
name|CNIL
condition|;
name|pnt
operator|=
name|pnt
operator|->
name|hshlnk
operator|,
name|cnt
operator|++
control|)
empty_stmt|;
name|cur
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|cur
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
block|}
name|cur
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lctcherr   this routine should only be called by the unwind protect simulation   lisp code   It is called after an unwind-protect frame has been entered and   evalated and we want to get on with the error or throw   We only handle the case where there are 0 to 2 extra arguments to the   error call. */
end_comment

begin_function
name|lispval
name|Lctcherr
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
name|type
decl_stmt|,
name|messg
decl_stmt|,
name|valret
decl_stmt|,
name|contuab
decl_stmt|,
name|uniqid
decl_stmt|,
name|datum1
decl_stmt|,
name|datum2
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"I-throw-err"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
operator|==
name|INT
condition|)
block|{
comment|/* continuing a non error (throw,reset, etc) */
name|Inonlocalgo
argument_list|(
operator|(
name|int
operator|)
name|handy
operator|->
name|d
operator|.
name|car
operator|->
name|i
argument_list|,
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|,
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|!=
name|nil
condition|)
block|{
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"I-do-throw: first element not fixnum or nil"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|handy
argument_list|)
expr_stmt|;
block|}
comment|/* decode the arg list */
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|type
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|messg
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|valret
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|contuab
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|uniqid
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* if not extra args */
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
block|{
name|errorh
argument_list|(
name|type
argument_list|,
name|messg
operator|->
name|a
operator|.
name|pname
argument_list|,
name|valret
argument_list|,
operator|(
name|int
operator|)
name|contuab
operator|->
name|i
argument_list|,
operator|(
name|int
operator|)
name|uniqid
operator|->
name|i
argument_list|)
expr_stmt|;
block|}
name|datum1
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* if one extra arg */
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
block|{
name|errorh1
argument_list|(
name|type
argument_list|,
name|messg
operator|->
name|a
operator|.
name|pname
argument_list|,
name|valret
argument_list|,
operator|(
name|int
operator|)
name|contuab
operator|->
name|i
argument_list|,
operator|(
name|int
operator|)
name|uniqid
operator|->
name|i
argument_list|,
name|datum1
argument_list|)
expr_stmt|;
block|}
comment|/* if two or more extra args, just use first 2 */
name|datum2
operator|=
name|handy
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|errorh2
argument_list|(
name|type
argument_list|,
name|messg
operator|->
name|a
operator|.
name|pname
argument_list|,
name|valret
argument_list|,
operator|(
name|int
operator|)
name|contuab
operator|->
name|i
argument_list|,
operator|(
name|int
operator|)
name|uniqid
operator|->
name|i
argument_list|,
name|datum1
argument_list|,
name|datum2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	(*makhunk '<fixnum>)  *<fixnum>  * Create a hunk of size 2       .<fixnum> must be between 0 and 6.  *  */
end_comment

begin_function
name|lispval
name|LMakhunk
parameter_list|()
block|{
specifier|register
name|int
name|hsize
decl_stmt|,
name|hcntr
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"Makehunk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
name|hsize
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
expr_stmt|;
comment|/* size of hunk (0-6) */
if|if
condition|(
operator|(
name|hsize
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|hsize
operator|<=
literal|6
operator|)
condition|)
block|{
name|result
operator|=
name|newhunk
argument_list|(
name|hsize
argument_list|)
expr_stmt|;
name|hsize
operator|=
literal|2
operator|<<
name|hsize
expr_stmt|;
comment|/* size of hunk (2-128) */
for|for
control|(
name|hcntr
operator|=
literal|0
init|;
name|hcntr
operator|<
name|hsize
condition|;
name|hcntr
operator|++
control|)
name|result
operator|->
name|h
operator|.
name|hunk
index|[
name|hcntr
index|]
operator|=
name|hunkfree
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"*makhunk: Illegal hunk size"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"*makhunk: First arg must be an fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  *	(cxr '<fixnum> '<hunk>)  * Returns the<fixnum>'th element of<hunk>  *  */
end_comment

begin_function
name|lispval
name|Lcxr
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"cxr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"cxr: First arg must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|HUNKP
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"cxr: Second arg must be a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<
operator|(
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|)
operator|)
condition|)
block|{
name|temp
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|lbot
operator|->
name|val
operator|->
name|i
index|]
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|hunkfree
condition|)
return|return
operator|(
name|temp
operator|)
return|;
else|else
name|error
argument_list|(
literal|"cxr: Arg outside of hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"cxr: Arg outside of hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  *	(rplacx '<fixnum> '<hunk> '<expr>)  * Replaces the<fixnum>'th element of<hunk> with<expr>.  *  */
end_comment

begin_function
name|lispval
name|Lrplcx
parameter_list|()
block|{
name|lispval
modifier|*
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"rplacx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"rplacx: First arg must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|HUNKP
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"rplacx: Second arg must be a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<
operator|(
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|handy
operator|=
operator|&
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|lbot
operator|->
name|val
operator|->
name|i
index|]
operator|)
operator|)
operator|!=
name|hunkfree
condition|)
operator|*
name|handy
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
else|else
name|error
argument_list|(
literal|"rplacx: Arg outside hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"rplacx: Arg outside hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(*rplacx '<fixnum> '<hunk> '<expr>)  * Replaces the<fixnum>'th element of<hunk> with<expr>. This is the  * same as (rplacx ...) except with this function you can replace EMPTY's.  *  */
end_comment

begin_function
name|lispval
name|Lstarrpx
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"*rplacx"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"*rplacx: First arg must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|HUNKP
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
name|error
argument_list|(
literal|"*rplacx: Second arg must be a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|<
operator|(
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|)
operator|)
condition|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|lbot
operator|->
name|val
operator|->
name|i
index|]
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
else|else
name|error
argument_list|(
literal|"*rplacx: Arg outside hunk range"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(hunksize '<hunk>)  * Returns the size of<hunk>  *  */
end_comment

begin_function
name|lispval
name|Lhunksize
parameter_list|()
block|{
specifier|register
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"hunksize"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUNKP
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
name|size
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|lbot
operator|->
name|val
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|!=
name|hunkfree
condition|)
block|{
name|size
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|inewint
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"hunksize: First argument must me a hunk"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * (hunk-to-list 'hunk)	returns a list of the hunk elements  */
end_comment

begin_function
name|lispval
name|Lhtol
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|retval
decl_stmt|,
name|last
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"hunk-to-list"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|HUNKP
argument_list|(
name|handy
argument_list|)
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"hunk-to-list: non hunk argument: "
argument_list|,
name|nil
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|retval
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|handy
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|!=
name|hunkfree
condition|)
block|{
if|if
condition|(
name|retval
operator|==
name|nil
condition|)
block|{
name|protect
argument_list|(
name|retval
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|last
operator|=
name|retval
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
operator|(
name|last
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
block|}
name|last
operator|->
name|d
operator|.
name|car
operator|=
name|handy
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
break|break;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(fileopen  filename mode)  * open a file for read, write, or append the arguments can be either  * strings or atoms.  */
end_comment

begin_function
name|lispval
name|Lfileopen
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|name
decl_stmt|;
specifier|register
name|lispval
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|namech
decl_stmt|;
specifier|register
name|char
modifier|*
name|modech
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"fileopen"
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|mode
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|namech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|name
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
name|modech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|mode
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
while|while
condition|(
name|modech
index|[
literal|0
index|]
operator|!=
literal|'r'
operator|&&
name|modech
index|[
literal|0
index|]
operator|!=
literal|'w'
operator|&&
name|modech
index|[
literal|0
index|]
operator|!=
literal|'a'
condition|)
block|{
name|mode
operator|=
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"Modes are only r, w, a."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|)
expr_stmt|;
name|modech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|mode
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|port
operator|=
name|fopen
argument_list|(
name|namech
argument_list|,
name|modech
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|namech
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|name
argument_list|,
literal|"fileopen:args must be atoms or strings"
argument_list|)
expr_stmt|;
block|}
comment|/* xports is a FILE *, cc complains about adding pointers */
name|ioname
index|[
name|PN
argument_list|(
name|port
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|namech
argument_list|)
expr_stmt|;
comment|/* remember name */
return|return
operator|(
name|P
argument_list|(
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(*invmod '<number> '<modulus>)  * This function returns the inverse of<number>  * mod<modulus> in balanced representation  * It is used in vaxima as a speed enhancement.  */
end_comment

begin_function
specifier|static
name|lispval
name|Ibalmod
parameter_list|(
name|invmodp
parameter_list|)
block|{
specifier|register
name|long
name|mod_div_2
decl_stmt|,
name|number
decl_stmt|,
name|modulus
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"*mod"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|INT
operator|)
operator|&&
operator|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|==
name|INT
operator|)
condition|)
block|{
name|modulus
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|invmodp
condition|)
name|number
operator|=
name|invmod
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|i
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
else|else
name|number
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
operator|%
name|modulus
expr_stmt|;
name|mod_div_2
operator|=
name|modulus
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|number
operator|<
operator|(
operator|-
name|mod_div_2
operator|)
condition|)
name|number
operator|+=
name|modulus
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|number
operator|>
name|mod_div_2
condition|)
name|number
operator|-=
name|modulus
expr_stmt|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|number
argument_list|)
operator|)
return|;
block|}
else|else
name|error
argument_list|(
literal|"*mod: Arguments must be fixnums"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|invmod
argument_list|(
argument|n
argument_list|,
argument|modulus
argument_list|)
end_macro

begin_decl_stmt
name|long
name|n
decl_stmt|,
name|modulus
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|y3
decl_stmt|,
name|q
decl_stmt|;
name|a1
operator|=
name|modulus
expr_stmt|;
name|a2
operator|=
name|n
expr_stmt|;
name|y1
operator|=
literal|0
expr_stmt|;
name|y2
operator|=
literal|1
expr_stmt|;
goto|goto
name|step3
goto|;
name|step2
label|:
name|q
operator|=
name|a1
operator|/
name|a2
expr_stmt|;
comment|/*truncated quotient */
name|a3
operator|=
name|mmuladd
argument_list|(
name|modulus
operator|-
name|a2
argument_list|,
name|q
argument_list|,
name|a1
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|y3
operator|=
name|mmuladd
argument_list|(
name|modulus
operator|-
name|y2
argument_list|,
name|q
argument_list|,
name|y1
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
name|a1
operator|=
name|a2
expr_stmt|;
name|a2
operator|=
name|a3
expr_stmt|;
name|y1
operator|=
name|y2
expr_stmt|;
name|y2
operator|=
name|y3
expr_stmt|;
name|step3
label|:
if|if
condition|(
name|a2
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"invmod: inverse of zero divisor"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|a2
operator|!=
literal|1
condition|)
goto|goto
name|step2
goto|;
else|else
return|return
operator|(
name|y2
operator|)
return|;
comment|/* NOTREACHED */
block|}
end_block

begin_function
name|lispval
name|Lstarinvmod
parameter_list|()
block|{
return|return
operator|(
name|Ibalmod
argument_list|(
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(*mod '<number> '<modulus>)  * This function returns<number> mod<modulus> (for balanced modulus).  * It is used in vaxima as a speed enhancement.  */
end_comment

begin_function
name|lispval
name|LstarMod
parameter_list|()
block|{
return|return
operator|(
name|Ibalmod
argument_list|(
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llsh
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|int
name|val
decl_stmt|,
name|shift
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"lsh"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"Non ints to lsh"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|mylbot
operator|->
name|val
argument_list|,
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|mylbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|shift
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|shift
operator|<
operator|-
literal|32
operator|||
name|shift
operator|>
literal|32
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|val
operator|=
name|val
operator|>>
operator|-
name|shift
expr_stmt|;
else|else
name|val
operator|=
name|val
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|&&
operator|(
name|shift
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* special case: the vax doesn't have a logical shift 		   instruction, so we must zero out the ones which 		   will propogate from the sign position 		*/
return|return
operator|(
name|inewint
argument_list|(
name|val
operator|&
operator|~
operator|(
literal|0x80000000
operator|>>
operator|-
operator|(
name|shift
operator|+
literal|1
operator|)
operator|)
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* very temporary function to test the validity of the bind stack */
end_comment

begin_macro
name|bndchk
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nament
modifier|*
name|npt
decl_stmt|;
specifier|register
name|lispval
name|in2
decl_stmt|;
name|in2
operator|=
name|inewint
argument_list|(
literal|200
argument_list|)
expr_stmt|;
for|for
control|(
name|npt
operator|=
name|orgbnp
init|;
name|npt
operator|<
name|bnp
condition|;
name|npt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|npt
operator|->
name|atm
operator|<
operator|(
name|int
operator|)
name|in2
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	formatted printer for lisp data  *    use: (cprintf formatstring datum [port])  */
end_comment

begin_function
name|lispval
name|Lcprintf
parameter_list|()
block|{
name|FILE
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|fstrng
decl_stmt|;
name|lispval
name|v
decl_stmt|;
if|if
condition|(
name|np
operator|-
name|lbot
operator|==
literal|2
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* write to standard output port */
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"cprintf"
argument_list|)
expr_stmt|;
name|fstrng
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"cprintf: first arg not string or symbol"
argument_list|)
expr_stmt|;
name|p
operator|=
name|okport
argument_list|(
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|poport
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|v
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
operator|->
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATOM
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
operator|->
name|a
operator|.
name|pname
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|fprintf
argument_list|(
name|p
argument_list|,
name|fstrng
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cprintf: Illegal second argument"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * C style sprintf: (sprintf "format" {<arg-list>})  *  * This function stacks the arguments onto the C stack in reverse  * order and then calls sprintf with one argument...This is what the  * C compiler does, so it works just fine. The return value is the  * string that is the result of the sprintf.  */
end_comment

begin_function
name|lispval
name|Lsprintf
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|char
name|sbuf
index|[
literal|600
index|]
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|;
comment|/* better way? */
name|Keepxs
argument_list|()
expr_stmt|;
if|if
condition|(
name|np
operator|-
name|lbot
operator|==
literal|0
condition|)
block|{
name|argerr
argument_list|(
literal|"sprintf"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|STRNG
operator|||
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
for|for
control|(
name|argp
operator|=
name|np
operator|-
literal|1
init|;
name|argp
operator|>=
name|lbot
condition|;
name|argp
operator|--
control|)
block|{
switch|switch
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|stack
argument_list|(
operator|(
name|long
operator|)
name|argp
operator|->
name|val
operator|->
name|a
operator|.
name|pname
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
ifndef|#
directive|ifndef
name|SPISFP
name|stack
argument_list|(
name|argp
operator|->
name|val
operator|->
name|r
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|double
name|rr
init|=
name|argp
operator|->
name|val
operator|->
name|r
decl_stmt|;
name|stack
argument_list|(
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|rr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|stack
argument_list|(
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|rr
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|INT
case|:
name|stack
argument_list|(
name|argp
operator|->
name|val
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|stack
argument_list|(
operator|(
name|long
operator|)
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"sprintf: Bad data type to sprintf"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|np
operator|-
name|lbot
condition|;
name|j
operator|++
control|)
name|unstack
argument_list|()
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"sprintf: First arg must be an atom or string"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Freexs
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|sbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lprobef
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"probef"
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
literal|"probef: not symbol or string arg "
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lsubstring
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|lispval
name|index
decl_stmt|,
name|length
decl_stmt|;
name|int
name|restofstring
init|=
name|FALSE
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ind
decl_stmt|,
name|reallen
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|restofstring
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
break|break;
default|default:
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"substring"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"substring: not symbol or string arg "
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|index
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"substring: non integer index "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ind
operator|=
name|index
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
name|ind
operator|=
name|len
operator|+
literal|1
operator|+
name|ind
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
operator|||
name|ind
operator|>
name|len
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/*index out of bounds*/
if|if
condition|(
name|restofstring
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|name
operator|+
name|ind
operator|-
literal|1
argument_list|)
operator|)
return|;
while|while
condition|(
name|TYPE
argument_list|(
name|length
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"substring: not integer length "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reallen
operator|=
name|length
operator|->
name|i
operator|)
operator|<
literal|0
operator|||
operator|(
name|reallen
operator|+
name|ind
operator|)
operator|>
name|len
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|name
operator|+
name|ind
operator|-
literal|1
argument_list|)
operator|)
return|;
name|strncpy
argument_list|(
name|strbuf
argument_list|,
name|name
operator|+
name|ind
operator|-
literal|1
argument_list|,
name|reallen
argument_list|)
expr_stmt|;
name|strbuf
index|[
name|reallen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|newstr
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is substringn  */
end_comment

begin_function
name|lispval
name|Lsstrn
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|ind
decl_stmt|,
name|reallen
decl_stmt|;
name|lispval
name|index
decl_stmt|,
name|length
decl_stmt|;
name|int
name|restofstring
init|=
name|FALSE
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|-
name|lbot
operator|)
operator|==
literal|2
condition|)
name|restofstring
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"substringn"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"substringn: non symbol or string arg "
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|index
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"substringn: non integer index "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|restofstring
condition|)
block|{
while|while
condition|(
name|TYPE
argument_list|(
name|length
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"substringn: not integer length "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|reallen
operator|=
name|length
operator|->
name|i
expr_stmt|;
block|}
else|else
name|reallen
operator|=
operator|-
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ind
operator|=
name|index
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
name|ind
operator|=
name|len
operator|+
literal|1
operator|+
name|ind
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|1
operator|||
name|ind
operator|>
name|len
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
name|reallen
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewint
argument_list|(
operator|*
operator|(
name|name
operator|+
name|ind
operator|-
literal|1
operator|)
argument_list|)
operator|)
return|;
else|else
block|{
name|char
modifier|*
name|pnt
init|=
name|name
operator|+
name|ind
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|last
init|=
name|name
operator|+
name|len
operator|-
literal|1
decl_stmt|;
name|lispval
name|cur
decl_stmt|,
name|start
decl_stmt|;
name|protect
argument_list|(
name|cur
operator|=
name|start
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|cur
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
operator|*
name|pnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|++
name|pnt
operator|<=
name|last
operator|&&
operator|--
name|reallen
operator|!=
literal|0
condition|)
block|{
name|cur
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|cur
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
operator|*
name|pnt
argument_list|)
expr_stmt|;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|start
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * (character-index 'string 'char)  * return the index of char in the string.  * return nil if not present  * char can be a fixnum (representing a character)  *  a symbol or string (in which case the first char is used)  *  */
end_comment

begin_if
if|#
directive|if
name|os_unix_ts
end_if

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|lispval
name|Lcharindex
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|str2
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"character-index"
argument_list|)
expr_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"character-index: non symbol or string arg "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|==
name|INT
condition|)
name|ch
operator|=
operator|(
name|char
operator|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
else|else
block|{
name|str2
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"character-index: bad first argument "
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|str2
expr_stmt|;
comment|/* grab the first character */
block|}
if|if
condition|(
operator|(
name|str2
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|string
argument_list|,
name|ch
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* not there */
comment|/* return 1-based index of character */
return|return
operator|(
name|inewint
argument_list|(
name|str2
operator|-
name|string
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function_decl
name|lispval
name|Ipurcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|lispval
name|Lpurcopy
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"purcopy"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Ipurcopy
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ipurcopy
parameter_list|(
name|handy
parameter_list|)
name|lispval
name|handy
decl_stmt|;
block|{
specifier|extern
name|int
modifier|*
name|beginsweep
decl_stmt|;
specifier|register
name|lispval
name|retv
decl_stmt|,
name|curv
decl_stmt|,
name|lv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
condition|)
block|{
case|case
name|DTPR
case|:
name|retv
operator|=
name|curv
operator|=
name|pnewdot
argument_list|()
expr_stmt|;
name|lv
operator|=
name|handy
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|curv
operator|->
name|d
operator|.
name|car
operator|=
name|Ipurcopy
argument_list|(
name|lv
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lv
operator|=
name|lv
operator|->
name|d
operator|.
name|cdr
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|curv
operator|->
name|d
operator|.
name|cdr
operator|=
name|pnewdot
argument_list|()
expr_stmt|;
name|curv
operator|=
name|curv
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
else|else
block|{
name|curv
operator|->
name|d
operator|.
name|cdr
operator|=
name|Ipurcopy
argument_list|(
name|lv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|SDOT
case|:
name|retv
operator|=
name|curv
operator|=
name|pnewsdot
argument_list|()
expr_stmt|;
name|lv
operator|=
name|handy
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|curv
operator|->
name|s
operator|.
name|I
operator|=
name|lv
operator|->
name|s
operator|.
name|I
expr_stmt|;
if|if
condition|(
name|lv
operator|->
name|s
operator|.
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
break|break;
name|lv
operator|=
name|lv
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
name|curv
operator|->
name|s
operator|.
name|CDR
operator|=
name|pnewdot
argument_list|()
expr_stmt|;
name|curv
operator|=
name|curv
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
block|}
name|curv
operator|->
name|s
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|INT
case|:
if|if
condition|(
operator|(
name|int
operator|*
operator|)
name|handy
operator|<
name|beginsweep
condition|)
return|return
operator|(
name|handy
operator|)
return|;
name|retv
operator|=
name|pnewint
argument_list|()
expr_stmt|;
name|retv
operator|->
name|i
operator|=
name|handy
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|DOUB
case|:
name|retv
operator|=
name|pnewdb
argument_list|()
expr_stmt|;
name|retv
operator|->
name|r
operator|=
name|handy
operator|->
name|r
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|HUNK2
case|:
name|i
operator|=
literal|0
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK4
case|:
name|i
operator|=
literal|1
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK8
case|:
name|i
operator|=
literal|2
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK16
case|:
name|i
operator|=
literal|3
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK32
case|:
name|i
operator|=
literal|4
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK64
case|:
name|i
operator|=
literal|5
expr_stmt|;
goto|goto
name|hunkit
goto|;
case|case
name|HUNK128
case|:
name|i
operator|=
literal|6
expr_stmt|;
name|hunkit
label|:
name|retv
operator|=
name|pnewhunk
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2
operator|<<
name|i
expr_stmt|;
comment|/* number of elements to copy over */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|retv
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|=
name|Ipurcopy
argument_list|(
name|handy
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retv
operator|)
return|;
case|case
name|STRNG
case|:
ifdef|#
directive|ifdef
name|GCSTRINGS
block|{
specifier|extern
name|char
name|purepage
index|[]
decl_stmt|;
if|if
condition|(
name|purepage
index|[
operator|(
operator|(
name|int
operator|)
name|handy
operator|)
operator|>>
literal|9
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|pinewstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handy
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
case|case
name|ATOM
case|:
case|case
name|BCD
case|:
case|case
name|PORT
case|:
return|return
operator|(
name|handy
operator|)
return|;
comment|/* We don't want to purcopy these, yet 				 * it won't hurt if we don't mark them 				 * since they either aren't swept or  				 * will be marked in a special way  				 */
case|case
name|ARRAY
case|:
name|error
argument_list|(
literal|"purcopy: can't purcopy array structures"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|" bad type to purcopy "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_comment
comment|/*  * Lpurep returns t if the given arg is in pure space  */
end_comment

begin_function
name|lispval
name|Lpurep
parameter_list|()
block|{
name|lispval
name|Ipurep
parameter_list|()
function_decl|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"purep"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Ipurep
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vector functions */
end_comment

begin_decl_stmt
name|lispval
name|newvec
argument_list|()
decl_stmt|,
name|nveci
argument_list|()
decl_stmt|,
name|Inewvector
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vector creation and initialization functions */
end_comment

begin_function
name|lispval
name|Lnvec
parameter_list|()
block|{
return|return
operator|(
name|Inewvector
argument_list|(
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnvecb
parameter_list|()
block|{
return|return
operator|(
name|Inewvector
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnvecw
parameter_list|()
block|{
return|return
operator|(
name|Inewvector
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnvecl
parameter_list|()
block|{
return|return
operator|(
name|Inewvector
argument_list|(
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (new-vector 'x_size ['g_fill] ['g_prop])  * class = 0: byte \  *       = 1: word> immediate  *       = 2: long /  *	 = 3: long  */
end_comment

begin_function
name|lispval
name|Inewvector
parameter_list|(
name|class
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|lispval
modifier|*
name|handy2
decl_stmt|;
name|char
modifier|*
name|chandy
decl_stmt|;
name|short
modifier|*
name|whandy
decl_stmt|;
name|long
modifier|*
name|lhandy
decl_stmt|;
name|lispval
name|sizearg
decl_stmt|,
name|fillarg
decl_stmt|,
name|proparg
decl_stmt|;
name|int
name|size
decl_stmt|,
name|vsize
decl_stmt|;
name|fillarg
operator|=
name|proparg
operator|=
name|nil
expr_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|3
case|:
name|proparg
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
case|case
literal|2
case|:
name|fillarg
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
case|case
literal|1
case|:
name|sizearg
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
expr_stmt|;
break|break;
default|default:
name|argerr
argument_list|(
literal|"new-vector"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|sizearg
argument_list|)
operator|!=
name|INT
operator|)
operator|||
name|sizearg
operator|->
name|i
operator|<
literal|0
condition|)
name|sizearg
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"new-vector: bad size for vector "
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|sizearg
argument_list|)
expr_stmt|;
name|size
operator|=
name|sizearg
operator|->
name|i
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|0
case|:
name|vsize
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|vsize
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
break|break;
default|default:
name|vsize
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|!=
literal|3
condition|)
name|handy
operator|=
name|nveci
argument_list|(
name|vsize
argument_list|)
expr_stmt|;
else|else
name|handy
operator|=
name|newvec
argument_list|(
name|vsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|0
case|:
name|chandy
operator|=
operator|(
name|char
operator|*
operator|)
name|handy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|chandy
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|fillarg
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|whandy
operator|=
operator|(
name|short
operator|*
operator|)
name|handy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|whandy
operator|++
operator|=
call|(
name|short
call|)
argument_list|(
name|fillarg
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|lhandy
operator|=
operator|(
name|long
operator|*
operator|)
name|handy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|lhandy
operator|++
operator|=
operator|(
name|fillarg
operator|->
name|i
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|handy2
operator|=
operator|(
name|lispval
operator|*
operator|)
name|handy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|handy2
operator|++
operator|=
name|fillarg
expr_stmt|;
break|break;
block|}
name|handy
operator|->
name|v
operator|.
name|vector
index|[
operator|-
literal|1
index|]
operator|=
name|proparg
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lvectorp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"vectorp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|VECTOR
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lpvp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"vectorip"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|==
name|VECTORI
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int:vref  vector[i] index class  *  class = 0: byte immed, 1: word immed, 2: long immed, 3: long  *  * also do C style dereferencing of pointers.  This is a temporary  * hack until we decide if we can live without it:  *  class = 4: char, 5: short, 6: long, 7: float, 8: double  */
end_comment

begin_function
name|lispval
name|LIvref
parameter_list|()
block|{
specifier|register
name|lispval
name|vect
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|class
decl_stmt|;
name|double
name|value
decl_stmt|;
name|chkarg
argument_list|(
literal|3
argument_list|,
literal|"int:vref"
argument_list|)
expr_stmt|;
name|vect
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
expr_stmt|;
name|index
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|class
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|inewint
argument_list|(
name|vect
operator|->
name|vb
operator|.
name|vectorb
index|[
name|index
index|]
argument_list|)
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|inewint
argument_list|(
name|vect
operator|->
name|vw
operator|.
name|vectorw
index|[
name|index
index|]
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|inewint
argument_list|(
name|vect
operator|->
name|vl
operator|.
name|vectorl
index|[
name|index
index|]
argument_list|)
operator|)
return|;
case|case
literal|3
case|:
return|return
operator|(
name|vect
operator|->
name|v
operator|.
name|vector
index|[
name|index
index|]
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
name|inewint
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
argument_list|)
operator|)
return|;
case|case
literal|5
case|:
return|return
operator|(
name|inewint
argument_list|(
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
argument_list|)
operator|)
return|;
case|case
literal|6
case|:
return|return
operator|(
name|inewint
argument_list|(
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
argument_list|)
operator|)
return|;
case|case
literal|7
case|:
name|value
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
expr_stmt|;
name|vect
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|vect
operator|->
name|r
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|vect
operator|)
return|;
case|case
literal|8
case|:
name|value
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
expr_stmt|;
name|vect
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|vect
operator|->
name|r
operator|=
name|value
expr_stmt|;
return|return
operator|(
name|vect
operator|)
return|;
block|}
name|error
argument_list|(
literal|"int:vref: impossible class detected"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * int:vset vector[i] index value class  *  class = 0: byte immed, 1: word immed, 2: long immed, 3: long  */
end_comment

begin_function
name|lispval
name|LIvset
parameter_list|()
block|{
specifier|register
name|lispval
name|vect
decl_stmt|,
name|value
decl_stmt|;
specifier|register
name|int
name|index
decl_stmt|;
name|int
name|class
decl_stmt|;
name|chkarg
argument_list|(
literal|4
argument_list|,
literal|"int:vset"
argument_list|)
expr_stmt|;
name|vect
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
expr_stmt|;
name|index
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|value
operator|=
name|lbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
name|class
operator|=
name|lbot
index|[
literal|3
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|0
case|:
name|vect
operator|->
name|vb
operator|.
name|vectorb
index|[
name|index
index|]
operator|=
operator|(
name|char
operator|)
name|value
operator|->
name|i
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|vect
operator|->
name|vw
operator|.
name|vectorw
index|[
name|index
index|]
operator|=
operator|(
name|short
operator|)
name|value
operator|->
name|i
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vect
operator|->
name|vl
operator|.
name|vectorl
index|[
name|index
index|]
operator|=
name|value
operator|->
name|i
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vect
operator|->
name|v
operator|.
name|vector
index|[
name|index
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
operator|(
name|char
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
operator|=
name|value
operator|->
name|i
expr_stmt|;
break|break;
case|case
literal|5
case|:
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
operator|=
name|value
operator|->
name|i
expr_stmt|;
break|break;
case|case
literal|6
case|:
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
operator|=
name|value
operator|->
name|i
expr_stmt|;
break|break;
case|case
literal|7
case|:
operator|*
operator|(
name|float
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
operator|=
name|value
operator|->
name|r
expr_stmt|;
break|break;
case|case
literal|8
case|:
operator|*
operator|(
name|double
operator|*
operator|)
operator|(
name|vect
operator|->
name|i
operator|+
name|index
operator|)
operator|=
name|value
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"int:vref: impossible class detected"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * LIvsize == (int:vsize 'vector 'x_shift)  *  return the vsize field of the vector shifted right by x_shift  */
end_comment

begin_function
name|lispval
name|LIvsize
parameter_list|()
block|{
name|int
name|typ
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"int:vsize"
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
operator|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|vl
operator|.
name|vectorl
index|[
name|VSizeOff
index|]
operator|)
operator|>>
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lvprop
parameter_list|()
block|{
name|int
name|typ
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"vprop"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|VECTOR
operator|)
operator|&&
operator|(
name|typ
operator|!=
name|VECTORI
operator|)
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"vprop: non vector argument: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lvsp
parameter_list|()
block|{
name|int
name|typ
decl_stmt|;
name|lispval
name|vector
decl_stmt|,
name|property
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"vsetprop"
argument_list|)
expr_stmt|;
name|vector
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|property
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|typ
operator|=
name|TYPE
argument_list|(
name|vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|!=
name|VECTOR
operator|&&
name|typ
operator|!=
name|VECTORI
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"vsetprop: non vector argument: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|vector
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|=
name|property
expr_stmt|;
return|return
operator|(
name|property
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vecequal  *  check if the two vector arguments are 'equal'  *  this is called by equal which has already checked that  *  the arguments are vector  */
end_comment

begin_macro
name|vecequal
argument_list|(
argument|v
argument_list|,
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|v
decl_stmt|,
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|lispval
name|vv
decl_stmt|,
name|ww
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|vsize
init|=
operator|(
name|int
operator|)
name|v
operator|->
name|v
operator|.
name|vector
index|[
name|VSizeOff
index|]
decl_stmt|;
name|int
name|wsize
init|=
operator|(
name|int
operator|)
name|w
operator|->
name|v
operator|.
name|vector
index|[
name|VSizeOff
index|]
decl_stmt|;
name|struct
name|argent
modifier|*
name|oldlbot
init|=
name|lbot
decl_stmt|;
name|lispval
name|Lequal
parameter_list|()
function_decl|;
if|if
condition|(
name|vsize
operator|!=
name|wsize
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|vsize
operator|/=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* determine number of entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
name|vv
operator|=
name|v
operator|->
name|v
operator|.
name|vector
index|[
name|i
index|]
expr_stmt|;
name|ww
operator|=
name|w
operator|->
name|v
operator|.
name|vector
index|[
name|i
index|]
expr_stmt|;
comment|/* avoid calling equal if they are eq */
if|if
condition|(
name|vv
operator|!=
name|ww
condition|)
block|{
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|vv
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|ww
argument_list|)
expr_stmt|;
name|ret
operator|=
name|Lequal
argument_list|()
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|oldlbot
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|nil
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* veciequal  *  check if the two vectori arguments are 'equal'  *  this is called by equal which has already checked that  *  the arguments are vector  *  Note: this would run faster if we did as many 'longword'  *  comparisons as possible and then did byte comparisons.  *  or if we used pointers instead of indexing.  */
end_comment

begin_macro
name|veciequal
argument_list|(
argument|v
argument_list|,
argument|w
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|v
decl_stmt|,
name|w
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|vv
decl_stmt|,
name|ww
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|vsize
init|=
operator|(
name|int
operator|)
name|v
operator|->
name|v
operator|.
name|vector
index|[
name|VSizeOff
index|]
decl_stmt|;
name|int
name|wsize
init|=
operator|(
name|int
operator|)
name|w
operator|->
name|v
operator|.
name|vector
index|[
name|VSizeOff
index|]
decl_stmt|;
if|if
condition|(
name|vsize
operator|!=
name|wsize
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|vb
operator|.
name|vectorb
index|[
name|i
index|]
operator|!=
name|w
operator|->
name|vb
operator|.
name|vectorb
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

end_unit

