begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_macro
name|mmuladd
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|long
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|work
index|[
literal|2
index|]
decl_stmt|;
name|char
name|err
decl_stmt|;
name|emul
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|ediv
argument_list|(
name|work
argument_list|,
name|m
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|work
index|[
literal|0
index|]
operator|)
return|;
block|}
end_block

begin_comment
comment|/*mmuladd (a, b, c, m)  int a, b, c, m; { 	asm ("emul	4(ap),8(ap),12(ap),r0"); 	asm ("ediv	16(ap),r0,r2,r0"); }  Imuldiv() { asm("	emul	4(ap),8(ap),12(ap),r0"); asm("	ediv	16(ap),r0,*20(ap),*24(ap)"); }*/
end_comment

begin_macro
name|Imuldiv
argument_list|(
argument|p1
argument_list|,
argument|p2
argument_list|,
argument|add
argument_list|,
argument|dv
argument_list|,
argument|quo
argument_list|,
argument|rem
argument_list|)
end_macro

begin_decl_stmt
name|long
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|add
decl_stmt|,
name|dv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|quo
decl_stmt|,
modifier|*
name|rem
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|work
index|[
literal|2
index|]
decl_stmt|;
name|char
name|err
decl_stmt|;
name|emul
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|add
argument_list|,
name|work
argument_list|)
expr_stmt|;
operator|*
name|quo
operator|=
name|ediv
argument_list|(
name|work
argument_list|,
name|dv
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
operator|*
name|rem
operator|=
operator|*
name|work
expr_stmt|;
block|}
end_block

begin_comment
comment|/*C library -- write   nwritten = write(file, buffer, count);   nwritten == -1 means error */
end_comment

begin_macro
name|write
argument_list|(
argument|file
argument_list|,
argument|buffer
argument_list|,
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|!=
literal|1
operator|)
operator|||
operator|(
name|Vcntlw
operator|->
name|a
operator|.
name|clb
operator|==
name|nil
operator|)
condition|)
goto|goto
name|top
goto|;
comment|/* since ^w is non nil, we do not want to print to the terminal, 	   but we must be sure to return a correct value from the write 	   in case there is no write to ptport 	*/
name|retval
operator|=
name|count
expr_stmt|;
goto|goto
name|skipit
goto|;
name|top
label|:
name|retval
operator|=
name|_write
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|skipit
label|:
if|if
condition|(
name|file
operator|==
literal|1
condition|)
block|{
name|handy
operator|=
name|Vptport
operator|->
name|a
operator|.
name|clb
expr_stmt|;
if|if
condition|(
name|handy
operator|!=
name|nil
operator|&&
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|PORT
operator|&&
name|handy
operator|->
name|p
operator|->
name|_file
operator|!=
literal|1
condition|)
block|{
name|fflush
argument_list|(
name|handy
operator|->
name|p
argument_list|)
expr_stmt|;
name|file
operator|=
name|handy
operator|->
name|p
operator|->
name|_file
expr_stmt|;
goto|goto
name|top
goto|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/* # C library -- read  # nread = read(file, buffer, count); # # nread ==0 means eof; nread == -1 means error */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_macro
name|read
argument_list|(
argument|file
argument_list|,
argument|buffer
argument_list|,
argument|count
argument_list|)
end_macro

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|register
name|int
name|Size
decl_stmt|;
name|again
label|:
name|Size
operator|=
name|_read
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Size
operator|>=
literal|0
operator|)
operator|||
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
return|return
operator|(
name|Size
operator|)
return|;
if|if
condition|(
name|sigintcnt
operator|>
literal|0
condition|)
name|sigcall
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_block

begin_function
name|lispval
name|Lpolyev
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|double
modifier|*
name|handy
decl_stmt|,
modifier|*
name|base
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
name|count
operator|=
literal|2
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|np
operator|)
operator|-
operator|(
name|int
operator|)
name|lbot
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|count
operator|==
literal|8
condition|)
return|return
operator|(
name|lbot
operator|->
name|val
operator|)
return|;
name|base
operator|=
name|handy
operator|=
operator|(
name|double
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|type
operator|=
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|DOUB
operator|&&
name|type
operator|!=
name|INT
condition|)
name|argp
operator|->
name|val
operator|=
operator|(
name|lispval
operator|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"%%machine-polyev:non-real arg"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|73
argument_list|,
name|lbot
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|==
name|INT
condition|)
block|{
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
block|}
else|else
operator|*
name|handy
operator|++
operator|=
name|argp
operator|->
name|val
operator|->
name|r
expr_stmt|;
block|}
name|count
operator|=
name|count
operator|/
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/*	asm("polyd	(r9),r11,8(r9)"); 	asm("movd	r0,(r9)");*/
name|result
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|result
operator|->
name|r
operator|=
operator|*
name|base
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrot
parameter_list|()
block|{
specifier|register
name|rot
operator|,
name|val
expr_stmt|;
comment|/* these must be the first registers */
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"rot"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|mylbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"Non ints to rot"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|mylbot
operator|->
name|val
argument_list|,
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|mylbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|rot
operator|=
name|rot
operator|%
literal|32
expr_stmt|;
comment|/* bring it down below one byte in size */
if|if
condition|(
name|rot
operator|<
literal|0
condition|)
block|{
name|rot
operator|=
operator|-
name|rot
expr_stmt|;
block|{
asm|asm("roll	d7,d6");
block|}
block|}
else|else
block|{
asm|asm("rorl	d7,d6");
block|}
return|return
operator|(
name|inewint
argument_list|(
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|myfrexp
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"myfrexp called"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|os_unisoft
end_if

begin_macro
name|syscall
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"vsyscall called"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_expr_stmt
name|prunei
argument_list|(
name|what
argument_list|)
specifier|register
name|lispval
name|what
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|struct
name|types
name|int_str
decl_stmt|;
name|int
name|gstart
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
operator|(
name|long
operator|)
name|what
operator|)
operator|>
operator|(
operator|(
name|long
operator|)
name|gstart
operator|)
condition|)
block|{
operator|--
operator|(
name|int_items
operator|->
name|i
operator|)
expr_stmt|;
name|what
operator|->
name|i
operator|=
operator|(
name|long
operator|)
name|int_str
operator|.
name|next_free
expr_stmt|;
name|int_str
operator|.
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
name|what
expr_stmt|;
block|}
block|}
end_block

begin_include
include|#
directive|include
file|"68kframe.h"
end_include

begin_comment
comment|/* new version of showstack, 	We will set fp to point where the register fp points. 	If we find that the saved pc is somewhere in the routine eval,    then we print the first argument to that eval frame. This is done    by looking on the stack. */
end_comment

begin_function
name|lispval
name|Lshostk
parameter_list|()
block|{
name|lispval
name|isho
parameter_list|()
function_decl|;
return|return
operator|(
name|isho
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lispval
name|isho
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
specifier|register
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* this must be the first local */
name|int
name|virgin
init|=
literal|1
decl_stmt|;
name|lispval
name|linterp
argument_list|()
decl_stmt|,
name|Ifuncal
argument_list|()
decl_stmt|;
name|lispval
name|_qfuncl
argument_list|()
decl_stmt|,
name|tynames
argument_list|()
decl_stmt|;
comment|/* locations in qfuncl */
specifier|extern
name|int
name|plevel
decl_stmt|,
name|plength
decl_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plevel
operator|=
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plevel
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlength
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plength
operator|=
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plength
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"Forms in evaluation:\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Backtrace:\n\n"
argument_list|)
expr_stmt|;
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* point to current frame */
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
operator|(
name|myfp
operator|->
name|pc
operator|>
name|eval
operator|&&
comment|/* interpreted code */
name|myfp
operator|->
name|pc
operator|<
name|popnames
operator|)
operator|||
operator|(
name|myfp
operator|->
name|pc
operator|>
name|Ifuncal
operator|&&
comment|/* compiled code */
name|myfp
operator|->
name|pc
operator|<
name|Lfuncal
operator|)
condition|)
block|{
block|{
name|handy
operator|=
operator|(
name|myfp
operator|->
name|fp
operator|->
name|ap
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|1
condition|)
name|printr
argument_list|(
name|handy
argument_list|,
name|stdout
argument_list|)
operator|,
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|virgin
condition|)
name|virgin
operator|=
literal|0
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" -- "
argument_list|)
expr_stmt|;
name|printr
argument_list|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|?
name|handy
operator|->
name|d
operator|.
name|car
else|:
name|handy
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
break|break;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  *	(baktrace)  *  * baktrace will print the names of all functions being evaluated  * from the current one (baktrace) down to the first one.  * currently it only prints the function name.  Planned is a  * list of local variables in all stack frames.  * written by jkf.  *  */
end_comment

begin_function
name|lispval
name|Lbaktrace
parameter_list|()
block|{
name|isho
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * (int:showstack 'stack_pointer)  * return  *   nil if at the end of the stack or illegal  *   ( expresssion . next_stack_pointer) otherwise  *   where expression is something passed to eval  * very vax specific  */
end_comment

begin_function
name|lispval
name|LIshowstack
parameter_list|()
block|{
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* must be the first local variable */
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
name|lispval
name|retval
decl_stmt|,
name|Ifuncal
argument_list|()
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"int:showstack"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|&&
operator|(
name|handy
operator|!=
name|nil
operator|)
condition|)
name|error
argument_list|(
literal|"int:showstack non fixnum arg"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|handy
operator|->
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|*
operator|*
operator|*
operator|)
name|myfp
operator|<=
operator|&
name|fp
condition|)
name|error
argument_list|(
literal|"int:showstack illegal stack value"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|myfp
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|myfp
operator|->
name|pc
operator|>
name|eval
operator|&&
comment|/* interpreted code */
name|myfp
operator|->
name|pc
operator|<
name|popnames
operator|)
operator|||
operator|(
name|myfp
operator|->
name|pc
operator|>
name|Ifuncal
operator|&&
comment|/* compiled code */
name|myfp
operator|->
name|pc
operator|<
name|Lfuncal
operator|)
condition|)
block|{
block|{
name|handy
operator|=
call|(
name|lispval
call|)
argument_list|(
name|myfp
operator|->
name|fp
operator|->
name|ap
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* arg to eval */
name|protect
argument_list|(
name|retval
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|->
name|d
operator|.
name|car
operator|=
name|handy
expr_stmt|;
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
name|myfp
operator|=
literal|0
expr_stmt|;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
name|retval
operator|->
name|d
operator|.
name|cdr
operator|=
name|inewint
argument_list|(
name|myfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
name|myfp
operator|=
literal|0
expr_stmt|;
comment|/* end of frames */
else|else
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

end_unit

