begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *$Header: qfuncl.c,v 1.7 83/09/06 21:49:27 layer Exp $  *$Locker:  $  *  * Copyright (c) 1982, by the Regents, University of California  *  *			-[Tue Mar 22 15:42:27 1983 by layer]-  *  * "quick" functions file.  *  * This is written in assembler but must be passed through the C preprocessor  * before being assembled.  *  */
end_comment

begin_include
include|#
directive|include
file|"ltypes.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* important offsets within data types for atoms */
end_comment

begin_define
define|#
directive|define
name|Atomfnbnd
value|8
end_define

begin_comment
comment|/*  for arrays */
end_comment

begin_define
define|#
directive|define
name|Arrayaccfun
value|0
end_define

begin_comment
comment|/* register defines */
end_comment

begin_define
define|#
directive|define
name|FIXREG
value|d2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NPINREG
end_ifdef

begin_define
define|#
directive|define
name|_np
value|a2
end_define

begin_define
define|#
directive|define
name|_lbot
value|d3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PROF
end_ifdef

begin_expr_stmt
operator|.
name|set
name|indx
operator|,
literal|0
define|#
directive|define
name|Profile
define|\
value|lea	prbuf+indx,a0 \ 	.set 	indx,indx+4 \ 	jsr 	mcount
define|#
directive|define
name|Profile2
define|\
value|movl	a0,sp@-
name|lea
name|prbuf
operator|+
name|indx
operator|,
name|a0
name|\
operator|.
name|set
name|indx
operator|,
name|indx
operator|+
literal|4
expr|\
name|jsr
name|mcount
name|movl
name|sp
expr|@
operator|+
operator|,
name|a0
else|#
directive|else
define|#
directive|define
name|Profile
define|#
directive|define
name|Profile2
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PORTABLE
define|#
directive|define
name|NILtest
parameter_list|(
name|p
parameter_list|)
value|cmpl	#
comment|/**/
value|OFFSET,p
define|#
directive|define
name|NILsub
parameter_list|(
name|p
parameter_list|)
value|subl	#
comment|/**/
value|OFFSET,p
else|#
directive|else
define|#
directive|define
name|NILtest
parameter_list|(
name|p
parameter_list|)
define|#
directive|define
name|NILsub
parameter_list|(
name|p
parameter_list|)
endif|#
directive|endif
operator|.
name|text
comment|/*   transfer  table linkage routine  */
operator|.
name|globl
name|_qlinker
name|_qlinker
operator|:
name|Profile
name|link
name|a6
operator|,
operator|#
operator|-
literal|28
name|tstb
name|sp
expr|@
operator|(
operator|-
literal|132
operator|)
name|moveml
operator|#
literal|036000
operator|,
name|a6
expr|@
operator|(
operator|-
literal|28
operator|)
operator||
name|a
argument_list|(
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
name|tstl
name|_exception
operator||
name|any
name|pending
name|exceptions
name|jeq
name|noexc
name|tstl
name|_sigintcnt
operator||
name|is
name|it
name|because
name|of
name|SIGINT
name|jeq
name|noexc
operator||
end_expr_stmt

begin_if
if|if not
operator|,
name|just
name|leave
name|movl
operator|#
literal|2
operator|,
name|sp
expr|@
operator|-
operator||
else|else
name|push
name|SIGINT
name|jsr
name|_sigcall
name|noexc
range|:
name|movl
name|a6
expr|@
operator|(
literal|4
operator|)
decl_stmt|,
name|a4
decl||
name|get
decl|return
name|pc
name|movl
name|a4
decl|@
argument_list|(
operator|-
literal|6
argument_list|)
decl_stmt|,
name|a4
decl||
name|get
name|pointer
name|to
name|table
name|movl
name|a4
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|a5
decl||
name|get
name|atom
name|pointer
name|retry
range|:
operator||
name|come
name|here
name|after
name|undeffunc
name|err
name|movl
name|a5
expr|@
operator|(
literal|8
operator|)
decl_stmt|,
name|a0
decl||
name|get
name|function
name|binding
name|cmpl
name|a0
decl_stmt|,
name|d7
decl||if
name|nil
decl_stmt|,
name|jeq
name|nonex
decl||
name|then
name|leave
name|tstl
decl|2
modifier|*
decl|4+
name|_stattab
decl||
name|see
decl|if
name|linkin
name|posble
argument_list|(
name|Strans
argument_list|)
name|jeq
name|nolink
decl||
name|no
decl_stmt|,
name|it
name|isn
decl|'t 	movl	a0,d0				|check type of function 	NILsub(d0) 	moveq	#9,d1 	asrl	d1,d0 	lea	_typetable+1,a3 	movb	a3@(0,d0:L),d1 	cmpb	#/**/BCD,d1 	jeq	linkin				|bcd, link it in! 	cmpb	#/**/ARRAY,d1			|how about array? 	jeq	doarray				|yep  nolink: 	movl	a5,sp@-				|non, bcd, call interpreter 	jsr	_Ifuncal 	moveml	a6@(-28),#036000 	unlk	a6 	rts  /*  * handle arrays by pushing the array descriptor on the table and checking  * for a bcd array handler  */ doarray: 	movl	a0@(Arrayaccfun),d0		|get access func addr shifted 	NILsub(d0) 	movl	#9,d1 	asrl	d1,d0 	lea	_typetable+1,a3 	cmpb	#/**/BCD,a3@(0,d0:L)		|bcd?? 	jne	nolink				|no, let funcal handle it 	movl	a0,a2@+				|store array header on stack 	movl	a2,_np 	movl	a0@,a0				|movl *(a0),a0 on VAX 	movl	a0@,a0 	jsr	a0@ 	subql	#4,_np 	moveml	a6@(-28),#036000 	unlk	a6 	rts 	 	 linkin:	 	movl	a0@(4),d0			|check type of function discipline 	NILsub(d0) 	movl	#9,d1 	asrl	d1,d0 	lea	_typetable+1,a3 	cmpb	#/**/STRNG,a3@(0,d0:L)		|is it string? 	jeq	nolink				|yes, it is a c call, 						|so dont link in 	movl	a0@,a0				|get function addr 	movl	a0,a4@				|put fcn addr in table 	jbsr	a0@ 	moveml	a6@(-28),#036000 	unlk	a6 	rts   nonex:	movl	a4,sp@-				|preserve table address 	movl	a5,sp@-				|non existant fcn 	jsr	_Undeff				|call processor 	movl	d0,a5				|back in r1 	addql	#4,sp 	movl	sp@+,a4				|restore table address 	jra	retry				|for the retry.   	.data 	.globl	__erthrow __erthrow:  	.asciz	"Uncaught throw from compiled code" 	.text  	.globl _tynames _tynames: 	.long	_nilatom			|nothing here 	.long	20*4+_lispsys			|str_name 	.long	21*4+_lispsys			|atom_name 	.long	19*4+_lispsys			|int_name 	.long	23*4+_lispsys			|dtpr_name 	.long	22*4+_lispsys			|doub_name 	.long	58*4+_lispsys			|funct_name 	.long	103*4+_lispsys			|port_name 	.long	47*4+_lispsys			|array_name 	.long	_nilatom			|nothing here 	.long	50*4+_lispsys			|sdot_name 	.long	53*4+_lispsys			|val_nam  	.long	_nilatom			| hunk2_nam 	.long	_nilatom			| hunk4_nam 	.long	_nilatom			| hunk8_nam 	.long	_nilatom			| hunk16_nam 	.long	_nilatom			| hunk32_nam 	.long	_nilatom			| hunk64_nam 	.long	_nilatom			| hunk128_nam 	.long	124*4+_lispsys			|vector_nam 	.long	125*4+_lispsys			|vectori_nam  /*	Quickly allocate small fixnums  */  	.globl	_qnewint _qnewint: 	Profile 	cmpl	#1024,FIXREG 	bge	alloc 	cmpl	#-1024,FIXREG 	bmi	alloc 	movl	FIXREG,d0 	asll	#2,d0 	addl	#_Fixzero,d0 	rts alloc: 	movl	_int_str,a0			|move next cell addr to r0 	NILtest(a0) 	jmi	callnewi			|if no space, allocate 	movl	4*24+_lispsys,a1 	addql	#1,a1@				|inc count of ints 	movl	a0@,_int_str			|advance free list 	movl	FIXREG,a0@			|put baby to bed. 	movl	a0,d0 	rts callnewi: 	movl	FIXREG,sp@- 	movl	a2,_np				|gc could occur 	movl	a2,_lbot 	jsr	_newint 	movl	d0,a0 	movl	sp@+,a0@ 	rts  /*  _qoneplus adds one to the boxed fixnum in r0  * and returns a boxed fixnum.  */  	.globl	_qoneplus _qoneplus: 	Profile 	movl	a0@,FIXREG 	addql	#1,FIXREG 	bra	_qnewint  /* _qoneminus  subtracts one from the boxes fixnum in r0 and returns a  * boxed fixnum  */ 	.globl	_qoneminus _qoneminus: 	Profile 	movl	a0@,FIXREG 	subql	#1,FIXREG 	bra	_qnewint  /*  *	_qnewdoub quick allocation of a initialized double (float) cell.  *	This entry point is required by the compiler for symmetry reasons.  *	Passed to _qnewdoub in d0,d1 is a double precision floating point  *	number.  This routine allocates a new cell, initializes it with  *	the given value and then returns the cell.  */  	.globl	_qnewdoub      _qnewdoub: 	Profile 	movl	_doub_str,a0			|move next cell addr to r0 	NILtest(a0) 	jmi	callnewd			|if no space, allocate 	|incl	*_lispsys+30*4			|inc count of doubs 	lea	30*4+_lispsys,a1 	addl	#1,a1@ 	movl	a0@,_doub_str			|advance free list strdb: 	movl	d0,a0@				|put baby to bed. 	movl	d1,a0@(4)			|put baby to bed. 	rts  callnewd: 	movl	d0,sp@-				|stack initial value 	movl	d1,sp@-				|stack initial value 	movl	a2,_np				|gc could occur 	movl	a2,_lbot 	jsr	_newdoub 	movl	d0,a0 	movl	sp@+,d1				|restore initial value 	movl	sp@+,d0				|restore initial value 	bra	strdb    /*  * quick cons call, the car and cdr are stacked on the namestack  * and this function is jsb'
name|ed
name|to
operator|.
modifier|*
decl|/ 	.
name|globl
name|_qcons
name|_qcons
range|:
name|Profile
name|movl
name|_dtpr_str
decl_stmt|,
name|a0
decl||
name|move
name|next
name|cell
name|addr
name|to
name|a0
name|NILtest
argument_list|(
name|a0
argument_list|)
name|jmi
name|getnew
decl||if
name|ran
name|out
name|of
name|space
name|jump
name|movl
decl|28
modifier|*
decl|4+
name|_lispsys
decl_stmt|,
name|a1
decl||
name|inc
name|count
name|of
name|dtprs
name|addql
decl|#1
decl_stmt|,
name|a1
decl|@
name|movl
name|a0
decl|@
decl_stmt|,
name|_dtpr_str
decl||
name|advance
name|free
name|list
name|storit
range|:
name|movl
name|a2
expr|@
operator|-
decl_stmt|,
name|a0
decl|@			|
name|store
name|in
name|cdr
name|movl
name|a2
decl|@-
decl_stmt|,
name|a0
decl|@
argument_list|(
literal|4
argument_list|)
decl||
name|store
name|in
name|car
name|movl
name|a0
decl_stmt|,
name|d0
name|rts
name|getnew
range|:
name|movl
name|a2
decl_stmt|,
name|_np
name|jsr
name|_newdot
decl||
name|must
name|gc
name|to
name|get
name|one
name|jra
name|storit
decl||
name|now
name|initialize
name|it
operator|.
comment|/*  * Fast equivalent of newdot, entered by jsb  */
decl|.
name|globl
name|_qnewdot
name|_qnewdot
range|:
name|Profile
name|movl
name|_dtpr_str
decl_stmt|,
name|a0
decl||
name|mov
name|next
name|cell
name|addr
name|t0
name|r0
name|NILtest
argument_list|(
name|a0
argument_list|)
name|jmi
name|mustallo
decl||if
name|ran
name|out
name|of
name|space
name|movl
name|a0
decl_stmt|,
name|sp
decl|@-
name|movl
decl|28
modifier|*
decl|4+
name|_lispsys
decl_stmt|,
name|a0
decl||
name|inc
name|count
name|of
name|dtprs
name|addql
decl|#1
decl_stmt|,
name|a0
decl|@
name|movl
name|sp
decl|@+
decl_stmt|,
name|a0
name|movl
name|a0
decl|@
decl_stmt|,
name|_dtpr_str
decl||
name|advance
name|free
name|list
name|clrl
name|a0
decl|@				|
name|clrq
argument_list|(
name|r0
argument_list|)
name|clrl
name|a0
decl|@
argument_list|(
literal|4
argument_list|)
name|rts
name|mustallo
range|:
name|movl
name|a2
decl_stmt|,
name|_np
decl||
name|gc
name|could
name|occur
name|jsr
name|_newdot
name|rts
comment|/*  * this is called exactly like popnames would be from C  * but has been carefully improved so that it doesn't  * have to alter the stack.  */
operator|.
name|globl
name|_qpopnames
name|_qpopnames
range|:
name|movl
name|_bnp
decl_stmt|,
name|a1
name|movl
name|sp
decl_stmt|,
name|a0
name|movl
name|a0
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|d0
name|jra
operator|.
name|L130
operator|.
name|L20001
range|:
name|movl
name|a1
expr|@
operator|(
literal|4
operator|)
decl_stmt|,
name|a0
name|movl
name|a1
decl|@
decl_stmt|,
name|a0
decl|@ .
name|L130
range|:
name|subql
operator|#
literal|8
decl_stmt|,
name|a1
name|cmpl
name|a1
decl_stmt|,
name|d0
name|jls
operator|.
name|L20001
name|movl
name|a1
decl_stmt|,
name|_bnp
name|rts
comment|/*  * _qget : fast get subroutine  *  (get 'atom 'ind)  * called with a2@(-8) equal to the atom  *	       a2@(-4) equal to the indicator  * no assumption is made about _lbot  * unfortunately, the atom may not in fact be an atom, it may  * be a list or nil, which are special cases.  * For nil, we grab the nil property list (stored in a special place)  * and for lists we punt and call the C routine since it is  most likely  * and error and we havent put in error checks yet.  */
operator|.
name|globl
name|_qget
name|_qget
range|:
name|Profile
name|movl
name|a2
expr|@
operator|(
operator|-
literal|4
operator|)
decl_stmt|,
name|a1
decl||
name|put
name|indicator
name|in
name|a1
name|movl
name|a2
decl|@
argument_list|(
operator|-
literal|8
argument_list|)
decl_stmt|,
name|a0
decl||
name|and
name|atom
name|into
name|a0
name|cmpl
name|a0
decl_stmt|,
name|d7
name|jeq
name|nilpli
decl||
name|jump
decl|if
name|atom
name|is
name|nil
name|movl
name|a0
decl_stmt|,
name|d0
decl||
name|check
name|type
name|NILsub
argument_list|(
name|d0
argument_list|)
name|movl
decl|#9
decl_stmt|,
name|d1
name|asrl
name|d1
decl_stmt|,
name|d0
name|lea
name|_typetable
decl|+1
decl_stmt|,
name|a5
name|cmpb
decl|#
comment|/**/
name|ATOM
decl_stmt|,
name|a5
decl|@
argument_list|(
literal|0
argument_list|,
name|d0
operator|:
name|L
argument_list|)
decl||
name|is
name|it
name|a
name|symbol
decl|??
name|jne
name|notsymb
decl||
name|nope
name|movl
name|a0
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|a0
decl||
name|yes
decl_stmt|,
name|put
name|prop
name|list
name|in
decl||
name|a0
name|to
name|begin
name|scan
name|cmpl
name|a0
decl_stmt|,
name|d7
name|jeq
name|fail
decl||if
name|no
name|prop
name|list
decl_stmt|, 						|
name|we
name|lose
name|right
name|away
name|lp
range|:
name|cmpl
name|a0
expr|@
operator|(
literal|4
operator|)
decl_stmt|,
name|a1
decl||
name|is
name|car
name|of
name|list
init|=
name|to
name|indicator
condition|?
name|jeq
name|good
operator||
name|jump
end_if

begin_if
if|if so 	movl	a0@
operator|,
name|a0
operator||
else|else
name|cddr
name|movl
name|a0
expr|@
operator|,
name|a0
operator||
name|down
name|list
name|cmpl
name|a0
operator|,
name|d7
name|jne
name|lp
operator||
name|and
name|jump
end_if

begin_if
if|if more list to go.  fail:	movl	a0
operator|,
name|d0
name|subql
operator|#
literal|8
operator|,
name|a2
name|rts
operator||
end_if

begin_return
return|return
name|with
name|a0
name|eq
name|to
name|nil
name|good
operator|:
name|movl
name|a0
expr|@
operator|,
name|a0
operator||
end_return

begin_return
return|return
name|cadr
name|of
name|list
name|movl
name|a0
expr|@
operator|(
literal|4
operator|)
operator|,
name|d0
name|subql
operator|#
literal|8
operator|,
name|a2
name|rts
name|nilpli
operator|:
name|movl
literal|64
operator|*
literal|4
operator|+
name|_lispsys
operator|,
name|a0
operator||
name|want
name|nil
name|prop
name|list
operator|,
operator||
name|get
name|it
name|specially
name|cmpl
name|a0
operator|,
name|d7
name|jne
name|lp
operator||
name|and
name|process
end_return

begin_if
if|if anything there 	movl	a0
operator|,
name|d0
name|subql
operator|#
literal|8
operator|,
name|a2
name|rts
operator||
else|else
name|fail
name|notsymb
range|:
name|lea
name|a2
expr|@
operator|(
operator|-
literal|8
operator|)
decl_stmt|,
name|a0
decl||
name|set
name|up
name|lbot
name|before
name|callin
name|movl
name|a0
decl_stmt|,
name|_lbot
name|movl
name|a2
decl_stmt|,
name|_np
name|jsr
name|_Lget
decl||
name|not
name|a
name|symbol
decl_stmt|,
name|call
name|C
name|routine
decl||
name|to
name|error
name|check
name|subql
decl|#8
decl_stmt|,
name|a2
name|rts
decl||
name|and
decl|return
name|what
name|it
name|returned
operator|.
comment|/*  *  prunel  - return a list of dtpr cells to the free list  * this is called by the pruneb after it has discarded the top bignum   * the dtpr cells are linked through their cars not their cdrs.  * this returns with an rsb  *  * method of operation: the dtpr list we get is linked by car's so we  * go through the list and link it by cdr's, then have the last dtpr  * point to the free list and then make the free list begin at the  * first dtpr.  */
name|qprunel
range|:
name|movl
name|a0
decl_stmt|,
name|d0
decl||
name|remember
name|first
name|dtpr
name|location
name|movl
decl|28
modifier|*
decl|4+
name|_lispsys
decl_stmt|,
name|a1
decl||
name|dec
name|count
name|of
name|dtprs
name|rep
range|:
name|subql
operator|#
literal|1
decl_stmt|,
name|a2
decl|@
name|movl
name|a0
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|a0
decl|@			|
name|make
name|cdr
argument_list|(
name|forward
name|lnk
argument_list|)
decl|==
name|car
name|jeq
name|endoflist
decl||if
name|nil
decl_stmt|,
name|then
name|end
name|of
name|list
name|movl
name|a0
decl|@
decl_stmt|,
name|a0
decl||
name|advance
name|to
name|next
name|dtpr
name|jra
name|rep
decl||
name|and
name|loop
name|around
name|endoflist
range|:
name|movl
name|_dtpr_str
decl_stmt|,
name|a0
decl|@			|
name|make
name|last
decl|1
name|pnt
name|to
name|free
name|list
name|movl
name|d0
decl_stmt|,
name|_dtpr_str
decl||
modifier|&
name|free
name|list
name|begin
name|at
decl|1st
name|one
name|rts
comment|/*  * qpruneb - called by the arithmetic routines to free an sdot and the dtprs  * which hang on it.  * called by  *	pushl	sdotaddr  *	jsb	_qpruneb  */
operator|.
name|globl
name|_qpruneb
name|_qpruneb
range|:
name|Profile
name|movl
literal|48
operator|*
literal|4
operator|+
name|_lispsys
decl_stmt|,
name|a0
decl||
name|decr
name|count
name|of
name|used
name|sdots
name|subql
decl|#1
decl_stmt|,
name|a0
decl|@
name|movl
name|sp
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|a0
decl||
name|get
name|address
name|movl
name|_sdot_str
decl_stmt|,
name|a0
decl|@			|
name|have
name|new
name|sdot
name|pnt
name|to
name|free
name|lst
name|movl
name|a0
decl_stmt|,
name|_sdot_str
decl||
name|strt
name|free
name|list
name|at
name|new
name|sdot
name|movl
name|a0
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|a0
decl||
name|get
name|address
name|of
name|first
name|dtpr
name|jne
name|qprunel
decl||if
name|exists
decl_stmt|,
name|prune
name|it
name|rts
decl||else return.
comment|/*  * _qprunei 	   *	called by the arithmetic routines to free a fixnum cell  * calling sequence  *	pushl	fixnumaddr  *	jsb	_qprunei  */
decl|.
name|globl
name|_qprunei
name|_qprunei
range|:
name|Profile
name|movl
name|a1
decl_stmt|,
name|sp
decl|@-
name|movl
name|sp
decl|@
argument_list|(
literal|4
argument_list|)
decl_stmt|,
name|a0
decl||
name|get
name|address
name|of
name|fixnum
name|cmpl
decl|#4
modifier|*
decl|1023+
name|_Fixzero
decl_stmt|,
name|a0
decl||
name|is
name|it
name|a
name|small
name|fixnum
name|jmi
name|skipit
decl||if
name|so
decl_stmt|,
name|leave
name|movl
decl|24
modifier|*
decl|4+
name|_lispsys
decl_stmt|,
name|a1
decl||
name|decr
name|count
name|of
name|used
name|ints
name|subql
decl|#1
decl_stmt|,
name|a1
decl|@
name|movl
name|_int_str
decl_stmt|,
name|a0
decl|@			|
name|link
name|the
name|fixnum
name|into
name|the
decl||
name|free
name|list
name|movl
name|a0
decl_stmt|,
name|_int_str
name|skipit
range|:
name|movl
name|sp
expr|@
operator|+
decl_stmt|,
name|a1
name|rts
name|Iclear
range|:
name|clrl
name|d0
name|rts
operator|.
name|text
operator|.
name|globl
name|_Itstbt
name|_Itstbt
operator|:
name|movl
name|a5
decl_stmt|,
name|d1
name|NILsub
argument_list|(
name|d1
argument_list|)
name|lsrl
decl|#2
decl_stmt|,
name|d1
name|movl
name|d1
decl_stmt|,
name|d0
name|andl
decl|#7
decl_stmt|,
name|d0
name|lsrl
decl|#3
decl_stmt|,
name|d1
name|lea
name|_bitmapi
decl_stmt|,
name|a0
name|bset
name|d0
decl_stmt|,
name|a0
decl|@
argument_list|(
literal|0
argument_list|,
name|d1
operator|:
name|L
argument_list|)
name|beq
operator|.
name|L14
name|moveq
decl|#1
decl_stmt|,
name|d0
name|bra
operator|.
name|L12
operator|.
name|L14
range|:
name|clrl
name|d0
operator|.
name|L12
operator|:
name|rts
comment|/*  * this routine returns an assembly language entry pt.  * it is put here to match the vax verison.  */
operator|.
name|globl
name|_gstart
operator|.
name|globl
name|_proflush
name|_gstart
operator|:
name|movl
operator|#
name|start
decl_stmt|,
name|d0
name|_proflush
range|:
name|rts
comment|/*  * The definition of mcount must be present even when the C code  * isn't being profiled, since lisp code may reference it.  */
operator|.
name|globl
name|_mcount
ifdef|#
directive|ifdef
name|SunGotItsActTogetherAboutTakingMcountOutOfCrt0
operator|.
name|globl
name|mcount
endif|#
directive|endif
name|_mcount
operator|:
name|mcount
operator|:
ifdef|#
directive|ifdef
name|PROF
name|movl
name|a0
expr|@
decl_stmt|,
name|a1
name|jne
name|incr
name|movl
name|_countbase
decl_stmt|,
name|a1
name|jeq
decl|return
name|addql
decl|#8
decl_stmt|,
name|_countbase
name|movl
name|sp
decl|@
decl_stmt|,
name|a1
decl|@+
name|movl
name|a1
decl_stmt|,
name|a0
decl|@
name|incr
range|:
name|addql
operator|#
literal|1
decl_stmt|,
name|a1
decl|@ return
range|:
endif|#
directive|endif
name|rts
comment|/*  * pushframe : stack a frame   * When this is called, the optional arguments and class have already been  * pushed on the stack as well as the return address (by virtue of the jsb)  * , we push on the rest of the stuff (see h/frame.h)  * for a picture of the save frame  */
operator|.
name|globl
name|_pushframe
operator|.
name|globl
name|_qpushframe
operator|.
name|globl
name|_Pushframe
name|_pushframe
operator|:
name|_qpushframe
operator|:
name|_Pushframe
operator|:
name|movl
name|sp
expr|@
decl_stmt|,
name|a0
name|movl
name|_errp
decl_stmt|,
name|sp
decl|@-
name|movl
name|_bnp
decl_stmt|,
name|sp
decl|@-
name|movl
name|_np
decl_stmt|,
name|sp
decl|@-
name|movl
name|_lbot
decl_stmt|,
name|sp
decl|@-
name|movl
name|sp
decl_stmt|,
name|d0
decl|| return
name|addr
name|of
name|lbot
name|on
name|stack
name|subl
decl|#56
decl_stmt|,
name|sp
name|moveml
decl|#0x7cfc
decl_stmt|,
name|sp
decl|@
argument_list|(
literal|12
argument_list|)
decl||
name|save
name|fp
decl_stmt|,
name|a5
decl|-
name|a2
decl_stmt|,
name|d7
decl|-
name|d2
name|clrl
name|_retval
decl||
name|set
name|retval
name|to
name|C_INITIAL
name|jmp
name|a0
decl|@		| return
name|through
decl|return
name|address
comment|/*  * qretfromfr  * called with frame to ret to in a5.  The popnames has already been done.  * we must restore all registers, and jump to the ret addr. the popping  * must be done without reducing the stack pointer since an interrupt  * could come in at any time and this frame must remain on the stack.  * thus we can't use popr.  */
operator|.
name|globl
name|_qretfromfr
name|_qretfromfr
range|:
name|movl
name|a5
decl_stmt|,
name|d0
decl|| return
name|error
name|frame
name|location
name|movl
name|a5
decl_stmt|,
name|a0
decl||
name|prepare
name|to
name|pop
name|off
name|moveml
name|a0
decl|@
argument_list|(
operator|-
literal|44
argument_list|)
decl_stmt|,#0x7cfc	|
name|restore
name|registers
name|lea
name|a0
decl|@
argument_list|(
operator|-
literal|56
argument_list|)
decl_stmt|,
name|sp
name|movl
name|a0
decl|@+
decl_stmt|,
name|_lbot
name|movl
name|a0
decl|@+
decl_stmt|,
name|_np
name|movl
name|a0
decl|@
argument_list|(
literal|8
argument_list|)
decl_stmt|,
name|a0
decl|| return
name|address
name|jmp
name|a0
decl|@
comment|/* This must be at the end of the file.  If we are profiling, allocate  * space for the profile buffer  */
ifdef|#
directive|ifdef
name|PROF
decl|.
name|data
operator|.
name|comm
name|_countbase
decl_stmt|,4 	.
name|lcomm
name|prbuf
decl_stmt|,
name|indx
decl|+4 	.
name|text
end_if

begin_endif
endif|#
directive|endif
end_endif

end_unit

