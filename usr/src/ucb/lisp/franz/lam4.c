begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: lam4.c,v 1.5 83/12/28 16:21:08 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sun Jun 19 22:25:48 1983 by jkf]-  * 	lam4.c				$Locker:  $  * lambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_decl_stmt
name|lispval
name|adbig
argument_list|()
decl_stmt|,
name|subbig
argument_list|()
decl_stmt|,
name|mulbig
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|double
name|Ifloat
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|lispval
name|Ladd
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|result
decl_stmt|,
modifier|*
name|mynp
decl_stmt|,
modifier|*
name|oldnp
decl_stmt|;
name|long
name|restype
decl_stmt|,
name|prunep
decl_stmt|,
name|hi
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
comment|/* now start as integers */
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
literal|1L
argument_list|,
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
comment|/* In adding the fixnum to the sdot we may make it 		    possible for the bignum to be represented as a fixnum */
break|break;
case|case
name|INT
case|:
if|if
condition|(
name|exarith
argument_list|(
name|lo
argument_list|,
literal|1L
argument_list|,
name|work
operator|->
name|i
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|hi
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|)
expr_stmt|;
goto|goto
name|code1
goto|;
case|case
name|SDOT
case|:
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* previous result is no longer needed */
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|code1
label|:
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* SDOT or INT */
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
name|lispval
name|handy
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|handy
operator|=
name|adbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|handy
expr_stmt|;
block|}
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|+
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|flacc
operator|=
name|work
operator|->
name|r
operator|+
name|lo
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|+=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to add"
argument_list|,
name|nil
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
break|break;
case|case
name|INT
case|:
name|work
operator|=
name|inewint
argument_list|(
name|lo
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
comment|/* wouldn't (copy result->val) be faster ? -dhl */
comment|/* It might, but isn't guaranteed to canonicalize */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in add "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_comment
comment|/* exarith(a,b,c,lo,hi)  * int a,b,c;  * int *lo, *hi;  * Exact arithmetic.  * a,b and c are 32 bit 2's complement integers  * calculates x=a*b+c to twice the precision of an int.  * In the vax version, the 30 low bits only are returned  * in *lo,and the next 32 bits of precision are returned in * hi.  * this works since exarith is used either for calculating the sum of  * two 32 bit numbers, (which is at most 33 bits), or  * multiplying a 30 bit number by a 32 bit numbers,  * which has a maximum precision of 62 bits.  * If *phi is 0 or -1 then  * x doesn't need any more than 31 bits plus sign to describe, so we  * place the sign in the high two bits of *plo and return 0 from this  * routine.  A non zero return indicates that x requires more than 31 bits  * to describe.  *  * The definition has been moved to vax.c.  */
end_comment

begin_function
name|lispval
name|Lsub
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|result
decl_stmt|,
modifier|*
name|mynp
decl_stmt|,
modifier|*
name|oldnp
decl_stmt|;
name|long
name|prunep
decl_stmt|,
name|restype
decl_stmt|,
name|hi
decl_stmt|,
name|lo
init|=
literal|0
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|lispval
name|Lminus
parameter_list|()
function_decl|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|mynp
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|oldnp
operator|==
name|lbot
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|oldnp
operator|==
name|mynp
condition|)
block|{
name|work
operator|=
name|Lminus
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
comment|/* examine the first argument and perhaps set restype to the  	 * correct type.  If restype (result type) is INT, then the 	 * fixnum value is stored in lo.  Otherwise, if restype is  	 * SDOT or DOUB, then the value is stored in result->val. 	 */
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
comment|/* we want to copy the sdot we are given as an argument since 		 * the bignum arithmetic routine dmlad clobbers the values it 		 * is given. 		 */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
comment|/* create a zero sdot */
name|dummybig
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|)
expr_stmt|;
comment|/* the resulting value may have been reduced from an 		 * sdot to a fixnum.  This should never happen though 		 * but if it does, we simplify things. 		 */
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
comment|/* has turned into an fixnum */
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* return fixnum cell	     */
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|work
operator|->
name|r
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
block|}
comment|/* now loop through the rest of the arguments subtracting them 	 * from the running result in result or lo 	 */
for|for
control|(
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* subtracting a fixnum from an bignum 				 * use the distructive multiply (by 1) 				 * and add the negative of the work value. 				 * The result will still be pointed to 				 * by result->val 				 */
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
literal|1L
argument_list|,
operator|-
name|work
operator|->
name|i
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
comment|/* check up on exiting */
break|break;
comment|/* that it didn't collapse */
case|case
name|INT
case|:
comment|/* subtracting a fixnum from a fixnum, 				 * the result could turn into a bignum 				 */
if|if
condition|(
name|exarith
argument_list|(
name|lo
argument_list|,
literal|1L
argument_list|,
operator|-
name|work
operator|->
name|i
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|hi
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
comment|/* subtracting a fixnum from a flonum */
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
comment|/* subtracting a bignum from an integer 			     * first make a bignum of the integer and 			     * then fall into the next case 			     */
name|dummybig
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|work
operator|=
name|subbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
case|case
name|SDOT
case|:
comment|/* subtracting one bignum from another.  The 			     * routine to do this ends up calling addbig 			     * and should probably be written specifically 			     * for subtraction. 			     */
name|work
operator|=
name|subbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|on1
label|:
comment|/* check if the result has turned into a fixnum */
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
comment|/* it has */
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
comment|/* Subtract bignum from float */
comment|/* Death on overflow 	 */
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* subtracting a flonum from a bignum. */
if|if
condition|(
name|prunep
condition|)
block|{
name|lispval
name|handy
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|handy
operator|=
name|adbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|handy
expr_stmt|;
block|}
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|-
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
comment|/* subtracting a flonum from an fixnum.  				 * The result will be an flonum. 				 */
name|flacc
operator|=
name|lo
operator|-
name|work
operator|->
name|r
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
comment|/* subtracting a flonum from a flonum, what 				 * could be easier? 				 */
name|result
operator|->
name|val
operator|->
name|r
operator|-=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to minus"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
break|break;
case|case
name|INT
case|:
name|work
operator|=
name|inewint
argument_list|(
name|lo
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in difference"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltimes
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|result
decl_stmt|,
modifier|*
name|mynp
decl_stmt|,
modifier|*
name|oldnp
decl_stmt|;
name|long
name|restype
decl_stmt|,
name|prunep
decl_stmt|,
name|hi
decl_stmt|,
name|lo
init|=
literal|1
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
comment|/* now start as integers */
name|prunep
operator|=
name|TRUE
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
for|for
control|(
name|mynp
operator|=
name|lbot
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
name|dmlad
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
operator|->
name|i
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
comment|/* In adding the fixnum to the sdot we may make it 		    possible for the bignum to be represented as a fixnum */
break|break;
case|case
name|INT
case|:
if|if
condition|(
name|exarith
argument_list|(
name|lo
argument_list|,
name|work
operator|->
name|i
argument_list|,
literal|0L
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|)
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|I
operator|=
name|hi
expr_stmt|;
name|work
operator|->
name|s
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|restype
operator|=
name|SDOT
expr_stmt|;
name|prunep
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|lo
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|mulbig
argument_list|(
name|work
argument_list|,
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|)
expr_stmt|;
goto|goto
name|code1
goto|;
case|case
name|SDOT
case|:
name|work
operator|=
name|mulbig
argument_list|(
name|work
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* previous result is no longer needed */
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|code1
label|:
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* SDOT or INT */
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
name|lo
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prunep
operator|=
name|FALSE
expr_stmt|;
comment|/* sdot is cannonical */
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
name|lispval
name|handy
decl_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|handy
operator|=
name|adbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|handy
expr_stmt|;
block|}
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|*
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|flacc
operator|=
name|work
operator|->
name|r
operator|*
name|lo
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|*=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to add"
argument_list|,
name|nil
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|DOUB
case|:
break|break;
case|case
name|INT
case|:
name|work
operator|=
name|inewint
argument_list|(
name|lo
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
if|if
condition|(
name|prunep
condition|)
block|{
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
name|work
operator|=
name|adbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|urk
label|:
name|error
argument_list|(
literal|"Internal error in times"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lquo
parameter_list|()
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|result
decl_stmt|,
modifier|*
name|mynp
decl_stmt|,
modifier|*
name|oldnp
decl_stmt|;
name|int
name|restype
decl_stmt|;
name|lispval
name|quotient
decl_stmt|;
name|double
name|flacc
decl_stmt|;
name|struct
name|sdot
name|dummybig
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|oldnp
operator|=
name|result
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|mynp
operator|=
name|lbot
operator|+
literal|1
expr_stmt|;
name|restype
operator|=
name|INT
expr_stmt|;
name|dummybig
operator|.
name|I
operator|=
literal|1
expr_stmt|;
name|dummybig
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|oldnp
operator|==
name|lbot
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|oldnp
operator|==
name|mynp
condition|)
name|mynp
operator|=
name|lbot
expr_stmt|;
else|else
block|{
comment|/* examine the first argument and perhaps set restype to the  	     * correct type.  If restype (result type) is INT, then the 	     * fixnum value is stored in lo.  Otherwise, if restype is  	     * SDOT or DOUB, then the value is stored in result->val. 	     */
name|work
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
comment|/* we want to copy the sdot we are given as an argument since 		 * the bignum divide routine divbig expects an argument in 		 * canonical form. 		 */
name|dummybig
operator|.
name|I
operator|=
literal|0
expr_stmt|;
comment|/* create a zero sdot */
name|work
operator|=
name|adbig
argument_list|(
name|work
argument_list|,
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TYPE
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
comment|/* Either INT or SDOT */
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
comment|/* has turned into an fixnum */
name|prunei
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* return fixnum cell	     */
block|}
else|else
block|{
name|result
operator|->
name|val
operator|=
name|work
expr_stmt|;
block|}
break|break;
case|case
name|DOUB
case|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|work
operator|->
name|r
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #1: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
block|}
comment|/* now loop through the rest of the arguments dividing them 	 * into the running result in result or dummybig.I 	 */
for|for
control|(
init|;
name|mynp
operator|<
name|oldnp
condition|;
name|mynp
operator|++
control|)
block|{
name|work
operator|=
name|mynp
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
if|if
condition|(
name|work
operator|->
name|i
operator|==
literal|0
condition|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
literal|8
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* there is no fast routine to destructively 				   divide a bignum by an int, so do it the 				   hard way. */
name|dummybig
operator|.
name|I
operator|=
name|work
operator|->
name|i
expr_stmt|;
name|divbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
operator|&
name|quotient
argument_list|,
operator|(
name|lispval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|on1
label|:
comment|/* check if the result has turned into a fixnum */
name|restype
operator|=
name|TYPE
argument_list|(
name|quotient
argument_list|)
expr_stmt|;
if|if
condition|(
name|restype
operator|==
name|INT
condition|)
block|{
comment|/* Either INT or SDOT */
name|dummybig
operator|.
name|I
operator|=
name|quotient
operator|->
name|i
expr_stmt|;
comment|/* has turned into an fixnum */
name|prunei
argument_list|(
name|quotient
argument_list|)
expr_stmt|;
comment|/* return fixnum cell	     */
block|}
else|else
name|result
operator|->
name|val
operator|=
name|quotient
expr_stmt|;
break|break;
case|case
name|INT
case|:
comment|/* divide int by int */
name|dummybig
operator|.
name|I
operator|/=
name|work
operator|->
name|i
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|result
operator|->
name|val
operator|->
name|r
operator|/=
name|work
operator|->
name|i
expr_stmt|;
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #2: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|SDOT
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|INT
case|:
comment|/* Although it seems that dividing an int 		     * by a bignum can only lead to zero, it is 		     * concievable that the bignum is improperly boxed, 		     * i.e. actually an int. 		     */
name|divbig
argument_list|(
operator|(
name|lispval
operator|)
operator|&
name|dummybig
argument_list|,
name|work
argument_list|,
operator|&
name|quotient
argument_list|,
operator|(
name|lispval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
case|case
name|SDOT
case|:
comment|/* dividing one bignum by another. */
name|divbig
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|work
argument_list|,
operator|&
name|quotient
argument_list|,
operator|(
name|lispval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|on1
goto|;
case|case
name|DOUB
case|:
comment|/* dividing a bignum into a flonum. 		     */
name|result
operator|->
name|val
operator|->
name|r
operator|/=
name|Ifloat
argument_list|(
name|work
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #3: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
break|break;
case|case
name|DOUB
case|:
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
comment|/* Divide bignum by flonum converting to flonum 			    * May die due to overflow */
name|flacc
operator|=
name|Ifloat
argument_list|(
name|result
operator|->
name|val
argument_list|)
operator|/
name|work
operator|->
name|r
expr_stmt|;
name|pruneb
argument_list|(
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
name|scrimp
label|:
operator|(
name|result
operator|->
name|val
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|flacc
expr_stmt|;
name|restype
operator|=
name|DOUB
expr_stmt|;
break|break;
case|case
name|INT
case|:
comment|/* dividing a flonum into a fixnum.  			   * The result will be a flonum. */
name|flacc
operator|=
operator|(
operator|(
name|double
operator|)
name|dummybig
operator|.
name|I
operator|)
operator|/
name|work
operator|->
name|r
expr_stmt|;
goto|goto
name|scrimp
goto|;
case|case
name|DOUB
case|:
comment|/* dividing a flonum into a flonum, what 			    * could be easier? 			    */
name|result
operator|->
name|val
operator|->
name|r
operator|/=
name|work
operator|->
name|r
expr_stmt|;
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #4: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
goto|goto
name|urk
goto|;
block|}
break|break;
default|default:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-number to quotient "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SDOT
case|:
case|case
name|DOUB
case|:
break|break;
case|case
name|INT
case|:
name|work
operator|=
name|inewint
argument_list|(
name|dummybig
operator|.
name|I
argument_list|)
expr_stmt|;
break|break;
default|default:
name|urk
label|:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Internal quotient error #5: "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfp
parameter_list|()
block|{
specifier|register
name|temp
operator|=
literal|0
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"+: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
name|temp
operator|+=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfm
parameter_list|()
block|{
specifier|register
name|temp
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"-: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|lbot
operator|+
literal|1
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
operator|-
name|temp
argument_list|)
operator|)
return|;
for|for
control|(
name|argp
operator|=
name|lbot
operator|+
literal|1
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"-: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
name|temp
operator|-=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lft
parameter_list|()
block|{
specifier|register
name|temp
operator|=
literal|1
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
for|for
control|(
name|argp
operator|=
name|lbot
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"*: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
name|temp
operator|*=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lflessp
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
init|=
name|lbot
decl_stmt|;
specifier|register
name|old
operator|,
name|new
expr_stmt|;
if|if
condition|(
name|np
operator|<
name|argp
operator|+
literal|2
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|old
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
name|argp
operator|++
expr_stmt|;
for|for
control|(
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"<: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|new
operator|=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|old
operator|<
name|new
operator|)
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|old
operator|=
name|new
expr_stmt|;
block|}
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfd
parameter_list|()
block|{
specifier|register
name|temp
operator|=
literal|0
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|1
argument_list|)
operator|)
return|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"/: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|lbot
operator|+
literal|1
operator|==
name|np
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|1
operator|/
name|temp
argument_list|)
operator|)
return|;
for|for
control|(
name|argp
operator|=
name|lbot
operator|+
literal|1
init|;
name|argp
operator|<
name|np
condition|;
name|argp
operator|++
control|)
if|if
condition|(
name|TYPE
argument_list|(
name|argp
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"/: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|argp
operator|->
name|val
argument_list|)
expr_stmt|;
else|else
name|temp
operator|/=
name|argp
operator|->
name|val
operator|->
name|i
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfadd1
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"1+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"1+: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lfexpt	(^ 'x_a 'x_b)  *   exponentiation of fixnums x_a and x_b returning a fixnum  * result  */
end_comment

begin_function
name|lispval
name|Lfexpt
parameter_list|()
block|{
specifier|register
name|int
name|base
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
specifier|register
name|int
name|res
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
operator|||
operator|(
name|TYPE
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
operator|!=
name|INT
operator|)
condition|)
name|errorh2
argument_list|(
name|Vermisc
argument_list|,
literal|"^: non fixnum arguments"
argument_list|,
name|nil
argument_list|,
literal|0
argument_list|,
name|lbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|base
operator|=
name|lbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|exp
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
comment|/* 0^0 == 1,  0 to any other power (even negative powers) 	 *  is zero (according to Maclisp) 	 */
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
return|return
operator|(
name|inewint
argument_list|(
literal|1
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
literal|1
condition|)
comment|/* 	 *  1 to any power is 1 	 */
return|return
operator|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
operator|)
return|;
comment|/* == 1 */
elseif|else
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
comment|/* 	 * anything to the zero power is 1 	 */
return|return
operator|(
name|inewint
argument_list|(
literal|1
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|base
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 	 * -1 to an even power is 1, to an odd is -1 	 */
if|if
condition|(
name|exp
operator|&
literal|1
condition|)
return|return
operator|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
operator|)
return|;
else|else
return|return
operator|(
name|inewint
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
comment|/* 	 * anything not 0,-1,or 1  to a negative power is 0 	 * 	 */
return|return
operator|(
name|inewint
argument_list|(
literal|0
argument_list|)
operator|)
return|;
comment|/* compute exponentiation.  This should check for overflows,        I suppose. --jkf      */
name|res
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|exp
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|exp
operator|&
literal|1
condition|)
block|{
comment|/* odd, just multiply by one */
name|res
operator|=
name|res
operator|*
name|base
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* even, square base */
name|base
operator|=
name|base
operator|*
name|base
expr_stmt|;
name|exp
operator|=
name|exp
operator|/
literal|2
expr_stmt|;
block|}
block|}
return|return
operator|(
name|inewint
argument_list|(
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfsub1
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"1-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"1-: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ldbtofl
parameter_list|()
block|{
name|float
name|x
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"double-to-float"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|DOUB
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"double-to-float: non flonum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|lbot
operator|->
name|val
operator|->
name|r
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
operator|*
operator|(
name|long
operator|*
operator|)
operator|&
name|x
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lfltodb
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"float-to-double"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"float-to-double: non fixnum argument "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|handy
operator|=
name|newdoub
argument_list|()
expr_stmt|;
name|handy
operator|->
name|r
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|lbot
operator|->
name|val
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

end_unit

