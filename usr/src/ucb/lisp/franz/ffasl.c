begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /na/franz/franz/RCS/ffasl.c,v 1.2 83/02/01 16:14:24 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 12:42:10 1983 by jkf]-  * 	ffasl.c				$Locker:  $  * dynamically load C code  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"naout.h"
end_include

begin_define
define|#
directive|define
name|round
parameter_list|(
name|x
parameter_list|,
name|s
parameter_list|)
value|((((x)-1)& ~((s)-1)) + (s))
end_define

begin_decl_stmt
name|char
modifier|*
name|stabf
init|=
literal|0
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|fvirgin
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|seed
operator|=
literal|0
operator|,
name|mypid
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|myname
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|lispval
name|verify
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* dispget - get discipline of function  * this is used to handle the tricky defaulting of the discipline  * field of such functions as cfasl and getaddress.  * dispget is given the value supplied by the caller,  *	the error message to print if something goes wrong,  *	the default to use if nil was supplied.  * the discipline can be an atom or string.  If an atom it is supplied  * it must be lambda, nlambda or macro.  Otherwise the atoms pname  * is used.  */
end_comment

begin_function
name|lispval
name|dispget
parameter_list|(
name|given
parameter_list|,
name|messg
parameter_list|,
name|defult
parameter_list|)
name|lispval
name|given
decl_stmt|,
name|defult
decl_stmt|;
name|char
modifier|*
name|messg
decl_stmt|;
block|{
name|int
name|typ
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|given
operator|==
name|nil
condition|)
return|return
operator|(
name|defult
operator|)
return|;
if|if
condition|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|given
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
block|{
if|if
condition|(
name|given
operator|==
name|lambda
operator|||
name|given
operator|==
name|nlambda
operator|||
name|given
operator|==
name|macro
condition|)
return|return
operator|(
name|given
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|lispval
operator|)
name|given
operator|->
name|a
operator|.
name|pname
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|typ
operator|==
name|STRNG
condition|)
return|return
operator|(
name|given
operator|)
return|;
name|given
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
name|messg
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|given
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|lispval
name|Lcfasl
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mlbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|int
name|fildes
decl_stmt|,
name|totsize
decl_stmt|;
name|int
name|readsize
decl_stmt|;
name|lispval
name|csegment
parameter_list|()
function_decl|;
name|char
modifier|*
name|sbrk
argument_list|()
decl_stmt|,
modifier|*
name|currend
decl_stmt|,
modifier|*
name|tfile
decl_stmt|,
name|cbuf
index|[
literal|6000
index|]
decl_stmt|,
modifier|*
name|mytemp
argument_list|()
decl_stmt|,
modifier|*
name|gstab
argument_list|()
decl_stmt|;
name|char
name|ostabf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|exec
name|header
decl_stmt|;
name|char
modifier|*
name|largs
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|3
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* no discipline given */
case|case
literal|4
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
comment|/* no library given  */
block|}
name|chkarg
argument_list|(
literal|5
argument_list|,
literal|"cfasl"
argument_list|)
expr_stmt|;
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
operator|=
name|verify
argument_list|(
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
literal|"Incorrect .o file specification"
argument_list|)
expr_stmt|;
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|verify
argument_list|(
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"Incorrect entry specification for cfasl"
argument_list|)
expr_stmt|;
name|mlbot
index|[
literal|3
index|]
operator|.
name|val
operator|=
name|dispget
argument_list|(
name|mlbot
index|[
literal|3
index|]
operator|.
name|val
argument_list|,
literal|"Incorrect discipline specification for cfasl"
argument_list|,
operator|(
name|lispval
operator|)
name|Vsubrou
operator|->
name|a
operator|.
name|pname
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
operator|!=
name|ATOM
condition|)
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad associated atom name for fasl"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|work
operator|=
name|mlbot
index|[
literal|4
index|]
operator|.
name|val
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|nil
condition|)
name|largs
operator|=
literal|0
expr_stmt|;
else|else
name|largs
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
name|work
argument_list|,
literal|"Bad loader flags"
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke loader. 	 */
name|strcpy
argument_list|(
name|ostabf
argument_list|,
name|gstab
argument_list|()
argument_list|)
expr_stmt|;
name|currend
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
comment|/*** UNIX cfasl code ***/
name|tfile
operator|=
name|mytemp
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"/usr/lib/lisp/nld -N -x -A %s -T %x %s -e %s -o %s %s -lc"
argument_list|,
name|ostabf
argument_list|,
name|currend
argument_list|,
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|tfile
argument_list|,
name|largs
argument_list|)
expr_stmt|;
comment|/* if nil don't print cfasl/nld message */
if|if
condition|(
name|Vldprt
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|system
argument_list|(
name|cbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|ungstab
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ld returns error status\n"
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
if|if
condition|(
name|fvirgin
condition|)
name|fvirgin
operator|=
literal|0
expr_stmt|;
else|else
name|unlink
argument_list|(
name|ostabf
argument_list|)
expr_stmt|;
name|stabf
operator|=
name|tfile
expr_stmt|;
if|if
condition|(
operator|(
name|fildes
operator|=
name|open
argument_list|(
name|tfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't open temporary file: %s\n"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
comment|/* 	 * Read a.out header to find out how much room to 	 * allocate and attempt to do so. 	 */
if|if
condition|(
name|read
argument_list|(
name|fildes
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|readsize
operator|=
name|round
argument_list|(
name|header
operator|.
name|a_text
argument_list|,
literal|4
argument_list|)
operator|+
name|round
argument_list|(
name|header
operator|.
name|a_data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|totsize
operator|=
name|readsize
operator|+
name|header
operator|.
name|a_bss
expr_stmt|;
name|totsize
operator|=
name|round
argument_list|(
name|totsize
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up system indicators, typing info, etc. 	 */
name|currend
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|OTHER
argument_list|,
name|totsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|readsize
operator|!=
name|read
argument_list|(
name|fildes
argument_list|,
name|currend
argument_list|,
name|readsize
argument_list|)
condition|)
block|{
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|work
operator|=
name|newfunct
argument_list|()
expr_stmt|;
name|work
operator|->
name|bcd
operator|.
name|start
operator|=
operator|(
name|lispval
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|header
operator|.
name|a_entry
expr_stmt|;
name|work
operator|->
name|bcd
operator|.
name|discipline
operator|=
name|mlbot
index|[
literal|3
index|]
operator|.
name|val
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|work
operator|)
return|;
else|#
directive|else
comment|/*** VMS cfasl code ***/
block|{
name|int
name|pid
init|=
name|getpid
argument_list|()
operator|&
literal|0xffff
decl_stmt|;
comment|/* Our process ID number */
name|char
name|objfil
index|[
literal|100
index|]
decl_stmt|;
comment|/* Absolute object file name */
name|char
name|symfil
index|[
literal|100
index|]
decl_stmt|;
comment|/* Old symbol table file */
name|char
name|filename
index|[
literal|100
index|]
decl_stmt|;
comment|/* Random filename buffer */
name|int
name|strlen
parameter_list|()
function_decl|;
comment|/* String length function */
name|int
name|cvt_unix_to_vms
parameter_list|()
function_decl|;
comment|/* Convert UNIX to VMS filename */
name|lispval
name|Lgetaddress
argument_list|()
decl_stmt|,
name|matom
argument_list|()
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|largs
operator|==
literal|0
condition|)
name|largs
operator|=
literal|" "
expr_stmt|;
name|sprintf
argument_list|(
name|objfil
argument_list|,
literal|"tmp:cfasl%d.tmp"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|symfil
index|[
name|cvt_unix_to_vms
argument_list|(
name|ostabf
argument_list|,
name|symfil
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|cbuf
argument_list|,
comment|/* Create link cmd. */
literal|"$ link/exe=%s/nom/syst=%%X%x/sym=tmp:sym%d.new %s,%s%s"
argument_list|,
name|objfil
argument_list|,
name|currend
argument_list|,
name|pid
argument_list|,
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
name|symfil
argument_list|,
name|largs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
comment|/* Echo link cmd. */
literal|"$ link/exe=%s/nomap/system=%%X%x/symbol_table=tmp:sym%d.new %s,%s%s\n"
argument_list|,
name|objfil
argument_list|,
name|currend
argument_list|,
name|pid
argument_list|,
name|mlbot
index|[
literal|0
index|]
operator|.
name|val
argument_list|,
name|symfil
argument_list|,
name|largs
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vms_system
argument_list|(
name|cbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fildes
operator|=
name|open
argument_list|(
name|objfil
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* Open abs file */
block|{
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
name|fstat
argument_list|(
name|fildes
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
comment|/* Get its size */
name|readsize
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|currend
operator|=
operator|(
name|char
operator|*
operator|)
name|csegment
argument_list|(
name|OTHER
argument_list|,
name|readsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|readsize
operator|=
name|read
argument_list|(
name|fildes
argument_list|,
name|currend
argument_list|,
literal|10000000
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fildes
argument_list|)
expr_stmt|;
comment|/* 	   * Delete the absolute object file 	   */
name|unlink
argument_list|(
name|objfil
argument_list|)
expr_stmt|;
comment|/* 	   * Delete the old symbol table (if temporary) 	   */
name|unlink
argument_list|(
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"tmp:sym%d.stb"
argument_list|,
name|pid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   * Rename the new symbol table so it is now the old symbol table 	   */
name|link
argument_list|(
name|sprintf
argument_list|(
name|symfil
argument_list|,
literal|"tmp:sym%d.new"
argument_list|,
name|pid
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|symfil
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|myname
argument_list|,
literal|"tmp:sym%d.stb"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|stabf
operator|=
name|myname
expr_stmt|;
comment|/* 	   * Return  Lgetaddress(entry,function_name,discipline) 	   */
block|{
name|struct
name|argent
modifier|*
name|oldlbot
decl_stmt|,
modifier|*
name|oldnp
decl_stmt|;
name|lispval
name|result
decl_stmt|;
name|oldlbot
operator|=
name|lbot
expr_stmt|;
name|oldnp
operator|=
name|np
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|matom
argument_list|(
name|mlbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|mlbot
index|[
literal|2
index|]
operator|.
name|val
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|matom
argument_list|(
name|mlbot
index|[
literal|3
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|Lgetaddress
argument_list|()
expr_stmt|;
name|lbot
operator|=
name|oldlbot
expr_stmt|;
name|np
operator|=
name|oldnp
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|M
value|4
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|oktox
parameter_list|(
name|n
parameter_list|)
define|\
value|(0==stat(n,&stbuf)&&(stbuf.st_mode&S_IFMT)==S_IFREG&&0==access(n,M))
end_define

begin_function
name|char
modifier|*
name|gstab
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|Xargv
decl_stmt|;
if|if
condition|(
name|stabf
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
literal|":/usr/ucb:/bin:/usr/bin"
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
operator|||
operator|*
name|Xargv
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|oktox
argument_list|(
name|Xargv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|myname
argument_list|,
name|Xargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|stabf
operator|=
name|myname
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|VMS
comment|/* 			 *	Try Xargv[0] with ".stb" concatenated 			 */
name|strcpy
argument_list|(
name|myname
argument_list|,
name|Xargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|myname
argument_list|,
literal|".stb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oktox
argument_list|(
name|myname
argument_list|)
condition|)
return|return
operator|(
name|stabf
operator|=
name|myname
operator|)
return|;
endif|#
directive|endif
block|}
for|for
control|(
init|;
operator|*
name|cp
condition|;
control|)
block|{
comment|/* copy over current directory 			   and then append argv[0] */
for|for
control|(
name|cp2
operator|=
name|myname
init|;
operator|(
operator|*
name|cp
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|cp
operator|)
operator|!=
literal|':'
condition|;
control|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|cp2
argument_list|,
name|Xargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
operator|!
name|oktox
argument_list|(
name|myname
argument_list|)
condition|)
continue|continue;
else|#
directive|else
comment|/* 			 *	Also try ".stb" in VMS 			 */
if|if
condition|(
operator|!
name|oktox
argument_list|(
name|myname
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|cp2
argument_list|,
literal|".stb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oktox
argument_list|(
name|myname
argument_list|)
condition|)
continue|continue;
block|}
endif|#
directive|endif
return|return
operator|(
name|stabf
operator|=
name|myname
operator|)
return|;
block|}
name|error
argument_list|(
literal|"Could not find which file is being executed."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
else|else
return|return
operator|(
name|stabf
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|mybuff
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|mytemp
parameter_list|()
block|{
if|if
condition|(
name|mypid
operator|==
literal|0
condition|)
name|mypid
operator|=
operator|(
name|getpid
argument_list|()
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|mybuff
argument_list|,
literal|"/tmp/Li%d.%d"
argument_list|,
name|mypid
argument_list|,
name|seed
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|mybuff
operator|)
return|;
block|}
end_function

begin_macro
name|ungstab
argument_list|()
end_macro

begin_block
block|{
name|seed
operator|--
expr_stmt|;
name|sprintf
argument_list|(
name|mybuff
argument_list|,
literal|"/tmp/Li%d.%d"
argument_list|,
name|mypid
argument_list|,
name|seed
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|seed
operator|==
literal|0
condition|)
block|{
name|stabf
operator|=
literal|0
expr_stmt|;
name|fvirgin
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_function
name|lispval
name|verify
parameter_list|(
name|in
parameter_list|,
name|error
parameter_list|)
specifier|register
name|lispval
name|in
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
block|{
for|for
control|(
name|EVER
control|)
block|{
switch|switch
condition|(
name|TYPE
argument_list|(
name|in
argument_list|)
condition|)
block|{
case|case
name|STRNG
case|:
return|return
operator|(
name|in
operator|)
return|;
case|case
name|ATOM
case|:
return|return
operator|(
operator|(
name|lispval
operator|)
name|in
operator|->
name|a
operator|.
name|pname
operator|)
return|;
block|}
name|in
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
name|error
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* extern	int fvirgin; */
end_comment

begin_comment
comment|/* declared in ffasl.c tells if this is original 			 *	lisp symbol table. 			 * if fvirgin is 1 then we must copy the symbol 			 * 	table, else we can overwrite it, since 			 * 	it is a temporary file which only 			 *	one user could be using(was not created 			 *	as an original lisp or by a (dumplisp) 			 *	or a (savelisp)). 			 */
end_comment

begin_comment
comment|/* copy a block of data from one file to another of size size */
end_comment

begin_macro
name|copyblock
argument_list|(
argument|f1
argument_list|,
argument|f2
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f1
decl_stmt|,
modifier|*
name|f2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|block
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
name|size
operator|>
name|BUFSIZ
condition|)
block|{
name|size
operator|-=
name|BUFSIZ
expr_stmt|;
name|fread
argument_list|(
name|block
argument_list|,
name|BUFSIZ
argument_list|,
literal|1
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|block
argument_list|,
name|BUFSIZ
argument_list|,
literal|1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|fread
argument_list|(
name|block
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
literal|1
argument_list|,
name|f1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|block
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
literal|1
argument_list|,
name|f2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* removeaddress --  *  * (removeaddress '|_entry1| '|_entry2| ...)  *  * 	removes the given entry points from the run time symbol table,  *		so that later cfasl'd files can have these label names.  *  */
end_comment

begin_function
name|lispval
name|Lrmadd
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mlbot
init|=
name|lbot
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|numberofargs
decl_stmt|,
name|strsize
decl_stmt|;
name|char
modifier|*
name|gstab
parameter_list|()
function_decl|;
name|char
name|ostabf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|nstabf
decl_stmt|,
modifier|*
name|mytemp
argument_list|()
decl_stmt|;
name|char
modifier|*
name|strtbl
decl_stmt|,
modifier|*
name|alloca
argument_list|()
decl_stmt|;
name|int
name|i2
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|,
name|nargleft
decl_stmt|,
name|savem
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|,
modifier|*
name|fa
decl_stmt|;
name|FILE
modifier|*
name|fnew
decl_stmt|;
name|off_t
name|savesymadd
decl_stmt|,
name|symadd
decl_stmt|;
comment|/* symbol address */
name|struct
name|exec
name|buf
decl_stmt|;
name|struct
name|nlist
name|nlbuf
index|[
name|BUFSIZ
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
index|]
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|int
name|change
decl_stmt|;
name|numberofargs
operator|=
operator|(
name|np
operator|-
name|lbot
operator|)
expr_stmt|;
name|nargleft
operator|=
name|numberofargs
expr_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numberofargs
condition|;
name|i
operator|++
operator|,
name|mlbot
operator|++
control|)
block|{
name|mlbot
operator|->
name|val
operator|=
name|verify
argument_list|(
name|mlbot
operator|->
name|val
argument_list|,
literal|"Incorrect entry specification."
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mlbot
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|n
expr_stmt|;
block|}
comment|/*  	 *  Must not disturb object file if it an original file which 	 *	other users can execute(signified by the variable fvirgin). 	 *	so the entire symbol table is copied to a new file. 	 */
if|if
condition|(
name|fvirgin
condition|)
block|{
name|strcpyn
argument_list|(
name|ostabf
argument_list|,
name|gstab
argument_list|()
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|nstabf
operator|=
name|mytemp
argument_list|()
expr_stmt|;
comment|/* 		 * copy over symbol table into a temporary file first 		 * 		 */
name|f
operator|=
name|fopen
argument_list|(
name|ostabf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fnew
operator|=
name|fopen
argument_list|(
name|nstabf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fnew
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* read exec header on file */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Is this a legitimate a.out file? */
if|if
condition|(
name|N_BADMAG
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|nstabf
argument_list|)
expr_stmt|;
name|ungstab
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fnew
argument_list|)
expr_stmt|;
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Removeaddress: Bad file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|inewstr
argument_list|(
name|ostabf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
comment|/* set pointer on read file to symbol table */
comment|/* must be done before the structure buf is reassigned  		 * so that it will be accurate for the read file  		 */
name|fseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|N_SYMOFF
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset up exec header structure for new file */
name|buf
operator|.
name|a_magic
operator|=
name|OMAGIC
expr_stmt|;
name|buf
operator|.
name|a_text
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|a_data
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|a_bss
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|a_entry
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|a_trsize
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|a_drsize
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|1
argument_list|,
name|fnew
argument_list|)
expr_stmt|;
comment|/* write out exec header */
name|copyblock
argument_list|(
name|f
argument_list|,
name|fnew
argument_list|,
operator|(
name|long
operator|)
name|buf
operator|.
name|a_syms
argument_list|)
expr_stmt|;
comment|/* copy symbol table */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|strsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* find size of string table */
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|strsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fnew
argument_list|)
expr_stmt|;
comment|/* find size of string table */
name|strsize
operator|-=
literal|4
expr_stmt|;
name|strtbl
operator|=
name|alloca
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|strtbl
argument_list|,
name|strsize
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* read and save string table*/
name|fwrite
argument_list|(
name|strtbl
argument_list|,
name|strsize
argument_list|,
literal|1
argument_list|,
name|fnew
argument_list|)
expr_stmt|;
comment|/* copy out string table     */
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fnew
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nstabf
operator|=
name|gstab
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * now unset the external bits it the entry points specified. 	 */
name|f
operator|=
name|fopen
argument_list|(
name|nstabf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fa
operator|=
name|fopen
argument_list|(
name|nstabf
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fa
operator|==
name|NULL
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|nstabf
argument_list|)
expr_stmt|;
name|ungstab
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|fa
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
comment|/* read exec header on file */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* Is this a legitimate a.out file? */
if|if
condition|(
name|N_BADMAG
argument_list|(
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|fvirgin
condition|)
block|{
name|unlink
argument_list|(
name|nstabf
argument_list|)
expr_stmt|;
name|ungstab
argument_list|()
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fa
argument_list|)
expr_stmt|;
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Removeaddress: Bad file"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|inewstr
argument_list|(
name|ostabf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
else|else
block|{
name|symadd
operator|=
name|N_SYMOFF
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* 		 * read in string table if not done during copying 		 */
if|if
condition|(
name|fvirgin
operator|==
literal|0
condition|)
block|{
name|fseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|N_STROFF
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|strsize
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|strsize
operator|-=
literal|4
expr_stmt|;
name|strtbl
operator|=
name|alloca
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
name|fread
argument_list|(
name|strtbl
argument_list|,
name|strsize
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|buf
operator|.
name|a_syms
expr_stmt|;
name|fseek
argument_list|(
name|f
argument_list|,
operator|(
name|long
operator|)
name|symadd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|m
operator|=
sizeof|sizeof
argument_list|(
name|nlbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|m
condition|)
name|m
operator|=
name|n
expr_stmt|;
comment|/* read next block of symbols from a.out file */
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nlbuf
argument_list|,
name|m
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|savem
operator|=
name|m
expr_stmt|;
name|savesymadd
operator|=
name|symadd
expr_stmt|;
name|symadd
operator|+=
name|m
expr_stmt|;
name|n
operator|-=
name|m
expr_stmt|;
name|change
operator|=
literal|0
expr_stmt|;
comment|/* compare block of symbols against list of entry point 		 *	names given, if a match occurs, clear the N_EXT bit 		 *	for that given symbol and signal a change. 		 */
for|for
control|(
name|q
operator|=
name|nlbuf
init|;
operator|(
name|m
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
operator|)
operator|>=
literal|0
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|->
name|n_un
operator|.
name|n_strx
operator|==
literal|0
operator|||
name|q
operator|->
name|n_type
operator|&
name|N_STAB
comment|/* make sure it is external */
operator|||
operator|(
operator|(
name|q
operator|->
name|n_type
operator|&
name|N_EXT
operator|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
for|for
control|(
name|mlbot
operator|=
name|lbot
operator|,
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
name|numberofargs
condition|;
name|i2
operator|++
operator|,
name|mlbot
operator|++
control|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|mlbot
operator|->
name|val
operator|)
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|mlbot
operator|->
name|val
operator|)
index|[
name|i
index|]
operator|!=
name|strtbl
index|[
name|i
operator|-
literal|4
operator|+
name|q
operator|->
name|n_un
operator|.
name|n_strx
index|]
condition|)
goto|goto
name|cont
goto|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strtbl
index|[
name|q
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|i
operator|-
literal|4
index|]
condition|)
goto|goto
name|cont
goto|;
name|change
operator|=
literal|1
expr_stmt|;
name|q
operator|->
name|n_type
operator|&=
operator|~
name|N_EXT
expr_stmt|;
break|break;
name|cont
label|:
empty_stmt|;
block|}
block|}
if|if
condition|(
name|change
condition|)
block|{
name|fseek
argument_list|(
name|fa
argument_list|,
operator|(
name|long
operator|)
name|savesymadd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nlbuf
argument_list|,
name|savem
argument_list|,
literal|1
argument_list|,
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|nargleft
operator|==
literal|0
condition|)
goto|goto
name|alldone
goto|;
block|}
block|}
block|}
name|alldone
label|:
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvirgin
condition|)
name|fvirgin
operator|=
literal|0
expr_stmt|;
name|stabf
operator|=
name|nstabf
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

end_unit

