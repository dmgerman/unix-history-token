begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /na/franz/franz/RCS/error.c,v 1.2 83/01/29 12:32:33 jkf Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 12:23:32 1983 by jkf]-  * 	error.c				$Locker:  $  * error handler  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"catchfram.h"
end_include

begin_decl_stmt
specifier|static
name|lispval
name|IEargs
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|IElimit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error  * this routine is always called on a non-fatal error.  The first argu-  * ment is printed out.  The second a boolean flag indicating if the  * error routine is permitted to return a pointer to a lisp value if  * the "cont" command is executed.  */
end_comment

begin_comment
comment|/* error from lisp C code, this temporarily replaces the old error  * allowing us to interface with the new errset scheme with minimum  * difficulty.  We assume that an error which comes to this routine  * is of an "undefined error type" ER%misc .  Soon all calls to this  * routine will be removed.  *  */
end_comment

begin_function
name|lispval
name|error
parameter_list|(
name|mesg
parameter_list|,
name|contvl
parameter_list|)
name|char
modifier|*
name|mesg
decl_stmt|;
name|int
name|contvl
decl_stmt|;
block|{
name|lispval
name|errorh
parameter_list|()
function_decl|;
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
name|mesg
argument_list|,
name|nil
argument_list|,
name|contvl
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* new error handler, works with errset   *   * call is errorh(type,message,valret,contuab) where  * type is an atom which classifys the error, and whose clb, if not nil  * is the name of a function to call to handle the error.  * message is a character string to print to describe the error  * valret is the value to return to an errset if one is found,  * and contuab is non nil if this error is continuable.  */
end_comment

begin_comment
comment|/* VARARGS5 */
end_comment

begin_function
specifier|static
name|lispval
name|Ierrorh
parameter_list|(
name|type
parameter_list|,
name|message
parameter_list|,
name|valret
parameter_list|,
name|contuab
parameter_list|,
name|uniqid
parameter_list|)
name|lispval
name|type
decl_stmt|,
name|valret
decl_stmt|;
name|int
name|uniqid
decl_stmt|,
name|contuab
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
specifier|register
name|struct
name|frame
modifier|*
name|curp
decl_stmt|,
modifier|*
name|uwpframe
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|lispval
modifier|*
name|work
init|=
name|IEargs
decl_stmt|;
name|int
name|limit
init|=
name|IElimit
decl_stmt|;
name|int
name|pass
decl_stmt|,
name|curdepth
decl_stmt|;
name|lispval
name|Lread
argument_list|()
decl_stmt|,
name|calhan
argument_list|()
decl_stmt|;
name|lispval
name|contatm
decl_stmt|;
name|lispval
name|handy2
decl_stmt|;
specifier|extern
name|struct
name|frame
modifier|*
name|errp
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|contatm
operator|=
operator|(
name|contuab
operator|==
name|TRUE
condition|?
name|tatom
else|:
name|nil
operator|)
expr_stmt|;
comment|/* if there is a catch every error handler */
if|if
condition|(
operator|(
name|handy
operator|=
name|Verall
operator|->
name|a
operator|.
name|clb
operator|)
operator|!=
name|nil
condition|)
block|{
name|handy
operator|=
name|Verall
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|Verall
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
comment|/* turn off before calling */
name|handy
operator|=
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|type
argument_list|,
name|uniqid
argument_list|,
name|contatm
argument_list|,
name|message
argument_list|,
name|handy
argument_list|)
expr_stmt|;
if|if
condition|(
name|contuab
operator|&&
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|)
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|handy
operator|=
name|type
operator|->
name|a
operator|.
name|clb
operator|)
operator|!=
name|nil
condition|)
comment|/* if there is an error handler */
block|{
name|handy
operator|=
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|type
argument_list|,
name|uniqid
argument_list|,
name|contatm
argument_list|,
name|message
argument_list|,
name|handy
argument_list|)
expr_stmt|;
if|if
condition|(
name|contuab
operator|&&
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|)
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
name|pass
operator|=
literal|1
expr_stmt|;
comment|/* search stack for error catcher */
name|ps2
label|:
for|for
control|(
name|curp
operator|=
name|errp
init|;
name|curp
operator|!=
operator|(
expr|struct
name|frame
operator|*
operator|)
literal|0
condition|;
name|curp
operator|=
name|curp
operator|->
name|olderrp
control|)
block|{
if|if
condition|(
name|curp
operator|->
name|class
operator|==
name|F_CATCH
condition|)
block|{
comment|/*  		 * interesting catch tags are ER%unwind-protect, generated 		 * by unwind-protect and ER%all, generated by errset 		 */
if|if
condition|(
operator|(
name|pass
operator|==
literal|1
operator|)
operator|&&
operator|(
name|curp
operator|->
name|larg1
operator|==
name|Veruwpt
operator|)
condition|)
block|{
name|uwpframe
operator|=
name|curp
expr_stmt|;
name|pass
operator|=
literal|2
expr_stmt|;
goto|goto
name|ps2
goto|;
block|}
elseif|else
if|if
condition|(
name|curp
operator|->
name|larg1
operator|==
name|Verall
condition|)
block|{
comment|/*  		     * have found an errset to jump to. If there is an 		     * errset handler, first call that. 		     */
if|if
condition|(
operator|(
name|handy
operator|=
name|Verrset
operator|->
name|a
operator|.
name|clb
operator|)
operator|!=
name|nil
condition|)
block|{
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|type
argument_list|,
name|uniqid
argument_list|,
name|contatm
argument_list|,
name|message
argument_list|,
name|handy
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * if there is an unwind-protect then go to that first. 		     * The unwind protect will return to errorh after 		     * it has processed its cleanup forms. 		     * assert: if pass == 2  		     *		then there is a pending unwind-protect 		     */
if|if
condition|(
name|uwpframe
operator|!=
operator|(
expr|struct
name|frame
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 			 * generate form to return to unwind-protect  			 */
name|protect
argument_list|(
name|handy2
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|handy2
operator|->
name|d
operator|.
name|car
operator|=
name|Veruwpt
expr_stmt|;
name|handy
operator|=
name|handy2
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|nil
expr_stmt|;
comment|/* indicates error */
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|type
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|matom
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|valret
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|uniqid
argument_list|)
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|contuab
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
comment|/* put in optional args */
block|{
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
operator|*
name|work
operator|++
expr_stmt|;
block|}
name|lispretval
operator|=
name|handy2
expr_stmt|;
comment|/* return this as value */
name|retval
operator|=
name|C_THROW
expr_stmt|;
name|Iretfromfr
argument_list|(
name|uwpframe
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 		     * Will return to errset 		     * print message if flag on this frame is non nil 		     * and we are not executing an 'err' function. 		     */
if|if
condition|(
operator|(
name|curp
operator|->
name|larg2
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|type
operator|!=
name|Vererr
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s  "
argument_list|,
name|message
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
block|{
name|printr
argument_list|(
operator|*
name|work
operator|++
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|lispretval
operator|=
name|valret
expr_stmt|;
name|retval
operator|=
name|C_THROW
expr_stmt|;
comment|/* looks like a throw */
name|Iretfromfr
argument_list|(
name|curp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* no one will catch this error, we must see if there is an 	   error-goes-to-top-level catcher */
if|if
condition|(
name|Vertpl
operator|->
name|a
operator|.
name|clb
operator|!=
name|nil
condition|)
block|{
name|handy
operator|=
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|type
argument_list|,
name|uniqid
argument_list|,
name|contatm
argument_list|,
name|message
argument_list|,
name|Vertpl
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
if|if
condition|(
name|contuab
operator|&&
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|DTPR
operator|)
condition|)
return|return
operator|(
name|handy
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
comment|/* at this point, print error message and break, just like 	   the current error scheme */
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|message
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
block|{
name|printr
argument_list|(
operator|*
name|work
operator|++
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* If automatic-reset is set 	 * we will now jump to top level, calling the reset function 	 * if it exists, or using the c rest function if it does not  	 */
if|if
condition|(
name|Sautor
condition|)
block|{
if|if
condition|(
operator|(
name|handy
operator|=
name|reseta
operator|->
name|a
operator|.
name|fnbnd
operator|)
operator|!=
name|nil
condition|)
block|{
name|lispval
name|Lapply
parameter_list|()
function_decl|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|reseta
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|Lapply
argument_list|()
expr_stmt|;
block|}
name|Inonlocalgo
argument_list|(
name|C_RESET
argument_list|,
name|inewint
argument_list|(
literal|0
argument_list|)
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * no one wants the error.  We set up another read-eval-print 	 * loop. The user can get out of this error by typing (return 'val) 	 * if the error is continuable.  Normally this code be replaced 	 * by more clever lisp code, when the full lisp is built 	 */
name|errp
operator|=
name|Pushframe
argument_list|(
name|F_PROG
argument_list|,
name|nil
argument_list|,
name|nil
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Verdepth
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|!=
name|INT
condition|)
block|{
name|curdepth
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|curdepth
operator|=
literal|1
operator|+
name|Verdepth
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
name|PUSHDOWN
argument_list|(
name|Verdepth
argument_list|,
name|inewint
argument_list|(
name|curdepth
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|C_RET
case|:
comment|/*  			 * attempt to return from error 			 */
if|if
condition|(
operator|!
name|contuab
condition|)
name|error
argument_list|(
literal|"Can't continue from this error"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|errp
operator|->
name|svbnp
argument_list|)
expr_stmt|;
name|errp
operator|=
name|Popframe
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|lispretval
operator|)
return|;
case|case
name|C_GO
case|:
comment|/* 			 * this may look like a valid prog, but it really 			 * isn't, since go's are not allowed.  Let the 			 * user know. 			 */
name|error
argument_list|(
literal|"Can't 'go' through an error break"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
case|case
name|C_INITIAL
case|:
comment|/* 			  * normal case, just fall through into read-eval-print 			  * loop 			  */
break|break;
block|}
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|eofa
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n%d:>"
argument_list|,
name|curdepth
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|vtemp
operator|=
name|Lread
argument_list|()
expr_stmt|;
if|if
condition|(
name|vtemp
operator|==
name|eofa
condition|)
name|franzexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|eval
argument_list|(
name|vtemp
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|lispval
name|errorh
parameter_list|(
name|type
parameter_list|,
name|message
parameter_list|,
name|valret
parameter_list|,
name|contuab
parameter_list|,
name|uniqid
parameter_list|)
name|lispval
name|type
decl_stmt|,
name|valret
decl_stmt|;
name|int
name|uniqid
decl_stmt|,
name|contuab
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|IElimit
operator|=
literal|0
expr_stmt|;
name|Ierrorh
argument_list|(
name|type
argument_list|,
name|message
argument_list|,
name|valret
argument_list|,
name|contuab
argument_list|,
name|uniqid
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|lispval
name|errorh1
parameter_list|(
name|type
parameter_list|,
name|message
parameter_list|,
name|valret
parameter_list|,
name|contuab
parameter_list|,
name|uniqid
parameter_list|,
name|arg1
parameter_list|)
name|lispval
name|type
decl_stmt|,
name|valret
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|uniqid
decl_stmt|,
name|contuab
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|IElimit
operator|=
literal|1
expr_stmt|;
name|IEargs
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|Ierrorh
argument_list|(
name|type
argument_list|,
name|message
argument_list|,
name|valret
argument_list|,
name|contuab
argument_list|,
name|uniqid
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|lispval
name|errorh2
parameter_list|(
name|type
parameter_list|,
name|message
parameter_list|,
name|valret
parameter_list|,
name|contuab
parameter_list|,
name|uniqid
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|lispval
name|type
decl_stmt|,
name|valret
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|uniqid
decl_stmt|,
name|contuab
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|IElimit
operator|=
literal|2
expr_stmt|;
name|IEargs
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|IEargs
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|Ierrorh
argument_list|(
name|type
argument_list|,
name|message
argument_list|,
name|valret
argument_list|,
name|contuab
argument_list|,
name|uniqid
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_decl_stmt
name|lispval
name|calhan
argument_list|(
name|limit
argument_list|,
name|work
argument_list|,
name|type
argument_list|,
name|uniqid
argument_list|,
name|contuab
argument_list|,
name|message
argument_list|,
name|handler
argument_list|)
decl|register
name|lispval
modifier|*
name|work
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|handler
decl_stmt|,
name|type
decl_stmt|,
name|contuab
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|limit
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|uniqid
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|handler
argument_list|)
expr_stmt|;
comment|/* funcall the handler */
name|protect
argument_list|(
name|handy
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
comment|/* with a list consisting of */
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|type
expr_stmt|;
comment|/* type, */
name|handy
operator|=
operator|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|uniqid
argument_list|)
expr_stmt|;
comment|/* identifying number, */
name|handy
operator|=
operator|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|contuab
expr_stmt|;
name|handy
operator|=
operator|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|matom
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|/* message to be typed out, */
while|while
condition|(
name|limit
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* any other args. */
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
operator|*
name|work
operator|++
expr_stmt|;
block|}
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
name|handy
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_block

begin_comment
comment|/* lispend **************************************************************/
end_comment

begin_comment
comment|/* Fatal errors come here, with their epitaph.				*/
end_comment

begin_macro
name|lispend
argument_list|(
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|char
name|mesg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dmpport
argument_list|(
name|poport
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|errport
argument_list|,
literal|"%s\n"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|errport
argument_list|)
expr_stmt|;
name|franzexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_comment
comment|/* namerr ***************************************************************/
end_comment

begin_comment
comment|/* handles namestack overflow, at present by simply giving a message	*/
end_comment

begin_macro
name|namerr
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|nplim
operator|=
name|np
operator|+
name|NAMINC
operator|)
operator|>
name|orgnp
operator|+
name|NAMESIZE
condition|)
block|{
name|printf
argument_list|(
literal|"Unrecoverable Namestack Overflow, (reset) is forced\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|nplim
operator|=
name|orgnp
operator|+
name|NAMESIZE
operator|-
literal|4
operator|*
name|NAMINC
expr_stmt|;
name|lbot
operator|=
name|np
operator|=
name|nplim
operator|-
name|NAMINC
expr_stmt|;
name|protect
argument_list|(
name|matom
argument_list|(
literal|"reset"
argument_list|)
argument_list|)
expr_stmt|;
name|Lfuncal
argument_list|()
expr_stmt|;
block|}
name|error
argument_list|(
literal|"NAMESTACK OVERFLOW"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_macro
name|binderr
argument_list|()
end_macro

begin_block
block|{
name|bnp
operator|-=
literal|10
expr_stmt|;
name|error
argument_list|(
literal|"Bindstack overflow."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_macro
name|rtaberr
argument_list|()
end_macro

begin_block
block|{
name|bindfix
argument_list|(
name|Vreadtable
argument_list|,
name|strtab
argument_list|,
name|nil
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Illegal read table."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_macro
name|badmem
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|char
name|errbuf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|sprintf
argument_list|()
decl_stmt|;
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"Attempt to allocate beyond static structures (%d)."
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|errbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_macro
name|argerr
argument_list|(
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"incorrect number of args to"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|matom
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_block

begin_decl_stmt
name|lispval
name|Vinterrfcn
init|=
name|nil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * wnaerr - wrong number of arguments to a compiled function hander  * called with the function name (symbol) and a descriptor of the  * number of arguments that were expected.  The form of the descriptor  * is (considered as a decimal number) xxyy where xx is the minumum  * and yy-1 is the maximum.  A maximum of -1 means that there is no  * maximum.  *  */
end_comment

begin_macro
name|wnaerr
argument_list|(
argument|fcn
argument_list|,
argument|wantargs
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|fcn
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|Vinterrfcn
operator|==
name|nil
condition|)
block|{
name|Vinterrfcn
operator|=
name|matom
argument_list|(
literal|"int:wrong-number-of-args-error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Vinterrfcn
operator|->
name|a
operator|.
name|fnbnd
operator|!=
name|nil
condition|)
block|{
name|protect
argument_list|(
name|fcn
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|inewint
argument_list|(
name|wantargs
operator|/
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
comment|/* min */
name|protect
argument_list|(
name|inewint
argument_list|(
operator|(
name|wantargs
operator|%
literal|1000
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* max */
name|Ifuncal
argument_list|(
name|Vinterrfcn
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"wrong number of args function should never return "
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"wrong number of arguments to "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|fcn
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

