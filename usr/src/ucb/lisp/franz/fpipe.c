begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: fpipe.c,v 1.3 85/05/22 07:53:41 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 12:44:16 1983 by jkf]-  * 	fpipe.c				$Locker:  $  * pipe creation  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_function
name|FILE
modifier|*
name|fpipe
parameter_list|(
name|info
parameter_list|)
name|FILE
modifier|*
name|info
index|[
literal|2
index|]
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|p
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
literal|0
operator|>
name|pipe
argument_list|(
name|fd
argument_list|)
condition|)
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|info
index|[
literal|0
index|]
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|p
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|info
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
return|return
operator|(
operator|(
name|FILE
operator|*
operator|)
literal|2
operator|)
return|;
comment|/*indicate sucess*/
block|}
end_function

begin_comment
comment|/* Nioreset *************************************************************/
end_comment

begin_function
name|lispval
name|Nioreset
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|RTPORTS
specifier|register
name|FILE
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|_iob
index|[
literal|3
index|]
init|;
name|p
operator|<
name|_iob
operator|+
name|_NFILE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOWRT
operator||
name|_IOREAD
operator|)
condition|)
name|fclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
else|RTPORTS
name|lispval
name|NiorUtil
parameter_list|()
function_decl|;
name|_fwalk
argument_list|(
name|NiorUtil
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|RTPORTS
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RTPORTS
end_ifdef

begin_decl_stmt
name|FILE
name|FILEdummy
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|lispval
name|NiorUtil
parameter_list|(
name|p
parameter_list|)
name|FILE
modifier|*
name|p
decl_stmt|;
block|{
name|lispval
name|handy
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|stdin
operator|||
name|p
operator|==
name|stdout
operator|||
name|p
operator|==
name|stderr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|handy
operator|=
name|P
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|==
name|PORT
condition|)
block|{
name|handy
operator|->
name|p
operator|=
operator|&
name|FILEdummy
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|xports
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOTS
value|(LBPG/(sizeof (FILE *)))
end_define

begin_function
name|lispval
name|P
parameter_list|(
name|p
parameter_list|)
name|FILE
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
modifier|*
name|q
decl_stmt|;
specifier|extern
name|int
name|fakettsize
decl_stmt|;
if|if
condition|(
name|xports
operator|==
operator|(
operator|(
name|FILE
operator|*
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
comment|/* this is gross.  I don't want to change csegment -- kls */
name|xports
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|csegment
argument_list|(
name|OTHER
argument_list|,
name|LOTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SETTYPE
argument_list|(
name|xports
argument_list|,
name|PORT
argument_list|,
literal|31
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|xports
init|;
name|q
operator|<
name|xports
operator|+
name|LOTS
condition|;
name|q
operator|++
control|)
block|{
operator|*
name|q
operator|=
operator|&
name|FILEdummy
expr_stmt|;
block|}
block|}
for|for
control|(
name|q
operator|=
name|xports
init|;
name|q
operator|<
name|xports
operator|+
name|LOTS
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
name|p
condition|)
return|return
operator|(
operator|(
name|lispval
operator|)
name|q
operator|)
return|;
if|if
condition|(
operator|*
name|q
operator|==
operator|&
name|FILEdummy
condition|)
block|{
operator|*
name|q
operator|=
name|p
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|q
operator|)
return|;
block|}
block|}
comment|/* Heavens above knows this could be disasterous in makevals() */
name|error
argument_list|(
literal|"Ran out of Ports"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|RTPORTS
end_endif

begin_function
name|FILE
modifier|*
name|fstopen
parameter_list|(
name|base
parameter_list|,
name|count
parameter_list|,
name|flag
parameter_list|)
name|char
modifier|*
name|base
decl_stmt|;
name|char
modifier|*
name|flag
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|p
init|=
name|fdopen
argument_list|(
literal|0
argument_list|,
name|flag
argument_list|)
decl_stmt|;
name|p
operator|->
name|_flag
operator||=
name|_IOSTRG
expr_stmt|;
name|p
operator|->
name|_cnt
operator|=
name|count
expr_stmt|;
name|p
operator|->
name|_ptr
operator|=
name|p
operator|->
name|_base
operator|=
name|base
expr_stmt|;
name|p
operator|->
name|_file
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPISFP
end_ifdef

begin_function
name|char
modifier|*
name|alloca
parameter_list|(
name|howmuch
parameter_list|)
specifier|register
name|int
name|howmuch
decl_stmt|;
block|{
name|howmuch
operator|+=
literal|3
expr_stmt|;
name|howmuch
operator|>>=
literal|2
expr_stmt|;
name|xsp
operator|-=
name|howmuch
expr_stmt|;
if|if
condition|(
name|xsp
operator|<
name|xstack
condition|)
block|{
name|xsp
operator|+=
name|howmuch
expr_stmt|;
name|xserr
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|xsp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

