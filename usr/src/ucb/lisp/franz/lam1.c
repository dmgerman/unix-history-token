begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /na/franz/franz/RCS/lam1.c,v 1.1 83/01/29 13:03:53 jkf Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Jan 29 13:01:16 1983 by jkf]-  * 	lam1.c				$Locker:  $  * lambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_function
name|lispval
name|Leval
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"eval"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
return|return
operator|(
name|eval
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lxcar
parameter_list|()
block|{
specifier|register
name|int
name|typ
decl_stmt|;
specifier|register
name|lispval
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"xcar"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|DTPR
operator|)
operator|||
operator|(
name|typ
operator|==
name|ATOM
operator|)
operator|||
name|HUNKP
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|temp
operator|->
name|d
operator|.
name|car
operator|)
return|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
name|result
operator|=
name|inewint
argument_list|(
name|temp
operator|->
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|error
argument_list|(
literal|"Bad arg to car"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lxcdr
parameter_list|()
block|{
specifier|register
name|int
name|typ
decl_stmt|;
specifier|register
name|lispval
name|temp
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"xcdr"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|nil
condition|)
return|return
operator|(
name|nil
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|==
name|DTPR
operator|)
operator|||
name|HUNKP
argument_list|(
name|temp
argument_list|)
condition|)
return|return
operator|(
name|temp
operator|->
name|d
operator|.
name|cdr
operator|)
return|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|s
operator|.
name|CDR
operator|==
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|temp
operator|=
name|temp
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|DTPR
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Fell off the end of a bignum"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|5
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|error
argument_list|(
literal|"Bad arg to cdr"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|cxxr
parameter_list|(
name|as
parameter_list|,
name|ds
parameter_list|)
specifier|register
name|int
name|as
decl_stmt|,
name|ds
decl_stmt|;
block|{
specifier|register
name|lispval
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|typ
decl_stmt|;
name|lispval
name|errorh
parameter_list|()
function_decl|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"c{ad}+r"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|temp
operator|!=
name|nil
condition|)
block|{
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typ
operator|==
name|DTPR
operator|)
operator|||
name|HUNKP
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|temp
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|s
operator|.
name|CDR
operator|==
literal|0
condition|)
name|temp
operator|=
name|nil
expr_stmt|;
else|else
name|temp
operator|=
name|temp
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|DTPR
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Fell off the end of a bignum"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|5
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad arg to cdr"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|5
argument_list|,
name|temp
argument_list|)
operator|)
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|as
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|temp
operator|!=
name|nil
condition|)
block|{
name|typ
operator|=
name|TYPE
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typ
operator|==
name|DTPR
operator|)
operator|||
name|HUNKP
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|temp
operator|->
name|d
operator|.
name|car
expr_stmt|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
name|temp2
operator|=
name|inewint
argument_list|(
name|temp
operator|->
name|i
argument_list|)
operator|,
name|temp
operator|=
name|temp2
expr_stmt|;
elseif|else
if|if
condition|(
name|Schainp
operator|!=
name|nil
operator|&&
name|typ
operator|==
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Bad arg to car"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|5
argument_list|,
name|temp
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcar
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcdr
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcadr
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcaar
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lc02r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cddr */
end_comment

begin_function
name|lispval
name|Lc12r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* caddr */
end_comment

begin_function
name|lispval
name|Lc03r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cdddr */
end_comment

begin_function
name|lispval
name|Lc13r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cadddr */
end_comment

begin_function
name|lispval
name|Lc04r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cddddr */
end_comment

begin_function
name|lispval
name|Lc14r
parameter_list|()
block|{
return|return
operator|(
name|cxxr
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* caddddr */
end_comment

begin_comment
comment|/*  *    *	(nthelem num list)  *  * Returns the num'th element of the list, by doing a caddddd...ddr  * where there are num-1 d's. If num<=0 or greater than the length of  * the list, we return nil.  *  */
end_comment

begin_function
name|lispval
name|Lnthelem
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"nthelem"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
operator|=
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
return|return
operator|(
name|error
argument_list|(
literal|"First arg to nthelem must be a fixnum"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
name|i
operator|=
name|temp
operator|->
name|i
expr_stmt|;
comment|/* pick up the first arg */
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
operator|++
name|lbot
expr_stmt|;
comment|/* fix lbot for call to cxxr() 'cadddd..r' */
name|temp
operator|=
name|cxxr
argument_list|(
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|--
name|lbot
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lscons
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
init|=
name|lbot
decl_stmt|;
specifier|register
name|lispval
name|retp
decl_stmt|,
name|handy
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"scons"
argument_list|)
expr_stmt|;
name|retp
operator|=
name|newsdot
argument_list|()
expr_stmt|;
name|handy
operator|=
operator|(
name|argp
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"First arg to scons must be an int."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retp
operator|->
name|s
operator|.
name|I
operator|=
name|handy
operator|->
name|i
expr_stmt|;
name|handy
operator|=
operator|(
name|argp
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
name|retp
operator|->
name|s
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|SDOT
condition|)
name|error
argument_list|(
literal|"Currently you may only link sdots to sdots."
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|retp
operator|->
name|s
operator|.
name|CDR
operator|=
name|handy
expr_stmt|;
block|}
return|return
operator|(
name|retp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lbigtol
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|newp
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"Bignum-to-list"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|!=
name|SDOT
condition|)
name|handy
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Non bignum argument to Bignum-to-list"
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|5755
argument_list|,
name|handy
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|newp
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
name|handy
condition|)
block|{
name|newp
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
operator|(
name|long
operator|)
name|handy
operator|->
name|s
operator|.
name|I
argument_list|)
expr_stmt|;
if|if
condition|(
name|handy
operator|->
name|s
operator|.
name|CDR
operator|==
operator|(
name|lispval
operator|)
literal|0
condition|)
break|break;
name|newp
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|newp
operator|=
name|newp
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|s
operator|.
name|CDR
expr_stmt|;
block|}
name|handy
operator|=
operator|(
operator|--
name|np
operator|)
operator|->
name|val
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lcons
parameter_list|()
block|{
specifier|register
name|lispval
name|retp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"cons"
argument_list|)
expr_stmt|;
name|retp
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|retp
operator|->
name|d
operator|.
name|car
operator|=
operator|(
operator|(
name|argp
operator|=
name|lbot
operator|)
operator|->
name|val
operator|)
expr_stmt|;
name|retp
operator|->
name|d
operator|.
name|cdr
operator|=
name|argp
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
return|return
operator|(
name|retp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CA
value|0
end_define

begin_define
define|#
directive|define
name|CD
value|1
end_define

begin_function
name|lispval
name|rpla
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
specifier|register
name|struct
name|argent
modifier|*
name|argp
decl_stmt|;
specifier|register
name|int
name|typ
decl_stmt|;
specifier|register
name|lispval
name|first
decl_stmt|,
name|second
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"rplac[ad]"
argument_list|)
expr_stmt|;
name|argp
operator|=
name|np
operator|-
literal|1
expr_stmt|;
name|first
operator|=
operator|(
name|argp
operator|-
literal|1
operator|)
operator|->
name|val
expr_stmt|;
while|while
condition|(
name|first
operator|==
name|nil
condition|)
name|first
operator|=
name|error
argument_list|(
literal|"Attempt to rplac[ad] nil."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|second
operator|=
name|argp
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
name|first
argument_list|)
operator|)
operator|==
name|DTPR
operator|)
operator|||
operator|(
name|typ
operator|==
name|ATOM
operator|)
operator|||
name|HUNKP
argument_list|(
name|first
argument_list|)
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|CA
condition|)
name|first
operator|->
name|d
operator|.
name|car
operator|=
name|second
expr_stmt|;
else|else
name|first
operator|->
name|d
operator|.
name|cdr
operator|=
name|second
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
if|if
condition|(
name|typ
operator|==
name|SDOT
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|CA
condition|)
block|{
name|typ
operator|=
name|TYPE
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|typ
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"Rplacca of a bignum will only replace INTS"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|first
operator|->
name|s
operator|.
name|I
operator|=
name|second
operator|->
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|second
operator|==
name|nil
condition|)
name|first
operator|->
name|s
operator|.
name|CDR
operator|=
operator|(
name|lispval
operator|)
literal|0
expr_stmt|;
else|else
name|first
operator|->
name|s
operator|.
name|CDR
operator|=
name|second
expr_stmt|;
block|}
return|return
operator|(
name|first
operator|)
return|;
block|}
return|return
operator|(
name|error
argument_list|(
literal|"Bad arg to rpla"
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrplaca
parameter_list|()
block|{
return|return
operator|(
name|rpla
argument_list|(
name|CA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lrplacd
parameter_list|()
block|{
return|return
operator|(
name|rpla
argument_list|(
name|CD
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Leq
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mynp
init|=
name|lbot
operator|+
name|AD
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"eq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynp
operator|->
name|val
operator|==
operator|(
name|mynp
operator|+
literal|1
operator|)
operator|->
name|val
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnull
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"null"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|->
name|val
operator|==
name|nil
operator|)
condition|?
name|tatom
else|:
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lreturn **************************************************************/
end_comment

begin_comment
comment|/* Returns the first argument - which is nill if not specified.		*/
end_comment

begin_function
name|lispval
name|Lreturn
parameter_list|()
block|{
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|Inonlocalgo
argument_list|(
name|C_RET
argument_list|,
name|lbot
operator|->
name|val
argument_list|,
name|nil
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
end_function

begin_function
name|lispval
name|Linfile
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|name
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"infile"
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|loop
label|:
name|name
operator|=
name|verify
argument_list|(
name|name
argument_list|,
literal|"infile: file name must be atom or string"
argument_list|)
expr_stmt|;
comment|/* return nil if file couldnt be opened 	if ((port = fopen((char *)name,"r")) == NULL) return(nil); */
if|if
condition|(
operator|(
name|port
operator|=
name|fopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file for reading."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|ioname
index|[
name|PN
argument_list|(
name|port
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
comment|/* remember name */
return|return
operator|(
name|P
argument_list|(
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* outfile - open a file for writing.    * 27feb81 [jkf] - modifed to accept two arguments, the second one being a  *   string or atom, which if it begins with an `a' tells outfile to open the  *   file in append mode  */
end_comment

begin_function
name|lispval
name|Loutfile
parameter_list|()
block|{
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|lispval
name|name
decl_stmt|;
name|char
modifier|*
name|mode
init|=
literal|"w"
decl_stmt|;
comment|/* mode is w for create new file, a for append */
name|char
modifier|*
name|given
decl_stmt|;
if|if
condition|(
name|lbot
operator|+
literal|1
operator|==
name|np
condition|)
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"outfile"
argument_list|)
expr_stmt|;
name|name
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|given
operator|=
operator|(
name|char
operator|*
operator|)
name|verify
argument_list|(
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
argument_list|,
literal|"Illegal file open mode."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|given
operator|==
literal|'a'
condition|)
name|mode
operator|=
literal|"a"
expr_stmt|;
name|loop
label|:
name|name
operator|=
name|verify
argument_list|(
name|name
argument_list|,
literal|"Please supply atom or string name for port."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* 	 *	If "w" mode, open it as a "txt" file for convenience in VMS 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|mode
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|name
argument_list|,
literal|0777
argument_list|,
literal|"txt"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|name
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file for writing."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|port
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|port
operator|=
name|fopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Unable to open file for writing."
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|31
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|ioname
index|[
name|PN
argument_list|(
name|port
argument_list|)
index|]
operator|=
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|P
argument_list|(
name|port
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lterpr
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|FILE
modifier|*
name|port
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|handy
operator|=
name|nil
expr_stmt|;
else|else
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"terpr"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
block|}
name|port
operator|=
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lclose
parameter_list|()
block|{
name|lispval
name|port
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
name|port
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|port
argument_list|)
operator|)
operator|==
name|PORT
condition|)
block|{
name|fclose
argument_list|(
name|port
operator|->
name|p
argument_list|)
expr_stmt|;
name|ioname
index|[
name|PN
argument_list|(
name|port
operator|->
name|p
argument_list|)
index|]
operator|=
name|nil
expr_stmt|;
return|return
operator|(
name|tatom
operator|)
return|;
block|}
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"close:Non-port"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|987
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Ltruename
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"truename"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|PORT
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"truename: non port argument"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ioname
index|[
name|PN
argument_list|(
name|lbot
operator|->
name|val
operator|->
name|p
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnwritn
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|value
expr_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|handy
operator|=
name|nil
expr_stmt|;
else|else
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"nwritn"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
block|}
name|port
operator|=
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|port
operator|->
name|_ptr
operator|-
name|port
operator|->
name|_base
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ldrain
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
specifier|register
name|int
name|iodes
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
name|struct
name|sgttyb
name|arg
decl_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
name|handy
operator|=
name|nil
expr_stmt|;
else|else
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"nwritn"
argument_list|)
expr_stmt|;
name|handy
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
block|}
name|port
operator|=
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|_flag
operator|&
name|_IOWRT
condition|)
block|{
name|fflush
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|port
operator|->
name|_flag
operator|&
name|_IOREAD
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|port
operator|->
name|_cnt
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|_ptr
operator|=
name|port
operator|->
name|_base
expr_stmt|;
name|iodes
operator|=
name|fileno
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|gtty
argument_list|(
name|iodes
argument_list|,
operator|&
name|arg
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|stty
argument_list|(
name|iodes
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|lispval
call|)
argument_list|(
name|xports
operator|+
operator|(
name|port
operator|-
name|_iob
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Llist
parameter_list|()
block|{
comment|/* added for the benefit of mapping functions. */
specifier|register
name|struct
name|argent
modifier|*
name|ulim
decl_stmt|,
modifier|*
name|namptr
decl_stmt|;
specifier|register
name|lispval
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ulim
operator|=
name|np
expr_stmt|;
name|namptr
operator|=
name|lbot
operator|+
name|AD
expr_stmt|;
name|temp
operator|=
name|result
operator|=
operator|(
name|lispval
operator|)
name|np
expr_stmt|;
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|namptr
operator|<
name|ulim
condition|;
control|)
block|{
name|temp
operator|=
name|temp
operator|->
name|l
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|temp
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|namptr
operator|++
operator|)
operator|->
name|val
expr_stmt|;
block|}
name|temp
operator|->
name|l
operator|=
name|nil
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|result
operator|->
name|l
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lnumberp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"numberp"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
case|case
name|DOUB
case|:
case|case
name|SDOT
case|:
return|return
operator|(
name|tatom
operator|)
return|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Latom
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|lb
init|=
name|lbot
decl_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"atom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lb
operator|->
name|val
argument_list|)
operator|==
name|DTPR
operator|||
operator|(
name|HUNKP
argument_list|(
name|lb
operator|->
name|val
argument_list|)
operator|)
condition|)
return|return
operator|(
name|nil
operator|)
return|;
else|else
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ltype
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
block|{
case|case
name|INT
case|:
return|return
operator|(
name|int_name
operator|)
return|;
case|case
name|ATOM
case|:
return|return
operator|(
name|atom_name
operator|)
return|;
case|case
name|SDOT
case|:
return|return
operator|(
name|sdot_name
operator|)
return|;
case|case
name|DOUB
case|:
return|return
operator|(
name|doub_name
operator|)
return|;
case|case
name|DTPR
case|:
return|return
operator|(
name|dtpr_name
operator|)
return|;
case|case
name|STRNG
case|:
return|return
operator|(
name|str_name
operator|)
return|;
case|case
name|ARRAY
case|:
return|return
operator|(
name|array_name
operator|)
return|;
case|case
name|BCD
case|:
return|return
operator|(
name|funct_name
operator|)
return|;
case|case
name|OTHER
case|:
return|return
operator|(
name|other_name
operator|)
return|;
case|case
name|HUNK2
case|:
return|return
operator|(
name|hunk_name
index|[
literal|0
index|]
operator|)
return|;
case|case
name|HUNK4
case|:
return|return
operator|(
name|hunk_name
index|[
literal|1
index|]
operator|)
return|;
case|case
name|HUNK8
case|:
return|return
operator|(
name|hunk_name
index|[
literal|2
index|]
operator|)
return|;
case|case
name|HUNK16
case|:
return|return
operator|(
name|hunk_name
index|[
literal|3
index|]
operator|)
return|;
case|case
name|HUNK32
case|:
return|return
operator|(
name|hunk_name
index|[
literal|4
index|]
operator|)
return|;
case|case
name|HUNK64
case|:
return|return
operator|(
name|hunk_name
index|[
literal|5
index|]
operator|)
return|;
case|case
name|HUNK128
case|:
return|return
operator|(
name|hunk_name
index|[
literal|6
index|]
operator|)
return|;
case|case
name|VECTOR
case|:
return|return
operator|(
name|vect_name
operator|)
return|;
case|case
name|VECTORI
case|:
return|return
operator|(
name|vecti_name
operator|)
return|;
case|case
name|VALUE
case|:
return|return
operator|(
name|val_name
operator|)
return|;
case|case
name|PORT
case|:
return|return
operator|(
name|port_name
operator|)
return|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ldtpr
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"dtpr"
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|DTPR
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lbcdp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"bcdp"
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|BCD
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Lportp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"portp"
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|PORT
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Larrayp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"arrayp"
argument_list|)
expr_stmt|;
return|return
operator|(
name|typred
argument_list|(
name|ARRAY
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	(hunkp 'g_arg1)  * Returns t if g_arg1 is a hunk, otherwise returns nil.  */
end_comment

begin_function
name|lispval
name|Lhunkp
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"hunkp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUNKP
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
comment|/* If a hunk, return t */
else|else
return|return
operator|(
name|nil
operator|)
return|;
comment|/* else nil */
block|}
end_function

begin_function
name|lispval
name|Lset
parameter_list|()
block|{
name|lispval
name|varble
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
name|varble
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|TYPE
argument_list|(
name|varble
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
return|return
operator|(
name|varble
operator|->
name|a
operator|.
name|clb
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
case|case
name|VALUE
case|:
return|return
operator|(
name|varble
operator|->
name|l
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|)
return|;
block|}
name|error
argument_list|(
literal|"IMPROPER USE OF SET"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|lispval
name|Lequal
parameter_list|()
block|{
specifier|register
name|lispval
name|first
decl_stmt|,
name|second
decl_stmt|;
specifier|register
name|type1
operator|,
name|type2
expr_stmt|;
name|lispval
name|Lsub
argument_list|()
decl_stmt|,
name|Lzerop
argument_list|()
decl_stmt|,
modifier|*
name|stack
argument_list|()
decl_stmt|,
name|unstack
argument_list|()
decl_stmt|;
name|char
modifier|*
name|oldsp
decl_stmt|,
modifier|*
name|sp
argument_list|()
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"equal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|lbot
index|[
literal|1
index|]
operator|.
name|val
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
name|oldsp
operator|=
name|sp
argument_list|()
expr_stmt|;
name|stack
argument_list|(
operator|(
name|long
operator|)
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|stack
argument_list|(
operator|(
name|long
operator|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|oldsp
operator|>
name|sp
argument_list|()
condition|;
control|)
block|{
name|first
operator|=
name|unstack
argument_list|()
expr_stmt|;
name|second
operator|=
name|unstack
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|first
operator|==
name|second
condition|)
continue|continue;
name|type1
operator|=
name|TYPE
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TYPE
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
if|if
condition|(
operator|(
name|type1
operator|==
name|SDOT
operator|&&
name|type2
operator|==
name|INT
operator|)
operator|||
operator|(
name|type1
operator|==
name|INT
operator|&&
name|type2
operator|==
name|SDOT
operator|)
condition|)
goto|goto
name|dosub
goto|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
switch|switch
condition|(
name|type1
condition|)
block|{
case|case
name|DTPR
case|:
name|stack
argument_list|(
name|first
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
name|stack
argument_list|(
name|second
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|second
operator|=
name|second
operator|->
name|d
operator|.
name|car
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|DOUB
case|:
if|if
condition|(
name|first
operator|->
name|r
operator|!=
name|second
operator|->
name|r
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
case|case
name|INT
case|:
if|if
condition|(
name|first
operator|->
name|i
operator|!=
name|second
operator|->
name|i
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
name|dosub
label|:
case|case
name|SDOT
case|:
block|{
name|lispval
name|temp
decl_stmt|;
name|struct
name|argent
modifier|*
name|OLDlbot
init|=
name|lbot
decl_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|first
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|second
expr_stmt|;
name|temp
operator|=
name|Lsub
argument_list|()
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|OLDlbot
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|INT
operator|||
name|temp
operator|->
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
block|}
continue|continue;
case|case
name|VALUE
case|:
if|if
condition|(
name|first
operator|->
name|l
operator|!=
name|second
operator|->
name|l
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
case|case
name|STRNG
case|:
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
argument_list|,
operator|(
name|char
operator|*
operator|)
name|second
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
default|default:
return|return
operator|(
name|nil
operator|)
return|;
block|}
block|}
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|oLequal
parameter_list|()
block|{
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"equal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|==
name|lbot
operator|->
name|val
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
if|if
condition|(
name|Iequal
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
name|lbot
operator|->
name|val
argument_list|)
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
else|else
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|Iequal
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
specifier|register
name|lispval
name|first
operator|,
name|second
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|type1
operator|,
name|type2
expr_stmt|;
name|lispval
name|Lsub
argument_list|()
decl_stmt|,
name|Lzerop
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|second
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|type1
operator|=
name|TYPE
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TYPE
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
if|if
condition|(
operator|(
name|type1
operator|==
name|SDOT
operator|&&
name|type2
operator|==
name|INT
operator|)
operator|||
operator|(
name|type1
operator|==
name|INT
operator|&&
name|type2
operator|==
name|SDOT
operator|)
condition|)
goto|goto
name|dosub
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|type1
condition|)
block|{
case|case
name|DTPR
case|:
return|return
operator|(
name|Iequal
argument_list|(
name|first
operator|->
name|d
operator|.
name|car
argument_list|,
name|second
operator|->
name|d
operator|.
name|car
argument_list|)
operator|&&
name|Iequal
argument_list|(
name|first
operator|->
name|d
operator|.
name|cdr
argument_list|,
name|second
operator|->
name|d
operator|.
name|cdr
argument_list|)
operator|)
return|;
case|case
name|DOUB
case|:
return|return
operator|(
name|first
operator|->
name|r
operator|==
name|second
operator|->
name|r
operator|)
return|;
case|case
name|INT
case|:
return|return
operator|(
operator|(
name|first
operator|->
name|i
operator|==
name|second
operator|->
name|i
operator|)
operator|)
return|;
name|dosub
label|:
case|case
name|SDOT
case|:
block|{
name|lispval
name|temp
decl_stmt|;
name|struct
name|argent
modifier|*
name|OLDlbot
init|=
name|lbot
decl_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|first
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|second
expr_stmt|;
name|temp
operator|=
name|Lsub
argument_list|()
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|OLDlbot
expr_stmt|;
return|return
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|INT
operator|&&
name|temp
operator|->
name|i
operator|==
literal|0
operator|)
return|;
block|}
case|case
name|VALUE
case|:
return|return
operator|(
name|first
operator|->
name|l
operator|==
name|second
operator|->
name|l
operator|)
return|;
case|case
name|STRNG
case|:
return|return
operator|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
argument_list|,
operator|(
name|char
operator|*
operator|)
name|second
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|lispval
name|Zequal
parameter_list|()
block|{
specifier|register
name|lispval
name|first
decl_stmt|,
name|second
decl_stmt|;
specifier|register
name|type1
operator|,
name|type2
expr_stmt|;
name|lispval
name|Lsub
argument_list|()
decl_stmt|,
name|Lzerop
argument_list|()
decl_stmt|,
modifier|*
name|stack
argument_list|()
decl_stmt|,
name|unstack
argument_list|()
decl_stmt|;
name|char
modifier|*
name|oldsp
decl_stmt|,
modifier|*
name|sp
argument_list|()
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"equal"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|lbot
index|[
literal|1
index|]
operator|.
name|val
condition|)
return|return
operator|(
name|tatom
operator|)
return|;
name|oldsp
operator|=
name|sp
argument_list|()
expr_stmt|;
name|stack
argument_list|(
operator|(
name|long
operator|)
name|lbot
operator|->
name|val
argument_list|)
expr_stmt|;
name|stack
argument_list|(
operator|(
name|long
operator|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|oldsp
operator|>
name|sp
argument_list|()
condition|;
control|)
block|{
name|first
operator|=
name|unstack
argument_list|()
expr_stmt|;
name|second
operator|=
name|unstack
argument_list|()
expr_stmt|;
name|again
label|:
if|if
condition|(
name|first
operator|==
name|second
condition|)
continue|continue;
name|type1
operator|=
name|TYPE
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|type2
operator|=
name|TYPE
argument_list|(
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|!=
name|type2
condition|)
block|{
if|if
condition|(
operator|(
name|type1
operator|==
name|SDOT
operator|&&
name|type2
operator|==
name|INT
operator|)
operator|||
operator|(
name|type1
operator|==
name|INT
operator|&&
name|type2
operator|==
name|SDOT
operator|)
condition|)
goto|goto
name|dosub
goto|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
switch|switch
condition|(
name|type1
condition|)
block|{
case|case
name|DTPR
case|:
name|stack
argument_list|(
name|first
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
name|stack
argument_list|(
name|second
operator|->
name|d
operator|.
name|cdr
argument_list|)
expr_stmt|;
name|first
operator|=
name|first
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|second
operator|=
name|second
operator|->
name|d
operator|.
name|car
expr_stmt|;
goto|goto
name|again
goto|;
case|case
name|DOUB
case|:
if|if
condition|(
name|first
operator|->
name|r
operator|!=
name|second
operator|->
name|r
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
case|case
name|INT
case|:
if|if
condition|(
name|first
operator|->
name|i
operator|!=
name|second
operator|->
name|i
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
name|dosub
label|:
case|case
name|SDOT
case|:
block|{
name|lispval
name|temp
decl_stmt|;
name|struct
name|argent
modifier|*
name|OLDlbot
init|=
name|lbot
decl_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|first
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|second
expr_stmt|;
name|temp
operator|=
name|Lsub
argument_list|()
expr_stmt|;
name|np
operator|=
name|lbot
expr_stmt|;
name|lbot
operator|=
name|OLDlbot
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|!=
name|INT
operator|||
name|temp
operator|->
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
block|}
continue|continue;
case|case
name|VALUE
case|:
if|if
condition|(
name|first
operator|->
name|l
operator|!=
name|second
operator|->
name|l
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
case|case
name|STRNG
case|:
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
argument_list|,
operator|(
name|char
operator|*
operator|)
name|second
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
continue|continue;
block|}
block|}
return|return
operator|(
name|tatom
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (print 'expression ['port]) prints the given expression to the given  * port or poport if no port is given.  The amount of structure  * printed is a function of global lisp variables plevel and  * plength.  */
end_comment

begin_function
name|lispval
name|Lprint
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|extern
name|int
name|plevel
decl_stmt|,
name|plength
decl_stmt|;
name|handy
operator|=
name|nil
expr_stmt|;
comment|/* port is optional, default nil */
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|handy
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
case|case
literal|1
case|:
break|break;
default|default:
name|argerr
argument_list|(
literal|"print"
argument_list|)
expr_stmt|;
block|}
name|chkrtab
argument_list|(
name|Vreadtable
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plevel
operator|=
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plevel
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlength
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plength
operator|=
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plength
operator|=
operator|-
literal|1
expr_stmt|;
name|printr
argument_list|(
name|lbot
operator|->
name|val
argument_list|,
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|poport
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* patom does not use plevel or plength   *  * form is (patom 'value ['port])  */
end_comment

begin_function
name|lispval
name|Lpatom
parameter_list|()
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|lispval
name|handy
decl_stmt|;
specifier|register
name|int
name|typ
decl_stmt|;
name|FILE
modifier|*
name|port
decl_stmt|;
name|handy
operator|=
name|nil
expr_stmt|;
comment|/* port is optional, default nil */
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|2
case|:
name|handy
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
case|case
literal|1
case|:
break|break;
default|default:
name|argerr
argument_list|(
literal|"patom"
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|Vreadtable
operator|->
name|a
operator|.
name|clb
expr_stmt|;
name|chkrtab
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|handy
argument_list|,
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typ
operator|=
name|TYPE
argument_list|(
operator|(
name|temp
operator|=
operator|(
name|lbot
operator|)
operator|->
name|val
operator|)
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
name|fputs
argument_list|(
name|temp
operator|->
name|a
operator|.
name|pname
argument_list|,
name|port
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|typ
operator|==
name|STRNG
condition|)
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
name|port
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plevel
operator|=
name|Vprinlevel
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plevel
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|Vprinlength
operator|->
name|a
operator|.
name|clb
argument_list|)
operator|==
name|INT
condition|)
block|{
name|plength
operator|=
name|Vprinlength
operator|->
name|a
operator|.
name|clb
operator|->
name|i
expr_stmt|;
block|}
else|else
name|plength
operator|=
operator|-
literal|1
expr_stmt|;
name|printr
argument_list|(
name|temp
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * (pntlen thing) returns the length it takes to print out  * an atom or number.  */
end_comment

begin_function
name|lispval
name|Lpntlen
parameter_list|()
block|{
return|return
operator|(
name|inewint
argument_list|(
operator|(
name|long
operator|)
name|Ipntlen
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|Ipntlen
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|lispval
name|temp
decl_stmt|;
specifier|register
name|char
modifier|*
name|handy
decl_stmt|;
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
name|temp
operator|=
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|loop
label|:
switch|switch
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
condition|)
block|{
case|case
name|ATOM
case|:
name|handy
operator|=
name|temp
operator|->
name|a
operator|.
name|pname
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|handy
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
expr_stmt|;
break|break;
case|case
name|INT
case|:
name|sprintf
argument_list|(
name|strbuf
argument_list|,
literal|"%d"
argument_list|,
name|temp
operator|->
name|i
argument_list|)
expr_stmt|;
name|handy
operator|=
name|strbuf
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
name|sprintf
argument_list|(
name|strbuf
argument_list|,
literal|"%g"
argument_list|,
name|temp
operator|->
name|r
argument_list|)
expr_stmt|;
name|handy
operator|=
name|strbuf
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
name|error
argument_list|(
literal|"Non atom or number to pntlen\n"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
operator|(
name|strlen
argument_list|(
name|handy
argument_list|)
operator|)
return|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|okport
end_undef

begin_function
name|FILE
modifier|*
name|okport
parameter_list|(
name|arg
parameter_list|,
name|proper
parameter_list|)
name|lispval
name|arg
decl_stmt|;
name|FILE
modifier|*
name|proper
decl_stmt|;
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|arg
argument_list|)
operator|!=
name|PORT
condition|)
return|return
operator|(
name|proper
operator|)
return|;
else|else
return|return
operator|(
name|arg
operator|->
name|p
operator|)
return|;
block|}
end_function

end_unit

