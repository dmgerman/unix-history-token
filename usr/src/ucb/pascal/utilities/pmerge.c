begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pmerge.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|PRGFILE
value|0
end_define

begin_define
define|#
directive|define
name|LABELFILE
value|1
end_define

begin_define
define|#
directive|define
name|CONSTFILE
value|2
end_define

begin_define
define|#
directive|define
name|TYPEFILE
value|3
end_define

begin_define
define|#
directive|define
name|VARFILE
value|4
end_define

begin_define
define|#
directive|define
name|RTNFILE
value|5
end_define

begin_define
define|#
directive|define
name|BODYFILE
value|6
end_define

begin_define
define|#
directive|define
name|NUMFILES
value|7
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|MAXINCL
value|9
end_define

begin_define
define|#
directive|define
name|MAXNAM
value|75
end_define

begin_define
define|#
directive|define
name|TMPNAME
value|"/usr/tmp/MGXXXXXX"
end_define

begin_decl_stmt
name|FILE
modifier|*
name|files
index|[
name|NUMFILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|names
index|[
name|NUMFILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|curfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current output file */
end_comment

begin_function_decl
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|labelopen
init|=
name|FALSE
decl_stmt|,
name|constopen
init|=
name|FALSE
decl_stmt|,
name|typeopen
init|=
name|FALSE
decl_stmt|,
name|varopen
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Remove temporary files if interrupted  */
end_comment

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMFILES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|unlink
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Program to merge separately compiled pascal modules into a  * single standard Pascal program.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|long
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|incl
index|[
name|MAXINCL
index|]
decl_stmt|;
comment|/* include stack */
name|long
name|inclcnt
init|=
literal|0
decl_stmt|;
comment|/* incl index */
name|char
modifier|*
name|name
index|[
name|MAXNAM
index|]
decl_stmt|;
comment|/* include names seen so far */
name|long
name|namcnt
init|=
literal|0
decl_stmt|;
comment|/* next name ptr slot available */
name|char
modifier|*
name|nambuf
decl_stmt|;
comment|/* string table for names */
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* input line buffer */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* next name space available */
name|FILE
modifier|*
name|input
init|=
name|stdin
decl_stmt|;
comment|/* current input file */
name|long
name|ac
init|=
literal|0
decl_stmt|;
comment|/* argv index */
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
comment|/* char ptrs */
name|char
name|quote
decl_stmt|;
comment|/* include quote character */
name|int
name|i
decl_stmt|;
comment|/* index var */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNAM
condition|;
name|i
operator|++
control|)
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|curfile
operator|=
name|files
index|[
name|PRGFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|PRGFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|files
index|[
name|LABELFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|LABELFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|files
index|[
name|CONSTFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|CONSTFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|files
index|[
name|TYPEFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|TYPEFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|files
index|[
name|VARFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|VARFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|files
index|[
name|RTNFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|RTNFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|files
index|[
name|BODYFILE
index|]
operator|=
name|fopen
argument_list|(
name|names
index|[
name|BODYFILE
index|]
operator|=
name|mktemp
argument_list|(
name|TMPNAME
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMFILES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nambuf
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"no space for string table\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|nambuf
expr_stmt|;
name|name
index|[
name|namcnt
index|]
operator|=
name|next
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|inclcnt
operator|>
literal|0
condition|)
block|{
name|inclcnt
operator|--
expr_stmt|;
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|input
operator|=
name|incl
index|[
name|inclcnt
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|ac
operator|<
name|argc
condition|)
block|{
name|input
operator|=
name|freopen
argument_list|(
name|argv
index|[
name|ac
index|]
argument_list|,
literal|"r"
argument_list|,
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|argv
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printout
argument_list|()
expr_stmt|;
name|onintr
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|input
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|input
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'#'
condition|)
block|{
name|split
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|input
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|cp
operator|=
operator|&
name|line
index|[
literal|1
index|]
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
comment|/* void */
empty_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"include"
argument_list|,
name|cp
argument_list|,
literal|7
argument_list|)
condition|)
goto|goto
name|bad
goto|;
for|for
control|(
name|cp
operator|+=
literal|7
init|;
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
comment|/* void */
empty_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\''
operator|&&
operator|*
name|cp
operator|!=
literal|'"'
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|&
name|nambuf
index|[
name|BUFSIZ
index|]
operator|<
name|next
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|nambuf
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"no space for string table\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|nambuf
expr_stmt|;
name|name
index|[
name|namcnt
index|]
operator|=
name|next
expr_stmt|;
block|}
for|for
control|(
name|fp
operator|=
name|next
operator|,
name|quote
operator|=
operator|*
name|cp
operator|++
init|;
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
name|quote
condition|;
control|)
operator|*
name|fp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
name|quote
operator|&&
operator|(
name|fp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'i'
operator|||
name|fp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'h'
operator|)
operator|&&
operator|(
name|fp
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
operator|)
condition|)
goto|goto
name|bad
goto|;
operator|*
name|fp
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|name
init|;
operator|*
name|cpp
operator|<
name|next
operator|&&
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
name|next
argument_list|)
condition|;
control|)
name|cpp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|==
name|next
condition|)
block|{
if|if
condition|(
name|inclcnt
operator|==
name|MAXINCL
condition|)
block|{
name|fputs
argument_list|(
literal|"include table overflow\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|namcnt
operator|==
name|MAXNAM
condition|)
block|{
name|fputs
argument_list|(
literal|"include name table overflow\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|incl
index|[
name|inclcnt
index|]
operator|=
name|input
expr_stmt|;
name|inclcnt
operator|++
expr_stmt|;
name|input
operator|=
name|fopen
argument_list|(
name|next
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|fp
expr_stmt|;
name|name
index|[
name|namcnt
index|]
operator|=
name|next
expr_stmt|;
block|}
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
name|bad
label|:
name|fputs
argument_list|(
literal|"bad include format:"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Split up output into the approprite files  */
end_comment

begin_decl_stmt
name|char
name|incom
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => in comment */
end_comment

begin_decl_stmt
name|char
name|incur
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => in (* *) style comment */
end_comment

begin_decl_stmt
name|char
name|inbrac
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => in { } style comment */
end_comment

begin_decl_stmt
name|char
name|instr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => in quoted string */
end_comment

begin_decl_stmt
name|char
name|inprog
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => program statement has been found */
end_comment

begin_decl_stmt
name|int
name|beginnest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* routine nesting level */
end_comment

begin_decl_stmt
name|int
name|nest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* begin block nesting level */
end_comment

begin_decl_stmt
name|int
name|paren_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nesting level of parentheses */
end_comment

begin_macro
name|split
argument_list|(
argument|line
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ch1
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* input window */
name|char
modifier|*
name|word
decl_stmt|;
comment|/* ptr to current word */
name|int
name|len
decl_stmt|;
comment|/* length of current word */
name|char
name|prt
init|=
name|TRUE
decl_stmt|;
comment|/* TRUE => print current word */
name|ch1
operator|=
literal|' '
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|incom
condition|)
break|break;
if|if
condition|(
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
operator|==
literal|'*'
condition|)
block|{
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|incom
operator|=
name|TRUE
expr_stmt|;
name|incur
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|paren_level
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|incur
operator|&&
name|ch1
operator|==
literal|'*'
condition|)
block|{
name|incom
operator|=
name|FALSE
expr_stmt|;
name|incur
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|incom
condition|)
block|{
name|paren_level
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
name|incom
condition|)
block|{
name|inbrac
operator|=
name|TRUE
expr_stmt|;
name|incom
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
name|inbrac
condition|)
block|{
name|inbrac
operator|=
name|FALSE
expr_stmt|;
name|incom
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|incom
condition|)
block|{
name|incom
operator|=
name|TRUE
expr_stmt|;
name|instr
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instr
condition|)
block|{
name|incom
operator|=
name|FALSE
expr_stmt|;
name|instr
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|incom
operator|||
operator|!
name|isalpha
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|fputc
argument_list|(
operator|*
name|cp
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|ch1
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|word
operator|=
name|cp
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|len
operator|=
name|cp
operator|-
name|word
expr_stmt|;
switch|switch
condition|(
operator|*
name|word
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"begin"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
operator|&&
name|beginnest
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inprog
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"improper program body"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|curfile
operator|=
name|files
index|[
name|BODYFILE
index|]
expr_stmt|;
block|}
else|else
block|{
name|beginnest
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|len
operator|==
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"case"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|beginnest
operator|>
literal|0
condition|)
block|{
name|beginnest
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"const"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
name|prt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|constopen
condition|)
block|{
name|constopen
operator|=
name|TRUE
expr_stmt|;
name|prt
operator|=
name|TRUE
expr_stmt|;
block|}
name|curfile
operator|=
name|files
index|[
name|CONSTFILE
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"end"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|beginnest
operator|==
literal|1
condition|)
block|{
name|nest
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|beginnest
operator|>
literal|0
condition|)
block|{
name|beginnest
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nest
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|inprog
operator|==
literal|1
condition|)
block|{
name|inprog
operator|=
literal|0
expr_stmt|;
name|nest
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"too many end statements"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"external"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"forward"
argument_list|,
name|curfile
argument_list|)
expr_stmt|;
name|prt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|paren_level
operator|==
literal|0
condition|)
block|{
name|nest
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|len
operator|==
literal|8
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"function"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
name|curfile
operator|=
name|files
index|[
name|RTNFILE
index|]
expr_stmt|;
block|}
if|if
condition|(
name|paren_level
operator|==
literal|0
condition|)
block|{
name|nest
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|7
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"forward"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|paren_level
operator|==
literal|0
condition|)
block|{
name|nest
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|len
operator|==
literal|5
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"label"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
name|prt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|labelopen
condition|)
block|{
name|labelopen
operator|=
name|TRUE
expr_stmt|;
name|prt
operator|=
name|TRUE
expr_stmt|;
block|}
name|curfile
operator|=
name|files
index|[
name|LABELFILE
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|len
operator|==
literal|9
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"procedure"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
name|curfile
operator|=
name|files
index|[
name|RTNFILE
index|]
expr_stmt|;
block|}
if|if
condition|(
name|paren_level
operator|==
literal|0
condition|)
block|{
name|nest
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|7
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"program"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"improper program nesting"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|inprog
operator|=
literal|1
expr_stmt|;
name|curfile
operator|=
name|files
index|[
name|PRGFILE
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|len
operator|==
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
name|prt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|typeopen
condition|)
block|{
name|typeopen
operator|=
name|TRUE
expr_stmt|;
name|prt
operator|=
name|TRUE
expr_stmt|;
block|}
name|curfile
operator|=
name|files
index|[
name|TYPEFILE
index|]
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|len
operator|==
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
name|word
argument_list|,
literal|"var"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|nest
operator|==
literal|0
condition|)
block|{
name|prt
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|varopen
condition|)
block|{
name|varopen
operator|=
name|TRUE
expr_stmt|;
name|prt
operator|=
name|TRUE
expr_stmt|;
block|}
name|curfile
operator|=
name|files
index|[
name|VARFILE
index|]
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|prt
condition|)
name|fprintf
argument_list|(
name|curfile
argument_list|,
literal|"%.*s"
argument_list|,
name|len
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|prt
operator|=
name|TRUE
expr_stmt|;
name|ch1
operator|=
literal|' '
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Print out the merged result  */
end_comment

begin_macro
name|printout
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMFILES
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|freopen
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|,
name|files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|quit
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Die gracefully  */
end_comment

begin_macro
name|quit
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|perror
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|onintr
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

