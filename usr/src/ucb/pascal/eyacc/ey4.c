begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1979 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ey4.c	5.1 (Berkeley) 4/29/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"ey.h"
end_include

begin_macro
name|output
argument_list|()
end_macro

begin_block
block|{
comment|/* print the output for the states */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|c
decl_stmt|;
name|settab
argument_list|()
expr_stmt|;
name|arrset
argument_list|(
literal|"yyact"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstate
condition|;
operator|++
name|i
control|)
block|{
comment|/* output the stuff for state i */
name|nolook
operator|=
operator|(
name|tystate
index|[
name|i
index|]
operator|==
literal|0
operator|)
expr_stmt|;
name|closure
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* output actions */
name|aryfil
argument_list|(
name|temp1
argument_list|,
name|nterms
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cwset
condition|;
operator|++
name|j
control|)
block|{
comment|/* look at the items */
name|c
operator|=
operator|*
operator|(
name|wsets
index|[
name|j
index|]
operator|.
name|pitem
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
name|NTBASE
operator|&&
name|temp1
index|[
name|c
index|]
operator|==
literal|0
condition|)
name|temp1
index|[
name|c
index|]
operator|=
name|go2
argument_list|(
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|temp1
index|[
literal|1
index|]
operator|=
name|ACCEPTCODE
expr_stmt|;
comment|/* now, we have the shifts; look at the reductions */
name|lastred
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cwset
condition|;
operator|++
name|j
control|)
block|{
name|c
operator|=
operator|*
operator|(
name|wsets
index|[
name|j
index|]
operator|.
name|pitem
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
comment|/* reduction */
name|lastred
operator|=
operator|-
name|c
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|nterms
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|wsets
index|[
name|j
index|]
operator|.
name|ws
index|[
name|k
operator|>>
literal|4
index|]
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|k
operator|&
literal|017
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|temp1
index|[
name|k
index|]
operator|==
literal|0
condition|)
name|temp1
index|[
name|k
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|temp1
index|[
name|k
index|]
operator|<
literal|0
condition|)
block|{
comment|/* reduce/reduce conflict */
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n%d: reduce/reduce conflict (red'ns %d and %d ) on %s"
argument_list|,
name|i
argument_list|,
operator|-
name|temp1
index|[
name|k
index|]
argument_list|,
name|lastred
argument_list|,
name|symnam
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
name|temp1
index|[
name|k
index|]
operator|>
name|lastred
condition|)
name|temp1
index|[
name|k
index|]
operator|=
operator|-
name|lastred
expr_stmt|;
operator|++
name|zzrrconf
expr_stmt|;
name|settab
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* potential shift/reduce conflict */
switch|switch
condition|(
name|precftn
argument_list|(
name|lastred
argument_list|,
name|k
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* precedence does not apply */
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n%d: shift/reduce conflict (shift %d, red'n %d) on %s"
argument_list|,
name|i
argument_list|,
name|temp1
index|[
name|k
index|]
argument_list|,
name|lastred
argument_list|,
name|symnam
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|zzsrconf
expr_stmt|;
name|settab
argument_list|()
expr_stmt|;
comment|/* resolve in favor of shifting, so remove from reduce set */
name|wsets
index|[
name|j
index|]
operator|.
name|ws
index|[
name|k
operator|>>
literal|4
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|k
operator|&
literal|017
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*  reduce */
name|temp1
index|[
name|k
index|]
operator|=
operator|-
name|lastred
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* error, binary operator */
name|temp1
index|[
name|k
index|]
operator|=
name|ERRCODE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* shift ... leave the entry alone */
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
name|wract
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|settab
argument_list|()
expr_stmt|;
name|arrdone
argument_list|()
expr_stmt|;
comment|/* now, output the pointers to the action array */
comment|/* also output the info about reductions */
name|prred
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|prred
argument_list|()
end_macro

begin_block
block|{
comment|/* print the information about the actions and the reductions */
name|int
name|index
decl_stmt|,
name|i
decl_stmt|;
name|arrset
argument_list|(
literal|"yypact"
argument_list|)
expr_stmt|;
name|index
operator|=
literal|1
expr_stmt|;
comment|/* position in the output table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstate
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|tystate
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
comment|/* the state is real */
name|temp1
index|[
name|i
index|]
operator|=
name|index
expr_stmt|;
name|arrval
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|index
operator|+=
name|tystate
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|arrval
argument_list|(
name|temp1
index|[
operator|-
name|tystate
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|arrdone
argument_list|()
expr_stmt|;
name|arrset
argument_list|(
literal|"yyr1"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nprod
condition|;
operator|++
name|i
control|)
name|arrval
argument_list|(
operator|*
name|prdptr
index|[
name|i
index|]
operator|-
name|NTBASE
argument_list|)
expr_stmt|;
name|arrdone
argument_list|()
expr_stmt|;
name|arrset
argument_list|(
literal|"yyr2"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nprod
condition|;
operator|++
name|i
control|)
name|arrval
argument_list|(
operator|(
name|prdptr
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|prdptr
index|[
name|i
index|]
operator|-
literal|2
operator|)
argument_list|)
expr_stmt|;
name|arrdone
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|go2
argument_list|(
argument|i
argument_list|,
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* do a goto on the closure state, not worrying about lookaheads */
if|if
condition|(
name|c
operator|<
name|NTBASE
condition|)
return|return
operator|(
name|amem
index|[
name|apstate
index|[
name|i
index|]
operator|+
name|c
index|]
operator|)
return|;
else|else
return|return
operator|(
name|amem
index|[
name|apstate
index|[
name|i
index|]
operator|+
name|c
operator|-
name|NTBASE
operator|+
name|nterms
index|]
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|pkdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|apack
argument_list|(
argument|p
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* pack state i from temp1 into amem */
name|_REGISTER
name|k
decl_stmt|,
name|l
decl_stmt|,
name|off
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* find the spot */
name|j
operator|=
name|n
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<=
name|j
operator|&&
name|p
index|[
name|off
index|]
operator|==
literal|0
condition|;
operator|++
name|off
control|)
empty_stmt|;
if|if
condition|(
name|off
operator|>
name|j
condition|)
block|{
comment|/* no actions */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|j
operator|-=
name|off
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|actsiz
condition|;
operator|++
name|k
control|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<=
name|j
condition|;
operator|++
name|l
control|)
block|{
if|if
condition|(
name|p
index|[
name|off
operator|+
name|l
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p
index|[
name|off
operator|+
name|l
index|]
operator|!=
name|amem
index|[
name|k
operator|+
name|l
index|]
operator|&&
name|amem
index|[
name|k
operator|+
name|l
index|]
operator|!=
literal|0
condition|)
goto|goto
name|nextk
goto|;
block|}
block|}
if|if
condition|(
name|pkdebug
condition|)
block|{
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"off = %d, k = %d\n"
argument_list|,
name|off
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
comment|/* we have found an acceptable k */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<=
name|j
condition|;
operator|++
name|l
control|)
block|{
if|if
condition|(
name|p
index|[
name|off
operator|+
name|l
index|]
condition|)
block|{
if|if
condition|(
name|k
operator|+
name|l
operator|>=
name|actsiz
condition|)
name|error
argument_list|(
literal|"action table overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|+
name|l
operator|>=
name|memact
condition|)
name|memact
operator|=
name|k
operator|+
name|l
expr_stmt|;
name|amem
index|[
name|k
operator|+
name|l
index|]
operator|=
name|p
index|[
name|off
operator|+
name|l
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pkdebug
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|memact
condition|;
name|k
operator|+=
literal|10
control|)
block|{
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<=
literal|9
condition|;
operator|++
name|l
control|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%d "
argument_list|,
name|amem
index|[
name|k
operator|+
name|l
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|k
operator|-
name|off
operator|)
return|;
name|nextk
label|:
empty_stmt|;
block|}
name|error
argument_list|(
literal|"no space in action table"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|go2out
argument_list|()
end_macro

begin_block
block|{
comment|/* output the gotos for the nontermninals */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|best
decl_stmt|,
name|offset
decl_stmt|,
name|count
decl_stmt|,
name|cbest
decl_stmt|,
name|times
decl_stmt|;
name|settab
argument_list|()
expr_stmt|;
name|arrset
argument_list|(
literal|"yygo"
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nnonter
condition|;
operator|++
name|i
control|)
block|{
name|go2gen
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* find the best one to make default */
name|temp2
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|best
operator|=
operator|-
literal|1
expr_stmt|;
name|times
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nstate
condition|;
operator|++
name|j
control|)
block|{
comment|/* is j the most frequent */
if|if
condition|(
name|tystate
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|tystate
index|[
name|j
index|]
operator|==
name|best
condition|)
continue|continue;
comment|/* is tystate[j] the most frequent */
name|count
operator|=
literal|0
expr_stmt|;
name|cbest
operator|=
name|tystate
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|j
init|;
name|k
operator|<=
name|nstate
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|tystate
index|[
name|k
index|]
operator|==
name|cbest
condition|)
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|times
condition|)
block|{
name|best
operator|=
name|cbest
expr_stmt|;
name|times
operator|=
name|count
expr_stmt|;
block|}
block|}
comment|/* best is now the default entry */
name|zzgobest
operator|+=
operator|(
name|times
operator|-
literal|1
operator|)
operator|*
literal|2
expr_stmt|;
name|settab
argument_list|()
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|nstate
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|tystate
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|tystate
index|[
name|j
index|]
operator|!=
name|best
condition|)
block|{
name|arrval
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|arrval
argument_list|(
name|tystate
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|zzgoent
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* now, the default */
name|zzgoent
operator|+=
literal|2
expr_stmt|;
name|arrval
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arrval
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
name|arrdone
argument_list|()
expr_stmt|;
name|arrset
argument_list|(
literal|"yypgo"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nnonter
condition|;
operator|++
name|i
control|)
name|arrval
argument_list|(
name|temp2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|arrdone
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|g2debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|go2gen
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
comment|/* output the gotos for nonterminal c */
name|int
name|i
decl_stmt|,
name|work
decl_stmt|,
name|cc
decl_stmt|;
name|struct
name|item
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* first, find nonterminals with gotos on c */
name|aryfil
argument_list|(
name|temp1
argument_list|,
name|nnonter
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp1
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
name|work
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|work
condition|)
block|{
name|work
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nprod
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|cc
operator|=
name|prdptr
index|[
name|i
index|]
index|[
literal|1
index|]
operator|-
name|NTBASE
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* cc is a nonterminal */
if|if
condition|(
name|temp1
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* cc has a goto on c */
name|cc
operator|=
operator|*
name|prdptr
index|[
name|i
index|]
operator|-
name|NTBASE
expr_stmt|;
comment|/* thus, the left side of production i does too */
if|if
condition|(
name|temp1
index|[
name|cc
index|]
operator|==
literal|0
condition|)
block|{
name|work
operator|=
literal|1
expr_stmt|;
name|temp1
index|[
name|cc
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* now, we have temp1[c] = 1 if a goto on c in closure of cc */
if|if
condition|(
name|g2debug
condition|)
block|{
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%s: gotos on "
argument_list|,
name|nontrst
index|[
name|c
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|nnonter
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|temp1
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%s "
argument_list|,
name|nontrst
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* now, go through and put gotos into tystate */
name|aryfil
argument_list|(
name|tystate
argument_list|,
name|nstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\nnonterminal %s\n"
argument_list|,
name|nontrst
index|[
name|c
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nstate
condition|;
operator|++
name|i
control|)
block|{
name|q
operator|=
name|pstate
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pstate
index|[
name|i
index|]
init|;
name|p
operator|<
name|q
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|(
name|cc
operator|=
operator|*
name|p
operator|->
name|pitem
operator|)
operator|>=
name|NTBASE
condition|)
block|{
if|if
condition|(
name|temp1
index|[
name|cc
operator|-=
name|NTBASE
index|]
condition|)
block|{
comment|/* goto on c is possible */
name|tystate
index|[
name|i
index|]
operator|=
name|amem
index|[
name|indgo
index|[
name|i
index|]
operator|+
name|c
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|tystate
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\t%d\t%d\n"
argument_list|,
name|i
argument_list|,
name|tystate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|precftn
argument_list|(
argument|r
argument_list|,
argument|t
argument_list|)
end_macro

begin_block
block|{
comment|/* decide a shift/reduce conflict by precedence. 			Returns 0 if action is 'do nothing',1 if action is reduce, 			2 if the action is 'error,binary operator' 			and 3 if the action is 'reduce'. */
name|int
name|lp
decl_stmt|,
name|lt
decl_stmt|;
name|lp
operator|=
name|levprd
index|[
name|r
index|]
expr_stmt|;
name|lt
operator|=
name|trmlev
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|lt
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|lp
operator|&
literal|03
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|lt
operator|>>
literal|3
operator|)
operator|==
operator|(
name|lp
operator|>>
literal|3
operator|)
condition|)
block|{
return|return
operator|(
name|lt
operator|&
literal|03
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lt
operator|>>
literal|3
operator|)
operator|>
operator|(
name|lp
operator|>>
literal|3
operator|)
condition|)
return|return
operator|(
literal|3
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|cdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug for common states */
end_comment

begin_macro
name|wract
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
comment|/* output state i */
comment|/* temp1 has the actions, lastred the default */
name|int
name|p
decl_stmt|,
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|size
decl_stmt|;
name|int
name|ntimes
decl_stmt|,
name|tred
decl_stmt|,
name|count
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|struct
name|item
modifier|*
name|q0
decl_stmt|,
modifier|*
name|q1
decl_stmt|;
comment|/* find the best choice for lastred */
name|lastred
operator|=
literal|0
expr_stmt|;
name|ntimes
operator|=
literal|0
expr_stmt|;
name|stateflags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/***** UCB MOD - full state spec if shift on error *****/
if|if
condition|(
name|temp1
index|[
literal|2
index|]
operator|>
literal|0
condition|)
name|stateflags
index|[
name|i
index|]
operator||=
name|NEEDSREDUCE
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|nterms
condition|;
operator|++
name|j
control|)
block|{
comment|/* find the entry on which the greatest number of reductions are done */
if|if
condition|(
name|temp1
index|[
name|j
index|]
operator|>=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|temp1
index|[
name|j
index|]
operator|+
name|lastred
operator|==
literal|0
condition|)
continue|continue;
comment|/* count the number of appearances of temp1[j] */
name|count
operator|=
literal|0
expr_stmt|;
name|tred
operator|=
operator|-
name|temp1
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|nterms
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|temp1
index|[
name|p
index|]
operator|+
name|tred
operator|==
literal|0
condition|)
operator|++
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|ntimes
condition|)
block|{
name|lastred
operator|=
name|tred
expr_stmt|;
name|ntimes
operator|=
name|count
expr_stmt|;
block|}
block|}
comment|/* clear out entries in temp1 which equal lastred */
comment|/* ie, make the most frequent reduction into the default reduction */
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|nterms
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|temp1
index|[
name|p
index|]
operator|+
name|lastred
operator|==
literal|0
condition|)
name|temp1
index|[
name|p
index|]
operator|=
literal|0
expr_stmt|;
comment|/* write out the state */
comment|/* first, check for equality with another state */
comment|/* see if there is a nonterminal with all dots before it, */
comment|/* and no reductions in the state */
comment|/* this is done by checking if all items are the same non-terminal */
name|p0
operator|=
literal|0
expr_stmt|;
name|q1
operator|=
name|pstate
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|q0
operator|=
name|pstate
index|[
name|i
index|]
init|;
name|q0
operator|<
name|q1
condition|;
operator|++
name|q0
control|)
block|{
if|if
condition|(
operator|(
name|p1
operator|=
operator|*
operator|(
name|q0
operator|->
name|pitem
operator|)
operator|)
operator|<
name|NTBASE
condition|)
goto|goto
name|standard
goto|;
if|if
condition|(
name|p0
operator|==
literal|0
condition|)
name|p0
operator|=
name|p1
expr_stmt|;
elseif|else
if|if
condition|(
name|p0
operator|!=
name|p1
condition|)
goto|goto
name|standard
goto|;
block|}
name|stateflags
index|[
name|i
index|]
operator||=
name|SINGLE_NT
operator||
name|pempty
index|[
name|p0
operator|-
name|NTBASE
index|]
expr_stmt|;
comment|/* now, all items have dots before p0 */
if|if
condition|(
name|cdebug
condition|)
block|{
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"state %d, pre-nonterminal %s\n"
argument_list|,
name|i
argument_list|,
name|nontrst
index|[
name|p0
operator|-
name|NTBASE
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
comment|/*        * check that the states have the same shift lookaheads.        */
if|if
condition|(
name|apstate
index|[
name|i
index|]
operator|!=
name|apstate
index|[
name|j
index|]
condition|)
continue|continue;
if|if
condition|(
name|cdebug
condition|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"states %d and %d have same shift lookaheads\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/*        * Check that state has one item, and that the item matches.        */
if|if
condition|(
operator|(
name|stateflags
index|[
name|j
index|]
operator|&
name|SINGLE_NT
operator|)
operator|==
literal|0
operator|||
operator|*
operator|(
name|pstate
index|[
name|j
index|]
operator|->
name|pitem
operator|)
operator|!=
name|p0
condition|)
continue|continue;
comment|/*        * Check that enumeration and reduce lookaheads are the same.        */
if|if
condition|(
operator|(
name|stateflags
index|[
name|i
index|]
operator|&
operator|(
name|GENLAMBDA
operator||
name|NEEDSREDUCE
operator|)
operator|)
operator|==
operator|(
name|GENLAMBDA
operator||
name|NEEDSREDUCE
operator|)
condition|)
block|{
comment|/* 	 * p0 derives lambda. 	 * state[i] needs full reduce lookahead 	 * state[j] has full reduce lookahead 	 */
if|if
condition|(
operator|(
name|stateflags
index|[
name|j
index|]
operator|&
name|NEEDSREDUCE
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"state %d does not need full reduce"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|lambdarule
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"missing lambda rule definition in state %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookstate
index|[
name|j
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"state %d lookahead was not saved"
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* must check lookaheads */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|tbitset
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|lastate
index|[
name|lookstate
index|[
name|j
index|]
index|]
operator|.
name|lset
index|[
name|k
index|]
operator|!=
name|wsets
index|[
name|lambdarule
index|]
operator|.
name|ws
index|[
name|k
index|]
condition|)
comment|/* cannot merge states */
goto|goto
name|nextj
goto|;
block|}
comment|/* we have a match with state j ! */
if|if
condition|(
name|cdebug
condition|)
block|{
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"state %d matches state %d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|tystate
index|[
name|i
index|]
operator|=
operator|-
name|j
expr_stmt|;
name|zzacsave
operator|+=
name|tystate
index|[
name|j
index|]
expr_stmt|;
name|zznsave
operator|++
expr_stmt|;
name|wrstate
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* merged, so no need for future consideration */
name|stateflags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return;
name|nextj
label|:
empty_stmt|;
block|}
name|standard
label|:
name|tystate
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
name|wrstate
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stateflags
index|[
name|i
index|]
operator|&
operator|(
name|SINGLE_NT
operator||
name|NEEDSREDUCE
operator||
name|GENLAMBDA
operator|)
operator|)
operator|==
operator|(
name|SINGLE_NT
operator||
name|NEEDSREDUCE
operator||
name|GENLAMBDA
operator|)
condition|)
block|{
if|if
condition|(
name|savedlook
operator|+
literal|1
operator|>=
name|maxlastate
condition|)
block|{
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"Warning: _maxlastate too small (%d), state packing impared\n"
argument_list|,
name|maxlastate
argument_list|)
expr_stmt|;
comment|/* cannot consider future merger with this state */
name|stateflags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cdebug
condition|)
block|{
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"save lookahead for state %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lookstate
index|[
name|i
index|]
operator|=
name|savedlook
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|tbitset
condition|;
operator|++
name|k
control|)
name|lastate
index|[
name|savedlook
index|]
operator|.
name|lset
index|[
name|k
index|]
operator|=
name|wsets
index|[
name|lambdarule
index|]
operator|.
name|ws
index|[
name|k
index|]
expr_stmt|;
name|savedlook
operator|++
expr_stmt|;
block|}
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p0
operator|=
literal|1
init|;
name|p0
operator|<=
name|nterms
condition|;
operator|++
name|p0
control|)
if|if
condition|(
operator|(
name|p1
operator|=
name|temp1
index|[
name|p0
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/***** UCB MOD - test actions are negative of symbol to be tested 			 this speeds up the parser as it is easy to check for 	 *****/
name|arrval
argument_list|(
operator|-
name|trmset
index|[
name|p0
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|<
literal|0
condition|)
name|arrval
argument_list|(
name|REDUCACT
operator|-
name|p1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|==
name|ACCEPTCODE
condition|)
name|arrval
argument_list|(
name|ACCEPTACT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p1
operator|==
name|ERRCODE
condition|)
name|arrval
argument_list|(
name|ERRACT
argument_list|)
expr_stmt|;
else|else
name|arrval
argument_list|(
name|SHIFTACT
operator|+
name|p1
argument_list|)
expr_stmt|;
name|size
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|lastred
condition|)
name|arrval
argument_list|(
name|REDUCACT
operator|+
name|lastred
argument_list|)
expr_stmt|;
else|else
name|arrval
argument_list|(
name|ERRACT
argument_list|)
expr_stmt|;
name|tystate
index|[
name|i
index|]
operator|=
name|size
operator|+
literal|1
expr_stmt|;
comment|/* store entry size in tystate */
name|zzacent
operator|+=
operator|(
name|size
operator|+
literal|1
operator|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|wrstate
argument_list|(
argument|i
argument_list|)
end_macro

begin_block
block|{
comment|/* writes state i */
name|int
name|j0
decl_stmt|,
name|j1
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|item
modifier|*
name|pp
decl_stmt|,
modifier|*
name|qq
decl_stmt|;
name|settty
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\nstate %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|qq
operator|=
name|pstate
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pstate
index|[
name|i
index|]
init|;
name|pp
operator|<
name|qq
condition|;
operator|++
name|pp
control|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\t%s\n"
argument_list|,
name|writem
argument_list|(
name|pp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* check for state equal to another */
if|if
condition|(
name|tystate
index|[
name|i
index|]
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n\tsame as %d\n\n"
argument_list|,
operator|-
name|tystate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|j0
operator|=
literal|1
init|;
name|j0
operator|<=
name|nterms
condition|;
operator|++
name|j0
control|)
if|if
condition|(
operator|(
name|j1
operator|=
name|temp1
index|[
name|j0
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n\t%s  "
argument_list|,
name|symnam
argument_list|(
name|j0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
comment|/* shift, error, or accept */
if|if
condition|(
name|j1
operator|==
name|ACCEPTCODE
condition|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"accept"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j1
operator|==
name|ERRCODE
condition|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"error"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"shift %d"
argument_list|,
name|j1
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"reduce %d"
argument_list|,
operator|-
name|j1
argument_list|)
expr_stmt|;
block|}
comment|/* output the final production */
if|if
condition|(
name|lastred
condition|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n\t.  reduce %d\n\n"
argument_list|,
name|lastred
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"\n\t.  error\n\n"
argument_list|)
expr_stmt|;
name|ret
label|:
name|settab
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

