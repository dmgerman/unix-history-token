begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)rec.c	5.2 (Berkeley) 4/6/87"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"align.h"
end_include

begin_include
include|#
directive|include
file|"tree_ty.h"
end_include

begin_comment
comment|/*      *	set this to TRUE with adb to turn on record alignment/offset debugging.      */
end_comment

begin_decl_stmt
name|bool
name|debug_records
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG_RECORDS
parameter_list|(
name|x
parameter_list|)
value|if (debug_records) { x ; } else
end_define

begin_comment
comment|/*  * Build a record namelist entry.  * Some of the processing here is somewhat involved.  * The basic structure we are building is as follows.  *  * Each record has a main RECORD entry,  * with an attached chain of fields as ->chain;  * these enclude all the fields in all the variants of this record.  * Fields are cons'ed to the front of the ->chain list as they are discovered.  * This is for reclook(), but not for sizing and aligning offsets.  *  * If there are variants to the record, NL_TAG points to the field which  * is the tag.  If its name is NIL, the tag field is unnamed, and is not  * allocated any space in the record.  * Attached to NL_VARNT is a chain of VARNT structures  * describing each of the variants.  These are further linked  * through ->chain.  Each VARNT has, in ->range[0] the value of  * the associated constant, and each points at a RECORD describing  * the subrecord through NL_VTOREC.  These pointers are not unique,  * more than one VARNT may reference the same RECORD.  *  * On the first pass, we traverse the parse tree and construct the namelist  * entries.  This pass fills in the alignment of each record (including  * subrecords (the alignment of a record is the maximum of the alignments  * of any of its fields).  * A second pass over the namelist entries fills in the offsets of each field  * based on the alignments required.  This second pass uses the NL_FIELDLIST  * chaining of fields, and the NL_TAG pointer and the NL_VARNT pointer to get  * to fields in the order in which they were declared.  * This second pass can not be folded into the first pass,  * as the starting offset of all variants is the same,  * so we must see all the variants (and especially must know their alignments)  * before assigning offsets.  With the alignments calculated (by the first  * pass) this can be done in one top down pass, max'ing over the alignment of  * variants before assigning offsets to any of them.  */
end_comment

begin_comment
comment|/*  * P0 points to the outermost RECORD for name searches.  */
end_comment

begin_decl_stmt
name|struct
name|nl
modifier|*
name|P0
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|nl
modifier|*
name|tyrec
parameter_list|(
name|r
parameter_list|,
name|off
parameter_list|)
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
name|struct
name|nl
modifier|*
name|recp
decl_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[tyrec] off=%d\n"
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     *	build namelist structure for the outermost record type. 	     *	then calculate offsets (starting at 0) of the fields 	     *	in this record and its variant subrecords. 	     */
name|recp
operator|=
name|tyrec1
argument_list|(
name|r
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rec_offsets
argument_list|(
name|recp
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|recp
return|;
block|}
end_function

begin_comment
comment|/*  * Define a record namelist entry.  * r is the tree for the record to be built.  * first is a boolean indicating whether this is an outermost record,  * for name lookups.  * p is the record we define here.  * P0was is a local which stacks the enclosing value of P0 in the stack frame,  * since tyrec1() is recursive.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tyrec1
parameter_list|(
name|r
parameter_list|,
name|first
parameter_list|)
specifier|register
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
comment|/* T_FLDLST */
name|bool
name|first
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
modifier|*
name|P0was
decl_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[tyrec1] first=%d\n"
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RECORD
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|P0was
operator|=
name|P0
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|P0
operator|=
name|p
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|p
operator|->
name|align_info
operator|=
name|A_MIN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|!=
name|TR_NIL
condition|)
block|{
name|fields
argument_list|(
name|p
argument_list|,
name|r
operator|->
name|fldlst
operator|.
name|fix_list
argument_list|)
expr_stmt|;
name|variants
argument_list|(
name|p
argument_list|,
name|r
operator|->
name|fldlst
operator|.
name|variant
argument_list|)
expr_stmt|;
block|}
name|P0
operator|=
name|P0was
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define the fixed part fields for p.  * hang them, in order, from the record entry, through ->ptr[NL_FIELDLIST].  * the fieldlist is a tconc structure, and is manipulated   * just like newlist(), addlist(), fixlist() in the parser.  */
end_comment

begin_macro
name|fields
argument_list|(
argument|p
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T_LISTPP */
end_comment

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|fp
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
name|struct
name|nl
modifier|*
name|jp
decl_stmt|;
name|struct
name|nl
modifier|*
name|fieldnlp
decl_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[fields]\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|r
init|;
name|fp
operator|!=
name|TR_NIL
condition|;
name|fp
operator|=
name|fp
operator|->
name|list_node
operator|.
name|next
control|)
block|{
name|tp
operator|=
name|fp
operator|->
name|list_node
operator|.
name|list
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|TR_NIL
condition|)
continue|continue;
name|jp
operator|=
name|gtype
argument_list|(
name|tp
operator|->
name|rfield
operator|.
name|type
argument_list|)
expr_stmt|;
name|line
operator|=
name|tp
operator|->
name|rfield
operator|.
name|line_no
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|tp
operator|->
name|rfield
operator|.
name|id_list
init|;
name|ip
operator|!=
name|TR_NIL
condition|;
name|ip
operator|=
name|ip
operator|->
name|list_node
operator|.
name|next
control|)
block|{
name|fieldnlp
operator|=
name|deffld
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|list_node
operator|.
name|list
argument_list|,
name|jp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|==
name|NIL
condition|)
block|{
comment|/* newlist */
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|fieldnlp
expr_stmt|;
name|fieldnlp
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|fieldnlp
expr_stmt|;
block|}
else|else
block|{
comment|/* addlist */
name|fieldnlp
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
expr_stmt|;
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|fieldnlp
expr_stmt|;
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|fieldnlp
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|!=
name|NIL
condition|)
block|{
comment|/* fixlist */
name|fieldnlp
operator|=
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
expr_stmt|;
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|NIL
expr_stmt|;
name|p
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
operator|=
name|fieldnlp
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Define the variants for RECORD p.  */
end_comment

begin_macro
name|variants
argument_list|(
argument|p
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* T_TYVARPT */
end_comment

begin_block
block|{
specifier|register
name|struct
name|tnode
modifier|*
name|vc
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|struct
name|nl
modifier|*
name|vr
decl_stmt|;
name|struct
name|nl
modifier|*
name|ct
decl_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[variants]\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|TR_NIL
condition|)
return|return;
name|ct
operator|=
name|gtype
argument_list|(
name|r
operator|->
name|varpt
operator|.
name|type_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ct
operator|!=
name|NLNIL
operator|)
operator|&&
operator|(
name|isnta
argument_list|(
name|ct
argument_list|,
literal|"bcsi"
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Tag fields cannot be %ss"
argument_list|,
name|nameof
argument_list|(
name|ct
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|r
operator|->
name|varpt
operator|.
name|line_no
expr_stmt|;
comment|/* 	 * Want it even if r[2] is NIL so 	 * we check its type in "new" and "dispose" 	 * calls -- link it to NL_TAG. 	 */
name|p
operator|->
name|ptr
index|[
name|NL_TAG
index|]
operator|=
name|deffld
argument_list|(
name|p
argument_list|,
name|r
operator|->
name|varpt
operator|.
name|cptr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
for|for
control|(
name|vc
operator|=
name|r
operator|->
name|varpt
operator|.
name|var_list
init|;
name|vc
operator|!=
name|TR_NIL
condition|;
name|vc
operator|=
name|vc
operator|->
name|list_node
operator|.
name|next
control|)
block|{
name|v
operator|=
name|vc
operator|->
name|list_node
operator|.
name|list
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|TR_NIL
condition|)
continue|continue;
name|vr
operator|=
name|tyrec1
argument_list|(
name|v
operator|->
name|tyvarnt
operator|.
name|fld_list
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[variants] p->align_info %d vr->align_info %d\n"
argument_list|,
name|p
operator|->
name|align_info
argument_list|,
name|vr
operator|->
name|align_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vr
operator|->
name|align_info
operator|>
name|p
operator|->
name|align_info
condition|)
block|{
name|p
operator|->
name|align_info
operator|=
name|vr
operator|->
name|align_info
expr_stmt|;
block|}
endif|#
directive|endif
name|line
operator|=
name|v
operator|->
name|tyvarnt
operator|.
name|line_no
expr_stmt|;
for|for
control|(
name|v
operator|=
name|v
operator|->
name|tyvarnt
operator|.
name|const_list
init|;
name|v
operator|!=
name|TR_NIL
condition|;
name|v
operator|=
name|v
operator|->
name|list_node
operator|.
name|next
control|)
operator|(
name|void
operator|)
name|defvnt
argument_list|(
name|p
argument_list|,
name|v
operator|->
name|list_node
operator|.
name|list
argument_list|,
name|vr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Define a field in subrecord p of record P0  * with name s and type t.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|deffld
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|fp
decl_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[deffld] s=<%s>\n"
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclook
argument_list|(
name|P0
argument_list|,
name|s
argument_list|)
operator|!=
name|NIL
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"%s is a duplicate field name in this record"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|NIL
expr_stmt|;
block|}
comment|/* 	     *	enter the field with its type 	     */
name|fp
operator|=
name|enter
argument_list|(
name|defnl
argument_list|(
name|s
argument_list|,
name|FIELD
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     *	if no name, then this is an unnamed tag, 	     *	so don't link it into reclook()'s chain. 	     */
if|if
condition|(
name|s
operator|!=
name|NIL
condition|)
block|{
name|fp
operator|->
name|chain
operator|=
name|P0
operator|->
name|chain
expr_stmt|;
name|P0
operator|->
name|chain
operator|=
name|fp
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
comment|/* 		     * and the alignment is propagated back. 		     */
name|fp
operator|->
name|align_info
operator|=
name|align
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[deffld] fp->align_info %d p->align_info %d \n"
argument_list|,
name|fp
operator|->
name|align_info
argument_list|,
name|p
operator|->
name|align_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|align_info
operator|>
name|p
operator|->
name|align_info
condition|)
block|{
name|p
operator|->
name|align_info
operator|=
name|fp
operator|->
name|align_info
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|t
operator|!=
name|NIL
condition|)
block|{
name|P0
operator|->
name|nl_flags
operator||=
name|t
operator|->
name|nl_flags
operator|&
name|NFILES
expr_stmt|;
name|p
operator|->
name|nl_flags
operator||=
name|t
operator|->
name|nl_flags
operator|&
name|NFILES
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Define a variant from the constant tree of t  * in subrecord p of record P0 where the casetype  * is ct and the variant record to be associated is vr.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|defvnt
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|vr
parameter_list|,
name|ct
parameter_list|)
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
decl|*
name|vr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|tnode
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CHAR_CONST or SIGN_CONST */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|nl
modifier|*
name|ct
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|av
decl_stmt|;
name|gconst
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|!=
name|NIL
operator|&&
name|incompat
argument_list|(
name|con
operator|.
name|ctype
argument_list|,
name|ct
argument_list|,
name|t
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|cerror
argument_list|(
literal|"Variant label type incompatible with selector type"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ct
operator|=
name|NIL
expr_stmt|;
block|}
name|av
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|VARNT
argument_list|,
name|ct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|ct
operator|!=
name|NIL
condition|)
name|uniqv
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|not PI1
name|av
operator|->
name|chain
operator|=
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
expr_stmt|;
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
operator|=
name|av
expr_stmt|;
name|av
operator|->
name|ptr
index|[
name|NL_VTOREC
index|]
operator|=
name|vr
expr_stmt|;
name|av
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|con
operator|.
name|crval
expr_stmt|;
return|return
operator|(
name|av
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|PI1
end_ifndef

begin_comment
comment|/*  * Check that the constant label value  * is unique among the labels in this variant.  */
end_comment

begin_macro
name|uniqv
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|vt
decl_stmt|;
for|for
control|(
name|vt
operator|=
name|p
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
init|;
name|vt
operator|!=
name|NIL
condition|;
name|vt
operator|=
name|vt
operator|->
name|chain
control|)
if|if
condition|(
name|vt
operator|->
name|range
index|[
literal|0
index|]
operator|==
name|con
operator|.
name|crval
condition|)
block|{
name|error
argument_list|(
literal|"Duplicate variant case label in record"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * See if the field name s is defined  * in the record p, returning a pointer  * to it namelist entry if it is.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|reclook
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NIL
operator|||
name|s
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
for|for
control|(
name|p
operator|=
name|p
operator|->
name|chain
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|chain
control|)
if|if
condition|(
name|p
operator|->
name|symbol
operator|==
name|s
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*      *	descend namelist entry for a record and assign offsets.      *	fields go at the next higher offset that suits their alignment.      *	all variants of a record start at the same offset, which is suitable      *	for the alignment of their worst aligned field.  thus the size of a       *	record is independent of whether or not it is a variant      *	(a desirable property).      *	records come to us in the namelist, where they have been annotated      *	with the maximum alignment their fields require.      *	the starting offset is passed to us, and is passed recursively for      *	variant records within records.      *	the final maximum size of each record is recorded in the namelist      *	in the value[NL_OFFS] field of the namelist for the record.      *      *	this is supposed to match the offsets used by the c compiler      *	so people can share records between modules in both languages.      */
end_comment

begin_macro
name|rec_offsets
argument_list|(
argument|recp
argument_list|,
argument|offset
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|recp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the namelist record */
end_comment

begin_decl_stmt
name|long
name|offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting offset for this record/field */
end_comment

begin_block
block|{
name|long
name|origin
decl_stmt|;
comment|/* offset of next field */
name|struct
name|nl
modifier|*
name|fieldnlp
decl_stmt|;
comment|/* the current field */
name|struct
name|nl
modifier|*
name|varntnlp
decl_stmt|;
comment|/* the current variant */
name|struct
name|nl
modifier|*
name|vrecnlp
decl_stmt|;
comment|/* record for the current variant */
if|if
condition|(
name|recp
operator|==
name|NIL
condition|)
block|{
return|return;
block|}
name|origin
operator|=
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|recp
operator|->
name|align_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|offset
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] offset=%d recp->align_info=%d origin=%d\n"
argument_list|,
name|offset
argument_list|,
name|recp
operator|->
name|align_info
argument_list|,
name|origin
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"rec_offsets"
argument_list|)
expr_stmt|;
block|}
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] offset %d recp->align %d origin %d\n"
argument_list|,
name|offset
argument_list|,
name|recp
operator|->
name|align_info
argument_list|,
name|origin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *	fixed fields are forward linked though ->ptr[NL_FIELDLIST] 	 *	give them all suitable offsets. 	 */
for|for
control|(
name|fieldnlp
operator|=
name|recp
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
init|;
name|fieldnlp
operator|!=
name|NIL
condition|;
name|fieldnlp
operator|=
name|fieldnlp
operator|->
name|ptr
index|[
name|NL_FIELDLIST
index|]
control|)
block|{
name|origin
operator|=
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|origin
argument_list|,
operator|(
name|long
operator|)
name|align
argument_list|(
name|fieldnlp
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fieldnlp
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|origin
expr_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] symbol %s origin %d\n"
argument_list|,
name|fieldnlp
operator|->
name|symbol
argument_list|,
name|origin
argument_list|)
argument_list|)
expr_stmt|;
name|origin
operator|+=
name|lwidth
argument_list|(
name|fieldnlp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	this is the extent of the record, so far 	 */
name|recp
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|origin
expr_stmt|;
comment|/* 	 *	if we have a tag field, we have variants to deal with 	 */
if|if
condition|(
name|recp
operator|->
name|ptr
index|[
name|NL_TAG
index|]
condition|)
block|{
comment|/* 	     *	if tag field is unnamed, then don't allocate space for it. 	     */
name|fieldnlp
operator|=
name|recp
operator|->
name|ptr
index|[
name|NL_TAG
index|]
expr_stmt|;
if|if
condition|(
name|fieldnlp
operator|->
name|symbol
operator|!=
name|NIL
condition|)
block|{
name|origin
operator|=
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|origin
argument_list|,
operator|(
name|long
operator|)
name|align
argument_list|(
name|fieldnlp
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fieldnlp
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|origin
expr_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] tag %s origin %d\n"
argument_list|,
name|fieldnlp
operator|->
name|symbol
argument_list|,
name|origin
argument_list|)
argument_list|)
expr_stmt|;
name|origin
operator|+=
name|lwidth
argument_list|(
name|fieldnlp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* 	     *	find maximum alignment of records of variants 	     */
for|for
control|(
name|varntnlp
operator|=
name|recp
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
init|;
name|varntnlp
operator|!=
name|NIL
condition|;
name|varntnlp
operator|=
name|varntnlp
operator|->
name|chain
control|)
block|{
name|vrecnlp
operator|=
name|varntnlp
operator|->
name|ptr
index|[
name|NL_VTOREC
index|]
expr_stmt|;
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] maxing variant %d align_info %d\n"
argument_list|,
name|varntnlp
operator|->
name|value
index|[
literal|0
index|]
argument_list|,
name|vrecnlp
operator|->
name|align_info
argument_list|)
argument_list|)
expr_stmt|;
name|origin
operator|=
name|roundup
argument_list|(
operator|(
name|int
operator|)
name|origin
argument_list|,
operator|(
name|long
operator|)
name|vrecnlp
operator|->
name|align_info
argument_list|)
expr_stmt|;
block|}
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] origin of variants %d\n"
argument_list|,
name|origin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     *	assign offsets to fields of records of the variants 	     *	keep maximum length of the current record. 	     */
for|for
control|(
name|varntnlp
operator|=
name|recp
operator|->
name|ptr
index|[
name|NL_VARNT
index|]
init|;
name|varntnlp
operator|!=
name|NIL
condition|;
name|varntnlp
operator|=
name|varntnlp
operator|->
name|chain
control|)
block|{
name|vrecnlp
operator|=
name|varntnlp
operator|->
name|ptr
index|[
name|NL_VTOREC
index|]
expr_stmt|;
comment|/* 		 *	assign offsets to fields of the variant. 		 *	recursive call on rec_offsets. 		 */
name|rec_offsets
argument_list|(
name|vrecnlp
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* 		 *	extent of the record is the 		 *	maximum extent of all variants 		 */
if|if
condition|(
name|vrecnlp
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|>
name|recp
operator|->
name|value
index|[
name|NL_OFFS
index|]
condition|)
block|{
name|recp
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|vrecnlp
operator|->
name|value
index|[
name|NL_OFFS
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 *	roundup the size of the record to its alignment 	 */
name|DEBUG_RECORDS
argument_list|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[rec_offsets] recp->value[NL_OFFS] %d ->align_info %d\n"
argument_list|,
name|recp
operator|->
name|value
index|[
name|NL_OFFS
index|]
argument_list|,
name|recp
operator|->
name|align_info
argument_list|)
argument_list|)
expr_stmt|;
name|recp
operator|->
name|value
index|[
name|NL_OFFS
index|]
operator|=
name|roundup
argument_list|(
name|recp
operator|->
name|value
index|[
name|NL_OFFS
index|]
argument_list|,
operator|(
name|long
operator|)
name|recp
operator|->
name|align_info
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

