begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)type.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_include
include|#
directive|include
file|"tree_ty.h"
end_include

begin_comment
comment|/*  * Type declaration part  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|typebeg
argument_list|(
argument|lineofytype
argument_list|,
argument|r
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lineofytype
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|bool
name|type_order
init|=
name|FALSE
decl_stmt|;
specifier|static
name|bool
name|type_seen
init|=
name|FALSE
decl_stmt|;
comment|/*  * this allows for multiple  * declaration parts unless  * standard option has been  * specified.  * If routine segment is being  * compiled, do level one processing.  */
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
operator|!
name|progseen
condition|)
name|level1
argument_list|()
expr_stmt|;
name|line
operator|=
name|lineofytype
expr_stmt|;
if|if
condition|(
name|parts
index|[
name|cbn
index|]
operator|&
operator|(
name|VPRT
operator||
name|RPRT
operator|)
condition|)
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|standard
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Type declarations should precede var and routine declarations"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|type_order
condition|)
block|{
name|type_order
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Type declarations should precede var and routine declarations"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parts
index|[
name|cbn
index|]
operator|&
name|TPRT
condition|)
block|{
if|if
condition|(
name|opt
argument_list|(
literal|'s'
argument_list|)
condition|)
block|{
name|standard
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"All types should be declared in one type part"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|type_seen
condition|)
block|{
name|type_seen
operator|=
name|TRUE
expr_stmt|;
name|warning
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"All types should be declared in one type part"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|parts
index|[
name|cbn
index|]
operator||=
name|TPRT
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Forechain is the head of a list of types that 	 * might be self referential.  We chain them up and 	 * process them later. 	 */
name|forechain
operator|=
name|NIL
expr_stmt|;
ifdef|#
directive|ifdef
name|PI0
name|send
argument_list|(
name|REVTBEG
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|type
argument_list|(
argument|tline
argument_list|,
argument|tid
argument_list|,
argument|tdecl
argument_list|)
end_macro

begin_decl_stmt
name|int
name|tline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tnode
modifier|*
name|tdecl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
name|struct
name|nl
modifier|*
name|tnp
decl_stmt|;
name|np
operator|=
name|gtype
argument_list|(
name|tdecl
argument_list|)
expr_stmt|;
name|line
operator|=
name|tline
expr_stmt|;
name|tnp
operator|=
name|defnl
argument_list|(
name|tid
argument_list|,
name|TYPE
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|enter
argument_list|(
name|tnp
argument_list|)
operator|->
name|nl_flags
operator||=
operator|(
name|char
operator|)
name|NMOD
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|enter
argument_list|(
name|tnp
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|REVTYPE
argument_list|,
name|tline
argument_list|,
name|tid
argument_list|,
name|tdecl
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC
if|if
condition|(
name|cbn
operator|==
literal|1
condition|)
block|{
name|stabgtype
argument_list|(
name|tid
argument_list|,
name|np
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stabltype
argument_list|(
name|tid
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PC
ifdef|#
directive|ifdef
name|PTREE
block|{
name|pPointer
name|Type
init|=
name|TypeDecl
argument_list|(
name|tid
argument_list|,
name|tdecl
argument_list|)
decl_stmt|;
name|pPointer
modifier|*
name|Types
decl_stmt|;
name|pSeize
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
expr_stmt|;
name|Types
operator|=
operator|&
operator|(
name|pDEF
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
operator|.
name|PorFTypes
operator|)
expr_stmt|;
operator|*
name|Types
operator|=
name|ListAppend
argument_list|(
operator|*
name|Types
argument_list|,
name|Type
argument_list|)
expr_stmt|;
name|pRelease
argument_list|(
name|PorFHeader
index|[
name|nesting
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_macro
name|typeend
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|PI0
name|send
argument_list|(
name|REVTEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|foredecl
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Return a type pointer (into the namelist)  * from a parse tree for a type, building  * namelist entries as needed.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|gtype
parameter_list|(
name|r
parameter_list|)
specifier|register
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|oline
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ
name|long
name|w
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|r
operator|==
name|TR_NIL
condition|)
return|return
operator|(
name|NLNIL
operator|)
return|;
name|oline
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tag
operator|!=
name|T_ID
condition|)
name|oline
operator|=
name|line
operator|=
name|r
operator|->
name|lined
operator|.
name|line_no
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"type"
argument_list|)
expr_stmt|;
case|case
name|T_TYID
case|:
name|r
operator|=
operator|(
expr|struct
name|tnode
operator|*
operator|)
operator|(
operator|&
operator|(
name|r
operator|->
name|tyid_node
operator|.
name|line_no
operator|)
operator|)
expr_stmt|;
case|case
name|T_ID
case|:
name|np
operator|=
name|lookup
argument_list|(
name|r
operator|->
name|char_const
operator|.
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NLNIL
condition|)
break|break;
if|if
condition|(
name|np
operator|->
name|class
operator|!=
name|TYPE
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"%s is a %s, not a type as required"
argument_list|,
name|r
operator|->
name|char_const
operator|.
name|cptr
argument_list|,
name|classes
index|[
name|np
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|NLNIL
expr_stmt|;
break|break;
block|}
name|np
operator|=
name|np
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_TYSCAL
case|:
name|np
operator|=
name|tyscal
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TYCRANG
case|:
name|np
operator|=
name|tycrang
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TYRANG
case|:
name|np
operator|=
name|tyrang
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TYPTR
case|:
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|PTR
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
operator|(
expr|struct
name|nl
operator|*
operator|)
name|r
operator|->
name|ptr_ty
operator|.
name|id_node
operator|)
expr_stmt|;
name|np
operator|->
name|nl_next
operator|=
name|forechain
expr_stmt|;
name|forechain
operator|=
name|np
expr_stmt|;
break|break;
case|case
name|T_TYPACK
case|:
name|np
operator|=
name|gtype
argument_list|(
name|r
operator|->
name|comp_ty
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TYCARY
case|:
case|case
name|T_TYARY
case|:
name|np
operator|=
name|tyary
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TYREC
case|:
name|np
operator|=
name|tyrec
argument_list|(
name|r
operator|->
name|comp_ty
operator|.
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTREE
comment|/* 				 * mung T_TYREC[3] to point to the record 				 * for RecTCopy 				 */
name|r
operator|->
name|comp_ty
operator|.
name|nl_entry
operator|=
name|np
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|T_TYFILE
case|:
name|np
operator|=
name|gtype
argument_list|(
name|r
operator|->
name|comp_ty
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NLNIL
condition|)
break|break;
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|np
operator|->
name|nl_flags
operator|&
name|NFILES
condition|)
name|error
argument_list|(
literal|"Files cannot be members of files"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|FILET
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|nl_flags
operator||=
name|NFILES
expr_stmt|;
break|break;
case|case
name|T_TYSET
case|:
name|np
operator|=
name|gtype
argument_list|(
name|r
operator|->
name|comp_ty
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NLNIL
condition|)
break|break;
if|if
condition|(
name|np
operator|->
name|type
operator|==
name|nl
operator|+
name|TDOUBLE
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Set of real is not allowed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|NLNIL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|np
operator|->
name|class
operator|!=
name|RANGE
operator|&&
name|np
operator|->
name|class
operator|!=
name|SCAL
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Set type must be range or scalar, not %s"
argument_list|,
name|nameof
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|NLNIL
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|PI1
if|if
condition|(
name|width
argument_list|(
name|np
argument_list|)
operator|>
literal|2
condition|)
name|error
argument_list|(
literal|"Implementation restriction: sets must be indexed by 16 bit quantities"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|SET
argument_list|,
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|oline
expr_stmt|;
ifndef|#
directive|ifndef
name|PC
name|w
operator|=
name|lwidth
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>=
name|TOOMUCH
condition|)
block|{
name|error
argument_list|(
literal|"Storage requirement of %s exceeds the implementation limit of %D by %D bytes"
argument_list|,
name|nameof
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
call|(
name|long
call|)
argument_list|(
name|TOOMUCH
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
call|(
name|long
call|)
argument_list|(
name|w
operator|-
name|TOOMUCH
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
name|NLNIL
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scalar (enumerated) types  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tyscal
parameter_list|(
name|r
parameter_list|)
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
comment|/* T_TYSCAL */
block|{
specifier|register
name|struct
name|nl
modifier|*
name|np
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|SCAL
argument_list|,
name|NLNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|type
operator|=
name|np
expr_stmt|;
name|v
operator|=
name|r
operator|->
name|comp_ty
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|TR_NIL
condition|)
return|return
operator|(
name|NLNIL
operator|)
return|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|zp
operator|=
name|np
expr_stmt|;
for|for
control|(
init|;
name|v
operator|!=
name|TR_NIL
condition|;
name|v
operator|=
name|v
operator|->
name|list_node
operator|.
name|next
control|)
block|{
name|op
operator|=
name|enter
argument_list|(
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v
operator|->
name|list_node
operator|.
name|list
argument_list|,
name|CONST
argument_list|,
name|np
argument_list|,
operator|++
name|i
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PI0
name|op
operator|->
name|nl_flags
operator||=
name|NMOD
expr_stmt|;
endif|#
directive|endif
name|op
operator|->
name|value
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|zp
operator|->
name|chain
operator|=
name|op
expr_stmt|;
name|zp
operator|=
name|op
expr_stmt|;
block|}
name|np
operator|->
name|range
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Declare a subrange for conformant arrays.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tycrang
parameter_list|(
name|r
parameter_list|)
specifier|register
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|gtype
argument_list|(
name|r
operator|->
name|crang_ty
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NLNIL
condition|)
return|return
operator|(
name|NLNIL
operator|)
return|;
comment|/* 	 * Just make a new type -- the lower and upper bounds must be 	 * set by params(). 	 */
name|p
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|CRANGE
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Declare a subrange.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tyrang
parameter_list|(
name|r
parameter_list|)
specifier|register
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
comment|/* T_TYRANG */
block|{
specifier|register
name|struct
name|nl
modifier|*
name|lp
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
name|double
name|high
decl_stmt|;
name|int
name|c
decl_stmt|,
name|c1
decl_stmt|;
name|gconst
argument_list|(
name|r
operator|->
name|rang_ty
operator|.
name|const2
argument_list|)
expr_stmt|;
name|hp
operator|=
name|con
operator|.
name|ctype
expr_stmt|;
name|high
operator|=
name|con
operator|.
name|crval
expr_stmt|;
name|gconst
argument_list|(
name|r
operator|->
name|rang_ty
operator|.
name|const1
argument_list|)
expr_stmt|;
name|lp
operator|=
name|con
operator|.
name|ctype
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NLNIL
operator|||
name|hp
operator|==
name|NLNIL
condition|)
return|return
operator|(
name|NLNIL
operator|)
return|;
if|if
condition|(
name|norange
argument_list|(
name|lp
argument_list|)
operator|||
name|norange
argument_list|(
name|hp
argument_list|)
condition|)
return|return
operator|(
name|NLNIL
operator|)
return|;
name|c
operator|=
name|classify
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|c1
operator|=
name|classify
argument_list|(
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|c1
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Can't mix %ss and %ss in subranges"
argument_list|,
name|nameof
argument_list|(
name|lp
argument_list|)
argument_list|,
name|nameof
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NLNIL
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|TSCAL
operator|&&
name|scalar
argument_list|(
name|lp
argument_list|)
operator|!=
name|scalar
argument_list|(
name|hp
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Scalar types must be identical in subranges"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NLNIL
operator|)
return|;
block|}
if|if
condition|(
name|con
operator|.
name|crval
operator|>
name|high
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Range lower bound exceeds upper bound"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NLNIL
operator|)
return|;
block|}
name|lp
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RANGE
argument_list|,
name|hp
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lp
operator|->
name|range
index|[
literal|0
index|]
operator|=
name|con
operator|.
name|crval
expr_stmt|;
name|lp
operator|->
name|range
index|[
literal|1
index|]
operator|=
name|high
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|norange
argument_list|(
name|p
argument_list|)
specifier|register
expr|struct
name|nl
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|isa
argument_list|(
name|p
argument_list|,
literal|"d"
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Subrange of real is not allowed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isnta
argument_list|(
name|p
argument_list|,
literal|"bcsi"
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Subrange bounds must be Boolean, character, integer or scalar, not %s"
argument_list|,
name|nameof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Declare arrays and chain together the dimension specification  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tyary
parameter_list|(
name|r
parameter_list|)
name|struct
name|tnode
modifier|*
name|r
decl_stmt|;
block|{
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|tnode
modifier|*
name|tl
decl_stmt|,
modifier|*
name|s
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|tp
decl_stmt|,
modifier|*
name|ltp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|s
operator|=
name|r
expr_stmt|;
comment|/* Count the dimensions */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|s
operator|->
name|tag
operator|==
name|T_TYARY
operator|||
name|s
operator|->
name|tag
operator|==
name|T_TYCARY
condition|;
name|s
operator|=
name|s
operator|->
name|ary_ty
operator|.
name|type
operator|,
name|n
operator|++
control|)
comment|/* NULL STATEMENT */
empty_stmt|;
name|tp
operator|=
name|gtype
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NLNIL
condition|)
return|return
operator|(
name|NLNIL
operator|)
return|;
name|np
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ARRAY
argument_list|,
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|nl_flags
operator||=
operator|(
name|tp
operator|->
name|nl_flags
operator|)
operator|&
name|NFILES
expr_stmt|;
name|ltp
operator|=
name|np
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|r
init|;
name|s
operator|->
name|tag
operator|==
name|T_TYARY
operator|||
name|s
operator|->
name|tag
operator|==
name|T_TYCARY
condition|;
name|s
operator|=
name|s
operator|->
name|ary_ty
operator|.
name|type
control|)
block|{
for|for
control|(
name|tl
operator|=
name|s
operator|->
name|ary_ty
operator|.
name|type_list
init|;
name|tl
operator|!=
name|TR_NIL
condition|;
name|tl
operator|=
name|tl
operator|->
name|list_node
operator|.
name|next
control|)
block|{
name|tp
operator|=
name|gtype
argument_list|(
name|tl
operator|->
name|list_node
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NLNIL
condition|)
block|{
name|np
operator|=
name|NLNIL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|class
operator|==
name|RANGE
operator|||
name|tp
operator|->
name|class
operator|==
name|CRANGE
operator|)
operator|&&
name|tp
operator|->
name|type
operator|==
name|nl
operator|+
name|TDOUBLE
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Index type for arrays cannot be real"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|NLNIL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tp
operator|->
name|class
operator|!=
name|RANGE
operator|&&
name|tp
operator|->
name|class
operator|!=
name|SCAL
operator|&&
name|tp
operator|->
name|class
operator|!=
name|CRANGE
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Array index type is a %s, not a range or scalar as required"
argument_list|,
name|classes
index|[
name|tp
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|NLNIL
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|PC
if|if
condition|(
name|tp
operator|->
name|class
operator|==
name|RANGE
operator|&&
name|bytes
argument_list|(
name|tp
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|tp
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
operator|>
literal|2
condition|)
block|{
ifndef|#
directive|ifndef
name|PI1
name|error
argument_list|(
literal|"Value of dimension specifier too large or small for this implementation"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|class
operator|!=
name|CRANGE
condition|)
name|tp
operator|=
name|nlcopy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ltp
operator|->
name|chain
operator|=
name|tp
expr_stmt|;
name|ltp
operator|=
name|tp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
operator|!=
name|NLNIL
condition|)
name|np
operator|->
name|value
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delayed processing for pointers to  * allow self-referential and mutually  * recursive pointer constructs.  */
end_comment

begin_macro
name|foredecl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|forechain
init|;
name|p
operator|!=
name|NLNIL
condition|;
name|p
operator|=
name|p
operator|->
name|nl_next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|class
operator|==
name|PTR
operator|&&
name|p
operator|->
name|ptr
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|p
operator|->
name|type
operator|=
name|gtype
argument_list|(
operator|(
expr|struct
name|tnode
operator|*
operator|)
name|p
operator|->
name|ptr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTREE
block|{
if|if
condition|(
name|pUSE
argument_list|(
name|p
operator|->
name|inTree
argument_list|)
operator|.
name|PtrTType
operator|==
name|pNIL
condition|)
block|{
name|pPointer
name|PtrTo
init|=
name|tCopy
argument_list|(
name|p
operator|->
name|ptr
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|pDEF
argument_list|(
name|p
operator|->
name|inTree
argument_list|)
operator|.
name|PtrTType
operator|=
name|PtrTo
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC
name|fixfwdtype
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|ptr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

end_unit

