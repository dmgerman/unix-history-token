begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tmps.c	5.2 (Berkeley) 11/12/86"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_include
include|#
directive|include
file|"pc.h"
end_include

begin_endif
endif|#
directive|endif
endif|PC
end_endif

begin_include
include|#
directive|include
file|"align.h"
end_include

begin_include
include|#
directive|include
file|"tmps.h"
end_include

begin_comment
comment|/*  * This routine defines the register allocation strategy  * All temporaries are allocated here, and this routines decides  * where they are to be put.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_comment
comment|/*      *	register temporaries      *	- are allocated from highreg towards lowreg.      *	- are of size regsize.      *	- register numbers from the various register types are mapped to       *	  integer register numbers using the offsets.  (cf. pcc/mac2defs)      *      *	stack temporaries      *	- are allocated on a downward growing stack.      */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_comment
comment|/*      *	first pass register declaration constants      */
end_comment

begin_struct
struct|struct
name|regtype
block|{
name|long
name|lowreg
decl_stmt|;
name|long
name|highreg
decl_stmt|;
name|long
name|regsize
decl_stmt|;
block|}
name|regtypes
index|[
name|NUMREGTYPES
index|]
init|=
block|{
block|{
literal|6
block|,
literal|11
block|,
literal|4
block|}
block|,
comment|/* r6..r11 */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
endif|vax
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|tahoe
end_ifdef

begin_comment
comment|/*      *	first pass register declaration constants      */
end_comment

begin_struct
struct|struct
name|regtype
block|{
name|long
name|lowreg
decl_stmt|;
name|long
name|highreg
decl_stmt|;
name|long
name|regsize
decl_stmt|;
block|}
name|regtypes
index|[
name|NUMREGTYPES
index|]
init|=
block|{
block|{
literal|6
block|,
literal|12
block|,
literal|4
block|}
block|,
comment|/* r6..r12 */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
endif|tahoe
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|mc68000
end_ifdef

begin_comment
comment|/*      *	first pass register declaration constants      */
end_comment

begin_struct
struct|struct
name|regtype
block|{
name|long
name|lowreg
decl_stmt|;
name|long
name|highreg
decl_stmt|;
name|long
name|regsize
decl_stmt|;
block|}
name|regtypes
index|[
name|NUMREGTYPES
index|]
init|=
block|{
block|{
literal|2
block|,
literal|7
block|,
literal|4
block|}
block|,
comment|/* d2..d7 */
block|{
literal|2
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* a2..a5 */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
endif|mc68000
end_endif

begin_endif
endif|#
directive|endif
endif|PC
end_endif

begin_macro
name|tmpinit
argument_list|(
argument|cbn
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cbn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|om
modifier|*
name|sizesp
init|=
operator|&
name|sizes
index|[
name|cbn
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PC
name|int
name|i
decl_stmt|;
endif|#
directive|endif
endif|PC
name|sizesp
operator|->
name|om_max
operator|=
operator|-
name|DPOFF1
expr_stmt|;
name|sizesp
operator|->
name|curtmps
operator|.
name|om_off
operator|=
operator|-
name|DPOFF1
expr_stmt|;
ifdef|#
directive|ifdef
name|PC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMREGTYPES
condition|;
name|i
operator|++
control|)
block|{
name|sizesp
operator|->
name|low_water
index|[
name|i
index|]
operator|=
name|regtypes
index|[
name|i
index|]
operator|.
name|highreg
operator|+
literal|1
expr_stmt|;
name|sizesp
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|i
index|]
operator|=
name|regtypes
index|[
name|i
index|]
operator|.
name|highreg
expr_stmt|;
block|}
endif|#
directive|endif
endif|PC
block|}
end_block

begin_comment
comment|/*  * allocate runtime temporary variables  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|struct
name|nl
modifier|*
name|tmpalloc
parameter_list|(
name|size
parameter_list|,
name|type
parameter_list|,
name|mode
parameter_list|)
name|long
name|size
decl_stmt|;
name|struct
name|nl
modifier|*
name|type
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|om
modifier|*
name|op
init|=
operator|&
name|sizes
index|[
name|cbn
index|]
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|nlp
decl_stmt|;
name|long
name|alignment
decl_stmt|;
ifdef|#
directive|ifdef
name|PC
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
if|if
condition|(
name|mode
operator|==
name|REGOK
operator|&&
name|size
operator|==
name|regtypes
index|[
name|REG_GENERAL
index|]
operator|.
name|regsize
operator|&&
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_GENERAL
index|]
operator|>=
name|regtypes
index|[
name|REG_GENERAL
index|]
operator|.
name|lowreg
condition|)
block|{
name|offset
operator|=
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_GENERAL
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|op
operator|->
name|low_water
index|[
name|REG_GENERAL
index|]
condition|)
block|{
name|op
operator|->
name|low_water
index|[
name|REG_GENERAL
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|nlp
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|VAR
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|extra_flags
operator|=
name|NLOCAL
operator||
name|NREGVAR
expr_stmt|;
name|putlbracket
argument_list|(
name|ftnno
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|nlp
return|;
block|}
endif|#
directive|endif
endif|vax || tahoe
ifdef|#
directive|ifdef
name|mc68000
if|if
condition|(
name|mode
operator|==
name|REGOK
operator|&&
name|type
operator|!=
name|nl
operator|+
name|TPTR
operator|&&
name|size
operator|==
name|regtypes
index|[
name|REG_DATA
index|]
operator|.
name|regsize
operator|&&
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_DATA
index|]
operator|>=
name|regtypes
index|[
name|REG_DATA
index|]
operator|.
name|lowreg
condition|)
block|{
name|offset
operator|=
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_DATA
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|op
operator|->
name|low_water
index|[
name|REG_DATA
index|]
condition|)
block|{
name|op
operator|->
name|low_water
index|[
name|REG_DATA
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|nlp
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|VAR
argument_list|,
name|type
argument_list|,
name|offset
operator|+
name|DATA_REG_OFFSET
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|extra_flags
operator|=
name|NLOCAL
operator||
name|NREGVAR
expr_stmt|;
name|putlbracket
argument_list|(
name|ftnno
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|nlp
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|REGOK
operator|&&
name|type
operator|==
name|nl
operator|+
name|TPTR
operator|&&
name|size
operator|==
name|regtypes
index|[
name|REG_ADDR
index|]
operator|.
name|regsize
operator|&&
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_ADDR
index|]
operator|>=
name|regtypes
index|[
name|REG_ADDR
index|]
operator|.
name|lowreg
condition|)
block|{
name|offset
operator|=
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_ADDR
index|]
operator|--
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|op
operator|->
name|low_water
index|[
name|REG_ADDR
index|]
condition|)
block|{
name|op
operator|->
name|low_water
index|[
name|REG_ADDR
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|nlp
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|VAR
argument_list|,
name|type
argument_list|,
name|offset
operator|+
name|ADDR_REG_OFFSET
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|extra_flags
operator|=
name|NLOCAL
operator||
name|NREGVAR
expr_stmt|;
name|putlbracket
argument_list|(
name|ftnno
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
name|nlp
return|;
block|}
endif|#
directive|endif
endif|mc68000
endif|#
directive|endif
endif|PC
if|if
condition|(
name|type
operator|==
name|NIL
condition|)
block|{
name|alignment
operator|=
name|A_STACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|nl
operator|+
name|TPTR
condition|)
block|{
name|alignment
operator|=
name|A_POINT
expr_stmt|;
block|}
else|else
block|{
name|alignment
operator|=
name|align
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|op
operator|->
name|curtmps
operator|.
name|om_off
operator|=
name|roundup
argument_list|(
call|(
name|int
call|)
argument_list|(
name|op
operator|->
name|curtmps
operator|.
name|om_off
operator|-
name|size
argument_list|)
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|offset
operator|=
name|op
operator|->
name|curtmps
operator|.
name|om_off
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|op
operator|->
name|om_max
condition|)
block|{
name|op
operator|->
name|om_max
operator|=
name|offset
expr_stmt|;
block|}
name|nlp
operator|=
name|defnl
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|VAR
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC
name|nlp
operator|->
name|extra_flags
operator|=
name|NLOCAL
expr_stmt|;
name|putlbracket
argument_list|(
name|ftnno
argument_list|,
name|op
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|PC
return|return
name|nlp
return|;
block|}
end_function

begin_comment
comment|/*  * deallocate runtime temporary variables  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|tmpfree
argument_list|(
name|restore
argument_list|)
specifier|register
expr|struct
name|tmps
operator|*
name|restore
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|PC
specifier|register
name|struct
name|om
modifier|*
name|op
init|=
operator|&
name|sizes
index|[
name|cbn
index|]
decl_stmt|;
name|bool
name|change
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
if|if
condition|(
name|restore
operator|->
name|next_avail
index|[
name|REG_GENERAL
index|]
operator|>
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_GENERAL
index|]
condition|)
block|{
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_GENERAL
index|]
operator|=
name|restore
operator|->
name|next_avail
index|[
name|REG_GENERAL
index|]
expr_stmt|;
name|change
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
endif|vax || tahoe
ifdef|#
directive|ifdef
name|mc68000
if|if
condition|(
name|restore
operator|->
name|next_avail
index|[
name|REG_DATA
index|]
operator|>
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_DATA
index|]
condition|)
block|{
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_DATA
index|]
operator|=
name|restore
operator|->
name|next_avail
index|[
name|REG_DATA
index|]
expr_stmt|;
name|change
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|restore
operator|->
name|next_avail
index|[
name|REG_ADDR
index|]
operator|>
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_ADDR
index|]
condition|)
block|{
name|op
operator|->
name|curtmps
operator|.
name|next_avail
index|[
name|REG_ADDR
index|]
operator|=
name|restore
operator|->
name|next_avail
index|[
name|REG_ADDR
index|]
expr_stmt|;
name|change
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
endif|mc68000
if|if
condition|(
name|restore
operator|->
name|om_off
operator|>
name|op
operator|->
name|curtmps
operator|.
name|om_off
condition|)
block|{
name|op
operator|->
name|curtmps
operator|.
name|om_off
operator|=
name|restore
operator|->
name|om_off
expr_stmt|;
name|change
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|change
condition|)
block|{
name|putlbracket
argument_list|(
name|ftnno
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|PC
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|PC
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_comment
comment|/*  * create a save mask for registers which have been used  * in this level  */
end_comment

begin_macro
name|savmask
argument_list|()
end_macro

begin_block
block|{
name|int
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
name|RSAVEMASK
expr_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'t'
argument_list|)
condition|)
name|mask
operator||=
name|RUNCHECK
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|regtypes
index|[
name|REG_GENERAL
index|]
operator|.
name|highreg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|sizes
index|[
name|cbn
index|]
operator|.
name|low_water
index|[
name|REG_GENERAL
index|]
condition|)
block|{
name|mask
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
return|return
name|mask
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|vax || tahoe
end_endif

begin_endif
endif|#
directive|endif
endif|PC
end_endif

end_unit

