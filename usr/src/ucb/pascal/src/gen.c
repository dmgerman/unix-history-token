begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)gen.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ
end_ifdef

begin_comment
comment|/*      *	and the rest of the file      */
end_comment

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_include
include|#
directive|include
file|"objfmt.h"
end_include

begin_comment
comment|/*  * This array tells the type  * returned by an arithmetic  * operation.  It is indexed  * by the logarithm of the  * lengths base 2.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_decl_stmt
name|char
name|arret
index|[]
init|=
block|{
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|arret0
index|[]
init|=
block|{
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|arret1
index|[]
init|=
block|{
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|T4INT
block|,
name|T4INT
block|,
name|T4INT
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|,
name|TDOUBLE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arret
init|=
name|arret0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These array of arithmetic and set  * operators are indexed by the  * tree nodes and is highly dependent  * on their order.  They thus take  * on the flavor of magic.  */
end_comment

begin_decl_stmt
name|int
name|arop
index|[]
init|=
block|{
literal|0
block|,
name|O_NEG2
block|,
name|O_MOD2
block|,
name|O_DIV2
block|,
name|O_DVD2
block|,
name|O_MUL2
block|,
name|O_ADD2
block|,
name|O_SUB2
block|,
name|O_REL2
block|,
name|O_REL2
block|,
name|O_REL2
block|,
name|O_REL2
block|,
name|O_REL2
block|,
name|O_REL2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setop
index|[]
init|=
block|{
name|O_MULT
block|,
name|O_ADDT
block|,
name|O_SUBT
block|,
name|O_RELT
block|,
name|O_RELT
block|,
name|O_RELT
block|,
name|O_RELT
block|,
name|O_RELT
block|,
name|O_RELT
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following array is  * used when operating on  * two reals since they are  * shoved off in a corner in  * the interpreter table.  */
end_comment

begin_decl_stmt
name|int
name|ar8op
index|[]
init|=
block|{
name|O_DVD8
block|,
name|O_MUL8
block|,
name|O_ADD8
block|,
name|O_SUB8
block|,
name|O_REL8
block|,
name|O_REL8
block|,
name|O_REL8
block|,
name|O_REL8
block|,
name|O_REL8
block|,
name|O_REL8
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following arrays, which are linearizations  * of two dimensional arrays, are the offsets for  * arithmetic, relational and assignment operations  * indexed by the logarithms of the argument widths.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_decl_stmt
name|char
name|artab
index|[]
init|=
block|{
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD42
operator|-
name|O_ADD2
block|,
name|O_ADD82
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD42
operator|-
name|O_ADD2
block|,
name|O_ADD82
operator|-
name|O_ADD2
block|,
name|O_ADD24
operator|-
name|O_ADD2
block|,
name|O_ADD24
operator|-
name|O_ADD2
block|,
name|O_ADD4
operator|-
name|O_ADD2
block|,
name|O_ADD84
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
name|O_ADD48
operator|-
name|O_ADD2
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|artab0
index|[]
init|=
block|{
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD42
operator|-
name|O_ADD2
block|,
name|O_ADD82
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD42
operator|-
name|O_ADD2
block|,
name|O_ADD82
operator|-
name|O_ADD2
block|,
name|O_ADD24
operator|-
name|O_ADD2
block|,
name|O_ADD24
operator|-
name|O_ADD2
block|,
name|O_ADD4
operator|-
name|O_ADD2
block|,
name|O_ADD84
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
name|O_ADD48
operator|-
name|O_ADD2
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|artab1
index|[]
init|=
block|{
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD82
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD82
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD2
operator|-
name|O_ADD2
block|,
name|O_ADD84
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
name|O_ADD28
operator|-
name|O_ADD2
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|artab
init|=
name|artab0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_decl_stmt
name|char
name|reltab
index|[]
init|=
block|{
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL42
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL42
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL24
operator|-
name|O_REL2
block|,
name|O_REL24
operator|-
name|O_REL2
block|,
name|O_REL4
operator|-
name|O_REL2
block|,
name|O_REL84
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL48
operator|-
name|O_REL2
block|,
name|O_REL8
operator|-
name|O_REL2
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|reltab0
index|[]
init|=
block|{
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL42
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL42
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL24
operator|-
name|O_REL2
block|,
name|O_REL24
operator|-
name|O_REL2
block|,
name|O_REL4
operator|-
name|O_REL2
block|,
name|O_REL84
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL48
operator|-
name|O_REL2
block|,
name|O_REL8
operator|-
name|O_REL2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|reltab1
index|[]
init|=
block|{
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL2
operator|-
name|O_REL2
block|,
name|O_REL82
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL28
operator|-
name|O_REL2
block|,
name|O_REL8
operator|-
name|O_REL2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|reltab
init|=
name|reltab0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_decl_stmt
name|char
name|asgntab
index|[]
init|=
block|{
name|O_AS21
operator|-
name|O_AS2
block|,
name|O_AS21
operator|-
name|O_AS2
block|,
name|O_AS41
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS42
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS24
operator|-
name|O_AS2
block|,
name|O_AS24
operator|-
name|O_AS2
block|,
name|O_AS4
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS48
operator|-
name|O_AS2
block|,
name|O_AS8
operator|-
name|O_AS2
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|asgntb0
index|[]
init|=
block|{
name|O_AS21
operator|-
name|O_AS2
block|,
name|O_AS21
operator|-
name|O_AS2
block|,
name|O_AS41
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS42
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS24
operator|-
name|O_AS2
block|,
name|O_AS24
operator|-
name|O_AS2
block|,
name|O_AS4
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS48
operator|-
name|O_AS2
block|,
name|O_AS8
operator|-
name|O_AS2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|asgntb1
index|[]
init|=
block|{
name|O_AS21
operator|-
name|O_AS2
block|,
name|O_AS21
operator|-
name|O_AS2
block|,
name|O_AS21
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
name|O_AS2
operator|-
name|O_AS2
block|,
operator|-
literal|1
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS28
operator|-
name|O_AS2
block|,
name|O_AS4
operator|-
name|O_AS2
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|asgntab
init|=
name|asgntb0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|genmx
argument_list|()
end_macro

begin_block
block|{
name|arret
operator|=
name|arret1
expr_stmt|;
name|artab
operator|=
name|artab1
expr_stmt|;
name|reltab
operator|=
name|reltab1
expr_stmt|;
name|asgntab
operator|=
name|asgntb1
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Gen generates code for assignments,  * and arithmetic and string operations  * and comparisons.  */
end_comment

begin_function
name|struct
name|nl
modifier|*
name|gen
parameter_list|(
name|p
parameter_list|,
name|o
parameter_list|,
name|w1
parameter_list|,
name|w2
parameter_list|)
name|int
name|p
decl_stmt|,
name|o
decl_stmt|,
name|w1
decl_stmt|,
name|w2
decl_stmt|;
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|int
name|op
decl_stmt|;
switch|switch
condition|(
name|p
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"gen"
argument_list|)
expr_stmt|;
case|case
name|O_AS2
case|:
case|case
name|NIL
case|:
name|i
operator|=
name|j
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Take the log2 of the widths 			 * and linearize them for indexing. 			 * width for indexing. 			 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|hp21mx
condition|)
block|{
if|if
condition|(
name|w1
operator|==
literal|4
condition|)
name|w1
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|w2
operator|==
literal|4
condition|)
name|w2
operator|=
literal|8
expr_stmt|;
block|}
endif|#
directive|endif
do|do
name|i
operator|++
expr_stmt|;
do|while
condition|(
name|w1
operator|>>=
literal|1
condition|)
do|;
do|do
name|j
operator|++
expr_stmt|;
do|while
condition|(
name|w2
operator|>>=
literal|1
condition|)
do|;
name|i
operator|<<=
literal|2
expr_stmt|;
name|i
operator||=
name|j
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|O_AS2
condition|)
block|{
operator|(
name|void
operator|)
name|put
argument_list|(
literal|1
argument_list|,
name|O_AS2
operator|+
name|asgntab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|op
operator|=
name|arop
index|[
name|o
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_REL2
condition|)
block|{
operator|(
name|void
operator|)
name|put
argument_list|(
literal|1
argument_list|,
operator|(
name|op
operator|+
name|reltab
index|[
name|i
index|]
operator|)
operator||
operator|(
name|o
operator|-
name|T_EQ
operator|)
operator|<<
literal|8
operator|+
name|INDX
argument_list|)
expr_stmt|;
return|return
operator|(
name|nl
operator|+
name|TBOOL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|put
argument_list|(
literal|1
argument_list|,
name|i
operator|==
literal|15
condition|?
name|ar8op
index|[
name|o
operator|-
name|T_DIVD
index|]
else|:
name|op
operator||
name|artab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|op
operator|==
name|O_DVD2
operator|&&
operator|!
name|divchk
condition|?
name|nl
operator|+
name|TDOUBLE
else|:
name|nl
operator|+
name|arret
index|[
name|i
index|]
operator|)
return|;
case|case
name|TREC
case|:
case|case
name|TSTR
case|:
operator|(
name|void
operator|)
name|put
argument_list|(
literal|2
argument_list|,
name|O_RELG
operator||
operator|(
name|o
operator|-
name|T_EQ
operator|)
operator|<<
literal|8
operator|+
name|INDX
argument_list|,
name|w1
argument_list|)
expr_stmt|;
return|return
operator|(
name|nl
operator|+
name|TBOOL
operator|)
return|;
case|case
name|TSET
case|:
name|op
operator|=
name|setop
index|[
name|o
operator|-
name|T_MULT
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|O_RELT
condition|)
name|op
operator||=
operator|(
name|o
operator|-
name|T_EQ
operator|)
operator|<<
literal|8
operator|+
name|INDX
expr_stmt|;
operator|(
name|void
operator|)
name|put
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|w1
argument_list|)
expr_stmt|;
return|return
operator|(
name|o
operator|>=
name|T_EQ
condition|?
name|nl
operator|+
name|TBOOL
else|:
name|nl
operator|+
name|TSET
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|OBJ
end_endif

end_unit

