begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)tree.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"whoami.h"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_comment
comment|/*  * TREE SPACE DECLARATIONS  */
end_comment

begin_struct
struct|struct
name|tr
block|{
name|int
modifier|*
name|tr_low
decl_stmt|;
name|int
modifier|*
name|tr_high
decl_stmt|;
block|}
name|ttab
index|[
name|MAXTREE
index|]
struct|,
modifier|*
name|tract
struct|;
end_struct

begin_comment
comment|/*  * The variable space is the  * absolute base of the tree segments.  * (exactly the same as ttab[0].tr_low)  * Spacep is maintained to point at the  * beginning of the next tree slot to  * be allocated for use by the grammar.  * Spacep is used "extern" by the semantic  * actions in pas.y.  * The variable tract is maintained to point  * at the tree segment out of which we are  * allocating (the active segment).  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|space
decl_stmt|,
modifier|*
name|spacep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TREENMAX is the maximum width  * in words that any tree node   * due to the way in which the parser uses  * the pointer spacep.  */
end_comment

begin_define
define|#
directive|define
name|TREENMAX
value|6
end_define

begin_decl_stmt
name|int
name|trspace
index|[
name|ITREE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|space
init|=
name|trspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|spacep
init|=
name|trspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tr
modifier|*
name|tract
init|=
name|ttab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Inittree allocates the first tree slot  * and sets up the first segment descriptor.  * A lot of this work is actually done statically  * above.  */
end_comment

begin_macro
name|inittree
argument_list|()
end_macro

begin_block
block|{
name|ttab
index|[
literal|0
index|]
operator|.
name|tr_low
operator|=
name|space
expr_stmt|;
name|ttab
index|[
literal|0
index|]
operator|.
name|tr_high
operator|=
operator|&
name|space
index|[
name|ITREE
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Tree builds the nodes in the  * parse tree. It is rarely called  * directly, rather calls are made  * to tree[12345] which supplies the  * first argument to save space in  * the code. Tree also guarantees  * that spacep points to the beginning  * of the next slot it will return,  * a property required by the parser  * which was always true before we  * segmented the tree space.  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|struct
name|tnode
modifier|*
name|tree
parameter_list|(
name|cnt
parameter_list|,
name|a
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|cnt
expr_stmt|;
name|p
operator|=
name|spacep
expr_stmt|;
name|q
operator|=
operator|&
name|a
expr_stmt|;
do|do
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|q
operator|=
name|spacep
expr_stmt|;
name|spacep
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|TREENMAX
operator|>=
name|tract
operator|->
name|tr_high
condition|)
comment|/* 		 * this peek-ahead should 		 * save a great number of calls 		 * to tralloc. 		 */
name|tralloc
argument_list|(
name|TREENMAX
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|tnode
operator|*
operator|)
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tralloc preallocates enough  * space in the tree to allow  * the grammar to use the variable  * spacep, as it did before the  * tree was segmented.  */
end_comment

begin_macro
name|tralloc
argument_list|(
argument|howmuch
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|spacep
operator|+
name|howmuch
operator|>=
name|tract
operator|->
name|tr_high
condition|)
block|{
name|i
operator|=
name|TRINC
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|yerror
argument_list|(
literal|"Ran out of memory (tralloc)"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|spacep
operator|=
operator|(
name|int
operator|*
operator|)
name|cp
expr_stmt|;
name|tract
operator|++
expr_stmt|;
if|if
condition|(
name|tract
operator|>=
operator|&
name|ttab
index|[
name|MAXTREE
index|]
condition|)
block|{
name|yerror
argument_list|(
literal|"Ran out of tree tables"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|tract
operator|->
name|tr_low
operator|=
operator|(
name|int
operator|*
operator|)
name|cp
expr_stmt|;
name|tract
operator|->
name|tr_high
operator|=
name|tract
operator|->
name|tr_low
operator|+
name|i
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|yylacnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|B
modifier|*
name|bottled
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PXP
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Free up the tree segments  * at the end of a block.  * If there is scanner lookahead,  * i.e. if yylacnt != 0 or there is bottled output, then we  * cannot free the tree space.  * This happens only when errors  * occur and the forward move extends  * across "units".  */
end_comment

begin_macro
name|trfree
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|yylacnt
operator|!=
literal|0
operator|||
name|bottled
operator|!=
name|NIL
condition|)
return|return;
ifdef|#
directive|ifdef
name|PXP
if|if
condition|(
name|needtree
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|spacep
operator|=
name|space
expr_stmt|;
while|while
condition|(
name|tract
operator|->
name|tr_low
operator|>
name|spacep
operator|||
name|tract
operator|->
name|tr_high
operator|<=
name|spacep
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tract
operator|->
name|tr_low
argument_list|)
expr_stmt|;
name|tract
operator|->
name|tr_low
operator|=
name|NIL
expr_stmt|;
name|tract
operator|->
name|tr_high
operator|=
name|NIL
expr_stmt|;
name|tract
operator|--
expr_stmt|;
if|if
condition|(
name|tract
operator|<
name|ttab
condition|)
name|panic
argument_list|(
literal|"ttab"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PXP
name|packtree
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Copystr copies a token from  * the "token" buffer into the  * tree space.  */
end_comment

begin_expr_stmt
name|copystr
argument_list|(
name|token
argument_list|)
specifier|register
name|char
operator|*
name|token
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|strlen
argument_list|(
name|token
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|&
operator|~
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|tralloc
argument_list|(
name|i
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pstrcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spacep
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|spacep
expr_stmt|;
name|spacep
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|cp
operator|+
name|i
operator|)
expr_stmt|;
name|tralloc
argument_list|(
name|TREENMAX
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|cp
operator|)
return|;
block|}
end_block

end_unit

