begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	Copyright 1984, 1985 by the Regents of the University of  *	California and by Gregory Glenn Minshall.  *  *	Permission to use, copy, modify, and distribute these  *	programs and their documentation for any purpose and  *	without fee is hereby granted, provided that this  *	copyright and permission appear on all copies and  *	supporting documentation, the name of the Regents of  *	the University of California not be used in advertising  *	or publicity pertaining to distribution of the programs  *	without specific prior permission, and notice be given in  *	supporting documentation that copying and distribution is  *	by permission of the Regents of the University of California  *	and by Gregory Glenn Minshall.  Neither the Regents of the  *	University of California nor Gregory Glenn Minshall make  *	representations about the suitability of this software  *	for any purpose.  It is provided "as is" without  *	express or implied warranty.  */
end_comment

begin_comment
comment|/* this exists to patch over DataFromNetwork until it is ready */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"ascebc.h"
end_include

begin_include
include|#
directive|include
file|"3270.h"
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)datastream.c	2.12\t12/16/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_function_decl
name|void
name|EmptyTerminal
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CorrectTerminalCursor
parameter_list|()
value|((TransparentClock == OutputClock)? terminalCursorAddress:UnLocked? CursorAddress: HighestScreen())
end_define

begin_define
define|#
directive|define
name|SetHighestLowest
parameter_list|(
name|position
parameter_list|)
value|{ \ 					if (position< Lowest) { \ 					    Lowest = position; \ 					} \ 					if (position> Highest) { \ 					    Highest = position; \ 					} \ 				    }
end_define

begin_decl_stmt
specifier|extern
name|char
name|ebcasc
index|[
name|NEBCASC
index|]
index|[
name|NEBC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* translate table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|terminalCursorAddress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the cursor is on term */
end_comment

begin_decl_stmt
specifier|static
name|int
name|screenInitd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the screen has been initialized */
end_comment

begin_decl_stmt
specifier|static
name|int
name|MAX_CHANGES_BEFORE_POLL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many characters before looking */
end_comment

begin_comment
comment|/* at terminal and net again */
end_comment

begin_decl_stmt
specifier|static
name|int
name|needToRing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* need to ring terinal bell */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bellSequence
init|=
literal|"\07"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bell sequence (may be replaced by 					 * VB during initialization) 					 */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|KS
decl_stmt|,
modifier|*
name|KE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Turn on and off keyboard */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Blanks
index|[
sizeof|sizeof
name|Terminal
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lots of blanks */
end_comment

begin_comment
comment|/* some globals */
end_comment

begin_decl_stmt
name|int
name|OutputClock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what time it is */
end_comment

begin_decl_stmt
name|int
name|TransparentClock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time we were last in transparent */
end_comment

begin_escape
end_escape

begin_comment
comment|/* StartScreen - called to initialize the screen, etc. */
end_comment

begin_macro
name|StartScreen
argument_list|()
end_macro

begin_block
block|{
name|int
name|save
decl_stmt|;
name|struct
name|sgttyb
name|ourttyb
decl_stmt|;
specifier|static
name|int
name|speeds
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|75
block|,
literal|110
block|,
literal|134
block|,
literal|150
block|,
literal|200
block|,
literal|300
block|,
literal|600
block|,
literal|1200
block|,
literal|1800
block|,
literal|2400
block|,
literal|4800
block|,
literal|9600
block|}
decl_stmt|;
specifier|static
name|char
name|KSEbuffer
index|[
literal|2050
index|]
decl_stmt|;
name|char
modifier|*
name|lotsofspace
init|=
name|KSEbuffer
decl_stmt|,
modifier|*
name|tgetstr
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|screenInitd
condition|)
block|{
name|ioctl
argument_list|(
literal|1
argument_list|,
name|TIOCGETP
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ourttyb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ourttyb
operator|.
name|sg_ospeed
operator|<
literal|0
operator|)
operator|||
operator|(
name|ourttyb
operator|.
name|sg_ospeed
operator|>
name|B9600
operator|)
condition|)
block|{
name|MAX_CHANGES_BEFORE_POLL
operator|=
literal|1920
expr_stmt|;
block|}
else|else
block|{
name|MAX_CHANGES_BEFORE_POLL
operator|=
name|speeds
index|[
name|ourttyb
operator|.
name|sg_ospeed
index|]
operator|/
literal|10
expr_stmt|;
if|if
condition|(
name|MAX_CHANGES_BEFORE_POLL
operator|<
literal|40
condition|)
block|{
name|MAX_CHANGES_BEFORE_POLL
operator|=
literal|40
expr_stmt|;
block|}
block|}
name|save
operator|=
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
comment|/* start up curses */
name|nonl
argument_list|()
expr_stmt|;
comment|/* the problem is that curses catches SIGTSTP to 			 * be nice, but it messes us up. 			 */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|KS
operator|=
name|tgetstr
argument_list|(
literal|"ks"
argument_list|,
operator|&
name|lotsofspace
argument_list|)
expr_stmt|;
name|KE
operator|=
name|tgetstr
argument_list|(
literal|"ke"
argument_list|,
operator|&
name|lotsofspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|KS
condition|)
block|{
name|StringToTerminal
argument_list|(
name|KS
argument_list|)
expr_stmt|;
block|}
name|DoARefresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|mode
argument_list|(
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|VB
operator|&&
operator|*
name|VB
condition|)
block|{
name|bellSequence
operator|=
name|VB
expr_stmt|;
comment|/* use visual bell */
block|}
name|screenInitd
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Stop3270 - called when we are going away... */
end_comment

begin_macro
name|Stop3270
argument_list|(
argument|doNewLine
argument_list|)
end_macro

begin_decl_stmt
name|int
name|doNewLine
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|screenInitd
condition|)
block|{
name|int
name|save
decl_stmt|;
name|move
argument_list|(
name|NUMBERLINES
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DoARefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|KE
condition|)
block|{
name|StringToTerminal
argument_list|(
name|KE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doNewLine
condition|)
block|{
name|StringToTerminal
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
name|EmptyTerminal
argument_list|()
expr_stmt|;
name|save
operator|=
name|mode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|mode
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ConnectScreen - called to reconnect to the screen */
end_comment

begin_macro
name|ConnectScreen
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|screenInitd
condition|)
block|{
if|if
condition|(
name|KS
condition|)
block|{
name|StringToTerminal
argument_list|(
name|KS
argument_list|)
expr_stmt|;
block|}
name|RefreshScreen
argument_list|()
expr_stmt|;
name|TryToSend
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* RefreshScreen - called to cause the screen to be refreshed */
end_comment

begin_macro
name|RefreshScreen
argument_list|()
end_macro

begin_block
block|{
name|clearok
argument_list|(
name|curscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|TryToSend
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear3270 - called to clear the screen */
end_comment

begin_macro
name|Clear3270
argument_list|()
end_macro

begin_block
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Host
argument_list|,
sizeof|sizeof
argument_list|(
name|Host
argument_list|)
argument_list|)
expr_stmt|;
name|DeleteAllFields
argument_list|()
expr_stmt|;
comment|/* get rid of all fields */
name|BufferAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Lowest
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
name|Highest
operator|=
name|HighestScreen
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* LocalClear3270() - clear the whole ball of wax, cheaply */
end_comment

begin_macro
name|LocalClear3270
argument_list|()
end_macro

begin_block
block|{
name|outputPurge
argument_list|()
expr_stmt|;
comment|/* flush all data to terminal */
name|clear
argument_list|()
expr_stmt|;
comment|/* clear in curses */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Terminal
argument_list|,
sizeof|sizeof
name|Terminal
argument_list|)
expr_stmt|;
name|Clear3270
argument_list|()
expr_stmt|;
comment|/* clear host part */
name|Lowest
operator|=
name|HighestScreen
argument_list|()
operator|+
literal|1
expr_stmt|;
comment|/* everything in sync... */
name|Highest
operator|=
name|LowestScreen
argument_list|()
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* OurExitString - designed to keep us from going through infinite recursion */
end_comment

begin_macro
name|OurExitString
argument_list|(
argument|file
argument_list|,
argument|string
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|recursion
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|recursion
condition|)
block|{
name|recursion
operator|=
literal|1
expr_stmt|;
name|ExitString
argument_list|(
name|file
argument_list|,
name|string
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|RingBell
argument_list|()
end_macro

begin_block
block|{
name|needToRing
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* AddHost - called to add a character to the buffer.  * 	We use a macro in this module, since we call it so  *	often from loops.  *  *	NOTE: It is a macro, so don't go around using AddHost(p, *c++), or  *	anything similar.  (I don't define any temporary variables, again  *	just for the speed.)  */
end_comment

begin_macro
name|AddHost
argument_list|(
argument|position
argument_list|,
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|position
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
define|#
directive|define
name|AddHostA
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
define|\
value|{								\ 	if (IsStartField(p)) {					\ 	    DeleteField(p);					\ 	    SetHighestLowest(p);				\ 	}							\ 	SetHost(p, c);						\     }
define|#
directive|define
name|AddHost
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
define|\
value|{								\ 	AddHostA(p,c);						\ 	if ((c != GetTerminal(p)) || TermIsStartField(p)) {	\ 	    SetHighestLowest(p);				\ 	}							\     }
comment|/* end of macro of AddHost */
name|AddHost
argument_list|(
name|position
argument_list|,
name|character
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* DoARefresh */
end_comment

begin_expr_stmt
specifier|static
name|DoARefresh
argument_list|()
block|{
if|if
condition|(
name|ERR
operator|==
name|refresh
argument_list|()
condition|)
block|{
name|OurExitString
argument_list|(
name|stderr
argument_list|,
literal|"ERR from refresh\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* TryToSend - send data out to user's terminal */
end_comment

begin_macro
unit|static
name|TryToSend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|pointer
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|fieldattr
decl_stmt|;
specifier|register
name|int
name|changes
decl_stmt|;
specifier|static
name|int
name|inHighlightMode
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|HaveInput
decl_stmt|;
comment|/* 1 if there is input to check out */
define|#
directive|define
name|SetHighlightMode
parameter_list|(
name|p
parameter_list|)
value|{ \ 		if (!IsStartField(p)&& IsHighlightedAttr(fieldattr)) { \ 		    if (!inHighlightMode) { \ 			inHighlightMode = 1; \ 			standout(); \ 		    } \ 		} else { \ 		    if (inHighlightMode) { \ 			inHighlightMode = 0; \ 			standend(); \ 		    } \ 		} \ 	    }
define|#
directive|define
name|DoCharacterAt
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|)
value|{ \ 		SetTerminal(p, c); \ 		if (p != HighestScreen()) { \ 		    c = TerminalCharacterAttr(ebcasc[0][c&0xff], p, \ 								fieldattr); \ 		    if (terminalCursorAddress != p) { \ 			if (ERR == mvaddch(ScreenLine(p), \ 						ScreenLineOffset(p), c)) {\ 			    char foo[100]; \ 			    \ 			    sprintf(foo, "ERR from mvaddch at %d (%d, %d)\n", \ 				    p, ScreenLine(p), ScreenLineOffset(p)); \ 			    OurExitString(stderr, foo, 1); \ 			} \ 		    } else { \ 			if (ERR == addch(c)) {\ 			    char foo[100]; \ 			    \ 			    sprintf(foo, "ERR from addch at %d (%d, %d)\n", \ 				    p, ScreenLine(p), ScreenLineOffset(p)); \ 			    OurExitString(stderr, foo, 1); \ 			} \ 		    } \ 		    terminalCursorAddress = ScreenInc(p); \ 		} \
comment|/* if (pointer%LINESIZE == LINESIZE-1) { \ 		    DoARefresh(); \ 		    if (TtyChars()> MAX_CHANGES_BEFORE_POLL) { \ 			EmptyTerminal(); \ 		    } \ 		} */
value|\ 	    }
comment|/* run through screen, printing out non-null lines */
comment|/* There are two separate reasons for wanting to terminate this      * loop early.  One is to respond to new input (either from      * the terminal or from the network [host]).  For this reason,      * we expect to see 'HaveInput' come true when new input comes in.       *      * The second reason is a bit more difficult (for me) to understand.      * Basically, we don't want to get too far ahead of the characters that      * appear on the screen.  Ideally, we would type out a few characters,      * wait until they appeared on the screen, then type out a few more.      * The reason for this is that the user, on seeing some characters      * appear on the screen may then start to type something.  We would      * like to look at what the user types at about the same 'time'      * (measured by characters being sent to the terminal) that the      * user types them.  For this reason, what we would like to do      * is update a bit, then call curses to do a refresh, flush the      * output to the terminal, then wait until the terminal data      * has been sent.      *      * Note that curses is useful for, among other things, deciding whether      * or not to send :ce: (clear to end of line), so we should call curses      * at end of lines (beginning of next lines).      *      * The problems here are the following:  If we do lots of write(2)s,      * we will be doing lots of context switches, thus lots of overhead      * (which we have already).  Second, if we do a select to wait for      * the output to drain, we have to contend with the fact that NOW      * we are scheduled to run, but who knows what the scheduler will      * decide when the output has caught up.      */
if|if
condition|(
name|Highest
operator|==
name|HighestScreen
argument_list|()
condition|)
block|{
name|Highest
operator|=
name|ScreenDec
argument_list|(
name|Highest
argument_list|)
expr_stmt|;
comment|/* else, while loop will never end */
block|}
if|if
condition|(
name|Lowest
operator|<
name|LowestScreen
argument_list|()
condition|)
block|{
name|Lowest
operator|=
name|LowestScreen
argument_list|()
expr_stmt|;
comment|/* could be -1 in some cases with 					 * unformatted screens. 					 */
block|}
if|if
condition|(
name|Highest
operator|>=
name|Lowest
condition|)
block|{
comment|/* if there is anything to do, do it.  We won't terminate 		 * the loop until we've gone at least to Highest. 		 */
name|pointer
operator|=
name|Lowest
expr_stmt|;
while|while
condition|(
operator|(
name|pointer
operator|<=
name|Highest
operator|)
operator|&&
operator|!
name|HaveInput
condition|)
block|{
comment|/* point at the next place of disagreement */
name|pointer
operator|+=
operator|(
name|bunequal
argument_list|(
name|Host
operator|+
name|pointer
argument_list|,
name|Terminal
operator|+
name|pointer
argument_list|,
operator|(
name|Highest
operator|-
name|pointer
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
name|Host
index|[
literal|0
index|]
argument_list|)
operator|/
sizeof|sizeof
name|Host
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* how many characters to change until the end of the 		 * current line 		 */
name|changes
operator|=
name|LINESIZE
operator|-
name|ScreenLineOffset
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
comment|/* what is the field attribute of the current position */
name|fieldattr
operator|=
name|FieldAttributes
argument_list|(
name|WhereAttrByte
argument_list|(
name|pointer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IsStartField
argument_list|(
name|pointer
argument_list|)
operator|!=
name|TermIsStartField
argument_list|(
name|pointer
argument_list|)
operator|)
operator|||
operator|(
name|IsStartField
argument_list|(
name|pointer
argument_list|)
operator|&&
name|fieldattr
operator|!=
name|TermAttributes
argument_list|(
name|pointer
argument_list|)
operator|)
condition|)
block|{
name|int
name|oldterm
decl_stmt|;
name|oldterm
operator|=
name|TermAttributes
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsStartField
argument_list|(
name|pointer
argument_list|)
condition|)
block|{
name|TermNewField
argument_list|(
name|pointer
argument_list|,
name|fieldattr
argument_list|)
expr_stmt|;
name|SetTerminal
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TermDeleteField
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
block|}
comment|/* We always do the first character in a divergent 		     * field, since otherwise the start of a field in 		     * the Host structure may leave a highlighted blank 		     * on the screen, and the start of a field in the 		     * Terminal structure may leave a non-highlighted 		     * something in the middle of a highlighted field 		     * on the screen. 		     */
name|SetHighlightMode
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|c
operator|=
name|GetHost
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|DoCharacterAt
argument_list|(
name|c
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|NotVisuallyCompatibleAttributes
argument_list|(
name|pointer
argument_list|,
name|fieldattr
argument_list|,
name|oldterm
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
name|j
operator|=
name|pointer
expr_stmt|;
name|pointer
operator|=
name|ScreenInc
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|SetHighlightMode
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
comment|/* Turn on highlighting */
while|while
condition|(
operator|!
name|IsStartField
argument_list|(
name|pointer
argument_list|)
operator|&&
operator|!
name|TermIsStartField
argument_list|(
name|pointer
argument_list|)
condition|)
block|{
name|c
operator|=
name|GetHost
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|DoCharacterAt
argument_list|(
name|c
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
comment|/* MACRO */
name|pointer
operator|=
name|ScreenInc
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|--
name|changes
operator|)
condition|)
block|{
name|DoARefresh
argument_list|()
expr_stmt|;
name|EmptyTerminal
argument_list|()
expr_stmt|;
comment|/* We don't look at HaveInput here, since 				 * if we leave this loop before the end of 				 * the 3270 field, we could have pointer 				 * higher than Highest.  This would cause 				 * us to end the highest "while" loop, 				 * but we may, in fact, need to go around the 				 * screen once again. 				 */
block|}
comment|/*		The loop needs to be protected 			 *	from the situation where there had been only 			 *	one field on the Terminal, and none on the Host. 			 *	In this case, we have just deleted our last 			 *	field.  Hence, the break. 			 */
if|if
condition|(
name|j
operator|==
name|pointer
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|TermIsStartField
argument_list|(
name|pointer
argument_list|)
condition|)
block|{
comment|/* Remember what the terminal looked like */
name|TermNewField
argument_list|(
name|pointer
argument_list|,
name|oldterm
argument_list|)
expr_stmt|;
name|SetTerminal
argument_list|(
name|pointer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The danger here is that the current position may 			 * be the start of a Host field.  If so, and the field 			 * is highlighted, and our terminal was highlighted, 			 * then we will leave a highlighted blank at this 			 * position. 			 */
name|SetHighlightMode
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|DoCharacterAt
argument_list|(
name|c
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
block|}
comment|/* We could be in the situation of needing to exit. 			 * This could happen if the current field wrapped around 			 * the end of the screen. 			 */
if|if
condition|(
name|j
operator|>
name|pointer
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|c
operator|=
name|GetHost
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
comment|/* We always do the first character in a divergent 			 * field, since otherwise the start of a field in 			 * the Host structure may leave a highlighted blank 			 * on the screen, and the start of a field in the 			 * Terminal structure may leave a non-highlighted 			 * something in the middle of a highlighted field 			 * on the screen. 			 */
name|SetHighlightMode
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
name|DoCharacterAt
argument_list|(
name|c
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SetHighlightMode
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
comment|/* The following will terminate at least when we get back 		 * to the original 'pointer' location (since we force 		 * things to be equal). 		 */
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|GetHost
argument_list|(
name|pointer
argument_list|)
operator|)
operator|!=
name|GetTerminal
argument_list|(
name|pointer
argument_list|)
operator|)
operator|&&
operator|!
name|IsStartField
argument_list|(
name|pointer
argument_list|)
operator|&&
operator|!
name|TermIsStartField
argument_list|(
name|pointer
argument_list|)
condition|)
block|{
name|DoCharacterAt
argument_list|(
name|c
argument_list|,
name|pointer
argument_list|)
expr_stmt|;
name|pointer
operator|=
name|ScreenInc
argument_list|(
name|pointer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|--
name|changes
operator|)
condition|)
block|{
name|DoARefresh
argument_list|()
expr_stmt|;
name|EmptyTerminal
argument_list|()
expr_stmt|;
if|if
condition|(
name|HaveInput
condition|)
block|{
comment|/* if input came in, take it */
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
name|DoARefresh
argument_list|()
expr_stmt|;
name|Lowest
operator|=
name|pointer
expr_stmt|;
if|if
condition|(
name|Lowest
operator|>
name|Highest
condition|)
block|{
comment|/* if we finished input... */
name|Lowest
operator|=
name|HighestScreen
argument_list|()
operator|+
literal|1
expr_stmt|;
name|Highest
operator|=
name|LowestScreen
argument_list|()
operator|-
literal|1
expr_stmt|;
name|terminalCursorAddress
operator|=
name|CorrectTerminalCursor
argument_list|()
expr_stmt|;
if|if
condition|(
name|ERR
operator|==
name|move
argument_list|(
name|ScreenLine
argument_list|(
name|terminalCursorAddress
argument_list|)
argument_list|,
name|ScreenLineOffset
argument_list|(
name|terminalCursorAddress
argument_list|)
argument_list|)
condition|)
block|{
name|OurExitString
argument_list|(
name|stderr
argument_list|,
literal|"ERR from move\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|DoARefresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|needToRing
condition|)
block|{
name|StringToTerminal
argument_list|(
name|bellSequence
argument_list|)
expr_stmt|;
name|needToRing
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|EmptyTerminal
argument_list|()
expr_stmt|;
comment|/* move data along */
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* returns a 1 if no more output available (so, go ahead and block),     or a 0 if there is more output available (so, just poll the other     sources/destinations, don't block).  */
end_comment

begin_function
name|int
name|DoTerminalOutput
parameter_list|()
block|{
comment|/* called just before a select to conserve IO to terminal */
if|if
condition|(
name|Initialized
operator|&&
operator|(
operator|(
name|Lowest
operator|<=
name|Highest
operator|)
operator|||
name|needToRing
operator|||
operator|(
name|terminalCursorAddress
operator|!=
name|CorrectTerminalCursor
argument_list|()
operator|)
operator|)
condition|)
block|{
name|TryToSend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Lowest
operator|>
name|Highest
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* no more output now */
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* more output for future */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* returns the number of characters consumed */
end_comment

begin_function
name|int
name|DataFromNetwork
parameter_list|(
name|buffer
parameter_list|,
name|count
parameter_list|,
name|control
parameter_list|)
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* what the data is */
specifier|register
name|int
name|count
decl_stmt|;
comment|/* and how much there is */
name|int
name|control
decl_stmt|;
comment|/* this buffer terminated block */
block|{
name|int
name|origCount
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|Command
decl_stmt|;
specifier|static
name|int
name|Wcc
decl_stmt|;
specifier|static
name|int
name|LastWasTerminated
init|=
literal|0
decl_stmt|;
comment|/* was "control" = 1 last time? */
if|if
condition|(
operator|!
name|Initialized
condition|)
block|{
comment|/* not initialized */
name|int
name|abort
parameter_list|()
function_decl|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Host
argument_list|,
sizeof|sizeof
name|Host
argument_list|)
expr_stmt|;
name|DeleteAllFields
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|Blanks
condition|;
name|i
operator|++
control|)
block|{
name|Blanks
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Terminal
argument_list|,
sizeof|sizeof
name|Terminal
argument_list|)
expr_stmt|;
name|Lowest
operator|=
name|HighestScreen
argument_list|()
operator|+
literal|1
expr_stmt|;
name|Highest
operator|=
name|LowestScreen
argument_list|()
operator|-
literal|1
expr_stmt|;
name|terminalCursorAddress
operator|=
name|CursorAddress
operator|=
name|BufferAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UnLocked
operator|=
literal|1
expr_stmt|;
name|StartScreen
argument_list|()
expr_stmt|;
name|LastWasTerminated
operator|=
literal|1
expr_stmt|;
name|Initialized
operator|=
literal|1
expr_stmt|;
name|OutputClock
operator|=
literal|1
expr_stmt|;
name|TransparentClock
operator|=
operator|-
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|abort
argument_list|)
expr_stmt|;
block|}
name|origCount
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|LastWasTerminated
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|StringToTerminal
argument_list|(
literal|"Short count received from host!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
name|Command
operator|=
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
switch|switch
condition|(
name|Command
condition|)
block|{
comment|/* This had better be a read command */
case|case
name|CMD_READ_MODIFIED
case|:
name|DoReadModified
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_READ_BUFFER
case|:
name|DoReadBuffer
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* We consumed everything */
block|}
name|Command
operator|=
name|buffer
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
name|Wcc
operator|=
name|buffer
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|Wcc
operator|&
name|WCC_RESET_MDT
condition|)
block|{
name|i
operator|=
name|c
operator|=
name|WhereAttrByte
argument_list|(
name|LowestScreen
argument_list|()
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|HasMdt
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|TurnOffMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|FieldInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|c
condition|)
do|;
block|}
switch|switch
condition|(
name|Command
condition|)
block|{
case|case
name|CMD_ERASE_WRITE
case|:
name|Clear3270
argument_list|()
expr_stmt|;
if|if
condition|(
name|TransparentClock
operator|==
name|OutputClock
condition|)
block|{
name|clearok
argument_list|(
name|curscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_ERASE_ALL_UNPROTECTED
case|:
name|CursorAddress
operator|=
name|HighestScreen
argument_list|()
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|LowestScreen
argument_list|()
init|;
name|i
operator|<=
name|HighestScreen
argument_list|()
condition|;
name|ScreenInc
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|IsUnProtected
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|CursorAddress
operator|>
name|i
condition|)
block|{
name|CursorAddress
operator|=
name|i
expr_stmt|;
block|}
name|AddHost
argument_list|(
name|i
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HasMdt
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|TurnOffMdt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|CursorAddress
operator|==
name|HighestScreen
argument_list|()
operator|+
literal|1
condition|)
block|{
name|CursorAddress
operator|=
name|SetBufferAddress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|UnLocked
operator|=
literal|1
expr_stmt|;
name|AidByte
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CMD_WRITE
case|:
break|break;
default|default:
break|break;
block|}
name|count
operator|-=
literal|2
expr_stmt|;
comment|/* strip off command and wcc */
name|buffer
operator|+=
literal|2
expr_stmt|;
block|}
name|LastWasTerminated
operator|=
literal|0
expr_stmt|;
comment|/* then, reset at end... */
while|while
condition|(
name|count
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|c
operator|=
operator|(
operator|*
name|buffer
operator|++
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|IsOrder
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* handle an order */
switch|switch
condition|(
name|c
condition|)
block|{
define|#
directive|define
name|Ensure
parameter_list|(
name|x
parameter_list|)
value|if (count< x) { \ 					    if (!control) { \ 						return(origCount-(count+1)); \ 					    } else { \
comment|/* XXX - should not occur */
value|\ 						count = 0; \ 						break; \ 					    } \ 					}
case|case
name|ORDER_SF
case|:
name|Ensure
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|*
name|buffer
operator|++
operator|)
operator|&
literal|0xff
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IsStartField
argument_list|(
name|BufferAddress
argument_list|)
operator|&&
name|FieldAttributes
argument_list|(
name|BufferAddress
argument_list|)
operator|==
name|c
operator|)
condition|)
block|{
if|if
condition|(
name|NotVisuallyCompatibleAttributes
argument_list|(
name|BufferAddress
argument_list|,
name|c
argument_list|,
name|FieldAttributes
argument_list|(
name|BufferAddress
argument_list|)
argument_list|)
condition|)
block|{
name|SetHighestLowest
argument_list|(
name|BufferAddress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GetTerminal
argument_list|(
name|BufferAddress
argument_list|)
condition|)
block|{
name|SetHighestLowest
argument_list|(
name|BufferAddress
argument_list|)
expr_stmt|;
block|}
name|NewField
argument_list|(
name|BufferAddress
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|SetHost
argument_list|(
name|BufferAddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BufferAddress
operator|=
name|ScreenInc
argument_list|(
name|BufferAddress
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDER_SBA
case|:
name|Ensure
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|i
operator|=
name|buffer
index|[
literal|0
index|]
expr_stmt|;
name|c
operator|=
name|buffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|c
condition|)
block|{
comment|/* transparent write */
if|if
condition|(
operator|!
name|control
condition|)
block|{
return|return
operator|(
name|origCount
operator|-
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|Initialized
operator|&&
operator|(
operator|(
name|Lowest
operator|<=
name|Highest
operator|)
operator|||
name|needToRing
operator|||
operator|(
name|terminalCursorAddress
operator|!=
name|CorrectTerminalCursor
argument_list|()
operator|)
operator|)
condition|)
block|{
specifier|extern
name|int
name|HaveInput
decl_stmt|;
name|HaveInput
operator|=
literal|0
expr_stmt|;
name|TryToSend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TransparentClock
operator|!=
name|OutputClock
condition|)
block|{
if|if
condition|(
operator|!
name|DoTerminalOutput
argument_list|()
condition|)
block|{
return|return
operator|(
name|origCount
operator|-
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
return|;
block|}
name|move
argument_list|(
name|ScreenLine
argument_list|(
name|CursorAddress
argument_list|)
argument_list|,
name|ScreenLineOffset
argument_list|(
name|CursorAddress
argument_list|)
argument_list|)
expr_stmt|;
name|DoARefresh
argument_list|()
expr_stmt|;
block|}
name|TransparentClock
operator|=
name|OutputClock
expr_stmt|;
comment|/* this clock */
operator|(
name|void
operator|)
name|DataToTerminal
argument_list|(
name|buffer
operator|+
literal|2
argument_list|,
name|count
operator|-
literal|2
argument_list|)
expr_stmt|;
name|SendToIBM
argument_list|()
expr_stmt|;
name|TransparentClock
operator|=
name|OutputClock
operator|+
literal|1
expr_stmt|;
comment|/* clock next */
name|buffer
operator|+=
name|count
expr_stmt|;
name|count
operator|-=
name|count
expr_stmt|;
block|}
block|}
else|else
block|{
name|BufferAddress
operator|=
name|Addr3270
argument_list|(
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|buffer
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|ORDER_IC
case|:
name|CursorAddress
operator|=
name|BufferAddress
expr_stmt|;
break|break;
case|case
name|ORDER_PT
case|:
for|for
control|(
name|i
operator|=
name|ScreenInc
argument_list|(
name|BufferAddress
argument_list|)
init|;
operator|(
name|i
operator|!=
name|HighestScreen
argument_list|()
operator|)
condition|;
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
control|)
block|{
if|if
condition|(
name|IsStartField
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IsProtected
argument_list|(
name|ScreenInc
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|HighestScreen
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
name|CursorAddress
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|ORDER_RA
case|:
name|Ensure
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|i
operator|=
name|Addr3270
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|,
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|c
operator|=
name|buffer
index|[
literal|2
index|]
expr_stmt|;
do|do
block|{
name|AddHost
argument_list|(
name|BufferAddress
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|BufferAddress
operator|=
name|ScreenInc
argument_list|(
name|BufferAddress
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|BufferAddress
operator|!=
name|i
condition|)
do|;
name|buffer
operator|+=
literal|3
expr_stmt|;
name|count
operator|-=
literal|3
expr_stmt|;
break|break;
case|case
name|ORDER_EUA
case|:
comment|/* (from [here,there), ie: half open interval] */
name|Ensure
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|c
operator|=
name|FieldAttributes
argument_list|(
name|WhereAttrByte
argument_list|(
name|BufferAddress
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Addr3270
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|,
name|buffer
index|[
literal|1
index|]
argument_list|)
init|;
name|i
operator|!=
name|BufferAddress
condition|;
name|BufferAddress
operator|=
name|ScreenInc
argument_list|(
name|BufferAddress
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|IsProtectedAttr
argument_list|(
name|BufferAddress
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|AddHost
argument_list|(
name|BufferAddress
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|buffer
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
break|break;
case|case
name|ORDER_YALE
case|:
comment|/* special YALE defined order */
name|Ensure
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* need at least two characters */
if|if
condition|(
operator|(
operator|*
name|buffer
operator|&
literal|0xff
operator|)
operator|==
literal|0x5b
condition|)
block|{
name|i
operator|=
name|OptOrder
argument_list|(
name|buffer
operator|+
literal|1
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|origCount
operator|-
operator|(
name|count
operator|+
literal|1
operator|)
operator|)
return|;
comment|/* come here again */
block|}
else|else
block|{
name|buffer
operator|+=
literal|1
operator|+
name|i
expr_stmt|;
name|count
operator|-
operator|=
operator|(
literal|1
operator|+
name|i
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
comment|/* XXX ? */
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Data comes in large clumps - take it all */
name|i
operator|=
name|BufferAddress
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|AddHost
argument_list|(
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NOTDEF */
name|AddHostA
argument_list|(
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|SetHighestLowest
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTDEF */
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|&&
operator|!
name|IsOrder
argument_list|(
name|c
operator|=
operator|*
operator|(
name|buffer
operator|)
operator|&
literal|0xff
argument_list|)
condition|)
block|{
name|buffer
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTDEF
name|AddHost
argument_list|(
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* NOTDEF */
name|AddHostA
argument_list|(
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTDEF */
name|i
operator|=
name|ScreenInc
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOTDEF
if|if
condition|(
name|i
operator|==
name|LowestScreen
argument_list|()
condition|)
block|{
name|SetHighestLowest
argument_list|(
name|HighestScreen
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NOTDEF */
name|count
operator|--
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NOTDEF
name|SetHighestLowest
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTDEF */
name|BufferAddress
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|OutputClock
operator|++
expr_stmt|;
comment|/* time rolls on */
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|Wcc
operator|&
name|WCC_RESTORE
condition|)
block|{
if|if
condition|(
name|TransparentClock
operator|!=
name|OutputClock
condition|)
block|{
name|AidByte
operator|=
literal|0
expr_stmt|;
block|}
name|UnLocked
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|TerminalIn
argument_list|()
expr_stmt|;
comment|/* move along user's input */
block|}
if|if
condition|(
name|Wcc
operator|&
name|WCC_ALARM
condition|)
block|{
name|RingBell
argument_list|()
expr_stmt|;
block|}
block|}
name|LastWasTerminated
operator|=
name|control
expr_stmt|;
comment|/* state for next time */
return|return
operator|(
name|origCount
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|origCount
operator|-
name|count
operator|)
return|;
block|}
block|}
end_function

end_unit

