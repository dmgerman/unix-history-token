begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: sysline.c,v 1.4 83/07/31 23:47:49 layer Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * sysline - system status display on 25th line of terminal  * j.k.foderaro  *  * Prints a variety of information on the special status line of terminals  * that have a status display capability.  Cursor motions, status commands,  * etc. are gleamed from /etc/termcap.  * By default, all information is printed, and flags are given on the command  * line to disable the printing of information.  The information and  * disabling flags are:  *  *  flag	what  *  -----	----  *		time of day  *		load average and change in load average in the last 5 mins  *		number of user logged on  *   -p		# of processes the users owns which are runnable and the  *		  number which are suspended.  Processes whose parent is 1  *		  are not counted.  *   -l		users who've logged on and off.  *   -m		summarize new mail which has arrived  *   *<other flags>  *   -r		use non reverse video  *   -c		turn off 25th line for 5 seconds before redisplaying.  *   -b		beep once one the half hour, twice on the hour  *   +N		refresh display every N seconds.  *   -i		print pid first thing  *   -e		do simple print designed for an emacs buffer line  *   -h		print hostname between time and load average  *   -D		print day/date before time of day  *   -d		debug mode - print status line data in human readable format  *   -q		quiet mode - don't output diagnostic messages  *   -s		print Short (left-justified) line if escapes not allowed  *   -j		Print left Justified line regardless  *  */
end_comment

begin_comment
comment|/* for 4.2 BSD */
end_comment

begin_define
define|#
directive|define
name|BSD4_2
end_define

begin_define
define|#
directive|define
name|NETPREFIX
value|"ucb"
end_define

begin_comment
comment|/* turn this on always */
end_comment

begin_define
define|#
directive|define
name|WHO
end_define

begin_comment
comment|/* turn this on if you are on running 4.1a or greater (i.e. a system    with the gethostname() function */
end_comment

begin_define
define|#
directive|define
name|HOSTNAME
end_define

begin_define
define|#
directive|define
name|RWHO
end_define

begin_comment
comment|/* turn this on if you are running on vmunix */
end_comment

begin_define
define|#
directive|define
name|VMUNIX
end_define

begin_comment
comment|/* turn this on if you are running on 4.1c or greater */
end_comment

begin_define
define|#
directive|define
name|NEW_BOOTTIME
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_include
include|#
directive|include
file|<unctrl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/vtimes.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_define
define|#
directive|define
name|strcmpn
value|strncmp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_undef
undef|#
directive|undef
name|nl
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|TERMINFO
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RWHO
end_ifdef

begin_define
define|#
directive|define
name|DOWN_THRESHOLD
value|(2 * 60)
end_define

begin_define
define|#
directive|define
name|RWHOLEADER
value|"/usr/spool/rwho/whod."
end_define

begin_define
define|#
directive|define
name|MAXFILENAME
value|128
end_define

begin_struct
struct|struct
name|whod
block|{
name|char
name|wd_vers
decl_stmt|;
name|char
name|wd_type
decl_stmt|;
name|char
name|wd_fill
index|[
literal|2
index|]
decl_stmt|;
name|int
name|wd_sendtime
decl_stmt|;
name|int
name|wd_recvtime
decl_stmt|;
name|char
name|wd_hostname
index|[
literal|32
index|]
decl_stmt|;
name|int
name|wd_loadav
index|[
literal|3
index|]
decl_stmt|;
name|int
name|wd_boottime
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|outmp
block|{
name|char
name|out_line
index|[
literal|8
index|]
decl_stmt|;
comment|/* tty name */
name|char
name|out_name
index|[
literal|8
index|]
decl_stmt|;
comment|/* user id */
name|long
name|out_time
decl_stmt|;
comment|/* time	on */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
endif|RWHO
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_define
define|#
directive|define
name|MAXUSERS
value|100
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXUSERS
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFDELAY
value|60
end_define

begin_comment
comment|/* update status once per minute */
end_comment

begin_define
define|#
directive|define
name|MAILDIR
value|"/usr/spool/mail"
end_define

begin_comment
comment|/* if MaxLoad is defined, then if the load average exceeded MaxLoad  * then the process table will not be scanned and the log in/out data  * will not be checked.   The purpose of this is to reduced the load  * on the system when it is loaded.  */
end_comment

begin_define
define|#
directive|define
name|MaxLoad
value|6.0
end_define

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
ifdef|#
directive|ifdef
name|NEW_BOOTTIME
block|{
block|{
literal|"_boottime"
block|}
block|,
comment|/* After 4.1a the label changed to "boottime" */
else|#
directive|else
block|{
block|{
literal|"_bootime"
block|}
block|,
comment|/* Under 4.1a and earlier it is "bootime" */
endif|#
directive|endif
define|#
directive|define
name|NL_BOOT
value|0
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|NL_PROC
value|1
block|{
literal|"_avenrun"
block|}
block|,
define|#
directive|define
name|NL_AVEN
value|2
ifdef|#
directive|ifdef
name|VMUNIX
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|NL_NPROC
value|3
endif|#
directive|endif
block|{
literal|0
block|}
block|}
block|;  struct
name|proc
operator|*
name|pr
block|;
name|int
name|nproc
block|;
name|int
name|procadr
block|;
name|double
name|avenrun
index|[
literal|3
index|]
block|;
comment|/* used for storing load averages */
name|int
name|kmem
block|;
comment|/* file pointers for memory */
name|int
name|ut
block|;
name|int
name|users
block|,
name|nentries
block|;
ifdef|#
directive|ifdef
name|WHO
name|char
name|whofilename
index|[
literal|100
index|]
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RWHO
name|char
operator|*
name|remotehost
index|[
literal|10
index|]
block|;
name|int
name|nremotes
operator|=
literal|0
block|;
endif|#
directive|endif
endif|RWHO
ifdef|#
directive|ifdef
name|HOSTNAME
name|char
name|hostname
index|[
literal|32
index|]
block|;
endif|#
directive|endif
name|char
name|lockfilename
index|[
literal|100
index|]
block|;
comment|/* if exists, will prevent us from running */
comment|/* flags which determine which info is printed */
name|int
name|mailcheck
operator|=
literal|1
block|;
comment|/* m - do biff like checking of mail 	*/
name|int
name|proccheck
operator|=
literal|1
block|;
comment|/* p - give information on processes	*/
name|int
name|logcheck
operator|=
literal|1
block|;
comment|/* l - tell who logs in and out		*/
name|int
name|hostprint
operator|=
literal|0
block|;
comment|/* h - print out hostname		*/
name|int
name|dateprint
operator|=
literal|0
block|;
comment|/* h - print out day/date		*/
name|int
name|quiet
operator|=
literal|0
block|;
comment|/* q - hush diagnostic messages		*/
comment|/* flags which determine how things are printed */
name|int
name|clr_bet_ref
operator|=
literal|0
block|;
comment|/* c - clear line between refeshes 	*/
name|int
name|reverse
operator|=
literal|1
block|;
comment|/* r - use reverse video 		*/
name|int
name|shortline
operator|=
literal|0
block|;
comment|/* s - short (left-justified) if escapes not allowed */
name|int
name|leftline
operator|=
literal|0
block|;
comment|/* j - left-justified even if escapes allowed */
name|int
name|sawmail
block|;
comment|/* remember mail was seen to print bells	*/
comment|/* flags which have terminal do random things	*/
name|int
name|beep
operator|=
literal|0
block|;
comment|/* b - beep every half hour and twice every hour */
name|int
name|synch
operator|=
literal|1
block|;
comment|/* synchronize with clock		*/
name|int
name|printid
operator|=
literal|0
block|;
comment|/* print pid of this process at startup */
comment|/*  * used to turn off reverse video every REVOFF times  * in an attempt to not wear out the phospher.  */
define|#
directive|define
name|REVOFF
value|5
name|int
name|revtime
operator|=
literal|1
block|;
comment|/* select output device (status display or straight output (emacs window)) */
name|int
name|emacs
operator|=
literal|0
block|;
comment|/* assume status display */
name|int
name|dbug
operator|=
literal|0
block|;
comment|/* used by mail checker */
name|off_t
name|mailsize
operator|=
literal|0
block|;
name|off_t
name|linebeg
operator|=
literal|0
block|;
comment|/* place where we last left off reading */
comment|/* globals */
name|int
name|mailprocessed
block|;
name|char
operator|*
name|username
block|; struct
name|stat
name|stbuf
block|,
name|mstbuf
block|;
comment|/* mstbuf for mail check only */
name|char
operator|*
name|ourtty
block|,
operator|*
name|ttyname
argument_list|()
block|;
comment|/* keep track of what tty we're on */
name|char
operator|*
name|getenv
argument_list|()
block|;
name|char
operator|*
name|tparm
argument_list|()
block|,
operator|*
name|tgoto
argument_list|()
block|;
name|unsigned
name|delay
operator|=
name|DEFDELAY
block|;
name|int
name|chars
block|;
name|short
name|uid
block|;
name|double
name|loadavg
operator|=
literal|0.0
block|;
comment|/* current load average */
name|int
name|fullprocess
block|;
name|int
name|users
operator|=
literal|0
block|;
comment|/* strings which control status line display */
ifdef|#
directive|ifdef
name|TERMINFO
name|char
operator|*
name|rev_out
block|,
operator|*
name|rev_end
block|,
operator|*
name|arrows
block|;
else|#
directive|else
comment|/* TERMCAP */
name|char
name|to_status_line
index|[
literal|64
index|]
block|;
name|char
name|from_status_line
index|[
literal|64
index|]
block|;
name|char
name|dis_status_line
index|[
literal|64
index|]
block|;
name|char
name|rev_out
index|[
literal|20
index|]
block|,
name|rev_end
index|[
literal|20
index|]
block|;
name|char
operator|*
name|arrows
block|,
operator|*
name|bell
operator|=
literal|"\007"
block|;
name|int
name|eslok
block|;
comment|/* escapes on status line okay (reverse, cursor addressing) */
name|int
name|columns
block|;
endif|#
directive|endif
comment|/*   * In order to determine how many people are logged on and who has  * logged in or out, we read in the /etc/utmp file. We also keep track of   * the previous utmp file.  */
block|struct
name|utmp
name|uts
index|[
literal|2
index|]
index|[
name|MAXUSERS
index|]
block|;
name|outc
argument_list|(
argument|c
argument_list|)
name|char
name|c
block|;
block|{
if|if
condition|(
name|dbug
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|erroutc
argument_list|(
argument|c
argument_list|)
name|char
name|c
block|;
block|{
if|if
condition|(
name|dbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
expr|main
operator|(
name|argc
expr|,
name|argv
operator|)
name|char
operator|*
operator|*
name|argv
block|;
block|{
specifier|register
name|new
block|,
name|old
block|,
name|tmp
block|;
name|int
name|clearbotl
argument_list|()
block|;
name|char
operator|*
name|cp
block|;
specifier|extern
name|char
name|_sobuf
index|[]
block|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|_sobuf
argument_list|)
block|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
block|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
block|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
block|;
ifdef|#
directive|ifdef
name|VMUNIX
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
block|;
endif|#
directive|endif
comment|/*      * When we logoff, init will do a "vhangup()" on this      * tty which turns off I/O access and sends a SIGHUP      * signal.  We catch this and thereby clear the status      * display.  Note that a bug in 4.1bsd caused the SIGHUP      * signal to be sent to the wrong process, so you had to      * `kill -HUP' yourself in your .logout file.      */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|clearbotl
argument_list|)
block|;
ifdef|#
directive|ifdef
name|HOSTNAME
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
block|;
endif|#
directive|endif
name|argv
operator|++
block|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
for|for
control|(
name|cp
operator|=
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'r'
case|:
name|reverse
operator|=
literal|0
expr_stmt|;
comment|/* turn off reverse video */
break|break;
case|case
literal|'c'
case|:
name|clr_bet_ref
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hostprint
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dateprint
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RWHO
case|case
literal|'H'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|hostname
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
operator|&
name|hostname
index|[
name|strlen
argument_list|(
name|NETPREFIX
argument_list|)
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
block|}
name|remotehost
index|[
name|nremotes
operator|++
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argv
operator|++
operator|,
name|argc
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
endif|RWHO
case|case
literal|'m'
case|:
name|mailcheck
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|proccheck
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|logcheck
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|beep
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|printid
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|emacs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbug
operator|=
literal|1
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|shortline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|leftline
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: bad flag: %c\n"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'+'
case|:
name|delay
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delay
operator|<=
literal|10
operator|)
operator|||
operator|(
name|delay
operator|>
literal|500
operator|)
condition|)
name|delay
operator|=
name|DEFDELAY
expr_stmt|;
name|synch
operator|=
literal|0
expr_stmt|;
comment|/* no more sync */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: illegal argument %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|emacs
condition|)
block|{
name|columns
operator|=
literal|80
expr_stmt|;
block|}
else|else
block|{
comment|/* if not to emacs window, initialize terminal dependent info */
name|initterm
argument_list|()
expr_stmt|;
block|}
comment|/* immediately fork and let the parent die if not emacs mode */
if|if
condition|(
operator|!
name|emacs
operator|&&
operator|!
name|dbug
operator|&&
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
block|;
name|ourtty
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
block|;
comment|/* remember what tty we are on */
if|if
condition|(
name|printid
condition|)
block|{
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|strcpy
argument_list|(
name|whofilename
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strcat
argument_list|(
name|whofilename
argument_list|,
literal|"/.who"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strcpy
argument_list|(
name|lockfilename
argument_list|,
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|strcat
argument_list|(
name|lockfilename
argument_list|,
literal|"/.syslinelock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|ut
operator|=
name|open
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open utmp"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open kmem"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* read in namelist in order to get location of symbols */
end_comment

begin_expr_stmt
name|readnamelist
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|proccheck
condition|)
name|initprocread
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|mailcheck
condition|)
block|{
name|chdir
argument_list|(
name|MAILDIR
argument_list|)
expr_stmt|;
name|username
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|username
argument_list|,
operator|&
name|mstbuf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|mailsize
operator|=
name|mstbuf
operator|.
name|st_size
expr_stmt|;
block|}
else|else
name|mailsize
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|old
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|new
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|emacs
operator|||
name|isloggedin
argument_list|()
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|lockfilename
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|mailprocessed
operator|=
literal|0
expr_stmt|;
name|prtinfo
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|clr_bet_ref
condition|)
block|{
name|tputs
argument_list|(
name|dis_status_line
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|revtime
operator|=
operator|(
literal|1
operator|+
name|revtime
operator|)
operator|%
name|REVOFF
expr_stmt|;
comment|/* 	     * if we have processed mail, then dont switch utmp pointers 	     * since we havent printed the people whove logged in and out 	     */
if|if
condition|(
operator|!
name|mailprocessed
operator|||
operator|!
name|fullprocess
condition|)
block|{
name|tmp
operator|=
name|old
expr_stmt|;
name|old
operator|=
name|new
expr_stmt|;
name|new
operator|=
name|tmp
expr_stmt|;
block|}
block|}
else|else
name|sleep
argument_list|(
literal|60
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|clearbotl
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* NOTREACHED */
end_comment

begin_expr_stmt
unit|}  isloggedin
operator|(
operator|)
block|{
comment|/*     * you can tell if a person has logged out if the owner of     * the tty has changed     */
block|struct
name|stat
name|statbuf
block|;
if|if
condition|(
name|fstat
argument_list|(
literal|2
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|statbuf
operator|.
name|st_uid
operator|==
name|uid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
comment|/* not logged in */
end_comment

begin_expr_stmt
unit|}   readnamelist
operator|(
operator|)
block|{
name|time_t
name|bootime
block|,
name|clock
block|,
name|nintv
block|,
name|time
argument_list|()
block|;
ifdef|#
directive|ifdef
name|pdp11
name|nlist
argument_list|(
literal|"/unix"
argument_list|,
name|nl
argument_list|)
block|;
else|#
directive|else
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
block|;
endif|#
directive|endif
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No namelist\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_BOOT
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|bootime
argument_list|,
sizeof|sizeof
argument_list|(
name|bootime
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nintv
operator|=
name|clock
operator|-
name|bootime
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|nintv
operator|<=
literal|0L
operator|||
name|nintv
operator|>
literal|60L
operator|*
literal|60L
operator|*
literal|24L
operator|*
literal|365L
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Time makes no sense... namelist must be wrong\n"
argument_list|)
expr_stmt|;
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
operator|=
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  readutmp
operator|(
name|n
operator|)
block|{
name|lseek
argument_list|(
name|ut
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
block|;
name|nentries
operator|=
name|read
argument_list|(
name|ut
argument_list|,
operator|&
name|uts
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|,
name|MAXUSERS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
block|; }
comment|/*   * read in the process table locations and sizes, and allocate space  * for storing the process table.  This is done only once.  */
name|initprocread
argument_list|()
block|{
if|if
condition|(
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|VMUNIX
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|procadr
argument_list|,
sizeof|sizeof
argument_list|(
name|procadr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_NPROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
name|nproc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_expr_stmt
name|procadr
operator|=
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nproc
operator|=
name|NPROC
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* from param.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|pr
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|calloc
argument_list|(
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  * read in the process table.  This assumes that initprocread has alread been  * called to set up storage.  */
end_comment

begin_expr_stmt
unit|readproctab
operator|(
operator|)
block|{
if|if
condition|(
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* printf("There are %d entries beginning at %x\n",nproc,procadr); */
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|procadr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|read
argument_list|(
name|kmem
argument_list|,
name|pr
argument_list|,
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|1
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * codes to say what has happened to a particular entry in utmp  * NOCH means no change, ON means new person logged on,  * OFF means person logged off.  */
end_comment

begin_define
define|#
directive|define
name|NOCH
value|0;
end_define

begin_define
define|#
directive|define
name|ON
value|0x1
end_define

begin_define
define|#
directive|define
name|OFF
value|0x2
end_define

begin_expr_stmt
unit|prtinfo
operator|(
name|old
operator|,
name|new
operator|)
name|int
name|old
operator|,
name|new
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|procrun
decl_stmt|,
name|procstop
decl_stmt|;
name|int
name|on
decl_stmt|,
name|off
decl_stmt|;
name|int
name|status
index|[
name|MAXUSERS
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|double
name|diff
decl_stmt|;
name|char
modifier|*
name|sysrup
parameter_list|()
function_decl|;
name|stringinit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|WHO
comment|/* check for file named .who in the home directory */
name|whocheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|timeprint
argument_list|()
expr_stmt|;
comment|/* 	 * if mail is seen, don't print rest of info, just the mail 	 * reverse new and old so that next time we run, we won't lose log 	 * in and out information 	 */
if|if
condition|(
name|mailcheck
operator|&&
operator|(
name|sawmail
operator|=
name|mailseen
argument_list|()
operator|)
condition|)
block|{
name|mailprocessed
operator|=
literal|1
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
ifdef|#
directive|ifdef
name|HOSTNAME
ifdef|#
directive|ifdef
name|RWHO
if|if
condition|(
name|remotehost
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nremotes
condition|;
name|i
operator|++
control|)
name|stringprt
argument_list|(
literal|" %s"
argument_list|,
name|sysrup
argument_list|(
name|remotehost
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * print hostname info if requested 	 */
if|if
condition|(
name|hostprint
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
name|stringcat
argument_list|(
name|hostname
argument_list|,
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  	 * print load average and difference between current load average 	 * and the load average 5 minutes ago 	 */
if|if
condition|(
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
operator|!=
literal|0
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMUNIX
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
name|avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
name|loadav
argument_list|(
name|avenrun
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stringprt
argument_list|(
literal|"%.1f "
argument_list|,
name|avenrun
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|diff
operator|=
name|avenrun
index|[
literal|0
index|]
operator|-
name|avenrun
index|[
literal|1
index|]
operator|)
operator|<
literal|0.0
condition|)
name|stringprt
argument_list|(
literal|"%.1f"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
else|else
name|stringprt
argument_list|(
literal|"+%.1f"
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|loadavg
operator|=
name|avenrun
index|[
literal|0
index|]
expr_stmt|;
comment|/* remember load average */
block|}
comment|/* 	 * print log on and off information 	 */
name|stringspace
argument_list|()
expr_stmt|;
name|fullprocess
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MaxLoad
if|if
condition|(
name|loadavg
operator|>
name|MaxLoad
condition|)
name|fullprocess
operator|=
literal|0
expr_stmt|;
comment|/* too loaded to run */
endif|#
directive|endif
comment|/* read utmp file (logged in data) only if we are doing a full 	   process or if this is the first time and we are calculating 	   the number of users 	 */
if|if
condition|(
name|fullprocess
operator|||
operator|(
name|users
operator|==
literal|0
operator|)
condition|)
name|readutmp
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/*  	 * make a pass through utmp, checking if person has logged off 	 * or on.  Results are stored in status[] 	 */
name|on
operator|=
name|off
operator|=
literal|0
expr_stmt|;
comment|/* only do this if it hasn't been done yet (users == 0) or 	 * if the load average is low enough to permit it 	 */
if|if
condition|(
name|fullprocess
operator|||
operator|(
name|users
operator|==
literal|0
operator|)
condition|)
block|{
name|users
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmpn
argument_list|(
name|uts
index|[
name|old
index|]
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|,
name|uts
index|[
name|new
index|]
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|uts
index|[
name|old
index|]
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|ON
expr_stmt|;
name|on
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uts
index|[
name|new
index|]
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|OFF
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
else|else
block|{
name|status
index|[
name|i
index|]
operator|=
name|ON
operator||
name|OFF
expr_stmt|;
name|on
operator|++
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
block|}
else|else
name|status
index|[
name|i
index|]
operator|=
name|NOCH
expr_stmt|;
if|if
condition|(
name|uts
index|[
name|new
index|]
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
condition|)
name|users
operator|++
expr_stmt|;
block|}
block|}
comment|/* at this point we know how many users there are */
name|stringprt
argument_list|(
literal|"%du"
argument_list|,
name|users
argument_list|)
expr_stmt|;
comment|/* if there is any unread mail, put out a star */
comment|/* fprintf(stderr,"mailsz:%d,mtime:%d,atime:%d\n", 		mailsize,mstbuf.st_mtime,mstbuf.st_atime); */
if|if
condition|(
operator|(
name|mailsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|mstbuf
operator|.
name|st_mtime
operator|>=
name|mstbuf
operator|.
name|st_atime
operator|)
condition|)
name|stringcat
argument_list|(
literal|"*"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if the load is too high, then we indicate that with a - sign */
if|if
condition|(
operator|!
name|fullprocess
operator|&&
operator|(
name|proccheck
operator|||
name|logcheck
operator|)
condition|)
name|stringcat
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* if we are to check on number of process running, do so now */
if|if
condition|(
name|fullprocess
operator|&&
name|proccheck
operator|&&
name|readproctab
argument_list|()
condition|)
block|{
comment|/*  	     * we are only interested in processes which have the same 	     * uid as us, and whose parent process id is not 1. 	     */
name|procrun
operator|=
name|procstop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|p_stat
operator|==
literal|0
operator|)
operator|||
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|p_pgrp
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|p_uid
operator|==
name|uid
operator|)
operator|&&
operator|(
name|pr
index|[
name|i
index|]
operator|.
name|p_ppid
operator|!=
literal|1
operator|)
condition|)
block|{
comment|/* printf("found pid %d, stat=%o\n", pr[i].p_pid, pr[i].p_stat); */
switch|switch
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|p_stat
condition|)
block|{
case|case
name|SSTOP
case|:
name|procstop
operator|++
expr_stmt|;
break|break;
case|case
name|SSLEEP
case|:
comment|/* 			     * sleep can mean waiting for a signal or just 			     * in a disk or page wait queue ready to run. 			     * We can tell if it is the later by the pri being 			     * negative 			     */
if|if
condition|(
name|pr
index|[
name|i
index|]
operator|.
name|p_pri
operator|<
name|PZERO
condition|)
name|procrun
operator|++
expr_stmt|;
break|break;
case|case
name|SWAIT
case|:
case|case
name|SRUN
case|:
case|case
name|SIDL
case|:
name|procrun
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|procrun
operator|>
literal|0
operator|)
operator|||
operator|(
name|procstop
operator|>
literal|0
operator|)
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|procrun
operator|>
literal|0
operator|)
operator|&&
operator|(
name|procstop
operator|>
literal|0
operator|)
condition|)
block|{
name|stringprt
argument_list|(
literal|"%dr"
argument_list|,
name|procrun
argument_list|)
expr_stmt|;
name|stringprt
argument_list|(
literal|" %ds"
argument_list|,
name|procstop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|procrun
operator|>
literal|0
condition|)
name|stringprt
argument_list|(
literal|"%dr"
argument_list|,
name|procrun
argument_list|)
expr_stmt|;
else|else
name|stringprt
argument_list|(
literal|"%ds"
argument_list|,
name|procstop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  	 * if anyone has logged on or off, and we are interested in it, 	 * print it out 	 */
if|if
condition|(
name|logcheck
operator|&&
name|on
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
name|stringprt
argument_list|(
literal|"on:"
argument_list|,
name|on
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|&
name|ON
condition|)
block|{
name|stringprt
argument_list|(
literal|" %.8s"
argument_list|,
name|uts
index|[
name|new
index|]
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|ttyprint
argument_list|(
name|uts
index|[
name|new
index|]
index|[
name|i
index|]
operator|.
name|ut_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  	 * check for people logging off if we are intereste 	 */
if|if
condition|(
name|logcheck
operator|&&
name|off
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
name|stringprt
argument_list|(
literal|"off:"
argument_list|,
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|status
index|[
name|i
index|]
operator|&
name|OFF
condition|)
block|{
name|stringprt
argument_list|(
literal|" %.8s"
argument_list|,
name|uts
index|[
name|old
index|]
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|ttyprint
argument_list|(
name|uts
index|[
name|old
index|]
index|[
name|i
index|]
operator|.
name|ut_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bottom
label|:
comment|/* dump out what we know */
name|stringdump
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|timeprint
argument_list|()
end_macro

begin_block
block|{
name|long
name|curtime
decl_stmt|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|,
modifier|*
name|localtime
argument_list|()
decl_stmt|;
specifier|static
name|int
name|beepable
init|=
literal|0
decl_stmt|;
comment|/* always print time */
name|time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|dateprint
condition|)
name|stringprt
argument_list|(
literal|"%.11s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|curtime
argument_list|)
argument_list|)
expr_stmt|;
name|stringprt
argument_list|(
literal|"%d:"
argument_list|,
operator|(
name|tp
operator|->
name|tm_hour
operator|>
literal|12
condition|?
name|tp
operator|->
name|tm_hour
operator|-
literal|12
else|:
operator|(
name|tp
operator|->
name|tm_hour
operator|==
literal|0
condition|?
literal|12
else|:
name|tp
operator|->
name|tm_hour
operator|)
operator|)
argument_list|)
expr_stmt|;
name|stringprt
argument_list|(
literal|"%02d"
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|synch
condition|)
name|delay
operator|=
literal|60
operator|-
name|tp
operator|->
name|tm_sec
expr_stmt|;
comment|/* sync with clock */
comment|/* beepable is used to insure that we get at most one set of beeps 	    every half hour */
if|if
condition|(
name|beep
operator|&&
name|beepable
operator|&&
operator|(
name|tp
operator|->
name|tm_min
operator|==
literal|30
operator|)
condition|)
block|{
name|tputs
argument_list|(
name|bell
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|beepable
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|beep
operator|&&
name|beepable
operator|&&
operator|(
name|tp
operator|->
name|tm_min
operator|==
literal|00
operator|)
condition|)
block|{
name|tputs
argument_list|(
name|bell
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|bell
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|beepable
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|beep
operator|&&
operator|(
operator|(
name|tp
operator|->
name|tm_min
operator|!=
literal|00
operator|)
operator|||
operator|(
name|tp
operator|->
name|tm_min
operator|!=
literal|30
operator|)
operator|)
condition|)
name|beepable
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * whocheck -- check for file named .who and print it on the who line first  */
end_comment

begin_macro
name|whocheck
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|wf
operator|,
name|i
operator|,
name|chss
expr_stmt|;
name|char
name|buff
index|[
literal|81
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|wf
operator|=
name|open
argument_list|(
name|whofilename
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|chss
operator|=
name|read
argument_list|(
name|wf
argument_list|,
name|buff
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|chss
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|wf
argument_list|)
expr_stmt|;
return|return;
block|}
name|buff
index|[
name|chss
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*  	 * remove all line feeds, and replace by spaces if they are within 	 * the message, else replace them by nulls. 	 */
for|for
control|(
name|i
operator|=
name|chss
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buff
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|buff
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|buff
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
else|else
name|buff
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|stringprt
argument_list|(
literal|"%s"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|stringspace
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|wf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*   * ttyprint -- given the name of a tty, print in the string buffer its  * short name surrounded by parenthesis.  * ttyxx is printed as (xx)  * console is printed as (cty)  */
end_comment

begin_macro
name|ttyprint
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|strcmpn
argument_list|(
name|name
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"(%s)"
argument_list|,
name|name
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"console"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"(cty)"
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * mail checking function   * returns 0 if no mail seen  */
end_comment

begin_macro
name|mailseen
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|mfd
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|chs
decl_stmt|,
name|initchs
decl_stmt|;
specifier|register
name|char
modifier|*
name|rp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|lbuf
index|[
literal|100
index|]
decl_stmt|,
name|sendbuf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|toprint
decl_stmt|,
name|seenspace
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|username
argument_list|,
operator|&
name|mstbuf
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|mstbuf
operator|.
name|st_size
operator|>
name|mailsize
operator|)
operator|&&
operator|(
operator|(
name|mfd
operator|=
name|fopen
argument_list|(
name|username
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* fprintf(stderr,"Mail gotten was %db, now %db\n", 				 mailsize,stbuf.st_size); */
name|fseek
argument_list|(
name|mfd
argument_list|,
name|mailsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|initchs
operator|=
name|readline
argument_list|(
name|mfd
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|strcmpn
argument_list|(
name|lbuf
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|lbuf
operator|+
literal|5
expr_stmt|;
comment|/* start after the From */
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
operator|++
name|cp
operator|!=
literal|' '
operator|)
condition|)
empty_stmt|;
comment|/* skip to blank */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate name */
name|stringspace
argument_list|()
expr_stmt|;
comment|/*  if(!emacs) stringcat(bell,0,0);   BELL MOVED */
name|sprintf
argument_list|(
name|sendbuf
argument_list|,
literal|"Mail from %s "
argument_list|,
name|lbuf
operator|+
literal|5
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|sendbuf
argument_list|,
name|strlen
argument_list|(
name|sendbuf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* print message preceeded by little arrow */
comment|/* skip over the headers and look for blank line */
while|while
condition|(
operator|(
operator|(
name|chs
operator|=
name|readline
argument_list|(
name|mfd
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|chs
operator|!=
literal|0
operator|)
condition|)
if|if
condition|(
name|strcmpn
argument_list|(
name|lbuf
argument_list|,
literal|"Subject"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|sendbuf
argument_list|,
literal|"on %s"
argument_list|,
name|lbuf
operator|+
literal|9
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|sendbuf
argument_list|,
name|strlen
argument_list|(
name|sendbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|emacs
condition|)
name|stringcat
argument_list|(
name|arrows
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|stringcat
argument_list|(
literal|" : "
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chs
operator|!=
name|EOF
condition|)
block|{
name|cp
operator|=
name|sendbuf
expr_stmt|;
name|toprint
operator|=
name|columns
operator|-
name|chars
expr_stmt|;
comment|/* space left on line */
name|lbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|chs
operator|=
name|readline
argument_list|(
name|mfd
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|lbuf
argument_list|)
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|toprint
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* space before lines */
name|toprint
operator|--
expr_stmt|;
block|}
name|rp
operator|=
name|lbuf
expr_stmt|;
if|if
condition|(
name|strcmpn
argument_list|(
name|lbuf
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
break|break;
while|while
condition|(
operator|*
name|rp
operator|&&
operator|(
name|toprint
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seenspace
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|seenspace
operator|=
literal|1
expr_stmt|;
name|toprint
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|rp
expr_stmt|;
name|seenspace
operator|=
literal|0
expr_stmt|;
name|toprint
operator|--
expr_stmt|;
block|}
name|rp
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|stringcat
argument_list|(
name|sendbuf
argument_list|,
name|strlen
argument_list|(
name|sendbuf
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*  if(!emacs) stringcat(bell,0,0);   BELL MOVED */
name|retval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|initchs
operator|==
name|EOF
condition|)
block|{
name|stringprt
argument_list|(
literal|"Mail has just arrived"
argument_list|,
name|chs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * want to update write time  so a star will 	 * appear after the number of users until the 	 * user reads his mail  	 */
name|mailsize
operator|=
name|linebeg
expr_stmt|;
name|touch
argument_list|(
name|username
argument_list|,
name|mfd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
block|}
else|else
name|mailsize
operator|=
name|mstbuf
operator|.
name|st_size
expr_stmt|;
block|}
else|else
name|mailsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*   * readline -- read a line from fp and store it in buf.  * return the number of characters read.  */
end_comment

begin_macro
name|readline
argument_list|(
argument|fp
argument_list|,
argument|buf
argument_list|,
argument|maxch
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|size
init|=
name|maxch
decl_stmt|;
name|long
name|ftell
parameter_list|()
function_decl|;
name|linebeg
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* remember loc where line begins */
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|size
operator|--
operator|>
literal|0
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|==
name|maxch
operator|)
operator|&&
operator|(
name|ch
operator|==
name|EOF
operator|)
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
else|else
return|return
operator|(
name|maxch
operator|-
name|size
operator|)
return|;
block|}
end_block

begin_comment
comment|/* string hacking functions */
end_comment

begin_decl_stmt
name|int
name|eol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non zero when we have hit the end of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strarr
index|[
literal|120
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|stringinit
argument_list|()
end_macro

begin_block
block|{
name|sp
operator|=
name|strarr
expr_stmt|;
name|chars
operator|=
literal|0
expr_stmt|;
name|eol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|stringprt
argument_list|(
argument|format
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tempbuf
index|[
literal|150
index|]
decl_stmt|;
name|int
name|bufsiz
decl_stmt|;
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
name|format
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|strlen
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|tempbuf
argument_list|,
name|bufsiz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stringdump
argument_list|()
end_macro

begin_block
block|{
name|char
name|bigbuf
index|[
literal|200
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|blanks
index|[
literal|80
index|]
decl_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|bigbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|emacs
condition|)
block|{
if|if
condition|(
name|sawmail
condition|)
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|bell
argument_list|)
expr_stmt|;
if|if
condition|(
name|eslok
condition|)
block|{
if|if
condition|(
operator|!
name|leftline
condition|)
name|cp
operator|=
name|tparm
argument_list|(
name|to_status_line
argument_list|,
name|columns
operator|-
name|chars
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|tparm
argument_list|(
name|to_status_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|to_status_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shortline
operator|&
operator|!
name|leftline
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|columns
operator|-
name|chars
operator|)
condition|;
name|i
operator|++
control|)
name|blanks
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|blanks
index|[
name|columns
operator|-
name|chars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|blanks
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reverse
operator|&&
operator|!
operator|(
name|revtime
operator|==
literal|0
operator|)
condition|)
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|rev_out
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|strarr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emacs
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|rev_end
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|from_status_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sawmail
condition|)
block|{
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|bell
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bigbuf
argument_list|,
name|bell
argument_list|)
expr_stmt|;
block|}
name|tputs
argument_list|(
name|bigbuf
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbug
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
name|bigbuf
argument_list|,
name|strlen
argument_list|(
name|bigbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stringspace
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|emacs
operator|&&
name|reverse
operator|&&
operator|!
operator|(
name|revtime
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMINFO
name|stringcat
argument_list|(
name|rev_end
argument_list|,
name|magic_cookie_glitch
operator|<=
literal|0
condition|?
literal|0
else|:
name|magic_cookie_glitch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|rev_out
argument_list|,
name|magic_cookie_glitch
operator|<=
literal|0
condition|?
literal|0
else|:
name|magic_cookie_glitch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|stringcat
argument_list|(
name|rev_end
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|rev_out
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|stringcat
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * stringcat :: concatenate the characters in string str to the list we are   * 	        building to send out.  *    * the three args are  *    str - the string to print. may contain funny (terminal control) chars.  *    chrs - the number of printable characters in the string  *    trunc - a flag which is non zero if we should truncate strings which  *   	      don't fit.  If this is 0 then if a string doesn't completely  *	      fit it wont' be printed, this prevents us from getting 1/2  *	      way through an escape sequence.  */
end_comment

begin_macro
name|stringcat
argument_list|(
argument|str
argument_list|,
argument|chrs
argument_list|,
argument|trunc
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|chrs
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|eol
operator|&&
name|chars
operator|+
name|chrs
operator|<=
name|columns
operator|)
operator|||
operator|(
operator|!
name|eol
operator|&&
name|trunc
operator|&&
operator|(
name|chars
operator|<
name|columns
operator|)
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|sp
operator|++
operator|=
operator|*
name|str
operator|++
condition|)
if|if
condition|(
name|trunc
condition|)
block|{
if|if
condition|(
operator|++
name|chars
operator|>=
name|columns
condition|)
comment|/* check for trunc */
block|{
name|eol
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
name|sp
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|trunc
condition|)
name|chars
operator|+=
name|chrs
expr_stmt|;
block|}
else|else
name|eol
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * touch :: update the modify time of a file.  */
end_comment

begin_macro
name|touch
argument_list|(
argument|name
argument_list|,
argument|filedes
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|filedes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* already open for read file descriptor */
end_comment

begin_block
block|{
specifier|register
name|fd
expr_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|lseek
argument_list|(
name|fileno
argument_list|(
name|filedes
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fileno
argument_list|(
name|filedes
argument_list|)
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get first byte */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|)
operator|>=
literal|0
condition|)
comment|/* open in append mode */
block|{
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* go to beginning */
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* and rewrite first byte */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*   * clearbotl :: clear bottom line.    * called when process quits or is killed.  * it clears the bottom line of the terminal.  */
end_comment

begin_macro
name|clearbotl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|exit
parameter_list|()
function_decl|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* if can't open in 30 secs, just die */
if|if
condition|(
operator|!
name|emacs
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|ourtty
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|dis_status_line
argument_list|,
name|strlen
argument_list|(
name|dis_status_line
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TERMINFO
end_ifdef

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|standbuf
index|[
literal|40
index|]
decl_stmt|;
name|setupterm
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|has_status_line
condition|)
block|{
comment|/* not an appropriate terminal */
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: no status capability for %s\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status_line_esc_ok
condition|)
block|{
if|if
condition|(
name|set_attributes
condition|)
block|{
comment|/* reverse video mode */
name|strcpy
argument_list|(
name|standbuf
argument_list|,
name|tparm
argument_list|(
name|set_attributes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rev_out
operator|=
name|standbuf
expr_stmt|;
name|rev_end
operator|=
name|exit_attribute_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enter_standout_mode
operator|&&
name|exit_standout_mode
condition|)
block|{
name|rev_out
operator|=
name|enter_standout_mode
expr_stmt|;
name|rev_end
operator|=
name|exit_standout_mode
expr_stmt|;
block|}
else|else
block|{
name|rev_out
operator|=
name|rev_end
operator|=
literal|""
expr_stmt|;
block|}
block|}
else|else
name|rev_out
operator|=
name|rev_end
operator|=
literal|""
expr_stmt|;
name|columns
operator|--
expr_stmt|;
comment|/* avoid cursor wraparound */
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TERMCAP */
end_comment

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|term
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|tbuf
index|[
literal|1024
index|]
decl_stmt|,
name|is2
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|UP
decl_stmt|;
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: No TERM variable in enviroment\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tgetent
argument_list|(
name|tbuf
argument_list|,
name|term
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: Unknown terminal type: %s\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tgetflag
argument_list|(
literal|"hs"
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmpn
argument_list|(
name|term
argument_list|,
literal|"h19"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* for upward compatability with h19sys */
name|strcpy
argument_list|(
name|to_status_line
argument_list|,
literal|"\033j\033x5\033x1\033Y8%+ \033o"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|from_status_line
argument_list|,
literal|"\033k\033y5"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dis_status_line
argument_list|,
literal|"\033y1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rev_out
argument_list|,
literal|"\033p"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rev_end
argument_list|,
literal|"\033q"
argument_list|)
expr_stmt|;
name|arrows
operator|=
literal|"\033Fhh\033G"
expr_stmt|;
name|columns
operator|=
literal|80
expr_stmt|;
name|UP
operator|=
literal|"\b"
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: No status capability for %s\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|is2
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"i2"
argument_list|,
operator|&
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* someday tset will do this */
name|tputs
argument_list|(
name|is2
argument_list|,
literal|1
argument_list|,
name|erroutc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* the "-1" below is to avoid cursor wraparound problems */
name|columns
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cp
operator|=
name|to_status_line
expr_stmt|;
name|tgetstr
argument_list|(
literal|"ts"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|from_status_line
expr_stmt|;
name|tgetstr
argument_list|(
literal|"fs"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dis_status_line
expr_stmt|;
name|tgetstr
argument_list|(
literal|"ds"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|eslok
operator|=
name|tgetflag
argument_list|(
literal|"es"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eslok
condition|)
block|{
name|cp
operator|=
name|rev_out
expr_stmt|;
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rev_end
expr_stmt|;
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reverse
operator|=
literal|0
expr_stmt|;
comment|/* turn off reverse video */
block|}
empty_stmt|;
name|UP
operator|=
literal|"\b"
expr_stmt|;
if|if
condition|(
operator|!
name|strcmpn
argument_list|(
name|term
argument_list|,
literal|"h19"
argument_list|,
literal|3
argument_list|)
condition|)
name|arrows
operator|=
literal|"\033Fhh\033G"
expr_stmt|;
comment|/* "two tiny graphic arrows" */
else|else
name|arrows
operator|=
literal|"->"
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|tparm
parameter_list|(
name|cap
parameter_list|,
name|parm
parameter_list|)
name|char
modifier|*
name|cap
decl_stmt|;
name|int
name|parm
decl_stmt|;
block|{
return|return
name|tgoto
argument_list|(
name|cap
argument_list|,
literal|0
argument_list|,
name|parm
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_macro
name|loadav
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|double
name|ap
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|short
name|s_avenrun
index|[
literal|3
index|]
decl_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
name|s_avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|s_avenrun
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|s_avenrun
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|s_avenrun
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
name|ap
index|[
name|i
index|]
operator|=
name|s_avenrun
index|[
name|i
index|]
operator|/
literal|256.0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RWHO
end_ifdef

begin_function
name|char
modifier|*
name|sysrup
parameter_list|(
name|hostname
parameter_list|)
name|char
modifier|*
name|hostname
decl_stmt|;
block|{
name|char
name|filename
index|[
name|MAXFILENAME
index|]
decl_stmt|;
name|FILE
modifier|*
name|rwhofile
decl_stmt|;
name|struct
name|whod
name|wd
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|long
name|now
decl_stmt|;
comment|/* 	 *	try rwho hostname file, and if that fails try ucbhostname. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|RWHOLEADER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|filename
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|rwhofile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwhofile
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|RWHOLEADER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|filename
argument_list|,
literal|"ucb"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|filename
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|rwhofile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwhofile
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s?"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
if|if
condition|(
name|fread
argument_list|(
operator|&
name|wd
argument_list|,
sizeof|sizeof
name|wd
argument_list|,
literal|1
argument_list|,
name|rwhofile
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s ?"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|rwhofile
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|wd
operator|.
name|wd_recvtime
operator|>
name|DOWN_THRESHOLD
condition|)
block|{
name|long
name|interval
decl_stmt|;
name|long
name|days
decl_stmt|,
name|hours
decl_stmt|,
name|minutes
decl_stmt|;
name|interval
operator|=
name|now
operator|-
name|wd
operator|.
name|wd_recvtime
expr_stmt|;
name|minutes
operator|=
operator|(
name|interval
operator|+
literal|59
operator|)
operator|/
literal|60
expr_stmt|;
comment|/* round to minutes */
name|hours
operator|=
name|minutes
operator|/
literal|60
expr_stmt|;
comment|/* extract hours from minutes */
name|minutes
operator|%=
literal|60
expr_stmt|;
comment|/* remove hours from minutes */
name|days
operator|=
name|hours
operator|/
literal|24
expr_stmt|;
comment|/* extract days from hours */
name|hours
operator|%=
literal|24
expr_stmt|;
comment|/* remove days from hours */
if|if
condition|(
name|days
operator|>
literal|7
operator|||
name|days
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s down"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|days
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %d+%d:%02d"
argument_list|,
name|hostname
argument_list|,
name|days
argument_list|,
name|hours
argument_list|,
name|minutes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %d:%02d"
argument_list|,
name|hostname
argument_list|,
name|hours
argument_list|,
name|minutes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %.1f"
argument_list|,
name|hostname
argument_list|,
name|wd
operator|.
name|wd_loadav
index|[
literal|0
index|]
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rwhofile
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|rwhofile
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|RWHO
end_endif

end_unit

