begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sysline.c	5.12 (Berkeley) 6/29/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * sysline - system status display on 25th line of terminal  * j.k.foderaro  *  * Prints a variety of information on the special status line of terminals  * that have a status display capability.  Cursor motions, status commands,  * etc. are gleamed from /etc/termcap.  * By default, all information is printed, and flags are given on the command  * line to disable the printing of information.  The information and  * disabling flags are:  *  *  flag	what  *  -----	----  *		time of day  *		load average and change in load average in the last 5 mins  *		number of user logged on  *   -p		# of processes the users owns which are runnable and the  *		  number which are suspended.  Processes whose parent is 1  *		  are not counted.  *   -l		users who've logged on and off.  *   -m		summarize new mail which has arrived  *  *<other flags>  *   -r		use non reverse video  *   -c		turn off 25th line for 5 seconds before redisplaying.  *   -b		beep once one the half hour, twice on the hour  *   +N		refresh display every N seconds.  *   -i		print pid first thing  *   -e		do simple print designed for an emacs buffer line  *   -w		do the right things for a window  *   -h		print hostname between time and load average  *   -D		print day/date before time of day  *   -d		debug mode - print status line data in human readable format  *   -q		quiet mode - don't output diagnostic messages  *   -s		print Short (left-justified) line if escapes not allowed  *   -j		Print left Justified line regardless  */
end_comment

begin_define
define|#
directive|define
name|BSD4_2
end_define

begin_comment
comment|/* for 4.2 BSD */
end_comment

begin_define
define|#
directive|define
name|WHO
end_define

begin_comment
comment|/* turn this on always */
end_comment

begin_define
define|#
directive|define
name|HOSTNAME
end_define

begin_comment
comment|/* 4.1a or greater, with hostname() */
end_comment

begin_define
define|#
directive|define
name|RWHO
end_define

begin_comment
comment|/* 4.1a or greater, with rwho */
end_comment

begin_define
define|#
directive|define
name|VMUNIX
end_define

begin_comment
comment|/* turn this on if you are running on vmunix */
end_comment

begin_define
define|#
directive|define
name|NEW_BOOTTIME
end_define

begin_comment
comment|/* 4.1c or greater */
end_comment

begin_define
define|#
directive|define
name|NETPREFIX
value|"ucb"
end_define

begin_define
define|#
directive|define
name|DEFDELAY
value|60
end_define

begin_comment
comment|/* update status once per minute */
end_comment

begin_define
define|#
directive|define
name|MAILDIR
value|"/usr/spool/mail"
end_define

begin_comment
comment|/*  * if MAXLOAD is defined, then if the load average exceeded MAXLOAD  * then the process table will not be scanned and the log in/out data  * will not be checked.   The purpose of this is to reduced the load  * on the system when it is loaded.  */
end_comment

begin_define
define|#
directive|define
name|MAXLOAD
value|6.0
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_2
end_ifndef

begin_include
include|#
directive|include
file|<unctrl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VMUNIX
end_ifdef

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/vtimes.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_undef
undef|#
directive|undef
name|nl
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|TERMINFO
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
endif|TERMINFO
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RWHO
end_ifdef

begin_include
include|#
directive|include
file|<protocols/rwhod.h>
end_include

begin_define
define|#
directive|define
name|DOWN_THRESHOLD
value|(11 * 60)
end_define

begin_define
define|#
directive|define
name|RWHOLEADER
value|"/usr/spool/rwho/whod."
end_define

begin_struct
struct|struct
name|remotehost
block|{
name|char
modifier|*
name|rh_host
decl_stmt|;
name|int
name|rh_file
decl_stmt|;
block|}
name|remotehost
index|[
literal|10
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|nremotes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|RWHO
end_endif

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NEW_BOOTTIME
block|{
literal|"_boottime"
block|}
block|,
comment|/* After 4.1a the label changed to "boottime" */
else|#
directive|else
block|{
literal|"_bootime"
block|}
block|,
comment|/* Under 4.1a and earlier it is "bootime" */
endif|#
directive|endif
define|#
directive|define
name|NL_BOOT
value|0
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|NL_PROC
value|1
block|{
literal|"_avenrun"
block|}
block|,
define|#
directive|define
name|NL_AVEN
value|2
ifdef|#
directive|ifdef
name|VMUNIX
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|NL_NPROC
value|3
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stuff for the kernel */
end_comment

begin_decl_stmt
name|int
name|kmem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor for /dev/kmem */
end_comment

begin_decl_stmt
name|struct
name|proc
modifier|*
name|proc
decl_stmt|,
modifier|*
name|procNPROC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|procadr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|avenrun
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for storing load averages */
end_comment

begin_comment
comment|/*  * In order to determine how many people are logged on and who has  * logged in or out, we read in the /etc/utmp file. We also keep track of  * the previous utmp file.  */
end_comment

begin_decl_stmt
name|int
name|ut
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the file descriptor */
end_comment

begin_decl_stmt
name|struct
name|utmp
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per tty status bits, see below */
end_comment

begin_decl_stmt
name|int
name|nentries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of utmp entries */
end_comment

begin_comment
comment|/* string lengths for printing */
end_comment

begin_define
define|#
directive|define
name|LINESIZE
value|(sizeof old->ut_line)
end_define

begin_define
define|#
directive|define
name|NAMESIZE
value|(sizeof old->ut_name)
end_define

begin_comment
comment|/*  * Status codes to say what has happened to a particular entry in utmp.  * NOCH means no change, ON means new person logged on,  * OFF means person logged off.  */
end_comment

begin_define
define|#
directive|define
name|NOCH
value|0
end_define

begin_define
define|#
directive|define
name|ON
value|0x1
end_define

begin_define
define|#
directive|define
name|OFF
value|0x2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|WHO
end_ifdef

begin_decl_stmt
name|char
name|whofilename
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|whofilename2
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HOSTNAME
end_ifdef

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one more for null termination */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|lockfilename
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if exists, will prevent us from running */
end_comment

begin_comment
comment|/* flags which determine which info is printed */
end_comment

begin_decl_stmt
name|int
name|mailcheck
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* m - do biff like checking of mail */
end_comment

begin_decl_stmt
name|int
name|proccheck
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* p - give information on processes */
end_comment

begin_decl_stmt
name|int
name|logcheck
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* l - tell who logs in and out */
end_comment

begin_decl_stmt
name|int
name|hostprint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* h - print out hostname */
end_comment

begin_decl_stmt
name|int
name|dateprint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* h - print out day/date */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* q - hush diagnostic messages */
end_comment

begin_comment
comment|/* flags which determine how things are printed */
end_comment

begin_decl_stmt
name|int
name|clr_bet_ref
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* c - clear line between refeshes */
end_comment

begin_decl_stmt
name|int
name|reverse
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* r - use reverse video */
end_comment

begin_decl_stmt
name|int
name|shortline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* s - short (left-justified) if escapes not allowed */
end_comment

begin_decl_stmt
name|int
name|leftline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* j - left-justified even if escapes allowed */
end_comment

begin_comment
comment|/* flags which have terminal do random things	*/
end_comment

begin_decl_stmt
name|int
name|beep
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* b - beep every half hour and twice every hour */
end_comment

begin_decl_stmt
name|int
name|printid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i - print pid of this process at startup */
end_comment

begin_decl_stmt
name|int
name|synch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* synchronize with clock */
end_comment

begin_comment
comment|/* select output device (status display or straight output) */
end_comment

begin_decl_stmt
name|int
name|emacs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* e - assume status display */
end_comment

begin_decl_stmt
name|int
name|window
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* w - window mode */
end_comment

begin_decl_stmt
name|int
name|dbug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* d - debug */
end_comment

begin_comment
comment|/*  * used to turn off reverse video every REVOFF times  * in an attempt to not wear out the phospher.  */
end_comment

begin_define
define|#
directive|define
name|REVOFF
value|5
end_define

begin_decl_stmt
name|int
name|revtime
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used by mail checker */
end_comment

begin_decl_stmt
name|off_t
name|mailsize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|off_t
name|linebeg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place where we last left off reading */
end_comment

begin_comment
comment|/* things used by the string routines */
end_comment

begin_decl_stmt
name|int
name|chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of printable characters */
end_comment

begin_decl_stmt
name|char
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|strarr
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* big enough now? */
end_comment

begin_comment
comment|/* flags to stringdump() */
end_comment

begin_decl_stmt
name|char
name|sawmail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remember mail was seen to print bells */
end_comment

begin_decl_stmt
name|char
name|mustclear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status line messed up */
end_comment

begin_comment
comment|/* strings which control status line display */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TERMINFO
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|rev_out
decl_stmt|,
modifier|*
name|rev_end
decl_stmt|,
modifier|*
name|arrows
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|tparm
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|to_status_line
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|from_status_line
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dis_status_line
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|clr_eol
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|rev_out
index|[
literal|20
index|]
decl_stmt|,
name|rev_end
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arrows
decl_stmt|,
modifier|*
name|bell
init|=
literal|"\007"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eslok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* escapes on status line okay (reverse, cursor addressing) */
end_comment

begin_decl_stmt
name|int
name|hasws
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is "ws" explicitly defined? */
end_comment

begin_decl_stmt
name|int
name|columns
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tparm
parameter_list|(
name|cap
parameter_list|,
name|parm
parameter_list|)
value|tgoto((cap), 0, (parm))
end_define

begin_function_decl
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* to deal with window size changes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_function_decl
name|int
name|sigwinch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|winchanged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* window size has changed since last update */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* random globals */
end_comment

begin_decl_stmt
name|char
modifier|*
name|username
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ourtty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keep track of what tty we're on */
end_comment

begin_decl_stmt
name|struct
name|stat
name|stbuf
decl_stmt|,
name|mstbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mstbuf for mail check only */
end_comment

begin_decl_stmt
name|unsigned
name|delay
init|=
name|DEFDELAY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|loadavg
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current load average */
end_comment

begin_decl_stmt
name|int
name|users
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strcpy1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|sysrup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|calloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|outc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|erroutc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|clearbotl
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|home
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|HOSTNAME
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
name|hostname
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|argv
operator|++
init|;
operator|*
name|argv
operator|!=
literal|0
condition|;
name|argv
operator|++
control|)
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'-'
case|:
for|for
control|(
name|cp
operator|=
operator|*
name|argv
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* turn off reverse video */
name|reverse
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|clr_bet_ref
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hostprint
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dateprint
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RWHO
case|case
literal|'H'
case|:
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hostname
argument_list|,
operator|*
name|argv
argument_list|)
operator|&&
name|strcmp
argument_list|(
operator|&
name|hostname
index|[
sizeof|sizeof
name|NETPREFIX
operator|-
literal|1
index|]
argument_list|,
operator|*
name|argv
argument_list|)
condition|)
name|remotehost
index|[
name|nremotes
operator|++
index|]
operator|.
name|rh_host
operator|=
operator|*
name|argv
expr_stmt|;
break|break;
endif|#
directive|endif
endif|RWHO
case|case
literal|'m'
case|:
name|mailcheck
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|proccheck
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|logcheck
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|beep
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|printid
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|window
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|emacs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dbug
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|shortline
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|leftline
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: bad flag: %c\n"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'+'
case|:
name|delay
operator|=
name|atoi
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|10
condition|)
name|delay
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|delay
operator|>
literal|500
condition|)
name|delay
operator|=
literal|500
expr_stmt|;
name|synch
operator|=
literal|0
expr_stmt|;
comment|/* no more sync */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: illegal argument %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emacs
condition|)
block|{
name|reverse
operator|=
literal|0
expr_stmt|;
name|columns
operator|=
literal|79
expr_stmt|;
block|}
else|else
comment|/* if not to emacs window, initialize terminal dependent info */
name|initterm
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
comment|/* 	 * When the window size changes and we are the foreground 	 * process (true if -w), we get this signal. 	 */
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|sigwinch
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|getwinsize
argument_list|()
expr_stmt|;
comment|/* get window size from ioctl */
comment|/* immediately fork and let the parent die if not emacs mode */
if|if
condition|(
operator|!
name|emacs
operator|&&
operator|!
name|window
operator|&&
operator|!
name|dbug
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* pgrp should take care of things, but ignore them anyway */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMUNIX
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * When we logoff, init will do a "vhangup()" on this 	 * tty which turns off I/O access and sends a SIGHUP 	 * signal.  We catch this and thereby clear the status 	 * display.  Note that a bug in 4.1bsd caused the SIGHUP 	 * signal to be sent to the wrong process, so you had to 	 * `kill -HUP' yourself in your .logout file. 	 * Do the same thing for SIGTERM, which is the default kill 	 * signal. 	 */
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|clearbotl
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|clearbotl
argument_list|)
expr_stmt|;
comment|/* 	 * This is so kill -ALRM to force update won't screw us up.. 	 */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|ourtty
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* remember what tty we are on */
if|if
condition|(
name|printid
condition|)
block|{
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|dup2
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|home
operator|=
literal|""
expr_stmt|;
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|whofilename
argument_list|,
name|home
argument_list|)
argument_list|,
literal|"/.who"
argument_list|)
expr_stmt|;
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|whofilename2
argument_list|,
name|home
argument_list|)
argument_list|,
literal|"/.sysline"
argument_list|)
expr_stmt|;
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|lockfilename
argument_list|,
name|home
argument_list|)
argument_list|,
literal|"/.syslinelock"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kmem
operator|=
name|open
argument_list|(
literal|"/dev/kmem"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open kmem.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|readnamelist
argument_list|()
expr_stmt|;
if|if
condition|(
name|proccheck
condition|)
name|initprocread
argument_list|()
expr_stmt|;
if|if
condition|(
name|mailcheck
condition|)
if|if
condition|(
operator|(
name|username
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|mailcheck
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|chdir
argument_list|(
name|MAILDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|username
argument_list|,
operator|&
name|mstbuf
argument_list|)
operator|>=
literal|0
condition|)
name|mailsize
operator|=
name|mstbuf
operator|.
name|st_size
expr_stmt|;
else|else
name|mailsize
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|emacs
operator|||
name|window
operator|||
name|isloggedin
argument_list|()
condition|)
if|if
condition|(
name|access
argument_list|(
name|lockfilename
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
name|sleep
argument_list|(
literal|60
argument_list|)
expr_stmt|;
else|else
block|{
name|prtinfo
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|clr_bet_ref
condition|)
block|{
name|tputs
argument_list|(
name|dis_status_line
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|revtime
operator|=
operator|(
literal|1
operator|+
name|revtime
operator|)
operator|%
name|REVOFF
expr_stmt|;
block|}
name|clearbotl
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_macro
name|isloggedin
argument_list|()
end_macro

begin_block
block|{
comment|/* 	 * you can tell if a person has logged out if the owner of 	 * the tty has changed 	 */
name|struct
name|stat
name|statbuf
decl_stmt|;
return|return
name|fstat
argument_list|(
literal|2
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
operator|&&
name|statbuf
operator|.
name|st_uid
operator|==
name|uid
return|;
block|}
end_block

begin_macro
name|readnamelist
argument_list|()
end_macro

begin_block
block|{
name|time_t
name|bootime
decl_stmt|,
name|clock
decl_stmt|,
name|nintv
decl_stmt|,
name|time
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|pdp11
name|nlist
argument_list|(
literal|"/unix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
else|#
directive|else
name|nlist
argument_list|(
literal|"/vmunix"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nl
index|[
literal|0
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No namelist\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_BOOT
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|bootime
argument_list|,
sizeof|sizeof
argument_list|(
name|bootime
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
name|nintv
operator|=
name|clock
operator|-
name|bootime
expr_stmt|;
if|if
condition|(
name|nintv
operator|<=
literal|0L
operator|||
name|nintv
operator|>
literal|60L
operator|*
literal|60L
operator|*
literal|24L
operator|*
literal|365L
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Time makes no sense... namelist must be wrong\n"
argument_list|)
expr_stmt|;
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
operator|=
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|readutmp
argument_list|(
argument|nflag
argument_list|)
end_macro

begin_decl_stmt
name|char
name|nflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|time_t
name|lastmod
decl_stmt|;
comment|/* initially zero */
specifier|static
name|off_t
name|utmpsize
decl_stmt|;
comment|/* ditto */
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|ut
operator|<
literal|0
operator|&&
operator|(
name|ut
operator|=
name|open
argument_list|(
literal|"/etc/utmp"
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: Can't open utmp.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|ut
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
name|st
operator|.
name|st_mtime
operator|==
name|lastmod
condition|)
return|return
literal|0
return|;
name|lastmod
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|utmpsize
operator|!=
name|st
operator|.
name|st_size
condition|)
block|{
name|utmpsize
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|nentries
operator|=
name|utmpsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|old
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|calloc
argument_list|(
name|utmpsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|calloc
argument_list|(
name|utmpsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old
argument_list|,
name|utmpsize
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|utmp
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
name|utmpsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|malloc
argument_list|(
name|nentries
operator|*
sizeof|sizeof
expr|*
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
operator|||
name|new
operator|==
literal|0
operator|||
name|status
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: Out of memory.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|lseek
argument_list|(
name|ut
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|ut
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|nflag
condition|?
name|new
else|:
name|old
operator|)
argument_list|,
name|utmpsize
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * read in the process table locations and sizes, and allocate space  * for storing the process table.  This is done only once.  */
end_comment

begin_macro
name|initprocread
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|VMUNIX
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|procadr
argument_list|,
sizeof|sizeof
name|procadr
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_NPROC
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|&
name|nproc
argument_list|,
sizeof|sizeof
name|nproc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
name|procadr
operator|=
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
expr_stmt|;
name|nproc
operator|=
name|NPROC
expr_stmt|;
comment|/* from param.h */
endif|#
directive|endif
if|if
condition|(
operator|(
name|proc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|calloc
argument_list|(
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|procNPROC
operator|=
name|proc
operator|+
name|nproc
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * read in the process table.  This assumes that initprocread has alread been  * called to set up storage.  */
end_comment

begin_macro
name|readproctab
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|nl
index|[
name|NL_PROC
index|]
operator|.
name|n_value
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|procadr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
operator|(
name|char
operator|*
operator|)
name|proc
argument_list|,
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|prtinfo
argument_list|()
end_macro

begin_block
block|{
name|int
name|on
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|char
name|fullprocess
decl_stmt|;
name|stringinit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
if|if
condition|(
name|winchanged
condition|)
block|{
name|winchanged
operator|=
literal|0
expr_stmt|;
name|getwinsize
argument_list|()
expr_stmt|;
name|mustclear
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WHO
comment|/* check for file named .who in the home directory */
name|whocheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|timeprint
argument_list|()
expr_stmt|;
comment|/* 	 * if mail is seen, don't print rest of info, just the mail 	 * reverse new and old so that next time we run, we won't lose log 	 * in and out information 	 */
if|if
condition|(
name|mailcheck
operator|&&
operator|(
name|sawmail
operator|=
name|mailseen
argument_list|()
operator|)
condition|)
goto|goto
name|bottom
goto|;
ifdef|#
directive|ifdef
name|HOSTNAME
ifdef|#
directive|ifdef
name|RWHO
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nremotes
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|stringspace
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|sysrup
argument_list|(
name|remotehost
operator|+
name|i
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * print hostname info if requested 	 */
if|if
condition|(
name|hostprint
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
name|stringcat
argument_list|(
name|hostname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * print load average and difference between current load average 	 * and the load average 5 minutes ago 	 */
if|if
condition|(
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
operator|!=
literal|0
condition|)
block|{
name|double
name|diff
decl_stmt|;
name|stringspace
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VMUNIX
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
name|avenrun
argument_list|,
sizeof|sizeof
name|avenrun
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
name|loadav
argument_list|(
name|avenrun
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|diff
operator|=
name|avenrun
index|[
literal|0
index|]
operator|-
name|avenrun
index|[
literal|1
index|]
operator|)
operator|<
literal|0.0
condition|)
name|stringprt
argument_list|(
literal|"%.1f %.1f"
argument_list|,
name|avenrun
index|[
literal|0
index|]
argument_list|,
name|diff
argument_list|)
expr_stmt|;
else|else
name|stringprt
argument_list|(
literal|"%.1f +%.1f"
argument_list|,
name|avenrun
index|[
literal|0
index|]
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|loadavg
operator|=
name|avenrun
index|[
literal|0
index|]
expr_stmt|;
comment|/* remember load average */
block|}
comment|/* 	 * print log on and off information 	 */
name|stringspace
argument_list|()
expr_stmt|;
name|fullprocess
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MAXLOAD
if|if
condition|(
name|loadavg
operator|>
name|MAXLOAD
condition|)
name|fullprocess
operator|=
literal|0
expr_stmt|;
comment|/* too loaded to run */
endif|#
directive|endif
comment|/* 	 * Read utmp file (logged in data) only if we are doing a full 	 * process, or if this is the first time and we are calculating 	 * the number of users. 	 */
name|on
operator|=
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|users
operator|==
literal|0
condition|)
block|{
comment|/* first time */
if|if
condition|(
name|readutmp
argument_list|(
literal|0
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|old
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
condition|)
name|users
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullprocess
operator|&&
name|readutmp
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|struct
name|utmp
modifier|*
name|tmp
decl_stmt|;
name|users
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|old
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|,
name|new
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|,
name|NAMESIZE
argument_list|)
operator|==
literal|0
condition|)
name|status
index|[
name|i
index|]
operator|=
name|NOCH
expr_stmt|;
elseif|else
if|if
condition|(
name|old
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|ON
expr_stmt|;
name|on
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|OFF
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
else|else
block|{
name|status
index|[
name|i
index|]
operator|=
name|ON
operator||
name|OFF
expr_stmt|;
name|on
operator|++
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|new
index|[
name|i
index|]
operator|.
name|ut_name
index|[
literal|0
index|]
condition|)
name|users
operator|++
expr_stmt|;
block|}
name|tmp
operator|=
name|new
expr_stmt|;
name|new
operator|=
name|old
expr_stmt|;
name|old
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 	 * Print: 	 * 	1.  number of users 	 *	2.  a * for unread mail 	 *	3.  a - if load is too high 	 *	4.  number of processes running and stopped 	 */
name|stringprt
argument_list|(
literal|"%du"
argument_list|,
name|users
argument_list|)
expr_stmt|;
if|if
condition|(
name|mailsize
operator|>
literal|0
operator|&&
name|mstbuf
operator|.
name|st_mtime
operator|>=
name|mstbuf
operator|.
name|st_atime
condition|)
name|stringcat
argument_list|(
literal|"*"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullprocess
operator|&&
operator|(
name|proccheck
operator|||
name|logcheck
operator|)
condition|)
name|stringcat
argument_list|(
literal|"-"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullprocess
operator|&&
name|proccheck
operator|&&
name|readproctab
argument_list|()
condition|)
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|procrun
decl_stmt|,
name|procstop
decl_stmt|;
comment|/* 		 * We are only interested in processes which have the same 		 * uid as us, and whose parent process id is not 1. 		 */
name|procrun
operator|=
name|procstop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|proc
init|;
name|p
operator|<
name|procNPROC
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
literal|0
operator|||
name|p
operator|->
name|p_pgrp
operator|==
literal|0
operator|||
name|p
operator|->
name|p_uid
operator|!=
name|uid
operator|||
name|p
operator|->
name|p_ppid
operator|==
literal|1
condition|)
continue|continue;
switch|switch
condition|(
name|p
operator|->
name|p_stat
condition|)
block|{
case|case
name|SSTOP
case|:
name|procstop
operator|++
expr_stmt|;
break|break;
case|case
name|SSLEEP
case|:
comment|/* 				 * Sleep can mean waiting for a signal or just 				 * in a disk or page wait queue ready to run. 				 * We can tell if it is the later by the pri 				 * being negative. 				 */
if|if
condition|(
name|p
operator|->
name|p_pri
operator|<
name|PZERO
condition|)
name|procrun
operator|++
expr_stmt|;
break|break;
case|case
name|SWAIT
case|:
case|case
name|SRUN
case|:
case|case
name|SIDL
case|:
name|procrun
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|procrun
operator|>
literal|0
operator|||
name|procstop
operator|>
literal|0
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
if|if
condition|(
name|procrun
operator|>
literal|0
operator|&&
name|procstop
operator|>
literal|0
condition|)
name|stringprt
argument_list|(
literal|"%dr %ds"
argument_list|,
name|procrun
argument_list|,
name|procstop
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|procrun
operator|>
literal|0
condition|)
name|stringprt
argument_list|(
literal|"%dr"
argument_list|,
name|procrun
argument_list|)
expr_stmt|;
else|else
name|stringprt
argument_list|(
literal|"%ds"
argument_list|,
name|procstop
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If anyone has logged on or off, and we are interested in it, 	 * print it out. 	 */
if|if
condition|(
name|logcheck
condition|)
block|{
comment|/* old and new have already been swapped */
if|if
condition|(
name|on
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
name|stringcat
argument_list|(
literal|"on:"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|status
index|[
name|i
index|]
operator|&
name|ON
condition|)
block|{
name|stringprt
argument_list|(
literal|" %.8s"
argument_list|,
name|old
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|ttyprint
argument_list|(
name|old
index|[
name|i
index|]
operator|.
name|ut_line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
condition|)
block|{
name|stringspace
argument_list|()
expr_stmt|;
name|stringcat
argument_list|(
literal|"off:"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|status
index|[
name|i
index|]
operator|&
name|OFF
condition|)
block|{
name|stringprt
argument_list|(
literal|" %.8s"
argument_list|,
name|new
index|[
name|i
index|]
operator|.
name|ut_name
argument_list|)
expr_stmt|;
name|ttyprint
argument_list|(
name|new
index|[
name|i
index|]
operator|.
name|ut_line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bottom
label|:
comment|/* dump out what we know */
name|stringdump
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|timeprint
argument_list|()
end_macro

begin_block
block|{
name|long
name|curtime
decl_stmt|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|,
modifier|*
name|localtime
argument_list|()
decl_stmt|;
specifier|static
name|int
name|beepable
init|=
literal|1
decl_stmt|;
comment|/* always print time */
name|time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|dateprint
condition|)
name|stringprt
argument_list|(
literal|"%.11s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|curtime
argument_list|)
argument_list|)
expr_stmt|;
name|stringprt
argument_list|(
literal|"%d:%02d"
argument_list|,
name|tp
operator|->
name|tm_hour
operator|>
literal|12
condition|?
name|tp
operator|->
name|tm_hour
operator|-
literal|12
else|:
operator|(
name|tp
operator|->
name|tm_hour
operator|==
literal|0
condition|?
literal|12
else|:
name|tp
operator|->
name|tm_hour
operator|)
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|synch
condition|)
comment|/* sync with clock */
name|delay
operator|=
literal|60
operator|-
name|tp
operator|->
name|tm_sec
expr_stmt|;
comment|/* 	 * Beepable is used to insure that we get at most one set of beeps 	 * every half hour. 	 */
if|if
condition|(
name|beep
condition|)
if|if
condition|(
name|beepable
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|tm_min
operator|==
literal|30
condition|)
block|{
name|tputs
argument_list|(
name|bell
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|beepable
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|tm_min
operator|==
literal|0
condition|)
block|{
name|tputs
argument_list|(
name|bell
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|bell
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|beepable
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|tm_min
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|tm_min
operator|!=
literal|30
condition|)
name|beepable
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * whocheck -- check for file named .who and print it on the who line first  */
end_comment

begin_macro
name|whocheck
argument_list|()
end_macro

begin_block
block|{
name|int
name|chss
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
literal|81
index|]
decl_stmt|;
name|int
name|whofile
decl_stmt|;
if|if
condition|(
operator|(
name|whofile
operator|=
name|open
argument_list|(
name|whofilename
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|whofile
operator|=
name|open
argument_list|(
name|whofilename2
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
name|chss
operator|=
name|read
argument_list|(
name|whofile
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
name|buff
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|whofile
argument_list|)
expr_stmt|;
if|if
condition|(
name|chss
operator|<=
literal|0
condition|)
return|return;
name|buff
index|[
name|chss
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Remove all line feeds, and replace by spaces if they are within 	 * the message, else replace them by nulls. 	 */
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
if|if
condition|(
name|p
index|[
literal|1
index|]
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
else|else
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|stringcat
argument_list|(
name|buff
argument_list|,
name|p
operator|-
name|buff
argument_list|)
expr_stmt|;
name|stringspace
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * ttyprint -- given the name of a tty, print in the string buffer its  * short name surrounded by parenthesis.  * ttyxx is printed as (xx)  * console is printed as (cty)  */
end_comment

begin_macro
name|ttyprint
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|11
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|stringprt
argument_list|(
literal|"(%.*s)"
argument_list|,
name|LINESIZE
operator|-
literal|3
argument_list|,
name|name
operator|+
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"console"
argument_list|)
operator|==
literal|0
condition|)
name|stringcat
argument_list|(
literal|"(cty)"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|stringprt
argument_list|(
literal|"(%.*s)"
argument_list|,
name|LINESIZE
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * mail checking function  * returns 0 if no mail seen  */
end_comment

begin_macro
name|mailseen
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|mfd
decl_stmt|;
specifier|register
name|n
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|lbuf
index|[
literal|100
index|]
decl_stmt|,
name|sendbuf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|bufend
decl_stmt|;
name|char
name|seenspace
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|username
argument_list|,
operator|&
name|mstbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mailsize
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mstbuf
operator|.
name|st_size
operator|<=
name|mailsize
operator|||
operator|(
name|mfd
operator|=
name|fopen
argument_list|(
name|username
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mailsize
operator|=
name|mstbuf
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fseek
argument_list|(
name|mfd
argument_list|,
name|mailsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|readline
argument_list|(
name|mfd
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|strncmp
argument_list|(
name|lbuf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|stringcat
argument_list|(
literal|"Mail has just arrived"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Found a From line, get second word, which is the sender, 	 * and print it. 	 */
for|for
control|(
name|cp
operator|=
name|lbuf
operator|+
literal|5
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|;
name|cp
operator|++
control|)
comment|/* skip to blank */
empty_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate name */
name|stringspace
argument_list|()
expr_stmt|;
name|stringprt
argument_list|(
literal|"Mail from %s "
argument_list|,
name|lbuf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* 	 * Print subject, and skip over header. 	 */
while|while
condition|(
operator|(
name|n
operator|=
name|readline
argument_list|(
name|mfd
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|lbuf
argument_list|,
literal|"Subject:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|stringprt
argument_list|(
literal|"on %s "
argument_list|,
name|lbuf
operator|+
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emacs
condition|)
name|stringcat
argument_list|(
name|arrows
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
name|stringcat
argument_list|(
literal|": "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* already at eof */
goto|goto
name|out
goto|;
comment|/* 	 * Print as much of the letter as we can. 	 */
name|cp
operator|=
name|sendbuf
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|columns
operator|-
name|chars
operator|)
operator|>
sizeof|sizeof
name|sendbuf
operator|-
literal|1
condition|)
name|n
operator|=
sizeof|sizeof
name|sendbuf
operator|-
literal|1
expr_stmt|;
name|bufend
operator|=
name|cp
operator|+
name|n
expr_stmt|;
name|seenspace
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|readline
argument_list|(
name|mfd
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|lbuf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cp
operator|>=
name|bufend
condition|)
continue|continue;
if|if
condition|(
operator|!
name|seenspace
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* space before lines */
name|seenspace
operator|=
literal|1
expr_stmt|;
block|}
name|rp
operator|=
name|lbuf
expr_stmt|;
while|while
condition|(
operator|*
name|rp
operator|&&
name|cp
operator|<
name|bufend
condition|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|rp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seenspace
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|seenspace
operator|=
literal|1
expr_stmt|;
block|}
name|rp
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|seenspace
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|stringcat
argument_list|(
name|sendbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Want to update write time so a star will 	 * appear after the number of users until the 	 * user reads his mail. 	 */
name|out
label|:
name|mailsize
operator|=
name|linebeg
expr_stmt|;
name|fclose
argument_list|(
name|mfd
argument_list|)
expr_stmt|;
name|touch
argument_list|(
name|username
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_comment
comment|/*  * readline -- read a line from fp and store it in buf.  * return the number of characters read.  */
end_comment

begin_expr_stmt
name|readline
argument_list|(
name|fp
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|linebeg
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* remember loc where line begins */
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|cp
operator|-
name|buf
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|cp
operator|-
name|buf
return|;
block|}
end_block

begin_comment
comment|/*  * string hacking functions  */
end_comment

begin_macro
name|stringinit
argument_list|()
end_macro

begin_block
block|{
name|sp
operator|=
name|strarr
expr_stmt|;
name|chars
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*VARARGS1*/
end_comment

begin_macro
name|stringprt
argument_list|(
argument|format
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tempbuf
index|[
literal|150
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
name|format
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|tempbuf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stringdump
argument_list|()
end_macro

begin_block
block|{
name|char
name|bigbuf
index|[
sizeof|sizeof
name|strarr
operator|+
literal|200
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
init|=
name|bigbuf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|emacs
condition|)
block|{
if|if
condition|(
name|sawmail
condition|)
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|bell
argument_list|)
expr_stmt|;
if|if
condition|(
name|eslok
condition|)
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|tparm
argument_list|(
name|to_status_line
argument_list|,
name|leftline
condition|?
literal|0
else|:
name|columns
operator|-
name|chars
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|to_status_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shortline
operator|&&
operator|!
name|leftline
condition|)
for|for
control|(
name|i
operator|=
name|columns
operator|-
name|chars
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|&&
name|revtime
operator|!=
literal|0
condition|)
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|rev_out
argument_list|)
expr_stmt|;
block|}
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|strarr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|emacs
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|rev_end
argument_list|)
expr_stmt|;
name|bp
operator|=
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|from_status_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sawmail
condition|)
name|bp
operator|=
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|bp
argument_list|,
name|bell
argument_list|)
argument_list|,
name|bell
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|tputs
argument_list|(
name|bigbuf
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mustclear
condition|)
block|{
name|mustclear
operator|=
literal|0
expr_stmt|;
name|tputs
argument_list|(
name|clr_eol
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbug
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
name|bigbuf
argument_list|,
name|bp
operator|-
name|bigbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|stringspace
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|reverse
operator|&&
name|revtime
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMINFO
name|stringcat
argument_list|(
name|rev_end
argument_list|,
name|magic_cookie_glitch
operator|<=
literal|0
condition|?
literal|0
else|:
name|magic_cookie_glitch
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|rev_out
argument_list|,
name|magic_cookie_glitch
operator|<=
literal|0
condition|?
literal|0
else|:
name|magic_cookie_glitch
argument_list|)
expr_stmt|;
else|#
directive|else
name|stringcat
argument_list|(
name|rev_end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stringcat
argument_list|(
name|rev_out
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|TERMINFO
block|}
else|else
name|stringcat
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * stringcat :: concatenate the characters in string str to the list we are  * 	        building to send out.  * str - the string to print. may contain funny (terminal control) chars.  * n  - the number of printable characters in the string  *	or if -1 then str is all printable so we can truncate it,  *	otherwise don't print only half a string.  */
end_comment

begin_expr_stmt
name|stringcat
argument_list|(
name|str
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|sp
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* truncate */
name|n
operator|=
name|columns
operator|-
name|chars
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|str
operator|++
operator|)
operator|&&
operator|--
name|n
operator|>=
literal|0
condition|)
empty_stmt|;
name|p
operator|--
expr_stmt|;
name|chars
operator|+=
name|p
operator|-
name|sp
expr_stmt|;
name|sp
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chars
operator|+
name|n
operator|<=
name|columns
condition|)
block|{
comment|/* don't truncate */
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|str
operator|++
condition|)
empty_stmt|;
name|chars
operator|+=
name|n
expr_stmt|;
name|sp
operator|=
name|p
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * touch :: update the modify time of a file.  */
end_comment

begin_macro
name|touch
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file */
end_comment

begin_block
block|{
specifier|register
name|fd
expr_stmt|;
name|char
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get first byte */
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* go to beginning */
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* and rewrite first byte */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * clearbotl :: clear bottom line.  * called when process quits or is killed.  * it clears the bottom line of the terminal.  */
end_comment

begin_macro
name|clearbotl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
name|int
name|exit
parameter_list|()
function_decl|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|exit
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* if can't open in 30 secs, just die */
if|if
condition|(
operator|!
name|emacs
operator|&&
operator|(
name|fd
operator|=
name|open
argument_list|(
name|ourtty
argument_list|,
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|dis_status_line
argument_list|,
name|strlen
argument_list|(
name|dis_status_line
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROF
if|if
condition|(
name|chdir
argument_list|(
literal|"/usr/src/ucb/sysline"
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TERMINFO
end_ifdef

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|standbuf
index|[
literal|40
index|]
decl_stmt|;
name|setupterm
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|window
operator|&&
operator|!
name|has_status_line
condition|)
block|{
comment|/* not an appropriate terminal */
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: no status capability for %s\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|window
operator|||
name|status_line_esc_ok
condition|)
block|{
if|if
condition|(
name|set_attributes
condition|)
block|{
comment|/* reverse video mode */
name|strcpy
argument_list|(
name|standbuf
argument_list|,
name|tparm
argument_list|(
name|set_attributes
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|rev_out
operator|=
name|standbuf
expr_stmt|;
name|rev_end
operator|=
name|exit_attribute_mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enter_standout_mode
operator|&&
name|exit_standout_mode
condition|)
block|{
name|rev_out
operator|=
name|enter_standout_mode
expr_stmt|;
name|rev_end
operator|=
name|exit_standout_mode
expr_stmt|;
block|}
else|else
name|rev_out
operator|=
name|rev_end
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|rev_out
operator|=
name|rev_end
operator|=
literal|""
expr_stmt|;
name|columns
operator|--
expr_stmt|;
comment|/* avoid cursor wraparound */
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* TERMCAP */
end_comment

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|term
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|tbuf
index|[
literal|1024
index|]
decl_stmt|;
name|char
name|is2
index|[
literal|40
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|UP
decl_stmt|;
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: No TERM variable in enviroment\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tgetent
argument_list|(
name|tbuf
argument_list|,
name|term
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: Unknown terminal type: %s\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|window
operator|&&
name|tgetflag
argument_list|(
literal|"hs"
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|term
argument_list|,
literal|"h19"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
comment|/* for upward compatability with h19sys */
name|strcpy
argument_list|(
name|to_status_line
argument_list|,
literal|"\033j\033x5\033x1\033Y8%+ \033o"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|from_status_line
argument_list|,
literal|"\033k\033y5"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dis_status_line
argument_list|,
literal|"\033y1"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rev_out
argument_list|,
literal|"\033p"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rev_end
argument_list|,
literal|"\033q"
argument_list|)
expr_stmt|;
name|arrows
operator|=
literal|"\033Fhh\033G"
expr_stmt|;
name|columns
operator|=
literal|80
expr_stmt|;
name|UP
operator|=
literal|"\b"
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sysline: No status capability for %s\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|is2
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"i2"
argument_list|,
operator|&
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* someday tset will do this */
name|tputs
argument_list|(
name|is2
argument_list|,
literal|1
argument_list|,
name|erroutc
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* the "-1" below is to avoid cursor wraparound problems */
name|columns
operator|=
name|tgetnum
argument_list|(
literal|"ws"
argument_list|)
expr_stmt|;
name|hasws
operator|=
name|columns
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hasws
condition|)
name|columns
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
name|columns
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
name|strcpy
argument_list|(
name|to_status_line
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dis_status_line
expr_stmt|;
comment|/* use the clear line sequence */
operator|*
name|cp
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|leftline
condition|)
name|strcpy
argument_list|(
name|from_status_line
argument_list|,
name|dis_status_line
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|from_status_line
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|to_status_line
expr_stmt|;
name|tgetstr
argument_list|(
literal|"ts"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|from_status_line
expr_stmt|;
name|tgetstr
argument_list|(
literal|"fs"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dis_status_line
expr_stmt|;
name|tgetstr
argument_list|(
literal|"ds"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|eslok
operator|=
name|tgetflag
argument_list|(
literal|"es"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eslok
operator|||
name|window
condition|)
block|{
name|cp
operator|=
name|rev_out
expr_stmt|;
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rev_end
expr_stmt|;
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|clr_eol
expr_stmt|;
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|reverse
operator|=
literal|0
expr_stmt|;
comment|/* turn off reverse video */
name|UP
operator|=
literal|"\b"
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|term
argument_list|,
literal|"h19"
argument_list|,
literal|3
argument_list|)
condition|)
name|arrows
operator|=
literal|"\033Fhh\033G"
expr_stmt|;
comment|/* "two tiny graphic arrows" */
else|else
name|arrows
operator|=
literal|"->"
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|TERMINFO
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|pdp11
end_ifdef

begin_macro
name|loadav
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|double
name|ap
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|short
name|s_avenrun
index|[
literal|3
index|]
decl_stmt|;
name|lseek
argument_list|(
name|kmem
argument_list|,
operator|(
name|long
operator|)
name|nl
index|[
name|NL_AVEN
index|]
operator|.
name|n_value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|kmem
argument_list|,
name|s_avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|s_avenrun
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|s_avenrun
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|s_avenrun
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
name|ap
index|[
name|i
index|]
operator|=
name|s_avenrun
index|[
name|i
index|]
operator|/
literal|256.0
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RWHO
end_ifdef

begin_function
name|char
modifier|*
name|sysrup
parameter_list|(
name|hp
parameter_list|)
specifier|register
name|struct
name|remotehost
modifier|*
name|hp
decl_stmt|;
block|{
name|char
name|filename
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|whod
name|wd
decl_stmt|;
define|#
directive|define
name|WHOD_HDR_SIZE
value|(sizeof (wd) - sizeof (wd.wd_we))
specifier|static
name|char
name|buffer
index|[
literal|50
index|]
decl_stmt|;
name|time_t
name|now
decl_stmt|;
comment|/* 	 * rh_file is initially 0. 	 * This is ok since standard input is assumed to exist. 	 */
if|if
condition|(
name|hp
operator|->
name|rh_file
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Try rwho hostname file, and if that fails try ucbhostname. 		 */
operator|(
name|void
operator|)
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|filename
argument_list|,
name|RWHOLEADER
argument_list|)
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|rh_file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|strcpy1
argument_list|(
name|filename
argument_list|,
name|RWHOLEADER
argument_list|)
argument_list|,
name|NETPREFIX
argument_list|)
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rh_file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp
operator|->
name|rh_file
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s?"
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|hp
operator|->
name|rh_file
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|hp
operator|->
name|rh_file
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wd
argument_list|,
name|WHOD_HDR_SIZE
argument_list|)
operator|!=
name|WHOD_HDR_SIZE
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s ?"
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|wd
operator|.
name|wd_recvtime
operator|>
name|DOWN_THRESHOLD
condition|)
block|{
name|long
name|interval
decl_stmt|;
name|long
name|days
decl_stmt|,
name|hours
decl_stmt|,
name|minutes
decl_stmt|;
name|interval
operator|=
name|now
operator|-
name|wd
operator|.
name|wd_recvtime
expr_stmt|;
name|minutes
operator|=
operator|(
name|interval
operator|+
literal|59
operator|)
operator|/
literal|60
expr_stmt|;
comment|/* round to minutes */
name|hours
operator|=
name|minutes
operator|/
literal|60
expr_stmt|;
comment|/* extract hours from minutes */
name|minutes
operator|%=
literal|60
expr_stmt|;
comment|/* remove hours from minutes */
name|days
operator|=
name|hours
operator|/
literal|24
expr_stmt|;
comment|/* extract days from hours */
name|hours
operator|%=
literal|24
expr_stmt|;
comment|/* remove days from hours */
if|if
condition|(
name|days
operator|>
literal|7
operator|||
name|days
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s down"
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|days
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %d+%d:%02d"
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|,
name|days
argument_list|,
name|hours
argument_list|,
name|minutes
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %d:%02d"
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|,
name|hours
argument_list|,
name|minutes
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %.1f"
argument_list|,
name|hp
operator|->
name|rh_host
argument_list|,
name|wd
operator|.
name|wd_loadav
index|[
literal|0
index|]
operator|/
literal|100.0
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|RWHO
end_endif

begin_macro
name|getwinsize
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|winsize
decl_stmt|;
comment|/* the "-1" below is to avoid cursor wraparound problems */
if|if
condition|(
operator|!
name|hasws
operator|&&
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|winsize
argument_list|)
operator|>=
literal|0
operator|&&
name|winsize
operator|.
name|ws_col
operator|!=
literal|0
condition|)
name|columns
operator|=
name|winsize
operator|.
name|ws_col
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SIGWINCH
end_ifdef

begin_macro
name|sigwinch
argument_list|()
end_macro

begin_block
block|{
name|winchanged
operator|++
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|strcpy1
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
condition|)
empty_stmt|;
return|return
name|p
operator|-
literal|1
return|;
block|}
end_block

begin_macro
name|outc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dbug
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|erroutc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dbug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

