begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1986, 1988, 1990 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_resp.c	4.65 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ns.h"
end_include

begin_include
include|#
directive|include
file|"db.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|ddt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_char
modifier|*
name|dnptrs
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|time_t
name|retrytime
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|fwdinfo
modifier|*
name|fwdtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sockaddr_in
name|from_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Source addr of last packet */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|needs_prime_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|priming
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|ns_resp
argument_list|(
argument|msg
argument_list|,
argument|msglen
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ns2
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|,
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dbflags
decl_stmt|;
name|int
name|cname
init|=
literal|0
decl_stmt|;
comment|/* flag for processing cname response */
name|int
name|count
decl_stmt|,
name|founddata
decl_stmt|,
name|foundname
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|newmsglen
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|u_char
name|newmsg
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|time_t
name|rtrip
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
specifier|extern
name|struct
name|netinfo
modifier|*
name|local
parameter_list|()
function_decl|;
specifier|extern
name|int
name|nsid
decl_stmt|;
specifier|extern
name|int
name|addcount
decl_stmt|;
name|struct
name|fwdinfo
modifier|*
name|fwd
decl_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_RESPONSES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|qfindid
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"DUP? dropped (id %d)\n"
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_DUPRESP
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"%s response nsid=%d id=%d\n"
argument_list|,
name|qp
operator|->
name|q_system
condition|?
literal|"SYSTEM"
else|:
literal|"USER"
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Here we handle bad responses from servers. 	 *  Several possibilities come to mind: 	 *	The server is sick and returns SERVFAIL 	 *	The server returns some garbage opcode (its sick) 	 *	The server can't understand our query and return FORMERR 	 *  In all these cases, we simply drop the packet and force 	 *  a retry.  This will make him look bad due to unresponsiveness. 	 *  Be sure not to include authoritative NXDOMAIN 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|&&
name|hp
operator|->
name|rcode
operator|!=
name|NXDOMAIN
operator|)
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|&&
operator|!
name|hp
operator|->
name|aa
operator|)
operator|||
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: error (ret %d, op %d), dropped\n"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hp
operator|->
name|opcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_BADRESPONSES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|&&
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEA
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEM
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEMA
operator|)
condition|)
block|{
comment|/* 		 * Update the secondary's copy, now that the primary 		 * successfully completed the update.  Zone doesn't matter 		 * for dyn. update -- doupdate calls findzone to find it 		 */
name|doupdate
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|databuf
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving, UPDATE*\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return code filled in by doupdate */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
endif|ALLOW_UPDATES
comment|/* 	 * Determine if the response came from a forwarder.  Packets from 	 * anyplace not listed as a forwarder or as a server to whom we 	 * might have forwarded the query will be dropped. 	 */
for|for
control|(
name|fwd
operator|=
name|fwdtab
init|;
name|fwd
operator|!=
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|;
name|fwd
operator|=
name|fwd
operator|->
name|next
control|)
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fwd
operator|->
name|fwdaddr
operator|.
name|sin_addr
argument_list|,
operator|&
name|from_addr
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* 	 * If we were using nameservers, find the qinfo pointer and update 	 * the rtt and fact that we have called on this server before. 	 */
if|if
condition|(
name|fwd
operator|==
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|timeval
modifier|*
name|stp
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
operator|&
name|from_addr
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|>=
name|qp
operator|->
name|q_naddr
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Response from unexpected source %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_MARTIANS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*  			 * We don't know who this response came from so it 			 * gets dropped on the floor. 			 */
return|return;
block|}
name|stp
operator|=
operator|&
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* Handle response from different (untried) interface */
if|if
condition|(
name|stp
operator|->
name|tv_sec
operator|==
literal|0
condition|)
block|{
name|ns
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
while|while
condition|(
name|qs
operator|>
name|qp
operator|->
name|q_addr
operator|&&
operator|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
operator|==
literal|0
operator|||
name|qs
operator|->
name|ns
operator|!=
name|ns
operator|)
condition|)
name|qs
operator|--
expr_stmt|;
operator|*
name|stp
operator|=
name|qs
operator|->
name|stime
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Response from unused address %s, assuming %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
comment|/* compute query round trip time */
name|rtrip
operator|=
operator|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tt
operator|.
name|tv_usec
operator|-
name|stp
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"stime %d/%d  now %d/%d rtt %d\n"
argument_list|,
name|stp
operator|->
name|tv_sec
argument_list|,
name|stp
operator|->
name|tv_usec
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|,
name|tt
operator|.
name|tv_usec
argument_list|,
name|rtrip
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* prevent floating point overflow, limit to 1000 sec */
if|if
condition|(
name|rtrip
operator|>
literal|1000000
condition|)
name|rtrip
operator|=
literal|1000000
expr_stmt|;
name|ns
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
comment|/* 		 * Don't update nstime if this doesn't look 		 * like an address databuf now.			XXX 		 */
if|if
condition|(
name|ns
operator|->
name|d_type
operator|==
name|T_A
operator|&&
name|ns
operator|->
name|d_class
operator|==
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
block|{
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|ns
operator|->
name|d_nstime
operator|=
operator|(
name|u_long
operator|)
name|rtrip
expr_stmt|;
else|else
name|ns
operator|->
name|d_nstime
operator|=
name|ns
operator|->
name|d_nstime
operator|*
name|ALPHA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
operator|(
name|u_long
operator|)
name|rtrip
expr_stmt|;
comment|/* prevent floating point overflow, limit to 1000 sec */
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|>
literal|1000000
condition|)
name|ns
operator|->
name|d_nstime
operator|=
literal|1000000
expr_stmt|;
block|}
comment|/* 		 * Record the source so that we do not use this NS again. 		 */
if|if
condition|(
name|qp
operator|->
name|q_nusedns
operator|<
name|NSMAX
condition|)
block|{
name|qp
operator|->
name|q_usedns
index|[
name|qp
operator|->
name|q_nusedns
operator|++
index|]
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"NS #%d addr %s used, rtt %d\n"
argument_list|,
name|n
argument_list|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ns
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
comment|/* 		 * Penalize those who had earlier chances but failed 		 * by multiplying round-trip times by BETA (>1). 		 * Improve nstime for unused addresses by applying GAMMA. 		 * The GAMMA factor makes unused entries slowly 		 * improve, so they eventually get tried again. 		 * GAMMA should be slightly less than 1. 		 * Watch out for records that may have timed out 		 * and are no longer the correct type.			XXX 		 */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|ns2
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
if|if
condition|(
name|ns2
operator|==
name|ns
condition|)
continue|continue;
if|if
condition|(
name|ns2
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|ns2
operator|->
name|d_class
operator|!=
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
comment|/* XXX */
continue|continue;
if|if
condition|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|ns2
operator|->
name|d_nstime
operator|=
name|rtrip
operator|*
name|BETA
expr_stmt|;
else|else
name|ns2
operator|->
name|d_nstime
operator|=
name|ns2
operator|->
name|d_nstime
operator|*
name|BETA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
expr_stmt|;
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|>
literal|1000000
condition|)
name|ns2
operator|->
name|d_nstime
operator|=
literal|1000000
expr_stmt|;
block|}
else|else
name|ns2
operator|->
name|d_nstime
operator|=
name|ns2
operator|->
name|d_nstime
operator|*
name|GAMMA
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"NS #%d %s rtt now %d\n"
argument_list|,
name|n
argument_list|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ns2
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
block|}
comment|/* 	 * Skip query section 	 */
name|addcount
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|qdcount
condition|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
goto|goto
name|formerr
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|-
name|msg
operator|>
name|msglen
condition|)
goto|goto
name|formerr
goto|;
block|}
comment|/* 	 * Save answers, authority, and additional records for future use. 	 */
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|nscount
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|cp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: ancount %d, aucount %d, arcount %d\n"
argument_list|,
name|ancount
argument_list|,
name|aucount
argument_list|,
name|arcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  If there's an answer, check if it's a CNAME response; 	 *  if no answer but aucount> 0, see if there is an NS 	 *  or just an SOA.  (NOTE: ancount might be 1 with a CNAME, 	 *  and NS records may still be in the authority section; 	 *  we don't bother counting them, as we only use nscount 	 *  if ancount == 0.) 	 */
if|if
condition|(
name|ancount
operator|==
literal|1
operator|||
operator|(
name|ancount
operator|==
literal|0
operator|&&
name|aucount
operator|>
literal|0
operator|)
condition|)
block|{
name|c
operator|=
name|aucount
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tp
operator|-
name|msg
operator|>=
name|msglen
condition|)
goto|goto
name|formerr
goto|;
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
goto|goto
name|formerr
goto|;
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|GETSHORT
argument_list|(
name|i
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* type */
name|tp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* class */
name|tp
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|count
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
if|if
condition|(
name|tp
operator|-
name|msg
operator|>
name|msglen
operator|-
name|count
condition|)
goto|goto
name|formerr
goto|;
name|tp
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|ancount
operator|&&
name|i
operator|==
name|T_CNAME
condition|)
block|{
name|cname
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"CNAME - needs more processing\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 			 * See if authority record is a nameserver. 			 */
if|if
condition|(
name|ancount
operator|==
literal|0
operator|&&
name|i
operator|==
name|T_NS
condition|)
name|nscount
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
do|;
name|tp
operator|=
name|cp
expr_stmt|;
block|}
comment|/* 	 * Add the info received in the response to the Data Base 	 */
name|c
operator|=
name|ancount
operator|+
name|aucount
operator|+
name|arcount
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If the request was for a CNAME that doesn't exist, 	 * but the name is valid, fetch any other data for the name. 	 * DON'T do this now, as it will requery if data are already 	 * in the cache (maybe later with negative caching). 	 */
if|if
condition|(
name|hp
operator|->
name|qdcount
operator|&&
name|type
operator|==
name|T_CNAME
operator|&&
name|c
operator|==
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
name|qp
operator|->
name|q_system
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving, no CNAME\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Cause us to put it in the cache later */
name|prime
argument_list|(
name|class
argument_list|,
name|T_ANY
argument_list|,
name|qp
argument_list|)
expr_stmt|;
comment|/* Nothing to store, just give user the answer */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
comment|/* notdef */
name|nspp
operator|=
name|nsp
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_system
condition|)
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
expr_stmt|;
else|else
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|databuf
modifier|*
name|ns3
decl_stmt|;
if|if
condition|(
name|cp
operator|>=
name|msg
operator|+
name|msglen
condition|)
goto|goto
name|formerr
goto|;
name|ns3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|doupdate
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
operator|&
name|ns3
argument_list|,
name|dbflags
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving, doupdate failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return code filled in by doupdate */
goto|goto
name|return_msg
goto|;
block|}
comment|/* 		 * Remember nameservers from the authority section 		 * for referrals. 		 * (This is usually overwritten by findns below(?). XXX 		 */
if|if
condition|(
name|ns3
operator|&&
name|i
operator|>=
name|ancount
operator|&&
name|i
operator|<
name|ancount
operator|+
name|aucount
operator|&&
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
operator|*
name|nspp
operator|++
operator|=
name|ns3
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_system
operator|&&
name|ancount
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_system
operator|==
name|PRIMING_CACHE
condition|)
name|check_root
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving, SYSQUERY ancount %d\n"
argument_list|,
name|ancount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|>
name|msg
operator|+
name|msglen
condition|)
goto|goto
name|formerr
goto|;
comment|/* 	 *  If there are addresses and this is a local query, 	 *  sort them appropriately for the local context. 	 */
if|if
condition|(
name|ancount
operator|>
literal|1
operator|&&
operator|(
name|lp
operator|=
name|local
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
name|tp
argument_list|,
name|ancount
argument_list|,
name|lp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
comment|/* 	 * An answer to a T_ANY query or a successful answer to a 	 * regular query with no indirection, then just return answer. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|qdcount
operator|&&
name|type
operator|==
name|T_ANY
operator|&&
name|ancount
operator|)
operator|||
operator|(
operator|!
name|cname
operator|&&
operator|!
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: got as much answer as there is\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * Eventually we will want to cache this negative answer. 	 */
if|if
condition|(
name|ancount
operator|==
literal|0
operator|&&
name|nscount
operator|==
literal|0
operator|&&
operator|(
name|hp
operator|->
name|aa
operator|||
name|fwd
operator|||
name|class
operator|==
name|C_ANY
operator|)
condition|)
block|{
comment|/* We have an authoritative NO */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving auth NO\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|qp
operator|->
name|q_cmsg
expr_stmt|;
name|msglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
block|}
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * All messages in here need further processing.  i.e. they 	 * are either CNAMEs or we got referred again. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|cname
operator|&&
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Cname second pass\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newmsglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|bcopy
argument_list|(
name|qp
operator|->
name|q_cmsg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newmsglen
operator|=
name|msglen
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|dnptrs
index|[
literal|0
index|]
operator|=
name|newmsg
expr_stmt|;
name|dnptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|newmsg
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"dn_expand failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
operator|!
name|cname
condition|)
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|newmsg
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|newmsg
operator|)
expr_stmt|;
name|try_again
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: nlookup(%s) type=%d\n"
argument_list|,
name|dname
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fname
operator|=
literal|""
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: %s '%s' as '%s' (cname=%d)\n"
argument_list|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetch_ns
goto|;
name|foundname
operator|++
expr_stmt|;
name|count
operator|=
name|cp
operator|-
name|newmsg
expr_stmt|;
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|fetch_ns
goto|;
comment|/* NO data available */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
name|cname
operator|++
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: foundname = %d count = %d "
argument_list|,
name|foundname
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"founddata = %d cname = %d\n"
argument_list|,
name|founddata
argument_list|,
name|cname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fetch_ns
label|:
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* shouldn't happen */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"req: leaving (%s, rcode %d)\n"
argument_list|,
name|dname
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* 			 * should return SOA if founddata == 0, 			 * but old named's are confused by an SOA 			 * in the auth. section if there's no error. 			 */
if|if
condition|(
name|foundname
operator|==
literal|0
operator|&&
name|np
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
block|}
goto|goto
name|return_newmsg
goto|;
case|case
name|SERVFAIL
case|:
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|founddata
condition|)
block|{
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|count
argument_list|)
expr_stmt|;
goto|goto
name|return_newmsg
goto|;
block|}
comment|/* 	 *  If we get here, we don't have the answer yet and are about 	 *  to iterate to try and get it.  First, infinite loop avoidance. 	 */
if|if
condition|(
name|qp
operator|->
name|q_nqueries
operator|++
operator|>
name|MAXQUERIES
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: MAXQUERIES exceeded (%s, class %d, type %d)\n"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"MAXQUERIES exceeded, possible data loop in resolving (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
comment|/* Reset the query control structure */
name|qp
operator|->
name|q_naddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
if|if
condition|(
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: no addrs found for NS's\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|servfail
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_cname
operator|++
operator|==
name|MAXCNAMES
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|servfail
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_cname = %d\n"
argument_list|,
name|qp
operator|->
name|q_cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: building recursive query; nslookup\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qp
operator|->
name|q_msg
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: malloc error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|servfail
goto|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
operator|++
name|nsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: forw -> %s %d (%d) nsid=%d id=%d %dms\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ds
argument_list|,
name|ntohs
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|,
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sendto error = %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* leave set to 0 for dup detection */
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: Query sent.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|formerr
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR resp() from %s size err %d, msglen %d\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Malformed response from %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_RESPFORMERR
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
return|return;
name|return_msg
label|:
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_RESPOK
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* The "standard" return code */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
name|return_newmsg
label|:
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_RESPOK
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|addcount
condition|)
block|{
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|newmsg
argument_list|,
name|cp
operator|-
name|newmsg
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
name|servfail
label|:
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_RESPFAIL
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|cname
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
argument_list|,
operator|(
name|cname
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Decode the resource record 'rrp' and update the database.  * If savens is true, record pointer for forwarding queries a second time.  */
end_comment

begin_macro
name|doupdate
argument_list|(
argument|msg
argument_list|,
argument|msglen
argument_list|,
argument|rrp
argument_list|,
argument|zone
argument_list|,
argument|savens
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|rrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|databuf
modifier|*
modifier|*
name|savens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|,
name|zone
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|;
name|u_long
name|ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|u_char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
name|int
name|zonenum
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doupdate(zone %d, savens %x, flags %x)\n"
argument_list|,
name|zone
argument_list|,
name|savens
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|rrp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"doupdate: dname %s type %d class %d ttl %d\n"
argument_list|,
name|dname
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Convert the resource record data into the internal 	 * database format. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
endif|ALLOW_T_UNSPEC
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|cp1
argument_list|,
name|n1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* get name */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|cp1
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"unknown type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update type %d: %d bytes is too much data\n"
argument_list|,
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
comment|/* XXX - FORMERR ??? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
comment|/* 	 * If this is a dynamic update request, process it specially; else, 	 * execute normal update code. 	 */
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
comment|/* For UPDATEM and UPDATEMA, do UPDATED/UPDATEDA followed by UPDATEA */
case|case
name|UPDATEM
case|:
case|case
name|UPDATEMA
case|:
comment|/* 	 * The named code for UPDATED and UPDATEDA is the same except that for 	 * UPDATEDA we we ignore any data that was passed: we just delete all 	 * RRs whose name, type, and class matches 	 */
case|case
name|UPDATED
case|:
case|case
name|UPDATEDA
case|:
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
comment|/* Not allowed */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"UDPATE: REFUSED - SOA delete\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't check message length if doing UPDATEM/UPDATEMA, 		 * since the whole message wont have been demarshalled until 		 * we reach the code for UPDATEA 		 */
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|msglen
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR UPDATE message length off\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_state
operator|&
name|Z_DYNADDONLY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEM
operator|)
condition|)
block|{
comment|/* Make a dp for use in db_update, as old dp */
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_MEXIST
operator||
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"UPDATE: db_update failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|free
argument_list|(
operator|(
expr|struct
name|databuf
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* UPDATEDA or UPDATEMA */
name|int
name|DeletedOne
init|=
literal|0
decl_stmt|;
comment|/* Make a dp for use in db_update, as old dp */
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
do|do
block|{
comment|/* Loop and delete all matching RR(s) */
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
break|break;
name|DeletedOne
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|free
argument_list|(
operator|(
expr|struct
name|databuf
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* Ok for UPDATEMA not to have deleted any RRs */
if|if
condition|(
operator|!
name|DeletedOne
operator|&&
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"UPDATE: db_update failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|)
condition|)
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
empty_stmt|;
comment|/* 		 * Else unmarshal the RR to be added and continue on to 		 * UPDATEA code for UPDATEM/UPDATEMA 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR UPDATE expand name failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
comment|/**** XXX - need bounds checking here ****/
name|cp
operator|+=
name|n
expr_stmt|;
case|case
name|UPDATEA
case|:
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"UPDATE: too much data\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|!=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|msglen
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"FORMERR UPDATE message length off\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_state
operator|&
name|Z_DYNADDONLY
condition|)
block|{
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|dname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"refusing add of existing name\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
name|DB_NODATA
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"UPDATE: db_update failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
endif|#
directive|endif
endif|ALLOW_UPDATES
if|if
condition|(
name|zone
operator|==
literal|0
condition|)
name|ttl
operator|+=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zone
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|flags
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|n
operator|!=
name|DATAEXISTS
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (DATAEXISTS)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|savens
operator|!=
name|NULL
condition|)
operator|*
name|savens
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_block

begin_macro
name|send_msg
argument_list|(
argument|msg
argument_list|,
argument|msglen
argument_list|,
argument|qp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|struct
name|qinfo
modifier|*
name|qhead
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|qinfo
modifier|*
name|tqp
decl_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|qp
operator|->
name|q_system
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"send_msg -> %s (%s %d %d) id=%d\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
literal|"UDP"
else|:
literal|"TCP"
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
name|qp
operator|->
name|q_dfd
else|:
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_port
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
for|for
control|(
name|tqp
operator|=
name|qhead
init|;
name|tqp
operator|!=
name|QINFO_NULL
condition|;
name|tqp
operator|=
name|tqp
operator|->
name|q_link
control|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"qp %x q_id: %d  q_nsid: %d q_msglen: %d "
argument_list|,
name|tqp
argument_list|,
name|tqp
operator|->
name|q_id
argument_list|,
name|tqp
operator|->
name|q_nsid
argument_list|,
name|tqp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_naddr: %d q_curaddr: %d\n"
argument_list|,
name|tqp
operator|->
name|q_naddr
argument_list|,
name|tqp
operator|->
name|q_curaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_next: %x q_link: %x\n"
argument_list|,
name|qp
operator|->
name|q_next
argument_list|,
name|qp
operator|->
name|q_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sendto error errno= %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|prime
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|,
argument|oqp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|qinfo
modifier|*
name|oqp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|oqp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
name|oqp
operator|->
name|q_msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"prime: %s\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|prime_cache
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"prime_cache: priming = %d\n"
argument_list|,
name|priming
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_PRIMECACHE
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|priming
operator|&&
name|fcachetab
operator|->
name|h_tab
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|!
name|forward_only
condition|)
block|{
name|priming
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|sysquery
argument_list|(
literal|""
argument_list|,
name|C_IN
argument_list|,
name|T_NS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|priming
operator|=
literal|0
expr_stmt|;
else|else
name|qp
operator|->
name|q_system
operator|=
name|PRIMING_CACHE
expr_stmt|;
block|}
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|(
name|dname
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|extern
name|struct
name|qinfo
modifier|*
name|qhead
decl_stmt|;
specifier|extern
name|int
name|nsid
decl_stmt|;
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|,
modifier|*
name|oqp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sysquery(%s, %d, %d)\n"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_SYSQUERIES
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|htp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|np
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sysquery: nlookup error on %s?\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sysquery: findns error on %s?\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* build new qinfo struct */
name|qp
operator|=
name|qnew
argument_list|()
expr_stmt|;
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|ds
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
name|qp
operator|->
name|q_system
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
operator|++
name|nsid
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_fwd
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* First check for an already pending query for this data */
for|for
control|(
name|oqp
operator|=
name|qhead
init|;
name|oqp
operator|!=
name|QINFO_NULL
condition|;
name|oqp
operator|=
name|oqp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
name|oqp
operator|!=
name|qp
operator|&&
name|oqp
operator|->
name|q_msglen
operator|==
name|qp
operator|->
name|q_msglen
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sysquery: duplicate\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"resp: no addrs found for NS's\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|==
literal|0
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sysquery: send -> %s %d (%d), nsid=%d id=%d %dms\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|qp
operator|->
name|q_dfd
argument_list|,
name|ntohs
argument_list|(
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|,
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_query
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"sendto error errno= %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_OUTPKTS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of root servers after receiving a response  * to a query for the root servers.  */
end_comment

begin_macro
name|check_root
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|priming
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"check_root: Can't find root!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"%d root servers\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|count
operator|<
name|MINROOTS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"check_root: %d root servers after query to root server< min"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|&&
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|&&
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"deleting old root server '%s'\n"
argument_list|,
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
comment|/* SHOULD DELETE FROM HINTS ALSO */
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
name|check_ns
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Check the root to make sure that for each NS record we have a A RR  */
end_comment

begin_macro
name|check_ns
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|tnp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|found_arr
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"check_ns()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STATS
name|stats
index|[
name|S_CHECKNS
index|]
operator|.
name|cnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|curtime
operator|=
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
condition|)
continue|continue;
comment|/* look for A records */
name|dname
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|tnp
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"check_ns: %s: not found %s %x\n"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|tnp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* look for name server addresses */
name|found_arr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|tdp
operator|->
name|d_class
operator|!=
name|dp
operator|->
name|d_class
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tdp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tdp
operator|->
name|d_ttl
operator|<
name|curtime
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"check_ns: stale entry '%s'\n"
argument_list|,
name|tnp
operator|->
name|n_dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Cache invalidate the address RR's */
name|delete_all
argument_list|(
name|tnp
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found_arr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_arr
condition|)
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MAXCLASS
value|255
end_define

begin_comment
comment|/* belongs elsewhere */
end_comment

begin_decl_stmt
name|int
name|norootlogged
index|[
name|MAXCLASS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Find NS's or an SOA for the given dname (np) and fill in the  *  nsp array.  Returns OK on success, and SERVFAIL on error.  *  We return NXDOMAIN to indicate we are authoritative.  */
end_comment

begin_expr_stmt
name|findns
argument_list|(
name|npp
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
name|countp
argument_list|)
specifier|register
expr|struct
name|namebuf
operator|*
operator|*
name|npp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|countp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
init|=
operator|*
name|npp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
if|if
condition|(
name|priming
operator|&&
operator|(
name|np
operator|==
name|NULL
operator|||
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|htp
operator|=
name|fcachetab
expr_stmt|;
name|try_again
label|:
if|if
condition|(
name|htp
operator|==
name|fcachetab
condition|)
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|np
operator|==
name|NULL
operator|&&
name|htp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"findns: using %s\n"
argument_list|,
name|htp
operator|==
name|hashtab
condition|?
literal|"cache"
else|:
literal|"hints"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|htp
operator|=
operator|(
name|htp
operator|==
name|hashtab
condition|?
name|fcachetab
else|:
name|NULL
operator|)
expr_stmt|;
comment|/* Fallback */
block|}
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"findns: np 0x%x\n"
argument_list|,
name|np
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Look first for SOA records. */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"findns: SOA found\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_auth
condition|)
block|{
operator|*
name|npp
operator|=
name|np
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
else|else
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
block|}
comment|/* If no SOA records, look for NS records. */
name|nspp
operator|=
operator|&
name|nsp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
operator|||
operator|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
operator|)
condition|)
continue|continue;
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|tt
operator|.
name|tv_sec
operator|+
literal|900
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"findns: stale entry '%s'\n"
argument_list|,
name|np
operator|->
name|n_dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Cache invalidate the NS RR's */
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
expr_stmt|;
goto|goto
name|try_parent
goto|;
block|}
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
block|}
operator|*
name|countp
operator|=
name|nspp
operator|-
name|nsp
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"findns: %d NS's added for '%s'\n"
argument_list|,
operator|*
name|countp
argument_list|,
name|np
operator|->
name|n_dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
operator|*
name|npp
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
comment|/* Success, got some NS's */
block|}
name|try_parent
label|:
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
if|if
condition|(
name|htp
condition|)
goto|goto
name|try_again
goto|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"findns: No root nameservers for class %d?\n"
argument_list|,
name|class
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|unsigned
operator|)
name|class
operator|<
name|MAXCLASS
operator|&&
name|norootlogged
index|[
name|class
index|]
operator|==
literal|0
condition|)
block|{
name|norootlogged
index|[
name|class
index|]
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No root nameservers for class %d\n"
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  Extract RR's from the given node that match class and type.  *  Return number of bytes added to response.  *  If no matching data is found, then 0 is returned.  */
end_comment

begin_macro
name|finddata
argument_list|(
argument|np
argument_list|,
argument|class
argument_list|,
argument|type
argument_list|,
argument|hp
argument_list|,
argument|dnamep
argument_list|,
argument|lenp
argument_list|,
argument|countp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|dnamep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|lenp
decl_stmt|,
modifier|*
name|countp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|foundstale
init|=
literal|0
decl_stmt|;
name|buflen
operator|=
operator|*
name|lenp
expr_stmt|;
name|cp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
operator|*
name|countp
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|class
operator|==
name|dp
operator|->
name|d_class
condition|)
block|{
comment|/* any data means no CNAME exists */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* 			 * Don't use stale data. 			 * Would like to call delete_all here 			 * and continue, but the data chain would get 			 * munged; can't restart, as make_rr has side 			 * effects (leaving pointers in dnptr). 			 * Just skip this entry for now 			 * and call delete_all at the end. 			 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"finddata: stale entry '%s'\n"
argument_list|,
name|np
operator|->
name|n_dname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
condition|)
name|foundstale
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* this isn't right for glue records, aa is set in ns_req */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_auth
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
comment|/* or T_NS? */
operator|*
name|dnamep
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_auth
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
comment|/* XXX */
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
block|}
break|break;
block|}
block|}
comment|/* 	 * Cache invalidate the other RR's of same type 	 * if some have timed out 	 */
if|if
condition|(
name|foundstale
condition|)
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"finddata: added %d class %d type %d RRs\n"
argument_list|,
name|count
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do we want this data record based on the class and type?  */
end_comment

begin_macro
name|wanted
argument_list|(
argument|dp
argument_list|,
argument|class
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"wanted(%x, %d, %d) %d, %d\n"
argument_list|,
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|dp
operator|->
name|d_type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_ANY
case|:
case|case
name|T_CNAME
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MAILB
case|:
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_MR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|T_AXFR
case|:
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  Add RR entries from dpp array to a query/response.  *  Return the number of bytes added or negative the amount  *  added if truncation was required.  Typically you are  *  adding NS records to a response.  */
end_comment

begin_macro
name|add_data
argument_list|(
argument|np
argument_list|,
argument|dpp
argument_list|,
argument|cp
argument_list|,
argument|buflen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|buflen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|*
name|dpp
operator|++
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
operator|*
name|dpp
operator|++
control|)
block|{
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* ignore old cache entry */
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|count
operator|)
return|;
comment|/* Truncation */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  This is best thought of as a "cache invalidate" function.  *  It is called whenever a piece of data is determined to have  *  timed out.  It is better to have no information, than to  *  have partial information you pass off as complete.  */
end_comment

begin_expr_stmt
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
specifier|register
expr|struct
name|namebuf
operator|*
name|np
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"delete_all: '%s' 0x%x class %d type %d\n"
argument_list|,
name|np
operator|->
name|n_dname
argument_list|,
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
end_block

end_unit

