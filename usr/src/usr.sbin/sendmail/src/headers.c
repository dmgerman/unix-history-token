begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)headers.c	6.11 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_comment
comment|/* **  CHOMPHEADER -- process and save a header line. ** **	Called by collect and by readcf to deal with header lines. ** **	Parameters: **		line -- header as a text line. **		def -- if set, this is a default value. **		e -- the envelope including this header. ** **	Returns: **		flags for this header. ** **	Side Effects: **		The header is saved on the header list. **		Contents of 'line' are destroyed. */
end_comment

begin_macro
name|chompheader
argument_list|(
argument|line
argument_list|,
argument|def
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|def
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|fvalue
decl_stmt|;
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
name|bool
name|cond
init|=
name|FALSE
decl_stmt|;
name|BITMAP
name|mopts
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|sendto
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|31
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"chompheader: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* strip off options */
name|clrbitmap
argument_list|(
name|mopts
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'?'
condition|)
block|{
comment|/* have some */
specifier|register
name|char
modifier|*
name|q
init|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
literal|'\0'
condition|)
name|setbitn
argument_list|(
operator|*
name|p
argument_list|,
name|mopts
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
else|else
name|usrerr
argument_list|(
literal|"553 header syntax error, line \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|cond
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* find canonical name */
name|fname
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"553 header syntax error, line \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fvalue
operator|=
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
operator|--
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
name|makelower
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* strip field value on front */
if|if
condition|(
operator|*
name|fvalue
operator|==
literal|' '
condition|)
name|fvalue
operator|++
expr_stmt|;
comment|/* see if it is a known type */
for|for
control|(
name|hi
operator|=
name|HdrInfo
init|;
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|;
name|hi
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hi
operator|->
name|hi_field
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* see if this is a resent message */
if|if
condition|(
operator|!
name|def
operator|&&
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_RESENT
expr_stmt|;
comment|/* if this means "end of header" quit now */
if|if
condition|(
name|bitset
argument_list|(
name|H_EOH
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
return|return
operator|(
name|hi
operator|->
name|hi_flags
operator|)
return|;
comment|/* drop explicit From: if same as what we would generate -- for MH */
name|p
operator|=
literal|"resent-from"
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|&&
operator|!
name|QueueRun
operator|&&
name|strcmp
argument_list|(
name|fname
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|fvalue
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|hi
operator|->
name|hi_flags
operator|)
return|;
block|}
comment|/* drop forged Sender: values */
name|p
operator|=
literal|"resent-sender"
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
condition|)
name|p
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|&&
operator|!
name|QueueRun
operator|&&
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|==
name|LocalMailer
operator|&&
name|bitset
argument_list|(
name|H_VALID
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
block|{
return|return
operator|(
name|hi
operator|->
name|hi_flags
operator|)
return|;
block|}
comment|/* delete default value for this header */
for|for
control|(
name|hp
operator|=
operator|&
name|e
operator|->
name|e_header
init|;
operator|(
name|h
operator|=
operator|*
name|hp
operator|)
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
operator|==
literal|0
operator|&&
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_FORCE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|h
operator|->
name|h_value
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* create a new node */
name|h
operator|=
operator|(
name|HDR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_field
operator|=
name|newstr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
name|NULL
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mopts
argument_list|,
operator|(
name|char
operator|*
operator|)
name|h
operator|->
name|h_mflags
argument_list|,
sizeof|sizeof
name|mopts
argument_list|)
expr_stmt|;
operator|*
name|hp
operator|=
name|h
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|hi
operator|->
name|hi_flags
expr_stmt|;
if|if
condition|(
name|def
condition|)
name|h
operator|->
name|h_flags
operator||=
name|H_DEFAULT
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|h
operator|->
name|h_flags
operator||=
name|H_CHECK
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
literal|0
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hack to see if this is a new format message */
if|if
condition|(
operator|!
name|def
operator|&&
name|bitset
argument_list|(
name|H_RCPT
operator||
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|(
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|fvalue
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|->
name|h_flags
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ADDHEADER -- add a header entry to the end of the queue. ** **	This bypasses the special checking of chompheader. ** **	Parameters: **		field -- the name of the header field. **		value -- the value of the field.  It must be lower-cased. **		e -- the envelope to add them to. ** **	Returns: **		none. ** **	Side Effects: **		adds the field on the list of headers for this envelope. */
end_comment

begin_macro
name|addheader
argument_list|(
argument|field
argument_list|,
argument|value
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|field
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* find info struct */
for|for
control|(
name|hi
operator|=
name|HdrInfo
init|;
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|;
name|hi
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|field
argument_list|,
name|hi
operator|->
name|hi_field
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* find current place in list -- keep back pointer? */
for|for
control|(
name|hp
operator|=
operator|&
name|e
operator|->
name|e_header
init|;
operator|(
name|h
operator|=
operator|*
name|hp
operator|)
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|field
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* allocate space for new header */
name|h
operator|=
operator|(
name|HDR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_field
operator|=
name|field
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|newstr
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
operator|*
name|hp
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|hi
operator|->
name|hi_flags
operator||
name|H_DEFAULT
expr_stmt|;
name|clrbitmap
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|)
expr_stmt|;
operator|*
name|hp
operator|=
name|h
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  HVALUE -- return value of a header. ** **	Only "real" fields (i.e., ones that have not been supplied **	as a default) are used. ** **	Parameters: **		field -- the field name. **		e -- the envelope containing the header. ** **	Returns: **		pointer to the value part. **		NULL if not found. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|hvalue
parameter_list|(
name|field
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|field
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|h
operator|->
name|h_value
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ISHEADER -- predicate telling if argument is a header. ** **	A line is a header if it has a single word followed by **	optional white space followed by a colon. ** **	Parameters: **		s -- string to check for possible headerness. ** **	Returns: **		TRUE if s is a header. **		FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isheader
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|s
operator|>
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|':'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
comment|/* following technically violates RFC822 */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|s
operator|==
literal|':'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  EATHEADER -- run through the stored header and extract info. ** **	Parameters: **		e -- the envelope to process. **		queuejob -- set if running a queued job. ** **	Returns: **		none. ** **	Side Effects: **		Sets a bunch of global variables from information **			in the collected header. **		Aborts the message if the hop count is exceeded. */
end_comment

begin_expr_stmt
name|eatheader
argument_list|(
name|e
argument_list|,
name|queuejob
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|queuejob
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|hopcnt
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|msgid
decl_stmt|;
name|char
name|msgidbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"----- collected header -----\n"
argument_list|)
expr_stmt|;
name|msgid
operator|=
literal|"<none>"
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
specifier|extern
name|char
modifier|*
name|capitalize
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
comment|/* count the number of times it has been processed */
if|if
condition|(
name|bitset
argument_list|(
name|H_TRACE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|hopcnt
operator|++
expr_stmt|;
comment|/* send to this person if we so desire */
if|if
condition|(
name|GrabTo
operator|&&
name|bitset
argument_list|(
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|(
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* save the message-id for logging */
if|if
condition|(
operator|!
name|queuejob
operator|&&
name|h
operator|->
name|h_value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
literal|"message-id"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msgid
operator|=
name|h
operator|->
name|h_value
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|expand
argument_list|(
name|msgid
argument_list|,
name|msgidbuf
argument_list|,
operator|&
name|msgidbuf
index|[
sizeof|sizeof
name|msgidbuf
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|msgidbuf
expr_stmt|;
block|}
block|}
comment|/* see if this is a return-receipt header */
if|if
condition|(
name|bitset
argument_list|(
name|H_RECEIPTTO
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|e
operator|->
name|e_receiptto
operator|=
name|h
operator|->
name|h_value
expr_stmt|;
comment|/* see if this is an errors-to header */
if|if
condition|(
name|bitset
argument_list|(
name|H_ERRORSTO
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sendtolist
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
comment|/* if we are just verifying (that is, sendmail -t -bv), drop out now */
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
return|return;
comment|/* store hop count */
if|if
condition|(
name|hopcnt
operator|>
name|e
operator|->
name|e_hopcount
condition|)
name|e
operator|->
name|e_hopcount
operator|=
name|hopcnt
expr_stmt|;
comment|/* message priority */
name|p
operator|=
name|hvalue
argument_list|(
literal|"precedence"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|e
operator|->
name|e_class
operator|=
name|priencode
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queuejob
condition|)
name|e
operator|->
name|e_msgpriority
operator|=
name|e
operator|->
name|e_msgsize
operator|-
name|e
operator|->
name|e_class
operator|*
name|WkClassFact
operator|+
name|e
operator|->
name|e_nrcpts
operator|*
name|WkRecipFact
expr_stmt|;
comment|/* full name of from person */
name|p
operator|=
name|hvalue
argument_list|(
literal|"full-name"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|define
argument_list|(
literal|'x'
argument_list|,
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* date message originated */
name|p
operator|=
name|hvalue
argument_list|(
literal|"posted-date"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|hvalue
argument_list|(
literal|"date"
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|define
argument_list|(
literal|'a'
argument_list|,
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  Log collection information. 	*/
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
operator|!
name|queuejob
operator|&&
name|LogLevel
operator|>
literal|4
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|hbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|sbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|RealHostName
operator|==
name|NULL
condition|)
name|name
operator|=
literal|"local"
expr_stmt|;
elseif|else
if|if
condition|(
name|RealHostName
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
name|name
operator|=
name|RealHostName
expr_stmt|;
else|else
block|{
specifier|extern
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
name|name
operator|=
name|hbuf
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|hbuf
argument_list|,
literal|"%.80s (%s)"
argument_list|,
name|RealHostName
argument_list|,
name|inet_ntoa
argument_list|(
name|RealHostAddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* some versions of syslog only take 5 printf args */
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"from=%.200s, size=%ld, class=%d, pri=%ld, nrcpts=%d, msgid=%.100s"
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|e
operator|->
name|e_msgsize
argument_list|,
name|e
operator|->
name|e_class
argument_list|,
name|e
operator|->
name|e_msgpriority
argument_list|,
name|e
operator|->
name|e_nrcpts
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: %s, received from %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|sbuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOG */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PRIENCODE -- encode external priority names into internal values. ** **	Parameters: **		p -- priority in ascii. ** **	Returns: **		priority as a numeric level. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|priencode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NumPriorities
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|Priorities
index|[
name|i
index|]
operator|.
name|pri_name
argument_list|)
condition|)
return|return
operator|(
name|Priorities
index|[
name|i
index|]
operator|.
name|pri_val
operator|)
return|;
block|}
comment|/* unknown priority */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CRACKADDR -- parse an address and turn it into a macro ** **	This doesn't actually parse the address -- it just extracts **	it and replaces it with "$g".  The parse is totally ad hoc **	and isn't even guaranteed to leave something syntactically **	identical to what it started with.  However, it does leave **	something semantically identical. ** **	This algorithm has been cleaned up to handle a wider range **	of cases -- notably quoted and backslash escaped strings. **	This modification makes it substantially better at preserving **	the original syntax. ** **	Parameters: **		addr -- the address to be cracked. ** **	Returns: **		a pointer to the new version. ** **	Side Effects: **		none. ** **	Warning: **		The return value is saved in local storage and should **		be copied if it is to be reused. */
end_comment

begin_function
name|char
modifier|*
name|crackaddr
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|cmtlev
decl_stmt|;
name|int
name|realcmtlev
decl_stmt|;
name|int
name|anglelev
decl_stmt|,
name|realanglelev
decl_stmt|;
name|int
name|copylev
decl_stmt|;
name|bool
name|qmode
decl_stmt|;
name|bool
name|realqmode
decl_stmt|;
name|bool
name|skipping
decl_stmt|;
name|bool
name|putgmac
init|=
name|FALSE
decl_stmt|;
name|bool
name|quoteit
init|=
name|FALSE
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|buflim
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|33
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"crackaddr(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* strip leading spaces */
while|while
condition|(
operator|*
name|addr
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|addr
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|addr
argument_list|)
condition|)
name|addr
operator|++
expr_stmt|;
comment|/* 	**  Start by assuming we have no angle brackets.  This will be 	**  adjusted later if we find them. 	*/
name|bp
operator|=
name|buf
expr_stmt|;
name|buflim
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|5
index|]
expr_stmt|;
name|p
operator|=
name|addr
expr_stmt|;
name|copylev
operator|=
name|anglelev
operator|=
name|realanglelev
operator|=
name|cmtlev
operator|=
name|realcmtlev
operator|=
literal|0
expr_stmt|;
name|qmode
operator|=
name|realqmode
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 		**  If the buffer is overful, go into a special "skipping" 		**  mode that tries to keep legal syntax but doesn't actually 		**  output things. 		*/
name|skipping
operator|=
name|bp
operator|>=
name|buflim
expr_stmt|;
if|if
condition|(
name|copylev
operator|>
literal|0
operator|&&
operator|!
name|skipping
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* check for backslash escapes */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
comment|/* too far */
name|p
operator|--
expr_stmt|;
goto|goto
name|putg
goto|;
block|}
if|if
condition|(
name|copylev
operator|>
literal|0
operator|&&
operator|!
name|skipping
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
goto|goto
name|putg
goto|;
block|}
comment|/* check for quoted strings */
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|qmode
operator|=
operator|!
name|qmode
expr_stmt|;
if|if
condition|(
name|copylev
operator|>
literal|0
operator|&&
operator|!
name|skipping
condition|)
name|realqmode
operator|=
operator|!
name|realqmode
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|qmode
condition|)
goto|goto
name|putg
goto|;
comment|/* check for comments */
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|cmtlev
operator|++
expr_stmt|;
comment|/* allow space for closing paren */
if|if
condition|(
operator|!
name|skipping
condition|)
block|{
name|buflim
operator|--
expr_stmt|;
name|realcmtlev
operator|++
expr_stmt|;
if|if
condition|(
name|copylev
operator|++
operator|<=
literal|0
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cmtlev
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|cmtlev
operator|--
expr_stmt|;
name|copylev
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|skipping
condition|)
block|{
name|realcmtlev
operator|--
expr_stmt|;
name|buflim
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
comment|/* syntax error: unmatched ) */
if|if
condition|(
operator|!
name|skipping
condition|)
name|bp
operator|--
expr_stmt|;
block|}
comment|/* check for characters that may have to be quoted */
if|if
condition|(
name|strchr
argument_list|(
literal|".'@,;:\\()"
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			**  If these occur as the phrase part of a<> 			**  construct, but are not inside of () or already 			**  quoted, they will have to be quoted.  Note that 			**  now (but don't actually do the quoting). 			*/
if|if
condition|(
name|cmtlev
operator|<=
literal|0
operator|&&
operator|!
name|qmode
condition|)
name|quoteit
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* check for angle brackets */
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/* oops -- have to change our mind */
name|anglelev
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|skipping
condition|)
name|realanglelev
operator|++
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|quoteit
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'"'
expr_stmt|;
comment|/* back up over the '<' and any spaces */
operator|--
name|p
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
operator|--
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
name|addr
init|;
name|q
operator|<
name|p
condition|;
control|)
block|{
name|c
operator|=
operator|*
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|<
name|buflim
condition|)
block|{
if|if
condition|(
name|quoteit
operator|&&
name|c
operator|==
literal|'"'
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quoteit
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'"'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'<'
condition|)
block|{
if|if
condition|(
name|bp
operator|<
name|buflim
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|copylev
operator|=
literal|0
expr_stmt|;
name|putgmac
operator|=
name|quoteit
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|anglelev
operator|>
literal|0
condition|)
block|{
name|anglelev
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|skipping
condition|)
block|{
name|realanglelev
operator|--
expr_stmt|;
name|buflim
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|skipping
condition|)
block|{
comment|/* syntax error: unmatched> */
if|if
condition|(
name|copylev
operator|>
literal|0
condition|)
name|bp
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|copylev
operator|++
operator|<=
literal|0
condition|)
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* must be a real address character */
name|putg
label|:
if|if
condition|(
name|copylev
operator|<=
literal|0
operator|&&
operator|!
name|putgmac
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|MACROEXPAND
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'g'
expr_stmt|;
name|putgmac
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* repair any syntactic damage */
if|if
condition|(
name|realqmode
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'"'
expr_stmt|;
while|while
condition|(
name|realcmtlev
operator|--
operator|>
literal|0
condition|)
operator|*
name|bp
operator|++
operator|=
literal|')'
expr_stmt|;
while|while
condition|(
name|realanglelev
operator|--
operator|>
literal|0
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|33
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"crackaddr=>`%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PUTHEADER -- put the header part of a message from the in-core copy ** **	Parameters: **		fp -- file to put it on. **		m -- mailer to use. **		e -- envelope to use. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_comment
comment|/*  * Macro for fast max (not available in e.g. DG/UX, 386/ix).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|putheader
argument_list|(
name|fp
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAX
argument_list|(
name|MAXLINE
argument_list|,
name|BUFSIZ
argument_list|)
index|]
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
name|char
name|obuf
index|[
name|MAXLINE
index|]
decl_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|bool
name|bitintersect
parameter_list|()
function_decl|;
if|if
condition|(
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitintersect
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
continue|continue;
comment|/* handle Resent-... headers specially */
if|if
condition|(
name|bitset
argument_list|(
name|H_RESENT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_RESENT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
continue|continue;
name|p
operator|=
name|h
operator|->
name|h_value
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
comment|/* macro expand value if generated internally */
name|expand
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
operator||
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
comment|/* address field */
name|bool
name|oldstyle
init|=
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|oldstyle
operator|=
name|FALSE
expr_stmt|;
name|commaize
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
name|fp
argument_list|,
name|oldstyle
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* vanilla header line */
specifier|register
name|char
modifier|*
name|nlp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|capitalize
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obuf
argument_list|,
literal|"%s: "
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nlp
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nlp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|obuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|nlp
operator|=
literal|'\n'
expr_stmt|;
name|putline
argument_list|(
name|obuf
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|p
operator|=
operator|++
name|nlp
expr_stmt|;
name|obuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|obuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|obuf
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  COMMAIZE -- output a header field, making a comma-translated list. ** **	Parameters: **		h -- the header field to output. **		p -- the value to put in it. **		fp -- file to put it to. **		oldstyle -- TRUE if this is an old style header. **		m -- a pointer to the mailer descriptor.  If NULL, **			don't transform the name at all. **		e -- the envelope containing the message. ** **	Returns: **		none. ** **	Side Effects: **		outputs "p" to file "fp". */
end_comment

begin_expr_stmt
name|commaize
argument_list|(
name|h
argument_list|,
name|p
argument_list|,
name|fp
argument_list|,
name|oldstyle
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
specifier|register
name|HDR
operator|*
name|h
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|oldstyle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|obp
decl_stmt|;
name|int
name|opos
decl_stmt|;
name|bool
name|firstone
init|=
name|TRUE
decl_stmt|;
name|char
name|obuf
index|[
name|MAXLINE
operator|+
literal|3
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|capitalize
parameter_list|()
function_decl|;
comment|/* 	**  Output the address list translated by the 	**  mailer and with commas. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|14
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"commaize(%s: %s)\n"
argument_list|,
name|h
operator|->
name|h_field
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|obp
operator|=
name|obuf
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obp
argument_list|,
literal|"%s: "
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|)
expr_stmt|;
name|opos
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
operator|+
literal|2
expr_stmt|;
name|obp
operator|+=
name|opos
expr_stmt|;
comment|/* 	**  Run through the list of values. 	*/
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|savechar
decl_stmt|;
specifier|extern
name|char
modifier|*
name|remotename
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
comment|/* defined in prescan */
comment|/* 		**  Find the end of the name.  New style names 		**  end with a comma, old style names end with 		**  a space character.  However, spaces do not 		**  necessarily delimit an old-style name -- at 		**  signs mean keep going. 		*/
comment|/* find end of name */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|name
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|oldp
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
specifier|extern
name|bool
name|isatword
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|prescan
argument_list|(
name|p
argument_list|,
name|oldstyle
condition|?
literal|' '
else|:
literal|','
argument_list|,
name|pvpbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|DelimChar
expr_stmt|;
comment|/* look to see if we have an at sign */
name|oldp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'@'
operator|&&
operator|!
name|isatword
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|oldp
expr_stmt|;
break|break;
block|}
name|p
operator|+=
operator|*
name|p
operator|==
literal|'@'
condition|?
literal|1
else|:
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* at the end of one complete name */
comment|/* strip off trailing white space */
while|while
condition|(
name|p
operator|>=
name|name
operator|&&
operator|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|)
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|++
name|p
operator|==
name|name
condition|)
continue|continue;
name|savechar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* translate the name to be relative */
name|name
operator|=
name|remotename
argument_list|(
name|name
argument_list|,
name|m
argument_list|,
name|bitset
argument_list|(
name|H_FROM
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|=
name|savechar
expr_stmt|;
continue|continue;
block|}
comment|/* output the name with nice formatting */
name|opos
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstone
condition|)
name|opos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|opos
operator|>
literal|78
operator|&&
operator|!
name|firstone
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|obp
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|obuf
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|obp
operator|=
name|obuf
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obp
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
name|opos
operator|=
name|strlen
argument_list|(
name|obp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|opos
expr_stmt|;
name|opos
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|firstone
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|obp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|obp
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* strip off quote bits as we output */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|obp
operator|<
operator|&
name|obuf
index|[
name|MAXLINE
index|]
condition|)
block|{
if|if
condition|(
name|bitnset
argument_list|(
name|M_7BITS
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|c
operator|&=
literal|0177
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|firstone
operator|=
name|FALSE
expr_stmt|;
operator|*
name|p
operator|=
name|savechar
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|obp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|obuf
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ISATWORD -- tell if the word we are pointing to is "at". ** **	Parameters: **		p -- word to check. ** **	Returns: **		TRUE -- if p is the word at. **		FALSE -- otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isatword
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|extern
name|char
name|lower
parameter_list|()
function_decl|;
if|if
condition|(
name|lower
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'a'
operator|&&
name|lower
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'t'
operator|&&
name|p
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
name|isascii
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isspace
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

end_unit

