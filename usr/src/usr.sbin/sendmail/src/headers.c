begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|headers
operator|.
name|c
literal|3.29
operator|%
name|G
operator|%
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  CHOMPHEADER -- process and save a header line. ** **	Called by collect and by readcf to deal with header lines. ** **	Parameters: **		line -- header as a text line. **		def -- if set, this is a default value. ** **	Returns: **		flags for this header. ** **	Side Effects: **		The header is saved on the header list. **		Contents of 'line' are destroyed. */
end_comment

begin_macro
name|chompheader
argument_list|(
argument|line
argument_list|,
argument|def
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|fvalue
decl_stmt|;
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
name|u_long
name|mopts
decl_stmt|;
specifier|extern
name|u_long
name|mfencode
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|crackaddr
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|sendto
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|31
argument_list|,
literal|6
argument_list|)
condition|)
name|printf
argument_list|(
literal|"chompheader: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* strip off options */
name|mopts
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'?'
condition|)
block|{
comment|/* have some */
specifier|register
name|char
modifier|*
name|q
init|=
name|index
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|*
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|mopts
operator|=
name|mfencode
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
else|else
name|syserr
argument_list|(
literal|"chompheader: syntax error, line \"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* find canonical name */
name|fname
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|fvalue
operator|=
operator|&
name|p
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
operator|--
name|p
argument_list|)
condition|)
continue|continue;
operator|*
operator|++
name|p
operator|=
literal|'\0'
expr_stmt|;
name|makelower
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* strip field value on front */
if|if
condition|(
operator|*
name|fvalue
operator|==
literal|' '
condition|)
name|fvalue
operator|++
expr_stmt|;
comment|/* search header list for this header */
for|for
control|(
name|hp
operator|=
operator|&
name|CurEnv
operator|->
name|e_header
operator|,
name|h
operator|=
name|CurEnv
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|h
operator|->
name|h_link
operator|,
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
operator|==
literal|0
operator|&&
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
break|break;
block|}
comment|/* see if it is a known type */
for|for
control|(
name|hi
operator|=
name|HdrInfo
init|;
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|;
name|hi
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hi
operator|->
name|hi_field
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* if this means "end of header" quit now */
if|if
condition|(
name|bitset
argument_list|(
name|H_EOH
argument_list|,
name|hi
operator|->
name|hi_flags
argument_list|)
condition|)
return|return
operator|(
name|hi
operator|->
name|hi_flags
operator|)
return|;
comment|/* count Received: lines to avoid loops (simulate hop counts) */
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
literal|"received"
argument_list|)
operator|==
literal|0
condition|)
name|HopCount
operator|++
expr_stmt|;
comment|/* create/fill in a new node */
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|bitset
argument_list|(
name|H_FORCE
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
comment|/* create a new node */
name|h
operator|=
operator|(
name|HDR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_field
operator|=
name|newstr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|NULL
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
operator|*
name|hp
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|hi
operator|->
name|hi_flags
expr_stmt|;
name|h
operator|->
name|h_mflags
operator|=
name|mopts
operator||
name|hi
operator|->
name|hi_mflags
expr_stmt|;
operator|*
name|hp
operator|=
name|h
expr_stmt|;
block|}
if|if
condition|(
name|def
condition|)
name|h
operator|->
name|h_flags
operator||=
name|H_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|mopts
operator|==
literal|0
condition|)
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|H_CHECK
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
operator|&&
name|strcmp
argument_list|(
name|fname
argument_list|,
literal|"from"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* turn it into a macro -- will be expanded later */
name|h
operator|->
name|h_value
operator|=
name|newstr
argument_list|(
name|crackaddr
argument_list|(
name|fvalue
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|H_DEFAULT
expr_stmt|;
block|}
else|else
name|h
operator|->
name|h_value
operator|=
name|newstr
argument_list|(
name|fvalue
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
literal|0
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hack to see if this is a new format message */
if|if
condition|(
name|bitset
argument_list|(
name|H_RCPT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|(
name|index
argument_list|(
name|fvalue
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|fvalue
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|fvalue
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|CurEnv
operator|->
name|e_oldstyle
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|h
operator|->
name|h_flags
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ADDHEADER -- add a header entry to the end of the queue. ** **	This bypasses the special checking of chompheader. ** **	Parameters: **		field -- the name of the header field. **		value -- the value of the field.  It must be lower-cased. **		e -- the envelope to add them to. ** **	Returns: **		none. ** **	Side Effects: **		adds the field on the list of headers for this envelope. */
end_comment

begin_macro
name|addheader
argument_list|(
argument|field
argument_list|,
argument|value
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|field
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|struct
name|hdrinfo
modifier|*
name|hi
decl_stmt|;
name|HDR
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* find info struct */
for|for
control|(
name|hi
operator|=
name|HdrInfo
init|;
name|hi
operator|->
name|hi_field
operator|!=
name|NULL
condition|;
name|hi
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|field
argument_list|,
name|hi
operator|->
name|hi_field
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* find current place in list -- keep back pointer? */
for|for
control|(
name|hp
operator|=
operator|&
name|e
operator|->
name|e_header
init|;
operator|(
name|h
operator|=
operator|*
name|hp
operator|)
operator|!=
name|NULL
condition|;
name|hp
operator|=
operator|&
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|field
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* allocate space for new header */
name|h
operator|=
operator|(
name|HDR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_field
operator|=
name|field
expr_stmt|;
name|h
operator|->
name|h_value
operator|=
name|newstr
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_link
operator|=
operator|*
name|hp
expr_stmt|;
name|h
operator|->
name|h_flags
operator|=
name|hi
operator|->
name|hi_flags
operator||
name|H_DEFAULT
expr_stmt|;
name|h
operator|->
name|h_mflags
operator|=
name|hi
operator|->
name|hi_mflags
expr_stmt|;
operator|*
name|hp
operator|=
name|h
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  HVALUE -- return value of a header. ** **	Only "real" fields (i.e., ones that have not been supplied **	as a default) are used. ** **	Parameters: **		field -- the field name. ** **	Returns: **		pointer to the value part. **		NULL if not found. ** **	Side Effects: **		sets the H_USED bit in the header if found. */
end_comment

begin_function
name|char
modifier|*
name|hvalue
parameter_list|(
name|field
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|CurEnv
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|field
argument_list|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|h_flags
operator||=
name|H_USED
expr_stmt|;
return|return
operator|(
name|h
operator|->
name|h_value
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  HRVALUE -- return pointer to header descriptor. ** **	Like hvalue except returns header descriptor block and isn't **	picky about "real" headers. ** **	Parameters: **		field -- name of field we are interested in. ** **	Returns: **		pointer to header descriptor. ** **	Side Effects: **		none. */
end_comment

begin_function
name|HDR
modifier|*
name|hrvalue
parameter_list|(
name|field
parameter_list|)
name|char
modifier|*
name|field
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|CurEnv
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
name|field
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|h
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ISHEADER -- predicate telling if argument is a header. ** **	A line is a header if it has a single word followed by **	optional white space followed by a colon. ** **	Parameters: **		s -- string to check for possible headerness. ** **	Returns: **		TRUE if s is a header. **		FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isheader
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|':'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|s
operator|==
literal|':'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  GETXPART -- extract the "signature" part of an address line. ** **	Try to extract the full name from a general address **	field.  We take anything which is a comment as a **	first choice.  Failing in that, we see if there is **	a "machine readable" name (in<angle brackets>); if **	so we take anything preceeding that clause. ** **	If we blow it here it's not all that serious. ** **	Parameters: **		p -- line to crack. ** **	Returns: **		signature part. **		NULL if no signature part. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|getxpart
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|rval
init|=
name|NULL
decl_stmt|;
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|int
name|parenlev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|q
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
name|parenlev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
operator|&&
operator|--
name|parenlev
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|q
operator|!=
literal|'\0'
condition|)
name|rval
operator|=
name|newstr
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|')'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|savec
decl_stmt|;
while|while
condition|(
operator|*
operator|--
name|q
operator|==
literal|' '
condition|)
continue|continue;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|savec
operator|=
operator|*
operator|++
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|rval
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|savec
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  EATHEADER -- run through the stored header and extract info. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Sets a bunch of global variables from information **		in the collected header. */
end_comment

begin_macro
name|eatheader
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|32
argument_list|,
literal|2
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|capitalize
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"----- collected header -----\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|CurEnv
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* message priority */
if|if
condition|(
operator|!
name|QueueRun
condition|)
block|{
comment|/* adjust total priority by message priority */
name|CurEnv
operator|->
name|e_msgpriority
operator|=
name|CurEnv
operator|->
name|e_msgsize
expr_stmt|;
name|p
operator|=
name|hvalue
argument_list|(
literal|"priority"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|CurEnv
operator|->
name|e_class
operator|=
name|priencode
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|CurEnv
operator|->
name|e_class
operator|=
name|PRI_NORMAL
expr_stmt|;
name|CurEnv
operator|->
name|e_msgpriority
operator|-=
name|CurEnv
operator|->
name|e_class
operator|*
name|WKPRIFACT
expr_stmt|;
block|}
comment|/* special handling */
name|p
operator|=
name|hvalue
argument_list|(
literal|"special-handling"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|spechandling
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* from person */
name|p
operator|=
name|hvalue
argument_list|(
literal|"sender"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|CurEnv
operator|->
name|e_origfrom
expr_stmt|;
if|if
condition|(
name|ArpaMode
condition|)
name|setfrom
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* full name of from person */
name|p
operator|=
name|hvalue
argument_list|(
literal|"full-name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|define
argument_list|(
literal|'x'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* date message originated */
name|p
operator|=
name|hvalue
argument_list|(
literal|"posted-date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|hvalue
argument_list|(
literal|"date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|define
argument_list|(
literal|'a'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* we don't have a good way to do canonical conversion .... 		define('d', newstr(arpatounix(p))); 		.... so we will ignore the problem for the time being */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PRIENCODE -- encode external priority names into internal values. ** **	Parameters: **		p -- priority in ascii. ** **	Returns: **		priority as a numeric level. ** **	Side Effects: **		none. */
end_comment

begin_struct
struct|struct
name|prio
block|{
name|char
modifier|*
name|pri_name
decl_stmt|;
comment|/* external name of priority */
name|int
name|pri_val
decl_stmt|;
comment|/* internal value for same */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|prio
name|Prio
index|[]
init|=
block|{
literal|"alert"
block|,
name|PRI_ALERT
block|,
literal|"quick"
block|,
name|PRI_QUICK
block|,
literal|"first-class"
block|,
name|PRI_FIRSTCL
block|,
literal|"normal"
block|,
name|PRI_NORMAL
block|,
literal|"second-class"
block|,
name|PRI_SECONDCL
block|,
literal|"third-class"
block|,
name|PRI_THIRDCL
block|,
literal|"junk"
block|,
name|PRI_JUNK
block|,
name|NULL
block|,
name|PRI_NORMAL
block|, }
decl_stmt|;
end_decl_stmt

begin_macro
name|priencode
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|prio
modifier|*
name|pl
decl_stmt|;
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
for|for
control|(
name|pl
operator|=
name|Prio
init|;
name|pl
operator|->
name|pri_name
operator|!=
name|NULL
condition|;
name|pl
operator|++
control|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|p
argument_list|,
name|pl
operator|->
name|pri_name
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|pl
operator|->
name|pri_val
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SPECHANDLE -- do special handling ** **	Parameters: **		p -- pointer to list of special handling words. ** **	Returns: **		none. ** **	Side Effects: **		Sets flags as indicated by p. */
end_comment

begin_struct
struct|struct
name|handling
block|{
name|char
modifier|*
name|han_name
decl_stmt|;
comment|/* word to get this magic */
name|int
name|han_what
decl_stmt|;
comment|/* what to do, see below */
block|}
struct|;
end_struct

begin_comment
comment|/* modes for han_what */
end_comment

begin_define
define|#
directive|define
name|HAN_NONE
value|0
end_define

begin_comment
comment|/* nothing special */
end_comment

begin_define
define|#
directive|define
name|HAN_RRECEIPT
value|1
end_define

begin_comment
comment|/* give return receipt */
end_comment

begin_decl_stmt
name|struct
name|handling
name|Handling
index|[]
init|=
block|{
literal|"return-receipt-requested"
block|,
name|HAN_RRECEIPT
block|,
name|NULL
block|,
name|HAN_NONE
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|spechandling
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|w
decl_stmt|;
specifier|register
name|struct
name|handling
modifier|*
name|h
decl_stmt|;
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* collect a word to compare to */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|','
operator|||
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|w
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|','
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* scan the special handling table */
for|for
control|(
name|h
operator|=
name|Handling
init|;
name|h
operator|->
name|han_name
operator|!=
name|NULL
condition|;
name|h
operator|++
control|)
if|if
condition|(
name|sameword
argument_list|(
name|h
operator|->
name|han_name
argument_list|,
name|w
argument_list|)
condition|)
break|break;
comment|/* see if we can do anything interesting */
switch|switch
condition|(
name|h
operator|->
name|han_what
condition|)
block|{
case|case
name|HAN_NONE
case|:
comment|/* nothing to be done */
break|break;
case|case
name|HAN_RRECEIPT
case|:
comment|/* give return receipt */
name|CurEnv
operator|->
name|e_retreceipt
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|30
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|">>> Return receipt requested\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
break|break;
default|default:
name|syserr
argument_list|(
literal|"spechandling: handling %d (%s)"
argument_list|,
name|h
operator|->
name|han_what
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CRACKADDR -- parse an address and turn it into a macro ** **	This doesn't actually parse the address -- it just extracts **	it and replaces it with "$g".  The parse is totally ad hoc **	and isn't even guaranteed to leave something syntactically **	identical to what it started with.  However, it does leave **	something semantically identical. ** **	The process is kind of strange.  There are a number of **	interesting cases: **		1.  comment<address> comment	==> comment<$g> comment **		2.  address			==> address **		3.  address (comment)		==> $g (comment) **		4.  (comment) address		==> (comment) $g **	And then there are the hard cases.... **		5.  add (comment) ress		==> $g (comment) **		6.  comment<address (comment)>	==> comment<$g (comment)> **		7.    .... etc .... ** **	Parameters: **		addr -- the address to be cracked. ** **	Returns: **		a pointer to the new version. ** **	Side Effects: **		none. ** **	Warning: **		The return value is saved in local storage and should **		be copied if it is to be reused. */
end_comment

begin_function
name|char
modifier|*
name|crackaddr
parameter_list|(
name|addr
parameter_list|)
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
modifier|*
name|rhs
decl_stmt|;
name|bool
name|gotaddr
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|33
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"crackaddr(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  See if we have anything in angle brackets.  If so, that is 	**  the address part, and the rest is the comment. 	*/
name|p
operator|=
name|index
argument_list|(
name|addr
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* copy the beginning of the addr field to the buffer */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'<'
expr_stmt|;
comment|/* find the matching right angle bracket */
name|addr
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'<'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|i
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
block|}
comment|/* p now points to the closing quote (or a null byte) */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
comment|/* make rhs point to the extra stuff at the end */
name|rhs
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* 	**  Now parse the real address part.  from points to the (null 	**  terminated) version of what we are inerested in; rhs points 	**  to the extra stuff at the end of the line, if any. 	*/
name|p
operator|=
name|addr
expr_stmt|;
comment|/* now strip out comments */
name|bp
operator|=
operator|&
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
index|]
expr_stmt|;
name|gotaddr
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
comment|/* copy to matching close paren */
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'('
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|i
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
break|break;
block|}
continue|continue;
block|}
comment|/* 		**  If this is the first "real" character we have seen, 		**  then we put the "$g" in the buffer now. 		*/
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|gotaddr
condition|)
block|{
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"$g"
argument_list|)
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
name|gotaddr
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* 	**  If there is a tag at the end, insert it. 	*/
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rhs
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rhs
operator|=
literal|'>'
expr_stmt|;
name|strcpy
argument_list|(
name|bp
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|33
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"crackaddr=>%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

