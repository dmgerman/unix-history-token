begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)parseaddr.c	3.18	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  PARSE -- Parse an address ** **	Parses an address and breaks it up into three parts: a **	net to transmit the message on, the host to transmit it **	to, and a user on that host.  These are loaded into an **	ADDRESS header with the values squirreled away if necessary. **	The "user" part may not be a real user; the process may **	just reoccur on that machine.  For example, on a machine **	with an arpanet connection, the address **		csvax.bill@berkeley **	will break up to a "user" of 'csvax.bill' and a host **	of 'berkeley' -- to be transmitted over the arpanet. ** **	Parameters: **		addr -- the address to parse. **		a -- a pointer to the address descriptor buffer. **			If NULL, a header will be created. **		copyf -- determines what shall be copied: **			-1 -- don't copy anything.  The printname **				(q_paddr) is just addr, and the **				user& host are allocated internally **				to parse. **			0 -- copy out the parsed user& host, but **				don't copy the printname. **			+1 -- copy everything. ** **	Returns: **		A pointer to the address descriptor header (`a' if **			`a' is non-NULL). **		NULL on error. ** **	Side Effects: **		none ** **	Called By: **		main **		sendto **		alias **		savemail */
end_comment

begin_define
define|#
directive|define
name|DELIMCHARS
value|"$()<>,;\\\"\r\n"
end_define

begin_comment
comment|/* word delimiters */
end_comment

begin_define
define|#
directive|define
name|SPACESUB
value|('.'|0200)
end_define

begin_comment
comment|/* substitution for<lwsp> */
end_comment

begin_function
name|ADDRESS
modifier|*
name|parse
parameter_list|(
name|addr
parameter_list|,
name|a
parameter_list|,
name|copyf
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|copyf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|()
function_decl|;
comment|/* 	**  Initialize and prescan address. 	*/
name|To
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n--parse(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|pvp
operator|=
name|prescan
argument_list|(
name|addr
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	**  Apply rewriting rules. 	*/
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**  See if we resolved to a real mailer. 	*/
if|if
condition|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
name|CANONNET
condition|)
block|{
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"cannot resolve name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Build canonical address from pvp. 	*/
name|a
operator|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|m
operator|=
name|Mailer
index|[
name|a
operator|->
name|q_mailer
index|]
expr_stmt|;
comment|/* 	**  Make local copies of the host& user and then 	**  transport them out. 	*/
if|if
condition|(
name|copyf
operator|>
literal|0
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|newstr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|q_paddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|copyf
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_host
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_host
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|q_host
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do UPPER->lower case mapping unless inhibited. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_HST_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_USR_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
comment|/* 	**  Compute return value. 	*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"parse(\"%s\"): host \"%s\" user \"%s\" mailer %d\n"
argument_list|,
name|addr
argument_list|,
name|a
operator|->
name|q_host
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|a
operator|->
name|q_mailer
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRESCAN -- Prescan name and make it canonical ** **	Scans a name and turns it into canonical form.  This involves **	deleting blanks, comments (in parentheses), and turning the **	word "at" into an at-sign ("@").  The name is copied as this **	is done; it is legal to copy a name onto itself, since this **	process can only make things smaller. ** **	This routine knows about quoted strings and angle brackets. ** **	There are certain subtleties to this routine.  The one that **	comes to mind now is that backslashes on the ends of names **	are silently stripped off; this is intentional.  The problem **	is that some versions of sndmsg (like at LBL) set the kill **	character to something other than @ when reading addresses; **	so people type "csvax.eric\@berkeley" -- which screws up the **	berknet mailer. ** **	Parameters: **		addr -- the name to chomp. **		delim -- the delimiter for the address, normally **			'\0' or ','; \0 is accepted in any case. **			are moving in place; set buflim to high core. ** **	Returns: **		A pointer to a vector of tokens. **		NULL on error. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|OPER
value|1
end_define

begin_define
define|#
directive|define
name|ATOM
value|2
end_define

begin_define
define|#
directive|define
name|EOTOK
value|3
end_define

begin_define
define|#
directive|define
name|QSTRING
value|4
end_define

begin_define
define|#
directive|define
name|SPACE
value|5
end_define

begin_define
define|#
directive|define
name|DOLLAR
value|6
end_define

begin_define
define|#
directive|define
name|GETONE
value|7
end_define

begin_function
name|char
modifier|*
modifier|*
name|prescan
parameter_list|(
name|addr
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|delim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
operator|+
name|MAXATOM
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|av
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
name|bool
name|space
decl_stmt|;
name|bool
name|bslashmode
decl_stmt|;
name|int
name|cmntcnt
decl_stmt|;
name|int
name|brccnt
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
name|int
name|nstate
decl_stmt|;
specifier|extern
name|char
name|lower
parameter_list|()
function_decl|;
name|space
operator|=
name|FALSE
expr_stmt|;
name|q
operator|=
name|buf
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
name|cmntcnt
operator|=
name|brccnt
operator|=
literal|0
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
name|state
operator|=
name|OPER
expr_stmt|;
for|for
control|(
name|p
operator|=
name|addr
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|delim
condition|;
control|)
block|{
comment|/* read a token */
name|tok
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|delim
condition|)
block|{
comment|/* chew up special characters */
name|c
operator|&=
operator|~
literal|0200
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bslashmode
condition|)
block|{
name|c
operator||=
literal|0200
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|bslashmode
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|QSTRING
condition|)
name|state
operator|=
name|OPER
expr_stmt|;
else|else
name|state
operator|=
name|QSTRING
expr_stmt|;
break|break;
block|}
name|nstate
operator|=
name|toktype
argument_list|(
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QSTRING
case|:
comment|/* in quoted string */
break|break;
case|case
name|ATOM
case|:
comment|/* regular atom */
name|state
operator|=
name|nstate
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|ATOM
condition|)
block|{
name|state
operator|=
name|EOTOK
expr_stmt|;
name|p
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|GETONE
case|:
comment|/* grab one character */
name|state
operator|=
name|OPER
expr_stmt|;
break|break;
case|case
name|EOTOK
case|:
comment|/* after atom or q-string */
name|state
operator|=
name|nstate
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SPACE
condition|)
continue|continue;
break|break;
case|case
name|SPACE
case|:
comment|/* linear white space */
name|state
operator|=
name|nstate
expr_stmt|;
name|space
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
name|OPER
case|:
comment|/* operator */
if|if
condition|(
name|nstate
operator|==
name|SPACE
condition|)
continue|continue;
name|state
operator|=
name|nstate
expr_stmt|;
break|break;
case|case
name|DOLLAR
case|:
comment|/* $- etc. */
name|state
operator|=
name|OPER
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* literal $ */
break|break;
case|case
literal|'+'
case|:
comment|/* match anything */
name|c
operator|=
name|MATCHANY
expr_stmt|;
name|state
operator|=
name|GETONE
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* match one token */
name|c
operator|=
name|MATCHONE
expr_stmt|;
name|state
operator|=
name|GETONE
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* match one token of class */
name|c
operator|=
name|MATCHCLASS
expr_stmt|;
name|state
operator|=
name|GETONE
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* canonical net name */
name|c
operator|=
name|CANONNET
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* canonical host name */
name|c
operator|=
name|CANONHOST
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* canonical user name */
name|c
operator|=
name|CANONUSER
expr_stmt|;
break|break;
default|default:
name|c
operator|=
literal|'$'
expr_stmt|;
name|state
operator|=
name|OPER
expr_stmt|;
name|p
operator|--
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|syserr
argument_list|(
literal|"prescan: unknown state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|OPER
condition|)
name|space
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|EOTOK
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
name|delim
operator|==
literal|'\t'
condition|)
block|{
name|state
operator|=
name|DOLLAR
expr_stmt|;
continue|continue;
block|}
comment|/* squirrel it away */
if|if
condition|(
name|q
operator|>=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|5
index|]
condition|)
block|{
name|usrerr
argument_list|(
literal|"Address too long"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|space
condition|)
operator|*
name|q
operator|++
operator|=
name|SPACESUB
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
comment|/* decide whether this represents end of token */
if|if
condition|(
name|state
operator|==
name|OPER
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|||
name|c
operator|==
name|delim
condition|)
name|p
operator|--
expr_stmt|;
comment|/* new token */
if|if
condition|(
name|tok
operator|==
name|q
condition|)
continue|continue;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|=
name|tok
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|cmntcnt
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced ')'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|cmntcnt
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
continue|continue;
operator|*
name|avp
operator|++
operator|=
name|tok
expr_stmt|;
comment|/* we prefer<> specs */
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|brccnt
operator|<
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"multiple< spec"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|brccnt
operator|++
expr_stmt|;
name|space
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|brccnt
operator|==
literal|1
condition|)
block|{
comment|/* we prefer using machine readable name */
name|q
operator|=
name|buf
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|brccnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced `>'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
name|brccnt
operator|--
expr_stmt|;
if|if
condition|(
name|brccnt
operator|<=
literal|0
condition|)
block|{
name|brccnt
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		**  Turn "at" into "@", 		**	but only if "at" is a word. 		*/
if|if
condition|(
name|lower
argument_list|(
name|tok
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'a'
operator|&&
name|lower
argument_list|(
name|tok
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'t'
operator|&&
name|tok
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|tok
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|tok
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '('"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|brccnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '<'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|QSTRING
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '\"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|av
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TOKTYPE -- return token type ** **	Parameters: **		c -- the character in question. ** **	Returns: **		Its type. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|toktype
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|bool
name|firstime
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|firstime
condition|)
block|{
name|firstime
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|expand
argument_list|(
literal|"$o"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|DELIMCHARS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|ATOM
operator|)
return|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|SPACE
operator|)
return|;
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
operator|||
name|index
argument_list|(
name|buf
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|OPER
operator|)
return|;
return|return
operator|(
name|ATOM
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  REWRITE -- apply rewrite rules to token vector. ** **	Parameters: **		pvp -- pointer to token vector. ** **	Returns: **		none. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_struct
struct|struct
name|match
block|{
name|char
modifier|*
modifier|*
name|firsttok
decl_stmt|;
comment|/* first token matched */
name|char
modifier|*
modifier|*
name|lasttok
decl_stmt|;
comment|/* last token matched */
name|char
name|name
decl_stmt|;
comment|/* name of parameter */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXMATCH
value|8
end_define

begin_comment
comment|/* max params per rewrite */
end_comment

begin_macro
name|rewrite
argument_list|(
argument|pvp
argument_list|,
argument|ruleset
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ruleset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* address pointer */
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* rewrite pointer */
specifier|register
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
comment|/* address vector pointer */
specifier|register
name|char
modifier|*
modifier|*
name|rvp
decl_stmt|;
comment|/* rewrite vector pointer */
name|struct
name|rewrite
modifier|*
name|rwr
decl_stmt|;
name|struct
name|match
name|mlist
index|[
name|MAXMATCH
index|]
decl_stmt|;
name|char
modifier|*
name|npvp
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
comment|/* temporary space for rebuild */
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"rewrite: original pvp:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Run through the list of rewrite rules, applying 	**	any that match. 	*/
for|for
control|(
name|rwr
operator|=
name|RewriteRules
index|[
name|ruleset
index|]
init|;
name|rwr
operator|!=
name|NULL
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"-----trying rule:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rwr
operator|->
name|r_lhs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* try to match on this rule */
name|clrmatch
argument_list|(
name|mlist
argument_list|)
expr_stmt|;
for|for
control|(
name|rvp
operator|=
name|rwr
operator|->
name|r_lhs
operator|,
name|avp
operator|=
name|pvp
init|;
operator|*
name|avp
operator|!=
name|NULL
condition|;
control|)
block|{
name|ap
operator|=
operator|*
name|avp
expr_stmt|;
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
comment|/* end-of-pattern before end-of-address */
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
operator|*
name|rp
condition|)
block|{
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|class
decl_stmt|;
case|case
name|MATCHONE
case|:
comment|/* match exactly one token */
name|setmatch
argument_list|(
name|mlist
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|,
name|avp
argument_list|,
name|avp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCHANY
case|:
comment|/* match any number of tokens */
name|setmatch
argument_list|(
name|mlist
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|avp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MATCHCLASS
case|:
comment|/* match any token in a class */
name|class
operator|=
name|rp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|class
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|isupper
argument_list|(
name|class
argument_list|)
condition|)
name|class
operator|-=
literal|'A'
expr_stmt|;
else|else
name|class
operator|-=
literal|'a'
expr_stmt|;
name|s
operator|=
name|stab
argument_list|(
name|ap
argument_list|,
name|ST_CLASS
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
name|s
operator|->
name|s_class
operator|&
operator|(
literal|1
operator|<<
name|class
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
break|break;
default|default:
comment|/* must have exact match */
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|rp
argument_list|,
name|ap
argument_list|)
condition|)
goto|goto
name|fail
goto|;
break|break;
block|}
comment|/* successful match on this token */
name|avp
operator|++
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
continue|continue;
name|fail
label|:
comment|/* match failed -- back up */
while|while
condition|(
operator|--
name|rvp
operator|>=
name|rwr
operator|->
name|r_lhs
condition|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHANY
condition|)
break|break;
comment|/* can't extend match: back up everything */
name|avp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHONE
condition|)
block|{
comment|/* undo binding */
name|setmatch
argument_list|(
name|mlist
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rvp
operator|<
name|rwr
operator|->
name|r_lhs
condition|)
block|{
comment|/* total failure to match */
break|break;
block|}
block|}
comment|/* 		**  See if we successfully matched 		*/
if|if
condition|(
name|rvp
operator|>=
name|rwr
operator|->
name|r_lhs
operator|&&
operator|*
name|rvp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"-----rule matches:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rwr
operator|->
name|r_rhs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* substitute */
for|for
control|(
name|rvp
operator|=
name|rwr
operator|->
name|r_rhs
operator|,
name|avp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHANY
condition|)
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|extern
name|struct
name|match
modifier|*
name|findmatch
parameter_list|()
function_decl|;
name|m
operator|=
name|findmatch
argument_list|(
name|mlist
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|pp
operator|=
name|m
operator|->
name|firsttok
expr_stmt|;
do|do
block|{
operator|*
name|avp
operator|++
operator|=
operator|*
name|pp
expr_stmt|;
block|}
do|while
condition|(
name|pp
operator|++
operator|!=
name|m
operator|->
name|lasttok
condition|)
do|;
block|}
block|}
else|else
operator|*
name|avp
operator|++
operator|=
name|rp
expr_stmt|;
block|}
operator|*
name|avp
operator|++
operator|=
name|NULL
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|npvp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pvp
argument_list|,
operator|(
name|avp
operator|-
name|npvp
operator|)
operator|*
sizeof|sizeof
expr|*
name|avp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|char
modifier|*
modifier|*
name|vp
decl_stmt|;
name|printf
argument_list|(
literal|"rewritten as `"
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|pvp
init|;
operator|*
name|vp
operator|!=
name|NULL
condition|;
name|vp
operator|++
control|)
name|xputs
argument_list|(
operator|*
name|vp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
name|CANONNET
condition|)
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|10
condition|)
name|printf
argument_list|(
literal|"----- rule fails\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SETMATCH -- set parameter value in match vector ** **	Parameters: **		mlist -- list of match values. **		name -- the character name of this parameter. **		first -- the first location of the replacement. **		last -- the last location of the replacement. ** **		If last == NULL, delete this entry. **		If first == NULL, extend this entry (or add it if **			it does not exist). ** **	Returns: **		nothing. ** **	Side Effects: **		munges with mlist. */
end_comment

begin_macro
name|setmatch
argument_list|(
argument|mlist
argument_list|,
argument|name
argument_list|,
argument|first
argument_list|,
argument|last
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|match
modifier|*
name|mlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
name|struct
name|match
modifier|*
name|nullm
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|m
operator|=
name|mlist
init|;
name|m
operator|<
operator|&
name|mlist
index|[
name|MAXMATCH
index|]
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|name
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|name
operator|==
literal|'\0'
condition|)
name|nullm
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|>=
operator|&
name|mlist
index|[
name|MAXMATCH
index|]
condition|)
name|m
operator|=
name|nullm
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|name
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|->
name|name
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|m
operator|->
name|firsttok
operator|=
name|last
expr_stmt|;
else|else
name|m
operator|->
name|firsttok
operator|=
name|first
expr_stmt|;
block|}
name|m
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|m
operator|->
name|lasttok
operator|=
name|last
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FINDMATCH -- find match in mlist ** **	Parameters: **		mlist -- list to search. **		name -- name to find. ** **	Returns: **		pointer to match structure. **		NULL if no match. ** **	Side Effects: **		none. */
end_comment

begin_function
name|struct
name|match
modifier|*
name|findmatch
parameter_list|(
name|mlist
parameter_list|,
name|name
parameter_list|)
name|struct
name|match
modifier|*
name|mlist
decl_stmt|;
name|char
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|mlist
init|;
name|m
operator|<
operator|&
name|mlist
index|[
name|MAXMATCH
index|]
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|m
operator|->
name|name
operator|==
name|name
condition|)
return|return
operator|(
name|m
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CLRMATCH -- clear match list ** **	Parameters: **		mlist -- list to clear. ** **	Returns: **		none. ** **	Side Effects: **		mlist is cleared. */
end_comment

begin_macro
name|clrmatch
argument_list|(
argument|mlist
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|match
modifier|*
name|mlist
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|mlist
init|;
name|m
operator|<
operator|&
name|mlist
index|[
name|MAXMATCH
index|]
condition|;
name|m
operator|++
control|)
name|m
operator|->
name|name
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUILDADDR -- build address from token vector. ** **	Parameters: **		tv -- token vector. **		a -- pointer to address descriptor to fill. **			If NULL, one will be allocated. ** **	Returns: **		'a' ** **	Side Effects: **		fills in 'a' */
end_comment

begin_function
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|(
name|tv
parameter_list|,
name|a
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|tv
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|struct
name|mailer
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|q_home
operator|=
name|NULL
expr_stmt|;
comment|/* figure out what net/mailer to use */
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONNET
condition|)
name|syserr
argument_list|(
literal|"buildaddr: no net"
argument_list|)
expr_stmt|;
name|tv
operator|++
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|Mailer
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|++
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
operator|*
name|tv
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"buildaddr: unknown net %s"
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_mailer
operator|=
name|i
expr_stmt|;
comment|/* figure out what host (if any) */
name|tv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_NOHOST
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONHOST
condition|)
name|syserr
argument_list|(
literal|"buildaddr: no host"
argument_list|)
expr_stmt|;
name|tv
operator|++
expr_stmt|;
name|a
operator|->
name|q_host
operator|=
operator|*
name|tv
expr_stmt|;
name|tv
operator|++
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
comment|/* figure out the user */
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
condition|)
name|syserr
argument_list|(
literal|"buildaddr: no user"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|*
operator|++
name|tv
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SAMEADDR -- Determine if two addresses are the same ** **	This is not just a straight comparison -- if the mailer doesn't **	care about the host we just ignore it, etc. ** **	Parameters: **		a, b -- pointers to the internal forms to compare. **		wildflg -- if TRUE, 'a' may have no user specified, **			in which case it is to match anything. ** **	Returns: **		TRUE -- they represent the same mailbox. **		FALSE -- they don't. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|sameaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|wildflg
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|b
decl_stmt|;
name|bool
name|wildflg
decl_stmt|;
block|{
comment|/* if they don't have the same mailer, forget it */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|b
operator|->
name|q_mailer
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the user isn't the same, we can drop out */
if|if
condition|(
operator|(
operator|!
name|wildflg
operator|||
name|a
operator|->
name|q_user
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|b
operator|->
name|q_user
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the mailer ignores hosts, we have succeeded! */
if|if
condition|(
name|bitset
argument_list|(
name|M_NOHOST
argument_list|,
name|Mailer
index|[
name|a
operator|->
name|q_mailer
index|]
operator|->
name|m_flags
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* otherwise compare hosts (but be careful for NULL ptrs) */
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
operator|||
name|b
operator|->
name|q_host
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_host
argument_list|,
name|b
operator|->
name|q_host
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTADDR -- print address (for debugging) ** **	Parameters: **		a -- the address to print **		follow -- follow the q_next chain. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|printaddr
argument_list|(
name|a
argument_list|,
name|follow
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"addr@%x: "
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: mailer %d (%s), host `%s', user `%s'\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|,
name|a
operator|->
name|q_mailer
argument_list|,
name|Mailer
index|[
name|a
operator|->
name|q_mailer
index|]
operator|->
name|m_name
argument_list|,
name|a
operator|->
name|q_host
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnext=%x flags=%o, rmailer %d\n"
argument_list|,
name|a
operator|->
name|q_next
argument_list|,
name|a
operator|->
name|q_flags
argument_list|,
name|a
operator|->
name|q_rmailer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|follow
condition|)
return|return;
name|a
operator|=
name|a
operator|->
name|q_next
expr_stmt|;
block|}
block|}
end_block

end_unit

