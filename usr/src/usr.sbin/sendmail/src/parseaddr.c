begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)parseaddr.c	8.44 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CC_WONT_PROMOTE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|toktype
name|__P
argument_list|(
operator|(
name|char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !CC_WONT_PROMOTE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|toktype
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* char -> int */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CC_WONT_PROMOTE */
end_comment

begin_decl_stmt
specifier|static
name|void
name|_rewrite
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|callsubr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ADDRESS
modifier|*
name|buildaddr
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|ADDRESS
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uurelativize
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|DelimChar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to point to the delimiter */
end_comment

begin_comment
comment|/* **  PARSEADDR -- Parse an address ** **	Parses an address and breaks it up into three parts: a **	net to transmit the message on, the host to transmit it **	to, and a user on that host.  These are loaded into an **	ADDRESS header with the values squirreled away if necessary. **	The "user" part may not be a real user; the process may **	just reoccur on that machine.  For example, on a machine **	with an arpanet connection, the address **		csvax.bill@berkeley **	will break up to a "user" of 'csvax.bill' and a host **	of 'berkeley' -- to be transmitted over the arpanet. ** **	Parameters: **		addr -- the address to parse. **		a -- a pointer to the address descriptor buffer. **			If NULL, a header will be created. **		flags -- describe detail for parsing.  See RF_ definitions **			in sendmail.h. **		delim -- the character to terminate the address, passed **			to prescan. **		delimptr -- if non-NULL, set to the location of the **			delim character that was found. **		e -- the envelope that will contain this address. ** **	Returns: **		A pointer to the address descriptor header (`a' if **			`a' is non-NULL). **		NULL on error. ** **	Side Effects: **		none */
end_comment

begin_comment
comment|/* following delimiters are inherent to the internal algorithms */
end_comment

begin_define
define|#
directive|define
name|DELIMCHARS
value|"()<>,;\r\n"
end_define

begin_comment
comment|/* default word delimiters */
end_comment

begin_function
name|ADDRESS
modifier|*
name|parseaddr
parameter_list|(
name|addr
parameter_list|,
name|a
parameter_list|,
name|flags
parameter_list|,
name|delim
parameter_list|,
name|delimptr
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|delim
decl_stmt|;
name|char
modifier|*
modifier|*
name|delimptr
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|auto
name|char
modifier|*
name|delimptrbuf
decl_stmt|;
name|bool
name|queueup
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
comment|/* 	**  Initialize and prescan address. 	*/
name|e
operator|->
name|e_to
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n--parseaddr(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
comment|/* parseaddr.c */
name|char
name|savec
decl_stmt|;
name|bool
name|invalid
decl_stmt|;
specifier|extern
name|char
modifier|*
name|finddelim
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|invalidaddr
parameter_list|()
function_decl|;
name|DelimChar
operator|=
name|finddelim
argument_list|(
name|addr
argument_list|,
name|delim
argument_list|)
expr_stmt|;
name|savec
operator|=
operator|*
name|DelimChar
expr_stmt|;
operator|*
name|DelimChar
operator|=
literal|'\0'
expr_stmt|;
name|invalid
operator|=
name|invalidaddr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|*
name|DelimChar
operator|=
name|savec
expr_stmt|;
if|if
condition|(
name|invalid
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|delimptr
operator|==
name|NULL
condition|)
name|delimptr
operator|=
operator|&
name|delimptrbuf
expr_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
name|addr
argument_list|,
name|delim
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"parseaddr-->NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|invalidaddr
argument_list|(
name|addr
argument_list|,
name|delim
operator|==
literal|'\0'
condition|?
name|NULL
else|:
operator|*
name|delimptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"parseaddr-->bad address\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	**  Save addr if we are going to have to. 	** 	**	We have to do this early because there is a chance that 	**	the map lookups in the rewriting rules could clobber 	**	static memory somewhere. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RF_COPYPADDR
argument_list|,
name|flags
argument_list|)
operator|&&
name|addr
operator|!=
name|NULL
condition|)
block|{
name|char
name|savec
init|=
operator|*
operator|*
name|delimptr
decl_stmt|;
if|if
condition|(
name|savec
operator|!=
literal|'\0'
condition|)
operator|*
operator|*
name|delimptr
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|addr
operator|=
name|newstr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|savec
operator|!=
literal|'\0'
condition|)
operator|*
operator|*
name|delimptr
operator|=
name|savec
expr_stmt|;
block|}
comment|/* 	**  Apply rewriting rules. 	**	Ruleset 0 does basic parsing.  It must resolve. 	*/
name|queueup
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
name|queueup
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
name|queueup
operator|=
name|TRUE
expr_stmt|;
comment|/* 	**  Build canonical address from pvp. 	*/
name|a
operator|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|a
argument_list|,
name|flags
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  Make local copies of the host& user and then 	**  transport them out. 	*/
name|allocaddr
argument_list|(
name|a
argument_list|,
name|flags
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
return|return
name|a
return|;
comment|/* 	**  If there was a parsing failure, mark it for queueing. 	*/
if|if
condition|(
name|queueup
condition|)
block|{
name|char
modifier|*
name|msg
init|=
literal|"Transient parse error -- message queued for future delivery"
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"parseaddr: queuing message\n"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_message
operator|=
name|newstr
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
block|}
comment|/* 	**  Compute return value. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"parseaddr-->"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INVALIDADDR -- check for address containing meta-characters ** **	Parameters: **		addr -- the address to check. ** **	Returns: **		TRUE -- if the address has any "wierd" characters **		FALSE -- otherwise. */
end_comment

begin_function
name|bool
name|invalidaddr
parameter_list|(
name|addr
parameter_list|,
name|delimptr
parameter_list|)
specifier|register
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|delimptr
decl_stmt|;
block|{
name|char
name|savedelim
decl_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
condition|)
block|{
name|savedelim
operator|=
operator|*
name|delimptr
expr_stmt|;
if|if
condition|(
name|savedelim
operator|!=
literal|'\0'
condition|)
operator|*
name|delimptr
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* for testing.... */
block|if (strcmp(addr, "INvalidADDR") == 0) 	{ 		usrerr("553 INvalid ADDRess"); 		goto addrfailure; 	}
endif|#
directive|endif
for|for
control|(
init|;
operator|*
name|addr
operator|!=
literal|'\0'
condition|;
name|addr
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
literal|0340
operator|)
operator|==
literal|0200
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|addr
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|savedelim
operator|!=
literal|'\0'
operator|&&
name|delimptr
operator|!=
name|NULL
condition|)
operator|*
name|delimptr
operator|=
name|savedelim
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"553 Address contained invalid control characters"
argument_list|)
expr_stmt|;
name|addrfailure
label|:
if|if
condition|(
name|savedelim
operator|!=
literal|'\0'
operator|&&
name|delimptr
operator|!=
name|NULL
condition|)
operator|*
name|delimptr
operator|=
name|savedelim
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ALLOCADDR -- do local allocations of address on demand. ** **	Also lowercases the host name if requested. ** **	Parameters: **		a -- the address to reallocate. **		flags -- the copy flag (see RF_ definitions in sendmail.h **			for a description). **		paddr -- the printname of the address. ** **	Returns: **		none. ** **	Side Effects: **		Copies portions of a into local buffers as requested. */
end_comment

begin_expr_stmt
name|allocaddr
argument_list|(
name|a
argument_list|,
name|flags
argument_list|,
name|paddr
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|paddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|24
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"allocaddr(flags=%x, paddr=%s)\n"
argument_list|,
name|flags
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_paddr
operator|=
name|paddr
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_user
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_host
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RF_COPYPARSE
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_host
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|q_paddr
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_paddr
operator|=
name|a
operator|->
name|q_user
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INVALIDADDR -- check an address string for invalid control characters. ** **	Parameters: **		addr -- address string to be checked. ** **	Returns: **		TRUE if address string could cause problems, FALSE o/w. ** **	Side Effects: **		ExitStat may be changed and an error message generated. */
end_comment

begin_function
name|bool
name|invalidaddr
parameter_list|(
name|addr
parameter_list|)
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* make sure error messages don't have garbage on them */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 	** Sendmail reserves characters 020 - 036 for rewriting rules 	** which can cause havoc (e.g. infinite rewriting loops) if 	** one shows up at the wrong time.  If any of these characters 	** appear in an address, the address is deemed "invalid" and 	** an error message is generated. 	*/
for|for
control|(
name|cp
operator|=
name|addr
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|cp
operator|>=
name|MATCHZANY
operator|&&
operator|*
name|cp
operator|<=
name|HOSTEND
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'\001'
condition|)
block|{
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"address contained invalid control char(s)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRESCAN -- Prescan name and make it canonical ** **	Scans a name and turns it into a set of tokens.  This process **	deletes blanks and comments (in parentheses). ** **	This routine knows about quoted strings and angle brackets. ** **	There are certain subtleties to this routine.  The one that **	comes to mind now is that backslashes on the ends of names **	are silently stripped off; this is intentional.  The problem **	is that some versions of sndmsg (like at LBL) set the kill **	character to something other than @ when reading addresses; **	so people type "csvax.eric\@berkeley" -- which screws up the **	berknet mailer. ** **	Parameters: **		addr -- the name to chomp. **		delim -- the delimiter for the address, normally **			'\0' or ','; \0 is accepted in any case. **			If '\t' then we are reading the .cf file. **		pvpbuf -- place to put the saved text -- note that **			the pointers are static. **		pvpbsize -- size of pvpbuf. **		delimptr -- if non-NULL, set to the location of the **			terminating delimiter. ** **	Returns: **		A pointer to a vector of tokens. **		NULL on error. */
end_comment

begin_comment
comment|/* states and character types */
end_comment

begin_define
define|#
directive|define
name|OPR
value|0
end_define

begin_comment
comment|/* operator */
end_comment

begin_define
define|#
directive|define
name|ATM
value|1
end_define

begin_comment
comment|/* atom */
end_comment

begin_define
define|#
directive|define
name|QST
value|2
end_define

begin_comment
comment|/* in quoted string */
end_comment

begin_define
define|#
directive|define
name|SPC
value|3
end_define

begin_comment
comment|/* chewing up spaces */
end_comment

begin_define
define|#
directive|define
name|ONE
value|4
end_define

begin_comment
comment|/* pick up one character */
end_comment

begin_define
define|#
directive|define
name|NSTATES
value|5
end_define

begin_comment
comment|/* number of states */
end_comment

begin_define
define|#
directive|define
name|TYPE
value|017
end_define

begin_comment
comment|/* mask to select state type */
end_comment

begin_comment
comment|/* meta bits for table */
end_comment

begin_define
define|#
directive|define
name|M
value|020
end_define

begin_comment
comment|/* meta character; don't pass through */
end_comment

begin_define
define|#
directive|define
name|B
value|040
end_define

begin_comment
comment|/* cause a break */
end_comment

begin_define
define|#
directive|define
name|MB
value|M|B
end_define

begin_comment
comment|/* meta-break */
end_comment

begin_decl_stmt
specifier|static
name|short
name|StateTab
index|[
name|NSTATES
index|]
index|[
name|NSTATES
index|]
init|=
block|{
comment|/*	oldst	chtype>	OPR	ATM	QST	SPC	ONE	*/
comment|/*OPR*/
name|OPR
operator||
name|B
block|,
name|ATM
operator||
name|B
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
comment|/*ATM*/
name|OPR
operator||
name|B
block|,
name|ATM
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
comment|/*QST*/
name|QST
block|,
name|QST
block|,
name|OPR
block|,
name|QST
block|,
name|QST
block|,
comment|/*SPC*/
name|OPR
block|,
name|ATM
block|,
name|QST
block|,
name|SPC
operator||
name|M
block|,
name|ONE
block|,
comment|/*ONE*/
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* token type table -- it gets modified with $o characters */
end_comment

begin_expr_stmt
specifier|static
name|TokTypeTab
index|[
literal|256
index|]
operator|=
block|{
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|SPC
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|ATM
block|,
name|QST
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|SPC
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|OPR
block|,
name|OPR
block|,
name|ONE
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|ONE
block|,
name|ONE
block|,
name|ONE
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|,
name|ATM
block|, }
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|toktype
parameter_list|(
name|c
parameter_list|)
value|((int) TokTypeTab[(c)& 0xff])
end_define

begin_define
define|#
directive|define
name|NOCHAR
value|-1
end_define

begin_comment
comment|/* signal nothing in lookahead token */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|prescan
parameter_list|(
name|addr
parameter_list|,
name|delim
parameter_list|,
name|pvpbuf
parameter_list|,
name|pvpbsize
parameter_list|,
name|delimptr
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
name|pvpbuf
index|[]
decl_stmt|;
name|char
modifier|*
modifier|*
name|delimptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
name|bool
name|bslashmode
decl_stmt|;
name|int
name|cmntcnt
decl_stmt|;
name|int
name|anglecnt
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|newstate
decl_stmt|;
name|char
modifier|*
name|saveto
init|=
name|CurEnv
operator|->
name|e_to
decl_stmt|;
specifier|static
name|char
modifier|*
name|av
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|firsttime
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|firsttime
condition|)
block|{
comment|/* initialize the token type table */
name|char
name|obuf
index|[
literal|50
index|]
decl_stmt|;
name|firsttime
operator|=
name|FALSE
expr_stmt|;
name|expand
argument_list|(
literal|"\201o"
argument_list|,
name|obuf
argument_list|,
operator|&
name|obuf
index|[
sizeof|sizeof
name|obuf
operator|-
sizeof|sizeof
name|DELIMCHARS
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|obuf
argument_list|,
name|DELIMCHARS
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|obuf
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|TokTypeTab
index|[
operator|*
name|p
operator|&
literal|0xff
index|]
operator|==
name|ATM
condition|)
name|TokTypeTab
index|[
operator|*
name|p
operator|&
literal|0xff
index|]
operator|=
name|OPR
expr_stmt|;
block|}
block|}
comment|/* make sure error messages don't have garbage on them */
name|errno
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|pvpbuf
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
name|cmntcnt
operator|=
literal|0
expr_stmt|;
name|anglecnt
operator|=
literal|0
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
name|state
operator|=
name|ATM
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
name|p
operator|=
name|addr
expr_stmt|;
name|CurEnv
operator|->
name|e_to
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"prescan: "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* read a token */
name|tok
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* store away any old lookahead character */
if|if
condition|(
name|c
operator|!=
name|NOCHAR
operator|&&
operator|!
name|bslashmode
condition|)
block|{
comment|/* see if there is room */
if|if
condition|(
name|q
operator|>=
operator|&
name|pvpbuf
index|[
name|pvpbsize
operator|-
literal|5
index|]
condition|)
block|{
name|usrerr
argument_list|(
literal|"553 Address too long"
argument_list|)
expr_stmt|;
name|returnnull
label|:
if|if
condition|(
name|delimptr
operator|!=
name|NULL
condition|)
operator|*
name|delimptr
operator|=
name|p
expr_stmt|;
name|CurEnv
operator|->
name|e_to
operator|=
name|saveto
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* squirrel it away */
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* read a new input character */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* diagnose and patch up bad syntax */
if|if
condition|(
name|state
operator|==
name|QST
condition|)
block|{
name|usrerr
argument_list|(
literal|"653 Unbalanced '\"'"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'"'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"653 Unbalanced '('"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|anglecnt
operator|>
literal|0
condition|)
block|{
name|c
operator|=
literal|'>'
expr_stmt|;
name|usrerr
argument_list|(
literal|"653 Unbalanced '<'"
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|p
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
name|anglecnt
operator|<=
literal|0
operator|&&
name|cmntcnt
operator|<=
literal|0
operator|&&
name|state
operator|!=
name|QST
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|101
argument_list|)
condition|)
name|printf
argument_list|(
literal|"c=%c, s=%d; "
argument_list|,
name|c
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* chew up special characters */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bslashmode
condition|)
block|{
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
comment|/* kludge \! for naive users */
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|NOCHAR
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'!'
operator|||
name|state
operator|==
name|QST
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|bslashmode
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|QST
condition|)
block|{
comment|/* do nothing, just avoid next clauses */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|cmntcnt
operator|++
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"653 Unbalanced ')'"
argument_list|)
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
else|else
name|cmntcnt
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
name|c
operator|=
name|NOCHAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
name|anglecnt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|anglecnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"653 Unbalanced '>'"
argument_list|)
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
else|else
name|anglecnt
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delim
operator|==
literal|' '
operator|&&
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|!
name|CurEnv
operator|->
name|e_oldstyle
condition|)
block|{
comment|/* consume characters until a semicolon */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced ':...;' group spec"
argument_list|)
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
comment|/* semicolons are not tokens */
name|c
operator|=
name|NOCHAR
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NOCHAR
condition|)
continue|continue;
comment|/* see if this is end of input */
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
name|anglecnt
operator|<=
literal|0
operator|&&
name|state
operator|!=
name|QST
condition|)
break|break;
name|newstate
operator|=
name|StateTab
index|[
name|state
index|]
index|[
name|toktype
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|101
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ns=%02o\n"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
name|state
operator|=
name|newstate
operator|&
name|TYPE
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|M
argument_list|,
name|newstate
argument_list|)
condition|)
name|c
operator|=
name|NOCHAR
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|B
argument_list|,
name|newstate
argument_list|)
condition|)
break|break;
block|}
comment|/* new token */
if|if
condition|(
name|tok
operator|!=
name|q
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|36
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tok="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|tok
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|avp
operator|>=
operator|&
name|av
index|[
name|MAXATOM
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"553 prescan: too many tokens"
argument_list|)
expr_stmt|;
goto|goto
name|returnnull
goto|;
block|}
if|if
condition|(
name|q
operator|-
name|tok
operator|>
name|MAXNAME
condition|)
block|{
name|syserr
argument_list|(
literal|"553 prescan: token too long"
argument_list|)
expr_stmt|;
goto|goto
name|returnnull
goto|;
block|}
operator|*
name|avp
operator|++
operator|=
name|tok
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|!=
name|delim
operator|||
name|anglecnt
operator|>
literal|0
operator|)
condition|)
do|;
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|delimptr
operator|!=
name|NULL
condition|)
operator|*
name|delimptr
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"prescan==>"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|av
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|saveto
expr_stmt|;
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"prescan: null leading token\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|av
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  REWRITE -- apply rewrite rules to token vector. ** **	This routine is an ordered production system.  Each rewrite **	rule has a LHS (called the pattern) and a RHS (called the **	rewrite); 'rwr' points the the current rewrite rule. ** **	For each rewrite rule, 'avp' points the address vector we **	are trying to match against, and 'pvp' points to the pattern. **	If pvp points to a special match value (MATCHZANY, MATCHANY, **	MATCHONE, MATCHCLASS, MATCHNCLASS) then the address in avp **	matched is saved away in the match vector (pointed to by 'mvp'). ** **	When a match between avp& pvp does not match, we try to **	back out.  If we back up over MATCHONE, MATCHCLASS, or MATCHNCLASS **	we must also back out the match in mvp.  If we reach a **	MATCHANY or MATCHZANY we just extend the match and start **	over again. ** **	When we finally match, we rewrite the address vector **	and try over again. ** **	Parameters: **		pvp -- pointer to token vector. **		ruleset -- the ruleset to use for rewriting. **		reclevel -- recursion level (to catch loops). **		e -- the current envelope. ** **	Returns: **		A status code.  If EX_TEMPFAIL, higher level code should **			attempt recovery. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_define
define|#
directive|define
name|OP_NONZLEN
value|00001
end_define

begin_define
define|#
directive|define
name|OP_VARLEN
value|00002
end_define

begin_define
define|#
directive|define
name|OP_CLASS
value|00004
end_define

begin_define
define|#
directive|define
name|OP_EXACT
value|00010
end_define

begin_struct
struct|struct
name|match
block|{
name|char
modifier|*
modifier|*
name|first
decl_stmt|;
comment|/* first token matched */
name|char
modifier|*
modifier|*
name|last
decl_stmt|;
comment|/* last token matched */
name|char
modifier|*
modifier|*
name|pattern
decl_stmt|;
comment|/* pointer to pattern */
name|char
modifier|*
modifier|*
name|source
decl_stmt|;
comment|/* left hand source operand */
name|char
name|flags
decl_stmt|;
comment|/* attributes of this operator */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXMATCH
value|9
end_define

begin_comment
comment|/* max params per rewrite */
end_comment

begin_define
define|#
directive|define
name|MAX_CONTROL
value|' '
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAXRULERECURSION
end_ifndef

begin_define
define|#
directive|define
name|MAXRULERECURSION
value|50
end_define

begin_comment
comment|/* max recursion depth */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|control_opts
index|[
name|MAX_CONTROL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
specifier|static
name|char
name|control_init_data
index|[]
init|=
block|{
name|MATCHZANY
block|,
name|OP_VARLEN
block|,
name|MATCHONE
block|,
name|OP_NONZLEN
block|,
name|MATCHANY
block|,
name|OP_VARLEN
operator||
name|OP_NONZLEN
block|,
ifdef|#
directive|ifdef
name|MACVALUE
name|MACVALUE
block|,
name|OP_EXACT
block|,
endif|#
directive|endif
comment|/* MACVALUE */
name|MATCHNCLASS
block|,
name|OP_NONZLEN
block|,
name|MATCHCLASS
block|,
name|OP_NONZLEN
operator||
name|OP_VARLEN
operator||
name|OP_CLASS
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nrw
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rewrite
parameter_list|(
name|pvp
parameter_list|,
name|ruleset
parameter_list|,
name|reclevel
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|int
name|ruleset
decl_stmt|;
name|int
name|reclevel
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|nrw
operator|=
literal|0
expr_stmt|;
name|_rewrite
argument_list|(
name|pvp
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rewrite
parameter_list|(
name|pvp
parameter_list|,
name|ruleset
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|int
name|ruleset
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* address pointer */
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* rewrite pointer */
specifier|register
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
comment|/* address vector pointer */
specifier|register
name|char
modifier|*
modifier|*
name|rvp
decl_stmt|;
comment|/* rewrite vector pointer */
specifier|register
name|struct
name|match
modifier|*
name|mlp
decl_stmt|;
comment|/* cur ptr into mlist */
specifier|register
name|struct
name|rewrite
modifier|*
name|rwr
decl_stmt|;
comment|/* pointer to current rewrite rule */
name|int
name|ruleno
decl_stmt|;
comment|/* current rule number */
name|int
name|rstat
init|=
name|EX_OK
decl_stmt|;
comment|/* return status */
name|int
name|loopcount
decl_stmt|;
name|int
name|subr
decl_stmt|;
comment|/* subroutine number if>= 0 */
name|bool
name|dolookup
decl_stmt|;
comment|/* do host aliasing */
name|char
modifier|*
name|npvp
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
comment|/* temporary space for rebuild */
name|char
name|tokbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* for concatenated class tokens */
name|int
name|nloops
decl_stmt|,
name|nmatches
init|=
literal|0
decl_stmt|;
comment|/* for looping rule checks */
name|struct
name|rewrite
modifier|*
name|prev_rwr
decl_stmt|;
comment|/* pointer to previous rewrite rule */
name|struct
name|match
name|mlist
index|[
name|MAXMATCH
operator|+
literal|1
index|]
decl_stmt|;
comment|/* stores match on LHS */
name|struct
name|match
modifier|*
name|old_mlp
decl_stmt|;
comment|/* to save our place */
name|bool
name|extend_match
decl_stmt|;
comment|/* extend existing match during backup */
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
operator|||
name|tTd
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rewrite: ruleset %2d   input:"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
name|printcav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ruleset
operator|<
literal|0
operator|||
name|ruleset
operator|>=
name|MAXRWSETS
condition|)
block|{
name|syserr
argument_list|(
literal|"554 rewrite: illegal ruleset number %d"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
if|if
condition|(
name|reclevel
operator|++
operator|>
name|MAXRULERECURSION
condition|)
block|{
name|syserr
argument_list|(
literal|"rewrite: infinite recursion, ruleset %d"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
name|EX_USAGE
return|;
if|if
condition|(
operator|++
name|nrw
operator|>
literal|100
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|buf
index|[
name|MAXLINE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pvp
condition|)
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|buf
argument_list|,
operator|*
name|pvp
operator|++
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|syserr
argument_list|(
literal|"address causes rewrite loop:<%s>"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Be sure to recognize first rule as new */
name|prev_rwr
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Run through the list of rewrite rules, applying any that match. 	*/
name|ruleno
operator|=
literal|1
expr_stmt|;
name|loopcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|rwr
operator|=
name|RewriteRules
index|[
name|ruleset
index|]
init|;
name|rwr
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"-----trying rule:"
argument_list|)
expr_stmt|;
name|printcav
argument_list|(
name|rwr
operator|->
name|r_lhs
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Set up the match list.  This is done once for each 		**  rule.  If a rule is used repeatedly, the list need not 		**  be set up the next time. 		*/
if|if
condition|(
name|rwr
operator|!=
name|prev_rwr
condition|)
block|{
name|prev_rwr
operator|=
name|rwr
expr_stmt|;
for|for
control|(
name|rvp
operator|=
name|rwr
operator|->
name|r_lhs
operator|,
name|mlp
operator|=
name|mlist
init|;
operator|*
name|rvp
operator|&&
operator|(
name|mlp
operator|<
operator|&
name|mlist
index|[
name|MAXMATCH
index|]
operator|)
condition|;
name|rvp
operator|++
control|)
block|{
name|mlp
operator|->
name|flags
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|rvp
operator|>=
name|MAX_CONTROL
operator|)
condition|?
literal|0
else|:
name|control_opts
index|[
operator|*
operator|*
name|rvp
index|]
expr_stmt|;
if|if
condition|(
name|mlp
operator|->
name|flags
condition|)
block|{
name|mlp
operator|->
name|source
operator|=
name|rvp
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|rvp
condition|)
block|{
name|syserr
argument_list|(
literal|"Too many variables on LHS in ruleset %d"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
return|return;
block|}
name|mlp
operator|->
name|source
operator|=
name|rvp
expr_stmt|;
comment|/* Make sure end marker is initialized */
name|mlp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* try to match on this rule */
name|mlp
operator|=
name|mlist
expr_stmt|;
name|rvp
operator|=
name|rwr
operator|->
name|r_lhs
expr_stmt|;
name|avp
operator|=
name|pvp
expr_stmt|;
name|nloops
operator|=
literal|0
expr_stmt|;
name|extend_match
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|++
name|loopcount
operator|>
literal|100
condition|)
block|{
if|if
condition|(
name|nloops
operator|++
operator|>
literal|400
condition|)
block|{
name|syserr
argument_list|(
literal|"Looping on ruleset %d, rule %d"
argument_list|,
name|ruleset
argument_list|,
name|rwr
operator|-
name|RewriteRules
index|[
name|ruleset
index|]
argument_list|)
expr_stmt|;
name|mlp
operator|=
name|mlist
operator|-
literal|1
expr_stmt|;
comment|/* force rule failure */
break|break;
block|}
name|syserr
argument_list|(
literal|"554 Infinite loop in ruleset %d, rule %d"
argument_list|,
name|ruleset
argument_list|,
name|ruleno
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"workspace: "
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
while|while
condition|(
operator|(
name|ap
operator|=
operator|*
name|avp
operator|)
operator|!=
name|NULL
operator|||
operator|*
name|rvp
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|35
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ADVANCE rp="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", ap="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extend_match
condition|)
name|extend_match
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|mlp
operator|->
name|first
operator|=
name|avp
expr_stmt|;
name|mlp
operator|->
name|last
operator|=
name|mlp
operator|->
name|flags
operator|==
literal|0
operator|||
operator|(
name|mlp
operator|->
name|flags
operator|&
name|OP_NONZLEN
operator|)
condition|?
name|avp
operator|+
literal|1
else|:
name|avp
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
comment|/* end-of-pattern before end-of-address */
goto|goto
name|backup
goto|;
comment|/* Premature end of address */
if|if
condition|(
name|ap
operator|==
name|NULL
operator|&&
name|avp
operator|!=
name|mlp
operator|->
name|last
condition|)
goto|goto
name|backup
goto|;
comment|/* 			**  Simplest case - exact token comparison between 			**  pattern and address.  Such a match is not saved 			**  in mlp. 			*/
if|if
condition|(
name|rvp
operator|<
name|mlp
operator|->
name|source
condition|)
block|{
if|if
condition|(
name|ap
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|ap
argument_list|,
name|rp
argument_list|)
condition|)
goto|goto
name|backup
goto|;
name|rvp
operator|++
expr_stmt|;
name|avp
operator|++
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|MACVALUE
comment|/* 			**  This is special case handled.  The match is exact, 			**  but might span zero or more address tokens.  The 			**  result is saved in mlp. 			*/
if|if
condition|(
operator|*
name|rp
operator|==
name|MACVALUE
condition|)
block|{
name|int
name|len
decl_stmt|;
name|rp
operator|=
name|macvalue
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
condition|)
while|while
condition|(
operator|*
name|rp
condition|)
block|{
if|if
condition|(
operator|*
name|avp
operator|==
name|NULL
operator|||
name|strncasecmp
argument_list|(
name|rp
argument_list|,
operator|*
name|avp
argument_list|,
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|avp
argument_list|)
argument_list|)
condition|)
goto|goto
name|backup
goto|;
name|rp
operator|+=
name|len
expr_stmt|;
name|avp
operator|++
expr_stmt|;
block|}
name|mlp
operator|->
name|last
operator|=
name|avp
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* MACVALUE */
comment|/* 			**  All other matches are saved in mlp.  Initially 			**  assume they match at the shortest possible length 			**  for this pattern.  Variable patterns will be 			**  extended later as needed. 			*/
comment|/* Fixed length first */
if|if
condition|(
operator|!
operator|(
name|mlp
operator|->
name|flags
operator|&
name|OP_VARLEN
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|rp
condition|)
block|{
break|break;
block|}
name|avp
operator|=
name|mlp
operator|->
name|last
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
case|case
name|MATCHZERO
case|:
comment|/* match zero tokens */
continue|continue;
block|}
case|case
name|MACRODEXPAND
case|:
comment|/* 				**  Match against run-time macro. 				**  This algorithm is broken for the 				**  general case (no recursive macros, 				**  improper tokenization) but should 				**  work for the usual cases. 				*/
name|ap
operator|=
name|macvalue
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|mlp
operator|->
name|first
operator|=
name|avp
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"rewrite: LHS $&%c => \"%s\"\n"
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|,
name|ap
operator|==
name|NULL
condition|?
literal|"(NULL)"
else|:
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
break|break;
while|while
condition|(
operator|*
name|ap
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|avp
operator|==
name|NULL
operator|||
name|strncasecmp
argument_list|(
name|ap
argument_list|,
operator|*
name|avp
argument_list|,
name|strlen
argument_list|(
operator|*
name|avp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* no match */
name|avp
operator|=
name|mlp
operator|->
name|first
expr_stmt|;
goto|goto
name|backup
goto|;
block|}
name|ap
operator|+=
name|strlen
argument_list|(
operator|*
name|avp
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* match */
break|break;
comment|/* 			**  We now have a variable length item.  It could 			**  be $+ or $* in which case no special checking 			**  is needed.  But a class match such as $=x must 			**  be verified. 			** 			**  As a speedup, if a variable length item is 			**  followed by a plain character token, we initially 			**  extend the match to the first such token we find. 			**  If the required character token cannot be found, 			**  we fail the match at this point. 			*/
name|avp
operator|=
name|mlp
operator|->
name|last
expr_stmt|;
comment|/* If next token is char token */
if|if
condition|(
operator|&
name|rvp
index|[
literal|1
index|]
operator|<
name|mlp
index|[
literal|1
index|]
operator|.
name|source
condition|)
block|{
while|while
condition|(
operator|*
name|avp
operator|&&
name|strcasecmp
argument_list|(
operator|*
name|avp
argument_list|,
name|rvp
index|[
literal|1
index|]
argument_list|)
condition|)
name|avp
operator|++
expr_stmt|;
comment|/* 				**  If we can't find the proper ending token, 				**  leave avp point to NULL.  This indicates 				**  we have run out of address tokens.  It is 				**  pointless to advance the beginning of this 				**  match and retry. 				*/
if|if
condition|(
operator|*
name|avp
operator|==
name|NULL
condition|)
goto|goto
name|backup
goto|;
name|mlp
operator|->
name|last
operator|=
name|avp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rvp
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
comment|/* next token is end of address */
block|{
while|while
condition|(
operator|*
name|avp
condition|)
name|avp
operator|++
expr_stmt|;
name|mlp
operator|->
name|last
operator|=
name|avp
expr_stmt|;
block|}
if|if
condition|(
name|mlp
operator|->
name|flags
operator|&
name|OP_CLASS
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|tokbuf
decl_stmt|;
name|avp
operator|=
name|mlp
operator|->
name|first
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|avp
argument_list|)
expr_stmt|;
name|avp
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|avp
operator|<
name|mlp
operator|->
name|last
condition|)
block|{
while|while
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|avp
argument_list|)
expr_stmt|;
name|avp
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|rp
condition|)
block|{
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
case|case
name|MATCHCLASS
case|:
name|s
operator|=
name|stab
argument_list|(
name|tokbuf
argument_list|,
name|ST_CLASS
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|s
operator|->
name|s_class
argument_list|)
condition|)
goto|goto
name|have_match
goto|;
break|break;
block|}
comment|/* 					**  Class match initially failed. 					**  Extend the tentative match. 					**  Again, if followed by a character 					**  token, extend all the way to that 					**  token before checking. 					*/
if|if
condition|(
operator|*
name|avp
condition|)
block|{
operator|(
name|mlp
operator|->
name|last
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|&
name|rvp
index|[
literal|1
index|]
operator|<
name|mlp
index|[
literal|1
index|]
operator|.
name|source
condition|)
block|{
while|while
condition|(
operator|*
operator|(
name|mlp
operator|->
name|last
operator|)
operator|&&
name|strcasecmp
argument_list|(
operator|*
operator|(
name|mlp
operator|->
name|last
operator|)
argument_list|,
name|rvp
index|[
literal|1
index|]
argument_list|)
condition|)
operator|(
name|mlp
operator|->
name|last
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|mlp
operator|->
name|last
operator|)
operator|==
name|NULL
condition|)
name|avp
operator|=
name|mlp
operator|->
name|last
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|avp
operator|==
name|NULL
condition|)
block|{
comment|/* 						**  We could not find the 						**  ending token.  But we had 						**  found ending tokens before. 						**  A match is still plausible 						**  if the start of the 						**  tentative match is advanced. 						**  Hence we must not leave avp 						**  pointing to NULL. 						*/
name|avp
operator|=
name|mlp
operator|->
name|first
expr_stmt|;
goto|goto
name|backup
goto|;
block|}
block|}
block|}
name|have_match
label|:
name|rvp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
continue|continue;
name|backup
label|:
comment|/* We failed to match.  mlp marks point of failure */
comment|/* 			**  There is a special case when we have exhausted 			**  the address, but have not exhausted the pattern. 			**  Under normal circumstances we could consider the 			**  failure permanent, since extending the number of 			**  address tokens matched by a '$+' or a '$*' will 			**  only worsen the situation. 			** 			**  There is an exception, however.  It is possible 			**  that we have matched a class token, say '$=x', 			**  with three or more tokens.  Extending a '$+' say, 			**  which precedes the '$=x' will move the beginning 			**  of the '$=x' match to the right, but it might match 			**  a smaller number of tokens then, possibly 			**  correcting the mismatch. 			** 			**  Thus in this case we initially back up to the 			**  $=x which matches three or more tokens. 			*/
if|if
condition|(
operator|*
name|avp
operator|==
name|NULL
condition|)
block|{
name|rvp
operator|=
name|mlp
operator|->
name|pattern
expr_stmt|;
while|while
condition|(
operator|--
name|mlp
operator|>
name|mlist
condition|)
block|{
if|if
condition|(
operator|(
name|mlp
operator|->
name|flags
operator|&
name|OP_CLASS
operator|)
operator|&&
name|mlp
operator|->
name|last
operator|>
literal|2
operator|+
name|mlp
operator|->
name|first
condition|)
break|break;
block|}
block|}
comment|/* 			**  Now backup till we find a match with a pattern 			**  whose length is extendable, and extend that. 			*/
name|mlp
operator|--
expr_stmt|;
while|while
condition|(
name|mlp
operator|>=
name|mlist
operator|&&
operator|!
operator|(
name|mlp
operator|->
name|flags
operator|&
name|OP_VARLEN
operator|)
condition|)
name|mlp
operator|--
expr_stmt|;
comment|/* Total failure to match */
if|if
condition|(
name|mlp
operator|<
name|mlist
condition|)
break|break;
name|avp
operator|=
operator|++
operator|(
name|mlp
operator|->
name|last
operator|)
expr_stmt|;
name|rvp
operator|=
name|mlp
operator|->
name|source
expr_stmt|;
comment|/* 			**  We have found a backup point.  Normally we would 			**  increase the matched amount by one token, and 			**  continue from the next item in the pattern.  But 			**  there are two special cases.  If this is a 			**  class-type match (OP_CLASS), we must test the 			**  validity of the extended match.  If this pattern 			**  item is directly followed by a character token, it 			**  is worth going back and locating the next such 			**  character token before we continue on. 			*/
if|if
condition|(
operator|(
name|mlp
operator|->
name|flags
operator|&
name|OP_CLASS
operator|)
operator|||
operator|(
operator|&
name|rvp
index|[
literal|1
index|]
operator|<
name|mlp
index|[
literal|1
index|]
operator|.
name|source
operator|)
condition|)
block|{
name|avp
operator|=
name|mlp
operator|->
name|first
expr_stmt|;
name|extend_match
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|mlp
operator|++
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		**  See if we successfully matched. 		*/
if|if
condition|(
name|mlp
operator|<
name|mlist
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"----- rule fails\n"
argument_list|)
expr_stmt|;
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
name|ruleno
operator|++
expr_stmt|;
name|loopcount
operator|=
literal|0
expr_stmt|;
name|nmatches
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nmatches
operator|++
operator|>
literal|200
condition|)
block|{
name|syserr
argument_list|(
literal|"Loop in ruleset %d, rule %d (too many matches)"
argument_list|,
name|ruleset
argument_list|,
name|rwr
operator|-
name|RewriteRules
index|[
name|ruleset
index|]
argument_list|)
expr_stmt|;
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
name|nmatches
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|rvp
operator|=
name|rwr
operator|->
name|r_rhs
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"-----rule matches:"
argument_list|)
expr_stmt|;
name|printcav
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
block|}
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|CANONUSER
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
name|ruleno
operator|++
expr_stmt|;
name|loopcount
operator|=
literal|0
expr_stmt|;
name|nmatches
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|CANONHOST
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
name|rwr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|rp
operator|&
literal|0377
operator|)
operator|==
name|CANONNET
condition|)
name|rwr
operator|=
name|NULL
expr_stmt|;
comment|/* substitute */
name|dolookup
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|avp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
comment|/* check to see if we should do a lookup */
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHLOOKUP
condition|)
name|dolookup
operator|=
name|TRUE
expr_stmt|;
comment|/* see if there is substitution here */
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHREPL
operator|&&
name|rp
index|[
literal|1
index|]
operator|>=
literal|'1'
operator|&&
name|rp
index|[
literal|1
index|]
operator|<=
literal|'9'
condition|)
block|{
comment|/* substitute from LHS */
name|m
operator|=
operator|&
name|mlist
index|[
name|rp
index|[
literal|1
index|]
operator|-
literal|'1'
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|<
name|mlist
operator|||
name|m
operator|>=
name|mlp
condition|)
block|{
name|toolong
label|:
name|syserr
argument_list|(
literal|"rewrite: ruleset %d: replacement #%c out of bounds"
argument_list|,
name|ruleset
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|EX_CONFIG
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"$%c:"
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pp
operator|=
name|m
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|pp
operator|<
name|m
operator|->
name|last
condition|)
block|{
name|printf
argument_list|(
literal|" %x=\""
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\""
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|pp
operator|=
name|m
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|pp
operator|<
name|m
operator|->
name|last
condition|)
block|{
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
operator|*
name|avp
operator|++
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* vanilla replacement */
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
ifdef|#
directive|ifdef
name|MACVALUE
if|if
condition|(
operator|*
name|rp
operator|==
name|MACVALUE
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|macvalue
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"expanding runtime macro '%c' to \"%s\"\n"
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|,
name|p
condition|?
name|p
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|avp
operator|++
operator|=
name|p
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* MACVALUE */
operator|*
name|avp
operator|++
operator|=
name|rp
expr_stmt|;
block|}
block|}
operator|*
name|avp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Check for any hostname/keyword lookups. 		*/
for|for
control|(
name|rvp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|hbrvp
decl_stmt|,
modifier|*
modifier|*
name|ubrvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|xpvp
decl_stmt|;
name|int
name|trsize
decl_stmt|;
name|char
modifier|*
name|replac
decl_stmt|;
name|int
name|endtoken
decl_stmt|;
name|STAB
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|mapname
decl_stmt|;
name|char
modifier|*
modifier|*
name|key_rvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|arg_rvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|default_rvp
decl_stmt|;
name|char
name|hbuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|,
name|ubuf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|pvpb1
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|argvect
index|[
literal|10
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|nullpvp
index|[
literal|1
index|]
decl_stmt|;
name|bool
name|match
decl_stmt|,
name|defaultpart
decl_stmt|;
name|char
name|begintype
decl_stmt|;
name|char
name|db
init|=
literal|'\0'
decl_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|!=
name|HOSTBEGIN
operator|&&
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|!=
name|LOOKUPBEGIN
condition|)
continue|continue;
comment|/* 			**  Got a hostname/keyword lookup. 			** 			**	This could be optimized fairly easily. 			*/
name|begintype
operator|=
operator|*
operator|*
name|rvp
expr_stmt|;
name|hbrvp
operator|=
name|rvp
expr_stmt|;
name|ubrvp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|==
name|HOSTBEGIN
condition|)
block|{
name|endtoken
operator|=
name|HOSTEND
expr_stmt|;
name|mapname
operator|=
literal|"host"
expr_stmt|;
block|}
else|else
block|{
name|endtoken
operator|=
name|LOOKUPEND
expr_stmt|;
name|mapname
operator|=
operator|*
operator|++
name|rvp
expr_stmt|;
block|}
name|map
operator|=
name|stab
argument_list|(
name|mapname
argument_list|,
name|ST_MAP
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"554 rewrite: map %s not found"
argument_list|,
name|mapname
argument_list|)
expr_stmt|;
comment|/* extract the match part */
name|key_rvp
operator|=
operator|++
name|rvp
expr_stmt|;
name|default_rvp
operator|=
name|NULL
expr_stmt|;
name|arg_rvp
operator|=
name|argvect
expr_stmt|;
name|xpvp
operator|=
name|NULL
expr_stmt|;
name|replac
operator|=
name|pvpbuf
expr_stmt|;
while|while
condition|(
operator|*
name|rvp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
operator|*
name|rvp
operator|&
literal|0377
operator|)
operator|!=
name|endtoken
condition|)
block|{
name|int
name|nodetype
init|=
operator|*
operator|*
name|rvp
operator|&
literal|0377
decl_stmt|;
if|if
condition|(
name|nodetype
operator|!=
name|CANONHOST
operator|&&
name|nodetype
operator|!=
name|CANONUSER
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|rvp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xpvp
operator|!=
name|NULL
condition|)
block|{
name|cataddr
argument_list|(
name|xpvp
argument_list|,
name|NULL
argument_list|,
name|replac
argument_list|,
operator|&
name|pvpbuf
index|[
sizeof|sizeof
name|pvpbuf
index|]
operator|-
name|replac
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
operator|++
name|arg_rvp
operator|=
name|replac
expr_stmt|;
name|replac
operator|+=
name|strlen
argument_list|(
name|replac
argument_list|)
operator|+
literal|1
expr_stmt|;
name|xpvp
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|nodetype
condition|)
block|{
case|case
name|CANONHOST
case|:
name|xpvp
operator|=
name|rvp
expr_stmt|;
break|break;
case|case
name|CANONUSER
case|:
name|default_rvp
operator|=
name|rvp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|rvp
operator|!=
name|NULL
condition|)
operator|*
name|rvp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xpvp
operator|!=
name|NULL
condition|)
block|{
name|cataddr
argument_list|(
name|xpvp
argument_list|,
name|NULL
argument_list|,
name|replac
argument_list|,
operator|&
name|pvpbuf
index|[
sizeof|sizeof
name|pvpbuf
index|]
operator|-
name|replac
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
operator|++
name|arg_rvp
operator|=
name|replac
expr_stmt|;
block|}
operator|*
operator|++
name|arg_rvp
operator|=
name|NULL
expr_stmt|;
comment|/* save the remainder of the input string */
name|trsize
operator|=
call|(
name|int
call|)
argument_list|(
name|avp
operator|-
name|rvp
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|rvp
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rvp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pvpb1
argument_list|,
name|trsize
argument_list|)
expr_stmt|;
comment|/* append it to the token list */
for|for
control|(
name|avp
operator|=
name|hbrvp
init|;
operator|*
name|xpvp
operator|!=
name|NULL
condition|;
name|xpvp
operator|++
control|)
block|{
operator|*
name|avp
operator|++
operator|=
name|newstr
argument_list|(
operator|*
name|xpvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
block|}
block|}
else|else
name|avp
operator|=
name|hbrvp
expr_stmt|;
comment|/* restore the old trailing information */
name|rvp
operator|=
name|avp
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|xpvp
operator|=
name|pvpb1
init|;
operator|*
name|xpvp
operator|!=
name|NULL
condition|;
name|xpvp
operator|++
control|)
block|{
if|if
condition|(
name|defaultpart
operator|&&
operator|*
operator|*
name|xpvp
operator|==
name|HOSTEND
condition|)
block|{
name|defaultpart
operator|=
name|FALSE
expr_stmt|;
name|rvp
operator|=
name|avp
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|defaultpart
operator|||
operator|!
name|match
condition|)
operator|*
name|avp
operator|++
operator|=
operator|*
name|xpvp
expr_stmt|;
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
block|}
operator|*
name|avp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/*break;*/
block|}
comment|/* 		**  Check for subroutine calls. 		**  Then copy vector back into original space. 		*/
name|callsubr
argument_list|(
name|npvp
argument_list|)
expr_stmt|;
for|for
control|(
name|avp
operator|=
name|npvp
init|;
operator|*
name|avp
operator|++
operator|!=
name|NULL
condition|;
control|)
empty_stmt|;
name|subr
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|rvp
argument_list|)
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
else|else
name|subr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		**  Copy result back to original string. 		*/
for|for
control|(
name|avp
operator|=
name|pvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
operator|*
name|avp
operator|++
operator|=
operator|*
name|rvp
expr_stmt|;
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  If this specified a subroutine, call it. 		*/
if|if
condition|(
name|subr
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"-----callsubr %s\n"
argument_list|,
name|subr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|subr
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Done with rewriting this pass. 		*/
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rewritten as:"
argument_list|)
expr_stmt|;
name|printcav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
operator|||
name|tTd
argument_list|(
literal|21
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rewrite: ruleset %2d returns:"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
name|printcav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|rstat
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  CALLSUBR -- call subroutines in rewrite vector ** **	Parameters: **		pvp -- pointer to token vector. ** **	Returns: **		none. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_function
unit|static
name|void
name|callsubr
parameter_list|(
name|pvp
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|rvp
decl_stmt|;
name|int
name|subr
decl_stmt|;
for|for
control|(
init|;
operator|*
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|pvp
operator|==
name|CALLSUBR
operator|&&
name|pvp
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|isdigit
argument_list|(
name|pvp
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|subr
operator|=
name|atoi
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"-----callsubr %d\n"
argument_list|,
name|subr
argument_list|)
expr_stmt|;
comment|/* 			**  Take care of possible inner calls. 			*/
name|callsubr
argument_list|(
name|pvp
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* 			**  Move vector up over calling opcode. 			*/
for|for
control|(
name|rvp
operator|=
name|pvp
operator|+
literal|2
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
name|rvp
index|[
operator|-
literal|2
index|]
operator|=
name|rvp
index|[
literal|0
index|]
expr_stmt|;
name|rvp
index|[
operator|-
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 			**  Call inferior ruleset. 			*/
name|_rewrite
argument_list|(
name|pvp
argument_list|,
name|subr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  BUILDADDR -- build address from token vector. ** **	Parameters: **		tv -- token vector. **		a -- pointer to address descriptor to fill. **			If NULL, one will be allocated. **		flags -- info regarding whether this is a sender or **			a recipient. **		e -- the current envelope. ** **	Returns: **		NULL if there was an error. **		'a' otherwise. ** **	Side Effects: **		fills in 'a' */
end_comment

begin_struct
struct|struct
name|errcodes
block|{
name|char
modifier|*
name|ec_name
decl_stmt|;
comment|/* name of error code */
name|int
name|ec_code
decl_stmt|;
comment|/* numeric code */
block|}
name|ErrorCodes
index|[]
init|=
block|{
literal|"usage"
block|,
name|EX_USAGE
block|,
literal|"nouser"
block|,
name|EX_NOUSER
block|,
literal|"nohost"
block|,
name|EX_NOHOST
block|,
literal|"unavailable"
block|,
name|EX_UNAVAILABLE
block|,
literal|"software"
block|,
name|EX_SOFTWARE
block|,
literal|"tempfail"
block|,
name|EX_TEMPFAIL
block|,
literal|"protocol"
block|,
name|EX_PROTOCOL
block|,
ifdef|#
directive|ifdef
name|EX_CONFIG
literal|"config"
block|,
name|EX_CONFIG
block|,
endif|#
directive|endif
name|NULL
block|,
name|EX_UNAVAILABLE
block|, }
struct|;
end_struct

begin_function
specifier|static
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|(
name|tv
parameter_list|,
name|a
parameter_list|,
name|flags
parameter_list|,
name|e
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|tv
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|mailer
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|spaceleft
decl_stmt|;
specifier|static
name|MAILER
name|errormailer
decl_stmt|;
specifier|static
name|char
modifier|*
name|errorargv
index|[]
init|=
block|{
literal|"ERROR"
block|,
name|NULL
block|}
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|24
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"buildaddr, flags=%x, tv="
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|tv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
comment|/* set up default error return flags */
name|a
operator|->
name|q_flags
operator||=
name|QPINGONFAILURE
operator||
name|QPINGONDELAY
expr_stmt|;
comment|/* figure out what net/mailer to use */
if|if
condition|(
operator|*
name|tv
operator|==
name|NULL
operator|||
operator|*
operator|*
name|tv
operator|!=
name|CANONNET
condition|)
block|{
name|syserr
argument_list|(
literal|"554 buildaddr: no net"
argument_list|)
expr_stmt|;
name|badaddr
label|:
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|a
operator|->
name|q_mailer
operator|=
operator|&
name|errormailer
expr_stmt|;
if|if
condition|(
name|errormailer
operator|.
name|m_name
operator|==
name|NULL
condition|)
block|{
comment|/* initialize the bogus mailer */
name|errormailer
operator|.
name|m_name
operator|=
literal|"*error*"
expr_stmt|;
name|errormailer
operator|.
name|m_mailer
operator|=
literal|"ERROR"
expr_stmt|;
name|errormailer
operator|.
name|m_argv
operator|=
name|errorargv
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
name|tv
operator|++
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|tv
argument_list|,
literal|"error"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
operator|++
name|tv
operator|&
literal|0377
operator|)
operator|==
name|CANONHOST
condition|)
block|{
specifier|register
name|struct
name|errcodes
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
operator|*
operator|++
name|tv
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
operator|*
name|tv
argument_list|)
condition|)
block|{
name|setstat
argument_list|(
name|atoi
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ep
operator|=
name|ErrorCodes
init|;
name|ep
operator|->
name|ec_name
operator|!=
name|NULL
condition|;
name|ep
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|ep
operator|->
name|ec_name
argument_list|,
operator|*
name|tv
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|setstat
argument_list|(
name|ep
operator|->
name|ec_code
argument_list|)
expr_stmt|;
block|}
name|tv
operator|++
expr_stmt|;
block|}
else|else
name|setstat
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
operator|(
operator|*
name|tv
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
operator|)
condition|;
name|tv
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
operator|*
name|tv
operator|&
literal|0377
operator|)
operator|!=
name|CANONUSER
condition|)
name|syserr
argument_list|(
literal|"554 buildaddr: error: no user"
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
operator|++
name|tv
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: Trace: $#ERROR $: %s"
argument_list|,
name|CurEnv
operator|->
name|e_id
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
if|if
condition|(
name|isascii
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isascii
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|&&
name|buf
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
block|{
name|char
name|fmt
index|[
literal|10
index|]
decl_stmt|;
name|strncpy
argument_list|(
name|fmt
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|fmt
index|[
literal|3
index|]
argument_list|,
literal|" %s"
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
name|fmt
argument_list|,
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* 			**  If this is a 4xx code and we aren't running 			**  SMTP on our input, bounce this message; 			**  otherwise it disappears without a trace. 			*/
if|if
condition|(
name|fmt
index|[
literal|0
index|]
operator|==
literal|'4'
operator|&&
name|OpMode
operator|!=
name|MD_SMTP
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_FATALERRS
expr_stmt|;
block|}
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"553 %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
goto|goto
name|badaddr
goto|;
block|}
for|for
control|(
name|mp
operator|=
name|Mailer
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
operator|*
name|tv
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"554 buildaddr: unknown mailer %s"
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
goto|goto
name|badaddr
goto|;
block|}
name|a
operator|->
name|q_mailer
operator|=
name|m
expr_stmt|;
comment|/* figure out what host (if any) */
if|if
condition|(
operator|*
operator|*
operator|++
name|tv
operator|!=
name|CANONHOST
condition|)
block|{
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
else|else
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|++
name|tv
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_host
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* figure out the user */
if|if
condition|(
operator|*
name|tv
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|*
name|tv
operator|&
literal|0377
operator|)
operator|!=
name|CANONUSER
condition|)
block|{
name|syserr
argument_list|(
literal|"554 buildaddr: no user"
argument_list|)
expr_stmt|;
goto|goto
name|badaddr
goto|;
block|}
name|tv
operator|++
expr_stmt|;
comment|/* do special mapping for local mailer */
if|if
condition|(
operator|*
name|tv
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|tv
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
operator|&&
name|bitnset
argument_list|(
name|M_CHECKPROG
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|ProgMailer
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
operator|&&
name|bitnset
argument_list|(
name|M_CHECKFILE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|FileMailer
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|&&
name|bitnset
argument_list|(
name|M_CHECKINCLUDE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
comment|/* may be :include: */
name|cataddr
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|buf
argument_list|,
literal|":include:"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if :include:, don't need further rewriting */
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|InclMailer
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
operator|&
name|buf
index|[
literal|9
index|]
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|bitnset
argument_list|(
name|M_CHECKUDB
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|*
name|tv
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|tv
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tv
operator|++
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QNOTREMOTE
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_r_rwset
operator|>
literal|0
condition|)
name|rewrite
argument_list|(
name|tv
argument_list|,
name|m
operator|->
name|m_r_rwset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rewrite
argument_list|(
name|tv
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* save the result for the command line/RCPT argument */
name|cataddr
argument_list|(
name|tv
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|buf
expr_stmt|;
comment|/* 	**  Do mapping to lower case as requested by mailer 	*/
if|if
condition|(
name|a
operator|->
name|q_host
operator|!=
name|NULL
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_HST_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_USR_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CATADDR -- concatenate pieces of addresses (putting in<LWSP> subs) ** **	Parameters: **		pvp -- parameter vector to rebuild. **		evp -- last parameter to include.  Can be NULL to **			use entire pvp. **		buf -- buffer to build the string into. **		sz -- size of buf. **		spacesub -- the space separator character; if null, **			use SpaceSub. ** **	Returns: **		none. ** **	Side Effects: **		Destroys buf. */
end_comment

begin_function
name|void
name|cataddr
parameter_list|(
name|pvp
parameter_list|,
name|evp
parameter_list|,
name|buf
parameter_list|,
name|sz
parameter_list|,
name|spacesub
parameter_list|)
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|evp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|sz
decl_stmt|;
name|char
name|spacesub
decl_stmt|;
block|{
name|bool
name|oatomtok
init|=
name|FALSE
decl_stmt|;
name|bool
name|natomtok
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|spacesub
operator|==
literal|'\0'
condition|)
name|spacesub
operator|=
name|SpaceSub
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|buf
expr_stmt|;
name|sz
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|*
name|pvp
argument_list|)
operator|)
operator|<
name|sz
condition|)
block|{
name|natomtok
operator|=
operator|(
name|toktype
argument_list|(
operator|*
operator|*
name|pvp
argument_list|)
operator|==
name|ATM
operator|)
expr_stmt|;
if|if
condition|(
name|oatomtok
operator|&&
name|natomtok
condition|)
operator|*
name|p
operator|++
operator|=
name|spacesub
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|pvp
argument_list|)
expr_stmt|;
name|oatomtok
operator|=
name|natomtok
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|sz
operator|-=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pvp
operator|++
operator|==
name|evp
condition|)
break|break;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SAMEADDR -- Determine if two addresses are the same ** **	This is not just a straight comparison -- if the mailer doesn't **	care about the host we just ignore it, etc. ** **	Parameters: **		a, b -- pointers to the internal forms to compare. ** **	Returns: **		TRUE -- they represent the same mailbox. **		FALSE -- they don't. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|sameaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|ca
decl_stmt|,
modifier|*
name|cb
decl_stmt|;
comment|/* if they don't have the same mailer, forget it */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|b
operator|->
name|q_mailer
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the user isn't the same, we can drop out */
if|if
condition|(
name|strcasecmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|b
operator|->
name|q_user
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if we have good uids for both but they differ, these are different */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|==
name|ProgMailer
condition|)
block|{
name|ca
operator|=
name|getctladdr
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|cb
operator|=
name|getctladdr
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|!=
name|NULL
operator|&&
name|cb
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|ca
operator|->
name|q_flags
operator|&
name|cb
operator|->
name|q_flags
argument_list|)
operator|&&
name|ca
operator|->
name|q_uid
operator|!=
name|cb
operator|->
name|q_uid
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* otherwise compare hosts (but be careful for NULL ptrs) */
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|b
operator|->
name|q_host
condition|)
block|{
comment|/* probably both null pointers */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
operator|||
name|b
operator|->
name|q_host
operator|==
name|NULL
condition|)
block|{
comment|/* only one is a null pointer */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|a
operator|->
name|q_host
argument_list|,
name|b
operator|->
name|q_host
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTADDR -- print address (for debugging) ** **	Parameters: **		a -- the address to print **		follow -- follow the q_next chain. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_function
name|void
name|printaddr
parameter_list|(
name|a
parameter_list|,
name|follow
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|bool
name|follow
decl_stmt|;
block|{
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
name|MAILER
name|pseudomailer
decl_stmt|;
specifier|static
name|int
name|indent
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x="
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* find the mailer -- carefully */
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
operator|&
name|pseudomailer
expr_stmt|;
name|m
operator|->
name|m_mno
operator|=
operator|-
literal|1
expr_stmt|;
name|m
operator|->
name|m_name
operator|=
literal|"NULL"
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|indent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnext=%x, flags=%o, rmailer %d, alias=%x, sibling=%x, child=%x\n"
argument_list|,
name|a
operator|->
name|q_next
argument_list|,
name|a
operator|->
name|q_flags
argument_list|,
name|a
operator|->
name|q_rmailer
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
name|a
operator|->
name|q_sibling
argument_list|,
name|a
operator|->
name|q_child
argument_list|)
expr_stmt|;
comment|/* follow the chain if appropriate */
if|if
condition|(
operator|!
name|follow
condition|)
return|return;
name|indent
operator|++
expr_stmt|;
name|printaddr
argument_list|(
name|a
operator|->
name|q_child
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|indent
operator|--
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|q_sibling
expr_stmt|;
block|}
if|if
condition|(
name|first
condition|)
name|printf
argument_list|(
literal|"[NULL]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  EMPTYADDR -- return TRUE if this address is empty (``<>'') ** **	Parameters: **		a -- pointer to the address ** **	Returns: **		TRUE -- if this address is "empty" (i.e., no one should **			ever generate replies to it. **		FALSE -- if it is a "regular" (read: replyable) address. */
end_comment

begin_function
name|bool
name|emptyaddr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|q_paddr
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|"<>"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  REMOTENAME -- return the name relative to the current mailer ** **	Parameters: **		name -- the name to translate. **		m -- the mailer that we want to do rewriting relative **			to. **		flags -- fine tune operations. **		pstat -- pointer to status word. **		e -- the current envelope. ** **	Returns: **		the text string representing this address relative to **			the receiving mailer. ** **	Side Effects: **		none. ** **	Warnings: **		The text string returned is tucked away locally; **			copy it if you intend to save it. */
end_comment

begin_function
name|char
modifier|*
name|remotename
parameter_list|(
name|name
parameter_list|,
name|m
parameter_list|,
name|flags
parameter_list|,
name|pstat
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|MAILER
modifier|*
name|m
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
modifier|*
name|pstat
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|fancy
decl_stmt|;
name|char
modifier|*
name|oldg
init|=
name|macvalue
argument_list|(
literal|'g'
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|int
name|rwset
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"remotename(%s)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* don't do anything if we are tagging it as special */
if|if
condition|(
operator|(
name|senderaddress
condition|?
name|m
operator|->
name|m_s_rwset
else|:
name|m
operator|->
name|m_r_rwset
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|name
operator|)
return|;
comment|/* 	**  Do a heuristic crack of this name to extract any comment info. 	**	This will leave the name as a comment and a $g macro. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|RF_CANONICAL
argument_list|,
name|flags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|M_NOCOMMENT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|fancy
operator|=
literal|"\201g"
expr_stmt|;
else|else
name|fancy
operator|=
name|crackaddr
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	**  Turn the name into canonical form. 	**	Normally this will be RFC 822 style, i.e., "user@domain". 	**	If this only resolves to "user", and the "C" flag is 	**	specified in the sending mailer, then the sender's 	**	domain will be appended. 	*/
name|pvp
operator|=
name|prescan
argument_list|(
name|name
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
if|if
condition|(
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|RF_ADDDOMAIN
argument_list|,
name|flags
argument_list|)
operator|&&
name|e
operator|->
name|e_fromdomain
operator|!=
name|NULL
condition|)
block|{
comment|/* append from domain to this address */
specifier|register
name|char
modifier|*
modifier|*
name|pxp
init|=
name|pvp
decl_stmt|;
comment|/* see if there is an "@domain" in the current name */
while|while
condition|(
operator|*
name|pxp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|pxp
argument_list|,
literal|"@"
argument_list|)
operator|!=
literal|0
condition|)
name|pxp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pxp
operator|==
name|NULL
condition|)
block|{
comment|/* no.... append the "@domain" from the sender */
specifier|register
name|char
modifier|*
modifier|*
name|qxq
init|=
name|e
operator|->
name|e_fromdomain
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|pxp
operator|++
operator|=
operator|*
name|qxq
operator|++
operator|)
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
block|}
comment|/* 	**  Do more specific rewriting. 	**	Rewrite using ruleset 1 or 2 for envelope addresses and 	**	5 or 6 for header addresses depending on whether this 	**	is a sender address or not. 	**	Then run it through any receiving-mailer-specific rulesets. 	*/
else|else
block|{
if|if
condition|(
name|rwset
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|rwset
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
block|}
comment|/* 	**  Do any final sanitation the address may require. 	**	This will normally be used to turn internal forms 	**	(e.g., user@host.LOCAL) into external form.  This 	**	may be used as a default to the above rules. 	*/
if|if
condition|(
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
operator|*
name|pstat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
comment|/* 	**  Now restore the comment information we had at the beginning. 	*/
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|NULL
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
name|lbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* need to make sure route-addrs have<angle brackets> */
if|if
condition|(
name|bitset
argument_list|(
name|RF_CANONICAL
argument_list|,
name|flags
argument_list|)
operator|&&
name|lbuf
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|expand
argument_list|(
literal|"<\201g>"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|expand
argument_list|(
name|fancy
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
name|oldg
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|12
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"remotename => `%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
comment|/* **  UURELATIVIZE -- Make an address !-relative to recipient/sender nodes ** **	Parameters: **		from -- the sending node (usually "$k" or "$w") **		to -- the receiving node (usually "$h") **		pvp -- address vector ** **	Returns: **		none. ** **	Side Effects: **		The pvp is rewritten to be relative the "to" node **		wrt the "from" node.  In other words, if the pvp **		is headed by "to!" that part is stripped; otherwise **		"from!" is prepended.  Exception: "to!user" addresses **		with no '!'s in the user part are sent as is. ** **	Bugs: **		The pvp may overflow, but we don't catch it. */
specifier|static
name|void
name|uurelativize
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|pvp
parameter_list|)
specifier|const
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pxp
init|=
name|pvp
decl_stmt|;
name|char
name|expfrom
index|[
name|MAXNAME
index|]
decl_stmt|,
name|expto
index|[
name|MAXNAME
index|]
decl_stmt|;
name|expand
argument_list|(
name|from
argument_list|,
name|expfrom
argument_list|,
operator|&
name|expfrom
index|[
sizeof|sizeof
name|expfrom
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|to
argument_list|,
name|expto
argument_list|,
operator|&
name|expto
index|[
sizeof|sizeof
name|expto
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* 	 * supposing that we've got something, should 	 * we add "from!" or remove "to!"? 	 */
if|if
condition|(
name|pvp
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pvp
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"!"
argument_list|)
operator|!=
literal|0
operator|||
comment|/*strcasecmp?*/
name|strcmp
argument_list|(
name|pvp
index|[
literal|0
index|]
argument_list|,
name|expto
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* either local name, no UUCP address, */
comment|/* or not to "to!" ==> prepend address with "from!" */
comment|/* already there? */
if|if
condition|(
name|pvp
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
literal|"!"
argument_list|)
operator|!=
literal|0
operator|||
comment|/*strcasecmp?*/
name|strcmp
argument_list|(
name|pvp
index|[
literal|0
index|]
argument_list|,
name|expfrom
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* no, put it there */
while|while
condition|(
operator|*
name|pxp
operator|!=
name|NULL
condition|)
name|pxp
operator|++
expr_stmt|;
do|do
name|pxp
index|[
literal|2
index|]
operator|=
operator|*
name|pxp
expr_stmt|;
do|while
condition|(
name|pxp
operator|--
operator|!=
name|pvp
condition|)
do|;
name|pvp
index|[
literal|0
index|]
operator|=
name|newstr
argument_list|(
name|expfrom
argument_list|)
expr_stmt|;
name|pvp
index|[
literal|1
index|]
operator|=
literal|"!"
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* address is to "to!" -- remove if not "to!user" */
for|for
control|(
name|pxp
operator|=
operator|&
name|pvp
index|[
literal|2
index|]
init|;
operator|*
name|pxp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|pxp
argument_list|,
literal|"!"
argument_list|)
operator|!=
literal|0
condition|;
name|pxp
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|pxp
operator|!=
name|NULL
condition|)
for|for
control|(
name|pxp
operator|=
name|pvp
init|;
operator|*
name|pxp
operator|!=
name|NULL
condition|;
name|pxp
operator|++
control|)
operator|*
name|pxp
operator|=
name|pxp
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* **  MAPLOCALUSER -- run local username through ruleset 5 for final redirection ** **	Parameters: **		a -- the address to map (but just the user name part). **		sendq -- the sendq in which to install any replacement **			addresses. **		aliaslevel -- the alias nesting depth. **		e -- the envelope. ** **	Returns: **		none. */
name|maplocaluser
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a1
init|=
name|NULL
decl_stmt|;
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"maplocaluser: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|pvp
operator|=
name|prescan
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|,
sizeof|sizeof
name|pvpbuf
argument_list|,
operator|&
name|delimptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
operator|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&
literal|0377
operator|)
operator|!=
name|CANONNET
condition|)
return|return;
comment|/* if non-null, mailer destination specified -- has it changed? */
name|a1
operator|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|==
name|NULL
operator|||
name|sameaddr
argument_list|(
name|a
argument_list|,
name|a1
argument_list|)
condition|)
return|return;
comment|/* mark old address as dead; insert new address */
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"maplocaluser: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|a1
operator|->
name|q_alias
operator|=
name|a
expr_stmt|;
name|allocaddr
argument_list|(
name|a1
argument_list|,
name|RF_COPYALL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|recipient
argument_list|(
name|a1
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* **  DEQUOTE_INIT -- initialize dequote map ** **	This is a no-op. ** **	Parameters: **		map -- the internal map structure. **		args -- arguments. ** **	Returns: **		TRUE. */
name|bool
name|dequote_init
parameter_list|(
name|map
parameter_list|,
name|args
parameter_list|)
name|MAP
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'-'
condition|)
break|break;
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'a'
case|:
name|map
operator|->
name|map_app
operator|=
operator|++
name|p
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|map
operator|->
name|map_coldelim
operator|=
operator|*
operator|++
name|p
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|->
name|map_app
operator|!=
name|NULL
condition|)
name|map
operator|->
name|map_app
operator|=
name|newstr
argument_list|(
name|map
operator|->
name|map_app
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* **  DEQUOTE_MAP -- unquote an address ** **	Parameters: **		map -- the internal map structure (ignored). **		name -- the name to dequote. **		av -- arguments (ignored). **		statp -- pointer to status out-parameter. ** **	Returns: **		NULL -- if there were no quotes, or if the resulting **			unquoted buffer would not be acceptable to prescan. **		else -- The dequoted buffer. */
name|char
modifier|*
name|dequote_map
parameter_list|(
name|map
parameter_list|,
name|name
parameter_list|,
name|av
parameter_list|,
name|statp
parameter_list|)
name|MAP
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
modifier|*
name|statp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|anglecnt
init|=
literal|0
decl_stmt|;
name|int
name|cmntcnt
init|=
literal|0
decl_stmt|;
name|int
name|quotecnt
init|=
literal|0
decl_stmt|;
name|int
name|spacecnt
init|=
literal|0
decl_stmt|;
name|bool
name|quotemode
init|=
name|FALSE
decl_stmt|;
name|bool
name|bslashmode
init|=
name|FALSE
decl_stmt|;
name|char
name|spacesub
init|=
name|map
operator|->
name|map_coldelim
decl_stmt|;
for|for
control|(
name|p
operator|=
name|q
operator|=
name|name
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
name|bslashmode
condition|)
block|{
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|spacesub
operator|!=
literal|'\0'
condition|)
name|c
operator|=
name|spacesub
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|bslashmode
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|cmntcnt
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|cmntcnt
operator|--
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
case|case
literal|' '
case|:
name|spacecnt
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'"'
case|:
name|quotemode
operator|=
operator|!
name|quotemode
expr_stmt|;
name|quotecnt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
name|anglecnt
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|anglecnt
operator|--
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
block|}
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|anglecnt
operator|!=
literal|0
operator|||
name|cmntcnt
operator|!=
literal|0
operator|||
name|bslashmode
operator|||
name|quotemode
operator|||
name|quotecnt
operator|<=
literal|0
operator|||
name|spacecnt
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

end_unit

