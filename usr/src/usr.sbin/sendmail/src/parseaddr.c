begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* **  Sendmail **  Copyright (c) 1983  Eric P. Allman **  Berkeley, California ** **  Copyright (c) 1983 Regents of the University of California. **  All rights reserved.  The Berkeley software License Agreement **  specifies the terms and conditions for redistribution. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)parseaddr.c	5.1.1.1 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_comment
comment|/* **  PARSEADDR -- Parse an address ** **	Parses an address and breaks it up into three parts: a **	net to transmit the message on, the host to transmit it **	to, and a user on that host.  These are loaded into an **	ADDRESS header with the values squirreled away if necessary. **	The "user" part may not be a real user; the process may **	just reoccur on that machine.  For example, on a machine **	with an arpanet connection, the address **		csvax.bill@berkeley **	will break up to a "user" of 'csvax.bill' and a host **	of 'berkeley' -- to be transmitted over the arpanet. ** **	Parameters: **		addr -- the address to parse. **		a -- a pointer to the address descriptor buffer. **			If NULL, a header will be created. **		copyf -- determines what shall be copied: **			-1 -- don't copy anything.  The printname **				(q_paddr) is just addr, and the **				user& host are allocated internally **				to parse. **			0 -- copy out the parsed user& host, but **				don't copy the printname. **			+1 -- copy everything. **		delim -- the character to terminate the address, passed **			to prescan. ** **	Returns: **		A pointer to the address descriptor header (`a' if **			`a' is non-NULL). **		NULL on error. ** **	Side Effects: **		none */
end_comment

begin_comment
comment|/* following delimiters are inherent to the internal algorithms */
end_comment

begin_define
define|#
directive|define
name|DELIMCHARS
value|"\001()<>,;\\\"\r\n"
end_define

begin_comment
comment|/* word delimiters */
end_comment

begin_function
name|ADDRESS
modifier|*
name|parseaddr
parameter_list|(
name|addr
parameter_list|,
name|a
parameter_list|,
name|copyf
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|int
name|copyf
decl_stmt|;
name|char
name|delim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|()
function_decl|;
comment|/* 	**  Initialize and prescan address. 	*/
name|CurEnv
operator|->
name|e_to
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n--parseaddr(%s)\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|pvp
operator|=
name|prescan
argument_list|(
name|addr
argument_list|,
name|delim
argument_list|,
name|pvpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	**  Apply rewriting rules. 	**	Ruleset 0 does basic parsing.  It must resolve. 	*/
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	**  See if we resolved to a real mailer. 	*/
if|if
condition|(
name|pvp
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
name|CANONNET
condition|)
block|{
name|setstat
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
name|usrerr
argument_list|(
literal|"cannot resolve name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Build canonical address from pvp. 	*/
name|a
operator|=
name|buildaddr
argument_list|(
name|pvp
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
comment|/* 	**  Make local copies of the host& user and then 	**  transport them out. 	*/
if|if
condition|(
name|copyf
operator|>
literal|0
condition|)
block|{
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
name|char
name|savec
init|=
operator|*
name|DelimChar
decl_stmt|;
operator|*
name|DelimChar
operator|=
literal|'\0'
expr_stmt|;
name|a
operator|->
name|q_paddr
operator|=
name|newstr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|*
name|DelimChar
operator|=
name|savec
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_paddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_user
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
condition|)
name|a
operator|->
name|q_host
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|copyf
operator|>=
literal|0
condition|)
block|{
name|a
operator|->
name|q_host
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_user
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Convert host name to lower case if requested. 	**	User name will be done later. 	*/
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_HST_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
comment|/* 	**  Compute return value. 	*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|20
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"parseaddr-->"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  LOWERADDR -- map UPPER->lower case on addresses as requested. ** **	Parameters: **		a -- address to be mapped. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|loweraddr
argument_list|(
name|a
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|MAILER
modifier|*
name|m
init|=
name|a
operator|->
name|q_mailer
decl_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_USR_UPPER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PRESCAN -- Prescan name and make it canonical ** **	Scans a name and turns it into a set of tokens.  This process **	deletes blanks and comments (in parentheses). ** **	This routine knows about quoted strings and angle brackets. ** **	There are certain subtleties to this routine.  The one that **	comes to mind now is that backslashes on the ends of names **	are silently stripped off; this is intentional.  The problem **	is that some versions of sndmsg (like at LBL) set the kill **	character to something other than @ when reading addresses; **	so people type "csvax.eric\@berkeley" -- which screws up the **	berknet mailer. ** **	Parameters: **		addr -- the name to chomp. **		delim -- the delimiter for the address, normally **			'\0' or ','; \0 is accepted in any case. **			If '\t' then we are reading the .cf file. **		pvpbuf -- place to put the saved text -- note that **			the pointers are static. ** **	Returns: **		A pointer to a vector of tokens. **		NULL on error. ** **	Side Effects: **		none. */
end_comment

begin_comment
comment|/* states and character types */
end_comment

begin_define
define|#
directive|define
name|OPR
value|0
end_define

begin_comment
comment|/* operator */
end_comment

begin_define
define|#
directive|define
name|ATM
value|1
end_define

begin_comment
comment|/* atom */
end_comment

begin_define
define|#
directive|define
name|QST
value|2
end_define

begin_comment
comment|/* in quoted string */
end_comment

begin_define
define|#
directive|define
name|SPC
value|3
end_define

begin_comment
comment|/* chewing up spaces */
end_comment

begin_define
define|#
directive|define
name|ONE
value|4
end_define

begin_comment
comment|/* pick up one character */
end_comment

begin_define
define|#
directive|define
name|NSTATES
value|5
end_define

begin_comment
comment|/* number of states */
end_comment

begin_define
define|#
directive|define
name|TYPE
value|017
end_define

begin_comment
comment|/* mask to select state type */
end_comment

begin_comment
comment|/* meta bits for table */
end_comment

begin_define
define|#
directive|define
name|M
value|020
end_define

begin_comment
comment|/* meta character; don't pass through */
end_comment

begin_define
define|#
directive|define
name|B
value|040
end_define

begin_comment
comment|/* cause a break */
end_comment

begin_define
define|#
directive|define
name|MB
value|M|B
end_define

begin_comment
comment|/* meta-break */
end_comment

begin_decl_stmt
specifier|static
name|short
name|StateTab
index|[
name|NSTATES
index|]
index|[
name|NSTATES
index|]
init|=
block|{
comment|/*	oldst	chtype>	OPR	ATM	QST	SPC	ONE	*/
comment|/*OPR*/
name|OPR
operator||
name|B
block|,
name|ATM
operator||
name|B
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
comment|/*ATM*/
name|OPR
operator||
name|B
block|,
name|ATM
block|,
name|QST
operator||
name|B
block|,
name|SPC
operator||
name|MB
block|,
name|ONE
operator||
name|B
block|,
comment|/*QST*/
name|QST
block|,
name|QST
block|,
name|OPR
block|,
name|QST
block|,
name|QST
block|,
comment|/*SPC*/
name|OPR
block|,
name|ATM
block|,
name|QST
block|,
name|SPC
operator||
name|M
block|,
name|ONE
block|,
comment|/*ONE*/
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|,
name|OPR
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOCHAR
value|-1
end_define

begin_comment
comment|/* signal nothing in lookahead token */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DelimChar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to point to the delimiter */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|prescan
parameter_list|(
name|addr
parameter_list|,
name|delim
parameter_list|,
name|pvpbuf
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|char
name|pvpbuf
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
name|bool
name|bslashmode
decl_stmt|;
name|int
name|cmntcnt
decl_stmt|;
name|int
name|anglecnt
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|newstate
decl_stmt|;
specifier|static
name|char
modifier|*
name|av
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* make sure error messages don't have garbage on them */
name|errno
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|pvpbuf
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
name|cmntcnt
operator|=
literal|0
expr_stmt|;
name|anglecnt
operator|=
literal|0
expr_stmt|;
name|avp
operator|=
name|av
expr_stmt|;
name|state
operator|=
name|OPR
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
name|p
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|45
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"prescan: "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
do|do
block|{
comment|/* read a token */
name|tok
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* store away any old lookahead character */
if|if
condition|(
name|c
operator|!=
name|NOCHAR
condition|)
block|{
comment|/* see if there is room */
if|if
condition|(
name|q
operator|>=
operator|&
name|pvpbuf
index|[
name|PSBUFSIZE
operator|-
literal|5
index|]
condition|)
block|{
name|usrerr
argument_list|(
literal|"Address too long"
argument_list|)
expr_stmt|;
name|DelimChar
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* squirrel it away */
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* read a new input character */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
name|c
operator|&=
operator|~
literal|0200
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|101
argument_list|)
condition|)
name|printf
argument_list|(
literal|"c=%c, s=%d; "
argument_list|,
name|c
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* chew up special characters */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bslashmode
condition|)
block|{
comment|/* kludge \! for naive users */
if|if
condition|(
name|c
operator|!=
literal|'!'
condition|)
name|c
operator||=
literal|0200
expr_stmt|;
name|bslashmode
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|bslashmode
operator|=
name|TRUE
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QST
condition|)
block|{
comment|/* do nothing, just avoid next clauses */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|cmntcnt
operator|++
expr_stmt|;
name|c
operator|=
name|NOCHAR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced ')'"
argument_list|)
expr_stmt|;
name|DelimChar
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
name|cmntcnt
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
name|c
operator|=
name|NOCHAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
name|anglecnt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|anglecnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced '>'"
argument_list|)
expr_stmt|;
name|DelimChar
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|anglecnt
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delim
operator|==
literal|' '
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|':'
operator|&&
operator|!
name|CurEnv
operator|->
name|e_oldstyle
condition|)
block|{
comment|/* consume characters until a semicolon */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced ':...;' group spec"
argument_list|)
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|NOCHAR
condition|)
continue|continue;
comment|/* see if this is end of input */
if|if
condition|(
name|c
operator|==
name|delim
operator|&&
name|anglecnt
operator|<=
literal|0
operator|&&
name|state
operator|!=
name|QST
condition|)
break|break;
name|newstate
operator|=
name|StateTab
index|[
name|state
index|]
index|[
name|toktype
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|101
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ns=%02o\n"
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|state
operator|=
name|newstate
operator|&
name|TYPE
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|M
argument_list|,
name|newstate
argument_list|)
condition|)
name|c
operator|=
name|NOCHAR
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|B
argument_list|,
name|newstate
argument_list|)
condition|)
break|break;
block|}
comment|/* new token */
if|if
condition|(
name|tok
operator|!=
name|q
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|22
argument_list|,
literal|36
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tok="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|tok
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|avp
operator|>=
operator|&
name|av
index|[
name|MAXATOM
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"prescan: too many tokens"
argument_list|)
expr_stmt|;
name|DelimChar
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|avp
operator|++
operator|=
name|tok
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|!=
name|delim
operator|||
name|anglecnt
operator|>
literal|0
operator|)
condition|)
do|;
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
name|DelimChar
operator|=
operator|--
name|p
expr_stmt|;
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '('"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|anglecnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '<'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|QST
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '\"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|av
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|av
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TOKTYPE -- return token type ** **	Parameters: **		c -- the character in question. ** **	Returns: **		Its type. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|toktype
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
specifier|static
name|bool
name|firstime
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
name|firstime
condition|)
block|{
name|firstime
operator|=
name|FALSE
expr_stmt|;
name|expand
argument_list|(
literal|"\001o"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|DELIMCHARS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|MATCHCLASS
operator|||
name|c
operator|==
name|MATCHREPL
operator|||
name|c
operator|==
name|MATCHNCLASS
condition|)
return|return
operator|(
name|ONE
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
return|return
operator|(
name|QST
operator|)
return|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
name|ATM
operator|)
return|;
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|')'
condition|)
return|return
operator|(
name|SPC
operator|)
return|;
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
operator|||
name|index
argument_list|(
name|buf
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|OPR
operator|)
return|;
return|return
operator|(
name|ATM
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  REWRITE -- apply rewrite rules to token vector. ** **	This routine is an ordered production system.  Each rewrite **	rule has a LHS (called the pattern) and a RHS (called the **	rewrite); 'rwr' points the the current rewrite rule. ** **	For each rewrite rule, 'avp' points the address vector we **	are trying to match against, and 'pvp' points to the pattern. **	If pvp points to a special match value (MATCHZANY, MATCHANY, **	MATCHONE, MATCHCLASS, MATCHNCLASS) then the address in avp **	matched is saved away in the match vector (pointed to by 'mvp'). ** **	When a match between avp& pvp does not match, we try to **	back out.  If we back up over MATCHONE, MATCHCLASS, or MATCHNCLASS **	we must also back out the match in mvp.  If we reach a **	MATCHANY or MATCHZANY we just extend the match and start **	over again. ** **	When we finally match, we rewrite the address vector **	and try over again. ** **	Parameters: **		pvp -- pointer to token vector. ** **	Returns: **		none. ** **	Side Effects: **		pvp is modified. */
end_comment

begin_struct
struct|struct
name|match
block|{
name|char
modifier|*
modifier|*
name|first
decl_stmt|;
comment|/* first token matched */
name|char
modifier|*
modifier|*
name|last
decl_stmt|;
comment|/* last token matched */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXMATCH
value|9
end_define

begin_comment
comment|/* max params per rewrite */
end_comment

begin_macro
name|rewrite
argument_list|(
argument|pvp
argument_list|,
argument|ruleset
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ruleset
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|ap
decl_stmt|;
comment|/* address pointer */
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* rewrite pointer */
specifier|register
name|char
modifier|*
modifier|*
name|avp
decl_stmt|;
comment|/* address vector pointer */
specifier|register
name|char
modifier|*
modifier|*
name|rvp
decl_stmt|;
comment|/* rewrite vector pointer */
specifier|register
name|struct
name|match
modifier|*
name|mlp
decl_stmt|;
comment|/* cur ptr into mlist */
specifier|register
name|struct
name|rewrite
modifier|*
name|rwr
decl_stmt|;
comment|/* pointer to current rewrite rule */
name|int
name|subr
decl_stmt|;
comment|/* subroutine number if>= 0 */
name|bool
name|dolookup
decl_stmt|;
comment|/* do host aliasing */
name|struct
name|match
name|mlist
index|[
name|MAXMATCH
index|]
decl_stmt|;
comment|/* stores match on LHS */
name|char
modifier|*
name|npvp
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
comment|/* temporary space for rebuild */
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
operator|||
name|tTd
argument_list|(
literal|21
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rewrite: ruleset %2d   input:"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return;
comment|/* 	**  Run through the list of rewrite rules, applying 	**	any that match. 	*/
for|for
control|(
name|rwr
operator|=
name|RewriteRules
index|[
name|ruleset
index|]
init|;
name|rwr
operator|!=
name|NULL
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"-----trying rule:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rwr
operator|->
name|r_lhs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* try to match on this rule */
name|mlp
operator|=
name|mlist
expr_stmt|;
name|rvp
operator|=
name|rwr
operator|->
name|r_lhs
expr_stmt|;
name|avp
operator|=
name|pvp
expr_stmt|;
while|while
condition|(
operator|(
name|ap
operator|=
operator|*
name|avp
operator|)
operator|!=
name|NULL
operator|||
operator|*
name|rvp
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|35
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ap="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", rp="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
comment|/* end-of-pattern before end-of-address */
goto|goto
name|backup
goto|;
block|}
if|if
condition|(
name|ap
operator|==
name|NULL
operator|&&
operator|*
name|rp
operator|!=
name|MATCHZANY
condition|)
block|{
comment|/* end-of-input */
break|break;
block|}
switch|switch
condition|(
operator|*
name|rp
condition|)
block|{
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
case|case
name|MATCHCLASS
case|:
case|case
name|MATCHNCLASS
case|:
comment|/* match any token in (not in) a class */
name|s
operator|=
name|stab
argument_list|(
name|ap
argument_list|,
name|ST_CLASS
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bitnset
argument_list|(
name|rp
index|[
literal|1
index|]
argument_list|,
name|s
operator|->
name|s_class
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHCLASS
condition|)
goto|goto
name|backup
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHNCLASS
condition|)
goto|goto
name|backup
goto|;
comment|/* explicit fall-through */
case|case
name|MATCHONE
case|:
case|case
name|MATCHANY
case|:
comment|/* match exactly one token */
name|mlp
operator|->
name|first
operator|=
name|avp
expr_stmt|;
name|mlp
operator|->
name|last
operator|=
name|avp
operator|++
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
case|case
name|MATCHZANY
case|:
comment|/* match zero or more tokens */
name|mlp
operator|->
name|first
operator|=
name|avp
expr_stmt|;
name|mlp
operator|->
name|last
operator|=
name|avp
operator|-
literal|1
expr_stmt|;
name|mlp
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* must have exact match */
if|if
condition|(
operator|!
name|sameword
argument_list|(
name|rp
argument_list|,
name|ap
argument_list|)
condition|)
goto|goto
name|backup
goto|;
name|avp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* successful match on this token */
name|rvp
operator|++
expr_stmt|;
continue|continue;
name|backup
label|:
comment|/* match failed -- back up */
while|while
condition|(
operator|--
name|rvp
operator|>=
name|rwr
operator|->
name|r_lhs
condition|)
block|{
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHANY
operator|||
operator|*
name|rp
operator|==
name|MATCHZANY
condition|)
block|{
comment|/* extend binding and continue */
name|avp
operator|=
operator|++
name|mlp
index|[
operator|-
literal|1
index|]
operator|.
name|last
expr_stmt|;
name|avp
operator|++
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
break|break;
block|}
name|avp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHONE
operator|||
operator|*
name|rp
operator|==
name|MATCHCLASS
operator|||
operator|*
name|rp
operator|==
name|MATCHNCLASS
condition|)
block|{
comment|/* back out binding */
name|mlp
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rvp
operator|<
name|rwr
operator|->
name|r_lhs
condition|)
block|{
comment|/* total failure to match */
break|break;
block|}
block|}
comment|/* 		**  See if we successfully matched 		*/
if|if
condition|(
name|rvp
operator|<
name|rwr
operator|->
name|r_lhs
operator|||
operator|*
name|rvp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|10
argument_list|)
condition|)
name|printf
argument_list|(
literal|"----- rule fails\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
continue|continue;
block|}
name|rvp
operator|=
name|rwr
operator|->
name|r_rhs
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|12
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"-----rule matches:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
if|if
condition|(
operator|*
name|rp
operator|==
name|CANONUSER
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
name|rwr
operator|=
name|rwr
operator|->
name|r_next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rp
operator|==
name|CANONHOST
condition|)
block|{
name|rvp
operator|++
expr_stmt|;
name|rwr
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rp
operator|==
name|CANONNET
condition|)
name|rwr
operator|=
name|NULL
expr_stmt|;
comment|/* substitute */
name|dolookup
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|avp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
specifier|register
name|struct
name|match
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|rp
operator|=
operator|*
name|rvp
expr_stmt|;
comment|/* check to see if we should do a lookup */
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHLOOKUP
condition|)
name|dolookup
operator|=
name|TRUE
expr_stmt|;
comment|/* see if there is substitution here */
if|if
condition|(
operator|*
name|rp
operator|==
name|MATCHREPL
condition|)
block|{
comment|/* substitute from LHS */
name|m
operator|=
operator|&
name|mlist
index|[
name|rp
index|[
literal|1
index|]
operator|-
literal|'1'
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>=
name|mlp
condition|)
block|{
name|toolong
label|:
name|syserr
argument_list|(
literal|"rewrite: ruleset %d: replacement out of bounds"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|15
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"$%c:"
argument_list|,
name|rp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pp
operator|=
name|m
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|pp
operator|<=
name|m
operator|->
name|last
condition|)
block|{
name|printf
argument_list|(
literal|" %x=\""
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\""
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
name|pp
operator|=
name|m
operator|->
name|first
expr_stmt|;
while|while
condition|(
name|pp
operator|<=
name|m
operator|->
name|last
condition|)
block|{
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"rewrite: expansion too long"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|avp
operator|++
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* vanilla replacement */
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
operator|*
name|avp
operator|++
operator|=
name|rp
expr_stmt|;
block|}
block|}
operator|*
name|avp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  Check for any hostname lookups. 		*/
for|for
control|(
name|rvp
operator|=
name|npvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|hbrvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|xpvp
decl_stmt|;
name|int
name|trsize
decl_stmt|;
name|char
modifier|*
name|olddelimchar
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|pvpb1
index|[
name|MAXATOM
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|rvp
operator|!=
name|HOSTBEGIN
condition|)
continue|continue;
comment|/* 			**  Got a hostname lookup. 			** 			**	This could be optimized fairly easily. 			*/
name|hbrvp
operator|=
name|rvp
expr_stmt|;
comment|/* extract the match part */
while|while
condition|(
operator|*
operator|++
name|rvp
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|rvp
operator|!=
name|HOSTEND
condition|)
continue|continue;
if|if
condition|(
operator|*
name|rvp
operator|!=
name|NULL
condition|)
operator|*
name|rvp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* save the remainder of the input string */
name|trsize
operator|=
call|(
name|int
call|)
argument_list|(
name|avp
operator|-
name|rvp
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|rvp
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rvp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pvpb1
argument_list|,
name|trsize
argument_list|)
expr_stmt|;
comment|/* look it up */
name|cataddr
argument_list|(
operator|++
name|hbrvp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|maphostname
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
comment|/* scan the new host name */
name|olddelimchar
operator|=
name|DelimChar
expr_stmt|;
name|xpvp
operator|=
name|prescan
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|pvpbuf
argument_list|)
expr_stmt|;
name|DelimChar
operator|=
name|olddelimchar
expr_stmt|;
if|if
condition|(
name|xpvp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"rewrite: cannot prescan canonical hostname: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append it to the token list */
for|for
control|(
name|avp
operator|=
operator|--
name|hbrvp
init|;
operator|*
name|xpvp
operator|!=
name|NULL
condition|;
name|xpvp
operator|++
control|)
block|{
operator|*
name|avp
operator|++
operator|=
name|newstr
argument_list|(
operator|*
name|xpvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
block|}
comment|/* restore the old trailing information */
for|for
control|(
name|xpvp
operator|=
name|pvpb1
init|;
operator|(
operator|*
name|avp
operator|++
operator|=
operator|*
name|xpvp
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|avp
operator|>=
operator|&
name|npvp
index|[
name|MAXATOM
index|]
condition|)
goto|goto
name|toolong
goto|;
break|break;
block|}
comment|/* 		**  Check for subroutine calls. 		*/
comment|/* 		**  Do hostname lookup if requested. 		*/
if|if
condition|(
name|dolookup
condition|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|maphost
parameter_list|()
function_decl|;
name|rvp
operator|=
name|maphost
argument_list|(
name|npvp
argument_list|)
expr_stmt|;
block|}
else|else
name|rvp
operator|=
name|npvp
expr_stmt|;
comment|/* 		**  See if this is a subroutine call. 		*/
if|if
condition|(
operator|*
operator|*
name|rvp
operator|==
name|CALLSUBR
condition|)
block|{
name|subr
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|rvp
argument_list|)
expr_stmt|;
name|rvp
operator|++
expr_stmt|;
block|}
else|else
name|subr
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		**  Copy result back to original string. 		*/
for|for
control|(
name|avp
operator|=
name|pvp
init|;
operator|*
name|rvp
operator|!=
name|NULL
condition|;
name|rvp
operator|++
control|)
operator|*
name|avp
operator|++
operator|=
operator|*
name|rvp
expr_stmt|;
operator|*
name|avp
operator|=
name|NULL
expr_stmt|;
comment|/* 		**  If this specified a subroutine, call it. 		*/
if|if
condition|(
name|subr
operator|>=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"-----callsubr %s\n"
argument_list|,
name|subr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|subr
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Done with rewriting this pass. 		*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|21
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rewritten as:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
operator|||
name|tTd
argument_list|(
literal|21
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"rewrite: ruleset %2d returns:"
argument_list|,
name|ruleset
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUILDADDR -- build address from token vector. ** **	Parameters: **		tv -- token vector. **		a -- pointer to address descriptor to fill. **			If NULL, one will be allocated. ** **	Returns: **		NULL if there was an error. **		'a' otherwise. ** **	Side Effects: **		fills in 'a' */
end_comment

begin_function
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|(
name|tv
parameter_list|,
name|a
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|tv
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|struct
name|mailer
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|ADDRESS
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|,
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
comment|/* figure out what net/mailer to use */
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONNET
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: no net"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tv
operator|++
expr_stmt|;
if|if
condition|(
name|sameword
argument_list|(
operator|*
name|tv
argument_list|,
literal|"error"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|*
operator|++
name|tv
operator|==
name|CANONHOST
condition|)
block|{
name|setstat
argument_list|(
name|atoi
argument_list|(
operator|*
operator|++
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|tv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
condition|)
name|syserr
argument_list|(
literal|"buildaddr: error: no user"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|tv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
block|}
name|usrerr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|mp
operator|=
name|Mailer
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|sameword
argument_list|(
name|m
operator|->
name|m_name
argument_list|,
operator|*
name|tv
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: unknown mailer %s"
argument_list|,
operator|*
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|a
operator|->
name|q_mailer
operator|=
name|m
expr_stmt|;
comment|/* figure out what host (if any) */
name|tv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_LOCAL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|tv
operator|++
operator|!=
name|CANONHOST
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: no host"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|tv
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|tv
operator|++
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_host
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_host
operator|=
name|NULL
expr_stmt|;
comment|/* figure out the user */
if|if
condition|(
operator|*
operator|*
name|tv
operator|!=
name|CANONUSER
condition|)
block|{
name|syserr
argument_list|(
literal|"buildaddr: no user"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* rewrite according recipient mailer rewriting rules */
name|rewrite
argument_list|(
operator|++
name|tv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_r_rwset
operator|>
literal|0
condition|)
name|rewrite
argument_list|(
name|tv
argument_list|,
name|m
operator|->
name|m_r_rwset
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|tv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* save the result for the command line/RCPT argument */
name|cataddr
argument_list|(
name|tv
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  CATADDR -- concatenate pieces of addresses (putting in<LWSP> subs) ** **	Parameters: **		pvp -- parameter vector to rebuild. **		buf -- buffer to build the string into. **		sz -- size of buf. ** **	Returns: **		none. ** **	Side Effects: **		Destroys buf. */
end_comment

begin_macro
name|cataddr
argument_list|(
argument|pvp
argument_list|,
argument|buf
argument_list|,
argument|sz
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|sz
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bool
name|oatomtok
init|=
name|FALSE
decl_stmt|;
name|bool
name|natomtok
init|=
name|FALSE
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|buf
expr_stmt|;
name|sz
operator|-=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
operator|*
name|pvp
argument_list|)
operator|)
operator|<
name|sz
condition|)
block|{
name|natomtok
operator|=
operator|(
name|toktype
argument_list|(
operator|*
operator|*
name|pvp
argument_list|)
operator|==
name|ATM
operator|)
expr_stmt|;
if|if
condition|(
name|oatomtok
operator|&&
name|natomtok
condition|)
operator|*
name|p
operator|++
operator|=
name|SpaceSub
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|pvp
argument_list|)
expr_stmt|;
name|oatomtok
operator|=
name|natomtok
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
name|sz
operator|-=
name|i
operator|+
literal|1
expr_stmt|;
name|pvp
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SAMEADDR -- Determine if two addresses are the same ** **	This is not just a straight comparison -- if the mailer doesn't **	care about the host we just ignore it, etc. ** **	Parameters: **		a, b -- pointers to the internal forms to compare. ** **	Returns: **		TRUE -- they represent the same mailbox. **		FALSE -- they don't. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|sameaddr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|b
decl_stmt|;
block|{
comment|/* if they don't have the same mailer, forget it */
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|!=
name|b
operator|->
name|q_mailer
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the user isn't the same, we can drop out */
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|b
operator|->
name|q_user
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* if the mailer ignores hosts, we have succeeded! */
if|if
condition|(
name|bitnset
argument_list|(
name|M_LOCAL
argument_list|,
name|a
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* otherwise compare hosts (but be careful for NULL ptrs) */
if|if
condition|(
name|a
operator|->
name|q_host
operator|==
name|NULL
operator|||
name|b
operator|->
name|q_host
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_host
argument_list|,
name|b
operator|->
name|q_host
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTADDR -- print address (for debugging) ** **	Parameters: **		a -- the address to print **		follow -- follow the q_next chain. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|printaddr
argument_list|(
name|a
argument_list|,
name|follow
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|follow
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bool
name|first
init|=
name|TRUE
decl_stmt|;
specifier|static
name|int
name|indent
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
name|first
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x="
argument_list|,
name|a
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: mailer %d (%s), host `%s', user `%s'\n"
argument_list|,
argument|a->q_paddr
argument_list|,
argument|for (i = indent; i>
literal|0
argument|; i--) 			printf(
literal|"\t"
argument|); 		printf(
literal|"\tnext=%x, flags=%o, rmailer %d, alias=%x, sibling=%x, child=%x\n"
argument|, 		       a->q_next, a->q_flags, a->q_rmailer, a->q_alias, 		       a->q_sibling, a->q_child);
comment|/* follow the chain if appropriate */
argument|if (!follow) 			return; 		 		indent++; 		printaddr(a->q_child, TRUE); 		indent--; 		a = a->q_sibling; 	} 	if (first) 		printf(
literal|"[NULL]\n"
argument|); }
endif|#
directive|endif
endif|DEBUG
comment|/* **  REMOTENAME -- return the name relative to the current mailer ** **	Parameters: **		name -- the name to translate. **		m -- the mailer that we want to do rewriting relative **			to. **		senderaddress -- if set, uses the sender rewriting rules **			rather than the recipient rewriting rules. **		canonical -- if set, strip out any comment information, **			etc. ** **	Returns: **		the text string representing this address relative to **			the receiving mailer. ** **	Side Effects: **		none. ** **	Warnings: **		The text string returned is tucked away locally; **			copy it if you intend to save it. */
argument|char * remotename(name, m, senderaddress, canonical) 	char *name; 	struct mailer *m; 	bool senderaddress; 	bool canonical; { 	register char **pvp; 	char *fancy; 	extern char *macvalue(); 	char *oldg = macvalue(
literal|'g'
argument|, CurEnv); 	static char buf[MAXNAME]; 	char lbuf[MAXNAME]; 	char pvpbuf[PSBUFSIZE]; 	extern char **prescan(); 	extern char *crackaddr();
ifdef|#
directive|ifdef
name|DEBUG
argument|if (tTd(
literal|12
argument|,
literal|1
argument|)) 		printf(
literal|"remotename(%s)\n"
argument|, name);
endif|#
directive|endif
endif|DEBUG
comment|/* don't do anything if we are tagging it as special */
argument|if ((senderaddress ? m->m_s_rwset : m->m_r_rwset)<
literal|0
argument|) 		return (name);
comment|/* 	**  Do a heuristic crack of this name to extract any comment info. 	**	This will leave the name as a comment and a $g macro. 	*/
argument|if (canonical) 		fancy =
literal|"\001g"
argument|; 	else 		fancy = crackaddr(name);
comment|/* 	**  Turn the name into canonical form. 	**	Normally this will be RFC 822 style, i.e., "user@domain". 	**	If this only resolves to "user", and the "C" flag is 	**	specified in the sending mailer, then the sender's 	**	domain will be appended. 	*/
argument|pvp = prescan(name,
literal|'\0'
argument|, pvpbuf); 	if (pvp == NULL) 		return (name); 	rewrite(pvp,
literal|3
argument|); 	if (CurEnv->e_fromdomain != NULL) 	{
comment|/* append from domain to this address */
argument|register char **pxp = pvp;
comment|/* see if there is an "@domain" in the current name */
argument|while (*pxp != NULL&& strcmp(*pxp,
literal|"@"
argument|) !=
literal|0
argument|) 			pxp++; 		if (*pxp == NULL) 		{
comment|/* no.... append the "@domain" from the sender */
argument|register char **qxq = CurEnv->e_fromdomain;  			while ((*pxp++ = *qxq++) != NULL) 				continue; 			rewrite(pvp,
literal|3
argument|); 		} 	}
comment|/* 	**  Do more specific rewriting. 	**	Rewrite using ruleset 1 or 2 depending on whether this is 	**		a sender address or not. 	**	Then run it through any receiving-mailer-specific rulesets. 	*/
argument|if (senderaddress) 	{ 		rewrite(pvp,
literal|1
argument|); 		if (m->m_s_rwset>
literal|0
argument|) 			rewrite(pvp, m->m_s_rwset); 	} 	else 	{ 		rewrite(pvp,
literal|2
argument|); 		if (m->m_r_rwset>
literal|0
argument|) 			rewrite(pvp, m->m_r_rwset); 	}
comment|/* 	**  Do any final sanitation the address may require. 	**	This will normally be used to turn internal forms 	**	(e.g., user@host.LOCAL) into external form.  This 	**	may be used as a default to the above rules. 	*/
argument|rewrite(pvp,
literal|4
argument|);
comment|/* 	**  Now restore the comment information we had at the beginning. 	*/
argument|cataddr(pvp, lbuf, sizeof lbuf); 	define(
literal|'g'
argument|, lbuf, CurEnv); 	expand(fancy, buf,&buf[sizeof buf -
literal|1
argument|], CurEnv); 	define(
literal|'g'
argument|, oldg, CurEnv);
ifdef|#
directive|ifdef
name|DEBUG
argument|if (tTd(
literal|12
argument|,
literal|1
argument|)) 		printf(
literal|"remotename => `%s'\n"
argument|, buf);
endif|#
directive|endif
endif|DEBUG
argument|return (buf); }
end_block

end_unit

