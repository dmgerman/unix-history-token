begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"dlvrmail.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)parseaddr.c	1.3	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  PARSE -- Parse an address ** **	Parses an address and breaks it up into three parts: a **	net to transmit the message on, the host to transmit it **	to, and a user on that host.  These are loaded into an **	addrq header with the values squirreled away if necessary. **	The "user" part may not be a real user; the process may **	just reoccur on that machine.  For example, on a machine **	with an arpanet connection, the address **		csvax.bill@berkeley **	will break up to a "user" of 'csvax.bill' and a host **	of 'berkeley' -- to be transmitted over the arpanet. ** **	Parameters: **		addr -- the address to parse. **		a -- a pointer to the address descriptor buffer. **			If NULL, a header will be created. **		copyf -- determines what shall be copied: **			-1 -- don't copy anything.  The printname **				(q_paddr) is just addr, and the **				user& host are allocated internally **				to parse. **			0 -- copy out the parsed user& host, but **				don't copy the printname. **			+1 -- copy everything. ** **	Returns: **		A pointer to the address descriptor header (`a' if **			`a' is non-NULL). **		NULL on error. ** **	Side Effects: **		none ** **	Called By: **		main **		sendto **		alias **		savemail */
end_comment

begin_function
name|addrq
modifier|*
name|parse
parameter_list|(
name|addr
parameter_list|,
name|a
parameter_list|,
name|copyf
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
specifier|register
name|addrq
modifier|*
name|a
decl_stmt|;
name|int
name|copyf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|parsetab
modifier|*
name|t
decl_stmt|;
specifier|extern
name|struct
name|parsetab
name|ParseTab
index|[]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|bool
name|got_one
decl_stmt|;
specifier|extern
name|char
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|xalloc
parameter_list|()
function_decl|;
comment|/* 	**  Initialize and prescan address. 	*/
name|To
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|prescan
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
argument_list|,
literal|'\0'
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	**  Scan parse table. 	**	Look for the first entry designating a character 	**		that is contained in the address. 	**	Arrange for q to point to that character. 	**	Check to see that there is only one of the char 	**		if it must be unique. 	**	Find the last one if the host is on the RHS. 	**	Insist that the host name is atomic. 	**	If just doing a map, do the map and then start all 	**		over. 	*/
name|rescan
label|:
name|got_one
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|ParseTab
init|;
name|t
operator|->
name|p_char
operator|!=
literal|'\0'
condition|;
name|t
operator|++
control|)
block|{
name|q
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
comment|/* find the end of this token */
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'_'
condition|)
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|t
operator|->
name|p_char
condition|)
block|{
name|got_one
operator|=
name|TRUE
expr_stmt|;
comment|/* do mapping as appropriate */
if|if
condition|(
name|flagset
argument_list|(
name|P_MAP
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
name|t
operator|->
name|p_arg
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|flagset
argument_list|(
name|P_ONE
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
goto|goto
name|rescan
goto|;
else|else
continue|continue;
block|}
comment|/* arrange for q to point to it */
if|if
condition|(
name|q
operator|!=
name|NULL
operator|&&
name|flagset
argument_list|(
name|P_ONE
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
block|{
name|usrerr
argument_list|(
literal|"multichar error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
operator|||
name|flagset
argument_list|(
name|P_HLAST
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
name|q
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
comment|/* insist that host name is atomic */
if|if
condition|(
name|flagset
argument_list|(
name|P_HLAST
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 	**  If we matched nothing cleanly, but we did match something 	**  somewhere in the process of scanning, then we have a 	**  syntax error.  This can happen on things like a@b:c where 	**  @ has a right host and : has a left host. 	** 	**  We also set `q' to the null string, in case someone forgets 	**  to put the P_MOVE bit in the local mailer entry of the 	**  configuration table. 	*/
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|got_one
condition|)
block|{
name|usrerr
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	**  Interpret entry. 	**	t points to the entry for the mailer we will use. 	**	q points to the significant character. 	*/
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|a
operator|=
operator|(
name|addrq
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyf
operator|>
literal|0
condition|)
block|{
name|p
operator|=
name|xalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|addr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_paddr
operator|=
name|p
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_paddr
operator|=
name|addr
expr_stmt|;
name|a
operator|->
name|q_mailer
operator|=
operator|&
name|Mailer
index|[
name|t
operator|->
name|p_mailer
index|]
expr_stmt|;
if|if
condition|(
name|flagset
argument_list|(
name|P_MOVE
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
block|{
comment|/* send the message to another host& retry */
name|a
operator|->
name|q_host
operator|=
name|t
operator|->
name|p_arg
expr_stmt|;
if|if
condition|(
name|copyf
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
name|xalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|p
expr_stmt|;
block|}
else|else
name|a
operator|->
name|q_user
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* 		**  Make local copies of the host& user and then 		**  transport them out. 		*/
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flagset
argument_list|(
name|P_HLAST
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_host
operator|=
name|q
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|q_host
operator|=
name|buf
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|copyf
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
name|xalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_host
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|xalloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_user
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* 	**  Do UPPER->lower case mapping unless inhibited. 	*/
if|if
condition|(
operator|!
name|flagset
argument_list|(
name|P_HST_UPPER
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flagset
argument_list|(
name|P_USR_UPPER
argument_list|,
name|t
operator|->
name|p_flags
argument_list|)
condition|)
name|makelower
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
comment|/* 	**  Compute return value. 	*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|&&
name|copyf
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"parse(\"%s\"): host \"%s\" user \"%s\" mailer %d\n"
argument_list|,
name|addr
argument_list|,
name|a
operator|->
name|q_host
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|t
operator|->
name|p_mailer
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MAKELOWER -- Translate a line into lower case ** **	Parameters: **		p -- the string to translate.  If NULL, return is **			immediate. ** **	Returns: **		none. ** **	Side Effects: **		String pointed to by p is translated to lower case. ** **	Called By: **		parse */
end_comment

begin_expr_stmt
name|makelower
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|c
operator|&
literal|0200
operator|)
operator|==
literal|0
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|p
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|'a'
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PRESCAN -- Prescan name and make it canonical ** **	Scans a name and turns it into canonical form.  This involves **	deleting blanks, comments (in parentheses), and turning the **	word "at" into an at-sign ("@").  The name is copied as this **	is done; it is legal to copy a name onto itself, since this **	process can only make things smaller. ** **	This routine knows about quoted strings and angle brackets. ** **	There are certain subtleties to this routine.  The one that **	comes to mind now is that backslashes on the ends of names **	are silently stripped off; this is intentional.  The problem **	is that some versions of sndmsg (like at LBL) set the kill **	character to something other than @ when reading addresses; **	so people type "csvax.eric\@berkeley" -- which screws up the **	berknet mailer. ** **	Parameters: **		addr -- the name to chomp. **		buf -- the buffer to copy it into. **		buflim -- the last usable address in the buffer **			(which will old a null byte).  Normally **&buf[sizeof buf - 1]. **		delim -- the delimiter for the address, normally **			'\0' or ','; \0 is accepted in any case. **			are moving in place; set buflim to high core. ** **	Returns: **		A pointer to the terminator of buf. **		NULL on error. ** **	Side Effects: **		buf gets clobbered. ** **	Called By: **		parse **		maketemp */
end_comment

begin_function
name|char
modifier|*
name|prescan
parameter_list|(
name|addr
parameter_list|,
name|buf
parameter_list|,
name|buflim
parameter_list|,
name|delim
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|buflim
decl_stmt|;
name|char
name|delim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|space
decl_stmt|;
name|bool
name|quotemode
decl_stmt|;
name|bool
name|bslashmode
decl_stmt|;
name|int
name|cmntcnt
decl_stmt|;
name|int
name|brccnt
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|bool
name|any
parameter_list|()
function_decl|;
name|space
operator|=
name|TRUE
expr_stmt|;
name|q
operator|=
name|buf
expr_stmt|;
name|bslashmode
operator|=
name|quotemode
operator|=
name|FALSE
expr_stmt|;
name|cmntcnt
operator|=
name|brccnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|addr
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|&
literal|0177
operator|)
operator|!=
literal|'\0'
condition|;
control|)
block|{
comment|/* chew up special characters */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|bslashmode
condition|)
block|{
name|c
operator||=
literal|0200
expr_stmt|;
name|bslashmode
operator|==
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|quotemode
operator|=
operator|!
name|quotemode
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|bslashmode
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|quotemode
condition|)
name|c
operator||=
literal|0200
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|delim
condition|)
break|break;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|cmntcnt
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced ')'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|cmntcnt
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'<'
condition|)
block|{
name|brccnt
operator|++
expr_stmt|;
if|if
condition|(
name|brccnt
operator|==
literal|1
condition|)
block|{
comment|/* we prefer using machine readable name */
name|q
operator|=
name|buf
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
name|brccnt
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Unbalanced `>'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
name|brccnt
operator|--
expr_stmt|;
if|if
condition|(
name|brccnt
operator|<=
literal|0
condition|)
continue|continue;
block|}
comment|/* 		**  Turn "at" into "@", 		**	but only if "at" is a word in and to itself. 		**	By the way, I violate the ARPANET RFC-733 		**	standard here, by assuming that 'space' delimits 		**	atoms.  I assume that is just a mistake, since 		**	it violates the spirit of the semantics 		**	of the document..... 		*/
if|if
condition|(
name|space
operator|&&
operator|(
name|c
operator|==
literal|'a'
operator|||
name|c
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|'t'
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|any
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|"()<>@,;:\\\""
argument_list|)
operator|||
name|p
index|[
literal|1
index|]
operator|<=
literal|040
operator|)
condition|)
block|{
name|c
operator|=
literal|'@'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* skip blanks */
if|if
condition|(
operator|(
operator|(
name|c
operator|&
literal|0200
operator|)
operator|!=
literal|0
operator|||
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
operator|)
operator|&&
name|cmntcnt
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|q
operator|>=
name|buflim
condition|)
block|{
name|usrerr
argument_list|(
literal|"Address too long"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|space
operator|=
name|isspace
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|cmntcnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '('"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|quotemode
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '\"'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|brccnt
operator|>
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Unbalanced '<'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

