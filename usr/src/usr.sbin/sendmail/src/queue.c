begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|QUEUE
end_ifndef

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|queue
operator|.
name|c
literal|3.8
operator|%
name|G
operator|%
operator|(
name|no
name|queueing
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
else|QUEUE
end_else

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|queue
operator|.
name|c
literal|3.8
operator|%
name|G
operator|%
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  QUEUEUP -- queue a message up for future transmission. ** **	The queued message should already be in the correct place. **	This routine just outputs the control file as appropriate. ** **	Parameters: **		df -- location of the data file.  The name will **			be transformed into a control file name. ** **	Returns: **		none. ** **	Side Effects: **		The current request (only unsatisfied addresses) **			are saved in a control file. */
end_comment

begin_macro
name|queueup
argument_list|(
argument|df
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|df
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
comment|/* 	**  Create control file. 	*/
name|strcpy
argument_list|(
name|cf
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cf
argument_list|,
literal|"/cfXXXXXX"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|cf
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|cf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"queueup: cannot create control file %s"
argument_list|,
name|cf
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"queued in %s\n"
argument_list|,
name|cf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Output future work requests. 	*/
comment|/* output name of data file */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"D%s\n"
argument_list|,
name|df
argument_list|)
expr_stmt|;
comment|/* output name of sender */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"S%s\n"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
comment|/* output timeout */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"T%ld\n"
argument_list|,
name|TimeOut
argument_list|)
expr_stmt|;
comment|/* output message priority */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"P%ld\n"
argument_list|,
name|MsgPriority
argument_list|)
expr_stmt|;
comment|/* output list of recipient addresses */
for|for
control|(
name|q
operator|=
name|SendQueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"queueing "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"R%s\n"
argument_list|,
name|q
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
comment|/* output headers for this message */
for|for
control|(
name|h
operator|=
name|Header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|h
operator|->
name|h_value
operator|==
name|NULL
operator|||
name|h
operator|->
name|h_value
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"H"
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_mflags
operator|!=
literal|0
operator|&&
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
name|mfdecode
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s: "
argument_list|,
name|h
operator|->
name|h_field
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|expand
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\n"
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Clean up. 	*/
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RUNQUEUE -- run the jobs in the queue. ** **	Gets the stuff out of the queue in some presumably logical **	order and processes them. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		runs things in the mail queue. */
end_comment

begin_decl_stmt
name|bool
name|ReorderQueue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, reorder the send queue */
end_comment

begin_decl_stmt
name|int
name|QueuePid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pid of child running queue */
end_comment

begin_macro
name|runqueue
argument_list|(
argument|forkflag
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|forkflag
decl_stmt|;
end_decl_stmt

begin_block
block|{
extern|extern reordersig(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|reordersig
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|QueueIntvl
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|forkflag
condition|)
block|{
name|QueuePid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|QueuePid
operator|>
literal|0
condition|)
block|{
comment|/* parent */
return|return;
block|}
else|else
operator|(
name|void
operator|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		**  Order the existing work requests. 		*/
name|orderq
argument_list|()
expr_stmt|;
if|if
condition|(
name|WorkQ
operator|==
name|NULL
condition|)
block|{
comment|/* no work?  well, maybe later */
if|if
condition|(
name|QueueIntvl
operator|==
literal|0
condition|)
break|break;
name|pause
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|ReorderQueue
operator|=
name|FALSE
expr_stmt|;
comment|/* 		**  Process them once at a time. 		**	The queue could be reordered while we do this to take 		**	new requests into account.  If so, the existing job 		**	will be finished but the next thing taken off WorkQ 		**	may be something else. 		*/
while|while
condition|(
name|WorkQ
operator|!=
name|NULL
condition|)
block|{
name|WORK
modifier|*
name|w
init|=
name|WorkQ
decl_stmt|;
name|WorkQ
operator|=
name|WorkQ
operator|->
name|w_next
expr_stmt|;
name|dowork
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReorderQueue
condition|)
break|break;
block|}
if|if
condition|(
name|QueueIntvl
operator|==
literal|0
condition|)
break|break;
block|}
end_for

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  REORDERSIG -- catch the alarm signal and tell sendmail to reorder queue. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		sets the "reorder work queue" flag. */
end_comment

begin_expr_stmt
unit|reordersig
operator|(
operator|)
block|{
if|if
condition|(
name|QueuePid
operator|==
literal|0
condition|)
block|{
comment|/* we are in a child doing queueing */
name|ReorderQueue
operator|=
name|TRUE
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
comment|/* we are in a parent -- poke child or start new one */
if|if
condition|(
name|kill
argument_list|(
name|QueuePid
argument_list|,
name|SIGALRM
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* no child -- get zombie& start new one */
specifier|static
name|int
name|st
decl_stmt|;
operator|(
name|void
operator|)
name|wait
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|QueuePid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|QueuePid
operator|==
literal|0
condition|)
block|{
comment|/* new child; run queue */
name|runqueue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_else

begin_comment
comment|/* 	**  Arrange to get this signal again. 	*/
end_comment

begin_expr_stmt
operator|(
name|void
operator|)
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
name|QueueIntvl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  ORDERQ -- order the work queue. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Sets WorkQ to the queue of available work, in order. */
end_comment

begin_define
define|#
directive|define
name|WLSIZE
value|120
end_define

begin_comment
comment|/* max size of worklist per sort */
end_comment

begin_expr_stmt
unit|orderq
operator|(
operator|)
block|{ 	struct
name|direct
name|d
block|;
specifier|register
name|WORK
operator|*
name|w
block|;
specifier|register
name|WORK
operator|*
operator|*
name|wp
block|;
comment|/* parent of w */
specifier|register
name|FILE
operator|*
name|f
block|;
specifier|register
name|int
name|i
block|;
name|WORK
name|wlist
index|[
name|WLSIZE
index|]
block|;
name|int
name|wn
operator|=
literal|0
block|;
specifier|extern
name|workcmpf
argument_list|()
block|;
specifier|extern
name|char
operator|*
name|QueueDir
block|;
comment|/* clear out old WorkQ */
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
control|)
block|{
specifier|register
name|WORK
modifier|*
name|nw
init|=
name|w
operator|->
name|w_next
decl_stmt|;
name|WorkQ
operator|=
name|nw
expr_stmt|;
name|free
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|nw
expr_stmt|;
block|}
comment|/* open the queue directory */
name|f
operator|=
name|fopen
argument_list|(
name|QueueDir
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"orderq: cannot open %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_comment
comment|/* 	**  Read the work directory. 	*/
end_comment

begin_while
while|while
condition|(
name|wn
operator|<
name|WLSIZE
operator|&&
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
argument_list|,
sizeof|sizeof
name|d
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
operator|==
literal|1
condition|)
block|{
name|char
name|cbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|FILE
modifier|*
name|cf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* is this an interesting entry? */
if|if
condition|(
name|d
operator|.
name|d_ino
operator|==
literal|0
operator|||
name|d
operator|.
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'c'
condition|)
continue|continue;
comment|/* yes -- find the control file location */
name|strcpy
argument_list|(
name|cbuf
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cbuf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|cbuf
index|[
name|strlen
argument_list|(
name|cbuf
argument_list|)
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|d
operator|.
name|d_name
argument_list|,
name|DIRSIZ
argument_list|)
expr_stmt|;
name|p
index|[
name|DIRSIZ
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* open control file */
name|cf
operator|=
name|fopen
argument_list|(
name|cbuf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"orderq: cannot open %s"
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|wlist
index|[
name|wn
index|]
operator|.
name|w_name
operator|=
name|newstr
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
comment|/* extract useful information */
while|while
condition|(
name|fgets
argument_list|(
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|,
name|cf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fixcrlf
argument_list|(
name|lbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* message priority */
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|&
name|lbuf
index|[
literal|1
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|wlist
index|[
name|wn
index|]
operator|.
name|w_pri
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|wn
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cf
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Sort the work directory. 	*/
end_comment

begin_expr_stmt
name|qsort
argument_list|(
name|wlist
argument_list|,
name|wn
argument_list|,
sizeof|sizeof
expr|*
name|wlist
argument_list|,
name|workcmpf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Convert the work list into canonical form. 	*/
end_comment

begin_expr_stmt
name|wp
operator|=
operator|&
name|WorkQ
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wn
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
operator|(
name|WORK
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|w
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_name
operator|=
name|wlist
index|[
name|i
index|]
operator|.
name|w_name
expr_stmt|;
name|w
operator|->
name|w_pri
operator|=
name|wlist
index|[
name|i
index|]
operator|.
name|w_pri
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|wp
operator|=
name|w
expr_stmt|;
name|wp
operator|=
operator|&
name|w
operator|->
name|w_next
expr_stmt|;
block|}
end_for

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|Debug
condition|)
block|{
for|for
control|(
name|w
operator|=
name|WorkQ
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
name|printf
argument_list|(
literal|"%32s: pri=%ld\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_escape
unit|}
end_escape

begin_comment
comment|/* **	WORKCMPF -- compare function for ordering work. ** **	Parameters: **		a -- the first argument. **		b -- the second argument. ** **	Returns: **		-1 if a< b **		0 if a == b **		1 if a> b ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|PRIFACT
value|1800
end_define

begin_comment
comment|/* bytes each priority point is worth */
end_comment

begin_expr_stmt
unit|workcmpf
operator|(
name|a
operator|,
name|b
operator|)
specifier|register
name|WORK
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|WORK
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|a
operator|->
name|w_pri
operator|==
name|b
operator|->
name|w_pri
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|w_pri
operator|>
name|b
operator|->
name|w_pri
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DOWORK -- do a work request. ** **	Parameters: **		w -- the work request to be satisfied. ** **	Returns: **		none. ** **	Side Effects: **		The work request is satisfied if possible. */
end_comment

begin_expr_stmt
name|dowork
argument_list|(
name|w
argument_list|)
specifier|register
name|WORK
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|xstat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"dowork: %s pri %ld\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|,
name|w
operator|->
name|w_pri
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Fork for work. 	*/
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"dowork: cannot fork"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 		**  CHILD 		*/
name|QueueRun
operator|=
name|TRUE
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
name|initsys
argument_list|()
expr_stmt|;
name|readqf
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|sendall
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"CurTime=%ld, TimeOut=%ld\n"
argument_list|,
name|CurTime
argument_list|,
name|TimeOut
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|QueueUp
operator|&&
name|CurTime
operator|>
name|TimeOut
condition|)
name|timeout
argument_list|(
name|w
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* 	**  Parent -- pick up results. 	*/
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|xstat
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  READQF -- read queue file and set up environment. ** **	Parameters: **		cf -- name of queue control file. ** **	Returns: **		none. ** **	Side Effects: **		cf is read and created as the current job, as though **		we had been invoked by argument. */
end_comment

begin_macro
name|readqf
argument_list|(
argument|cf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|sendto
parameter_list|()
function_decl|;
comment|/* 	**  Open the file created by queueup. 	*/
name|f
operator|=
name|fopen
argument_list|(
name|cf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"readqf: no cf file %s"
argument_list|,
name|cf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  Read and process the file. 	*/
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"Running %s (from %s)"
argument_list|,
name|cf
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fixcrlf
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'R'
case|:
comment|/* specify recipient */
operator|(
name|void
operator|)
name|sendto
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* header */
operator|(
name|void
operator|)
name|chompheader
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* sender */
name|setsender
argument_list|(
name|newstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* data file name */
name|InFileName
operator|=
name|newstr
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TempFile
operator|=
name|fopen
argument_list|(
name|InFileName
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TempFile
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"readqf: cannot open %s"
argument_list|,
name|InFileName
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* timeout */
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|TimeOut
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* message priority */
operator|(
name|void
operator|)
name|sscanf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|MsgPriority
argument_list|)
expr_stmt|;
comment|/* make sure that big things get sent eventually */
name|MsgPriority
operator|-=
name|WKTIMEFACT
expr_stmt|;
break|break;
default|default:
name|syserr
argument_list|(
literal|"readqf(%s): bad line \"%s\""
argument_list|,
name|cf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TIMEOUT -- process timeout on queue file. ** **	Parameters: **		w -- pointer to work request that timed out. ** **	Returns: **		none. ** **	Side Effects: **		Returns a message to the sender saying that this **		message has timed out. */
end_comment

begin_expr_stmt
name|timeout
argument_list|(
name|w
argument_list|)
specifier|register
name|WORK
operator|*
name|w
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"timeout(%s)\n"
argument_list|,
name|w
operator|->
name|w_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* return message to sender */
operator|(
name|void
operator|)
name|returntosender
argument_list|(
literal|"Cannot send mail for three days"
argument_list|)
expr_stmt|;
comment|/* arrange to remove files from queue */
name|QueueUp
operator|=
name|FALSE
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|QUEUE
end_endif

end_unit

