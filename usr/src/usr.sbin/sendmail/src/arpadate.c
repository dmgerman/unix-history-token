begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)arpadate.c	6.5 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* **  ARPADATE -- Create date in ARPANET format ** **	Parameters: **		ud -- unix style date string.  if NULL, one is created. ** **	Returns: **		pointer to an ARPANET date field ** **	Side Effects: **		none ** **	WARNING: **		date is stored in a local buffer -- subsequent **		calls will overwrite. ** **	Bugs: **		Timezone is computed from local time, rather than **		from whereever (and whenever) the message was sent. **		To do better is very hard. ** **		Some sites are now inserting the timezone into the **		local date.  This routine should figure out what **		the format is and work appropriately. */
end_comment

begin_function
name|char
modifier|*
name|arpadate
parameter_list|(
name|ud
parameter_list|)
specifier|register
name|char
modifier|*
name|ud
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|off
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|lt
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
name|gmt
decl_stmt|;
specifier|static
name|char
name|b
index|[
literal|40
index|]
decl_stmt|;
comment|/* 	**  Get current time. 	**	This will be used if a null argument is passed and 	**	to resolve the timezone. 	*/
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ud
operator|==
name|NULL
condition|)
name|ud
operator|=
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
comment|/* 	**  Crack the UNIX date line in a singularly unoriginal way. 	*/
name|q
operator|=
name|b
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|0
index|]
expr_stmt|;
comment|/* Mon */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|8
index|]
expr_stmt|;
comment|/* 16 */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|4
index|]
expr_stmt|;
comment|/* Sep */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|20
index|]
expr_stmt|;
comment|/* 1979 */
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|=
operator|&
name|ud
index|[
literal|11
index|]
expr_stmt|;
comment|/* 01:03:52 */
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* 	 * should really get the timezone from the time in "ud" (which 	 * is only different if a non-null arg was passed which is different 	 * from the current time), but for all practical purposes, returning 	 * the current local zone will do (its all that is ever needed). 	 */
name|gmt
operator|=
operator|*
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|lt
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|lt
operator|->
name|tm_hour
operator|-
name|gmt
operator|.
name|tm_hour
operator|)
operator|*
literal|60
operator|+
name|lt
operator|->
name|tm_min
operator|-
name|gmt
operator|.
name|tm_min
expr_stmt|;
comment|/* assume that offset isn't more than a day ... */
if|if
condition|(
name|lt
operator|->
name|tm_year
operator|<
name|gmt
operator|.
name|tm_year
condition|)
name|off
operator|-=
literal|24
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
operator|->
name|tm_year
operator|>
name|gmt
operator|.
name|tm_year
condition|)
name|off
operator|+=
literal|24
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
operator|->
name|tm_yday
operator|<
name|gmt
operator|.
name|tm_yday
condition|)
name|off
operator|-=
literal|24
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
operator|->
name|tm_yday
operator|>
name|gmt
operator|.
name|tm_yday
condition|)
name|off
operator|+=
literal|24
operator|*
literal|60
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'G'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'M'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'T'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|off
operator|<
literal|0
condition|)
block|{
name|off
operator|=
operator|-
name|off
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
name|off
operator|>=
literal|24
operator|*
literal|60
condition|)
comment|/* should be impossible */
name|off
operator|=
literal|23
operator|*
literal|60
operator|+
literal|59
expr_stmt|;
comment|/* if not, insert silly value */
operator|*
name|q
operator|++
operator|=
operator|(
name|off
operator|/
literal|600
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|off
operator|/
literal|60
operator|)
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|off
operator|%=
literal|60
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|off
operator|/
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|off
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  NEXTATOM -- Return pointer to next atom in header **		(skip whitespace and comments) ** **	Parameters: **		s -- pointer to header string ** **	Returns: **		pointer advanced to next non-comment header atom ** **	Side Effects: **		none */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nextatom
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'('
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|int
name|nested
init|=
literal|0
decl_stmt|;
comment|/* ignore comments */
name|p
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
name|nested
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
condition|)
if|if
condition|(
operator|!
name|nested
condition|)
break|break;
else|else
name|nested
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  ARPATOUNIX -- Convert RFC-822/1123 date-time specification to ctime format. ** **	Parameters: **		s -- pointer to date string ** **	Returns: **		pointer to a string in ctime format ** **	Side Effects: **		Calls asctime() which modifies its static area. ** **	Syntax: **		date-time field specification from RFC822 **		as amended by RFC 1123: ** **			[ day "," ] 1*2DIGIT month 2*4DIGIT \ **			2DIGIT ":" 2DIGIT [ ":" 2DIGIT  ] zone ** **		Day can be "Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun" **			(case-insensitive) **		Month can be "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" **			"Aug" "Sep" "Oct" "Nov" "Dec" (also case-insensitive) **		Zone can be as in the list below. **		Additional whitespace or comments may occur. ** **	Notes: **		It's not clear this routine is valuable, since about the **		only place UNIX dates are used is in the UNIX mailbox **		header, which should probably be delivery time, not **		message creation time.  Oh well, I'll leave this for **		the time being. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|MonthDays
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tzone
block|{
name|char
modifier|*
name|tzname
decl_stmt|;
comment|/* string name */
name|int
name|tzoff
decl_stmt|;
comment|/* offset in hours from GMT */
name|bool
name|tzdst
decl_stmt|;
comment|/* daylight savings */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tzone
name|Zones
index|[]
init|=
block|{
literal|"UT"
block|,
literal|0
block|,
name|FALSE
block|,
literal|"GMT"
block|,
literal|0
block|,
name|FALSE
block|,
literal|"AST"
block|,
operator|-
literal|4
block|,
name|FALSE
block|,
comment|/* Atlantic */
literal|"ADT"
block|,
operator|-
literal|3
block|,
name|TRUE
block|,
literal|"EST"
block|,
operator|-
literal|5
block|,
name|FALSE
block|,
comment|/* Eastern */
literal|"EDT"
block|,
operator|-
literal|4
block|,
name|TRUE
block|,
literal|"CST"
block|,
operator|-
literal|6
block|,
name|FALSE
block|,
comment|/* Central */
literal|"CDT"
block|,
operator|-
literal|5
block|,
name|TRUE
block|,
literal|"MST"
block|,
operator|-
literal|7
block|,
name|FALSE
block|,
comment|/* Mountain */
literal|"MDT"
block|,
operator|-
literal|6
block|,
name|TRUE
block|,
literal|"PST"
block|,
operator|-
literal|8
block|,
name|FALSE
block|,
comment|/* Pacific */
literal|"PDT"
block|,
operator|-
literal|7
block|,
name|TRUE
block|,
literal|"YST"
block|,
operator|-
literal|9
block|,
name|FALSE
block|,
comment|/* Yukon */
literal|"YDT"
block|,
operator|-
literal|8
block|,
name|TRUE
block|,
literal|"JST"
block|,
literal|9
block|,
name|FALSE
block|,
comment|/* Japan */
literal|"AHST"
block|,
operator|-
literal|10
block|,
name|FALSE
block|,
comment|/* Aleutian */
literal|"AHDT"
block|,
operator|-
literal|9
block|,
name|TRUE
block|,
literal|"HAST"
block|,
operator|-
literal|10
block|,
name|FALSE
block|,
comment|/* Aleutian */
literal|"HADT"
block|,
operator|-
literal|9
block|,
name|TRUE
block|,
literal|"NST"
block|,
operator|-
literal|11
block|,
name|FALSE
block|,
comment|/* Nome */
literal|"BST"
block|,
operator|-
literal|11
block|,
name|FALSE
block|,
comment|/* Bering */
literal|"SST"
block|,
operator|-
literal|11
block|,
name|FALSE
block|,
comment|/* Samoa */
literal|"HST"
block|,
operator|-
literal|10
block|,
name|FALSE
block|,
comment|/* Hawaii */
literal|"BST"
block|,
literal|1
block|,
name|TRUE
block|,
literal|"WET"
block|,
literal|0
block|,
name|FALSE
block|,
comment|/* Western European */
literal|"WET DST"
block|,
literal|1
block|,
name|TRUE
block|,
literal|"MET"
block|,
literal|1
block|,
name|FALSE
block|,
comment|/* Middle European */
literal|"MET DST"
block|,
literal|2
block|,
name|TRUE
block|,
literal|"CET"
block|,
literal|1
block|,
name|FALSE
block|,
comment|/* Central European */
literal|"CET DST"
block|,
literal|2
block|,
name|TRUE
block|,
literal|"EET"
block|,
literal|2
block|,
name|FALSE
block|,
comment|/* Eastern European */
literal|"MET DST"
block|,
literal|3
block|,
name|TRUE
block|,
literal|"HKT"
block|,
literal|8
block|,
name|FALSE
block|,
comment|/* Hong Kong */
literal|"IST"
block|,
literal|2
block|,
name|FALSE
block|,
comment|/* Israel */
literal|"IDT"
block|,
literal|3
block|,
name|TRUE
block|,
literal|"KST"
block|,
literal|9
block|,
name|FALSE
block|,
comment|/* Korea */
literal|"KDT"
block|,
literal|10
block|,
name|TRUE
block|,
literal|"SST"
block|,
literal|8
block|,
name|FALSE
block|,
comment|/* Singapore */
literal|"NZST"
block|,
literal|12
block|,
name|FALSE
block|,
comment|/* New Zealand */
literal|"NZDT"
block|,
literal|13
block|,
name|TRUE
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|arpatounix
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|;
name|int
name|h_offset
init|=
literal|0
decl_stmt|;
comment|/* hours */
name|int
name|m_offset
init|=
literal|0
decl_stmt|;
comment|/* minutes */
name|struct
name|tm
name|tm
decl_stmt|;
specifier|register
name|struct
name|tzone
modifier|*
name|z
decl_stmt|;
specifier|extern
name|char
modifier|*
name|DowList
index|[]
decl_stmt|;
comment|/* defined in collect.c */
specifier|extern
name|char
modifier|*
name|MonthList
index|[]
decl_stmt|;
comment|/* defined in collect.c */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tm
argument_list|,
sizeof|sizeof
name|tm
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_wday
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* impossible value */
name|p
operator|=
name|nextatom
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* next atom must be a day or a date */
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* day */
for|for
control|(
name|tm
operator|.
name|tm_wday
operator|=
literal|0
init|;
name|DowList
index|[
name|tm
operator|.
name|tm_wday
index|]
condition|;
name|tm
operator|.
name|tm_wday
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
name|DowList
index|[
name|tm
operator|.
name|tm_wday
index|]
argument_list|,
literal|3
argument_list|)
condition|)
continue|continue;
else|else
block|{
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* ',' */
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|=
name|nextatom
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* now must have date */
name|tm
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
comment|/* skip over date */
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* point to month name */
for|for
control|(
name|tm
operator|.
name|tm_mon
operator|=
literal|0
init|;
name|MonthList
index|[
name|tm
operator|.
name|tm_mon
index|]
condition|;
name|tm
operator|.
name|tm_mon
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
name|MonthList
index|[
name|tm
operator|.
name|tm_mon
index|]
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* year */
name|tm
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* if this was 4 digits, subtract 1900 */
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|>
literal|999
condition|)
name|tm
operator|.
name|tm_year
operator|-=
literal|1900
expr_stmt|;
else|else
block|{
comment|/* if 2 or 3 digits, guess which century and convert */
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|gmt
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|gmt
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* more likely +1 day than -100(0) years */
if|if
condition|(
name|gmt
operator|->
name|tm_mon
operator|==
literal|11
operator|&&
name|gmt
operator|->
name|tm_mday
operator|==
literal|31
operator|&&
name|tm
operator|.
name|tm_mon
operator|==
literal|0
operator|&&
name|tm
operator|.
name|tm_mday
operator|==
literal|1
condition|)
name|gmt
operator|->
name|tm_year
operator|++
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|>
literal|99
condition|)
block|{
comment|/* 3 digits */
name|tm
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|gmt
operator|->
name|tm_year
operator|+
literal|900
operator|-
name|tm
operator|.
name|tm_year
operator|)
operator|/
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
else|else
block|{
comment|/* 2 digits */
name|tm
operator|.
name|tm_year
operator|+=
operator|(
operator|(
name|gmt
operator|->
name|tm_year
operator|-
name|tm
operator|.
name|tm_year
operator|)
operator|/
literal|100
operator|)
operator|*
literal|100
expr_stmt|;
block|}
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
comment|/* skip over year */
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* hours */
name|tm
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
comment|/* skip over hours */
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* colon */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|=
name|nextatom
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* minutes */
name|tm
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
comment|/* skip over minutes */
name|p
operator|++
expr_stmt|;
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* colon or zone */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
comment|/* have seconds field */
block|{
name|p
operator|=
name|nextatom
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
comment|/* skip over seconds */
name|p
operator|++
expr_stmt|;
block|}
name|p
operator|=
name|nextatom
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* zone */
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
block|{
name|int
name|off
decl_stmt|;
name|off
operator|=
name|atoi
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
name|h_offset
operator|=
name|off
operator|/
literal|100
expr_stmt|;
name|m_offset
operator|=
name|off
operator|%
literal|100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|int
name|off
decl_stmt|;
name|off
operator|=
name|atoi
argument_list|(
operator|++
name|p
argument_list|)
expr_stmt|;
name|h_offset
operator|=
name|off
operator|/
operator|-
literal|100
expr_stmt|;
name|m_offset
operator|=
operator|-
literal|1
operator|*
operator|(
name|off
operator|%
literal|100
operator|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|z
operator|=
name|Zones
init|;
name|z
operator|->
name|tzname
operator|!=
name|NULL
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|strncasecmp
argument_list|(
name|p
argument_list|,
name|z
operator|->
name|tzname
argument_list|,
name|strlen
argument_list|(
name|z
operator|->
name|tzname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|z
operator|->
name|tzname
operator|!=
name|NULL
condition|)
block|{
name|h_offset
operator|=
name|z
operator|->
name|tzoff
expr_stmt|;
name|tm
operator|.
name|tm_isdst
operator|=
name|z
operator|->
name|tzdst
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: arpatounix: unparseable date: %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* is the year a leap year? */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|4
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|400
operator|==
literal|0
operator|)
operator|)
condition|)
name|MonthDays
index|[
literal|2
index|]
operator|=
literal|29
expr_stmt|;
else|else
name|MonthDays
index|[
literal|2
index|]
operator|=
literal|28
expr_stmt|;
comment|/* apply offset -- this leaves the date in GMT */
if|if
condition|(
name|h_offset
operator|!=
literal|0
operator|||
name|m_offset
operator|!=
literal|0
condition|)
block|{
name|tm
operator|.
name|tm_min
operator|-=
name|m_offset
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|-=
name|h_offset
expr_stmt|;
comment|/* normalize */
if|if
condition|(
name|tm
operator|.
name|tm_min
operator|<
literal|0
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|--
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|+=
literal|60
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tm
operator|.
name|tm_min
operator|>
literal|59
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|++
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|-=
literal|60
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_hour
operator|<
literal|0
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|--
expr_stmt|;
name|tm
operator|.
name|tm_wday
operator|--
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|+=
literal|24
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tm
operator|.
name|tm_hour
operator|>
literal|23
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|++
expr_stmt|;
name|tm
operator|.
name|tm_wday
operator|++
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|-=
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|tm
operator|.
name|tm_mday
operator|<
literal|1
condition|)
block|{
if|if
condition|(
operator|--
name|tm
operator|.
name|tm_mon
operator|==
operator|-
literal|1
condition|)
block|{
name|tm
operator|.
name|tm_mon
operator|=
literal|11
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|--
expr_stmt|;
comment|/* is the year a leap year? */
if|if
condition|(
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|4
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|||
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|400
operator|==
literal|0
operator|)
operator|)
condition|)
name|MonthDays
index|[
literal|2
index|]
operator|=
literal|29
expr_stmt|;
else|else
name|MonthDays
index|[
literal|2
index|]
operator|=
literal|28
expr_stmt|;
block|}
name|tm
operator|.
name|tm_mday
operator|+=
name|MonthDays
index|[
name|tm
operator|.
name|tm_mon
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tm
operator|.
name|tm_mday
operator|>
name|MonthDays
index|[
name|tm
operator|.
name|tm_mon
index|]
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|-=
name|MonthDays
index|[
name|tm
operator|.
name|tm_mon
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_mon
operator|>
literal|11
condition|)
block|{
name|tm
operator|.
name|tm_mon
operator|=
literal|0
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|++
expr_stmt|;
comment|/* 				* Don't have to worry about leap years in 				* January. 				*/
block|}
block|}
block|}
comment|/* determine day of week if not set from RFC822/1123 line */
if|if
condition|(
name|tm
operator|.
name|tm_wday
operator|<
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tm
operator|.
name|tm_mon
condition|;
name|i
operator|++
control|)
name|tm
operator|.
name|tm_yday
operator|+=
name|MonthDays
index|[
name|i
index|]
expr_stmt|;
name|tm
operator|.
name|tm_yday
operator|+=
name|tm
operator|.
name|tm_mday
expr_stmt|;
comment|/* I wouldn't change these constants if I were you... */
name|tm
operator|.
name|tm_wday
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|699L
operator|)
operator|*
literal|146097L
operator|)
operator|/
literal|400L
operator|)
operator|+
name|tm
operator|.
name|tm_yday
operator|)
operator|%
literal|7
argument_list|)
expr_stmt|;
block|}
comment|/* now get UT */
if|if
condition|(
operator|(
name|p
operator|=
name|asctime
argument_list|(
operator|&
name|tm
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|p
argument_list|)
operator|<
literal|25
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: arpatounix: asctime failed: %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

