begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SMTP
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)srvrsmtp.c	8.28 (Berkeley) %G% (with SMTP)"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)srvrsmtp.c	8.28 (Berkeley) %G% (without SMTP)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMTP
end_ifdef

begin_comment
comment|/* **  SMTP -- run the SMTP protocol. ** **	Parameters: **		none. ** **	Returns: **		never. ** **	Side Effects: **		Reads commands from the input channel and processes **			them. */
end_comment

begin_struct
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmdname
decl_stmt|;
comment|/* command name */
name|int
name|cmdcode
decl_stmt|;
comment|/* internal code, see below */
block|}
struct|;
end_struct

begin_comment
comment|/* values for cmdcode */
end_comment

begin_define
define|#
directive|define
name|CMDERROR
value|0
end_define

begin_comment
comment|/* bad command */
end_comment

begin_define
define|#
directive|define
name|CMDMAIL
value|1
end_define

begin_comment
comment|/* mail -- designate sender */
end_comment

begin_define
define|#
directive|define
name|CMDRCPT
value|2
end_define

begin_comment
comment|/* rcpt -- designate recipient */
end_comment

begin_define
define|#
directive|define
name|CMDDATA
value|3
end_define

begin_comment
comment|/* data -- send message text */
end_comment

begin_define
define|#
directive|define
name|CMDHOPS
value|4
end_define

begin_comment
comment|/* hops -- specify hop count */
end_comment

begin_define
define|#
directive|define
name|CMDRSET
value|4
end_define

begin_comment
comment|/* rset -- reset state */
end_comment

begin_define
define|#
directive|define
name|CMDVRFY
value|5
end_define

begin_comment
comment|/* vrfy -- verify address */
end_comment

begin_define
define|#
directive|define
name|CMDEXPN
value|6
end_define

begin_comment
comment|/* expn -- expand address */
end_comment

begin_define
define|#
directive|define
name|CMDNOOP
value|7
end_define

begin_comment
comment|/* noop -- do nothing */
end_comment

begin_define
define|#
directive|define
name|CMDQUIT
value|8
end_define

begin_comment
comment|/* quit -- close connection and die */
end_comment

begin_define
define|#
directive|define
name|CMDHELO
value|9
end_define

begin_comment
comment|/* helo -- be polite */
end_comment

begin_define
define|#
directive|define
name|CMDHELP
value|10
end_define

begin_comment
comment|/* help -- give usage info */
end_comment

begin_define
define|#
directive|define
name|CMDEHLO
value|11
end_define

begin_comment
comment|/* ehlo -- extended helo (RFC 1425) */
end_comment

begin_comment
comment|/* non-standard commands */
end_comment

begin_define
define|#
directive|define
name|CMDONEX
value|16
end_define

begin_comment
comment|/* onex -- sending one transaction only */
end_comment

begin_define
define|#
directive|define
name|CMDVERB
value|17
end_define

begin_comment
comment|/* verb -- go into verbose mode */
end_comment

begin_comment
comment|/* use this to catch and log "door handle" attempts on your system */
end_comment

begin_define
define|#
directive|define
name|CMDLOGBOGUS
value|23
end_define

begin_comment
comment|/* bogus command that should be logged */
end_comment

begin_comment
comment|/* debugging-only commands, only enabled if SMTPDEBUG is defined */
end_comment

begin_define
define|#
directive|define
name|CMDDBGQSHOW
value|24
end_define

begin_comment
comment|/* showq -- show send queue */
end_comment

begin_define
define|#
directive|define
name|CMDDBGDEBUG
value|25
end_define

begin_comment
comment|/* debug -- set debug mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd
name|CmdTab
index|[]
init|=
block|{
literal|"mail"
block|,
name|CMDMAIL
block|,
literal|"rcpt"
block|,
name|CMDRCPT
block|,
literal|"data"
block|,
name|CMDDATA
block|,
literal|"rset"
block|,
name|CMDRSET
block|,
literal|"vrfy"
block|,
name|CMDVRFY
block|,
literal|"expn"
block|,
name|CMDEXPN
block|,
literal|"expn"
block|,
name|CMDVRFY
block|,
literal|"help"
block|,
name|CMDHELP
block|,
literal|"noop"
block|,
name|CMDNOOP
block|,
literal|"quit"
block|,
name|CMDQUIT
block|,
literal|"helo"
block|,
name|CMDHELO
block|,
literal|"ehlo"
block|,
name|CMDEHLO
block|,
literal|"verb"
block|,
name|CMDVERB
block|,
literal|"onex"
block|,
name|CMDONEX
block|,
literal|"hops"
block|,
name|CMDHOPS
block|,
comment|/* 	 * remaining commands are here only 	 * to trap and log attempts to use them 	 */
literal|"showq"
block|,
name|CMDDBGQSHOW
block|,
literal|"debug"
block|,
name|CMDDBGDEBUG
block|,
literal|"wiz"
block|,
name|CMDLOGBOGUS
block|,
name|NULL
block|,
name|CMDERROR
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|OneXact
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one xaction only this run */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CurSmtpClient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* who's at the other end of channel */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|skipword
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|smtp
argument_list|(
name|e
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|sendto
parameter_list|()
function_decl|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
name|hasmail
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
operator|!=
name|fileno
argument_list|(
name|stdout
argument_list|)
condition|)
block|{
comment|/* arrange for debugging output to go to remote host */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|settime
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|peerhostname
operator|=
name|RealHostName
expr_stmt|;
if|if
condition|(
name|peerhostname
operator|==
name|NULL
condition|)
name|peerhostname
operator|=
literal|"localhost"
expr_stmt|;
name|CurHostName
operator|=
name|peerhostname
expr_stmt|;
name|CurSmtpClient
operator|=
name|macvalue
argument_list|(
literal|'_'
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|CurSmtpClient
operator|==
name|NULL
condition|)
name|CurSmtpClient
operator|=
name|CurHostName
expr_stmt|;
name|setproctitle
argument_list|(
literal|"server %s startup"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"\201e"
argument_list|,
name|inp
argument_list|,
operator|&
name|inp
index|[
sizeof|sizeof
name|inp
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|BrokenSmtpPeers
condition|)
block|{
name|message
argument_list|(
literal|"220 %s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
literal|"220-%s"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"220 ESMTP spoken here"
argument_list|)
expr_stmt|;
block|}
name|protocol
operator|=
name|NULL
expr_stmt|;
name|sendinghost
operator|=
name|macvalue
argument_list|(
literal|'s'
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|gothello
operator|=
name|FALSE
expr_stmt|;
name|gotmail
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* arrange for backout */
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* if() nesting is necessary for Cray UNICOS */
if|if
condition|(
name|InChild
condition|)
block|{
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
block|}
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|HoldErrs
operator|=
name|FALSE
expr_stmt|;
name|LogUsrErrs
operator|=
name|FALSE
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
operator|(
name|EF_VRFYONLY
operator||
name|EF_GLOBALERRS
operator|)
expr_stmt|;
comment|/* setup for the read */
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|Errors
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* read the input line */
name|SmtpPhase
operator|=
literal|"server cmd read"
expr_stmt|;
name|setproctitle
argument_list|(
literal|"server %s cmd read"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|p
operator|=
name|sfgets
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
name|inp
argument_list|,
name|InChannel
argument_list|,
name|TimeOuts
operator|.
name|to_nextcommand
argument_list|,
name|SmtpPhase
argument_list|)
expr_stmt|;
comment|/* handle errors */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* end of file, just die */
name|message
argument_list|(
literal|"421 %s Lost input channel from %s"
argument_list|,
name|MyHostName
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
operator|(
name|gotmail
condition|?
literal|1
else|:
literal|19
operator|)
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"lost input channel from %s"
argument_list|,
name|CurSmtpClient
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|InChild
condition|)
name|ExitStat
operator|=
name|EX_QUIT
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* clean up end of line */
name|fixcrlf
argument_list|(
name|inp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* echo command to transcript */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"<<< %s\n"
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
name|setproctitle
argument_list|(
literal|"%s: %.80s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
else|else
name|setproctitle
argument_list|(
literal|"%s %s: %.80s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* break off command */
for|for
control|(
name|p
operator|=
name|inp
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|cmd
operator|=
name|cmdbuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
name|cmd
operator|<
operator|&
name|cmdbuf
index|[
sizeof|sizeof
name|cmdbuf
operator|-
literal|2
index|]
condition|)
operator|*
name|cmd
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|cmd
operator|=
literal|'\0'
expr_stmt|;
comment|/* throw away leading whitespace */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* decode command */
for|for
control|(
name|c
operator|=
name|CmdTab
init|;
name|c
operator|->
name|cmdname
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|c
operator|->
name|cmdname
argument_list|,
name|cmdbuf
argument_list|)
condition|)
break|break;
block|}
comment|/* reset errors */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* process command */
switch|switch
condition|(
name|c
operator|->
name|cmdcode
condition|)
block|{
case|case
name|CMDHELO
case|:
comment|/* hello -- introduce yourself */
case|case
name|CMDEHLO
case|:
comment|/* extended hello */
if|if
condition|(
name|c
operator|->
name|cmdcode
operator|==
name|CMDEHLO
condition|)
block|{
name|protocol
operator|=
literal|"ESMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server EHLO"
expr_stmt|;
block|}
else|else
block|{
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|SmtpPhase
operator|=
literal|"server HELO"
expr_stmt|;
block|}
name|sendinghost
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"250"
argument_list|,
literal|"%s Hello %s, pleased to meet you"
argument_list|,
name|HostName
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDMAIL
case|:
comment|/* mail -- designate sender */
name|SmtpPhase
operator|=
literal|"server MAIL"
expr_stmt|;
comment|/* check for validity of this command */
if|if
condition|(
operator|!
name|gothello
condition|)
block|{
comment|/* set sending host to our known value */
if|if
condition|(
name|sendinghost
operator|==
name|NULL
condition|)
name|sendinghost
operator|=
name|peerhostname
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NEEDMAILHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"503 Polite people say HELO first"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|gotmail
condition|)
block|{
name|message
argument_list|(
literal|"503 Sender already specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|InChild
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"503 Nested MAIL command: MAIL %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* fork a subprocess to process this command */
if|if
condition|(
name|runinchild
argument_list|(
literal|"SMTP-MAIL"
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|gothello
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"Host %s didn't use HELO protocol"
argument_list|,
name|peerhostname
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PICKY_HELO_CHECK
if|if
condition|(
name|strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|peerhostname
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|peerhostname
argument_list|,
literal|"localhost"
argument_list|)
operator|!=
literal|0
operator|||
name|strcasecmp
argument_list|(
name|sendinghost
argument_list|,
name|MyHostName
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|auth_warning
argument_list|(
name|e
argument_list|,
literal|"Host %s claimed to be %s"
argument_list|,
name|peerhostname
argument_list|,
name|sendinghost
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|protocol
operator|==
name|NULL
condition|)
name|protocol
operator|=
literal|"SMTP"
expr_stmt|;
name|define
argument_list|(
literal|'r'
argument_list|,
name|protocol
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'s'
argument_list|,
name|sendinghost
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|initsys
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|nrcpts
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_LOGSENDER
expr_stmt|;
name|setproctitle
argument_list|(
literal|"%s %s: %.80s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* child -- go do the processing */
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* this failed -- undo work */
if|if
condition|(
name|InChild
condition|)
block|{
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
comment|/* must parse sender first */
name|delimptr
operator|=
name|NULL
expr_stmt|;
name|setsender
argument_list|(
name|p
argument_list|,
name|e
argument_list|,
operator|&
name|delimptr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* now parse ESMTP arguments */
name|msize
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
name|char
modifier|*
name|kp
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
comment|/* locate the beginning of the keyword */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|kp
operator|=
name|p
expr_stmt|;
comment|/* skip to the value portion */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|vp
operator|=
name|p
expr_stmt|;
comment|/* skip to the end of the value */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|iscntrl
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|19
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"MAIL: got arg %s=%s\n"
argument_list|,
name|kp
argument_list|,
name|vp
operator|==
name|NULL
condition|?
literal|"<null>"
else|:
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 SIZE requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|msize
operator|=
name|atol
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|kp
argument_list|,
literal|"body"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"501 BODY requires a value"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
ifdef|#
directive|ifdef
name|MIME
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"8bitmime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|e_bodytype
operator|=
literal|"8BITMIME"
expr_stmt|;
name|SevenBit
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|vp
argument_list|,
literal|"7bit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|e
operator|->
name|e_bodytype
operator|=
literal|"7BIT"
expr_stmt|;
name|SevenBit
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 Unknown BODY type %s"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|usrerr
argument_list|(
literal|"501 %s parameter unrecognized"
argument_list|,
name|kp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
if|if
condition|(
name|MaxMessageSize
operator|>
literal|0
operator|&&
name|msize
operator|>
name|MaxMessageSize
condition|)
block|{
name|usrerr
argument_list|(
literal|"552 Message size exceeds fixed maximum message size (%ld)"
argument_list|,
name|MaxMessageSize
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|enoughspace
argument_list|(
name|msize
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"452 Insufficient disk space; try again later"
argument_list|)
expr_stmt|;
break|break;
block|}
name|message
argument_list|(
literal|"250 Sender ok"
argument_list|)
expr_stmt|;
name|gotmail
operator|=
name|TRUE
expr_stmt|;
comment|/* optimize: non-interactive, don't expand aliases */
if|if
condition|(
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_DELIVER
condition|)
name|e
operator|->
name|e_flags
operator||=
name|EF_VRFYONLY
expr_stmt|;
break|break;
case|case
name|CMDRCPT
case|:
comment|/* rcpt -- designate recipient */
if|if
condition|(
operator|!
name|gotmail
condition|)
block|{
name|usrerr
argument_list|(
literal|"503 Need MAIL before RCPT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|SmtpPhase
operator|=
literal|"server RCPT"
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|TopFrame
argument_list|)
operator|>
literal|0
condition|)
block|{
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
break|break;
block|}
name|QuickAbort
operator|=
name|TRUE
expr_stmt|;
name|LogUsrErrs
operator|=
name|TRUE
expr_stmt|;
name|p
operator|=
name|skipword
argument_list|(
name|p
argument_list|,
literal|"to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|a
operator|=
name|sendto
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|1
condition|)
name|printaddr
argument_list|(
name|a
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|Errors
operator|!=
literal|0
condition|)
break|break;
comment|/* no errors during parsing, but might be a duplicate */
name|e
operator|->
name|e_to
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"250 Recipient ok%s"
argument_list|,
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|?
literal|" (will queue)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|nrcpts
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* punt -- should keep message in ADDRESS.... */
name|message
argument_list|(
literal|"550 Addressee unknown"
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CMDDATA
case|:
comment|/* data -- text of mail */
name|SmtpPhase
operator|=
literal|"server DATA"
expr_stmt|;
if|if
condition|(
operator|!
name|gotmail
condition|)
block|{
name|message
argument_list|(
literal|"503 Need MAIL command"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|nrcpts
operator|<=
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"503 Need RCPT (recipient)"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check to see if we need to re-expand aliases */
comment|/* also reset QBADADDR on already-diagnosted addrs */
name|doublequeue
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* need to re-expand aliases */
name|doublequeue
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* make this "go away" */
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
name|a
operator|->
name|q_flags
operator|&=
operator|~
name|QBADADDR
expr_stmt|;
block|}
block|}
comment|/* collect the text of the message */
name|SmtpPhase
operator|=
literal|"collect"
expr_stmt|;
name|collect
argument_list|(
name|TRUE
argument_list|,
name|doublequeue
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|Errors
operator|!=
literal|0
condition|)
goto|goto
name|abortmessage
goto|;
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
comment|/* 			**  Arrange to send to everyone. 			**	If sending to multiple people, mail back 			**		errors rather than reporting directly. 			**	In any case, don't mail back errors for 			**		anything that has happened up to 			**		now (the other end will do this). 			**	Truncate our transcript -- the mail has gotten 			**		to us successfully, and if we have 			**		to mail this back, it will be easier 			**		on the reader. 			**	Then send to everyone. 			**	Finally give a reply code.  If an error has 			**		already been given, don't mail a 			**		message back. 			**	We goose error returns by clearing error bit. 			*/
name|SmtpPhase
operator|=
literal|"delivery"
expr_stmt|;
if|if
condition|(
name|nrcpts
operator|!=
literal|1
operator|&&
operator|!
name|doublequeue
condition|)
block|{
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
block|}
name|e
operator|->
name|e_xfp
operator|=
name|freopen
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'x'
argument_list|)
argument_list|,
literal|"w"
argument_list|,
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
name|id
operator|=
name|e
operator|->
name|e_id
expr_stmt|;
comment|/* send to all recipients */
name|sendall
argument_list|(
name|e
argument_list|,
name|Verbose
condition|?
name|SM_DELIVER
else|:
name|SM_QUEUE
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* issue success if appropriate and reset */
if|if
condition|(
name|Errors
operator|==
literal|0
operator|||
name|HoldErrs
condition|)
name|message
argument_list|(
literal|"250 %s Message accepted for delivery"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|HoldErrs
condition|)
block|{
comment|/* avoid sending back an extra message */
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_FATALERRS
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
block|}
else|else
block|{
comment|/* from now on, we have to operate silently */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
comment|/* if we just queued, poke it */
if|if
condition|(
name|doublequeue
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_QUEUE
condition|)
block|{
specifier|extern
name|pid_t
name|dowork
parameter_list|()
function_decl|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dowork
argument_list|(
name|id
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now make it really happen */
if|if
condition|(
operator|!
name|Verbose
operator|&&
name|e
operator|->
name|e_sendmode
operator|!=
name|SM_QUEUE
condition|)
name|dowork
argument_list|(
name|id
argument_list|,
name|TRUE
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|abortmessage
label|:
comment|/* if in a child, pop back to our parent */
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|()
expr_stmt|;
comment|/* clean up a bit */
name|gotmail
operator|=
name|FALSE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|e
operator|=
name|newenvelope
argument_list|(
name|e
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
break|break;
case|case
name|CMDRSET
case|:
comment|/* rset -- reset state */
name|message
argument_list|(
literal|"250 Reset state"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|finis
argument_list|()
expr_stmt|;
comment|/* clean up a bit */
name|gotmail
operator|=
name|FALSE
expr_stmt|;
name|dropenvelope
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|CurEnv
operator|=
name|e
operator|=
name|newenvelope
argument_list|(
name|e
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDVRFY
case|:
comment|/* vrfy -- verify address */
case|case
name|CMDEXPN
case|:
comment|/* expn -- expand address */
name|vrfy
operator|=
name|c
operator|->
name|cmdcode
operator|==
name|CMDVRFY
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NOVRFY
else|:
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
if|if
condition|(
name|vrfy
condition|)
name|message
argument_list|(
literal|"252 Who's to say?"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"502 Sorry, we do not allow this operation"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: %s [rejected]"
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|gothello
operator|&&
name|bitset
argument_list|(
name|vrfy
condition|?
name|PRIV_NEEDVRFYHELO
else|:
name|PRIV_NEEDEXPNHELO
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"503 I demand that you introduce yourself first"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|runinchild
argument_list|(
name|vrfy
condition|?
literal|"SMTP-VRFY"
else|:
literal|"SMTP-EXPN"
argument_list|,
name|e
argument_list|)
operator|>
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|5
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: %s"
argument_list|,
name|CurSmtpClient
argument_list|,
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|paddrtree
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDHELP
case|:
comment|/* help -- give user info */
name|help
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDNOOP
case|:
comment|/* noop -- do nothing */
name|message
argument_list|(
literal|"250 OK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDQUIT
case|:
comment|/* quit -- leave mail */
name|message
argument_list|(
literal|"221 %s closing connection"
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
comment|/* avoid future 050 messages */
name|Verbose
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|InChild
condition|)
name|ExitStat
operator|=
name|EX_QUIT
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
case|case
name|CMDVERB
case|:
comment|/* set verbose mode */
if|if
condition|(
name|bitset
argument_list|(
name|PRIV_NOEXPN
argument_list|,
name|PrivacyFlags
argument_list|)
condition|)
block|{
comment|/* this would give out the same info */
name|message
argument_list|(
literal|"502 Verbose unavailable"
argument_list|)
expr_stmt|;
break|break;
block|}
name|Verbose
operator|=
name|TRUE
expr_stmt|;
name|e
operator|->
name|e_sendmode
operator|=
name|SM_DELIVER
expr_stmt|;
name|message
argument_list|(
literal|"250 Verbose mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDONEX
case|:
comment|/* doing one transaction only */
name|OneXact
operator|=
name|TRUE
expr_stmt|;
name|message
argument_list|(
literal|"250 Only one transaction"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SMTPDEBUG
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
name|printf
argument_list|(
literal|"Send Queue="
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"200 Debug set"
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* not SMTPDEBUG */
case|case
name|CMDDBGQSHOW
case|:
comment|/* show queues */
case|case
name|CMDDBGDEBUG
case|:
comment|/* set debug mode */
endif|#
directive|endif
comment|/* SMTPDEBUG */
case|case
name|CMDLOGBOGUS
case|:
comment|/* bogus command */
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"\"%s\" command from %s (%s)"
argument_list|,
name|c
operator|->
name|cmdname
argument_list|,
name|peerhostname
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|RealHostAddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FALL THROUGH */
case|case
name|CMDERROR
case|:
comment|/* unknown command */
name|message
argument_list|(
literal|"500 Command unrecognized"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"500 smtp: unknown code %d"
argument_list|,
name|c
operator|->
name|cmdcode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SKIPWORD -- skip a fixed word. ** **	Parameters: **		p -- place to start looking. **		w -- word to skip. ** **	Returns: **		p following w. **		NULL on error. ** **	Side Effects: **		clobbers the p data area. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skipword
parameter_list|(
name|p
parameter_list|,
name|w
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|firstp
init|=
name|p
decl_stmt|;
comment|/* find beginning of word */
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
comment|/* find end of word */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
block|{
name|syntax
label|:
name|message
argument_list|(
literal|"501 Syntax error in parameters scanning \"%s\""
argument_list|,
name|firstp
argument_list|)
expr_stmt|;
name|Errors
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
goto|goto
name|syntax
goto|;
comment|/* see if the input word matches desired word */
if|if
condition|(
name|strcasecmp
argument_list|(
name|q
argument_list|,
name|w
argument_list|)
condition|)
goto|goto
name|syntax
goto|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  PRINTVRFYADDR -- print an entry in the verify queue ** **	Parameters: **		a -- the address to print **		last -- set if this is the last one. ** **	Returns: **		none. ** **	Side Effects: **		Prints the appropriate 250 codes. */
end_comment

begin_expr_stmt
name|printvrfyaddr
argument_list|(
name|a
argument_list|,
name|last
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|fmtbuf
index|[
literal|20
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|fmtbuf
argument_list|,
literal|"250"
argument_list|)
expr_stmt|;
name|fmtbuf
index|[
literal|3
index|]
operator|=
name|last
condition|?
literal|' '
else|:
literal|'-'
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_fullname
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"<%s@%s>"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"<%s>"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"%s<%s@%s>"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
operator|&
name|fmtbuf
index|[
literal|4
index|]
argument_list|,
literal|"%s<%s>"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|fmtbuf
argument_list|,
name|a
operator|->
name|q_fullname
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  HELP -- implement the HELP command. ** **	Parameters: **		topic -- the topic we want help for. ** **	Returns: **		none. ** **	Side Effects: **		outputs the help file to message output. */
end_comment

begin_macro
name|help
argument_list|(
argument|topic
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|topic
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|hf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|bool
name|noinfo
decl_stmt|;
if|if
condition|(
name|HelpFile
operator|==
name|NULL
operator|||
operator|(
name|hf
operator|=
name|fopen
argument_list|(
name|HelpFile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no help */
name|errno
operator|=
literal|0
expr_stmt|;
name|message
argument_list|(
literal|"502 HELP not implemented"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|topic
operator|==
name|NULL
operator|||
operator|*
name|topic
operator|==
literal|'\0'
condition|)
name|topic
operator|=
literal|"smtp"
expr_stmt|;
else|else
name|makelower
argument_list|(
name|topic
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|topic
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|hf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|topic
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|buf
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|fixcrlf
argument_list|(
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"214-%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|noinfo
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noinfo
condition|)
name|message
argument_list|(
literal|"504 HELP topic unknown"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"214 End of HELP info"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hf
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RUNINCHILD -- return twice -- once in the child, then in the parent again ** **	Parameters: **		label -- a string used in error messages ** **	Returns: **		zero in the child **		one in the parent ** **	Side Effects: **		none. */
end_comment

begin_macro
name|runinchild
argument_list|(
argument|label
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|childpid
decl_stmt|;
if|if
condition|(
operator|!
name|OneXact
condition|)
block|{
name|childpid
operator|=
name|dofork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s: cannot fork"
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|childpid
operator|>
literal|0
condition|)
block|{
specifier|auto
name|int
name|st
decl_stmt|;
comment|/* parent -- wait for child to complete */
name|setproctitle
argument_list|(
literal|"server %s child wait"
argument_list|,
name|CurHostName
argument_list|)
expr_stmt|;
name|st
operator|=
name|waitfor
argument_list|(
name|childpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
operator|-
literal|1
condition|)
name|syserr
argument_list|(
literal|"%s: lost child"
argument_list|,
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
name|syserr
argument_list|(
literal|"%s: died on signal %d"
argument_list|,
name|label
argument_list|,
name|st
operator|&
literal|0177
argument_list|)
expr_stmt|;
comment|/* if we exited on a QUIT command, complete the process */
if|if
condition|(
name|st
operator|==
operator|(
name|EX_QUIT
operator|<<
literal|8
operator|)
condition|)
name|finis
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* child */
name|InChild
operator|=
name|TRUE
expr_stmt|;
name|QuickAbort
operator|=
name|FALSE
expr_stmt|;
name|clearenvelope
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* open alias database */
name|initmaps
argument_list|(
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PADDRTREE -- print address tree ** **	Used by VRFY and EXPD to dump the tree of addresses produced. ** **	Parameters: **		a -- address of root. ** **	Returns: **		none. ** **	Side Effects: **		prints the tree in a nice order. */
end_comment

begin_expr_stmt
name|paddrtree
argument_list|(
name|a
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|ADDRESS
modifier|*
name|prev
decl_stmt|;
specifier|static
name|int
name|lev
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return;
name|lev
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|q_fullname
operator|!=
name|NULL
condition|)
name|message
argument_list|(
literal|"250-"
argument_list|,
literal|"%s<%s>"
argument_list|,
name|prev
operator|->
name|q_fullname
argument_list|,
name|prev
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250-"
argument_list|,
literal|"<%s>"
argument_list|,
name|prev
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|a
expr_stmt|;
block|}
name|paddrtree
argument_list|(
name|a
operator|->
name|q_child
argument_list|)
expr_stmt|;
name|paddrtree
argument_list|(
name|a
operator|->
name|q_sibling
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|lev
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
comment|/* last one */
if|if
condition|(
name|prev
operator|->
name|q_fullname
operator|!=
name|NULL
condition|)
name|message
argument_list|(
literal|"250"
argument_list|,
literal|"%s<%s>"
argument_list|,
name|prev
operator|->
name|q_fullname
argument_list|,
name|prev
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
literal|"250"
argument_list|,
literal|"<%s>"
argument_list|,
name|prev
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|message
argument_list|(
literal|"550"
argument_list|,
literal|"User unknown"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

end_unit

