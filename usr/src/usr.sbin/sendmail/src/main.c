begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	6.19 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NAMED_BIND
end_ifdef

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
name|char
name|edata
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by tables read in from /usr/lib/sendmail.cf **	(read by readcf.c).  Some more static configuration info, **	including some code that you may want to tailor for your **	installation, is in conf.c.  You may also want to touch **	daemon.c (if you have some other IPC mechanism), acct.c **	(to change your accounting), names.c (to adjust the name **	server mechanism). ** **	Usage: **		/usr/lib/sendmail [flags] addr ... ** **		See the associated documentation for details. ** **	Author: **		Eric Allman, UCB/INGRES (until 10/81) **			     Britton-Lee, Inc., purveyors of fine **				database computers (from 11/81) **			     Now back at UCB at the Mammoth project. **		The support of the INGRES Project and Britton-Lee is **			gratefully acknowledged.  Britton-Lee in **			particular had absolutely nothing to gain from **			my involvement in this project. */
end_comment

begin_decl_stmt
name|int
name|NextMailer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "free" index into Mailer struct */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a "blank" envelope */
end_comment

begin_decl_stmt
name|ENVELOPE
name|MainEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the envelope around the basic letter */
end_comment

begin_decl_stmt
name|ADDRESS
name|NullAddress
init|=
comment|/* a null address */
block|{
literal|""
block|,
literal|""
block|,
name|NULL
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|UserEnviron
index|[
name|MAXUSERENVIRON
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* saved user environment */
end_comment

begin_comment
comment|/* **  Pointers for setproctitle. **	This allows "ps" listings to give more useful information. **	These must be kept out of BSS for frozen configuration files **		to work. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SETPROCTITLE
end_ifdef

begin_decl_stmt
name|char
modifier|*
modifier|*
name|Argv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to argument vector */
end_comment

begin_decl_stmt
name|char
modifier|*
name|LastArgv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of argv */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SETPROCTITLE */
end_comment

begin_comment
comment|/* **  The file in which to log raw recipient information. **	This is logged before aliasing, forwarding, and so forth so we **	can see how our addresses are being used.  For example, this **	would give us the names of aliases (instead of what they alias **	to), the pre-MX hostnames, and so forth. ** **	This is specified on the command line, not in the config file, **	and is therefore really only useful for logging SMTP RCPTs. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|RcptLogFile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name */
end_comment

begin_function_decl
specifier|static
name|void
name|obsolete
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DAEMON
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SMTP
end_ifndef

begin_expr_stmt
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|daemon
name|mode
name|without
name|SMTP
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
comment|/* SMTP */
endif|#
directive|endif
comment|/* DAEMON */
define|#
directive|define
name|MAXCONFIGLEVEL
value|3
comment|/* highest config version level known */
expr|main
operator|(
name|argc
operator|,
name|argv
operator|,
name|envp
operator|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|locname
decl_stmt|;
specifier|extern
name|int
name|finis
parameter_list|()
function_decl|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|from
decl_stmt|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|fnptr
function_decl|)
parameter_list|()
function_decl|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|bool
name|readconfig
init|=
name|TRUE
decl_stmt|;
name|bool
name|queuemode
init|=
name|FALSE
decl_stmt|;
comment|/* process queue requests */
name|bool
name|nothaw
decl_stmt|;
name|bool
name|safecf
init|=
name|TRUE
decl_stmt|;
specifier|static
name|bool
name|reenter
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|argv0
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
name|jbuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
comment|/* holds MyHostName */
specifier|extern
name|int
name|DtableSize
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|bool
name|safefile
parameter_list|()
function_decl|;
specifier|extern
name|time_t
name|convtime
parameter_list|()
function_decl|;
extern|extern putheader(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|putbody
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ENVELOPE
modifier|*
name|newenvelope
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|intsig
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|myhostname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	**  Check to see if we reentered. 	**	This would normally happen if e_putheader or e_putbody 	**	were NULL when invoked. 	*/
end_comment

begin_if
if|if
condition|(
name|reenter
condition|)
block|{
name|syserr
argument_list|(
literal|"main: reentered!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|reenter
operator|=
name|TRUE
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|bool
name|canrename
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SYS5TZ
end_ifndef

begin_comment
comment|/* enforce use of kernel-supplied time zone information */
end_comment

begin_expr_stmt
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* in 4.4BSD, the table can be huge; impose a reasonable limit */
end_comment

begin_expr_stmt
name|DtableSize
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|DtableSize
operator|>
literal|256
condition|)
name|DtableSize
operator|=
literal|256
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Be sure we have enough file descriptors. 	**	But also be sure that 0, 1,& 2 are open. 	*/
end_comment

begin_expr_stmt
name|i
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|2
condition|)
name|i
operator|=
name|dup
argument_list|(
name|i
argument_list|)
expr_stmt|;
end_while

begin_expr_stmt
name|i
operator|=
name|DtableSize
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|STDIN_FILENO
operator|&&
name|i
operator|!=
name|STDOUT_FILENO
operator|&&
name|i
operator|!=
name|STDERR_FILENO
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG_MAIL
end_ifdef

begin_expr_stmt
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_MAIL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	**  Set default values for variables. 	**	These cannot be in initialized data space. 	*/
end_comment

begin_expr_stmt
name|setdefaults
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* set up the blank envelope */
end_comment

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_putbody
operator|=
name|putbody
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_xfp
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRUCTCOPY
argument_list|(
name|NullAddress
argument_list|,
name|BlankEnvelope
operator|.
name|e_from
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STRUCTCOPY
argument_list|(
name|BlankEnvelope
argument_list|,
name|MainEnvelope
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CurEnv
operator|=
operator|&
name|MainEnvelope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Handle any non-getoptable constructions. */
end_comment

begin_expr_stmt
name|obsolete
argument_list|(
name|argv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Do a quick prescan of the argument list. 	**	We do this to find out if we can potentially thaw the 	**	configuration file.  If not, we do the thaw now so that 	**	the argument processing applies to this run rather than 	**	to the run that froze the configuration. 	*/
end_comment

begin_expr_stmt
name|nothaw
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|OPTIONS
value|"b:C:cd:e:F:f:h:Iimno:p:q:R:r:sTtv"
end_define

begin_while
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'z'
operator|&&
name|optarg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|nothaw
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|ConfFile
operator|=
name|optarg
expr_stmt|;
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|getrgid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getruid
argument_list|()
argument_list|)
expr_stmt|;
name|safecf
operator|=
name|FALSE
expr_stmt|;
name|nothaw
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_while

begin_expr_stmt
name|InChannel
operator|=
name|stdin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OutChannel
operator|=
name|stdout
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|nothaw
condition|)
name|readconfig
operator|=
operator|!
name|thaw
argument_list|(
name|FreezeFile
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SETPROCTITLE
end_ifdef

begin_comment
comment|/* 	**  Move the environment so setproctitle can use the space at 	**  the top of memory. 	*/
end_comment

begin_for
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXUSERENVIRON
operator|&&
operator|(
name|p
operator|=
name|envp
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"FS="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"LD_"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|UserEnviron
index|[
name|j
operator|++
index|]
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|UserEnviron
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|environ
operator|=
name|UserEnviron
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Save start and extent of argv for setproctitle. 	*/
end_comment

begin_expr_stmt
name|Argv
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|LastArgv
operator|=
name|envp
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|envp
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|LastArgv
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SETPROCTITLE */
end_comment

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OldUmask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OpMode
operator|=
name|MD_DELIVER
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MotherPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FullName
operator|=
name|getenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|from
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|readconfig
condition|)
block|{
comment|/* initialize some macros, etc. */
name|initmacros
argument_list|()
expr_stmt|;
comment|/* hostname */
name|av
operator|=
name|myhostname
argument_list|(
name|jbuf
argument_list|,
sizeof|sizeof
name|jbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|jbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|struct
name|utsname
name|utsname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"canonical name: %s\n"
argument_list|,
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|q
operator|=
name|strchr
argument_list|(
name|jbuf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'m'
argument_list|,
name|q
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|uname
argument_list|(
operator|&
name|utsname
argument_list|)
operator|>=
literal|0
condition|)
name|p
operator|=
name|utsname
operator|.
name|nodename
expr_stmt|;
else|else
block|{
name|makelower
argument_list|(
name|jbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|jbuf
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"UUCP nodename: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'k'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|av
operator|!=
name|NULL
operator|&&
operator|*
name|av
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\ta.k.a.: %s\n"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|setclass
argument_list|(
literal|'w'
argument_list|,
operator|*
name|av
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* version */
name|define
argument_list|(
literal|'v'
argument_list|,
name|Version
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* current time */
end_comment

begin_expr_stmt
name|define
argument_list|(
literal|'b'
argument_list|,
name|arpadate
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	** Crack argv. 	*/
end_comment

begin_expr_stmt
name|av
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
name|strrchr
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|p
operator|++
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|av
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"newaliases"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"mailq"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_PRINT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"smtpd"
argument_list|)
operator|==
literal|0
condition|)
name|OpMode
operator|=
name|MD_DAEMON
expr_stmt|;
end_if

begin_expr_stmt
name|optind
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|(
name|j
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|OPTIONS
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* operations mode */
switch|switch
condition|(
name|j
operator|=
operator|*
name|optarg
condition|)
block|{
case|case
name|MD_DAEMON
case|:
ifdef|#
directive|ifdef
name|DAEMON
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|unsetenv
argument_list|(
literal|"HOSTALIASES"
argument_list|)
expr_stmt|;
else|#
directive|else
name|usrerr
argument_list|(
literal|"Daemon mode not implemented"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DAEMON */
case|case
name|MD_SMTP
case|:
ifndef|#
directive|ifndef
name|SMTP
name|usrerr
argument_list|(
literal|"I don't speak SMTP"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* SMTP */
case|case
name|MD_DELIVER
case|:
case|case
name|MD_VERIFY
case|:
case|case
name|MD_TEST
case|:
case|case
name|MD_INITALIAS
case|:
case|case
name|MD_PRINT
case|:
case|case
name|MD_FREEZE
case|:
name|OpMode
operator|=
name|j
expr_stmt|;
break|break;
default|default:
name|usrerr
argument_list|(
literal|"Invalid operation mode %c"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* select configuration file (already done) */
break|break;
case|case
literal|'d'
case|:
comment|/* debugging -- redo in case frozen */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* from address */
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|FullName
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|CurEnv
operator|->
name|e_hopcount
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
block|{
name|usrerr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* set option */
name|setoption
argument_list|(
operator|*
name|optarg
argument_list|,
name|optarg
operator|+
literal|1
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* set protocol */
name|q
operator|=
name|strchr
argument_list|(
name|optarg
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|optarg
operator|!=
literal|'\0'
condition|)
name|define
argument_list|(
literal|'r'
argument_list|,
name|newstr
argument_list|(
name|optarg
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|)
name|define
argument_list|(
literal|'s'
argument_list|,
name|newstr
argument_list|(
name|q
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* run queue files at intervals */
ifdef|#
directive|ifdef
name|QUEUE
operator|(
name|void
operator|)
name|unsetenv
argument_list|(
literal|"HOSTALIASES"
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|NULL
expr_stmt|;
name|queuemode
operator|=
name|TRUE
expr_stmt|;
name|QueueIntvl
operator|=
name|convtime
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* QUEUE */
name|usrerr
argument_list|(
literal|"I don't know about queues"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
endif|#
directive|endif
comment|/* QUEUE */
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|GrabTo
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* compatibility flags */
case|case
literal|'c'
case|:
comment|/* connect to non-local mailers */
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
case|case
literal|'m'
case|:
comment|/* send to me too */
case|case
literal|'T'
case|:
comment|/* set timeout interval */
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|setoption
argument_list|(
name|j
argument_list|,
literal|"T"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* error message disposition */
name|setoption
argument_list|(
name|j
argument_list|,
name|optarg
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|setoption
argument_list|(
literal|'f'
argument_list|,
literal|"T"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|OpMode
operator|=
name|MD_INITALIAS
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DBM */
case|case
literal|'R'
case|:
comment|/* log raw recipient info */
name|RcptLogFile
operator|=
name|newstr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_while

begin_expr_stmt
name|av
operator|+=
name|optind
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NAMED_BIND
end_ifdef

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|)
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 	**  Do basic initialization. 	**	Read system control file. 	**	Extract special fields for local use. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_FREEZE
operator|||
name|readconfig
condition|)
name|readcf
argument_list|(
name|ConfFile
argument_list|,
name|safecf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5TZ
end_ifdef

begin_comment
comment|/* Enforce use of local time (null string overrides this) */
end_comment

begin_if
if|if
condition|(
name|TimeZoneSpec
operator|==
name|NULL
condition|)
name|unsetenv
argument_list|(
literal|"TZ"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TimeZoneSpec
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|xalloc
argument_list|(
name|strlen
argument_list|(
name|TimeZoneSpec
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"TZ="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|p
argument_list|,
name|TimeZoneSpec
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|ConfigLevel
operator|>
name|MAXCONFIGLEVEL
condition|)
block|{
name|syserr
argument_list|(
literal|"Warning: .cf version level (%d) exceeds program functionality (%d)"
argument_list|,
name|ConfigLevel
argument_list|,
name|MAXCONFIGLEVEL
argument_list|)
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_if
if|if
condition|(
name|queuemode
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* check to see if we own the queue directory */
if|if
condition|(
name|stat
argument_list|(
name|QueueDir
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"main: cannot stat %s"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_uid
operator|!=
name|getuid
argument_list|()
condition|)
block|{
comment|/* nope, really a botch */
name|usrerr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_NOPERM
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUEUE */
end_comment

begin_switch
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_FREEZE
case|:
comment|/* this is critical to avoid forgeries of the frozen config */
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* freeze the configuration */
name|freeze
argument_list|(
name|FreezeFile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
case|case
name|MD_INITALIAS
case|:
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|MD_DAEMON
case|:
comment|/* remove things that don't make sense in daemon mode */
name|FullName
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
end_switch

begin_comment
comment|/* do heuristic mode adjustment */
end_comment

begin_if
if|if
condition|(
name|Verbose
condition|)
block|{
comment|/* turn off noconnect option */
name|setoption
argument_list|(
literal|'c'
argument_list|,
literal|"F"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* turn on interactive delivery */
name|setoption
argument_list|(
literal|'d'
argument_list|,
literal|""
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* our name for SMTP codes */
end_comment

begin_expr_stmt
name|expand
argument_list|(
literal|"\001j"
argument_list|,
name|jbuf
argument_list|,
operator|&
name|jbuf
index|[
sizeof|sizeof
name|jbuf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MyHostName
operator|=
name|jbuf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the indices of built-in mailers */
end_comment

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"local"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No local mailer defined"
argument_list|)
expr_stmt|;
else|else
name|LocalMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"prog"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No prog mailer defined"
argument_list|)
expr_stmt|;
else|else
name|ProgMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"*file*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *file* mailer defined"
argument_list|)
expr_stmt|;
else|else
name|FileMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"*include*"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No *include* mailer defined"
argument_list|)
expr_stmt|;
else|else
name|InclMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_comment
comment|/* operate in queue directory */
end_comment

begin_if
if|if
condition|(
name|chdir
argument_list|(
name|QueueDir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot chdir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	**  Do operation-mode-dependent initialization. 	*/
end_comment

begin_switch
switch|switch
condition|(
name|OpMode
condition|)
block|{
case|case
name|MD_PRINT
case|:
comment|/* print the queue */
ifdef|#
directive|ifdef
name|QUEUE
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|printqueue
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* QUEUE */
name|usrerr
argument_list|(
literal|"No queue to print"
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* QUEUE */
case|case
name|MD_INITALIAS
case|:
comment|/* initialize alias database */
name|initaliases
argument_list|(
name|AliasFile
argument_list|,
name|TRUE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
case|case
name|MD_DAEMON
case|:
comment|/* don't open alias database -- done in srvrsmtp */
break|break;
default|default:
comment|/* open the alias database */
name|initaliases
argument_list|(
name|AliasFile
argument_list|,
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
break|break;
block|}
end_switch

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* print configuration table (or at least part of it) */
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|mailer
modifier|*
name|m
init|=
name|Mailer
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"mailer %d (%s): P=%s S=%d/%d R=%d/%d M=%ld F="
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|,
name|m
operator|->
name|m_se_rwset
argument_list|,
name|m
operator|->
name|m_sh_rwset
argument_list|,
name|m
operator|->
name|m_re_rwset
argument_list|,
name|m
operator|->
name|m_rh_rwset
argument_list|,
name|m
operator|->
name|m_maxsize
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|'\0'
init|;
name|j
operator|<=
literal|'\177'
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|bitnset
argument_list|(
name|j
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" E="
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|m
operator|->
name|m_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_argv
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|a
init|=
name|m
operator|->
name|m_argv
decl_stmt|;
name|printf
argument_list|(
literal|" A="
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|m
operator|->
name|m_argv
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
operator|*
name|a
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* 	**  Switch to the main envelope. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|=
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MainEnvelope
operator|.
name|e_flags
operator|=
name|BlankEnvelope
operator|.
name|e_flags
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  If test mode, read addresses from stdin and process. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_TEST
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|Verbose
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
block|{
name|printf
argument_list|(
literal|"ADDRESS TEST MODE (ruleset 3 NOT automatically invoked)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Enter<ruleset><address>\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
specifier|extern
name|bool
name|invalidaddr
parameter_list|()
function_decl|;
if|if
condition|(
name|Verbose
condition|)
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|finis
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Verbose
condition|)
name|printf
argument_list|(
literal|"> %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"No address!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|invalidaddr
argument_list|(
name|p
operator|+
literal|1
argument_list|)
condition|)
continue|continue;
do|do
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
name|char
name|pvpbuf
index|[
name|PSBUFSIZE
index|]
decl_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
operator|++
name|p
argument_list|,
literal|','
argument_list|,
name|pvpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
continue|continue;
block|}
block|}
do|while
condition|(
operator|*
operator|(
name|p
operator|=
name|DelimChar
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_comment
comment|/* 	**  If collecting stuff from the queue, go start doing that. 	*/
end_comment

begin_if
if|if
condition|(
name|queuemode
operator|&&
name|OpMode
operator|!=
name|MD_DAEMON
operator|&&
name|QueueIntvl
operator|==
literal|0
condition|)
block|{
name|runqueue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUEUE */
end_comment

begin_comment
comment|/* 	**  If a daemon, wait for a request. 	**	getrequests will always return in a child. 	**	If we should also be processing the queue, start 	**		doing it in background. 	**	We check for any errors that might have happened 	**		during startup. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* put us in background */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"daemon: cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* get our pid right */
name|MotherPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* disconnect from our controlling tty */
name|disconnect
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|queuemode
condition|)
block|{
name|runqueue
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|OpMode
operator|!=
name|MD_DAEMON
condition|)
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* QUEUE */
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DAEMON
name|getrequests
argument_list|()
expr_stmt|;
comment|/* at this point we are in a child: reset state */
name|OpMode
operator|=
name|MD_SMTP
expr_stmt|;
operator|(
name|void
operator|)
name|newenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|openxscript
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DAEMON */
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|SMTP
end_ifdef

begin_comment
comment|/* 	**  If running SMTP protocol, start collecting and executing 	**  commands.  This will never return. 	*/
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
condition|)
name|smtp
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMTP */
end_comment

begin_comment
comment|/* 	**  Do basic system initialization and set the sender 	*/
end_comment

begin_expr_stmt
name|initsys
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|setsender
argument_list|(
name|from
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|av
operator|==
name|NULL
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|usrerr
argument_list|(
literal|"Recipient names must be specified"
argument_list|)
expr_stmt|;
comment|/* collect body for UUCP return */
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|collect
argument_list|(
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|OpMode
operator|==
name|MD_VERIFY
condition|)
name|SendMode
operator|=
name|SM_VERIFY
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Scan argv and deliver the message to everyone. 	*/
end_comment

begin_expr_stmt
name|sendtoargv
argument_list|(
name|av
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if we have had errors sofar, arrange a meaningful exit stat */
end_comment

begin_if
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Read the input mail. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
operator|||
name|GrabTo
condition|)
name|collect
argument_list|(
name|FALSE
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* collect statistics */
end_comment

begin_if
if|if
condition|(
name|OpMode
operator|!=
name|MD_VERIFY
condition|)
name|markstats
argument_list|(
name|CurEnv
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"main: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sendall
argument_list|(
name|CurEnv
argument_list|,
name|SM_DEFAULT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	** All done. 	*/
end_comment

begin_expr_stmt
name|finis
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		none ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_expr_stmt
unit|finis
operator|(
operator|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n====finis: stat %d e_flags %o\n"
argument_list|,
name|ExitStat
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
expr_stmt|;
comment|/* clean up temp files */
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* flush any cached connections */
end_comment

begin_expr_stmt
name|mci_flush
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* post statistics */
end_comment

begin_expr_stmt
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* and exit */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_if
if|if
condition|(
name|LogLevel
operator|>
literal|78
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"finis, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOG */
end_comment

begin_if
if|if
condition|(
name|ExitStat
operator|==
name|EX_TEMPFAIL
condition|)
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
end_if

begin_expr_stmt
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  INTSIG -- clean up on interrupt ** **	This just arranges to exit.  It pessimises in that it **	may resend a message. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Unlocks the current job. */
end_comment

begin_macro
unit|void
name|intsig
argument_list|()
end_macro

begin_block
block|{
name|FileName
operator|=
name|NULL
expr_stmt|;
name|unlockqueue
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INITMACROS -- initialize the macro system ** **	This just involves defining some macros that are actually **	used internally as metasymbols to be themselves. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes several macros to be themselves. */
end_comment

begin_decl_stmt
name|struct
name|metamac
name|MetaMacros
index|[]
init|=
block|{
comment|/* LHS pattern matching characters */
literal|'*'
block|,
name|MATCHZANY
block|,
literal|'+'
block|,
name|MATCHANY
block|,
literal|'-'
block|,
name|MATCHONE
block|,
literal|'='
block|,
name|MATCHCLASS
block|,
literal|'~'
block|,
name|MATCHNCLASS
block|,
comment|/* these are RHS metasymbols */
literal|'#'
block|,
name|CANONNET
block|,
literal|'@'
block|,
name|CANONHOST
block|,
literal|':'
block|,
name|CANONUSER
block|,
literal|'>'
block|,
name|CALLSUBR
block|,
literal|'{'
block|,
name|MATCHLOOKUP
block|,
literal|'}'
block|,
name|MATCHELOOKUP
block|,
comment|/* the conditional operations */
literal|'?'
block|,
name|CONDIF
block|,
literal|'|'
block|,
name|CONDELSE
block|,
literal|'.'
block|,
name|CONDFI
block|,
comment|/* and finally the hostname lookup characters */
literal|'['
block|,
name|HOSTBEGIN
block|,
literal|']'
block|,
name|HOSTEND
block|,
literal|'('
block|,
name|LOOKUPBEGIN
block|,
literal|')'
block|,
name|LOOKUPEND
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|initmacros
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|metamac
modifier|*
name|m
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|m
operator|=
name|MetaMacros
init|;
name|m
operator|->
name|metaname
operator|!=
literal|'\0'
condition|;
name|m
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|metaval
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|m
operator|->
name|metaname
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|MATCHREPL
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|define
argument_list|(
name|c
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FREEZE -- freeze BSS& allocated memory ** **	This will be used to efficiently load the configuration file. ** **	Parameters: **		freezefile -- the name of the file to freeze to. ** **	Returns: **		none. ** **	Side Effects: **		Writes BSS and malloc'ed memory to freezefile */
end_comment

begin_union
union|union
name|frz
block|{
name|char
name|frzpad
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* insure we are on a BUFSIZ boundary */
struct|struct
block|{
name|time_t
name|frzstamp
decl_stmt|;
comment|/* timestamp on this freeze */
name|char
modifier|*
name|frzbrk
decl_stmt|;
comment|/* the current break */
name|char
modifier|*
name|frzedata
decl_stmt|;
comment|/* address of edata */
name|char
modifier|*
name|frzend
decl_stmt|;
comment|/* address of end */
name|char
name|frzver
index|[
literal|252
index|]
decl_stmt|;
comment|/* sendmail version */
block|}
name|frzinfo
struct|;
block|}
union|;
end_union

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|BRK_TYPE
value|int
end_define

begin_define
define|#
directive|define
name|SBRK_TYPE
value|void *
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BRK_TYPE
value|char *
end_define

begin_define
define|#
directive|define
name|SBRK_TYPE
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|freeze
argument_list|(
argument|freezefile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|freezefile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f
decl_stmt|;
name|union
name|frz
name|fhdr
decl_stmt|;
specifier|extern
name|SBRK_TYPE
name|sbrk
parameter_list|()
function_decl|;
specifier|extern
name|char
name|edata
decl_stmt|,
name|end
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
if|if
condition|(
name|freezefile
operator|==
name|NULL
condition|)
return|return;
comment|/* try to open the freeze file */
name|f
operator|=
name|creat
argument_list|(
name|freezefile
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot freeze %s"
argument_list|,
name|freezefile
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* build the freeze header */
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzstamp
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzedata
operator|=
operator|&
name|edata
expr_stmt|;
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzend
operator|=
operator|&
name|end
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzver
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* write out the freeze header */
if|if
condition|(
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
operator|!=
sizeof|sizeof
name|fhdr
operator|||
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|edata
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
argument_list|)
operator|!=
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot freeze %s"
argument_list|,
name|freezefile
argument_list|)
expr_stmt|;
block|}
comment|/* fine, clean up */
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  THAW -- read in the frozen configuration file. ** **	Parameters: **		freezefile -- the name of the file to thaw from. **		binfile -- the name of the sendmail binary (ok to guess). ** **	Returns: **		TRUE if it successfully read the freeze file. **		FALSE otherwise. ** **	Side Effects: **		reads freezefile in to BSS area. */
end_comment

begin_macro
name|thaw
argument_list|(
argument|freezefile
argument_list|,
argument|binfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|freezefile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|binfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|union
name|frz
name|fhdr
decl_stmt|;
name|char
name|hbuf
index|[
literal|60
index|]
decl_stmt|;
name|struct
name|stat
name|fst
decl_stmt|,
name|sst
decl_stmt|;
specifier|extern
name|char
name|edata
decl_stmt|,
name|end
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|myhostname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
specifier|extern
name|BRK_TYPE
name|brk
parameter_list|()
function_decl|;
if|if
condition|(
name|freezefile
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* open the freeze file */
name|f
operator|=
name|open
argument_list|(
name|freezefile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|fst
argument_list|)
operator|<
literal|0
operator|||
name|stat
argument_list|(
name|ConfFile
argument_list|,
operator|&
name|sst
argument_list|)
operator|<
literal|0
operator|||
name|fst
operator|.
name|st_mtime
operator|<
name|sst
operator|.
name|st_mtime
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Freeze file older than config file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|binfile
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
operator|&&
name|stat
argument_list|(
name|binfile
argument_list|,
operator|&
name|sst
argument_list|)
operator|==
literal|0
operator|&&
name|fst
operator|.
name|st_mtime
operator|<
name|sst
operator|.
name|st_mtime
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Freeze file older than binary file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* read in the header */
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fhdr
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
operator|<
sizeof|sizeof
name|fhdr
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Cannot read frozen config file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzedata
operator|!=
operator|&
name|edata
operator|||
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzend
operator|!=
operator|&
name|end
operator|||
name|strcmp
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzver
argument_list|,
name|Version
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Wrong version of frozen config file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* arrange to have enough space */
if|if
condition|(
name|brk
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
argument_list|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot break to %x"
argument_list|,
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* now read in the freeze file */
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|edata
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
argument_list|)
operator|!=
call|(
name|int
call|)
argument_list|(
name|fhdr
operator|.
name|frzinfo
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot read frozen config file"
argument_list|)
expr_stmt|;
comment|/* oops!  we have trashed memory..... */
operator|(
name|void
operator|)
name|write
argument_list|(
literal|2
argument_list|,
literal|"Cannot read freeze file\n"
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* verify that the host name was correct on the freeze */
operator|(
name|void
operator|)
name|myhostname
argument_list|(
name|hbuf
argument_list|,
sizeof|sizeof
name|hbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|macvalue
argument_list|(
literal|'w'
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hbuf
argument_list|,
name|macvalue
argument_list|(
literal|'w'
argument_list|,
name|CurEnv
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Hostname changed since freeze (%s => %s)"
argument_list|,
name|p
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DISCONNECT -- remove our connection with any foreground process ** **	Parameters: **		fulldrop -- if set, we should also drop the controlling **			TTY if possible -- this should only be done when **			setting up the daemon since otherwise UUCP can **			leave us trying to open a dialin, and we will **			wait for the carrier. ** **	Returns: **		none ** **	Side Effects: **		Trys to insure that we are immune to vagaries of **		the controlling tty. */
end_comment

begin_macro
name|disconnect
argument_list|(
argument|fulldrop
argument_list|)
end_macro

begin_decl_stmt
name|bool
name|fulldrop
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"disconnect: In %d Out %d\n"
argument_list|,
name|fileno
argument_list|(
name|InChannel
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|52
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"don't\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* be sure we don't get nasty signals */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* we can't communicate with our caller, so.... */
name|HoldErrs
operator|=
name|TRUE
expr_stmt|;
name|ErrorMode
operator|=
name|EM_MAIL
expr_stmt|;
name|Verbose
operator|=
name|FALSE
expr_stmt|;
comment|/* all input from /dev/null */
if|if
condition|(
name|InChannel
operator|!=
name|stdin
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|InChannel
argument_list|)
expr_stmt|;
name|InChannel
operator|=
name|stdin
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* output to the transcript */
if|if
condition|(
name|OutChannel
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|OutChannel
argument_list|)
expr_stmt|;
name|OutChannel
operator|=
name|stdout
expr_stmt|;
block|}
if|if
condition|(
name|CurEnv
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|CurEnv
operator|->
name|e_xfp
operator|=
name|fopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|CurEnv
operator|->
name|e_xfp
argument_list|)
argument_list|)
operator|)
operator|<
literal|2
operator|&&
name|fd
operator|>
literal|0
condition|)
continue|continue;
comment|/* drop our controlling TTY completely if possible */
if|if
condition|(
name|fulldrop
condition|)
block|{
ifdef|#
directive|ifdef
name|SYSTEM5
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|int
operator|)
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCNOTTY */
name|errno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|71
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"in background, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|obsolete
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|ap
decl_stmt|;
while|while
condition|(
name|ap
operator|=
operator|*
operator|++
name|argv
condition|)
block|{
comment|/* Return if "--" or not an option of any form. */
if|if
condition|(
name|ap
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|ap
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
return|return;
comment|/* If -C doesn't have an argument, use sendmail.cf. */
define|#
directive|define
name|__DEFPATH
value|"sendmail.cf"
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|argv
operator|=
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|__DEFPATH
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
literal|'C'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|__DEFPATH
argument_list|)
expr_stmt|;
block|}
comment|/* If -q doesn't have an argument, run it once. */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'q'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
operator|*
name|argv
operator|=
literal|"-q0"
expr_stmt|;
comment|/* if -d doesn't have an argument, use 0-99.1 */
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|==
literal|'d'
operator|&&
name|ap
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
operator|*
name|argv
operator|=
literal|"-d0-99.1"
expr_stmt|;
block|}
block|}
end_function

end_unit

