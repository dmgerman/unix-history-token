begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
expr|main
operator|.
name|c
literal|3.132
operator|%
name|G
operator|%
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by tables read in from /usr/lib/sendmail.cf **	(read by readcf.c).  Some more static configuration info, **	including some code that you may want to tailor for your **	installation, is in conf.c.  You may also want to touch **	daemon.c (if you have some other IPC mechanism), acct.c **	(to change your accounting), names.c (to adjust the name **	server mechanism). ** **	Usage: **		/etc/sendmail [flags] addr ... ** **	Positional Parameters: **		addr -- the address to deliver the mail to.  There **			can be several. ** **	Flags: **		-f name		The mail is from "name" -- used for **				the header in local mail, and to **				deliver reports of failures to. **		-r name		Same as -f; however, this flag is **				reserved to indicate special processing **				for remote mail delivery as needed **				in the future.  So, network servers **				should use -r. **		-Ffullname	Select what the full-name should be **				listed as. **		-a		This mail should be in ARPANET std **				format (obsolete version). **		-as		Speak SMTP. **		-n		Don't do aliasing.  This might be used **				when delivering responses, for **				instance. **		-dN		Run with debugging set to level N. **		-em		Mail back a response if there was an **				error in processing.  This should be **				used when the origin of this message **				is another machine. **		-ew		Write back a response if the user is **				still logged in, otherwise, act like **				-em. **		-eq		Don't print any error message (just **				return exit status). **		-ep		(default)  Print error messages **				normally. **		-ee		Send BerkNet style errors.  This **				is equivalent to MailBack except **				that it has gives zero return code **				(unless there were errors during **				returning).  This used to be **				"EchoBack", but you know how the old **				software bounces. **		-m		In group expansion, send to the **				sender also (stands for the Mail metoo **				option. **		-i		Do not terminate mail on a line **				containing just dot. **		-s		Save UNIX-like "From" lines on the **				front of messages. **		-v		Give blow-by-blow description of **				everything that happens. **		-t		Read "to" addresses from message. **				Looks at To:, Cc:, and Bcc: lines. **		-I		Initialize the DBM alias files from **				the text format files. **		-Cfilename	Use alternate configuration file. **		-Afilename	Use alternate alias file. **		-DXvalue	Define macro X to have value. **		-bv		Verify addresses only. **		-bd		Run as a daemon.  Berkeley 4.2 only. **		-bf		Fork after address verification. **		-bq		Queue up for later delivery. **		-ba		Process mail completely. ** **	Return Codes: **		As defined in<sysexits.h>. ** **		These codes are actually returned from the auxiliary **		mailers; it is their responsibility to make them **		correct. ** **	Compilation Flags: **		LOG -- if set, everything is logged. ** **	Author: **		Eric Allman, UCB/INGRES */
end_comment

begin_decl_stmt
name|int
name|NextMailer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "free" index into Mailer struct */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a "blank" envelope */
end_comment

begin_decl_stmt
name|ENVELOPE
name|MainEnvelope
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the envelope around the basic letter */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DAEMON
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SMTP
end_ifndef

begin_expr_stmt
name|ERROR
operator|%
operator|%
operator|%
operator|%
name|Cannot
name|have
name|daemon
name|mode
name|without
name|SMTP
operator|%
operator|%
operator|%
operator|%
name|ERROR
endif|#
directive|endif
endif|SMTP
endif|#
directive|endif
endif|DAEMON
expr|main
operator|(
name|argc
operator|,
name|argv
operator|)
name|int
name|argc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|char
modifier|*
name|locname
decl_stmt|;
specifier|extern
name|int
name|finis
parameter_list|()
function_decl|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|fnptr
function_decl|)
parameter_list|()
function_decl|;
name|STAB
modifier|*
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pass
init|=
literal|0
decl_stmt|;
name|bool
name|safecf
init|=
name|TRUE
decl_stmt|;
comment|/* this conf file is sys default */
name|bool
name|queuemode
init|=
name|FALSE
decl_stmt|;
comment|/* process queue requests */
specifier|static
name|bool
name|reenter
init|=
name|FALSE
decl_stmt|;
name|char
name|jbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* holds HostName */
specifier|extern
name|bool
name|safefile
parameter_list|()
function_decl|;
specifier|extern
name|time_t
name|convtime
parameter_list|()
function_decl|;
extern|extern putheader(
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|putbody
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ENVELOPE
modifier|*
name|newenvelope
parameter_list|()
function_decl|;
end_function_decl

begin_extern
extern|extern intsig(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|reenter
condition|)
block|{
name|syserr
argument_list|(
literal|"main: reentered!"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|reenter
operator|=
name|TRUE
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|bool
name|canrename
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|InChannel
operator|=
name|stdin
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OutChannel
operator|=
name|stdout
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|intsig
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|OldUmask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Mode
operator|=
name|MD_DEFAULT
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MotherPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_expr_stmt
name|FullName
operator|=
name|getenv
argument_list|(
literal|"NAME"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|V6
end_endif

begin_comment
comment|/* set up the blank envelope */
end_comment

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|BlankEnvelope
operator|.
name|e_putbody
operator|=
name|putbody
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CurEnv
operator|=
operator|&
name|BlankEnvelope
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_expr_stmt
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_expr_stmt
name|Xscript
operator|=
name|stderr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|from
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|initmacros
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	** Crack argv. 	*/
end_comment

begin_label
name|crackargs
label|:
end_label

begin_expr_stmt
name|ac
operator|=
name|argc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|av
operator|=
name|argv
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|pass
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|p
operator|=
name|rindex
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|p
operator|++
operator|==
name|NULL
condition|)
name|p
operator|=
operator|*
name|av
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"newaliases"
argument_list|)
operator|==
literal|0
condition|)
name|setoption
argument_list|(
literal|'b'
argument_list|,
literal|"i"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"mailq"
argument_list|)
operator|==
literal|0
condition|)
name|setoption
argument_list|(
literal|'b'
argument_list|,
literal|"p"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
end_if

begin_while
while|while
condition|(
operator|--
name|ac
operator|>
literal|0
operator|&&
operator|(
name|p
operator|=
operator|*
operator|++
name|av
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* arpanet format */
name|ArpaMode
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'s'
condition|)
block|{
comment|/* running smtp */
ifdef|#
directive|ifdef
name|SMTP
name|Smtp
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
else|SMTP
name|syserr
argument_list|(
literal|"I don't speak SMTP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SMTP
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* select configuration file */
name|ConfFile
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|ConfFile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ConfFile
operator|=
literal|"sendmail.cf"
expr_stmt|;
name|safecf
operator|=
name|FALSE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
comment|/* debug */
name|tTsetup
argument_list|(
name|tTdvect
argument_list|,
sizeof|sizeof
name|tTdvect
argument_list|,
literal|"0-99.1"
argument_list|)
expr_stmt|;
name|tTflag
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DEBUG
case|case
literal|'f'
case|:
comment|/* from address */
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|av
expr_stmt|;
if|if
condition|(
operator|--
name|ac
operator|<=
literal|0
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|syserr
argument_list|(
literal|"No \"from\" person"
argument_list|)
expr_stmt|;
name|ac
operator|++
expr_stmt|;
name|av
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
operator|&&
name|pass
operator|<=
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|av
expr_stmt|;
if|if
condition|(
operator|--
name|ac
operator|<=
literal|0
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad -F flag"
argument_list|)
expr_stmt|;
name|ac
operator|++
expr_stmt|;
name|av
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|FullName
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|av
expr_stmt|;
if|if
condition|(
operator|--
name|ac
operator|<=
literal|0
operator|||
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ac
operator|++
expr_stmt|;
name|av
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|HopCount
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* set option */
name|setoption
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|,
operator|&
name|p
index|[
literal|3
index|]
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* run queue files at intervals */
ifdef|#
directive|ifdef
name|QUEUE
name|queuemode
operator|=
name|TRUE
expr_stmt|;
name|QueueIntvl
operator|=
name|convtime
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
else|QUEUE
name|syserr
argument_list|(
literal|"I don't know about queues"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|GrabTo
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* compatibility flags */
case|case
literal|'b'
case|:
comment|/* operations mode */
case|case
literal|'c'
case|:
comment|/* connect to non-local mailers */
case|case
literal|'e'
case|:
comment|/* error message disposition */
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
case|case
literal|'m'
case|:
comment|/* send to me too */
case|case
literal|'T'
case|:
comment|/* set timeout interval */
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|setoption
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|setoption
argument_list|(
literal|'f'
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|setoption
argument_list|(
literal|'b'
argument_list|,
literal|"i"
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DBM
block|}
block|}
end_while

begin_comment
comment|/* 	**  Do basic initialization. 	**	Read system control file. 	**	Extract special fields for local use. 	*/
end_comment

begin_if
if|if
condition|(
name|pass
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|safecf
operator|||
name|Mode
operator|==
name|MD_FREEZE
operator|||
operator|!
name|thaw
argument_list|()
condition|)
name|readcf
argument_list|(
name|ConfFile
argument_list|,
name|safecf
argument_list|)
expr_stmt|;
else|else
goto|goto
name|crackargs
goto|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|Mode
condition|)
block|{
case|case
name|MD_FREEZE
case|:
name|freeze
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
case|case
name|MD_INITALIAS
case|:
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|MD_PRINT
case|:
name|usrerr
argument_list|(
literal|"mailq mode not yet implemented"
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_switch

begin_comment
comment|/* do heuristic mode adjustment */
end_comment

begin_if
if|if
condition|(
name|Verbose
condition|)
name|setoption
argument_list|(
literal|'b'
argument_list|,
literal|"a"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* our name for SMTP codes */
end_comment

begin_expr_stmt
name|expand
argument_list|(
literal|"$j"
argument_list|,
name|jbuf
argument_list|,
operator|&
name|jbuf
index|[
sizeof|sizeof
name|jbuf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|HostName
operator|=
name|jbuf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* the indices of local and program mailers */
end_comment

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"local"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No local mailer defined"
argument_list|)
expr_stmt|;
else|else
name|LocalMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_expr_stmt
name|st
operator|=
name|stab
argument_list|(
literal|"prog"
argument_list|,
name|ST_MAILER
argument_list|,
name|ST_FIND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No prog mailer defined"
argument_list|)
expr_stmt|;
else|else
name|ProgMailer
operator|=
name|st
operator|->
name|s_mailer
expr_stmt|;
end_if

begin_comment
comment|/* operate in queue directory */
end_comment

begin_if
if|if
condition|(
name|chdir
argument_list|(
name|QueueDir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot chdir(%s)"
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	**  Initialize aliases. 	*/
end_comment

begin_expr_stmt
name|initaliases
argument_list|(
name|AliasFile
argument_list|,
name|Mode
operator|==
name|MD_INITALIAS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DBM
end_ifdef

begin_if
if|if
condition|(
name|Mode
operator|==
name|MD_INITALIAS
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|DBM
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|0
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* print configuration table (or at least part of it) */
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|mailer
modifier|*
name|m
init|=
name|Mailer
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"mailer %d: %s %s %lo %d %d\n"
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
name|m
operator|->
name|m_s_rwset
argument_list|,
name|m
operator|->
name|m_r_rwset
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_comment
comment|/* 	**  Switch to the main envelope. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|=
name|newenvelope
argument_list|(
operator|&
name|MainEnvelope
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  If test mode, read addresses from stdin and process. 	*/
end_comment

begin_if
if|if
condition|(
name|Mode
operator|==
name|MD_TEST
condition|)
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ADDRESS TEST MODE\nEnter<ruleset><address>\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
modifier|*
name|rewrite
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|finis
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|*
name|p
operator|++
control|)
continue|continue;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|pvp
operator|=
name|prescan
argument_list|(
operator|++
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
continue|continue;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|rewrite
argument_list|(
name|pvp
argument_list|,
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
continue|continue;
block|}
block|}
do|while
condition|(
operator|*
operator|(
name|p
operator|=
name|DelimChar
operator|)
operator|!=
literal|'\0'
condition|)
do|;
block|}
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DAEMON
end_ifdef

begin_comment
comment|/* 	**  If a daemon, wait for a request. 	**	getrequests will always return in a child. 	**	If we should also be processing the queue, start 	**		doing it in background. 	**	We check for any errors that might have happened 	**		during startup. 	*/
end_comment

begin_if
if|if
condition|(
name|Mode
operator|==
name|MD_DAEMON
operator|||
name|QueueIntvl
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* put us in background */
name|i
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"daemon: cannot fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* get our pid right */
name|MotherPid
operator|=
name|getpid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"background daemon, pid=%d"
argument_list|,
name|MotherPid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
comment|/* disconnect from our controlling tty */
name|i
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|i
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|queuemode
condition|)
block|{
name|runqueue
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mode
operator|!=
name|MD_DAEMON
condition|)
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|QUEUE
name|checkerrors
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|getrequests
argument_list|()
expr_stmt|;
comment|/* at this point we are in a child: reset state */
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_id
operator|=
name|CurEnv
operator|->
name|e_qf
operator|=
name|CurEnv
operator|->
name|e_df
operator|=
name|NULL
expr_stmt|;
name|FatalErrors
operator|=
name|FALSE
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|DAEMON
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_comment
comment|/* 	**  If collecting stuff from the queue, go start doing that. 	*/
end_comment

begin_if
if|if
condition|(
name|queuemode
operator|&&
name|Mode
operator|!=
name|MD_DAEMON
condition|)
block|{
name|runqueue
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|QUEUE
end_endif

begin_comment
comment|/* do basic system initialization */
end_comment

begin_expr_stmt
name|initsys
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMTP
end_ifdef

begin_comment
comment|/* 	**  If running SMTP protocol, start collecting and executing 	**  commands.  This will never return. 	*/
end_comment

begin_if
if|if
condition|(
name|Smtp
condition|)
name|smtp
argument_list|()
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|SMTP
end_endif

begin_comment
comment|/* 	**  Set the sender 	*/
end_comment

begin_expr_stmt
name|setsender
argument_list|(
name|from
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Mode
operator|!=
name|MD_DAEMON
operator|&&
name|ac
operator|<=
literal|0
operator|&&
operator|!
name|GrabTo
condition|)
block|{
name|usrerr
argument_list|(
literal|"Usage: /etc/sendmail [flags] addr..."
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	**  Process Hop count. 	**	The Hop count tells us how many times this message has 	**	been processed by sendmail.  If it exceeds some 	**	fairly large threshold, then we assume that we have 	**	an infinite forwarding loop and die. 	*/
end_comment

begin_if
if|if
condition|(
operator|++
name|HopCount
operator|>
name|MAXHOP
condition|)
name|syserr
argument_list|(
literal|"Infinite forwarding loop (%s->%s)"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Scan argv and deliver the message to everyone. 	**	Actually, suppress delivery if we are taking To: 	**	lines from the message. 	*/
end_comment

begin_if
if|if
condition|(
name|GrabTo
condition|)
name|DontSend
operator|=
name|TRUE
expr_stmt|;
end_if

begin_expr_stmt
name|sendtoargv
argument_list|(
name|av
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if we have had errors sofar, arrange a meaningful exit stat */
end_comment

begin_if
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
end_if

begin_comment
comment|/* 	**  Read the input mail. 	*/
end_comment

begin_expr_stmt
name|DontSend
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Mode
operator|!=
name|MD_VERIFY
operator|||
name|GrabTo
condition|)
name|collect
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  If we don't want to wait around for actual delivery, this 	**  is a good time to fork off. 	**	We have examined what we can without doing actual 	**		delivery, so we will inform our caller of 	**		whatever we can now. 	**	Since the parent process will go away immediately, 	**		the child will be caught by init. 	**	If the fork fails, we will just continue in the 	**		parent; this is perfectly safe, albeit 	**		slower than it must be. 	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|QUEUE
end_ifdef

begin_if
if|if
condition|(
name|Mode
operator|==
name|MD_QUEUE
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|CurEnv
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|CurEnv
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"queued"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|4
condition|)
name|logdelivery
argument_list|(
literal|"queued"
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|Mode
operator|==
name|MD_QUEUE
operator|||
name|Mode
operator|==
name|MD_FORK
operator|||
operator|(
name|Mode
operator|!=
name|MD_VERIFY
operator|&&
name|SuperSafe
operator|)
condition|)
name|queueup
argument_list|(
name|CurEnv
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|Mode
operator|==
name|MD_FORK
condition|)
block|{
if|if
condition|(
name|fork
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|/* parent -- quit */
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"background delivery, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
block|}
elseif|else
if|if
condition|(
name|Mode
operator|==
name|MD_QUEUE
condition|)
block|{
name|CurEnv
operator|->
name|e_df
operator|=
name|CurEnv
operator|->
name|e_qf
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_dontqueue
operator|=
name|TRUE
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|initsys
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* collect statistics */
end_comment

begin_expr_stmt
name|Stat
operator|.
name|stat_nf
index|[
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_mno
index|]
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Stat
operator|.
name|stat_bf
index|[
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_mno
index|]
operator|+=
name|kbytes
argument_list|(
name|CurEnv
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Arrange that the person who is sending the mail 	**  will not be expanded (unless explicitly requested). 	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_expr_stmt
name|CurEnv
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|MeToo
condition|)
name|recipient
argument_list|(
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
operator|&
name|CurEnv
operator|->
name|e_sendqueue
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
end_comment

begin_expr_stmt
name|sendall
argument_list|(
name|CurEnv
argument_list|,
name|Mode
operator|==
name|MD_VERIFY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	** All done. 	*/
end_comment

begin_expr_stmt
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Mode
operator|!=
name|MD_VERIFY
condition|)
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|finis
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  SETFROM -- set the person who this message is from ** **	Under certain circumstances allow the user to say who **	s/he is (using -f or -r).  These are: **	1.  The user's uid is zero (root). **	2.  The user's login name is in an approved list (typically **	    from a network server). **	3.  The address the user is trying to claim has a **	    "!" character in it (since #2 doesn't do it for **	    us if we are dialing out for UUCP). **	A better check to replace #3 would be if the **	effective uid is "UUCP" -- this would require me **	to rewrite getpwent to "grab" uucp as it went by, **	make getname more nasty, do another passwd file **	scan, or compile the UID of "UUCP" into the code, **	all of which are reprehensible. ** **	Assuming all of these fail, we figure out something **	ourselves. ** **	Parameters: **		from -- the person it is from. **		realname -- the actual person executing sendmail. **			If NULL, then take whoever we previously **			thought was the from person. ** **	Returns: **		none. ** **	Side Effects: **		sets sendmail's notion of who the from person is. */
end_comment

begin_expr_stmt
unit|setfrom
operator|(
name|from
operator|,
name|realname
operator|)
name|char
operator|*
name|from
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|realname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|frombuf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|realname
operator|==
name|NULL
condition|)
name|realname
operator|=
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"setfrom(%s, %s)\n"
argument_list|,
name|from
argument_list|,
name|realname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Do validation to determine whether this user is allowed 	**  to change the sender name. 	*/
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|bool
name|trusteduser
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|trusteduser
argument_list|(
name|realname
argument_list|)
operator|&&
ifdef|#
directive|ifdef
name|DEBUG
operator|(
operator|!
name|tTd
argument_list|(
literal|1
argument_list|,
literal|9
argument_list|)
operator|||
name|getuid
argument_list|()
operator|!=
name|geteuid
argument_list|()
operator|)
operator|&&
endif|#
directive|endif
endif|DEBUG
name|index
argument_list|(
name|from
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* network sends -r regardless (why why why?) */
comment|/* syserr("%s, you cannot use the -f flag", realname); */
name|from
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	**  Parse the sender name. 	**	Arrange to send return messages to the same person. 	**	Set up some environment info. 	*/
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|parse
argument_list|(
name|from
argument_list|,
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|from
operator|=
name|newstr
argument_list|(
name|realname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse
argument_list|(
name|from
argument_list|,
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|FromFlag
operator|=
name|TRUE
expr_stmt|;
name|CurEnv
operator|->
name|e_returnto
operator|=
operator|&
name|CurEnv
operator|->
name|e_from
expr_stmt|;
name|SuprErrs
operator|=
name|FALSE
expr_stmt|;
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|CurEnv
operator|->
name|e_from
operator|.
name|q_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
name|CurEnv
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|V6
if|if
condition|(
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
operator|!=
literal|0
condition|)
block|{
name|DefUid
operator|=
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
expr_stmt|;
name|DefGid
operator|=
name|CurEnv
operator|->
name|e_from
operator|.
name|q_gid
expr_stmt|;
block|}
comment|/* 	**  Rewrite the from person to dispose of possible implicit 	**	links in the net. 	*/
name|pvp
operator|=
name|prescan
argument_list|(
name|from
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot prescan from (%s)"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|frombuf
argument_list|,
sizeof|sizeof
name|frombuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'f'
argument_list|,
name|newstr
argument_list|(
name|frombuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save the domain spec if this mailer wants it */
if|if
condition|(
name|bitset
argument_list|(
name|M_CANONICAL
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|copyplist
parameter_list|()
function_decl|;
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|pvp
argument_list|,
literal|"@"
argument_list|)
operator|!=
literal|0
condition|)
name|pvp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pvp
operator|!=
name|NULL
condition|)
name|CurEnv
operator|->
name|e_fromdomain
operator|=
name|copyplist
argument_list|(
name|pvp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TRUSTEDUSER -- tell us if this user is to be trusted. ** **	Parameters: **		user -- the user to be checked. ** **	Returns: **		TRUE if the user is in an approved list. **		FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|trusteduser
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ulist
decl_stmt|;
specifier|extern
name|char
modifier|*
name|TrustedUsers
index|[]
decl_stmt|;
for|for
control|(
name|ulist
operator|=
name|TrustedUsers
init|;
operator|*
name|ulist
operator|!=
name|NULL
condition|;
name|ulist
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|ulist
argument_list|,
name|user
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		none ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_macro
name|finis
argument_list|()
end_macro

begin_block
block|{
name|CurEnv
operator|=
operator|&
name|MainEnvelope
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n====finis: stat %d sendreceipt %d FatalErrors %d\n"
argument_list|,
name|ExitStat
argument_list|,
name|CurEnv
operator|->
name|e_sendreceipt
argument_list|,
name|FatalErrors
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Send back return receipts as requested. 	*/
if|if
condition|(
name|CurEnv
operator|->
name|e_receiptto
operator|!=
name|NULL
operator|&&
operator|(
name|CurEnv
operator|->
name|e_sendreceipt
operator|||
name|ExitStat
operator|!=
name|EX_OK
operator|)
condition|)
block|{
specifier|auto
name|ADDRESS
modifier|*
name|rlist
decl_stmt|;
name|sendto
argument_list|(
name|CurEnv
operator|->
name|e_receiptto
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|rlist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|returntosender
argument_list|(
literal|"Return receipt"
argument_list|,
name|rlist
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Arrange to return errors or queue up as appropriate. 	**	If we are running a queue file and exiting abnormally, 	**		be sure we save the queue file. 	**	This clause will arrange to return error messages. 	*/
name|checkerrors
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* 	**  Now clean up temp files and exit. 	*/
if|if
condition|(
name|Transcript
operator|!=
name|NULL
condition|)
name|xunlink
argument_list|(
name|Transcript
argument_list|)
expr_stmt|;
name|dropenvelope
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|11
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"finis, pid=%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INTSIG -- clean up on interrupt ** **	This just arranges to call finis. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Arranges to not unlink the qf and df files. */
end_comment

begin_macro
name|intsig
argument_list|()
end_macro

begin_block
block|{
name|CurEnv
operator|->
name|e_df
operator|=
name|CurEnv
operator|->
name|e_qf
operator|=
name|NULL
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  OPENXSCRPT -- Open transcript file ** **	Creates a transcript file for possible eventual mailing or **	sending back. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Open the transcript file. */
end_comment

begin_macro
name|openxscrpt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|queuename
argument_list|(
name|CurEnv
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|Xscript
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Xscript
operator|==
name|NULL
condition|)
block|{
name|Xscript
operator|=
name|stdout
expr_stmt|;
name|syserr
argument_list|(
literal|"Can't create %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|p
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
name|Transcript
operator|=
name|newstr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SETSENDER -- set sendmail's idea of the sender. ** **	Parameters: **		from -- the person we would like to believe this **			is from. ** **	Returns: **		none. ** **	Side Effects: **		Sets the idea of the sender. */
end_comment

begin_macro
name|setsender
argument_list|(
argument|from
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
modifier|*
name|realname
decl_stmt|;
name|char
name|cfbuf
index|[
literal|40
index|]
decl_stmt|;
name|bool
name|nofullname
decl_stmt|;
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
comment|/* 	**  Figure out the real user executing us. 	**	Getlogin can return errno != 0 on non-errors. 	*/
if|if
condition|(
operator|!
name|Smtp
operator|&&
operator|!
name|QueueRun
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|getlogin
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|nofullname
operator|=
operator|(
name|from
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|from
expr_stmt|;
name|nofullname
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|Smtp
operator|&&
operator|!
name|QueueRun
condition|)
name|syserr
argument_list|(
literal|"Who are you? (name=%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
name|int
name|uid
decl_stmt|;
name|nofullname
operator|=
name|TRUE
expr_stmt|;
name|uid
operator|=
name|getruid
argument_list|()
expr_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Who are you? (uid=%d)"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|pw
operator|==
name|NULL
condition|)
name|finis
argument_list|()
expr_stmt|;
name|realname
operator|=
name|p
expr_stmt|;
comment|/* 	**  Process passwd file entry. 	*/
comment|/* run user's .mailcf file */
name|define
argument_list|(
literal|'z'
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"$z/.mailcf"
argument_list|,
name|cfbuf
argument_list|,
operator|&
name|cfbuf
index|[
sizeof|sizeof
name|cfbuf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nofullname
operator|&&
name|safefile
argument_list|(
name|cfbuf
argument_list|,
name|getruid
argument_list|()
argument_list|,
name|S_IREAD
argument_list|)
condition|)
name|readcf
argument_list|(
name|cfbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* if the user has given fullname already, don't redefine */
if|if
condition|(
name|FullName
operator|==
name|NULL
condition|)
name|FullName
operator|=
name|macvalue
argument_list|(
literal|'x'
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* extract full name from passwd file */
if|if
condition|(
operator|!
name|nofullname
operator|&&
operator|(
name|FullName
operator|==
name|NULL
operator|||
name|FullName
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|pw_gecos
operator|!=
name|NULL
condition|)
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|fullname
argument_list|(
name|pw
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|FullName
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FullName
operator|!=
name|NULL
operator|&&
name|FullName
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|define
argument_list|(
literal|'x'
argument_list|,
name|FullName
argument_list|)
expr_stmt|;
name|setfrom
argument_list|(
name|from
argument_list|,
name|realname
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INITSYS -- initialize instantiation of system ** **	In Daemon mode, this is done in the child. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Initializes the system macros, some global variables, **		etc.  In particular, the current time in various **		forms is set. */
end_comment

begin_macro
name|initsys
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|cbuf
index|[
literal|5
index|]
decl_stmt|;
comment|/* holds hop count */
specifier|static
name|char
name|dbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* holds ctime(tbuf) */
specifier|static
name|char
name|pbuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds pid */
specifier|static
name|char
name|tbuf
index|[
literal|20
index|]
decl_stmt|;
comment|/* holds "current" time */
specifier|static
name|char
name|ybuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds tty id */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|extern
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
specifier|auto
name|time_t
name|now
decl_stmt|;
comment|/* 	**  Give this envelope a reality. 	**	I.e., an id, a transcript, and a creation time. 	*/
name|openxscrpt
argument_list|()
expr_stmt|;
name|CurEnv
operator|->
name|e_ctime
operator|=
name|curtime
argument_list|()
expr_stmt|;
comment|/* 	**  Set OutChannel to something useful if stdout isn't it. 	**	This arranges that any extra stuff the mailer produces 	**	gets sent back to the user on error (because it is 	**	tucked away in the transcript). 	*/
if|if
condition|(
name|Mode
operator|==
name|MD_DAEMON
operator|&&
name|QueueRun
condition|)
name|OutChannel
operator|=
name|Xscript
expr_stmt|;
comment|/* 	**  Set up some basic system macros. 	*/
comment|/* process id */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'p'
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
comment|/* hop count */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"%d"
argument_list|,
name|HopCount
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'c'
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
comment|/* time as integer, unix time, arpa time */
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%02d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'t'
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dbuf
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|index
argument_list|(
name|dbuf
argument_list|,
literal|'\n'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|macvalue
argument_list|(
literal|'d'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
name|define
argument_list|(
literal|'d'
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|arpadate
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macvalue
argument_list|(
literal|'a'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
name|define
argument_list|(
literal|'a'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'b'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* version */
name|define
argument_list|(
literal|'v'
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* tty name */
if|if
condition|(
name|macvalue
argument_list|(
literal|'y'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ybuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'y'
argument_list|,
name|ybuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INITMACROS -- initialize the macro system ** **	This just involves defining some macros that are actually **	used internally as metasymbols to be themselves. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		initializes several macros to be themselves. */
end_comment

begin_struct
struct|struct
name|metamac
block|{
name|char
name|metaname
decl_stmt|;
name|char
name|metaval
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|metamac
name|MetaMacros
index|[]
init|=
block|{
comment|/* these are important on the LHS */
literal|'*'
block|,
name|MATCHZANY
block|,
literal|'+'
block|,
name|MATCHANY
block|,
literal|'-'
block|,
name|MATCHONE
block|,
literal|'='
block|,
name|MATCHCLASS
block|,
comment|/* these are RHS metasymbols */
literal|'#'
block|,
name|CANONNET
block|,
literal|'@'
block|,
name|CANONHOST
block|,
literal|':'
block|,
name|CANONUSER
block|,
literal|'>'
block|,
name|CALLSUBR
block|,
comment|/* and finally the conditional operations */
literal|'?'
block|,
name|CONDIF
block|,
literal|'|'
block|,
name|CONDELSE
block|,
literal|'.'
block|,
name|CONDFI
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|initmacros
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|metamac
modifier|*
name|m
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
for|for
control|(
name|m
operator|=
name|MetaMacros
init|;
name|m
operator|->
name|metaname
operator|!=
literal|'\0'
condition|;
name|m
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|m
operator|->
name|metaval
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
name|m
operator|->
name|metaname
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|MATCHREPL
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|'0'
init|;
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|++
control|)
block|{
name|buf
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|define
argument_list|(
name|c
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  NEWENVELOPE -- allocate a new envelope ** **	Supports inheritance. ** **	Parameters: **		e -- the new envelope to fill in. ** **	Returns: **		e. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ENVELOPE
modifier|*
name|newenvelope
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|bh
decl_stmt|;
specifier|register
name|HDR
modifier|*
modifier|*
name|nhp
decl_stmt|;
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
operator|&
name|e
operator|->
name|e_from
argument_list|,
sizeof|sizeof
name|e
operator|->
name|e_from
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_parent
operator|=
name|CurEnv
expr_stmt|;
name|e
operator|->
name|e_ctime
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|e
operator|->
name|e_puthdr
operator|=
name|CurEnv
operator|->
name|e_puthdr
expr_stmt|;
name|e
operator|->
name|e_putbody
operator|=
name|CurEnv
operator|->
name|e_putbody
expr_stmt|;
name|bh
operator|=
name|BlankEnvelope
operator|.
name|e_header
expr_stmt|;
name|nhp
operator|=
operator|&
name|e
operator|->
name|e_header
expr_stmt|;
while|while
condition|(
name|bh
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nhp
operator|=
operator|(
name|HDR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|bh
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bh
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|*
name|nhp
argument_list|,
sizeof|sizeof
expr|*
name|bh
argument_list|)
expr_stmt|;
name|bh
operator|=
name|bh
operator|->
name|h_link
expr_stmt|;
name|nhp
operator|=
operator|&
operator|(
operator|*
name|nhp
operator|)
operator|->
name|h_link
expr_stmt|;
block|}
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  DROPENVELOPE -- deallocate an envelope. ** **	Parameters: **		e -- the envelope to deallocate. ** **	Returns: **		none. ** **	Side Effects: **		housekeeping necessary to dispose of an envelope. */
end_comment

begin_expr_stmt
name|dropenvelope
argument_list|(
name|e
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|e
operator|->
name|e_df
operator|!=
name|NULL
condition|)
name|xunlink
argument_list|(
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_qf
operator|!=
name|NULL
condition|)
name|xunlink
argument_list|(
name|e
operator|->
name|e_qf
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|!=
name|NULL
condition|)
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'l'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  QUEUENAME -- build a file name in the queue directory for this envelope. ** **	Assigns an id code if one does not already exist. **	This code is very careful to avoid trashing existing files **	under any circumstances. **		We first create an nf file that is only used when **		assigning an id.  This file is always empty, so that **		we can never accidently truncate an lf file. ** **	Parameters: **		e -- envelope to build it in/from. **		type -- the file type, used as the first character **			of the file name. ** **	Returns: **		a pointer to the new file name (in a static buffer). ** **	Side Effects: **		Will create the lf and qf files if no id code is **		already assigned.  This will cause the envelope **		to be modified. */
end_comment

begin_function
name|char
modifier|*
name|queuename
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
block|{
name|char
name|counter
init|=
literal|'A'
operator|-
literal|1
decl_stmt|;
name|char
name|qf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|lf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|nf
index|[
literal|20
index|]
decl_stmt|;
comment|/* find a unique id */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|qf
argument_list|,
literal|"qf_%05d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lf
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|lf
index|[
literal|0
index|]
operator|=
literal|'l'
expr_stmt|;
name|strcpy
argument_list|(
name|nf
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|nf
index|[
literal|0
index|]
operator|=
literal|'n'
expr_stmt|;
while|while
condition|(
name|counter
operator|<
literal|'~'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|qf
index|[
literal|2
index|]
operator|=
name|lf
index|[
literal|2
index|]
operator|=
name|nf
index|[
literal|2
index|]
operator|=
operator|++
name|counter
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|20
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: trying \"%s\"\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|access
argument_list|(
name|lf
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|||
name|access
argument_list|(
name|qf
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
continue|continue;
name|errno
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|creat
argument_list|(
name|nf
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|nf
argument_list|)
expr_stmt|;
comment|/* kernel bug */
continue|continue;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|link
argument_list|(
name|nf
argument_list|,
name|lf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|nf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|link
argument_list|(
name|lf
argument_list|,
name|qf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|>=
literal|'~'
condition|)
block|{
name|syserr
argument_list|(
literal|"queuename: Cannot create \"%s\" in \"%s\""
argument_list|,
name|lf
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_qf
operator|=
name|newstr
argument_list|(
name|qf
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_id
operator|=
operator|&
name|e
operator|->
name|e_qf
index|[
literal|2
index|]
expr_stmt|;
name|define
argument_list|(
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: assigned id %s, env=%x\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|type
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%cf%s"
argument_list|,
name|type
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FREEZE -- freeze BSS& allocated memory ** **	This will be used to efficiently load the configuration file. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Writes BSS and malloc'ed memory to FreezeFile */
end_comment

begin_struct
struct|struct
name|frz
block|{
name|time_t
name|frzstamp
decl_stmt|;
comment|/* timestamp on this freeze */
name|char
modifier|*
name|frzbrk
decl_stmt|;
comment|/* the current break */
name|char
name|frzver
index|[
literal|252
index|]
decl_stmt|;
comment|/* sendmail version */
block|}
struct|;
end_struct

begin_macro
name|freeze
argument_list|()
end_macro

begin_block
block|{
name|int
name|f
decl_stmt|;
name|struct
name|frz
name|fhdr
decl_stmt|;
specifier|extern
name|char
name|edata
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sbrk
parameter_list|()
function_decl|;
if|if
condition|(
name|FreezeFile
operator|==
name|NULL
condition|)
return|return;
comment|/* try to open the freeze file */
name|f
operator|=
name|open
argument_list|(
name|FreezeFile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot freeze"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* build the freeze header */
name|fhdr
operator|.
name|frzstamp
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|fhdr
operator|.
name|frzbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fhdr
operator|.
name|frzver
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* write out the freeze header */
if|if
condition|(
name|write
argument_list|(
name|f
argument_list|,
operator|&
name|fhdr
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
operator|!=
sizeof|sizeof
name|fhdr
operator|||
name|write
argument_list|(
name|f
argument_list|,
operator|&
name|edata
argument_list|,
name|fhdr
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
operator|!=
operator|(
name|fhdr
operator|.
name|frzbrk
operator|-
operator|&
name|edata
operator|)
condition|)
name|syserr
argument_list|(
literal|"Cannot freeze"
argument_list|)
expr_stmt|;
comment|/* fine, clean up */
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  THAW -- read in the frozen configuration file. ** **	Parameters: **		none. ** **	Returns: **		TRUE if it successfully read the freeze file. **		FALSE otherwise. ** **	Side Effects: **		reads FreezeFile in to BSS area. */
end_comment

begin_macro
name|thaw
argument_list|()
end_macro

begin_block
block|{
name|int
name|f
decl_stmt|;
name|struct
name|frz
name|fhdr
decl_stmt|;
specifier|extern
name|char
name|edata
decl_stmt|;
if|if
condition|(
name|FreezeFile
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* open the freeze file */
name|f
operator|=
name|open
argument_list|(
name|FreezeFile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* read in the header */
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|fhdr
argument_list|,
sizeof|sizeof
name|fhdr
argument_list|)
operator|<
sizeof|sizeof
name|fhdr
operator|||
name|strcmp
argument_list|(
name|fhdr
operator|.
name|frzver
argument_list|,
name|Version
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* arrange to have enough space */
if|if
condition|(
name|brk
argument_list|(
name|fhdr
operator|.
name|frzbrk
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot break to %x"
argument_list|,
name|fhdr
operator|.
name|frzbrk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* now read in the freeze file */
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|&
name|edata
argument_list|,
name|fhdr
operator|.
name|frzbrk
operator|-
operator|&
name|edata
argument_list|)
operator|!=
operator|(
name|fhdr
operator|.
name|frzbrk
operator|-
operator|&
name|edata
operator|)
condition|)
block|{
comment|/* oops!  we have trashed memory..... */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot read freeze file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SOFTWARE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

end_unit

