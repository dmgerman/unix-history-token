begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_define
define|#
directive|define
name|_DEFINE
end_define

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)main.c	3.38	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SENDMAIL -- Post mail to a set of destinations. ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Sendmail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Sendmail is driven by tables defined in conf.c.  This **	file will be different from system to system, but the rest **	of the code will be the same.  This table could be read in, **	but it seemed nicer to have it compiled in, since deliver- **	mail will potentially be exercised a lot. ** **	Usage: **		/etc/sendmail [-f name] [-a] [-q] [-v] [-n] [-m] addr ... ** **	Positional Parameters: **		addr -- the address to deliver the mail to.  There **			can be several. ** **	Flags: **		-f name		The mail is from "name" -- used for **				the header in local mail, and to **				deliver reports of failures to. **		-r name		Same as -f; however, this flag is **				reserved to indicate special processing **				for remote mail delivery as needed **				in the future.  So, network servers **				should use -r. **		-Ffullname	Select what the full-name should be **				listed as. **		-a		This mail should be in ARPANET std **				format (obsolete version). **		-am		Called from an FTP "MAIL" command. **		-af		Called from an FTP "MLFL" command. **		-n		Don't do aliasing.  This might be used **				when delivering responses, for **				instance. **		-d		Run in debug mode. **		-em		Mail back a response if there was an **				error in processing.  This should be **				used when the origin of this message **				is another machine. **		-ew		Write back a response if the user is **				still logged in, otherwise, act like **				-em. **		-eq		Don't print any error message (just **				return exit status). **		-ep		(default)  Print error messages **				normally. **		-ee		Send BerkNet style errors.  This **				is equivalent to MailBack except **				that it has gives zero return code **				(unless there were errors during **				returning).  This used to be **				"EchoBack", but you know how the old **				software bounces. **		-m		In group expansion, send to the **				sender also (stands for the Mail metoo **				option. **		-i		Do not terminate mail on a line **				containing just dot. **		-s		Save UNIX-like "From" lines on the **				front of messages. **		-v		Give blow-by-blow description of **				everything that happens. **		-t		Read "to" addresses from message. **				Looks at To:, Cc:, and Bcc: lines. **		-I		Initialize the DBM alias files from **				the text format files. **		-Cfilename	Use alternate configuration file. **		-Afilename	Use alternate alias file. **		-DXvalue	Define macro X to have value. ** **	Return Codes: **		As defined in<sysexits.h>. ** **		These codes are actually returned from the auxiliary **		mailers; it is their responsibility to make them **		correct. ** **	Compilation Flags: **		LOG -- if set, everything is logged. ** **	Author: **		Eric Allman, UCB/INGRES */
end_comment

begin_decl_stmt
name|char
name|InFileName
index|[]
init|=
literal|"/tmp/mailtXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Transcript
index|[]
init|=
literal|"/tmp/mailxXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|NextMailer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "free" index into Mailer struct */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|realname
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
name|NULL
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
name|char
modifier|*
name|locname
decl_stmt|;
specifier|extern
name|int
name|finis
parameter_list|()
function_decl|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|fnptr
function_decl|)
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|AliasFile
decl_stmt|;
comment|/* location of alias file */
specifier|extern
name|char
modifier|*
name|ConfFile
decl_stmt|;
comment|/* location of configuration file */
specifier|extern
name|char
modifier|*
name|StatFile
decl_stmt|;
comment|/* location of statistics summary */
specifier|register
name|int
name|i
decl_stmt|;
name|bool
name|verifyonly
init|=
name|FALSE
decl_stmt|;
comment|/* only verify names */
name|bool
name|safecf
init|=
name|TRUE
decl_stmt|;
comment|/* this conf file is sys default */
name|char
name|pbuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds pid */
name|char
name|tbuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds "current" time */
name|char
name|cbuf
index|[
literal|5
index|]
decl_stmt|;
comment|/* holds hop count */
name|char
name|dbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* holds ctime(tbuf) */
name|char
name|ybuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds tty id */
name|bool
name|aliasinit
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
name|bool
name|canrename
decl_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|finis
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|finis
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|finis
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|OldUmask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
name|openlog
argument_list|(
literal|"sendmail"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
ifdef|#
directive|ifdef
name|DEBUG
ifdef|#
directive|ifdef
name|DEBUGFILE
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|DEBUGFILE
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|i
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Debug
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUGFILE
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* 	**  Initialize and define basic system macros. 	**	Collect should be called first, so that the time 	**	corresponds to the time that the messages starts 	**	getting sent, rather than when it is first composed. 	*/
name|from
operator|=
name|NULL
expr_stmt|;
comment|/* process id */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'p'
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
comment|/* hop count */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"%d"
argument_list|,
name|HopCount
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'c'
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
comment|/* time as integer, unix time, arpa time */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|CurTime
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|&
name|CurTime
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'t'
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dbuf
argument_list|,
name|ctime
argument_list|(
operator|&
name|CurTime
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|index
argument_list|(
name|dbuf
argument_list|,
literal|'\n'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|define
argument_list|(
literal|'d'
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|arpadate
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'a'
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'b'
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* version */
name|define
argument_list|(
literal|'v'
argument_list|,
name|Version
argument_list|)
expr_stmt|;
comment|/* tty name */
name|p
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|ybuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'y'
argument_list|,
name|ybuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Crack argv. 	*/
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|(
name|p
operator|=
operator|*
operator|++
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
case|case
literal|'f'
case|:
comment|/* from address */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|syserr
argument_list|(
literal|"No \"from\" person"
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* set full name */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad -F flag"
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|fullname
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
operator|||
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|HopCount
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* error message disposition */
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* print errors normally */
break|break;
comment|/* (default) */
case|case
literal|'q'
case|:
comment|/* be silent about it */
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* mail back */
name|MailBack
operator|++
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* do berknet error processing */
name|BerkNet
operator|++
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* write back (or mail) */
name|WriteBack
operator|++
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
comment|/* debug */
name|Debug
operator|=
name|atoi
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Debug
operator|<=
literal|0
condition|)
name|Debug
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Version %s Debug %d\n"
argument_list|,
name|Version
argument_list|,
name|Debug
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* redefine internal macro */
name|define
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|,
operator|&
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DEBUG
case|case
literal|'C'
case|:
comment|/* select configuration file */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|ConfFile
operator|=
literal|"sendmail.cf"
expr_stmt|;
else|else
name|ConfFile
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
name|safecf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* select alias file */
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|AliasFile
operator|=
literal|"aliases"
expr_stmt|;
else|else
name|AliasFile
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DBM
case|case
literal|'I'
case|:
comment|/* initialize alias DBM file */
name|aliasinit
operator|=
name|TRUE
expr_stmt|;
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DBM
case|case
literal|'m'
case|:
comment|/* send to me too */
name|MeToo
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
name|IgnrDot
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* verify only */
name|verifyonly
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arpanet format */
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* mail from file connection */
name|ArpaMode
operator|=
name|ARPA_FILE
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* mail over telnet connection */
name|ArpaMode
operator|=
name|ARPA_MAIL
expr_stmt|;
break|break;
default|default:
name|ArpaMode
operator|=
name|ARPA_OLD
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|SaveFrom
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* give blow-by-blow description */
name|Verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* read recipients from message */
name|GrabTo
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* at Eric Schmidt's suggestion, this will not be an error.... 			syserr("Unknown flag %s", p); 			... seems that upward compatibility will be easier. */
break|break;
block|}
block|}
comment|/* 	**  Read control file. 	*/
name|readcf
argument_list|(
name|ConfFile
argument_list|,
name|safecf
argument_list|)
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|char
name|cfbuf
index|[
literal|60
index|]
decl_stmt|;
name|define
argument_list|(
literal|'z'
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|expand
argument_list|(
literal|"$z/.mailcf"
argument_list|,
name|cfbuf
argument_list|,
operator|&
name|cfbuf
index|[
sizeof|sizeof
name|cfbuf
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|cfbuf
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|readcf
argument_list|(
name|cfbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|initaliases
argument_list|(
name|AliasFile
argument_list|,
name|aliasinit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBM
if|if
condition|(
name|aliasinit
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DBM
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|15
condition|)
block|{
name|printrules
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAILERS
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|mailer
modifier|*
name|m
init|=
name|Mailer
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"mailer %d: %s %s %o %s\n"
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|,
name|m
operator|->
name|m_flags
argument_list|,
name|m
operator|->
name|m_from
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* 	locname = getname(); 	if (locname == NULL || locname[0] == '\0') 	{ 		extern struct passwd *getpwuid(); 		int uid;  		uid = getruid(); 		pw = getpwuid(uid); 		if (pw == NULL) 			syserr("Who are you? (uid=%d)", uid); 		else 			p = pw->pw_name; 	} 	else 	{ 		extern struct passwd *getpwnam();  		pw = getpwnam(p); 		if (pw == NULL) 			syserr("Who are you? (name=%s)", p); 	} 	if (p == NULL || p[0] == '\0' || pw == NULL) 		finis();  	realname = p;  	/* extract full name from passwd file */
if|if
condition|(
operator|(
name|fullname
operator|==
name|NULL
operator|||
name|fullname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|pw_gecos
operator|!=
name|NULL
condition|)
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|realname
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ArpaMode
operator|==
name|ARPA_NONE
operator|&&
name|from
operator|==
name|NULL
operator|&&
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fullname
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullname
operator|!=
name|NULL
operator|&&
name|fullname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|define
argument_list|(
literal|'x'
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|setfrom
argument_list|(
name|from
argument_list|,
name|realname
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|0
operator|&&
operator|!
name|GrabTo
condition|)
name|usrerr
argument_list|(
literal|"Usage: /etc/sendmail [flags] addr..."
argument_list|)
expr_stmt|;
comment|/* 	**  Process Hop count. 	**	The Hop count tells us how many times this message has 	**	been processed by sendmail.  If it exceeds some 	**	fairly large threshold, then we assume that we have 	**	an infinite forwarding loop and die. 	*/
if|if
condition|(
operator|++
name|HopCount
operator|>
name|MAXHOP
condition|)
name|syserr
argument_list|(
literal|"Infinite forwarding loop (%s->%s)"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* 	**  Scan argv and deliver the message to everyone. 	**	Actually, suppress delivery if we are taking To: 	**	lines from the message. 	*/
if|if
condition|(
name|GrabTo
condition|)
name|DontSend
operator|=
name|TRUE
expr_stmt|;
name|sendtoargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* if we have had errors sofar, drop out now */
if|if
condition|(
name|Errors
operator|>
literal|0
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
if|if
condition|(
name|ArpaMode
operator|>
name|ARPA_OLD
operator|&&
name|ExitStat
operator|!=
name|EX_OK
condition|)
name|finis
argument_list|()
expr_stmt|;
comment|/* 	**  Read the input mail. 	*/
name|DontSend
operator|=
name|FALSE
expr_stmt|;
name|To
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|verifyonly
operator|||
name|GrabTo
condition|)
name|collect
argument_list|()
expr_stmt|;
comment|/* collect statistics */
name|Stat
operator|.
name|stat_nf
index|[
name|From
operator|.
name|q_mailer
index|]
operator|++
expr_stmt|;
name|Stat
operator|.
name|stat_bf
index|[
name|From
operator|.
name|q_mailer
index|]
operator|+=
name|kbytes
argument_list|(
name|MsgSize
argument_list|)
expr_stmt|;
comment|/* 	**  Arrange that the person who is sending the mail 	**  will not be expanded (unless explicitly requested). 	*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|From
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
operator|!
name|MeToo
condition|)
name|recipient
argument_list|(
operator|&
name|From
argument_list|)
expr_stmt|;
name|To
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Actually send everything. 	**	If verifying, just ack. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Mailer
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|ADDRESS
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|Mailer
index|[
name|i
index|]
operator|->
name|m_sendq
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|verifyonly
condition|)
block|{
name|To
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|q_mailer
operator|==
name|MN_LOCAL
operator|||
name|q
operator|->
name|q_mailer
operator|==
name|MN_PROG
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"deliverable"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"queueable"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|deliver
argument_list|(
name|q
argument_list|,
operator|(
name|fnptr
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	** All done. 	*/
name|To
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|Errors
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|ArpaMode
condition|)
block|{
specifier|static
name|char
modifier|*
name|okmsg
init|=
literal|"Mail accepted"
decl_stmt|;
specifier|extern
name|char
name|Arpa_Fmsg
index|[]
decl_stmt|,
name|Arpa_Mmsg
index|[]
decl_stmt|;
case|case
name|ARPA_FILE
case|:
name|message
argument_list|(
name|Arpa_Fmsg
argument_list|,
name|okmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARPA_MAIL
case|:
name|message
argument_list|(
name|Arpa_Mmsg
argument_list|,
name|okmsg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|verifyonly
condition|)
name|poststats
argument_list|(
name|StatFile
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SETFROM -- set the person who this message is from ** **	Under certain circumstances allow the user to say who **	s/he is (using -f or -r).  These are: **	1.  The user's uid is zero (root). **	2.  The user's login name is "network" (mail from **	    a network server). **	3.  The user's login name is "uucp" (mail from the **	    uucp network). **	4.  The address the user is trying to claim has a **	    "!" character in it (since #3 doesn't do it for **	    us if we are dialing out). **	A better check to replace #3& #4 would be if the **	effective uid is "UUCP" -- this would require me **	to rewrite getpwent to "grab" uucp as it went by, **	make getname more nasty, do another passwd file **	scan, or compile the UID of "UUCP" into the code, **	all of which are reprehensible. ** **	Assuming all of these fail, we figure out something **	ourselves. ** **	Parameters: **		from -- the person it is from. **		realname -- the actual person executing sendmail. **			If NULL, then take whoever we previously **			thought was the from person. ** **	Returns: **		none. ** **	Side Effects: **		sets sendmail's notion of who the from person is. */
end_comment

begin_macro
name|setfrom
argument_list|(
argument|from
argument_list|,
argument|realname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|realname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
name|frombuf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
if|if
condition|(
name|realname
operator|==
name|NULL
condition|)
name|realname
operator|=
name|From
operator|.
name|q_paddr
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|realname
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|realname
argument_list|,
literal|"uucp"
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|from
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* network sends -r regardless (why why why?) */
comment|/* syserr("%s, you cannot use the -f flag", realname); */
name|from
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|parse
argument_list|(
name|from
argument_list|,
operator|&
name|From
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|from
operator|=
name|newstr
argument_list|(
name|realname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse
argument_list|(
name|from
argument_list|,
operator|&
name|From
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|FromFlag
operator|=
name|TRUE
expr_stmt|;
name|SuprErrs
operator|=
name|FALSE
expr_stmt|;
name|From
operator|.
name|q_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|From
operator|.
name|q_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
name|From
operator|.
name|q_home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|V6
name|From
operator|.
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
comment|/* 	**  Rewrite the from person to dispose of possible implicit 	**	links in the net. 	*/
name|pvp
operator|=
name|prescan
argument_list|(
name|from
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot prescan from (%s)"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|frombuf
argument_list|,
sizeof|sizeof
name|frombuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'f'
argument_list|,
name|newstr
argument_list|(
name|frombuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Parameters: **		none ** **	Returns: **		never ** **	Side Effects: **		exits sendmail */
end_comment

begin_macro
name|finis
argument_list|()
end_macro

begin_block
block|{
comment|/* mail back the transcript on errors */
if|if
condition|(
name|ExitStat
operator|!=
name|EX_OK
condition|)
name|savemail
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasXscrpt
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|Transcript
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|InFileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  OPENXSCRPT -- Open transcript file ** **	Creates a transcript file for possible eventual mailing or **	sending back. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Turns the standard output into a special file **			somewhere. */
end_comment

begin_macro
name|openxscrpt
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|Transcript
argument_list|)
expr_stmt|;
name|HasXscrpt
operator|++
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|Transcript
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Can't create %s"
argument_list|,
name|Transcript
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|Transcript
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

