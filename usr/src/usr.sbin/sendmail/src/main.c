begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"dlvrmail.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_include
include|#
directive|include
file|<log.h>
end_include

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_comment
comment|/* **  DELIVERMAIL -- Deliver mail to a set of destinations ** **	This is the basic mail router.  All user mail programs should **	call this routine to actually deliver mail.  Delivermail in **	turn calls a bunch of mail servers that do the real work of **	delivering the mail. ** **	Delivermail is driven by tables defined in config.c.  This **	file will be different from system to system, but the rest **	of the code will be the same.  This table could be read in, **	but it seemed nicer to have it compiled in, since deliver- **	mail will potentially be exercised a lot. ** **	Usage: **		/etc/delivermail [-f name] [-a] [-q] [-v] [-n] [-m] addr ... ** **	Positional Parameters: **		addr -- the address to deliver the mail to.  There **			can be several. ** **	Flags: **		-f name		The mail is from "name" -- used for **				the header in local mail, and to **				deliver reports of failures to. **		-r name		Same as -f; however, this flag is **				reserved to indicate special processing **				for remote mail delivery as needed **				in the future.  So, network servers **				should use -r. **		-a		This mail should be in ARPANET std **				format (not used). **		-n		Don't do aliasing.  This might be used **				when delivering responses, for **				instance. **		-d		Run in debug mode. **		-em		Mail back a response if there was an **				error in processing.  This should be **				used when the origin of this message **				is another machine. **		-ew		Write back a response if the user is **				still logged in, otherwise, act like **				-em. **		-eq		Don't print any error message (just **				return exit status). **		-ep		(default)  Print error messages **				normally. **		-m		In group expansion, send to the **				sender also (stands for the Mail metoo **				option. **		-i		Do not terminate mail on a line **				containing just dot. **		-s		Save UNIX-like "From" lines on the **				front of messages. ** **	Return Codes: **		As defined in<sysexits.h>. ** **		These codes are actually returned from the auxiliary **		mailers; it is their responsibility to make them **		correct. ** **	Defined Constants: **		none ** **	Compilation Flags: **		BADMAIL -- the mailer used for local mail doesn't **			return the standard set of exit codes.  This **			causes the name to be looked up before mail **			is ever sent. **		LOG -- if set, everything is logged. **		MESSAGEID -- if set, the Message-Id field is added **			to the message header if one does not already **			exist.  This can be used to delete duplicate **			messages. ** **	Compilation Instructions: **		cc -c -O main.c config.c deliver.c parse.c **		cc -n -s *.o -lS **		chown root a.out **		chmod 755 a.out **		mv a.out delivermail ** **	Requires: **		signal (sys) **		setbuf (sys) **		initlog (libX) **		open (sys) **		lseek (sys) **		close (sys) **		dup (sys) **		printf (sys) **		syserr **		atoi (sys) **		freopen (sys) **		openxscript **		maketemp **		getname **		strcmp (sys) **		getuid (sys) **		parse **		usrerr **		finis **		sendto **		alias **		recipient **		nxtinq **		deliver ** **	Deficiencies: **		It ought to collect together messages that are **			destined for a single host and send these **			to the auxiliary mail server together. **		It should take "user at host" as three separate **			parameters and combine them into one address. ** **	Author: **		Eric Allman, UCB/INGRES ** **	History: **		12/26/79 -- first written. */
end_comment

begin_decl_stmt
name|char
name|ArpaFmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mail is expected to be in ARPANET format */
end_comment

begin_decl_stmt
name|char
name|FromFlag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from person is explicitly specified */
end_comment

begin_decl_stmt
name|char
name|Debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run in debug mode */
end_comment

begin_decl_stmt
name|char
name|MailBack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mail back response on error */
end_comment

begin_decl_stmt
name|char
name|EchoBack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* echo the message on error */
end_comment

begin_decl_stmt
name|char
name|WriteBack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write back response on error */
end_comment

begin_decl_stmt
name|char
name|HasXscrpt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, the transcript file exists */
end_comment

begin_decl_stmt
name|char
name|NoAlias
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't do aliasing */
end_comment

begin_decl_stmt
name|char
name|ForceMail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mail even if already sent a copy */
end_comment

begin_decl_stmt
name|char
name|MeToo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send to the sender also if in a group expansion */
end_comment

begin_decl_stmt
name|char
name|SaveFrom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save From lines on the front of messages */
end_comment

begin_decl_stmt
name|char
name|IgnrDot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if set, ignore dot when collecting mail */
end_comment

begin_decl_stmt
name|char
name|Error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if errors */
end_comment

begin_decl_stmt
name|char
name|SuprErrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* supress errors if set */
end_comment

begin_decl_stmt
name|char
name|InFileName
index|[]
init|=
literal|"/tmp/mailtXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Transcript
index|[]
init|=
literal|"/tmp/mailxXXXXXX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|addrq
name|From
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the from person */
end_comment

begin_decl_stmt
name|char
modifier|*
name|To
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the target person */
end_comment

begin_decl_stmt
name|char
name|MsgId
index|[
name|MAXNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the message-id for this letter */
end_comment

begin_decl_stmt
name|int
name|HopCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hop count */
end_comment

begin_decl_stmt
name|int
name|ExitStat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the exit status byte */
end_comment

begin_decl_stmt
name|addrq
name|SendQ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of people to send to */
end_comment

begin_decl_stmt
name|addrq
name|AliasQ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of people who turned out to be aliases */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|maketemp
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
specifier|extern
name|int
name|finis
parameter_list|()
function_decl|;
specifier|extern
name|addrq
modifier|*
name|parse
parameter_list|()
function_decl|;
specifier|register
name|addrq
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|fnptr
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|finis
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|finis
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
name|initlog
argument_list|(
literal|"delivermail"
argument_list|,
literal|0
argument_list|,
name|LOG_INDEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
ifdef|#
directive|ifdef
name|DEBUG
ifdef|#
directive|ifdef
name|DEBUGFILE
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|DEBUGFILE
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|lseek
argument_list|(
name|i
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Debug
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUGFILE
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|Version
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
name|from
operator|=
name|NULL
expr_stmt|;
comment|/* 	** Crack argv. 	*/
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|(
name|p
operator|=
operator|*
operator|++
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* obsolete -f flag */
case|case
literal|'f'
case|:
comment|/* from address */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|syserr
argument_list|(
literal|"No \"from\" person"
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|p
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hop count */
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|<=
literal|0
operator|||
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
block|{
name|syserr
argument_list|(
literal|"Bad hop count (%s)"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|argc
operator|++
expr_stmt|;
name|argv
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|HopCount
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* error message disposition */
switch|switch
condition|(
name|p
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* print errors normally */
break|break;
comment|/* (default) */
case|case
literal|'q'
case|:
comment|/* be silent about it */
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* mail back */
name|MailBack
operator|++
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* echo back */
name|EchoBack
operator|++
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* write back (or mail) */
name|WriteBack
operator|++
expr_stmt|;
name|openxscrpt
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
comment|/* debug */
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DEBUG
case|case
literal|'n'
case|:
comment|/* don't alias */
name|NoAlias
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* send to me too */
name|MeToo
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* don't let dot stop me */
name|IgnrDot
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* arpanet format */
name|ArpaFmt
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* save From lines in headers */
name|SaveFrom
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* at Eric Schmidt's suggestion, this will not be an error.... 			syserr("Unknown flag %s", p); 			... seems that upward compatibility will be easier. */
break|break;
block|}
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
operator|&&
name|ArpaFmt
condition|)
name|syserr
argument_list|(
literal|"-f and -a are mutually exclusive"
argument_list|)
expr_stmt|;
comment|/* 	** Get a temp file. 	*/
name|p
operator|=
name|maketemp
argument_list|()
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
name|from
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"Message-Id:<%s>\n"
argument_list|,
name|MsgId
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Figure out who it's coming from. 	**	If we are root or "network", then allow -f.  Otherwise, 	**	insist that we figure it out ourselves. 	*/
name|errno
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|getname
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"Who are you? (uid=%d)"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"network"
argument_list|)
operator|!=
literal|0
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
comment|/*&& strcmp(p, From) != 0 */
condition|)
block|{
comment|/* network sends -r regardless (why why why?) */
comment|/* syserr("%s, you cannot use the -f flag", p); */
name|from
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|from
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|from
operator|=
name|p
expr_stmt|;
else|else
name|FromFlag
operator|++
expr_stmt|;
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|parse
argument_list|(
name|from
argument_list|,
operator|&
name|From
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* too many arpanet hosts generate garbage From addresses .... 		syserr("Bad from address `%s'", from); 		.... so we will just ignore this address */
name|from
operator|=
name|p
expr_stmt|;
name|FromFlag
operator|=
name|FALSE
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"From person = \"%s\"\n"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|usrerr
argument_list|(
literal|"Usage: /etc/delivermail [flags] addr..."
argument_list|)
expr_stmt|;
comment|/* 	**  Process Hop count. 	**	The Hop count tells us how many times this message has 	**	been processed by delivermail.  If it exceeds some 	**	fairly large threshold, then we assume that we have 	**	an infinite forwarding loop and die. 	*/
if|if
condition|(
operator|++
name|HopCount
operator|>
name|MAXHOP
condition|)
name|syserr
argument_list|(
literal|"Infinite forwarding loop (%s->%s)"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* if we have had errors sofar, drop out now */
if|if
condition|(
name|Error
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
if|if
condition|(
name|ExitStat
operator|!=
name|EX_OK
condition|)
name|finis
argument_list|()
expr_stmt|;
comment|/* 	** Scan argv and deliver the message to everyone. 	*/
for|for
control|(
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
name|argv
operator|++
control|)
block|{
name|sendto
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  See if we have anyone to send to at all. 	*/
if|if
condition|(
name|nxtinq
argument_list|(
operator|&
name|SendQ
argument_list|)
operator|==
name|NULL
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
block|{
name|syserr
argument_list|(
literal|"Noone to send to!"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_USAGE
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
comment|/* 	**  Do aliasing. 	**	First arrange that the person who is sending the mail 	**	will not be expanded (unless explicitly requested). 	*/
if|if
condition|(
operator|!
name|MeToo
condition|)
name|recipient
argument_list|(
operator|&
name|From
argument_list|,
operator|&
name|AliasQ
argument_list|)
expr_stmt|;
name|To
operator|=
name|NULL
expr_stmt|;
name|alias
argument_list|()
expr_stmt|;
if|if
condition|(
name|nxtinq
argument_list|(
operator|&
name|SendQ
argument_list|)
operator|==
name|NULL
operator|&&
name|ExitStat
operator|==
name|EX_OK
condition|)
block|{
comment|/* 		syserr("Vacant send queue; probably aliasing loop"); 		ExitStat = EX_SOFTWARE; 		finis(); */
name|recipient
argument_list|(
operator|&
name|From
argument_list|,
operator|&
name|SendQ
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Actually send everything. 	*/
for|for
control|(
name|q
operator|=
operator|&
name|SendQ
init|;
operator|(
name|q
operator|=
name|nxtinq
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
name|deliver
argument_list|(
name|q
argument_list|,
operator|(
name|fnptr
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	** All done. 	*/
name|finis
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINIS -- Clean up and exit. ** **	Algorithm: **		if we should remove the input **			remove the input **		exit ** **	Parameters: **		none ** **	Returns: **		never ** **	Side Effects: **		exits delivermail ** **	Requires: **		unlink (sys) **		exit (sys) **		savemail **		InFileName -- the file to remove **		ExitStat -- the status to exit with ** **	Called By: **		main **		via signal on interrupt. ** **	Deficiencies: **		It may be that it should only remove the input **			file if there have been no errors. ** **	History: **		12/26/79 -- written. */
end_comment

begin_macro
name|finis
argument_list|()
end_macro

begin_block
block|{
comment|/* mail back the transcript on errors */
if|if
condition|(
name|ExitStat
operator|!=
name|EX_OK
condition|)
name|savemail
argument_list|()
expr_stmt|;
if|if
condition|(
name|HasXscrpt
condition|)
name|unlink
argument_list|(
name|Transcript
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|InFileName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAKETEMP -- Make temporary file ** **	Creates a temporary file name and copies the standard **	input to that file.  While it is doing it, it looks for **	"From:" and "Sender:" fields to use as the from-person **	(but only if the -a flag is specified).  It prefers to **	to use the "Sender:" field -- the protocol says that **	"Sender:" must come after "From:", so this works easily. **	MIT seems to like to produce "Sent-By:" fields instead **	of "Sender:" fields.  We used to catch this, but it turns **	out that the "Sent-By:" field doesn't always correspond **	to someone real, as required by the protocol.  So we limp **	by..... ** **	Parameters: **		none ** **	Returns: **		Name of temp file. ** **	Side Effects: **		Temp file is created and filled. ** **	Requires: **		creat (sys) **		close (sys) **		syserr **		mktemp (sys) **		fopen (sys) **		fgets (sys) **		makemsgid **		fprintf (sys) **		fputs (sys) **		isspace (sys) **		matchhdr **		prescan **		ferror (sys) **		clearerr (sys) **		freopen (sys) ** **	Called By: **		main ** **	Notes: **		This is broken off from main largely so that the **		temp buffer can be deallocated. ** **	Deficiencies: **		It assumes that the From: field will preceed the **		Sender: field.  This violates the Arpanet NIC 733 **		protocol, but seems reasonable in practice.  In **		any case, the only problem is that error responses **		may be sent to the wrong person. ** **	History: **		12/26/79 -- written. */
end_comment

begin_function
name|char
modifier|*
name|maketemp
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|tf
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
name|fbuf
index|[
sizeof|sizeof
name|buf
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|matchhdr
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|inheader
decl_stmt|;
name|bool
name|firstline
decl_stmt|;
comment|/* 	**  Create the temp file name and create the file. 	*/
name|mktemp
argument_list|(
name|InFileName
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|creat
argument_list|(
name|InFileName
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|=
name|fopen
argument_list|(
name|InFileName
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot create %s"
argument_list|,
name|InFileName
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Copy stdin to temp file& do message editting. 	**	From person gets copied into fbuf.  At the end of 	**	this loop, if fbuf[0] == '\0' then there was no 	**	recognized from person in the message.  We also 	**	save the message id in MsgId.  The 	**	flag 'inheader' keeps track of whether we are 	**	in the header or in the body of the message. 	**	The flag 'firstline' is only true on the first 	**	line of a message. 	**	To keep certain mailers from getting confused, 	**	and to keep the output clean, lines that look 	**	like UNIX "From" lines are deleted in the header, 	**	and prepended with ">" in the body. 	*/
name|inheader
operator|=
name|TRUE
expr_stmt|;
name|firstline
operator|=
name|TRUE
expr_stmt|;
name|fbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|IgnrDot
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|||
name|buf
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
comment|/* are we still in the header? */
if|if
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|inheader
condition|)
block|{
name|inheader
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|MsgId
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|makemsgid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MESSAGEID
name|fprintf
argument_list|(
name|tf
argument_list|,
literal|"Message-Id:<%s>\n"
argument_list|,
name|MsgId
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MESSAGEID
block|}
block|}
comment|/* Hide UNIX-like From lines */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|buf
index|[
literal|3
index|]
operator|==
literal|'m'
operator|&&
name|buf
index|[
literal|4
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|firstline
operator|&&
operator|!
name|SaveFrom
condition|)
continue|continue;
name|fputs
argument_list|(
literal|">"
argument_list|,
name|tf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inheader
operator|&&
operator|!
name|isspace
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* find out if this is really a header */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|inheader
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|inheader
condition|)
block|{
comment|/* find the sender */
name|p
operator|=
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"sender"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|prescan
argument_list|(
name|p
argument_list|,
name|fbuf
argument_list|,
operator|&
name|fbuf
index|[
sizeof|sizeof
name|fbuf
operator|-
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* find the message id */
name|p
operator|=
name|matchhdr
argument_list|(
name|buf
argument_list|,
literal|"message-id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|MsgId
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|prescan
argument_list|(
name|p
argument_list|,
name|MsgId
argument_list|,
operator|&
name|MsgId
index|[
sizeof|sizeof
name|MsgId
operator|-
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|buf
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|firstline
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|tf
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot write %s"
argument_list|,
name|InFileName
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|tf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|tf
argument_list|)
expr_stmt|;
if|if
condition|(
name|MsgId
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|makemsgid
argument_list|()
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|InFileName
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Cannot reopen %s"
argument_list|,
name|InFileName
argument_list|)
expr_stmt|;
return|return
operator|(
name|ArpaFmt
operator|&&
name|fbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|fbuf
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MAKEMSGID -- Compute a message id for this process. ** **	This routine creates a message id for a message if **	it did not have one already.  If the MESSAGEID compile **	flag is set, the messageid will be added to any message **	that does not already have one.  Currently it is more **	of an artifact, but I suggest that if you are hacking, **	you leave it in -- I may want to use it someday if **	duplicate messages turn out to be a problem. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Stores a message-id into MsgId. ** **	Requires: **		sprintf (sys) **		getpid (sys) **		time (sys) ** **	Called By: **		maketemp ** **	History: **		2/3/80 -- written. */
end_comment

begin_macro
name|makemsgid
argument_list|()
end_macro

begin_block
block|{
specifier|auto
name|long
name|t
decl_stmt|;
specifier|extern
name|char
modifier|*
name|MyLocName
decl_stmt|;
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|MsgId
argument_list|,
literal|"%ld.%d.%s@Berkeley"
argument_list|,
name|t
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|MyLocName
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  OPENXSCRPT -- Open transcript file ** **	Creates a transcript file for possible eventual mailing or **	sending back. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		Turns the standard output into a special file **			somewhere. ** **	Requires: **		mktemp (sys) **		chmod (sys) **		freopen (sys) **		syserr **		setbuf (sys) ** **	Called By: **		main ** **	History: **		1/11/80 -- written. */
end_comment

begin_macro
name|openxscrpt
argument_list|()
end_macro

begin_block
block|{
name|mktemp
argument_list|(
name|Transcript
argument_list|)
expr_stmt|;
name|HasXscrpt
operator|++
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|Transcript
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Can't create %s"
argument_list|,
name|Transcript
argument_list|)
expr_stmt|;
name|chmod
argument_list|(
name|Transcript
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

