begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|envelope
operator|.
name|c
literal|3.16
operator|%
name|G
operator|%
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  NEWENVELOPE -- allocate a new envelope ** **	Supports inheritance. ** **	Parameters: **		e -- the new envelope to fill in. ** **	Returns: **		e. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ENVELOPE
modifier|*
name|newenvelope
parameter_list|(
name|e
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|HDR
modifier|*
name|bh
decl_stmt|;
specifier|register
name|HDR
modifier|*
modifier|*
name|nhp
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|parent
decl_stmt|;
extern|extern putheader(
block|)
operator|,
function|putbody
parameter_list|()
function|;
end_function

begin_decl_stmt
specifier|extern
name|ENVELOPE
name|BlankEnvelope
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|parent
operator|=
name|CurEnv
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|e
operator|==
name|CurEnv
condition|)
name|parent
operator|=
name|e
operator|->
name|e_parent
expr_stmt|;
end_if

begin_expr_stmt
name|clear
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|,
sizeof|sizeof
expr|*
name|e
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|e
operator|->
name|e_from
argument_list|,
sizeof|sizeof
name|e
operator|->
name|e_from
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e
operator|->
name|e_parent
operator|=
name|parent
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e
operator|->
name|e_ctime
operator|=
name|curtime
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e
operator|->
name|e_puthdr
operator|=
name|putheader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e
operator|->
name|e_putbody
operator|=
name|putbody
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bh
operator|=
name|BlankEnvelope
operator|.
name|e_header
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nhp
operator|=
operator|&
name|e
operator|->
name|e_header
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|bh
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nhp
operator|=
operator|(
name|HDR
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|bh
argument_list|)
expr_stmt|;
name|bmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bh
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|*
name|nhp
argument_list|,
sizeof|sizeof
expr|*
name|bh
argument_list|)
expr_stmt|;
name|bh
operator|=
name|bh
operator|->
name|h_link
expr_stmt|;
name|nhp
operator|=
operator|&
operator|(
operator|*
name|nhp
operator|)
operator|->
name|h_link
expr_stmt|;
block|}
end_while

begin_if
if|if
condition|(
name|CurEnv
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|CurEnv
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|e
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  DROPENVELOPE -- deallocate an envelope. ** **	Parameters: **		e -- the envelope to deallocate. ** **	Returns: **		none. ** **	Side Effects: **		housekeeping necessary to dispose of an envelope. **		Unlocks this queue file. */
end_comment

begin_expr_stmt
unit|dropenvelope
operator|(
name|e
operator|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bool
name|queueit
init|=
name|FALSE
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|50
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dropenvelope %x id="
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|xputs
argument_list|(
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" flags=%o\n"
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|10
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"dropenvelope, id=%s, flags=%o, pid=%d"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"(none)"
else|:
name|e
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_flags
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
comment|/* we must have an id to remove disk files */
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
return|return;
comment|/* 	**  Extract state information from dregs of send list. 	*/
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|queueit
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	**  Send back return receipts as requested. 	*/
if|if
condition|(
name|e
operator|->
name|e_receiptto
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|EF_SENDRECEIPT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
specifier|auto
name|ADDRESS
modifier|*
name|rlist
init|=
name|NULL
decl_stmt|;
name|sendtolist
argument_list|(
name|CurEnv
operator|->
name|e_receiptto
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|rlist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|returntosender
argument_list|(
literal|"Return receipt"
argument_list|,
name|rlist
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Arrange to send error messages if there are fatal errors. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_FATALERRS
operator||
name|EF_TIMEOUT
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|ErrorMode
operator|!=
name|EM_QUIET
condition|)
name|savemail
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* 	**  Instantiate or deinstantiate the queue. 	*/
if|if
condition|(
operator|(
operator|!
name|queueit
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_KEEPQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|)
operator|||
name|bitset
argument_list|(
name|EF_CLRQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_df
operator|!=
name|NULL
condition|)
name|xunlink
argument_list|(
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queueit
operator|||
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QUEUE
name|queueup
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|#
directive|else
else|QUEUE
name|syserr
argument_list|(
literal|"dropenvelope: queueup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
block|}
comment|/* now unlock the job */
name|closexscript
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|unlockqueue
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* make sure that this envelope is marked unused */
name|e
operator|->
name|e_id
operator|=
name|e
operator|->
name|e_df
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CLEARENVELOPE -- clear an envelope without unlocking ** **	This is normally used by a child process to get a clean **	envelope without disturbing the parent. ** **	Parameters: **		e -- the envelope to clear. ** **	Returns: **		none. ** **	Side Effects: **		Closes files associated with the envelope. **		Marks the envelope as unallocated. */
end_comment

begin_expr_stmt
name|clearenvelope
argument_list|(
name|e
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* clear out any file information */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
comment|/* now expunge names of objects */
name|e
operator|->
name|e_df
operator|=
name|e
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
comment|/* and the flags which are now meaningless */
name|e
operator|->
name|e_flags
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  UNLOCKQUEUE -- unlock the queue entry for a specified envelope ** **	Parameters: **		e -- the envelope to unlock. ** **	Returns: **		none ** **	Side Effects: **		unlocks the queue for `e'. */
end_comment

begin_macro
name|unlockqueue
argument_list|(
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* remove the transcript */
ifdef|#
directive|ifdef
name|DEBUG
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: unlock"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
if|if
condition|(
operator|!
name|tTd
argument_list|(
literal|51
argument_list|,
literal|4
argument_list|)
condition|)
endif|#
directive|endif
endif|DEBUG
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'x'
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUEUE
comment|/* last but not least, remove the lock */
name|xunlink
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'l'
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INITSYS -- initialize instantiation of system ** **	In Daemon mode, this is done in the child. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Initializes the system macros, some global variables, **		etc.  In particular, the current time in various **		forms is set. */
end_comment

begin_macro
name|initsys
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|cbuf
index|[
literal|5
index|]
decl_stmt|;
comment|/* holds hop count */
specifier|static
name|char
name|pbuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds pid */
specifier|static
name|char
name|ybuf
index|[
literal|10
index|]
decl_stmt|;
comment|/* holds tty id */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
specifier|extern
name|char
name|Version
index|[]
decl_stmt|;
comment|/* 	**  Give this envelope a reality. 	**	I.e., an id, a transcript, and a creation time. 	*/
name|openxscript
argument_list|(
name|CurEnv
argument_list|)
expr_stmt|;
name|CurEnv
operator|->
name|e_ctime
operator|=
name|curtime
argument_list|()
expr_stmt|;
comment|/* 	**  Set OutChannel to something useful if stdout isn't it. 	**	This arranges that any extra stuff the mailer produces 	**	gets sent back to the user on error (because it is 	**	tucked away in the transcript). 	*/
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|&&
name|QueueRun
condition|)
name|OutChannel
operator|=
name|CurEnv
operator|->
name|e_xfp
expr_stmt|;
comment|/* 	**  Set up some basic system macros. 	*/
comment|/* process id */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'p'
argument_list|,
name|pbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* hop count */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"%d"
argument_list|,
name|CurEnv
operator|->
name|e_hopcount
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'c'
argument_list|,
name|cbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* time as integer, unix time, arpa time */
name|settime
argument_list|()
expr_stmt|;
comment|/* tty name */
if|if
condition|(
name|macvalue
argument_list|(
literal|'y'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|ttyname
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|p
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ybuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'y'
argument_list|,
name|ybuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SETTIME -- set the current time. ** **	Parameters: **		none. ** **	Returns: **		none. ** **	Side Effects: **		Sets the various time macros -- $a, $b, $d, $t. */
end_comment

begin_macro
name|settime
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|auto
name|time_t
name|now
decl_stmt|;
specifier|static
name|char
name|tbuf
index|[
literal|20
index|]
decl_stmt|;
comment|/* holds "current" time */
specifier|static
name|char
name|dbuf
index|[
literal|30
index|]
decl_stmt|;
comment|/* holds ctime(tbuf) */
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
name|now
operator|=
name|curtime
argument_list|()
expr_stmt|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tbuf
argument_list|,
literal|"%02d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'t'
argument_list|,
name|tbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dbuf
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|index
argument_list|(
name|dbuf
argument_list|,
literal|'\n'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|macvalue
argument_list|(
literal|'d'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
name|define
argument_list|(
literal|'d'
argument_list|,
name|dbuf
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|arpadate
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|macvalue
argument_list|(
literal|'a'
argument_list|,
name|CurEnv
argument_list|)
operator|==
name|NULL
condition|)
name|define
argument_list|(
literal|'a'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'b'
argument_list|,
name|p
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  QUEUENAME -- build a file name in the queue directory for this envelope. ** **	Assigns an id code if one does not already exist. **	This code is very careful to avoid trashing existing files **	under any circumstances. **		We first create an nf file that is only used when **		assigning an id.  This file is always empty, so that **		we can never accidently truncate an lf file. ** **	Parameters: **		e -- envelope to build it in/from. **		type -- the file type, used as the first character **			of the file name. ** **	Returns: **		a pointer to the new file name (in a static buffer). ** **	Side Effects: **		Will create the lf and qf files if no id code is **		already assigned.  This will cause the envelope **		to be modified. */
end_comment

begin_function
name|char
modifier|*
name|queuename
parameter_list|(
name|e
parameter_list|,
name|type
parameter_list|)
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|char
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|static
name|int
name|pid
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|c1
init|=
literal|'A'
decl_stmt|;
name|char
name|c2
init|=
literal|'A'
decl_stmt|;
if|if
condition|(
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|)
block|{
name|char
name|qf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|lf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|nf
index|[
literal|20
index|]
decl_stmt|;
comment|/* find a unique id */
if|if
condition|(
name|pid
operator|!=
name|getpid
argument_list|()
condition|)
block|{
comment|/* new process -- start back at "AA" */
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|c1
operator|=
literal|'A'
expr_stmt|;
name|c2
operator|=
literal|'A'
operator|-
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|qf
argument_list|,
literal|"qfAA%05d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lf
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|lf
index|[
literal|0
index|]
operator|=
literal|'l'
expr_stmt|;
name|strcpy
argument_list|(
name|nf
argument_list|,
name|qf
argument_list|)
expr_stmt|;
name|nf
index|[
literal|0
index|]
operator|=
literal|'n'
expr_stmt|;
while|while
condition|(
name|c1
operator|<
literal|'~'
operator|||
name|c2
operator|<
literal|'Z'
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c2
operator|>=
literal|'Z'
condition|)
block|{
name|c1
operator|++
expr_stmt|;
name|c2
operator|=
literal|'A'
operator|-
literal|1
expr_stmt|;
block|}
name|qf
index|[
literal|2
index|]
operator|=
name|lf
index|[
literal|2
index|]
operator|=
name|nf
index|[
literal|2
index|]
operator|=
name|c1
expr_stmt|;
name|qf
index|[
literal|3
index|]
operator|=
name|lf
index|[
literal|3
index|]
operator|=
name|nf
index|[
literal|3
index|]
operator|=
operator|++
name|c2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|20
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: trying \"%s\"\n"
argument_list|,
name|nf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|access
argument_list|(
name|lf
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|||
name|access
argument_list|(
name|qf
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
continue|continue;
name|errno
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|creat
argument_list|(
name|nf
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|nf
argument_list|)
expr_stmt|;
comment|/* kernel bug */
continue|continue;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|link
argument_list|(
name|nf
argument_list|,
name|lf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|nf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|link
argument_list|(
name|lf
argument_list|,
name|qf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|lf
argument_list|)
expr_stmt|;
else|#
directive|else
else|QUEUE
if|if
condition|(
name|close
argument_list|(
name|creat
argument_list|(
name|qf
argument_list|,
name|FileMode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
endif|#
directive|endif
endif|QUEUE
block|}
if|if
condition|(
name|c1
operator|>=
literal|'~'
operator|&&
name|c2
operator|>=
literal|'Z'
condition|)
block|{
name|syserr
argument_list|(
literal|"queuename: Cannot create \"%s\" in \"%s\""
argument_list|,
name|lf
argument_list|,
name|QueueDir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_id
operator|=
name|newstr
argument_list|(
operator|&
name|qf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'i'
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: assigned id %s, env=%x\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|16
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: assigned id"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|type
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%cf%s"
argument_list|,
name|type
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|7
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"queuename: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  OPENXSCRIPT -- Open transcript file ** **	Creates a transcript file for possible eventual mailing or **	sending back. ** **	Parameters: **		e -- the envelope to create the transcript in/for. ** **	Returns: **		none ** **	Side Effects: **		Creates the transcript file. */
end_comment

begin_expr_stmt
name|openxscript
argument_list|(
name|e
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|19
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: openx%s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|?
literal|""
else|:
literal|" (no)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
return|return;
name|p
operator|=
name|queuename
argument_list|(
name|e
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|fopen
argument_list|(
name|p
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"Can't create %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|p
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CLOSEXSCRIPT -- close the transcript file. ** **	Parameters: **		e -- the envelope containing the transcript to close. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|closexscript
argument_list|(
name|e
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SETSENDER -- set the person who this message is from ** **	Under certain circumstances allow the user to say who **	s/he is (using -f or -r).  These are: **	1.  The user's uid is zero (root). **	2.  The user's login name is in an approved list (typically **	    from a network server). **	3.  The address the user is trying to claim has a **	    "!" character in it (since #2 doesn't do it for **	    us if we are dialing out for UUCP). **	A better check to replace #3 would be if the **	effective uid is "UUCP" -- this would require me **	to rewrite getpwent to "grab" uucp as it went by, **	make getname more nasty, do another passwd file **	scan, or compile the UID of "UUCP" into the code, **	all of which are reprehensible. ** **	Assuming all of these fail, we figure out something **	ourselves. ** **	Parameters: **		from -- the person we would like to believe this message **			is from, as specified on the command line. ** **	Returns: **		none. ** **	Side Effects: **		sets sendmail's notion of who the from person is. */
end_comment

begin_macro
name|setsender
argument_list|(
argument|from
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|realname
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|safefile
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|FullName
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|45
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"setsender(%s)\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Figure out the real user executing us. 	**	Username can return errno != 0 on non-errors. 	*/
if|if
condition|(
name|QueueRun
operator|||
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|OpMode
operator|==
name|MD_ARPAFTP
condition|)
name|realname
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|realname
operator|==
name|NULL
operator|||
name|realname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|extern
name|char
modifier|*
name|username
parameter_list|()
function_decl|;
name|realname
operator|=
name|username
argument_list|()
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|realname
operator|==
name|NULL
operator|||
name|realname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|getruid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
name|realname
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|realname
operator|==
name|NULL
operator|||
name|realname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"Who are you?"
argument_list|)
expr_stmt|;
name|realname
operator|=
literal|"root"
expr_stmt|;
block|}
comment|/* 	**  Determine if this real person is allowed to alias themselves. 	*/
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|bool
name|trusteduser
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|trusteduser
argument_list|(
name|realname
argument_list|)
operator|&&
ifdef|#
directive|ifdef
name|DEBUG
operator|(
operator|!
name|tTd
argument_list|(
literal|1
argument_list|,
literal|9
argument_list|)
operator|||
name|getuid
argument_list|()
operator|!=
name|geteuid
argument_list|()
operator|)
operator|&&
endif|#
directive|endif
endif|DEBUG
name|index
argument_list|(
name|from
argument_list|,
literal|'!'
argument_list|)
operator|==
name|NULL
operator|&&
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
comment|/* network sends -r regardless (why why why?) */
comment|/* syserr("%s, you cannot use the -f flag", realname); */
name|from
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|from
argument_list|,
name|realname
argument_list|)
operator|!=
literal|0
condition|)
name|pw
operator|=
name|NULL
expr_stmt|;
block|}
name|SuprErrs
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
operator|||
name|parseaddr
argument_list|(
name|from
argument_list|,
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
literal|1
argument_list|,
literal|'\0'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|from
operator|=
name|newstr
argument_list|(
name|realname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parseaddr
argument_list|(
name|from
argument_list|,
operator|&
name|CurEnv
operator|->
name|e_from
argument_list|,
literal|1
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
name|FromFlag
operator|=
name|TRUE
expr_stmt|;
name|CurEnv
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
name|SuprErrs
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|&&
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|==
name|LocalMailer
condition|)
block|{
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|CurEnv
operator|->
name|e_from
operator|.
name|q_user
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Process passwd file entry. 	*/
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
comment|/* extract home directory */
name|CurEnv
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
comment|/* extract user and group id */
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|CurEnv
operator|->
name|e_from
operator|.
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
comment|/* run user's .mailcf file */
name|define
argument_list|(
literal|'z'
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_home
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"$z/.mailcf"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|safefile
argument_list|(
name|buf
argument_list|,
name|getruid
argument_list|()
argument_list|,
name|S_IREAD
argument_list|)
condition|)
name|readcf
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* if the user has given fullname already, don't redefine */
if|if
condition|(
name|FullName
operator|==
name|NULL
condition|)
name|FullName
operator|=
name|macvalue
argument_list|(
literal|'x'
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
if|if
condition|(
name|FullName
operator|!=
name|NULL
operator|&&
name|FullName
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|FullName
operator|=
name|NULL
expr_stmt|;
comment|/* extract full name from passwd file */
if|if
condition|(
name|FullName
operator|==
name|NULL
operator|&&
name|pw
operator|->
name|pw_gecos
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_user
argument_list|)
operator|==
literal|0
condition|)
block|{
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_user
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|FullName
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FullName
operator|!=
name|NULL
condition|)
name|define
argument_list|(
literal|'x'
argument_list|,
name|FullName
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|V6
if|if
condition|(
name|CurEnv
operator|->
name|e_from
operator|.
name|q_home
operator|==
name|NULL
condition|)
name|CurEnv
operator|->
name|e_from
operator|.
name|q_home
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|V6
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|CurEnv
operator|->
name|e_from
operator|.
name|q_gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
operator|!=
literal|0
condition|)
block|{
name|DefUid
operator|=
name|CurEnv
operator|->
name|e_from
operator|.
name|q_uid
expr_stmt|;
name|DefGid
operator|=
name|CurEnv
operator|->
name|e_from
operator|.
name|q_gid
expr_stmt|;
block|}
comment|/* 	**  Rewrite the from person to dispose of possible implicit 	**	links in the net. 	*/
name|pvp
operator|=
name|prescan
argument_list|(
name|from
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"cannot prescan from (%s)"
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|finis
argument_list|()
expr_stmt|;
block|}
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'f'
argument_list|,
name|newstr
argument_list|(
name|buf
argument_list|)
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* save the domain spec if this mailer wants it */
if|if
condition|(
name|bitnset
argument_list|(
name|M_CANONICAL
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|copyplist
parameter_list|()
function_decl|;
while|while
condition|(
operator|*
name|pvp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|*
name|pvp
argument_list|,
literal|"@"
argument_list|)
operator|!=
literal|0
condition|)
name|pvp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pvp
operator|!=
name|NULL
condition|)
name|CurEnv
operator|->
name|e_fromdomain
operator|=
name|copyplist
argument_list|(
name|pvp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  TRUSTEDUSER -- tell us if this user is to be trusted. ** **	Parameters: **		user -- the user to be checked. ** **	Returns: **		TRUE if the user is in an approved list. **		FALSE otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|trusteduser
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ulist
decl_stmt|;
specifier|extern
name|char
modifier|*
name|TrustedUsers
index|[]
decl_stmt|;
for|for
control|(
name|ulist
operator|=
name|TrustedUsers
init|;
operator|*
name|ulist
operator|!=
name|NULL
condition|;
name|ulist
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|ulist
argument_list|,
name|user
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

end_unit

