begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988 Regents of the University of California.  * All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)recipient.c	6.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_comment
comment|/* **  SENDTOLIST -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	The `ctladdr' is the address that expanded to be this one, **	e.g., in an alias expansion.  This is used for a number of **	purposed, most notably inheritance of uid/gid for protection **	purposes.  It is also used to detect self-reference in group **	expansions and the like. ** **	Parameters: **		list -- the send list. **		ctladdr -- the address template for the person to **			send to -- effective uid/gid are important. **			This is typically the alias that caused this **			expansion. **		sendq -- a pointer to the head of a queue to put **			these people into. **		qflags -- special flags to set in the q_flags field. ** **	Returns: **		pointer to chain of addresses. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|MAXRCRSN
value|10
end_define

begin_function
name|ADDRESS
modifier|*
name|sendto
parameter_list|(
name|list
parameter_list|,
name|copyf
parameter_list|,
name|ctladdr
parameter_list|,
name|qflags
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|u_short
name|qflags
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|al
decl_stmt|;
comment|/* list of addresses to send to */
name|bool
name|firstone
decl_stmt|;
comment|/* set on first address sent */
name|bool
name|selfref
decl_stmt|;
comment|/* set if this list includes ctladdr */
name|char
name|delimiter
decl_stmt|;
comment|/* the address delimiter */
name|ADDRESS
modifier|*
name|sibl
decl_stmt|;
comment|/* sibling pointer in tree */
name|ADDRESS
modifier|*
name|prev
decl_stmt|;
comment|/* previous sibling */
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendto: %s\n   ctladdr="
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* heuristic to determine old versus new style addresses */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|list
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
name|delimiter
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|ctladdr
operator|!=
name|NULL
condition|)
name|delimiter
operator|=
literal|','
expr_stmt|;
name|firstone
operator|=
name|TRUE
expr_stmt|;
name|selfref
operator|=
name|FALSE
expr_stmt|;
name|al
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
comment|/* defined in prescan */
comment|/* parse the address */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|delimiter
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|DelimChar
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|a
operator|->
name|q_next
operator|=
name|al
expr_stmt|;
name|a
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_flags
operator||=
name|ctladdr
operator|->
name|q_flags
operator|&
operator|~
name|QPRIMARY
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|qflags
expr_stmt|;
comment|/* see if this should be marked as a primary address */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|||
operator|(
name|firstone
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|sameaddr
argument_list|(
name|ctladdr
argument_list|,
name|a
argument_list|)
condition|)
name|selfref
operator|=
name|TRUE
expr_stmt|;
name|al
operator|=
name|a
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* if this alias doesn't include itself, delete ctladdr */
if|if
condition|(
operator|!
name|selfref
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendtolist: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ctladdr
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
block|}
comment|/* arrange to send to everyone on the local send list */
name|prev
operator|=
name|sibl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|prev
operator|=
name|ctladdr
operator|->
name|q_child
expr_stmt|;
while|while
condition|(
name|al
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
init|=
name|al
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
name|al
operator|=
name|a
operator|->
name|q_next
expr_stmt|;
name|sibl
operator|=
name|recipient
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|sibl
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|ADDRESS
modifier|*
name|addrref
parameter_list|()
function_decl|;
comment|/* inherit full name */
if|if
condition|(
name|sibl
operator|->
name|q_fullname
operator|==
name|NULL
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|sibl
operator|->
name|q_fullname
operator|=
name|ctladdr
operator|->
name|q_fullname
expr_stmt|;
comment|/* link tree together (but only if the node is new) */
if|if
condition|(
name|sibl
operator|==
name|a
condition|)
block|{
name|sibl
operator|->
name|q_sibling
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|sibl
expr_stmt|;
block|}
block|}
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|ctladdr
operator|->
name|q_child
operator|=
name|prev
expr_stmt|;
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ADDRREF -- return pointer to address that references another address. ** **	Parameters: **		a -- address to check. **		r -- reference to find. ** **	Returns: **		address of node in tree rooted at 'a' that references **			'r'. **		NULL if no such node exists. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|addrref
parameter_list|(
name|a
parameter_list|,
name|r
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_child
operator|==
name|r
operator|||
name|a
operator|->
name|q_sibling
operator|==
name|r
condition|)
return|return
operator|(
name|a
operator|)
return|;
name|q
operator|=
name|addrref
argument_list|(
name|a
operator|->
name|q_child
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
return|return
operator|(
name|q
operator|)
return|;
name|a
operator|=
name|a
operator|->
name|q_sibling
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient ** **	Saves the named person for future mailing. ** **	Parameters: **		a -- the (preparsed) address header for the recipient. **		sendq -- a pointer to the head of a queue to put the **			recipient in.  Duplicate supression is done **			in this queue. **		e -- the current envelope. ** **	Returns: **		pointer to address actually inserted in send list. ** **	Side Effects: **		none. */
end_comment

begin_function_decl
specifier|extern
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RcptLogFile
decl_stmt|;
end_decl_stmt

begin_function
name|ADDRESS
modifier|*
name|ADDRESS
modifier|*
name|recipient
parameter_list|(
name|a
parameter_list|,
name|sendq
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|quoted
init|=
name|FALSE
decl_stmt|;
comment|/* set if the addr has a quote bit */
name|int
name|findusercount
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* unquoted image of the user name */
specifier|extern
name|bool
name|safefile
parameter_list|()
function_decl|;
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nrecipient: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* break aliasing loops */
if|if
condition|(
name|AliasLevel
operator|>
name|MAXRCRSN
condition|)
block|{
name|usrerr
argument_list|(
literal|"aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Finish setting up address structure. 	*/
comment|/* set the queue timeout */
name|a
operator|->
name|q_timeout
operator|=
name|TimeOut
expr_stmt|;
comment|/* map user& host to lower case if requested on non-aliases */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
name|loweraddr
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* get unquoted user for file, program or user.name check */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|quoted
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|quoted
operator|=
name|TRUE
expr_stmt|;
block|}
name|stripquotes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* check for direct mailing to restricted mailers */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
name|m
operator|==
name|ProgMailer
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
operator||
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"Cannot mail directly to programs"
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Look up this person in the recipient list. 	**	If they are there already, return, otherwise continue. 	**	If the list is empty, just add it.  Notice the cute 	**	hack to make from addresses suppress things correctly: 	**	the QDONTSEND bit will be set in the send list. 	**	[Please note: the emphasis is on "hack."] 	*/
for|for
control|(
name|pq
operator|=
name|sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|ForceMail
operator|&&
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s in sendq: "
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Verbose
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QPSEUDO
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"duplicate suppressed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPSEUDO
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|->
name|q_flags
operator|&=
operator|~
name|QPSEUDO
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
comment|/* add address on list */
operator|*
name|pq
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
name|RcptLogFile
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
specifier|static
name|int
name|RcptLogFd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 		**  Log the incoming recipient name before aliasing, 		**  expanding, forwarding, rewriting, and all that jazz. 		**  We'll use this to track down out-of-date aliases, 		**  host names, and so forth. 		*/
if|if
condition|(
name|RcptLogFd
operator|<
literal|0
condition|)
block|{
comment|/* try to open the log file */
name|RcptLogFd
operator|=
name|open
argument_list|(
name|RcptLogFile
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|RcptLogFd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|RcptLogFd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RcptLogFd
operator|>=
literal|0
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|a
operator|->
name|q_paddr
argument_list|)
decl_stmt|;
name|a
operator|->
name|q_paddr
index|[
name|l
index|]
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|RcptLogFd
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|,
name|l
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|RcptLogFd
argument_list|)
expr_stmt|;
name|RcptLogFd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|a
operator|->
name|q_paddr
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* 	**  Alias the name and handle special mailer types. 	*/
name|trylocaluser
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"at trylocaluser %s\n"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
return|return
operator|(
name|a
operator|)
return|;
if|if
condition|(
name|m
operator|==
name|InclMailer
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"Cannot mail directly to :include:s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"including file %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|include
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|FALSE
argument_list|,
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|FileMailer
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
specifier|extern
name|bool
name|writable
parameter_list|()
function_decl|;
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* check if writable or creatable */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
operator|!
name|QueueRun
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
operator||
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"Cannot mail directly to files"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|stb
argument_list|)
operator|>=
literal|0
operator|)
condition|?
operator|(
operator|!
name|writable
argument_list|(
operator|&
name|stb
argument_list|)
operator|)
else|:
operator|(
operator|*
name|p
operator|=
literal|'\0'
operator|,
operator|!
name|safefile
argument_list|(
name|buf
argument_list|,
name|getruid
argument_list|()
argument_list|,
name|S_IWRITE
operator||
name|S_IEXEC
argument_list|)
operator|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_CANTCREAT
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|LocalMailer
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
comment|/* try aliasing */
name|alias
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERDB
comment|/* if not aliased, look it up in the user database */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QNOTREMOTE
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|udbexpand
parameter_list|()
function_decl|;
if|if
condition|(
name|udbexpand
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_message
operator|=
name|newstr
argument_list|(
literal|"Deferred: user database error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: deferred: udbexpand"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"queued (user database error)"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* if it was an alias or a UDB expansion, just return now */
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
return|return
operator|(
name|a
operator|)
return|;
comment|/* 	**  If we have a level two config file, then pass the name through 	**  Ruleset 5 before sending it off.  Ruleset 5 has the right 	**  to send rewrite it to another mailer.  This gives us a hook 	**  after local aliasing has been done. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"recipient: testing local?  cl=%d, rr5=%x\n\t"
argument_list|,
name|ConfigLevel
argument_list|,
name|RewriteRules
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QNOTREMOTE
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|ConfigLevel
operator|>=
literal|2
operator|&&
name|RewriteRules
index|[
literal|5
index|]
operator|!=
name|NULL
condition|)
block|{
name|maplocaluser
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If it didn't get rewritten to another mailer, go ahead 	**  and deliver it. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
specifier|auto
name|bool
name|fuzzy
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|()
function_decl|;
comment|/* warning -- finduser may trash buf */
name|pw
operator|=
name|finduser
argument_list|(
name|buf
argument_list|,
operator|&
name|fuzzy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|fuzzy
condition|)
block|{
comment|/* name was a fuzzy match */
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|findusercount
operator|++
operator|>
literal|3
condition|)
block|{
name|usrerr
argument_list|(
literal|"aliasing/forwarding loop for %s broken"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
comment|/* see if it aliases */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
goto|goto
name|trylocaluser
goto|;
block|}
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quoted
condition|)
name|forward
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINDUSER -- find the password entry for a user. ** **	This looks a lot like getpwnam, except that it may want to **	do some fancier pattern matching in /etc/passwd. ** **	This routine contains most of the time of many sendmail runs. **	It deserves to be optimized. ** **	Parameters: **		name -- the name to match against. **		fuzzyp -- an outarg that is set to TRUE if this entry **			was found using the fuzzy matching algorithm; **			set to FALSE otherwise. ** **	Returns: **		A pointer to a pw struct. **		NULL if name is unknown or ambiguous. ** **	Side Effects: **		may modify name. */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|(
name|name
parameter_list|,
name|fuzzyp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|bool
modifier|*
name|fuzzyp
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"finduser(%s): "
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* map upper => lower case */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|fuzzyp
operator|=
name|FALSE
expr_stmt|;
comment|/* look up this login name using fast path */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"found (non-fuzzy)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MATCHGECOS
comment|/* see if fuzzy matching allowed */
if|if
condition|(
operator|!
name|MatchGecos
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* search for a matching full name instead */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|SpaceSub
operator|&
literal|0177
operator|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|fullname
argument_list|(
name|pw
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"fuzzy matches %s\n"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"sending to %s<%s>"
argument_list|,
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"no fuzzy match found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WRITABLE -- predicate returning if the file is writable. ** **	This routine must duplicate the algorithm in sys/fio.c. **	Unfortunately, we cannot use the access call since we **	won't necessarily be the real uid when we try to **	actually open the file. ** **	Notice that ANY file with ANY execute bit is automatically **	not writable.  This is also enforced by mailfile. ** **	Parameters: **		s -- pointer to a stat struct for the file. ** **	Returns: **		TRUE -- if we will be able to write this file. **		FALSE -- if we cannot write this file. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|writable
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
block|{
name|uid_t
name|euid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|0111
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|euid
operator|=
name|getruid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getrgid
argument_list|()
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
name|euid
operator|=
name|s
operator|->
name|st_uid
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
name|egid
operator|=
name|s
operator|->
name|st_gid
expr_stmt|;
block|}
if|if
condition|(
name|euid
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|bits
operator|=
name|S_IWRITE
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
name|s
operator|->
name|st_uid
condition|)
block|{
name|bits
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
name|s
operator|->
name|st_gid
condition|)
name|bits
operator|>>=
literal|3
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|s
operator|->
name|st_mode
operator|&
name|bits
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INCLUDE -- handle :include: specification. ** **	Parameters: **		fname -- filename to include. **		forwarding -- if TRUE, we are reading a .forward file. **			if FALSE, it's a :include: file. **		ctladdr -- address template to use to fill in these **			addresses -- effective user/group id are **			the important things. **		sendq -- a pointer to the head of the send queue **			to put these addresses in. ** **	Returns: **		open error status ** **	Side Effects: **		reads the :include: file and sends to everyone **		listed in that file. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|CtxIncludeTimeout
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|include
parameter_list|(
name|fname
parameter_list|,
name|forwarding
parameter_list|,
name|ctladdr
parameter_list|,
name|sendq
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|bool
name|forwarding
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|oldfilename
init|=
name|FileName
decl_stmt|;
name|int
name|oldlinenumber
init|=
name|LineNumber
decl_stmt|;
specifier|register
name|EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|static
name|int
name|includetimeout
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* 	**  If home directory is remote mounted but server is down, 	**  this can hang or give errors; use a timeout to avoid this 	*/
if|if
condition|(
name|setjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctladdr
operator|->
name|q_flags
operator||=
name|QQUEUEUP
operator||
name|QDONTSEND
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 open timeout on %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|ETIMEDOUT
return|;
block|}
name|ev
operator|=
name|setevent
argument_list|(
operator|(
name|time_t
operator|)
literal|60
argument_list|,
name|includetimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if forwarding, the input file must be marked safe */
if|if
condition|(
name|forwarding
operator|&&
operator|!
name|safefile
argument_list|(
name|fname
argument_list|,
name|ctladdr
operator|->
name|q_uid
argument_list|,
name|S_IREAD
argument_list|)
condition|)
block|{
comment|/* don't use this .forward file */
name|clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: not safe (uid=%d)\n"
argument_list|,
name|ctladdr
operator|->
name|q_uid
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|int
name|ret
init|=
name|errno
decl_stmt|;
name|usrerr
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|getctladdr
argument_list|(
name|ctladdr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"Cannot fstat %s!"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ctladdr
operator|->
name|q_uid
operator|=
name|st
operator|.
name|st_uid
expr_stmt|;
name|ctladdr
operator|->
name|q_gid
operator|=
name|st
operator|.
name|st_gid
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
name|clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
comment|/* read the file -- each line is a comma-separated list. */
name|FileName
operator|=
name|fname
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|LineNumber
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"%s to %s"
argument_list|,
name|forwarding
condition|?
literal|"forwarding"
else|:
literal|"sending"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|forwarding
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: forward %s => %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|oldto
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AliasLevel
operator|++
expr_stmt|;
name|sendto
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|ctladdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AliasLevel
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|oldfilename
expr_stmt|;
name|LineNumber
operator|=
name|oldlinenumber
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|includetimeout
argument_list|()
block|{
name|longjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|,
literal|1
argument_list|)
block|; }
comment|/* **  SENDTOARGV -- send to an argument vector. ** **	Parameters: **		argv -- argument vector to send to. ** **	Returns: **		none. ** **	Side Effects: **		puts all addresses on the argument vector onto the **			send queue. */
name|sendtoargv
argument_list|(
name|argv
argument_list|,
name|e
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"at"
argument_list|)
condition|)
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|2
operator|>
sizeof|sizeof
name|nbuf
condition|)
name|usrerr
argument_list|(
literal|"address overflow"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nbuf
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nbuf
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|sendto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETCTLADDR -- get controlling address from an address header. ** **	If none, get one corresponding to the effective userid. ** **	Parameters: **		a -- the address to find the controller of. ** **	Returns: **		the controlling address. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

end_unit

