begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)recipient.c	3.10	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  SENDTO -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	Parameters: **		list -- the send list. **		copyf -- the copy flag; passed to parse. ** **	Returns: **		none ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|MAXRCRSN
value|10
end_define

begin_macro
name|sendto
argument_list|(
argument|list
argument_list|,
argument|copyf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|copyf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|more
decl_stmt|;
comment|/* set if more addresses to send to */
name|more
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|more
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
comment|/* find the end of this address */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
name|more
operator|=
name|c
operator|!=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|p
operator|++
expr_stmt|;
comment|/* parse the address */
if|if
condition|(
operator|(
name|a
operator|=
name|parse
argument_list|(
name|q
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
name|copyf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* arrange to send to this person */
name|recipient
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
name|To
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient ** **	Saves the named person for future mailing. ** **	Parameters: **		a -- the (preparsed) address header for the recipient. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|recipient
argument_list|(
name|a
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|To
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|Mailer
index|[
name|a
operator|->
name|q_mailer
index|]
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"recipient(%s)\n"
argument_list|,
name|To
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* break aliasing loops */
if|if
condition|(
name|AliasLevel
operator|>
name|MAXRCRSN
condition|)
block|{
name|usrerr
argument_list|(
literal|"aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  Do sickly crude mapping for program mailing, etc. 	*/
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|==
name|MN_LOCAL
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_user
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|a
operator|->
name|q_mailer
operator|=
name|MN_PROG
expr_stmt|;
name|m
operator|=
name|Mailer
index|[
name|MN_PROG
index|]
expr_stmt|;
name|a
operator|->
name|q_user
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|AliasLevel
operator|<=
literal|0
condition|)
block|{
name|usrerr
argument_list|(
literal|"Cannot mail directly to programs"
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
block|}
endif|#
directive|endif
endif|PARANOID
block|}
block|}
comment|/* 	**  Look up this person in the recipient list.  If they 	**  are there already, return, otherwise continue. 	**  If the list is empty, just add it. 	*/
for|for
control|(
name|pq
operator|=
operator|&
name|m
operator|->
name|m_sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|ForceMail
operator|&&
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"(%s in sendq)\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|Verbose
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"duplicate supressed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* add address on list */
operator|*
name|pq
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|DontSend
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
comment|/* 	**  Alias the name and handle :include: specs. 	*/
if|if
condition|(
name|a
operator|->
name|q_mailer
operator|==
name|MN_LOCAL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|":include:"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"including file %s"
argument_list|,
operator|&
name|a
operator|->
name|q_user
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|include
argument_list|(
operator|&
name|a
operator|->
name|q_user
index|[
literal|9
index|]
argument_list|,
literal|" sending"
argument_list|)
expr_stmt|;
block|}
else|else
name|alias
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If the user is local and still being sent, verify that 	**  the address is good.  If it is, try to forward. 	**  If the address is already good, we have a forwarding 	**  loop.  This can be broken by just sending directly to 	**  the user (which is probably correct anyway). 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|a
operator|->
name|q_mailer
operator|==
name|MN_LOCAL
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* see if this is to a file */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* check if writable or creatable */
if|if
condition|(
operator|(
name|access
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|)
condition|?
operator|(
name|access
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
operator|)
else|:
operator|(
operator|*
name|p
operator|=
literal|'\0'
operator|,
name|access
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_CANTCREAT
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
operator|==
literal|0
condition|)
name|forward
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  INCLUDE -- handle :include: specification. ** **	Parameters: **		fname -- filename to include. **		msg -- message to print in verbose mode. ** **	Returns: **		none. ** **	Side Effects: **		reads the :include: file and sends to everyone **		listed in that file. */
end_comment

begin_macro
name|include
argument_list|(
argument|fname
argument_list|,
argument|msg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|To
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* read the file -- each line is a comma-separated list. */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|To
operator|=
name|oldto
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"%s to %s"
argument_list|,
name|msg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|AliasLevel
operator|++
expr_stmt|;
name|sendto
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AliasLevel
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

