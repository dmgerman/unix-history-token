begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)recipient.c	8.64 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_comment
comment|/* **  SENDTOLIST -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	The `ctladdr' is the address that expanded to be this one, **	e.g., in an alias expansion.  This is used for a number of **	purposed, most notably inheritance of uid/gid for protection **	purposes.  It is also used to detect self-reference in group **	expansions and the like. ** **	Parameters: **		list -- the send list. **		ctladdr -- the address template for the person to **			send to -- effective uid/gid are important. **			This is typically the alias that caused this **			expansion. **		sendq -- a pointer to the head of a queue to put **			these people into. **		aliaslevel -- the current alias nesting depth -- to **			diagnose loops. **		e -- the envelope in which to add these recipients. **		qflags -- special flags to set in the q_flags field. ** **	Returns: **		pointer to chain of addresses. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|MAXRCRSN
value|10
end_define

begin_comment
comment|/* maximum levels of alias recursion */
end_comment

begin_comment
comment|/* q_flags bits inherited from ctladdr */
end_comment

begin_define
define|#
directive|define
name|QINHERITEDBITS
value|(QPINGONSUCCESS|QPINGONFAILURE|QPINGONDELAY|QHAS_RET_PARAM|QRET_HDRS)
end_define

begin_function
name|int
name|ADDRESS
modifier|*
name|sendto
parameter_list|(
name|list
parameter_list|,
name|copyf
parameter_list|,
name|ctladdr
parameter_list|,
name|qflags
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
name|u_short
name|qflags
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|al
decl_stmt|;
comment|/* list of addresses to send to */
name|bool
name|firstone
decl_stmt|;
comment|/* set on first address sent */
name|char
name|delimiter
decl_stmt|;
comment|/* the address delimiter */
name|int
name|naddrs
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
specifier|static
name|char
modifier|*
name|bufp
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|buflen
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
name|ADDRESS
modifier|*
name|sibl
decl_stmt|;
comment|/* sibling pointer in tree */
name|ADDRESS
modifier|*
name|prev
decl_stmt|;
comment|/* previous sibling */
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"sendtolist: null list"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendto: %s\n   ctladdr="
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* heuristic to determine old versus new style addresses */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
operator|(
name|strchr
argument_list|(
name|list
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|strchr
argument_list|(
name|list
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
name|delimiter
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|||
name|ctladdr
operator|!=
name|NULL
condition|)
name|delimiter
operator|=
literal|','
expr_stmt|;
name|firstone
operator|=
name|TRUE
expr_stmt|;
name|al
operator|=
name|NULL
expr_stmt|;
name|naddrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufp
operator|==
name|NULL
condition|)
block|{
name|bufp
operator|=
name|buf
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
name|buf
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|list
argument_list|)
operator|>
name|buflen
condition|)
block|{
comment|/* allocate additional space */
if|if
condition|(
name|bufp
operator|!=
name|buf
condition|)
name|free
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|strlen
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|malloc
argument_list|(
name|buflen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|bufp
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bufp
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
specifier|auto
name|char
modifier|*
name|delimptr
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
comment|/* parse the address */
while|while
condition|(
operator|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
name|NULLADDR
argument_list|,
name|RF_COPYALL
argument_list|,
name|delimiter
argument_list|,
operator|&
name|delimptr
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|delimptr
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|a
operator|->
name|q_next
operator|=
name|al
expr_stmt|;
name|a
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_flags
operator||=
name|ctladdr
operator|->
name|q_flags
operator|&
operator|~
name|QPRIMARY
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|qflags
expr_stmt|;
comment|/* see if this should be marked as a primary address */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|||
operator|(
name|firstone
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
name|sibl
operator|=
name|recipient
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|sibl
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|ADDRESS
modifier|*
name|addrref
parameter_list|()
function_decl|;
comment|/* inherit full name */
if|if
condition|(
name|sibl
operator|->
name|q_fullname
operator|==
name|NULL
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|sibl
operator|->
name|q_fullname
operator|=
name|ctladdr
operator|->
name|q_fullname
expr_stmt|;
comment|/* link tree together (but only if the node is new) */
if|if
condition|(
name|sibl
operator|==
name|a
condition|)
block|{
name|sibl
operator|->
name|q_sibling
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|sibl
expr_stmt|;
block|}
block|}
block|}
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
return|return
operator|(
name|naddrs
operator|)
return|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|ctladdr
operator|->
name|q_child
operator|=
name|prev
expr_stmt|;
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ADDRREF -- return pointer to address that references another address. ** **	Parameters: **		a -- address to check. **		r -- reference to find. ** **	Returns: **		address of node in tree rooted at 'a' that references **			'r'. **		NULL if no such node exists. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|addrref
parameter_list|(
name|a
parameter_list|,
name|r
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_child
operator|==
name|r
operator|||
name|a
operator|->
name|q_sibling
operator|==
name|r
condition|)
return|return
operator|(
name|a
operator|)
return|;
name|q
operator|=
name|addrref
argument_list|(
name|a
operator|->
name|q_child
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
return|return
operator|(
name|q
operator|)
return|;
name|a
operator|=
name|a
operator|->
name|q_sibling
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient ** **	Saves the named person for future mailing. ** **	Parameters: **		a -- the (preparsed) address header for the recipient. **		sendq -- a pointer to the head of a queue to put the **			recipient in.  Duplicate supression is done **			in this queue. **		aliaslevel -- the current alias nesting depth. **		e -- the current envelope. ** **	Returns: **		pointer to address actually inserted in send list. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|ADDRESS
modifier|*
name|recipient
parameter_list|(
name|a
parameter_list|,
name|sendq
parameter_list|,
name|aliaslevel
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|quoted
init|=
name|FALSE
decl_stmt|;
comment|/* set if the addr has a quote bit */
name|int
name|findusercount
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|buf0
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* unquoted image of the user name */
specifier|extern
name|int
name|safefile
parameter_list|()
function_decl|;
name|e
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nrecipient: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* if this is primary, add it to the original recipient list */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_origrcpt
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
elseif|else
if|if
condition|(
name|e
operator|->
name|e_origrcpt
operator|!=
name|a
operator|->
name|q_paddr
condition|)
name|e
operator|->
name|e_origrcpt
operator|=
literal|""
expr_stmt|;
block|}
comment|/* break aliasing loops */
if|if
condition|(
name|aliaslevel
operator|>
name|MAXRCRSN
condition|)
block|{
name|usrerr
argument_list|(
literal|"554 aliasing/forwarding loop broken (%d aliases deep; %d max"
argument_list|,
name|aliaslevel
argument_list|,
name|MAXRCRSN
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Finish setting up address structure. 	*/
comment|/* get unquoted user for file, program or user.name check */
name|i
operator|=
name|strlen
argument_list|(
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
sizeof|sizeof
name|buf
condition|)
name|buf
operator|=
name|xalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|buf0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|quoted
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|quoted
operator|=
name|TRUE
expr_stmt|;
block|}
name|stripquotes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* check for direct mailing to restricted mailers */
if|if
condition|(
name|m
operator|==
name|ProgMailer
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot mail directly to programs"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBOGUSSHELL
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 User %s@%s doesn't have a valid shell for mailing to programs"
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_ruser
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QUNSAFEADDR
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Address %s is unsafe for mailing to programs"
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Look up this person in the recipient list. 	**	If they are there already, return, otherwise continue. 	**	If the list is empty, just add it.  Notice the cute 	**	hack to make from addresses suppress things correctly: 	**	the QDONTSEND bit will be set in the send list. 	**	[Please note: the emphasis is on "hack."] 	*/
for|for
control|(
name|pq
operator|=
name|sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|)
condition|)
block|{
comment|/* if this is a reinsertion, just go ahead */
if|if
condition|(
name|bitset
argument_list|(
name|QVERIFIED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s in sendq: "
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|message
argument_list|(
literal|"duplicate suppressed"
argument_list|)
expr_stmt|;
name|q
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QSELFREF
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
operator|&
operator|~
name|QDONTSEND
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPSEUDO
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|->
name|q_flags
operator|&=
operator|~
name|QPSEUDO
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
comment|/* add address on list */
if|if
condition|(
operator|*
name|pq
operator|!=
name|a
condition|)
block|{
operator|*
name|pq
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
block|}
name|a
operator|->
name|q_flags
operator|&=
operator|~
name|QVERIFIED
expr_stmt|;
comment|/* 	**  Alias the name and handle special mailer types. 	*/
name|trylocaluser
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|7
argument_list|)
condition|)
name|printf
argument_list|(
literal|"at trylocaluser %s\n"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
goto|goto
name|testselfdestruct
goto|;
if|if
condition|(
name|m
operator|==
name|InclMailer
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot mail directly to :include:s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ret
decl_stmt|;
name|message
argument_list|(
literal|"including file %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
name|ret
operator|=
name|include
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|FALSE
argument_list|,
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|transienterror
argument_list|(
name|ret
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: include %s: transient error: %s"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|e
operator|->
name|e_id
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
name|a
operator|->
name|q_flags
operator|&=
operator|~
name|QDONTSEND
expr_stmt|;
name|usrerr
argument_list|(
literal|"451 Cannot open %s: %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot open %s: %s"
argument_list|,
name|a
operator|->
name|q_user
argument_list|,
name|errstring
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|FileMailer
condition|)
block|{
specifier|extern
name|bool
name|writable
parameter_list|()
function_decl|;
comment|/* check if writable or creatable */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Cannot mail directly to files"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QBOGUSSHELL
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 User %s@%s doesn't have a valid shell for mailing to files"
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_ruser
argument_list|,
name|MyHostName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|QUNSAFEADDR
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"550 Address %s is unsafe for mailing to files"
argument_list|,
name|a
operator|->
name|q_alias
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|writable
argument_list|(
name|buf
argument_list|,
name|getctladdr
argument_list|(
name|a
argument_list|)
argument_list|,
name|SFF_ANYFILE
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_CANTCREAT
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try aliasing */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_ALIASABLE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|alias
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USERDB
comment|/* if not aliased, look it up in the user database */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QNOTREMOTE
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_CHECKUDB
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|udbexpand
parameter_list|()
function_decl|;
if|if
condition|(
name|udbexpand
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
operator|==
name|EX_TEMPFAIL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_message
operator|==
name|NULL
condition|)
name|e
operator|->
name|e_message
operator|=
name|newstr
argument_list|(
literal|"Deferred: user database error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: deferred: udbexpand: %s"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|e
operator|->
name|e_id
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|message
argument_list|(
literal|"queued (user database error): %s"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
goto|goto
name|testselfdestruct
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* 	**  If we have a level two config file, then pass the name through 	**  Ruleset 5 before sending it off.  Ruleset 5 has the right 	**  to send rewrite it to another mailer.  This gives us a hook 	**  after local aliasing has been done. 	*/
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"recipient: testing local?  cl=%d, rr5=%x\n\t"
argument_list|,
name|ConfigLevel
argument_list|,
name|RewriteRules
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QNOTREMOTE
operator||
name|QDONTSEND
operator||
name|QQUEUEUP
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|ConfigLevel
operator|>=
literal|2
operator|&&
name|RewriteRules
index|[
literal|5
index|]
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|M_TRYRULESET5
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|maplocaluser
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If it didn't get rewritten to another mailer, go ahead 	**  and deliver it. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QQUEUEUP
operator||
name|QVERIFIED
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_HASPWENT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|auto
name|bool
name|fuzzy
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|()
function_decl|;
comment|/* warning -- finduser may trash buf */
name|pw
operator|=
name|finduser
argument_list|(
name|buf
argument_list|,
operator|&
name|fuzzy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|a
operator|->
name|q_alias
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|fuzzy
condition|)
block|{
comment|/* name was a fuzzy match */
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|findusercount
operator|++
operator|>
literal|3
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"554 aliasing/forwarding loop for %s broken"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* see if it aliases */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
goto|goto
name|trylocaluser
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|a
operator|->
name|q_home
operator|=
literal|""
expr_stmt|;
else|else
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_ruser
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|pw_shell
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|pw_shell
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|usershellok
argument_list|(
name|pw
operator|->
name|pw_shell
argument_list|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBOGUSSHELL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quoted
condition|)
name|forward
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
name|testselfdestruct
label|:
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"testselfdestruct: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
name|a
operator|!=
operator|&
name|e
operator|->
name|e_from
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|q
operator|=
operator|*
name|sendq
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|=
name|q
operator|->
name|q_next
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"554 aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|buf
operator|!=
name|buf0
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINDUSER -- find the password entry for a user. ** **	This looks a lot like getpwnam, except that it may want to **	do some fancier pattern matching in /etc/passwd. ** **	This routine contains most of the time of many sendmail runs. **	It deserves to be optimized. ** **	Parameters: **		name -- the name to match against. **		fuzzyp -- an outarg that is set to TRUE if this entry **			was found using the fuzzy matching algorithm; **			set to FALSE otherwise. ** **	Returns: **		A pointer to a pw struct. **		NULL if name is unknown or ambiguous. ** **	Side Effects: **		may modify name. */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|(
name|name
parameter_list|,
name|fuzzyp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|bool
modifier|*
name|fuzzyp
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"finduser(%s): "
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|fuzzyp
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|HESIOD
comment|/* DEC Hesiod getpwnam accepts numeric strings -- short circuit it */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"failed (numeric input)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* look up this login name using fast path */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"found (non-fuzzy)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MATCHGECOS
comment|/* see if fuzzy matching allowed */
if|if
condition|(
operator|!
name|MatchGecos
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* search for a matching full name instead */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|SpaceSub
operator|&
literal|0177
operator|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|fullname
argument_list|(
name|pw
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"fuzzy matches %s\n"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"sending to %s<%s>"
argument_list|,
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"no fuzzy match found\n"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"not found (fuzzy disabled)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WRITABLE -- predicate returning if the file is writable. ** **	This routine must duplicate the algorithm in sys/fio.c. **	Unfortunately, we cannot use the access call since we **	won't necessarily be the real uid when we try to **	actually open the file. ** **	Notice that ANY file with ANY execute bit is automatically **	not writable.  This is also enforced by mailfile. ** **	Parameters: **		filename -- the file name to check. **		ctladdr -- the controlling address for this file. **		flags -- SFF_* flags to control the function. ** **	Returns: **		TRUE -- if we will be able to write this file. **		FALSE -- if we cannot write this file. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|writable
parameter_list|(
name|filename
parameter_list|,
name|ctladdr
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|uid_t
name|euid
decl_stmt|;
name|gid_t
name|egid
decl_stmt|;
name|int
name|bits
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|uname
decl_stmt|;
name|struct
name|stat
name|stb
decl_stmt|;
specifier|extern
name|char
name|RealUserName
index|[]
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"writable(%s, %x)\n"
argument_list|,
name|filename
argument_list|,
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HASLSTAT
if|if
condition|(
operator|(
name|bitset
argument_list|(
name|SFF_NOSLINK
argument_list|,
name|flags
argument_list|)
condition|?
name|lstat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
else|:
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* file does not exist -- see if directory is safe */
name|p
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOTDIR
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|errno
operator|=
name|safefile
argument_list|(
name|filename
argument_list|,
name|RealUid
argument_list|,
name|RealGid
argument_list|,
name|RealUserName
argument_list|,
name|SFF_MUSTOWN
argument_list|,
name|S_IWRITE
operator||
name|S_IEXEC
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
return|return
name|errno
operator|==
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|SUID_ROOT_FILES_OK
comment|/* really ought to be passed down -- and not a good idea */
name|flags
operator||=
name|SFF_ROOTOK
expr_stmt|;
endif|#
directive|endif
comment|/* 	**  File does exist -- check that it is writable. 	*/
if|if
condition|(
name|bitset
argument_list|(
literal|0111
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"failed (mode %o: x bits)\n"
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
name|euid
operator|=
name|ctladdr
operator|->
name|q_uid
expr_stmt|;
name|egid
operator|=
name|ctladdr
operator|->
name|q_gid
expr_stmt|;
name|uname
operator|=
name|ctladdr
operator|->
name|q_user
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RUN_AS_REAL_UID
else|else
block|{
name|euid
operator|=
name|RealUid
expr_stmt|;
name|egid
operator|=
name|RealGid
expr_stmt|;
name|uname
operator|=
name|RealUserName
expr_stmt|;
block|}
else|#
directive|else
elseif|else
if|if
condition|(
name|FileMailer
operator|!=
name|NULL
condition|)
block|{
name|euid
operator|=
name|FileMailer
operator|->
name|m_uid
expr_stmt|;
name|egid
operator|=
name|FileMailer
operator|->
name|m_gid
expr_stmt|;
block|}
else|else
block|{
name|euid
operator|=
name|egid
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|euid
operator|==
literal|0
condition|)
block|{
name|euid
operator|=
name|DefUid
expr_stmt|;
name|uname
operator|=
name|DefUser
expr_stmt|;
block|}
if|if
condition|(
name|egid
operator|==
literal|0
condition|)
name|egid
operator|=
name|DefGid
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|stb
operator|.
name|st_uid
operator|!=
literal|0
operator|||
name|bitset
argument_list|(
name|SFF_ROOTOK
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|euid
operator|=
name|stb
operator|.
name|st_uid
expr_stmt|;
name|uname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|stb
operator|.
name|st_gid
operator|!=
literal|0
operator|||
name|bitset
argument_list|(
name|SFF_ROOTOK
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
name|egid
operator|=
name|stb
operator|.
name|st_gid
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|29
argument_list|,
literal|5
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\teu/gid=%d/%d, st_u/gid=%d/%d\n"
argument_list|,
name|euid
argument_list|,
name|egid
argument_list|,
name|stb
operator|.
name|st_uid
argument_list|,
name|stb
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|errno
operator|=
name|safefile
argument_list|(
name|filename
argument_list|,
name|euid
argument_list|,
name|egid
argument_list|,
name|uname
argument_list|,
name|flags
argument_list|,
name|S_IWRITE
argument_list|)
expr_stmt|;
return|return
name|errno
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INCLUDE -- handle :include: specification. ** **	Parameters: **		fname -- filename to include. **		forwarding -- if TRUE, we are reading a .forward file. **			if FALSE, it's a :include: file. **		ctladdr -- address template to use to fill in these **			addresses -- effective user/group id are **			the important things. **		sendq -- a pointer to the head of the send queue **			to put these addresses in. **		aliaslevel -- the alias nesting depth. **		e -- the current envelope. ** **	Returns: **		open error status ** **	Side Effects: **		reads the :include: file and sends to everyone **		listed in that file. ** **	Security Note: **		If you have restricted chown (that is, you can't **		give a file away), it is reasonable to allow programs **		and files called from this :include: file to be to be **		run as the owner of the :include: file.  This is bogus **		if there is any chance of someone giving away a file. **		We assume that pre-POSIX systems can give away files. ** **		There is an additional restriction that if you **		forward to a :include: file, it will not take on **		the ownership of the :include: file.  This may not **		be necessary, but shouldn't hurt. */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|CtxIncludeTimeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|includetimeout
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|S_IWOTH
end_ifndef

begin_define
define|#
directive|define
name|S_IWOTH
value|(S_IWRITE>> 6)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|include
parameter_list|(
name|fname
parameter_list|,
name|forwarding
parameter_list|,
name|ctladdr
parameter_list|,
name|sendq
parameter_list|,
name|aliaslevel
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|bool
name|forwarding
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|int
name|aliaslevel
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|e
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|oldfilename
init|=
name|FileName
decl_stmt|;
name|int
name|oldlinenumber
init|=
name|LineNumber
decl_stmt|;
specifier|register
name|EVENT
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|int
name|nincludes
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|ca
decl_stmt|;
name|uid_t
name|saveduid
decl_stmt|,
name|uid
decl_stmt|;
name|gid_t
name|savedgid
decl_stmt|,
name|gid
decl_stmt|;
name|char
modifier|*
name|uname
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|int
name|sfflags
init|=
name|forwarding
condition|?
name|SFF_MUSTOWN
else|:
name|SFF_ANYFILE
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_CHOWN_RESTRICTED
if|#
directive|if
name|_POSIX_CHOWN_RESTRICTED
operator|==
operator|-
literal|1
define|#
directive|define
name|safechown
value|FALSE
else|#
directive|else
define|#
directive|define
name|safechown
value|TRUE
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|_PC_CHOWN_RESTRICTED
name|bool
name|safechown
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD
define|#
directive|define
name|safechown
value|TRUE
else|#
directive|else
define|#
directive|define
name|safechown
value|FALSE
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
specifier|extern
name|bool
name|chownsafe
parameter_list|()
function_decl|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|2
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include(%s)\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"   ruid=%d euid=%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|14
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ctladdr "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: old uid = %d/%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|ca
operator|=
name|getctladdr
argument_list|(
name|ctladdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|==
name|NULL
condition|)
block|{
name|uid
operator|=
name|DefUid
expr_stmt|;
name|gid
operator|=
name|DefGid
expr_stmt|;
name|uname
operator|=
name|DefUser
expr_stmt|;
block|}
else|else
block|{
name|uid
operator|=
name|ca
operator|->
name|q_uid
expr_stmt|;
name|gid
operator|=
name|ca
operator|->
name|q_gid
expr_stmt|;
name|uname
operator|=
name|ca
operator|->
name|q_user
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HASSETREUID
name|saveduid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|savedgid
operator|=
name|getegid
argument_list|()
expr_stmt|;
if|if
condition|(
name|saveduid
operator|==
literal|0
condition|)
block|{
name|initgroups
argument_list|(
name|uname
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|setreuid
argument_list|(
literal|0
argument_list|,
name|uid
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"setreuid(0, %d) failure (real=%d, eff=%d)"
argument_list|,
name|uid
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|sfflags
operator||=
name|SFF_NOPATHCHECK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: new uid = %d/%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	**  If home directory is remote mounted but server is down, 	**  this can hang or give errors; use a timeout to avoid this 	*/
if|if
condition|(
name|setjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ctladdr
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* return pseudo-error code */
name|rval
operator|=
name|EOPENTIMEOUT
expr_stmt|;
goto|goto
name|resetuid
goto|;
block|}
if|if
condition|(
name|TimeOuts
operator|.
name|to_fileopen
operator|>
literal|0
condition|)
name|ev
operator|=
name|setevent
argument_list|(
name|TimeOuts
operator|.
name|to_fileopen
argument_list|,
name|includetimeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ev
operator|=
name|NULL
expr_stmt|;
comment|/* the input file must be marked safe */
name|rval
operator|=
name|safefile
argument_list|(
name|fname
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|uname
argument_list|,
name|sfflags
argument_list|,
name|S_IREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
block|{
comment|/* don't use this :include: file */
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: not safe (uid=%d): %s\n"
argument_list|,
name|uid
argument_list|,
name|errstring
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|4
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: open: %s\n"
argument_list|,
name|errstring
argument_list|(
name|rval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ev
operator|!=
name|NULL
condition|)
name|clrevent
argument_list|(
name|ev
argument_list|)
expr_stmt|;
name|resetuid
label|:
ifdef|#
directive|ifdef
name|HASSETREUID
if|if
condition|(
name|saveduid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"setreuid(-1, 0) failure (real=%d, eff=%d)"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setreuid
argument_list|(
name|RealUid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"setreuid(%d, 0) failure (real=%d, eff=%d)"
argument_list|,
name|RealUid
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setgid
argument_list|(
name|savedgid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|9
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: reset uid = %d/%d\n"
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|EOPENTIMEOUT
condition|)
name|usrerr
argument_list|(
literal|"451 open timeout on %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
name|rval
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rval
operator|=
name|errno
expr_stmt|;
name|syserr
argument_list|(
literal|"Cannot fstat %s!"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
ifndef|#
directive|ifndef
name|safechown
name|safechown
operator|=
name|chownsafe
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ca
operator|==
name|NULL
operator|&&
name|safechown
condition|)
block|{
name|ctladdr
operator|->
name|q_uid
operator|=
name|st
operator|.
name|st_uid
expr_stmt|;
name|ctladdr
operator|->
name|q_gid
operator|=
name|st
operator|.
name|st_gid
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
if|if
condition|(
name|ca
operator|!=
name|NULL
operator|&&
name|ca
operator|->
name|q_uid
operator|==
name|st
operator|.
name|st_uid
condition|)
block|{
comment|/* optimization -- avoid getpwuid if we already have info */
name|ctladdr
operator|->
name|q_flags
operator||=
name|ca
operator|->
name|q_flags
operator|&
name|QBOGUSSHELL
expr_stmt|;
name|ctladdr
operator|->
name|q_ruser
operator|=
name|ca
operator|->
name|q_ruser
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|st
operator|.
name|st_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QBOGUSSHELL
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|sh
decl_stmt|;
name|ctladdr
operator|->
name|q_ruser
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|safechown
condition|)
name|sh
operator|=
name|pw
operator|->
name|pw_shell
expr_stmt|;
else|else
name|sh
operator|=
literal|"/SENDMAIL/ANY/SHELL/"
expr_stmt|;
if|if
condition|(
operator|!
name|usershellok
argument_list|(
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
name|safechown
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QBOGUSSHELL
expr_stmt|;
else|else
name|ctladdr
operator|->
name|q_flags
operator||=
name|QUNSAFEADDR
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bitset
argument_list|(
name|EF_VRFYONLY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* don't do any more now */
name|ctladdr
operator|->
name|q_flags
operator||=
name|QVERIFIED
expr_stmt|;
name|e
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
name|xfclose
argument_list|(
name|fp
argument_list|,
literal|"include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
comment|/* 	** Check to see if some bad guy can write this file 	** 	**	This should really do something clever with group 	**	permissions; currently we just view world writable 	**	as unsafe.  Also, we don't check for writable 	**	directories in the path.  We've got to leave 	**	something for the local sysad to do. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|S_IWOTH
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QUNSAFEADDR
expr_stmt|;
comment|/* read the file -- each line is a comma-separated list. */
name|FileName
operator|=
name|fname
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator|&=
operator|~
name|QSELFREF
expr_stmt|;
name|nincludes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
name|LineNumber
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
name|message
argument_list|(
literal|"%s to %s"
argument_list|,
name|forwarding
condition|?
literal|"forwarding"
else|:
literal|"sending"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|forwarding
operator|&&
name|LogLevel
operator|>
literal|9
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: forward %s => %s"
argument_list|,
name|e
operator|->
name|e_id
operator|==
name|NULL
condition|?
literal|"NOQUEUE"
else|:
name|e
operator|->
name|e_id
argument_list|,
name|oldto
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nincludes
operator|+=
name|sendtolist
argument_list|(
name|buf
argument_list|,
name|ctladdr
argument_list|,
name|sendq
argument_list|,
name|aliaslevel
operator|+
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|tTd
argument_list|(
literal|27
argument_list|,
literal|3
argument_list|)
condition|)
name|printf
argument_list|(
literal|"include: read error: %s\n"
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nincludes
operator|>
literal|0
operator|&&
operator|!
name|bitset
argument_list|(
name|QSELFREF
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|27
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"include: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ctladdr
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|fp
argument_list|,
literal|"include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|oldfilename
expr_stmt|;
name|LineNumber
operator|=
name|oldlinenumber
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|includetimeout
argument_list|()
block|{
name|longjmp
argument_list|(
name|CtxIncludeTimeout
argument_list|,
literal|1
argument_list|)
block|; }
comment|/* **  SENDTOARGV -- send to an argument vector. ** **	Parameters: **		argv -- argument vector to send to. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		puts all addresses on the argument vector onto the **			send queue. */
name|sendtoargv
argument_list|(
name|argv
argument_list|,
name|e
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sendto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETCTLADDR -- get controlling address from an address header. ** **	If none, get one corresponding to the effective userid. ** **	Parameters: **		a -- the address to find the controller of. ** **	Returns: **		the controlling address. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

end_unit

