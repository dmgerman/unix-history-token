begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* **  Sendmail **  Copyright (c) 1983  Eric P. Allman **  Berkeley, California ** **  Copyright (c) 1983 Regents of the University of California. **  All rights reserved.  The Berkeley software License Agreement **  specifies the terms and conditions for redistribution. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)recipient.c	5.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* **  SENDTOLIST -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	The `ctladdr' is the address that expanded to be this one, **	e.g., in an alias expansion.  This is used for a number of **	purposed, most notably inheritance of uid/gid for protection **	purposes.  It is also used to detect self-reference in group **	expansions and the like. ** **	Parameters: **		list -- the send list. **		ctladdr -- the address template for the person to **			send to -- effective uid/gid are important. **			This is typically the alias that caused this **			expansion. **		sendq -- a pointer to the head of a queue to put **			these people into. **		qflags -- special flags to set in the q_flags field. ** **	Returns: **		pointer to chain of addresses. ** **	Side Effects: **		none. */
end_comment

begin_define
define|#
directive|define
name|MAXRCRSN
value|10
end_define

begin_function
name|ADDRESS
modifier|*
name|sendto
parameter_list|(
name|list
parameter_list|,
name|copyf
parameter_list|,
name|ctladdr
parameter_list|,
name|qflags
parameter_list|)
name|char
modifier|*
name|list
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
name|u_short
name|qflags
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|al
decl_stmt|;
comment|/* list of addresses to send to */
name|bool
name|firstone
decl_stmt|;
comment|/* set on first address sent */
name|bool
name|selfref
decl_stmt|;
comment|/* set if this list includes ctladdr */
name|char
name|delimiter
decl_stmt|;
comment|/* the address delimiter */
name|ADDRESS
modifier|*
name|sibl
decl_stmt|;
comment|/* sibling pointer in tree */
name|ADDRESS
modifier|*
name|prev
decl_stmt|;
comment|/* previous sibling */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|25
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendto: %s\n   ctladdr="
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* heuristic to determine old versus new style addresses */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
operator|(
name|index
argument_list|(
name|list
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|list
argument_list|,
literal|';'
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|list
argument_list|,
literal|'<'
argument_list|)
operator|!=
name|NULL
operator|||
name|index
argument_list|(
name|list
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|CurEnv
operator|->
name|e_flags
operator|&=
operator|~
name|EF_OLDSTYLE
expr_stmt|;
name|delimiter
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_OLDSTYLE
argument_list|,
name|CurEnv
operator|->
name|e_flags
argument_list|)
operator|||
name|ctladdr
operator|!=
name|NULL
condition|)
name|delimiter
operator|=
literal|','
expr_stmt|;
name|firstone
operator|=
name|TRUE
expr_stmt|;
name|selfref
operator|=
name|FALSE
expr_stmt|;
name|al
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|extern
name|char
modifier|*
name|DelimChar
decl_stmt|;
comment|/* defined in prescan */
comment|/* parse the address */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|p
operator|++
expr_stmt|;
name|a
operator|=
name|parseaddr
argument_list|(
name|p
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
name|delimiter
argument_list|)
expr_stmt|;
name|p
operator|=
name|DelimChar
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
continue|continue;
name|a
operator|->
name|q_next
operator|=
name|al
expr_stmt|;
name|a
operator|->
name|q_alias
operator|=
name|ctladdr
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|a
operator|->
name|q_flags
operator||=
name|ctladdr
operator|->
name|q_flags
operator|&
operator|~
name|QPRIMARY
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|qflags
expr_stmt|;
comment|/* see if this should be marked as a primary address */
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|||
operator|(
name|firstone
operator|&&
operator|*
name|p
operator|==
literal|'\0'
operator|&&
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|ctladdr
operator|->
name|q_flags
argument_list|)
operator|)
condition|)
name|a
operator|->
name|q_flags
operator||=
name|QPRIMARY
expr_stmt|;
comment|/* put on send queue or suppress self-reference */
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
operator|&&
name|sameaddr
argument_list|(
name|ctladdr
argument_list|,
name|a
argument_list|)
condition|)
name|selfref
operator|=
name|TRUE
expr_stmt|;
else|else
name|al
operator|=
name|a
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* if this alias doesn't include itself, delete ctladdr */
if|if
condition|(
operator|!
name|selfref
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|ctladdr
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
comment|/* arrange to send to everyone on the local send list */
name|prev
operator|=
name|sibl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|prev
operator|=
name|ctladdr
operator|->
name|q_child
expr_stmt|;
while|while
condition|(
name|al
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|a
init|=
name|al
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
name|al
operator|=
name|a
operator|->
name|q_next
expr_stmt|;
name|sibl
operator|=
name|recipient
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|sibl
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|ADDRESS
modifier|*
name|addrref
parameter_list|()
function_decl|;
comment|/* inherit full name */
if|if
condition|(
name|sibl
operator|->
name|q_fullname
operator|==
name|NULL
operator|&&
name|ctladdr
operator|!=
name|NULL
condition|)
name|sibl
operator|->
name|q_fullname
operator|=
name|ctladdr
operator|->
name|q_fullname
expr_stmt|;
comment|/* link tree together (but only if the node is new) */
if|if
condition|(
name|sibl
operator|==
name|a
condition|)
block|{
name|sibl
operator|->
name|q_sibling
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|sibl
expr_stmt|;
block|}
block|}
block|}
name|CurEnv
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|!=
name|NULL
condition|)
name|ctladdr
operator|->
name|q_child
operator|=
name|prev
expr_stmt|;
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  ADDRREF -- return pointer to address that references another address. ** **	Parameters: **		a -- address to check. **		r -- reference to find. ** **	Returns: **		address of node in tree rooted at 'a' that references **			'r'. **		NULL if no such node exists. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|addrref
parameter_list|(
name|a
parameter_list|,
name|r
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|q_child
operator|==
name|r
operator|||
name|a
operator|->
name|q_sibling
operator|==
name|r
condition|)
return|return
operator|(
name|a
operator|)
return|;
name|q
operator|=
name|addrref
argument_list|(
name|a
operator|->
name|q_child
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
return|return
operator|(
name|q
operator|)
return|;
name|a
operator|=
name|a
operator|->
name|q_sibling
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient ** **	Saves the named person for future mailing. ** **	Parameters: **		a -- the (preparsed) address header for the recipient. **		sendq -- a pointer to the head of a queue to put the **			recipient in.  Duplicate supression is done **			in this queue. ** **	Returns: **		pointer to address actually inserted in send list. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|ADDRESS
modifier|*
name|recipient
parameter_list|(
name|a
parameter_list|,
name|sendq
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|ADDRESS
modifier|*
modifier|*
name|pq
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bool
name|quoted
init|=
name|FALSE
decl_stmt|;
comment|/* set if the addr has a quote bit */
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* unquoted image of the user name */
specifier|extern
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|safefile
parameter_list|()
function_decl|;
name|CurEnv
operator|->
name|e_to
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|a
operator|->
name|q_mailer
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nrecipient: "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|a
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* break aliasing loops */
if|if
condition|(
name|AliasLevel
operator|>
name|MAXRCRSN
condition|)
block|{
name|usrerr
argument_list|(
literal|"aliasing/forwarding loop broken"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	**  Finish setting up address structure. 	*/
comment|/* set the queue timeout */
name|a
operator|->
name|q_timeout
operator|=
name|TimeOut
expr_stmt|;
comment|/* map user& host to lower case if requested on non-aliases */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
condition|)
name|loweraddr
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* get unquoted user for file, program or user.name check */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|q_user
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|!
name|quoted
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
operator|*
name|p
operator|&
literal|0377
operator|)
operator|!=
operator|(
name|SpaceSub
operator|&
literal|0377
operator|)
condition|)
name|quoted
operator|=
name|TRUE
expr_stmt|;
block|}
name|stripquotes
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* do sickly crude mapping for program mailing, etc. */
if|if
condition|(
name|m
operator|==
name|LocalMailer
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'|'
condition|)
block|{
name|a
operator|->
name|q_mailer
operator|=
name|m
operator|=
name|ProgMailer
expr_stmt|;
name|a
operator|->
name|q_user
operator|++
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
operator|!
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|QueueRun
operator|&&
operator|!
name|ForceMail
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
operator||
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"Cannot mail directly to programs"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Look up this person in the recipient list. 	**	If they are there already, return, otherwise continue. 	**	If the list is empty, just add it.  Notice the cute 	**	hack to make from addresses suppress things correctly: 	**	the QDONTSEND bit will be set in the send list. 	**	[Please note: the emphasis is on "hack."] 	*/
for|for
control|(
name|pq
operator|=
name|sendq
init|;
operator|(
name|q
operator|=
operator|*
name|pq
operator|)
operator|!=
name|NULL
condition|;
name|pq
operator|=
operator|&
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
operator|!
name|ForceMail
operator|&&
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tTd
argument_list|(
literal|26
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s in sendq: "
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|Verbose
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QPSEUDO
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"duplicate suppressed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPRIMARY
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|->
name|q_flags
operator||=
name|a
operator|->
name|q_flags
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QPSEUDO
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|q
operator|->
name|q_flags
operator|&=
operator|~
name|QPSEUDO
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
block|}
comment|/* add address on list */
operator|*
name|pq
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
name|CurEnv
operator|->
name|e_nrcpts
operator|++
expr_stmt|;
comment|/* 	**  Alias the name and handle :include: specs. 	*/
if|if
condition|(
name|m
operator|==
name|LocalMailer
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
literal|":include:"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
operator|!
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|QueueRun
operator|&&
operator|!
name|ForceMail
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"Cannot mail directly to :include:s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"including file %s"
argument_list|,
operator|&
name|a
operator|->
name|q_user
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|include
argument_list|(
operator|&
name|a
operator|->
name|q_user
index|[
literal|9
index|]
argument_list|,
literal|" sending"
argument_list|,
name|a
argument_list|,
name|sendq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|alias
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  If the user is local and still being sent, verify that 	**  the address is good.  If it is, try to forward. 	**  If the address is already good, we have a forwarding 	**  loop.  This can be broken by just sending directly to 	**  the user (which is probably correct anyway). 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
operator|&&
name|m
operator|==
name|LocalMailer
condition|)
block|{
name|struct
name|stat
name|stb
decl_stmt|;
specifier|extern
name|bool
name|writable
parameter_list|()
function_decl|;
comment|/* see if this is to a file */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|=
name|rindex
argument_list|(
name|buf
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* check if writable or creatable */
if|if
condition|(
name|a
operator|->
name|q_alias
operator|==
name|NULL
operator|&&
operator|!
name|tTd
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|QueueRun
operator|&&
operator|!
name|ForceMail
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QDONTSEND
operator||
name|QBADADDR
expr_stmt|;
name|usrerr
argument_list|(
literal|"Cannot mail directly to files"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|stb
argument_list|)
operator|>=
literal|0
operator|)
condition|?
operator|(
operator|!
name|writable
argument_list|(
operator|&
name|stb
argument_list|)
operator|)
else|:
operator|(
operator|*
name|p
operator|=
literal|'\0'
operator|,
operator|!
name|safefile
argument_list|(
name|buf
argument_list|,
name|getruid
argument_list|()
argument_list|,
name|S_IWRITE
operator||
name|S_IEXEC
argument_list|)
operator|)
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_CANTCREAT
argument_list|,
name|m
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|()
function_decl|;
comment|/* warning -- finduser may trash buf */
name|pw
operator|=
name|finduser
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|m
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|q_user
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|q_user
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
name|a
operator|->
name|q_home
operator|=
name|newstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|a
operator|->
name|q_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|a
operator|->
name|q_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
name|a
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
name|buildfname
argument_list|(
name|pw
operator|->
name|pw_gecos
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|fullname
argument_list|(
name|pw
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|a
operator|->
name|q_fullname
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quoted
condition|)
name|forward
argument_list|(
name|a
argument_list|,
name|sendq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|a
operator|)
return|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  FINDUSER -- find the password entry for a user. ** **	This looks a lot like getpwnam, except that it may want to **	do some fancier pattern matching in /etc/passwd. ** **	This routine contains most of the time of many sendmail runs. **	It deserves to be optimized. ** **	Parameters: **		name -- the name to match against. ** **	Returns: **		A pointer to a pw struct. **		NULL if name is unknown or ambiguous. ** **	Side Effects: **		may modify name. */
end_comment

begin_function
name|struct
name|passwd
modifier|*
name|finduser
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
comment|/* map upper => lower case */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* look up this login name using fast path */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pw
operator|)
return|;
comment|/* search for a matching full name instead */
for|for
control|(
name|p
operator|=
name|name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
operator|(
name|SpaceSub
operator|&
literal|0177
operator|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|fullname
argument_list|(
name|pw
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|)
operator|!=
name|NULL
operator|&&
name|sameword
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"sending to %s<%s>"
argument_list|,
name|buf
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|pw
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  WRITABLE -- predicate returning if the file is writable. ** **	This routine must duplicate the algorithm in sys/fio.c. **	Unfortunately, we cannot use the access call since we **	won't necessarily be the real uid when we try to **	actually open the file. ** **	Notice that ANY file with ANY execute bit is automatically **	not writable.  This is also enforced by mailfile. ** **	Parameters: **		s -- pointer to a stat struct for the file. ** **	Returns: **		TRUE -- if we will be able to write this file. **		FALSE -- if we cannot write this file. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|writable
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|stat
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|euid
decl_stmt|,
name|egid
decl_stmt|;
name|int
name|bits
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|0111
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|euid
operator|=
name|getruid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getrgid
argument_list|()
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
name|euid
operator|=
name|s
operator|->
name|st_uid
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|s
operator|->
name|st_mode
argument_list|)
condition|)
name|egid
operator|=
name|s
operator|->
name|st_gid
expr_stmt|;
block|}
if|if
condition|(
name|euid
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|bits
operator|=
name|S_IWRITE
expr_stmt|;
if|if
condition|(
name|euid
operator|!=
name|s
operator|->
name|st_uid
condition|)
block|{
name|bits
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|egid
operator|!=
name|s
operator|->
name|st_gid
condition|)
name|bits
operator|>>=
literal|3
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|s
operator|->
name|st_mode
operator|&
name|bits
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  INCLUDE -- handle :include: specification. ** **	Parameters: **		fname -- filename to include. **		msg -- message to print in verbose mode. **		ctladdr -- address template to use to fill in these **			addresses -- effective user/group id are **			the important things. **		sendq -- a pointer to the head of the send queue **			to put these addresses in. ** **	Returns: **		none. ** **	Side Effects: **		reads the :include: file and sends to everyone **		listed in that file. */
end_comment

begin_macro
name|include
argument_list|(
argument|fname
argument_list|,
argument|msg
argument_list|,
argument|ctladdr
argument_list|,
argument|sendq
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
modifier|*
name|sendq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|oldto
init|=
name|CurEnv
operator|->
name|e_to
decl_stmt|;
name|char
modifier|*
name|oldfilename
init|=
name|FileName
decl_stmt|;
name|int
name|oldlinenumber
init|=
name|LineNumber
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"Cannot open %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getctladdr
argument_list|(
name|ctladdr
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|syserr
argument_list|(
literal|"Cannot fstat %s!"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ctladdr
operator|->
name|q_uid
operator|=
name|st
operator|.
name|st_uid
expr_stmt|;
name|ctladdr
operator|->
name|q_gid
operator|=
name|st
operator|.
name|st_gid
expr_stmt|;
name|ctladdr
operator|->
name|q_flags
operator||=
name|QGOODUID
expr_stmt|;
block|}
comment|/* read the file -- each line is a comma-separated list. */
name|FileName
operator|=
name|fname
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|index
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|CurEnv
operator|->
name|e_to
operator|=
name|oldto
expr_stmt|;
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"%s to %s"
argument_list|,
name|msg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|AliasLevel
operator|++
expr_stmt|;
name|sendto
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|ctladdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AliasLevel
operator|--
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|FileName
operator|=
name|oldfilename
expr_stmt|;
name|LineNumber
operator|=
name|oldlinenumber
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SENDTOARGV -- send to an argument vector. ** **	Parameters: **		argv -- argument vector to send to. ** **	Returns: **		none. ** **	Side Effects: **		puts all addresses on the argument vector onto the **			send queue. */
end_comment

begin_expr_stmt
name|sendtoargv
argument_list|(
name|argv
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|argv
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|bool
name|sameword
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|argv
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|argv
index|[
literal|1
index|]
operator|!=
name|NULL
operator|&&
name|sameword
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"at"
argument_list|)
condition|)
block|{
name|char
name|nbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|2
operator|>
sizeof|sizeof
name|nbuf
condition|)
name|usrerr
argument_list|(
literal|"address overflow"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nbuf
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nbuf
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|newstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|sendto
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GETCTLADDR -- get controlling address from an address header. ** **	If none, get one corresponding to the effective userid. ** **	Parameters: **		a -- the address to find the controller of. ** **	Returns: **		the controlling address. ** **	Side Effects: **		none. */
end_comment

begin_function
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|(
name|a
parameter_list|)
specifier|register
name|ADDRESS
modifier|*
name|a
decl_stmt|;
block|{
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QGOODUID
argument_list|,
name|a
operator|->
name|q_flags
argument_list|)
condition|)
name|a
operator|=
name|a
operator|->
name|q_alias
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

end_unit

