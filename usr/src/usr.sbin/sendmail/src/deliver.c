begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_expr_stmt
name|SCCSID
argument_list|(
argument|@
operator|(
operator|#
operator|)
name|deliver
operator|.
name|c
literal|3.82
operator|%
name|G
operator|%
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* **  DELIVER -- Deliver a message to a list of addresses. ** **	This routine delivers to everyone on the same host as the **	user on the head of the list.  It is clever about mailers **	that don't handle multiple users.  It is NOT guaranteed **	that it will deliver to all these addresses however -- so **	deliver should be called once for each address on the **	list. ** **	Parameters: **		firstto -- head of the address list to deliver to. ** **	Returns: **		zero -- successfully delivered. **		else -- some failure, see ExitStat for more info. ** **	Side Effects: **		The standard input is passed off to someone. */
end_comment

begin_macro
name|deliver
argument_list|(
argument|firstto
argument_list|)
end_macro

begin_decl_stmt
name|ADDRESS
modifier|*
name|firstto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|host
decl_stmt|;
comment|/* host being sent to */
name|char
modifier|*
name|user
decl_stmt|;
comment|/* user being sent to */
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|mvp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
comment|/* mailer for this recipient */
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|bool
name|checkcompat
parameter_list|()
function_decl|;
name|char
modifier|*
name|pv
index|[
name|MAXPV
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|tobuf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* text line of to people */
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|getctladdr
parameter_list|()
function_decl|;
name|char
name|tfrombuf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* translated from person */
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|register
name|ADDRESS
modifier|*
name|to
init|=
name|firstto
decl_stmt|;
name|bool
name|clever
init|=
name|FALSE
decl_stmt|;
comment|/* running user smtp to this mailer */
name|bool
name|tempfail
init|=
name|FALSE
decl_stmt|;
name|ADDRESS
modifier|*
name|tochain
init|=
name|NULL
decl_stmt|;
comment|/* chain of users in this mailer call */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ForceMail
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QPSEUDO
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|=
name|to
operator|->
name|q_mailer
expr_stmt|;
name|host
operator|=
name|to
operator|->
name|q_host
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"\n--deliver, mailer=%d, host=`%s', first user=`%s'\n"
argument_list|,
name|m
operator|->
name|m_mno
argument_list|,
name|host
argument_list|,
name|to
operator|->
name|q_user
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"Connecting to %s.%s..."
argument_list|,
name|host
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
comment|/* 	**  If this mailer is expensive, and if we don't want to make 	**  connections now, just mark these addresses and return. 	**	This is useful if we want to batch connections to 	**	reduce load.  This will cause the messages to be 	**	queued up, and a daemon will come along to send the 	**	messages later. 	**		This should be on a per-mailer basis. 	*/
if|if
condition|(
name|NoConnect
operator|&&
operator|!
name|QueueRun
operator|&&
name|bitset
argument_list|(
name|M_EXPENSIVE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
for|for
control|(
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_next
control|)
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
name|to
operator|->
name|q_flags
operator||=
name|QQUEUEUP
operator||
name|QDONTSEND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	**  Do initial argv setup. 	**	Insert the mailer name.  Notice that $x expansion is 	**	NOT done on the mailer name.  Then, if the mailer has 	**	a picky -f flag, we insert it as appropriate.  This 	**	code does not check for 'pv' overflow; this places a 	**	manifest lower limit of 4 for MAXPV. 	**		We rewrite the from address here, being careful 	**		to also rewrite it again using ruleset 2 to 	**		eliminate redundancies. 	*/
comment|/* rewrite from address, using rewriting rules */
name|expand
argument_list|(
name|m
operator|->
name|m_from
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|mvp
operator|=
name|prescan
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"bad mailer from translate \"%s\""
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
name|rewrite
argument_list|(
name|mvp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
name|mvp
argument_list|,
name|tfrombuf
argument_list|,
sizeof|sizeof
name|tfrombuf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
name|tfrombuf
argument_list|)
expr_stmt|;
comment|/* translated sender address */
name|define
argument_list|(
literal|'h'
argument_list|,
name|host
argument_list|)
expr_stmt|;
comment|/* to host */
name|Errors
operator|=
literal|0
expr_stmt|;
name|pvp
operator|=
name|pv
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* insert -f or -r flag as appropriate */
if|if
condition|(
name|bitset
argument_list|(
name|M_FOPT
operator||
name|M_ROPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|FromFlag
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|M_FOPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
operator|*
name|pvp
operator|++
operator|=
literal|"-f"
expr_stmt|;
else|else
operator|*
name|pvp
operator|++
operator|=
literal|"-r"
expr_stmt|;
name|expand
argument_list|(
literal|"$g"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Append the other fixed parts of the argv.  These run 	**  up to the first entry containing "$u".  There can only 	**  be one of these, and there are only a few more slots 	**  in the pv after it. 	*/
for|for
control|(
name|mvp
operator|=
name|m
operator|->
name|m_argv
init|;
operator|(
name|p
operator|=
operator|*
operator|++
name|mvp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'$'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|'u'
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
break|break;
comment|/* this entry is safe -- go ahead and process it */
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
operator|-
literal|3
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"Too many parameters to %s before $u"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	**  If we have no substitution for the user name in the argument 	**  list, we know that we must supply the names otherwise -- and 	**  SMTP is the answer!! 	*/
if|if
condition|(
operator|*
name|mvp
operator|==
name|NULL
condition|)
block|{
comment|/* running SMTP */
ifdef|#
directive|ifdef
name|SMTP
name|clever
operator|=
name|TRUE
expr_stmt|;
operator|*
name|pvp
operator|=
name|NULL
expr_stmt|;
comment|/* send the initial SMTP protocol */
name|i
operator|=
name|smtpinit
argument_list|(
name|m
argument_list|,
name|pv
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|i
operator|==
name|EX_TEMPFAIL
condition|)
name|tempfail
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
else|#
directive|else
else|SMTP
comment|/* oops!  we don't implement SMTP */
name|syserr
argument_list|(
literal|"SMTP style mailer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
endif|#
directive|endif
endif|SMTP
block|}
comment|/* 	**  At this point *mvp points to the argument with $u.  We 	**  run through our address list and append all the addresses 	**  we can.  If we run out of space, do not fret!  We can 	**  always send another copy later. 	*/
name|tobuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|CurEnv
operator|->
name|e_to
operator|=
name|tobuf
expr_stmt|;
name|ctladdr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_next
control|)
block|{
comment|/* avoid sending multiple recipients to dumb mailers */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|bitset
argument_list|(
name|M_MUSER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
break|break;
comment|/* if already sent or not for this host, don't send */
if|if
condition|(
operator|(
operator|!
name|ForceMail
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QPSEUDO
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|)
operator|||
name|strcmp
argument_list|(
name|to
operator|->
name|q_host
argument_list|,
name|host
argument_list|)
operator|!=
literal|0
operator|||
name|to
operator|->
name|q_mailer
operator|!=
name|firstto
operator|->
name|q_mailer
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"\nsend to "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|to
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* compute effective uid/gid when sending */
if|if
condition|(
name|to
operator|->
name|q_mailer
operator|==
name|ProgMailer
condition|)
name|ctladdr
operator|=
name|getctladdr
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|user
operator|=
name|to
operator|->
name|q_user
expr_stmt|;
name|CurEnv
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
name|to
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|tempfail
condition|)
block|{
name|to
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  Check to see that these people are allowed to 		**  talk to each other. 		*/
if|if
condition|(
operator|!
name|checkcompat
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|giveresponse
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  Strip quote bits from names if the mailer is dumb 		**	about them. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|M_STRIPQ
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|stripquotes
argument_list|(
name|user
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stripquotes
argument_list|(
name|user
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|host
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Pass it to the other host if we are running SMTP. 		*/
if|if
condition|(
name|clever
condition|)
block|{
ifdef|#
directive|ifdef
name|SMTP
name|i
operator|=
name|smtprcpt
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EX_OK
condition|)
block|{
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|i
operator|==
name|EX_TEMPFAIL
condition|)
name|to
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
else|else
endif|#
directive|endif
endif|QUEUE
block|{
name|to
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
else|SMTP
name|syserr
argument_list|(
literal|"trying to be clever"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SMTP
block|}
comment|/* 		**  If an error message has already been given, don't 		**	bother to send to this address. 		** 		**>>>>>>>>>> This clause assumes that the local mailer 		**>> NOTE>> cannot do any further aliasing; that 		**>>>>>>>>>> function is subsumed by sendmail. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
comment|/* save statistics.... */
name|Stat
operator|.
name|stat_nt
index|[
name|to
operator|->
name|q_mailer
operator|->
name|m_mno
index|]
operator|++
expr_stmt|;
name|Stat
operator|.
name|stat_bt
index|[
name|to
operator|->
name|q_mailer
operator|->
name|m_mno
index|]
operator|+=
name|kbytes
argument_list|(
name|CurEnv
operator|->
name|e_msgsize
argument_list|)
expr_stmt|;
comment|/* 		**  See if this user name is "special". 		**	If the user name has a slash in it, assume that this 		**	is a file -- send it off without further ado.  Note 		**	that this type of addresses is not processed along 		**	with the others, so we fudge on the To person. 		*/
if|if
condition|(
name|m
operator|==
name|LocalMailer
condition|)
block|{
if|if
condition|(
name|user
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|i
operator|=
name|mailfile
argument_list|(
name|user
argument_list|,
name|getctladdr
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		**  Address is verified -- add this user to mailer 		**  argv, and add it to the print list of recipients. 		*/
comment|/* link together the chain of recipients */
name|to
operator|->
name|q_tchain
operator|=
name|tochain
expr_stmt|;
name|tochain
operator|=
name|to
expr_stmt|;
comment|/* create list of users for error messages */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tobuf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tobuf
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'u'
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* to user */
name|define
argument_list|(
literal|'z'
argument_list|,
name|to
operator|->
name|q_home
argument_list|)
expr_stmt|;
comment|/* user's home */
comment|/* 		**  Expand out this user into argument list. 		*/
if|if
condition|(
operator|!
name|clever
condition|)
block|{
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
operator|-
literal|2
index|]
condition|)
block|{
comment|/* allow some space for trailing parms */
break|break;
block|}
block|}
block|}
comment|/* see if any addresses still exist */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|SMTP
if|if
condition|(
name|clever
condition|)
name|smtpquit
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SMTP
name|define
argument_list|(
literal|'g'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* print out messages as full list */
name|CurEnv
operator|->
name|e_to
operator|=
name|tobuf
expr_stmt|;
comment|/* 	**  Fill out any parameters after the $u parameter. 	*/
while|while
condition|(
operator|!
name|clever
operator|&&
operator|*
operator|++
name|mvp
operator|!=
name|NULL
condition|)
block|{
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
index|]
condition|)
name|syserr
argument_list|(
literal|"deliver: pv overflow after $u for %s"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|pvp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Call the mailer. 	**	The argument vector gets built, pipes 	**	are created as necessary, and we fork& exec as 	**	appropriate. 	**	If we are running SMTP, we just need to clean up. 	*/
if|if
condition|(
name|ctladdr
operator|==
name|NULL
condition|)
name|ctladdr
operator|=
operator|&
name|CurEnv
operator|->
name|e_from
expr_stmt|;
ifdef|#
directive|ifdef
name|SMTP
if|if
condition|(
name|clever
condition|)
block|{
name|i
operator|=
name|smtpfinish
argument_list|(
name|m
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|smtpquit
argument_list|(
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|SMTP
name|i
operator|=
name|sendoff
argument_list|(
name|m
argument_list|,
name|pv
argument_list|,
name|ctladdr
argument_list|)
expr_stmt|;
comment|/* 	**  If we got a temporary failure, arrange to queue the 	**  addressees. 	*/
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|i
operator|==
name|EX_TEMPFAIL
condition|)
block|{
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
name|to
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
block|}
endif|#
directive|endif
endif|QUEUE
name|errno
operator|=
literal|0
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DOFORK -- do a fork, retrying a couple of times on failure. ** **	This MUST be a macro, since after a vfork we are running **	two processes on the same stack!!! ** **	Parameters: **		none. ** **	Returns: **		From a macro???  You've got to be kidding! ** **	Side Effects: **		Modifies the ==> LOCAL<== variable 'pid', leaving: **			pid of child in parent, zero in child. **			-1 on unrecoverable error. ** **	Notes: **		I'm awfully sorry this looks so awful.  That's **		vfork for you..... */
end_comment

begin_define
define|#
directive|define
name|NFORKTRIES
value|5
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_define
define|#
directive|define
name|XFORK
value|vfork
end_define

begin_else
else|#
directive|else
else|VFORK
end_else

begin_define
define|#
directive|define
name|XFORK
value|fork
end_define

begin_endif
endif|#
directive|endif
endif|VFORK
end_endif

begin_define
define|#
directive|define
name|DOFORK
parameter_list|(
name|fORKfN
parameter_list|)
define|\
value|{\ 	register int i;\ \ 	for (i = NFORKTRIES; i--> 0; )\ 	{\ 		pid = fORKfN();\ 		if (pid>= 0)\ 			break;\ 		sleep(NFORKTRIES - i);\ 	}\ }
end_define

begin_escape
end_escape

begin_comment
comment|/* **  DOFORK -- simple fork interface to DOFORK. ** **	Parameters: **		none. ** **	Returns: **		pid of child in parent. **		zero in child. **		-1 on error. ** **	Side Effects: **		returns twice, once in parent and once in child. */
end_comment

begin_macro
name|dofork
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|DOFORK
argument_list|(
name|fork
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SENDOFF -- send off call to mailer& collect response. ** **	Parameters: **		m -- mailer descriptor. **		pvp -- parameter vector to send to it. **		ctladdr -- an address pointer controlling the **			user/groupid etc. of the mailer. ** **	Returns: **		exit status of mailer. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|sendoff
argument_list|(
argument|m
argument_list|,
argument|pvp
argument_list|,
argument|ctladdr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|auto
name|FILE
modifier|*
name|mfile
decl_stmt|;
specifier|auto
name|FILE
modifier|*
name|rfile
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* 	**  Create connection to mailer. 	*/
name|pid
operator|=
name|openmailer
argument_list|(
name|m
argument_list|,
name|pvp
argument_list|,
name|ctladdr
argument_list|,
name|FALSE
argument_list|,
operator|&
name|mfile
argument_list|,
operator|&
name|rfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	**  Format and send message. 	*/
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|putfromline
argument_list|(
name|mfile
argument_list|,
name|m
argument_list|)
expr_stmt|;
call|(
modifier|*
name|CurEnv
operator|->
name|e_puthdr
call|)
argument_list|(
name|mfile
argument_list|,
name|m
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|CurEnv
operator|->
name|e_putbody
call|)
argument_list|(
name|mfile
argument_list|,
name|m
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|mfile
argument_list|)
expr_stmt|;
name|i
operator|=
name|endmailer
argument_list|(
name|pid
argument_list|,
name|pvp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* arrange a return receipt if requested */
if|if
condition|(
name|CurEnv
operator|->
name|e_retreceipt
operator|&&
name|bitset
argument_list|(
name|M_LOCAL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|i
operator|==
name|EX_OK
condition|)
block|{
name|CurEnv
operator|->
name|e_sendreceipt
operator|=
name|TRUE
expr_stmt|;
name|fprintf
argument_list|(
name|Xscript
argument_list|,
literal|"%s... successfully delivered\n"
argument_list|,
name|CurEnv
operator|->
name|e_to
argument_list|)
expr_stmt|;
comment|/* do we want to send back more info? */
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ENDMAILER -- Wait for mailer to terminate. ** **	We should never get fatal errors (e.g., segmentation **	violation), so we report those specially.  For other **	errors, we choose a status message (into statmsg), **	and if it represents an error, we print it. ** **	Parameters: **		pid -- pid of mailer. **		name -- name of mailer (for error messages). ** **	Returns: **		exit code of mailer. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|endmailer
argument_list|(
argument|pid
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|st
decl_stmt|;
comment|/* in the IPC case there is nothing to wait for */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
return|return
operator|(
name|EX_OK
operator|)
return|;
comment|/* wait for the mailer process to die and collect status */
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|st
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|i
operator|!=
name|pid
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* see if it died a horrid death */
if|if
condition|(
operator|(
name|st
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s: stat %o"
argument_list|,
name|name
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* normal death -- return status */
name|i
operator|=
operator|(
name|st
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  OPENMAILER -- open connection to mailer. ** **	Parameters: **		m -- mailer descriptor. **		pvp -- parameter vector to pass to mailer. **		ctladdr -- controlling address for user. **		clever -- create a full duplex connection. **		pmfile -- pointer to mfile (to mailer) connection. **		prfile -- pointer to rfile (from mailer) connection. ** **	Returns: **		pid of mailer (> 0 ). **		-1 on error. **		zero on an IPC connection. ** **	Side Effects: **		creates a mailer in a subprocess. */
end_comment

begin_macro
name|openmailer
argument_list|(
argument|m
argument_list|,
argument|pvp
argument_list|,
argument|ctladdr
argument_list|,
argument|clever
argument_list|,
argument|pmfile
argument_list|,
argument|prfile
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|clever
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|pmfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|prfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|int
name|mpvect
index|[
literal|2
index|]
decl_stmt|;
name|int
name|rpvect
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|mfile
decl_stmt|;
name|FILE
modifier|*
name|rfile
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"openmailer:\n"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DAEMON
comment|/* 	**  Deal with the special case of mail handled through an IPC 	**  connection. 	**	In this case we don't actually fork.  We must be 	**	running SMTP for this to work.  We will return a 	**	zero pid to indicate that we are running IPC. 	*/
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[IPC]"
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|clever
condition|)
name|syserr
argument_list|(
literal|"non-clever IPC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
name|i
operator|=
name|atoi
argument_list|(
name|pvp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|makeconnection
argument_list|(
name|pvp
index|[
literal|1
index|]
argument_list|,
name|i
argument_list|,
name|pmfile
argument_list|,
name|prfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EX_OK
condition|)
block|{
name|ExitStat
operator|=
name|i
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
endif|DAEMON
comment|/* create a pipe to shove the mail through */
if|if
condition|(
name|pipe
argument_list|(
name|mpvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"pipe (to mailer)"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SMTP
comment|/* if this mailer speaks smtp, create a return pipe */
if|if
condition|(
name|clever
operator|&&
name|pipe
argument_list|(
name|rpvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"pipe (from mailer)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
endif|SMTP
comment|/* 	**  Actually fork the mailer process. 	**	DOFORK is clever about retrying. 	*/
name|DOFORK
argument_list|(
name|XFORK
argument_list|)
expr_stmt|;
comment|/* pid is set by DOFORK */
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
comment|/* failure */
name|syserr
argument_list|(
literal|"Cannot fork"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clever
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child -- set up input& exec mailer */
comment|/* make diagnostic output be standard output */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* arrange to filter standard& diag output of command */
if|if
condition|(
name|clever
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OutChannel
operator|!=
name|stdout
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|fileno
argument_list|(
name|OutChannel
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* arrange to get standard input */
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot dup to zero!"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_RESTR
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|->
name|q_uid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|DefGid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|DefUid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|ctladdr
operator|->
name|q_uid
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|VFORK
comment|/* 		**  We have to be careful with vfork - we can't mung up the 		**  memory but we don't want the mailer to inherit any extra 		**  open files.  Chances are the mailer won't 		**  care about an extra file, but then again you never know. 		**  Actually, we would like to close(fileno(pwf)), but it's 		**  declared static so we can't.  But if we fclose(pwf), which 		**  is what endpwent does, it closes it in the parent too and 		**  the next getpwnam will be slower.  If you have a weird 		**  mailer that chokes on the extra file you should do the 		**  endpwent(). 		** 		**  Similar comments apply to log.  However, openlog is 		**  clever enough to set the FIOCLEX mode on the file, 		**  so it will be closed automatically on the exec. 		*/
name|endpwent
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
name|closelog
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|LOG
endif|#
directive|endif
endif|VFORK
comment|/* try to execute the mailer */
name|execv
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
comment|/* syserr fails because log is closed */
comment|/* syserr("Cannot exec %s", m->m_mailer); */
name|printf
argument_list|(
literal|"Cannot exec '%s' errno=%d\n"
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|,
name|errno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Set up return value. 	*/
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mfile
operator|=
name|fdopen
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clever
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|rfile
operator|=
name|fdopen
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
operator|*
name|pmfile
operator|=
name|mfile
expr_stmt|;
operator|*
name|prfile
operator|=
name|rfile
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GIVERESPONSE -- Interpret an error response from a mailer ** **	Parameters: **		stat -- the status code from the mailer (high byte **			only; core dumps must have been taken care of **			already). **		force -- if set, force an error message output, even **			if the mailer seems to like to print its own **			messages. **		m -- the mailer descriptor for this mailer. ** **	Returns: **		none. ** **	Side Effects: **		Errors may be incremented. **		ExitStat may be set. */
end_comment

begin_macro
name|giveresponse
argument_list|(
argument|stat
argument_list|,
argument|force
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|force
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|statmsg
decl_stmt|;
specifier|extern
name|char
modifier|*
name|SysExMsg
index|[]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|N_SysEx
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
comment|/* 	**  Compute status message from code. 	*/
name|i
operator|=
name|stat
operator|-
name|EX__BASE
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|N_SysEx
condition|)
name|statmsg
operator|=
name|NULL
expr_stmt|;
else|else
name|statmsg
operator|=
name|SysExMsg
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|M_LOCAL
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|statmsg
operator|=
literal|"delivered"
expr_stmt|;
else|else
name|statmsg
operator|=
literal|"queued"
expr_stmt|;
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUEUE
elseif|else
if|if
condition|(
name|stat
operator|==
name|EX_TEMPFAIL
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"transmission deferred"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|QUEUE
else|else
block|{
name|Errors
operator|++
expr_stmt|;
name|FatalErrors
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|statmsg
operator|==
name|NULL
operator|&&
name|m
operator|->
name|m_badstat
operator|!=
literal|0
condition|)
block|{
name|stat
operator|=
name|m
operator|->
name|m_badstat
expr_stmt|;
name|i
operator|=
name|stat
operator|-
name|EX__BASE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|N_SysEx
condition|)
name|syserr
argument_list|(
literal|"Bad m_badstat %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|DEBUG
name|statmsg
operator|=
name|SysExMsg
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|statmsg
operator|==
name|NULL
condition|)
name|usrerr
argument_list|(
literal|"unknown mailer response %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|force
operator|||
operator|!
name|bitset
argument_list|(
name|M_QUIET
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|Verbose
condition|)
name|usrerr
argument_list|(
literal|"%s"
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Final cleanup. 	**	Log a record of the transaction.  Compute the new 	**	ExitStat -- if we already had an error, stick with 	**	that. 	*/
if|if
condition|(
name|statmsg
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"error %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s->%s: %ld: %s"
argument_list|,
name|CurEnv
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|CurEnv
operator|->
name|e_to
argument_list|,
name|CurEnv
operator|->
name|e_msgsize
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
name|stat
operator|!=
name|EX_TEMPFAIL
condition|)
endif|#
directive|endif
endif|QUEUE
name|setstat
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTFROMLINE -- output a UNIX-style from line (or whatever) ** **	then passes the rest of the message through.  If we have **	managed to extract a date already, use that; otherwise, **	use the current date/time. ** **	One of the ugliest hacks seen by human eyes is **	contained herein: UUCP wants those stupid **	"remote from<host>" lines.  Why oh why does a **	well-meaning programmer such as myself have to **	deal with this kind of antique garbage???? ** **	Parameters: **		fp -- the file to output to. **		m -- the mailer describing this entry. ** **	Returns: **		none ** **	Side Effects: **		outputs some text to fp. */
end_comment

begin_expr_stmt
name|putfromline
argument_list|(
name|fp
argument_list|,
name|m
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|char
name|SentDate
index|[]
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|M_NHDR
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|UGLYUUCP
if|if
condition|(
name|bitset
argument_list|(
name|M_UGLYUUCP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
name|char
modifier|*
name|sys
init|=
name|macvalue
argument_list|(
literal|'g'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bang
init|=
name|index
argument_list|(
name|sys
argument_list|,
literal|'!'
argument_list|)
decl_stmt|;
if|if
condition|(
name|bang
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"No ! in UUCP! (%s)"
argument_list|,
name|sys
argument_list|)
expr_stmt|;
else|else
operator|*
name|bang
operator|=
literal|'\0'
expr_stmt|;
name|expand
argument_list|(
literal|"From $f  $d remote from $g"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
operator|*
name|bang
operator|=
literal|'!'
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|UGLYUUCP
name|expand
argument_list|(
literal|"$l\n"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTHEADER -- put the header part of a message from the in-core copy ** **	Parameters: **		fp -- file to put it on. **		m -- mailer to use. **		e -- envelope to use. ** **	Returns: **		none. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|putheader
argument_list|(
name|fp
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|capitalize
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|hvalue
parameter_list|()
function_decl|;
specifier|extern
name|bool
name|samefrom
parameter_list|()
function_decl|;
name|char
modifier|*
name|of_line
decl_stmt|;
name|of_line
operator|=
name|hvalue
argument_list|(
literal|"original-from"
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|e
operator|->
name|e_header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|origfrom
init|=
name|e
operator|->
name|e_origfrom
decl_stmt|;
name|bool
name|nooutput
decl_stmt|;
name|nooutput
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|H_CHECK
operator||
name|H_ACHECK
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|h
operator|->
name|h_mflags
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|nooutput
operator|=
name|TRUE
expr_stmt|;
comment|/* use From: line from message if generated is the same */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
literal|"from"
argument_list|)
operator|==
literal|0
operator|&&
name|origfrom
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|m
operator|->
name|m_from
argument_list|,
literal|"$f"
argument_list|)
operator|==
literal|0
operator|&&
name|of_line
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|origfrom
expr_stmt|;
name|origfrom
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|H_DEFAULT
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
name|expand
argument_list|(
name|h
operator|->
name|h_value
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitset
argument_list|(
name|H_ADDR
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
block|{
specifier|register
name|int
name|opos
decl_stmt|;
name|bool
name|firstone
init|=
name|TRUE
decl_stmt|;
comment|/* 			**  Output the address list translated by the 			**  mailer and with commas. 			*/
name|p
operator|=
name|h
operator|->
name|h_value
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
operator|||
name|nooutput
condition|)
continue|continue;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: "
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|)
expr_stmt|;
name|opos
operator|=
name|strlen
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|remotename
parameter_list|()
function_decl|;
name|char
name|savechar
decl_stmt|;
comment|/* find the end of the name */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
specifier|extern
name|bool
name|isatword
parameter_list|()
function_decl|;
name|char
modifier|*
name|oldp
decl_stmt|;
if|if
condition|(
operator|!
name|e
operator|->
name|e_oldstyle
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
name|oldp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'@'
operator|&&
operator|!
name|isatword
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|=
name|oldp
expr_stmt|;
break|break;
block|}
name|p
operator|+=
operator|*
name|p
operator|==
literal|'@'
condition|?
literal|1
else|:
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|savechar
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* translate the name to be relative */
name|name
operator|=
name|remotename
argument_list|(
name|name
argument_list|,
name|m
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* output the name with nice formatting */
name|opos
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstone
condition|)
name|opos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|opos
operator|>
literal|78
operator|&&
operator|!
name|firstone
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|",\n        "
argument_list|)
expr_stmt|;
name|opos
operator|=
literal|8
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|firstone
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|firstone
operator|=
name|FALSE
expr_stmt|;
comment|/* clean up the source string */
operator|*
name|p
operator|=
name|savechar
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|','
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|nooutput
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|p
operator|=
name|h
operator|->
name|h_value
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* hack, hack -- output Original-From field if different */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
literal|"from"
argument_list|)
operator|==
literal|0
operator|&&
name|origfrom
operator|!=
name|NULL
condition|)
block|{
comment|/* output new Original-From line if needed */
if|if
condition|(
name|of_line
operator|==
name|NULL
operator|&&
operator|!
name|samefrom
argument_list|(
name|p
argument_list|,
name|origfrom
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Original-From: %s\n"
argument_list|,
name|origfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|of_line
operator|!=
name|NULL
operator|&&
operator|!
name|nooutput
operator|&&
name|samefrom
argument_list|(
name|p
argument_list|,
name|of_line
argument_list|)
condition|)
block|{
comment|/* delete Original-From: line if redundant */
name|p
operator|=
name|of_line
expr_stmt|;
name|of_line
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|h_field
argument_list|,
literal|"original-from"
argument_list|)
operator|==
literal|0
operator|&&
name|of_line
operator|==
name|NULL
condition|)
name|nooutput
operator|=
name|TRUE
expr_stmt|;
comment|/* finally, output the header line */
if|if
condition|(
operator|!
name|nooutput
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|H_USED
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTBODY -- put the body of a message. ** **	Parameters: **		fp -- file to output onto. **		m -- a mailer descriptor. **		xdot -- if set, use SMTP hidden dot algorithm. ** **	Returns: **		none. ** **	Side Effects: **		The message is written onto fp. */
end_comment

begin_macro
name|putbody
argument_list|(
argument|fp
argument_list|,
argument|m
argument_list|,
argument|xdot
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|xdot
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	**  Output the body of the message 	*/
ifdef|#
directive|ifdef
name|lint
comment|/* m will be needed later for complete smtp emulation */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
endif|#
directive|endif
endif|lint
if|if
condition|(
name|TempFile
operator|!=
name|NULL
condition|)
block|{
name|rewind
argument_list|(
name|TempFile
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
while|while
condition|(
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|fgets
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|,
name|TempFile
argument_list|)
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
operator|(
name|xdot
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|?
name|buf
else|:
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|TempFile
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"putbody: read error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|errno
operator|!=
name|EPIPE
condition|)
block|{
name|syserr
argument_list|(
literal|"putbody: write error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ISATWORD -- tell if the word we are pointing to is "at". ** **	Parameters: **		p -- word to check. ** **	Returns: **		TRUE -- if p is the word at. **		FALSE -- otherwise. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|isatword
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|extern
name|char
name|lower
parameter_list|()
function_decl|;
if|if
condition|(
name|lower
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|==
literal|'a'
operator|&&
name|lower
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'t'
operator|&&
name|p
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  REMOTENAME -- return the name relative to the current mailer ** **	Parameters: **		name -- the name to translate. **		force -- if set, forces rewriting even if the mailer **			does not request it.  Used for rewriting **			sender addresses. ** **	Returns: **		the text string representing this address relative to **			the receiving mailer. ** **	Side Effects: **		none. ** **	Warnings: **		The text string returned is tucked away locally; **			copy it if you intend to save it. */
end_comment

begin_function
name|char
modifier|*
name|remotename
parameter_list|(
name|name
parameter_list|,
name|m
parameter_list|,
name|force
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|bool
name|force
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|lbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|macvalue
parameter_list|()
function_decl|;
name|char
modifier|*
name|oldf
init|=
name|macvalue
argument_list|(
literal|'f'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|oldx
init|=
name|macvalue
argument_list|(
literal|'x'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|oldg
init|=
name|macvalue
argument_list|(
literal|'g'
argument_list|)
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|prescan
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getxpart
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|buildaddr
parameter_list|()
function_decl|;
comment|/* 	**  See if this mailer wants the name to be rewritten.  There are 	**  many problems here, owing to the standards for doing replies. 	**  In general, these names should only be rewritten if we are 	**  sending to another host that runs sendmail. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_RELRCPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|force
condition|)
return|return
operator|(
name|name
operator|)
return|;
comment|/* 	**  Do general rewriting of name. 	**	This will also take care of doing global name translation. 	*/
name|define
argument_list|(
literal|'x'
argument_list|,
name|getxpart
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|pvp
operator|=
name|prescan
argument_list|(
name|name
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pvp
operator|==
name|CANONNET
condition|)
block|{
specifier|auto
name|ADDRESS
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|hostalias
parameter_list|()
function_decl|;
comment|/* oops... resolved to something */
if|if
condition|(
name|buildaddr
argument_list|(
name|pvp
argument_list|,
operator|&
name|a
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|p
operator|=
name|hostalias
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|pvp
operator|=
name|prescan
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* make the name relative to the receiving mailer */
name|define
argument_list|(
literal|'f'
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|m
operator|->
name|m_from
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
comment|/* rewrite to get rid of garbage we added in the expand above */
name|pvp
operator|=
name|prescan
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|rewrite
argument_list|(
name|pvp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cataddr
argument_list|(
name|pvp
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
expr_stmt|;
comment|/* now add any comment info we had before back */
name|define
argument_list|(
literal|'g'
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|expand
argument_list|(
literal|"$q"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'f'
argument_list|,
name|oldf
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
name|oldg
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'x'
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"remotename(%s) => `%s'\n"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  SAMEFROM -- tell if two text addresses represent the same from address. ** **	Parameters: **		ifrom -- internally generated form of from address. **		efrom -- external form of from address. ** **	Returns: **		TRUE -- if they convey the same info. **		FALSE -- if any information has been lost. ** **	Side Effects: **		none. */
end_comment

begin_function
name|bool
name|samefrom
parameter_list|(
name|ifrom
parameter_list|,
name|efrom
parameter_list|)
name|char
modifier|*
name|ifrom
decl_stmt|;
name|char
modifier|*
name|efrom
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|MAXNAME
operator|+
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|7
condition|)
name|printf
argument_list|(
literal|"samefrom(%s,%s)-->"
argument_list|,
name|ifrom
argument_list|,
name|efrom
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|strcmp
argument_list|(
name|ifrom
argument_list|,
name|efrom
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|success
goto|;
name|p
operator|=
name|index
argument_list|(
name|ifrom
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|failure
goto|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ifrom
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" at "
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'@'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|efrom
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|success
goto|;
name|failure
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|7
condition|)
name|printf
argument_list|(
literal|"FALSE\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|FALSE
operator|)
return|;
name|success
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|7
condition|)
name|printf
argument_list|(
literal|"TRUE\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MAILFILE -- Send a message to a file. ** **	If the file has the setuid/setgid bits set, but NO execute **	bits, sendmail will try to become the owner of that file **	rather than the real user.  Obviously, this only works if **	sendmail runs as root. ** **	Parameters: **		filename -- the name of the file to send to. **		ctladdr -- the controlling address header -- includes **			the userid/groupid to be when sending. ** **	Returns: **		The exit code associated with the operation. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|mailfile
argument_list|(
argument|filename
argument_list|,
argument|ctladdr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
comment|/* 	**  Fork so we can change permissions here. 	**	Note that we MUST use fork, not vfork, because of 	**	the complications of calling subroutines, etc. 	*/
name|DOFORK
argument_list|(
name|fork
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
operator|(
name|EX_OSERR
operator|)
return|;
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child -- actually write to file */
name|struct
name|stat
name|stb
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|OldUmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
name|stb
operator|.
name|st_mode
operator|=
literal|0666
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|0111
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|==
name|NULL
condition|)
name|ctladdr
operator|=
operator|&
name|CurEnv
operator|->
name|e_from
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
operator|||
name|setgid
argument_list|(
name|stb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|->
name|q_uid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|DefGid
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
operator|||
name|setuid
argument_list|(
name|stb
operator|.
name|st_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|->
name|q_uid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|DefUid
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|ctladdr
operator|->
name|q_uid
argument_list|)
expr_stmt|;
block|}
name|f
operator|=
name|dfopen
argument_list|(
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
name|putfromline
argument_list|(
name|f
argument_list|,
name|Mailer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|CurEnv
operator|->
name|e_puthdr
call|)
argument_list|(
name|f
argument_list|,
name|Mailer
index|[
literal|1
index|]
argument_list|,
name|CurEnv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|CurEnv
operator|->
name|e_putbody
call|)
argument_list|(
name|f
argument_list|,
name|Mailer
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* reset ISUID& ISGID bits for paranoid systems */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|filename
argument_list|,
operator|(
name|int
operator|)
name|stb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
block|{
comment|/* parent -- wait for exit status */
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|stat
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|stat
argument_list|)
operator|)
operator|!=
name|pid
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|stat
operator|=
name|EX_OSERR
operator|<<
literal|8
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|stat
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
name|stat
operator|=
name|EX_UNAVAILABLE
operator|<<
literal|8
expr_stmt|;
return|return
operator|(
operator|(
name|stat
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SENDALL -- actually send all the messages. ** **	Parameters: **		e -- the envelope to send. **		verifyonly -- if set, only give verification messages. ** **	Returns: **		none. ** **	Side Effects: **		Scans the send lists and sends everything it finds. **		Delivers any appropriate error messages. */
end_comment

begin_macro
name|sendall
argument_list|(
argument|e
argument_list|,
argument|verifyonly
argument_list|)
end_macro

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|verifyonly
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nSend Queue:\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Run through the list and send everything. 	*/
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|verifyonly
condition|)
block|{
name|CurEnv
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|M_LOCAL
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"deliverable"
argument_list|)
expr_stmt|;
else|else
name|message
argument_list|(
name|Arpa_Info
argument_list|,
literal|"queueable"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|deliver
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Now run through and check for errors. 	*/
if|if
condition|(
name|verifyonly
condition|)
return|return;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
specifier|register
name|ADDRESS
modifier|*
name|qq
decl_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|e
operator|->
name|e_queueup
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QBADADDR
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
comment|/* we have an address that failed -- find the parent */
for|for
control|(
name|qq
operator|=
name|q
init|;
name|qq
operator|!=
name|NULL
condition|;
name|qq
operator|=
name|qq
operator|->
name|q_alias
control|)
block|{
name|char
name|obuf
index|[
name|MAXNAME
operator|+
literal|6
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|aliaslookup
parameter_list|()
function_decl|;
comment|/* we can only have owners for local addresses */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_LOCAL
argument_list|,
name|qq
operator|->
name|q_mailer
operator|->
name|m_flags
argument_list|)
condition|)
continue|continue;
comment|/* see if the owner list exists */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|obuf
argument_list|,
literal|"owner-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|obuf
argument_list|,
name|qq
operator|->
name|q_user
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliaslookup
argument_list|(
name|obuf
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* owner list exists -- add it to the error queue */
name|qq
operator|->
name|q_flags
operator|&=
operator|~
name|QPRIMARY
expr_stmt|;
name|sendto
argument_list|(
name|obuf
argument_list|,
literal|1
argument_list|,
name|qq
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|)
expr_stmt|;
name|MailBack
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* if we did not find an owner, send to the sender */
if|if
condition|(
name|qq
operator|==
name|NULL
condition|)
name|sendto
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
literal|1
argument_list|,
name|qq
argument_list|,
operator|&
name|e
operator|->
name|e_errorqueue
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  CHECKERRORS -- check a queue of addresses and process errors. ** **	Parameters: **		e -- the envelope to check. ** **	Returns: **		none. ** **	Side Effects: **		Arranges to queue all tempfailed messages in q **			or deliver error responses. */
end_comment

begin_expr_stmt
name|checkerrors
argument_list|(
name|e
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\ncheckerrors: errorqueue:\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_errorqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
comment|/* mail back the transcript on errors */
if|if
condition|(
name|FatalErrors
condition|)
name|savemail
argument_list|()
expr_stmt|;
comment|/* queue up anything laying around */
if|if
condition|(
name|e
operator|->
name|e_queueup
condition|)
block|{
ifdef|#
directive|ifdef
name|QUEUE
name|queueup
argument_list|(
name|e
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|#
directive|else
else|QUEUE
name|syserr
argument_list|(
literal|"finis: trying to queue %s"
argument_list|,
name|e
operator|->
name|e_df
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|QUEUE
block|}
block|}
end_block

end_unit

