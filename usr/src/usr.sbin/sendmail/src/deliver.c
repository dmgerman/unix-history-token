begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Eric P. Allman  * Copyright (c) 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * %sccs.include.redist.c%  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)deliver.c	8.10 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"sendmail.h"
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NAMED_BIND
end_ifdef

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **  SENDALL -- actually send all the messages. ** **	Parameters: **		e -- the envelope to send. **		mode -- the delivery mode to use.  If SM_DEFAULT, use **			the current e->e_sendmode. ** **	Returns: **		none. ** **	Side Effects: **		Scans the send lists and sends everything it finds. **		Delivers any appropriate error messages. **		If we are running in a non-interactive mode, takes the **			appropriate action. */
end_comment

begin_macro
name|sendall
argument_list|(
argument|e
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|owner
decl_stmt|;
name|int
name|otherowners
decl_stmt|;
specifier|register
name|ENVELOPE
modifier|*
name|ee
decl_stmt|;
name|ENVELOPE
modifier|*
name|splitenv
init|=
name|NULL
decl_stmt|;
name|bool
name|announcequeueup
decl_stmt|;
name|int
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCKF
name|struct
name|flock
name|lfd
decl_stmt|;
endif|#
directive|endif
comment|/* 	**  If we have had global, fatal errors, don't bother sending 	**  the message at all if we are in SMTP mode.  Local errors 	**  (e.g., a single address failing) will still cause the other 	**  addresses to be sent. 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_FATALERRS
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|OpMode
operator|==
name|MD_SMTP
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_CLRQUEUE
expr_stmt|;
return|return;
block|}
comment|/* determine actual delivery mode */
if|if
condition|(
name|mode
operator|==
name|SM_DEFAULT
condition|)
block|{
name|mode
operator|=
name|e
operator|->
name|e_sendmode
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|SM_VERIFY
operator|&&
name|shouldqueue
argument_list|(
name|e
operator|->
name|e_msgpriority
argument_list|,
name|e
operator|->
name|e_ctime
argument_list|)
condition|)
name|mode
operator|=
name|SM_QUEUE
expr_stmt|;
name|announcequeueup
operator|=
name|mode
operator|==
name|SM_QUEUE
expr_stmt|;
block|}
else|else
name|announcequeueup
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nSENDALL: mode %c, e_from "
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sendqueue:\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Do any preprocessing necessary for the mode we are running. 	**	Check to make sure the hop count is reasonable. 	**	Delete sends to the sender in mailing lists. 	*/
name|CurEnv
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_hopcount
operator|>
name|MaxHopCount
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|syserr
argument_list|(
literal|"554 too many hops %d (%d max): from %s, to %s"
argument_list|,
name|e
operator|->
name|e_hopcount
argument_list|,
name|MaxHopCount
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|e
operator|->
name|e_sendqueue
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	**  Do sender deletion. 	** 	**	If the sender has the QQUEUEUP flag set, skip this. 	**	This can happen if the name server is hosed when you 	**	are trying to send mail.  The result is that the sender 	**	is instantiated in the queue as a recipient. 	*/
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|EF_METOO
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
operator|!
name|bitset
argument_list|(
name|QQUEUEUP
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendall: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
operator|(
name|void
operator|)
name|recipient
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QUEUE
if|if
condition|(
operator|(
name|mode
operator|==
name|SM_QUEUE
operator|||
name|mode
operator|==
name|SM_FORK
operator|||
operator|(
name|mode
operator|!=
name|SM_VERIFY
operator|&&
name|SuperSafe
operator|)
operator|)
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_INQUEUE
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
comment|/* be sure everything is instantiated in the queue */
name|queueup
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|,
name|mode
operator|==
name|SM_QUEUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* QUEUE */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SM_VERIFY
case|:
name|Verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SM_QUEUE
case|:
name|queueonly
label|:
name|e
operator|->
name|e_flags
operator||=
name|EF_INQUEUE
operator||
name|EF_KEEPQUEUE
expr_stmt|;
return|return;
case|case
name|SM_FORK
case|:
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF
comment|/* 		**  Since lockf has the interesting semantic that the 		**  lock is lost when we fork, we have to risk losing 		**  the lock here by closing before the fork, and then 		**  trying to get it back in the child. 		*/
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
literal|"sendenvelope"
argument_list|,
literal|"lockfp"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCKF */
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
goto|goto
name|queueonly
goto|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
comment|/* be sure we leave the temp files to our child */
name|e
operator|->
name|e_id
operator|=
name|e
operator|->
name|e_df
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|LOCKF
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|,
literal|"sendenvelope"
argument_list|,
literal|"lockfp"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* close any random open files in the envelope */
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|,
literal|"sendenvelope"
argument_list|,
literal|"dfp"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"sendenvelope"
argument_list|,
literal|"xfp"
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_xfp
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
comment|/* double fork to avoid zombies */
if|if
condition|(
name|fork
argument_list|()
operator|>
literal|0
condition|)
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
comment|/* be sure we are immune from the terminal */
name|disconnect
argument_list|(
name|FALSE
argument_list|,
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF
comment|/* 		**  Now try to get our lock back. 		*/
name|lfd
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|lfd
operator|.
name|l_whence
operator|=
name|lfd
operator|.
name|l_start
operator|=
name|lfd
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_lockfp
operator|=
name|fopen
argument_list|(
name|queuename
argument_list|(
name|e
argument_list|,
literal|'q'
argument_list|)
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_lockfp
operator|==
name|NULL
operator|||
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_lockfp
argument_list|)
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|lfd
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* oops....  lost it */
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sendenvelope: %s lost lock: lockfp=%x, %s\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_lockfp
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|29
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: lost lock: %m"
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCKF */
comment|/* 		**  Close any cached connections. 		** 		**	We don't send the QUIT protocol because the parent 		**	still knows about the connection. 		** 		**	This should only happen when delivering an error 		**	message. 		*/
name|mci_flush
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	**  If we haven't fully expanded aliases, do it now 	*/
if|if
condition|(
name|bitset
argument_list|(
name|EF_VRFYONLY
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator|&=
operator|~
name|EF_VRFYONLY
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
specifier|extern
name|ADDRESS
modifier|*
name|recipient
parameter_list|()
function_decl|;
if|if
condition|(
name|bitset
argument_list|(
name|QVERIFIED
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
name|recipient
argument_list|(
name|q
argument_list|,
operator|&
name|e
operator|->
name|e_sendqueue
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	**  Handle alias owners. 	** 	**	We scan up the q_alias chain looking for owners. 	**	We discard owners that are the same as the return path. 	*/
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
specifier|register
name|struct
name|address
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|q
init|;
name|a
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|q_owner
operator|==
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|q_alias
control|)
continue|continue;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|q
operator|->
name|q_owner
operator|=
name|a
operator|->
name|q_owner
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|NULL
operator|&&
operator|!
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|q
operator|->
name|q_owner
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
operator|==
literal|0
condition|)
name|q
operator|->
name|q_owner
operator|=
name|NULL
expr_stmt|;
block|}
name|owner
operator|=
literal|""
expr_stmt|;
name|otherowners
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|owner
operator|!=
name|NULL
operator|&&
name|otherowners
operator|>
literal|0
condition|)
block|{
name|owner
operator|=
name|NULL
expr_stmt|;
name|otherowners
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|owner
operator|==
name|NULL
condition|)
name|owner
operator|=
name|q
operator|->
name|q_owner
expr_stmt|;
elseif|else
if|if
condition|(
name|owner
operator|!=
name|q
operator|->
name|q_owner
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|owner
argument_list|,
name|q
operator|->
name|q_owner
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* make future comparisons cheap */
name|q
operator|->
name|q_owner
operator|=
name|owner
expr_stmt|;
block|}
else|else
block|{
name|otherowners
operator|++
expr_stmt|;
block|}
name|owner
operator|=
name|q
operator|->
name|q_owner
expr_stmt|;
block|}
block|}
else|else
block|{
name|otherowners
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|owner
operator|!=
name|NULL
operator|&&
name|otherowners
operator|>
literal|0
condition|)
block|{
specifier|extern
name|HDR
modifier|*
name|copyheader
parameter_list|()
function_decl|;
specifier|extern
name|ADDRESS
modifier|*
name|copyqueue
parameter_list|()
function_decl|;
comment|/* 			**  Split this envelope into two. 			*/
name|ee
operator|=
operator|(
name|ENVELOPE
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ENVELOPE
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ee
operator|=
operator|*
name|e
expr_stmt|;
name|ee
operator|->
name|e_id
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|queuename
argument_list|(
name|ee
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sendall: split %s into %s\n"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|ee
operator|->
name|e_id
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_header
operator|=
name|copyheader
argument_list|(
name|e
operator|->
name|e_header
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_sendqueue
operator|=
name|copyqueue
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_errorqueue
operator|=
name|copyqueue
argument_list|(
name|e
operator|->
name|e_errorqueue
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_flags
operator|=
name|e
operator|->
name|e_flags
operator|&
operator|~
operator|(
name|EF_INQUEUE
operator||
name|EF_CLRQUEUE
operator||
name|EF_FATALERRS
operator|)
expr_stmt|;
name|setsender
argument_list|(
name|owner
argument_list|,
name|ee
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendall(split): QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|ee
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|ee
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_xfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_lockfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_df
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
name|ee
operator|->
name|e_sibling
operator|=
name|splitenv
expr_stmt|;
name|splitenv
operator|=
name|ee
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
if|if
condition|(
name|q
operator|->
name|q_owner
operator|==
name|owner
condition|)
name|q
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ee
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
if|if
condition|(
name|q
operator|->
name|q_owner
operator|!=
name|owner
condition|)
name|q
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_df
operator|!=
name|NULL
operator|&&
name|mode
operator|!=
name|SM_VERIFY
condition|)
block|{
name|ee
operator|->
name|e_dfp
operator|=
name|NULL
expr_stmt|;
name|ee
operator|->
name|e_df
operator|=
name|queuename
argument_list|(
name|ee
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
name|ee
operator|->
name|e_df
operator|=
name|newstr
argument_list|(
name|ee
operator|->
name|e_df
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|e
operator|->
name|e_df
argument_list|,
name|ee
operator|->
name|e_df
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"sendall: link(%s, %s)"
argument_list|,
name|e
operator|->
name|e_df
argument_list|,
name|ee
operator|->
name|e_df
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|!=
name|SM_VERIFY
condition|)
name|openxscript
argument_list|(
name|ee
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
if|if
condition|(
name|LogLevel
operator|>
literal|4
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: clone %s"
argument_list|,
name|ee
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|owner
operator|!=
name|NULL
condition|)
block|{
name|setsender
argument_list|(
name|owner
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sendall(owner): QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
operator|&
name|e
operator|->
name|e_from
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_from
operator|.
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
name|e
operator|->
name|e_errormode
operator|=
name|EM_MAIL
expr_stmt|;
block|}
if|if
condition|(
name|splitenv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|13
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nsendall: Split queue; remaining queue:\n"
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|e
operator|->
name|e_sendqueue
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ee
operator|=
name|splitenv
init|;
name|ee
operator|!=
name|NULL
condition|;
name|ee
operator|=
name|ee
operator|->
name|e_sibling
control|)
block|{
name|CurEnv
operator|=
name|ee
expr_stmt|;
name|sendenvelope
argument_list|(
name|ee
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|CurEnv
operator|=
name|e
expr_stmt|;
block|}
name|sendenvelope
argument_list|(
name|e
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|splitenv
operator|!=
name|NULL
condition|;
name|splitenv
operator|=
name|splitenv
operator|->
name|e_sibling
control|)
name|dropenvelope
argument_list|(
name|splitenv
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|sendenvelope
argument_list|(
name|e
argument_list|,
name|mode
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|mode
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
name|bool
name|oldverbose
init|=
name|Verbose
decl_stmt|;
comment|/* 	**  Run through the list and send everything. 	** 	**	Set EF_GLOBALERRS so that error messages during delivery 	**	result in returned mail. 	*/
name|e
operator|->
name|e_nsent
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|e_flags
operator||=
name|EF_GLOBALERRS
expr_stmt|;
for|for
control|(
name|q
operator|=
name|e
operator|->
name|e_sendqueue
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|mode
operator|==
name|SM_VERIFY
condition|)
block|{
name|e
operator|->
name|e_to
operator|=
name|q
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"deliverable: mailer %s, host %s, user %s"
argument_list|,
name|q
operator|->
name|q_mailer
operator|->
name|m_name
argument_list|,
name|q
operator|->
name|q_host
argument_list|,
name|q
operator|->
name|q_user
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
argument_list|,
name|q
operator|->
name|q_flags
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|QUEUE
comment|/* 			**  Checkpoint the send list every few addresses 			*/
if|if
condition|(
name|e
operator|->
name|e_nsent
operator|>=
name|CheckpointInterval
condition|)
block|{
name|queueup
argument_list|(
name|e
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_nsent
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* QUEUE */
operator|(
name|void
operator|)
name|deliver
argument_list|(
name|e
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|Verbose
operator|=
name|oldverbose
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SM_FORK
condition|)
name|finis
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DOFORK -- do a fork, retrying a couple of times on failure. ** **	This MUST be a macro, since after a vfork we are running **	two processes on the same stack!!! ** **	Parameters: **		none. ** **	Returns: **		From a macro???  You've got to be kidding! ** **	Side Effects: **		Modifies the ==> LOCAL<== variable 'pid', leaving: **			pid of child in parent, zero in child. **			-1 on unrecoverable error. ** **	Notes: **		I'm awfully sorry this looks so awful.  That's **		vfork for you..... */
end_comment

begin_define
define|#
directive|define
name|NFORKTRIES
value|5
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|FORK
end_ifndef

begin_define
define|#
directive|define
name|FORK
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOFORK
parameter_list|(
name|fORKfN
parameter_list|)
define|\
value|{\ 	register int i;\ \ 	for (i = NFORKTRIES; --i>= 0; )\ 	{\ 		pid = fORKfN();\ 		if (pid>= 0)\ 			break;\ 		if (i> 0)\ 			sleep((unsigned) NFORKTRIES - i);\ 	}\ }
end_define

begin_escape
end_escape

begin_comment
comment|/* **  DOFORK -- simple fork interface to DOFORK. ** **	Parameters: **		none. ** **	Returns: **		pid of child in parent. **		zero in child. **		-1 on error. ** **	Side Effects: **		returns twice, once in parent and once in child. */
end_comment

begin_macro
name|dofork
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|pid
decl_stmt|;
name|DOFORK
argument_list|(
name|fork
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  DELIVER -- Deliver a message to a list of addresses. ** **	This routine delivers to everyone on the same host as the **	user on the head of the list.  It is clever about mailers **	that don't handle multiple users.  It is NOT guaranteed **	that it will deliver to all these addresses however -- so **	deliver should be called once for each address on the **	list. ** **	Parameters: **		e -- the envelope to deliver. **		firstto -- head of the address list to deliver to. ** **	Returns: **		zero -- successfully delivered. **		else -- some failure, see ExitStat for more info. ** **	Side Effects: **		The standard input is passed off to someone. */
end_comment

begin_expr_stmt
name|deliver
argument_list|(
name|e
argument_list|,
name|firstto
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|firstto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|host
decl_stmt|;
comment|/* host being sent to */
name|char
modifier|*
name|user
decl_stmt|;
comment|/* user being sent to */
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|mvp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
comment|/* mailer for this recipient */
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|register
name|ADDRESS
modifier|*
name|to
init|=
name|firstto
decl_stmt|;
name|bool
name|clever
init|=
name|FALSE
decl_stmt|;
comment|/* running user smtp to this mailer */
name|ADDRESS
modifier|*
name|tochain
init|=
name|NULL
decl_stmt|;
comment|/* chain of users in this mailer call */
name|int
name|rcode
decl_stmt|;
comment|/* response code */
name|char
modifier|*
name|firstsig
decl_stmt|;
comment|/* signature of firstto */
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|curhost
decl_stmt|;
name|int
name|mpvect
index|[
literal|2
index|]
decl_stmt|;
name|int
name|rpvect
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|pv
index|[
name|MAXPV
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|tobuf
index|[
name|TOBUFSIZE
index|]
decl_stmt|;
comment|/* text line of to people */
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|rpathbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
comment|/* translated return path */
specifier|extern
name|int
name|checkcompat
parameter_list|()
function_decl|;
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ForceMail
operator|&&
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QPSEUDO
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|NAMED_BIND
comment|/* unless interactive, try twice, over a minute */
if|if
condition|(
name|OpMode
operator|==
name|MD_DAEMON
operator|||
name|OpMode
operator|==
name|MD_SMTP
condition|)
block|{
name|_res
operator|.
name|retrans
operator|=
literal|30
expr_stmt|;
name|_res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|=
name|to
operator|->
name|q_mailer
expr_stmt|;
name|host
operator|=
name|to
operator|->
name|q_host
expr_stmt|;
name|CurEnv
operator|=
name|e
expr_stmt|;
comment|/* just in case */
name|e
operator|->
name|e_statmsg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n--deliver, mailer=%d, host=`%s', first user=`%s'\n"
argument_list|,
name|m
operator|->
name|m_mno
argument_list|,
name|host
argument_list|,
name|to
operator|->
name|q_user
argument_list|)
expr_stmt|;
comment|/* 	**  If this mailer is expensive, and if we don't want to make 	**  connections now, just mark these addresses and return. 	**	This is useful if we want to batch connections to 	**	reduce load.  This will cause the messages to be 	**	queued up, and a daemon will come along to send the 	**	messages later. 	**		This should be on a per-mailer basis. 	*/
if|if
condition|(
name|NoConnect
operator|&&
operator|!
name|bitset
argument_list|(
name|EF_QUEUERUN
argument_list|,
name|e
operator|->
name|e_flags
argument_list|)
operator|&&
name|bitnset
argument_list|(
name|M_EXPENSIVE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
operator|!
name|Verbose
condition|)
block|{
for|for
control|(
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
operator||
name|QQUEUEUP
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|to
operator|->
name|q_mailer
operator|!=
name|m
condition|)
continue|continue;
name|to
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
name|message
argument_list|(
literal|"queued"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogLevel
operator|>
literal|8
condition|)
name|logdelivery
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
literal|"queued"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	**  Do initial argv setup. 	**	Insert the mailer name.  Notice that $x expansion is 	**	NOT done on the mailer name.  Then, if the mailer has 	**	a picky -f flag, we insert it as appropriate.  This 	**	code does not check for 'pv' overflow; this places a 	**	manifest lower limit of 4 for MAXPV. 	**		The from address rewrite is expected to make 	**		the address relative to the other end. 	*/
comment|/* rewrite from address, using rewriting rules */
name|rcode
operator|=
name|EX_OK
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rpathbuf
argument_list|,
name|remotename
argument_list|(
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|,
name|m
argument_list|,
name|RF_SENDERADDR
operator||
name|RF_CANONICAL
argument_list|,
operator|&
name|rcode
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
name|rpathbuf
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* translated return path */
name|define
argument_list|(
literal|'h'
argument_list|,
name|host
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* to host */
name|Errors
operator|=
literal|0
expr_stmt|;
name|pvp
operator|=
name|pv
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* insert -f or -r flag as appropriate */
if|if
condition|(
name|FromFlag
operator|&&
operator|(
name|bitnset
argument_list|(
name|M_FOPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|||
name|bitnset
argument_list|(
name|M_ROPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bitnset
argument_list|(
name|M_FOPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
operator|*
name|pvp
operator|++
operator|=
literal|"-f"
expr_stmt|;
else|else
operator|*
name|pvp
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|rpathbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Append the other fixed parts of the argv.  These run 	**  up to the first entry containing "$u".  There can only 	**  be one of these, and there are only a few more slots 	**  in the pv after it. 	*/
for|for
control|(
name|mvp
operator|=
name|m
operator|->
name|m_argv
init|;
operator|(
name|p
operator|=
operator|*
operator|++
name|mvp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
comment|/* can't use strchr here because of sign extension problems */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|&
literal|0377
operator|)
operator|==
name|MACROEXPAND
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'u'
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
break|break;
comment|/* this entry is safe -- go ahead and process it */
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
operator|-
literal|3
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"554 Too many parameters to %s before $u"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	**  If we have no substitution for the user name in the argument 	**  list, we know that we must supply the names otherwise -- and 	**  SMTP is the answer!! 	*/
if|if
condition|(
operator|*
name|mvp
operator|==
name|NULL
condition|)
block|{
comment|/* running SMTP */
ifdef|#
directive|ifdef
name|SMTP
name|clever
operator|=
name|TRUE
expr_stmt|;
operator|*
name|pvp
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* SMTP */
comment|/* oops!  we don't implement SMTP */
name|syserr
argument_list|(
literal|"554 SMTP style mailer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
endif|#
directive|endif
comment|/* SMTP */
block|}
comment|/* 	**  At this point *mvp points to the argument with $u.  We 	**  run through our address list and append all the addresses 	**  we can.  If we run out of space, do not fret!  We can 	**  always send another copy later. 	*/
name|tobuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|tobuf
expr_stmt|;
name|ctladdr
operator|=
name|NULL
expr_stmt|;
name|firstsig
operator|=
name|hostsignature
argument_list|(
name|firstto
operator|->
name|q_mailer
argument_list|,
name|firstto
operator|->
name|q_host
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_next
control|)
block|{
comment|/* avoid sending multiple recipients to dumb mailers */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|bitnset
argument_list|(
name|M_MUSER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
break|break;
comment|/* if already sent or not for this host, don't send */
if|if
condition|(
name|bitset
argument_list|(
name|QDONTSEND
operator||
name|QBADADDR
operator||
name|QQUEUEUP
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
operator|||
name|to
operator|->
name|q_mailer
operator|!=
name|firstto
operator|->
name|q_mailer
operator|||
name|strcmp
argument_list|(
name|hostsignature
argument_list|(
name|to
operator|->
name|q_mailer
argument_list|,
name|to
operator|->
name|q_host
argument_list|,
name|e
argument_list|)
argument_list|,
name|firstsig
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* avoid overflowing tobuf */
if|if
condition|(
sizeof|sizeof
name|tobuf
operator|<
operator|(
name|strlen
argument_list|(
name|to
operator|->
name|q_paddr
argument_list|)
operator|+
name|strlen
argument_list|(
name|tobuf
argument_list|)
operator|+
literal|2
operator|)
condition|)
break|break;
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nsend to "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|to
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* compute effective uid/gid when sending */
if|if
condition|(
name|to
operator|->
name|q_mailer
operator|==
name|ProgMailer
condition|)
name|ctladdr
operator|=
name|getctladdr
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|user
operator|=
name|to
operator|->
name|q_user
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|10
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"deliver: QDONTSEND "
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|to
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|to
operator|->
name|q_flags
operator||=
name|QDONTSEND
expr_stmt|;
comment|/* 		**  Check to see that these people are allowed to 		**  talk to each other. 		*/
if|if
condition|(
name|m
operator|->
name|m_maxsize
operator|!=
literal|0
operator|&&
name|e
operator|->
name|e_msgsize
operator|>
name|m
operator|->
name|m_maxsize
condition|)
block|{
name|NoReturn
operator|=
name|TRUE
expr_stmt|;
name|usrerr
argument_list|(
literal|"552 Message is too large; %ld bytes max"
argument_list|,
name|m
operator|->
name|m_maxsize
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rcode
operator|=
name|checkcompat
argument_list|(
name|to
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  Strip quote bits from names if the mailer is dumb 		**	about them. 		*/
if|if
condition|(
name|bitnset
argument_list|(
name|M_STRIPQ
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|stripquotes
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
comment|/* hack attack -- delivermail compatibility */
if|if
condition|(
name|m
operator|==
name|ProgMailer
operator|&&
operator|*
name|user
operator|==
literal|'|'
condition|)
name|user
operator|++
expr_stmt|;
comment|/* 		**  If an error message has already been given, don't 		**	bother to send to this address. 		** 		**>>>>>>>>>> This clause assumes that the local mailer 		**>> NOTE>> cannot do any further aliasing; that 		**>>>>>>>>>> function is subsumed by sendmail. 		*/
if|if
condition|(
name|bitset
argument_list|(
name|QBADADDR
operator||
name|QQUEUEUP
argument_list|,
name|to
operator|->
name|q_flags
argument_list|)
condition|)
continue|continue;
comment|/* save statistics.... */
name|markstats
argument_list|(
name|e
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* 		**  See if this user name is "special". 		**	If the user name has a slash in it, assume that this 		**	is a file -- send it off without further ado.  Note 		**	that this type of addresses is not processed along 		**	with the others, so we fudge on the To person. 		*/
if|if
condition|(
name|m
operator|==
name|FileMailer
condition|)
block|{
name|rcode
operator|=
name|mailfile
argument_list|(
name|user
argument_list|,
name|getctladdr
argument_list|(
name|to
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
name|to
operator|->
name|q_flags
operator||=
name|QSENT
expr_stmt|;
continue|continue;
block|}
comment|/* 		**  Address is verified -- add this user to mailer 		**  argv, and add it to the print list of recipients. 		*/
comment|/* link together the chain of recipients */
name|to
operator|->
name|q_tchain
operator|=
name|tochain
expr_stmt|;
name|tochain
operator|=
name|to
expr_stmt|;
comment|/* create list of users for error messages */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tobuf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tobuf
argument_list|,
name|to
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
name|define
argument_list|(
literal|'u'
argument_list|,
name|user
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* to user */
name|define
argument_list|(
literal|'z'
argument_list|,
name|to
operator|->
name|q_home
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* user's home */
comment|/* 		**  Expand out this user into argument list. 		*/
if|if
condition|(
operator|!
name|clever
condition|)
block|{
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
operator|-
literal|2
index|]
condition|)
block|{
comment|/* allow some space for trailing parms */
break|break;
block|}
block|}
block|}
comment|/* see if any addresses still exist */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|define
argument_list|(
literal|'g'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* print out messages as full list */
name|e
operator|->
name|e_to
operator|=
name|tobuf
operator|+
literal|1
expr_stmt|;
comment|/* 	**  Fill out any parameters after the $u parameter. 	*/
while|while
condition|(
operator|!
name|clever
operator|&&
operator|*
operator|++
name|mvp
operator|!=
name|NULL
condition|)
block|{
name|expand
argument_list|(
operator|*
name|mvp
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|newstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
index|]
condition|)
name|syserr
argument_list|(
literal|"554 deliver: pv overflow after $u for %s"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|*
name|pvp
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* 	**  Call the mailer. 	**	The argument vector gets built, pipes 	**	are created as necessary, and we fork& exec as 	**	appropriate. 	**	If we are running SMTP, we just need to clean up. 	*/
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|&&
name|m
operator|!=
name|ProgMailer
condition|)
name|ctladdr
operator|=
operator|&
name|e
operator|->
name|e_from
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"openmailer:"
argument_list|)
expr_stmt|;
name|printav
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|CurHostName
operator|=
name|m
operator|->
name|m_mailer
expr_stmt|;
comment|/* 	**  Deal with the special case of mail handled through an IPC 	**  connection. 	**	In this case we don't actually fork.  We must be 	**	running SMTP for this to work.  We will return a 	**	zero pid to indicate that we are running IPC. 	**  We also handle a debug version that just talks to stdin/out. 	*/
name|curhost
operator|=
name|NULL
expr_stmt|;
comment|/* check for Local Person Communication -- not for mortals!!! */
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[LPC]"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mci
operator|=
operator|(
name|MCI
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|mci
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mci
argument_list|,
sizeof|sizeof
expr|*
name|mci
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|stdin
expr_stmt|;
name|mci
operator|->
name|mci_out
operator|=
name|stdout
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|clever
condition|?
name|MCIS_OPENING
else|:
name|MCIS_OPEN
expr_stmt|;
name|mci
operator|->
name|mci_mailer
operator|=
name|m
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[IPC]"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
literal|"[TCP]"
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DAEMON
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_short
name|port
decl_stmt|;
name|CurHostName
operator|=
name|pv
index|[
literal|1
index|]
expr_stmt|;
name|curhost
operator|=
name|hostsignature
argument_list|(
name|m
argument_list|,
name|pv
index|[
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|curhost
operator|==
name|NULL
operator|||
name|curhost
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syserr
argument_list|(
literal|"null signature"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|if
condition|(
operator|!
name|clever
condition|)
block|{
name|syserr
argument_list|(
literal|"554 non-clever IPC"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
if|if
condition|(
name|pv
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
name|port
operator|=
name|atoi
argument_list|(
name|pv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
literal|0
expr_stmt|;
name|tryhost
label|:
name|mci
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|curhost
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|mci
operator|=
name|NULL
expr_stmt|;
comment|/* pull the next host from the signature */
name|p
operator|=
name|strchr
argument_list|(
name|curhost
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
operator|&
name|curhost
index|[
name|strlen
argument_list|(
name|curhost
argument_list|)
index|]
expr_stmt|;
name|strncpy
argument_list|(
name|hostbuf
argument_list|,
name|curhost
argument_list|,
name|p
operator|-
name|curhost
argument_list|)
expr_stmt|;
name|hostbuf
index|[
name|p
operator|-
name|curhost
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|p
operator|++
expr_stmt|;
name|curhost
operator|=
name|p
expr_stmt|;
comment|/* see if we already know that this host is fried */
name|CurHostName
operator|=
name|hostbuf
expr_stmt|;
name|mci
operator|=
name|mci_get
argument_list|(
name|hostbuf
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"openmailer: "
argument_list|)
expr_stmt|;
name|mci_dump
argument_list|(
name|mci
argument_list|)
expr_stmt|;
block|}
name|CurHostName
operator|=
name|mci
operator|->
name|mci_host
expr_stmt|;
break|break;
block|}
name|mci
operator|->
name|mci_mailer
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_exitstat
operator|!=
name|EX_OK
condition|)
continue|continue;
comment|/* try the connection */
name|setproctitle
argument_list|(
literal|"%s %s: %s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|hostbuf
argument_list|,
literal|"user open"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"Connecting to %s (%s)..."
argument_list|,
name|hostbuf
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|i
operator|=
name|makeconnection
argument_list|(
name|hostbuf
argument_list|,
name|port
argument_list|,
name|mci
argument_list|,
name|bitnset
argument_list|(
name|M_SECURE_PORT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_exitstat
operator|=
name|i
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
name|mci
operator|->
name|mci_herrno
operator|=
name|h_errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
name|EX_OK
condition|)
block|{
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_OPENING
expr_stmt|;
name|mci_cache
argument_list|(
name|mci
argument_list|)
expr_stmt|;
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|"%05d == CONNECT %s\n"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|hostbuf
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"openmailer: makeconnection => stat=%d, errno=%d\n"
argument_list|,
name|i
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* enter status of this host */
name|setstat
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|mci
operator|->
name|mci_pid
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* no DAEMON */
name|syserr
argument_list|(
literal|"554 openmailer: no IPC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* DAEMON */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|XDEBUG
name|char
name|wbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* make absolutely certain 0, 1, and 2 are in use */
name|sprintf
argument_list|(
name|wbuf
argument_list|,
literal|"%s... openmailer(%s)"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|checkfd012
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TrafficLogFile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|"%05d === EXEC"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|pv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|TrafficLogFile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* create a pipe to shove the mail through */
if|if
condition|(
name|pipe
argument_list|(
name|mpvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): pipe (to mailer)"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
comment|/* if this mailer speaks smtp, create a return pipe */
if|if
condition|(
name|clever
operator|&&
name|pipe
argument_list|(
name|rpvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): pipe (from mailer)"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
comment|/* 		**  Actually fork the mailer process. 		**	DOFORK is clever about retrying. 		** 		**	Dispose of SIGCHLD signal catchers that may be laying 		**	around so that endmail will get it. 		*/
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
comment|/* for debugging */
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGCHLD
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGCHLD */
name|DOFORK
argument_list|(
name|FORK
argument_list|)
expr_stmt|;
comment|/* pid is set by DOFORK */
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
comment|/* failure */
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot fork"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|clever
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"openmailer: NULL\n"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_OSERR
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|saveerrno
decl_stmt|;
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|env
index|[
name|MAXUSERENVIRON
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|extern
name|int
name|DtableSize
decl_stmt|;
comment|/* child -- set up input& exec mailer */
comment|/* make diagnostic output be standard output */
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
comment|/* close any other cached connections */
name|mci_flush
argument_list|(
name|FALSE
argument_list|,
name|mci
argument_list|)
expr_stmt|;
comment|/* move into some "safe" directory */
if|if
condition|(
name|m
operator|->
name|m_execdir
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
for|for
control|(
name|p
operator|=
name|m
operator|->
name|m_execdir
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
operator|-
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|20
argument_list|)
condition|)
name|printf
argument_list|(
literal|"openmailer: trydir %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|chdir
argument_list|(
name|buf
argument_list|)
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* arrange to filter std& diag output of command */
if|if
condition|(
name|clever
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup pipe %d for stdout"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OpMode
operator|==
name|MD_SMTP
operator|||
name|HoldErrs
condition|)
block|{
comment|/* put mailer output in transcript */
if|if
condition|(
name|dup2
argument_list|(
name|fileno
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup xscript %d for stdout"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|fileno
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dup2
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|STDERR_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup stdout for stderr"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
comment|/* arrange to get standard input */
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s... openmailer(%s): cannot dup pipe %d for stdin"
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|m
operator|->
name|m_name
argument_list|,
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitnset
argument_list|(
name|M_RESTR
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|==
name|NULL
operator|||
name|ctladdr
operator|->
name|q_uid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|DefGid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|DefUser
argument_list|,
name|DefGid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|DefUid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|ctladdr
operator|->
name|q_ruser
condition|?
name|ctladdr
operator|->
name|q_ruser
else|:
name|ctladdr
operator|->
name|q_user
argument_list|,
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|ctladdr
operator|->
name|q_uid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* arrange for all the files to be closed */
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|DtableSize
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|fcntl
argument_list|(
name|i
argument_list|,
name|F_GETFD
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|i
argument_list|,
name|F_SETFD
argument_list|,
name|j
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set up the mailer environment */
name|i
operator|=
literal|0
expr_stmt|;
name|env
index|[
name|i
operator|++
index|]
operator|=
literal|"AGENT=sendmail"
expr_stmt|;
for|for
control|(
name|ep
operator|=
name|environ
init|;
operator|*
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|ep
argument_list|,
literal|"TZ="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|env
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ep
expr_stmt|;
block|}
name|env
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* try to execute the mailer */
name|execve
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
name|pv
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|saveerrno
operator|=
name|errno
expr_stmt|;
name|syserr
argument_list|(
literal|"Cannot exec %s"
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|LocalMailer
operator|||
name|transienterror
argument_list|(
name|saveerrno
argument_list|)
condition|)
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 		**  Set up return value. 		*/
name|mci
operator|=
operator|(
name|MCI
operator|*
operator|)
name|xalloc
argument_list|(
sizeof|sizeof
expr|*
name|mci
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mci
argument_list|,
sizeof|sizeof
expr|*
name|mci
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_mailer
operator|=
name|m
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|clever
condition|?
name|MCIS_OPENING
else|:
name|MCIS_OPEN
expr_stmt|;
name|mci
operator|->
name|mci_pid
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|mpvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_out
operator|=
name|fdopen
argument_list|(
name|mpvect
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clever
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rpvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|fdopen
argument_list|(
name|rpvect
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mci
operator|->
name|mci_flags
operator||=
name|MCIF_TEMP
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	**  If we are in SMTP opening state, send initial protocol. 	*/
if|if
condition|(
name|clever
operator|&&
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_CLOSED
condition|)
block|{
name|smtpinit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"openmailer: "
argument_list|)
expr_stmt|;
name|mci_dump
argument_list|(
name|mci
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mci
operator|->
name|mci_state
operator|!=
name|MCIS_OPEN
condition|)
block|{
comment|/* couldn't open the mailer */
name|rcode
operator|=
name|mci
operator|->
name|mci_exitstat
expr_stmt|;
name|errno
operator|=
name|mci
operator|->
name|mci_errno
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
name|h_errno
operator|=
name|mci
operator|->
name|mci_herrno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
comment|/* shouldn't happen */
name|syserr
argument_list|(
literal|"554 deliver: rcode=%d, mci_state=%d, sig=%s"
argument_list|,
name|rcode
argument_list|,
name|mci
operator|->
name|mci_state
argument_list|,
name|firstsig
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_SOFTWARE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rcode
operator|==
name|EX_TEMPFAIL
operator|&&
operator|*
name|curhost
operator|!=
literal|'\0'
condition|)
block|{
comment|/* try next MX site */
goto|goto
name|tryhost
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|clever
condition|)
block|{
comment|/* 		**  Format and send message. 		*/
name|putfromline
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|putline
argument_list|(
literal|"\n"
argument_list|,
name|mci
operator|->
name|mci_out
argument_list|,
name|m
argument_list|)
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|m
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* get the exit status */
name|rcode
operator|=
name|endmailer
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
else|else
ifdef|#
directive|ifdef
name|SMTP
block|{
comment|/* 		**  Send the MAIL FROM: protocol 		*/
name|rcode
operator|=
name|smtpmailfrom
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|tobuf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* send the recipient list */
name|tobuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
block|{
name|e
operator|->
name|e_to
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|smtprcpt
argument_list|(
name|to
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
operator|)
operator|!=
name|EX_OK
condition|)
block|{
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|t
operator|++
operator|=
literal|','
expr_stmt|;
for|for
control|(
name|p
operator|=
name|to
operator|->
name|q_paddr
init|;
operator|*
name|p
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
block|}
block|}
comment|/* now send the data */
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rcode
operator|=
name|EX_OK
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|MCIF_CACHED
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|smtprset
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|->
name|e_to
operator|=
name|tobuf
operator|+
literal|1
expr_stmt|;
name|rcode
operator|=
name|smtpdata
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* now close the connection */
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|MCIF_CACHED
argument_list|,
name|mci
operator|->
name|mci_flags
argument_list|)
condition|)
name|smtpquit
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
operator|&&
operator|*
name|curhost
operator|!=
literal|'\0'
condition|)
block|{
comment|/* try next MX site */
goto|goto
name|tryhost
goto|;
block|}
block|}
else|#
directive|else
comment|/* not SMTP */
block|{
name|syserr
argument_list|(
literal|"554 deliver: need SMTP compiled to use clever mailer"
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|EX_CONFIG
expr_stmt|;
goto|goto
name|give_up
goto|;
block|}
endif|#
directive|endif
comment|/* SMTP */
ifdef|#
directive|ifdef
name|NAMED_BIND
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
comment|/* arrange a return receipt if requested */
if|if
condition|(
name|e
operator|->
name|e_receiptto
operator|!=
name|NULL
operator|&&
name|bitnset
argument_list|(
name|M_LOCALMAILER
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|e
operator|->
name|e_flags
operator||=
name|EF_SENDRECEIPT
expr_stmt|;
comment|/* do we want to send back more info? */
block|}
comment|/* 	**  Do final status disposal. 	**	We check for something in tobuf for the SMTP case. 	**	If we got a temporary failure, arrange to queue the 	**		addressees. 	*/
name|give_up
label|:
if|if
condition|(
name|tobuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|giveresponse
argument_list|(
name|rcode
argument_list|,
name|m
argument_list|,
name|mci
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|to
operator|=
name|tochain
init|;
name|to
operator|!=
name|NULL
condition|;
name|to
operator|=
name|to
operator|->
name|q_tchain
control|)
block|{
if|if
condition|(
name|rcode
operator|!=
name|EX_OK
condition|)
name|markfailure
argument_list|(
name|e
argument_list|,
name|to
argument_list|,
name|rcode
argument_list|)
expr_stmt|;
else|else
block|{
name|to
operator|->
name|q_flags
operator||=
name|QSENT
expr_stmt|;
name|e
operator|->
name|e_nsent
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	**  Restore state and return. 	*/
name|errno
operator|=
literal|0
expr_stmt|;
name|define
argument_list|(
literal|'g'
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcode
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MARKFAILURE -- mark a failure on a specific address. ** **	Parameters: **		e -- the envelope we are sending. **		q -- the address to mark. **		rcode -- the code signifying the particular failure. ** **	Returns: **		none. ** **	Side Effects: **		marks the address (and possibly the envelope) with the **			failure so that an error will be returned or **			the message will be queued, as appropriate. */
end_comment

begin_expr_stmt
name|markfailure
argument_list|(
name|e
argument_list|,
name|q
argument_list|,
name|rcode
argument_list|)
specifier|register
name|ENVELOPE
operator|*
name|e
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rcode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
name|rcode
operator|==
name|EX_OK
condition|)
return|return;
elseif|else
if|if
condition|(
name|rcode
operator|==
name|EX_TEMPFAIL
condition|)
name|q
operator|->
name|q_flags
operator||=
name|QQUEUEUP
expr_stmt|;
elseif|else
if|if
condition|(
name|rcode
operator|!=
name|EX_IOERR
operator|&&
name|rcode
operator|!=
name|EX_OSERR
condition|)
name|q
operator|->
name|q_flags
operator||=
name|QBADADDR
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  ENDMAILER -- Wait for mailer to terminate. ** **	We should never get fatal errors (e.g., segmentation **	violation), so we report those specially.  For other **	errors, we choose a status message (into statmsg), **	and if it represents an error, we print it. ** **	Parameters: **		pid -- pid of mailer. **		e -- the current envelope. **		pv -- the parameter vector that invoked the mailer **			(for error messages). ** **	Returns: **		exit code of mailer. ** **	Side Effects: **		none. */
end_comment

begin_expr_stmt
name|endmailer
argument_list|(
name|mci
argument_list|,
name|e
argument_list|,
name|pv
argument_list|)
specifier|register
name|MCI
operator|*
name|mci
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|st
decl_stmt|;
comment|/* close any connections */
if|if
condition|(
name|mci
operator|->
name|mci_in
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|mci
operator|->
name|mci_in
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|,
literal|"mci_in"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mci
operator|->
name|mci_out
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|mci
operator|->
name|mci_out
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|,
literal|"mci_out"
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_in
operator|=
name|mci
operator|->
name|mci_out
operator|=
name|NULL
expr_stmt|;
name|mci
operator|->
name|mci_state
operator|=
name|MCIS_CLOSED
expr_stmt|;
comment|/* in the IPC case there is nothing to wait for */
if|if
condition|(
name|mci
operator|->
name|mci_pid
operator|==
literal|0
condition|)
return|return
operator|(
name|EX_OK
operator|)
return|;
comment|/* wait for the mailer process to die and collect status */
name|st
operator|=
name|waitfor
argument_list|(
name|mci
operator|->
name|mci_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
operator|-
literal|1
condition|)
block|{
name|syserr
argument_list|(
literal|"endmailer %s: wait"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_SOFTWARE
operator|)
return|;
block|}
comment|/* see if it died a horrid death */
if|if
condition|(
operator|(
name|st
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"mailer %s died with signal %o"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|,
name|st
argument_list|)
expr_stmt|;
comment|/* log the arguments */
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"Arguments:"
argument_list|)
expr_stmt|;
for|for
control|(
name|av
operator|=
name|pv
init|;
operator|*
name|av
operator|!=
name|NULL
condition|;
name|av
operator|++
control|)
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ExitStat
operator|=
name|EX_TEMPFAIL
expr_stmt|;
return|return
operator|(
name|EX_TEMPFAIL
operator|)
return|;
block|}
comment|/* normal death -- return status */
name|st
operator|=
operator|(
name|st
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
return|return
operator|(
name|st
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  GIVERESPONSE -- Interpret an error response from a mailer ** **	Parameters: **		stat -- the status code from the mailer (high byte **			only; core dumps must have been taken care of **			already). **		m -- the mailer info for this mailer. **		mci -- the mailer connection info -- can be NULL if the **			response is given before the connection is made. **		e -- the current envelope. ** **	Returns: **		none. ** **	Side Effects: **		Errors may be incremented. **		ExitStat may be set. */
end_comment

begin_macro
name|giveresponse
argument_list|(
argument|stat
argument_list|,
argument|m
argument_list|,
argument|mci
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|int
name|stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
specifier|const
name|char
modifier|*
name|statmsg
decl_stmt|;
specifier|extern
name|char
modifier|*
name|SysExMsg
index|[]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|N_SysEx
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Compute status message from code. 	*/
name|i
operator|=
name|stat
operator|-
name|EX__BASE
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
name|statmsg
operator|=
literal|"250 Sent"
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_statmsg
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s (%s)"
argument_list|,
name|statmsg
argument_list|,
name|e
operator|->
name|e_statmsg
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|N_SysEx
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"554 unknown mailer error %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|stat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|EX_TEMPFAIL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|SysExMsg
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
if|if
condition|(
name|h_errno
operator|==
name|TRY_AGAIN
condition|)
name|statmsg
operator|=
name|errstring
argument_list|(
name|h_errno
operator|+
name|E_DNSBASE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|statmsg
operator|=
name|errstring
argument_list|(
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|SMTP
specifier|extern
name|char
name|SmtpError
index|[]
decl_stmt|;
name|statmsg
operator|=
name|SmtpError
expr_stmt|;
else|#
directive|else
comment|/* SMTP */
name|statmsg
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* SMTP */
block|}
block|}
if|if
condition|(
name|statmsg
operator|!=
name|NULL
operator|&&
name|statmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
block|}
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NAMED_BIND
elseif|else
if|if
condition|(
name|stat
operator|==
name|EX_NOHOST
operator|&&
name|h_errno
operator|!=
literal|0
condition|)
block|{
name|statmsg
operator|=
name|errstring
argument_list|(
name|h_errno
operator|+
name|E_DNSBASE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s (%s)"
argument_list|,
name|SysExMsg
index|[
name|i
index|]
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|statmsg
operator|=
name|SysExMsg
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|statmsg
operator|++
operator|==
literal|':'
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: %s"
argument_list|,
name|statmsg
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
block|}
comment|/* 	**  Print the message as appropriate 	*/
if|if
condition|(
name|stat
operator|==
name|EX_OK
operator|||
name|stat
operator|==
name|EX_TEMPFAIL
condition|)
name|message
argument_list|(
operator|&
name|statmsg
index|[
literal|4
index|]
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|Errors
operator|++
expr_stmt|;
name|usrerr
argument_list|(
name|statmsg
argument_list|,
name|errstring
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Final cleanup. 	**	Log a record of the transaction.  Compute the new 	**	ExitStat -- if we already had an error, stick with 	**	that. 	*/
if|if
condition|(
name|LogLevel
operator|>
operator|(
operator|(
name|stat
operator|==
name|EX_TEMPFAIL
operator|)
condition|?
literal|8
else|:
operator|(
name|stat
operator|==
name|EX_OK
operator|)
condition|?
literal|7
else|:
literal|6
operator|)
condition|)
name|logdelivery
argument_list|(
name|m
argument_list|,
name|mci
argument_list|,
operator|&
name|statmsg
index|[
literal|4
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|EX_TEMPFAIL
condition|)
name|setstat
argument_list|(
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|EX_OK
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_message
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|e
operator|->
name|e_message
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_message
operator|=
name|newstr
argument_list|(
operator|&
name|statmsg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
name|h_errno
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  LOGDELIVERY -- log the delivery in the system log ** **	Parameters: **		m -- the mailer info.  Can be NULL for initial queue. **		mci -- the mailer connection info -- can be NULL if the **			log is occuring when no connection is active. **		stat -- the message to print for the status. **		e -- the current envelope. ** **	Returns: **		none ** **	Side Effects: **		none */
end_comment

begin_macro
name|logdelivery
argument_list|(
argument|m
argument_list|,
argument|mci
argument_list|,
argument|stat
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|LOG
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"delay=%s"
argument_list|,
name|pintvl
argument_list|(
name|curtime
argument_list|()
operator|-
name|e
operator|->
name|e_ctime
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", mailer="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mci
operator|!=
name|NULL
operator|&&
name|mci
operator|->
name|mci_host
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DAEMON
specifier|extern
name|SOCKADDR
name|CurHostAddr
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relay="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|mci
operator|->
name|mci_host
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DAEMON
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|anynet_ntoa
argument_list|(
operator|&
name|CurHostAddr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|macvalue
argument_list|(
literal|'h'
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", relay="
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: to=%s, %s, stat=%s"
argument_list|,
name|e
operator|->
name|e_id
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|buf
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTFROMLINE -- output a UNIX-style from line (or whatever) ** **	then passes the rest of the message through.  If we have **	managed to extract a date already, use that; otherwise, **	use the current date/time. ** **	One of the ugliest hacks seen by human eyes is contained herein: **	UUCP wants those stupid "remote from<host>" lines.  Why oh why **	does a well-meaning programmer such as myself have to deal with **	this kind of antique garbage???? ** **	Parameters: **		fp -- the file to output to. **		m -- the mailer describing this entry. ** **	Returns: **		none ** **	Side Effects: **		outputs some text to fp. */
end_comment

begin_expr_stmt
name|putfromline
argument_list|(
name|fp
argument_list|,
name|m
argument_list|,
name|e
argument_list|)
specifier|register
name|FILE
operator|*
name|fp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|template
init|=
literal|"\201l\n"
decl_stmt|;
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|extern
name|char
name|SentDate
index|[]
decl_stmt|;
if|if
condition|(
name|bitnset
argument_list|(
name|M_NHDR
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|UGLYUUCP
if|if
condition|(
name|bitnset
argument_list|(
name|M_UGLYUUCP
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|char
modifier|*
name|bang
decl_stmt|;
name|char
name|xbuf
index|[
name|MAXLINE
index|]
decl_stmt|;
name|expand
argument_list|(
literal|"\201g"
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|bang
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bang
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"554 No ! in UUCP! (%s)"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|bang
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"From %s  \201d remote from %s\n"
argument_list|,
name|bang
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|template
operator|=
name|xbuf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* UGLYUUCP */
name|expand
argument_list|(
name|template
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|putline
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTBODY -- put the body of a message. ** **	Parameters: **		fp -- file to output onto. **		m -- a mailer descriptor to control output format. **		e -- the envelope to put out. **		separator -- if non-NULL, a message separator that must **			not be permitted in the resulting message. ** **	Returns: **		none. ** **	Side Effects: **		The message is written onto fp. */
end_comment

begin_macro
name|putbody
argument_list|(
argument|fp
argument_list|,
argument|m
argument_list|,
argument|e
argument_list|,
argument|separator
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MAILER
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|separator
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
comment|/* 	**  Output the body of the message 	*/
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|e_df
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|e_dfp
operator|=
name|fopen
argument_list|(
name|e
operator|->
name|e_df
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
name|syserr
argument_list|(
literal|"putbody: Cannot open %s for %s from %s"
argument_list|,
name|e
operator|->
name|e_df
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
block|}
else|else
name|putline
argument_list|(
literal|"<<< No Message Collected>>>"
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|!=
name|NULL
condition|)
block|{
name|rewind
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|e
operator|->
name|e_dfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|bitnset
argument_list|(
name|M_ESCFROM
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"From "
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'>'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'-'
operator|&&
name|separator
operator|!=
name|NULL
condition|)
block|{
comment|/* possible separator */
name|int
name|sl
init|=
name|strlen
argument_list|(
name|separator
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|separator
argument_list|,
name|sl
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putline
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|e
operator|->
name|e_dfp
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"putbody: read error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
block|}
block|}
comment|/* some mailers want extra blank line at end of message */
if|if
condition|(
name|bitnset
argument_list|(
name|M_BLANKEND
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|putline
argument_list|(
literal|""
argument_list|,
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
name|errno
operator|!=
name|EPIPE
condition|)
block|{
name|syserr
argument_list|(
literal|"putbody: write error"
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_IOERR
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  MAILFILE -- Send a message to a file. ** **	If the file has the setuid/setgid bits set, but NO execute **	bits, sendmail will try to become the owner of that file **	rather than the real user.  Obviously, this only works if **	sendmail runs as root. ** **	This could be done as a subordinate mailer, except that it **	is used implicitly to save messages in ~/dead.letter.  We **	view this as being sufficiently important as to include it **	here.  For example, if the system is dying, we shouldn't have **	to create another process plus some pipes to save the message. ** **	Parameters: **		filename -- the name of the file to send to. **		ctladdr -- the controlling address header -- includes **			the userid/groupid to be when sending. ** **	Returns: **		The exit code associated with the operation. ** **	Side Effects: **		none. */
end_comment

begin_macro
name|mailfile
argument_list|(
argument|filename
argument_list|,
argument|ctladdr
argument_list|,
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|ctladdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|tTd
argument_list|(
literal|11
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"mailfile %s\n  ctladdr="
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|printaddr
argument_list|(
name|ctladdr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|e_xfp
operator|!=
name|NULL
condition|)
name|fflush
argument_list|(
name|e
operator|->
name|e_xfp
argument_list|)
expr_stmt|;
comment|/* 	**  Fork so we can change permissions here. 	**	Note that we MUST use fork, not vfork, because of 	**	the complications of calling subroutines, etc. 	*/
name|DOFORK
argument_list|(
name|fork
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
return|return
operator|(
name|EX_OSERR
operator|)
return|;
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child -- actually write to file */
name|struct
name|stat
name|stb
decl_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsignal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|OldUmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|stb
argument_list|)
operator|<
literal|0
condition|)
name|stb
operator|.
name|st_mode
operator|=
name|FileMode
expr_stmt|;
name|mode
operator|=
name|stb
operator|.
name|st_mode
expr_stmt|;
comment|/* limit the errors to those actually caused in the child */
name|errno
operator|=
literal|0
expr_stmt|;
name|ExitStat
operator|=
name|EX_OK
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
literal|0111
argument_list|,
name|stb
operator|.
name|st_mode
argument_list|)
condition|)
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctladdr
operator|==
name|NULL
condition|)
name|ctladdr
operator|=
operator|&
name|e
operator|->
name|e_from
expr_stmt|;
else|else
block|{
comment|/* ignore setuid and setgid bits */
name|mode
operator|&=
operator|~
operator|(
name|S_ISGID
operator||
name|S_ISUID
operator|)
expr_stmt|;
block|}
comment|/* we have to open the dfile BEFORE setuid */
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
operator|&&
name|e
operator|->
name|e_df
operator|!=
name|NULL
condition|)
block|{
name|e
operator|->
name|e_dfp
operator|=
name|fopen
argument_list|(
name|e
operator|->
name|e_df
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_dfp
operator|==
name|NULL
condition|)
block|{
name|syserr
argument_list|(
literal|"mailfile: Cannot open %s for %s from %s"
argument_list|,
name|e
operator|->
name|e_df
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|e
operator|->
name|e_from
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_ISGID
argument_list|,
name|mode
argument_list|)
operator|||
name|setgid
argument_list|(
name|stb
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|->
name|q_uid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|DefGid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|DefUser
argument_list|,
name|DefGid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|ctladdr
operator|->
name|q_ruser
condition|?
name|ctladdr
operator|->
name|q_ruser
else|:
name|ctladdr
operator|->
name|q_user
argument_list|,
name|ctladdr
operator|->
name|q_gid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|S_ISUID
argument_list|,
name|mode
argument_list|)
operator|||
name|setuid
argument_list|(
name|stb
operator|.
name|st_uid
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ctladdr
operator|->
name|q_uid
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|DefUid
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|ctladdr
operator|->
name|q_uid
argument_list|)
expr_stmt|;
block|}
name|FileName
operator|=
name|filename
expr_stmt|;
name|LineNumber
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|dfopen
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_APPEND
argument_list|,
name|FileMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|message
argument_list|(
literal|"554 cannot open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_CANTCREAT
argument_list|)
expr_stmt|;
block|}
name|putfromline
argument_list|(
name|f
argument_list|,
name|FileMailer
argument_list|,
name|e
argument_list|)
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_puthdr
call|)
argument_list|(
name|f
argument_list|,
name|FileMailer
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|putline
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|,
name|FileMailer
argument_list|)
expr_stmt|;
call|(
modifier|*
name|e
operator|->
name|e_putbody
call|)
argument_list|(
name|f
argument_list|,
name|FileMailer
argument_list|,
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|putline
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|,
name|FileMailer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|message
argument_list|(
literal|"451 I/O error"
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|EX_IOERR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|xfclose
argument_list|(
name|f
argument_list|,
literal|"mailfile"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* reset ISUID& ISGID bits for paranoid systems */
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|filename
argument_list|,
operator|(
name|int
operator|)
name|stb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ExitStat
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
else|else
block|{
comment|/* parent -- wait for exit status */
name|int
name|st
decl_stmt|;
name|st
operator|=
name|waitfor
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EX_UNAVAILABLE
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|st
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
return|;
comment|/*NOTREACHED*/
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  HOSTSIGNATURE -- return the "signature" for a host. ** **	The signature describes how we are going to send this -- it **	can be just the hostname (for non-Internet hosts) or can be **	an ordered list of MX hosts. ** **	Parameters: **		m -- the mailer describing this host. **		host -- the host name. **		e -- the current envelope. ** **	Returns: **		The signature for this host. ** **	Side Effects: **		Can tweak the symbol table. */
end_comment

begin_function
name|char
modifier|*
name|hostsignature
parameter_list|(
name|m
parameter_list|,
name|host
parameter_list|,
name|e
parameter_list|)
specifier|register
name|MAILER
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|ENVELOPE
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
name|int
name|nmx
decl_stmt|;
specifier|auto
name|int
name|rcode
decl_stmt|;
name|char
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|int
name|oldoptions
decl_stmt|;
name|char
modifier|*
name|mxhosts
index|[
name|MAXMXHOSTS
operator|+
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	**  Check to see if this uses IPC -- if not, it can't have MX records. 	*/
name|p
operator|=
name|m
operator|->
name|m_mailer
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"[IPC]"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"[TCP]"
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* just an ordinary mailer */
return|return
name|host
return|;
block|}
comment|/* 	**  If it is a numeric address, just return it. 	*/
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
return|return
name|host
return|;
comment|/* 	**  Look it up in the symbol table. 	*/
name|s
operator|=
name|stab
argument_list|(
name|host
argument_list|,
name|ST_HOSTSIG
argument_list|,
name|ST_ENTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|!=
name|NULL
condition|)
return|return
name|s
operator|->
name|s_hostsig
return|;
comment|/* 	**  Not already there -- create a signature. 	*/
ifdef|#
directive|ifdef
name|NAMED_BIND
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
block|{
name|oldoptions
operator|=
name|_res
operator|.
name|options
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator|)
expr_stmt|;
comment|/* XXX */
block|}
for|for
control|(
name|hp
operator|=
name|host
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|endp
control|)
block|{
name|endp
operator|=
name|strchr
argument_list|(
name|hp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
name|nmx
operator|=
name|getmxrr
argument_list|(
name|hp
argument_list|,
name|mxhosts
argument_list|,
name|TRUE
argument_list|,
operator|&
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmx
operator|<=
literal|0
condition|)
block|{
specifier|register
name|MCI
modifier|*
name|mci
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
comment|/* update the connection info for this host */
name|mci
operator|=
name|mci_get
argument_list|(
name|hp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mci
operator|->
name|mci_exitstat
operator|=
name|rcode
expr_stmt|;
name|mci
operator|->
name|mci_errno
operator|=
name|errno
expr_stmt|;
ifdef|#
directive|ifdef
name|NAMED_BIND
name|mci
operator|->
name|mci_herrno
operator|=
name|h_errno
expr_stmt|;
endif|#
directive|endif
comment|/* and return the original host name as the signature */
name|nmx
operator|=
literal|1
expr_stmt|;
name|mxhosts
index|[
literal|0
index|]
operator|=
name|hp
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|mxhosts
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|s
operator|->
name|s_hostsig
argument_list|)
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|xalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|s_hostsig
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|s_hostsig
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
operator|->
name|s_hostsig
argument_list|)
expr_stmt|;
name|s
operator|->
name|s_hostsig
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
else|else
name|s
operator|->
name|s_hostsig
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|mxhosts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|endp
operator|!=
name|NULL
condition|)
operator|*
name|endp
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
name|makelower
argument_list|(
name|s
operator|->
name|s_hostsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|ConfigLevel
operator|<
literal|2
condition|)
name|_res
operator|.
name|options
operator|=
name|oldoptions
expr_stmt|;
else|#
directive|else
comment|/* not using BIND -- the signature is just the host name */
name|s
operator|->
name|s_hostsig
operator|=
name|host
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tTd
argument_list|(
literal|17
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"hostsignature(%s) = %s\n"
argument_list|,
name|host
argument_list|,
name|s
operator|->
name|s_hostsig
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|s_hostsig
return|;
block|}
end_function

end_unit

