begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"postbox.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
endif|LOG
end_endif

begin_decl_stmt
specifier|static
name|char
name|SccsId
index|[]
init|=
literal|"@(#)deliver.c	3.5	%G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  DELIVER -- Deliver a message to a particular address. ** **	Algorithm: **		Compute receiving network (i.e., mailer), host,& user. **		If local, see if this is really a program name. **		Build argument for the mailer. **		Create pipe through edit fcn if appropriate. **		Fork. **			Child: call mailer **		Parent: call editfcn if specified. **		Wait for mailer to finish. **		Interpret exit status. ** **	Parameters: **		to -- the address to deliver the message to. **		editfcn -- if non-NULL, we want to call this function **			to output the letter (instead of just out- **			putting it raw). ** **	Returns: **		zero -- successfully delivered. **		else -- some failure, see ExitStat for more info. ** **	Side Effects: **		The standard input is passed off to someone. ** **	WARNING: **		The standard input is shared amongst all children, **		including the file pointer.  It is critical that the **		parent waits for the child to finish before forking **		another child. ** **	Called By: **		main **		savemail ** **	Files: **		standard input -- must be opened to the message to **			deliver. */
end_comment

begin_macro
name|deliver
argument_list|(
argument|to
argument_list|,
argument|editfcn
argument_list|)
end_macro

begin_decl_stmt
name|ADDRESS
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|editfcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|buildargv
parameter_list|()
function_decl|;
specifier|auto
name|int
name|st
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|pvect
index|[
literal|2
index|]
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|FILE
modifier|*
name|mfile
decl_stmt|;
extern|extern putmessage(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_extern
extern|extern pipesig(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|bool
name|checkcompat
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* 	**  Compute receiving mailer, host, and to addreses. 	**	Do some initialization first.  To is the to address 	**	for error messages. 	*/
end_comment

begin_expr_stmt
name|To
operator|=
name|to
operator|->
name|q_paddr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|=
name|Mailer
index|[
name|to
operator|->
name|q_mailer
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|user
operator|=
name|to
operator|->
name|q_user
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|host
operator|=
name|to
operator|->
name|q_host
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Errors
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|errno
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_if
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"deliver(%s [%d, `%s', `%s'])\n"
argument_list|,
name|To
argument_list|,
name|m
argument_list|,
name|host
argument_list|,
name|user
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_comment
comment|/* 	**  Check to see that these people are allowed to talk to each other. 	*/
end_comment

begin_if
if|if
condition|(
operator|!
name|checkcompat
argument_list|(
name|to
argument_list|)
condition|)
return|return
operator|(
name|giveresponse
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
operator|)
return|;
end_if

begin_comment
comment|/* 	**  Remove quote bits from user/host. 	*/
end_comment

begin_for
for|for
control|(
name|p
operator|=
name|user
init|;
operator|(
operator|*
name|p
operator|++
operator|&=
literal|0177
operator|)
operator|!=
literal|'\0'
condition|;
control|)
continue|continue;
end_for

begin_if
if|if
condition|(
name|host
operator|!=
name|NULL
condition|)
for|for
control|(
name|p
operator|=
name|host
init|;
operator|(
operator|*
name|p
operator|++
operator|&=
literal|0177
operator|)
operator|!=
literal|'\0'
condition|;
control|)
continue|continue;
end_if

begin_comment
comment|/* 	**  Strip quote bits from names if the mailer wants it. 	*/
end_comment

begin_if
if|if
condition|(
name|bitset
argument_list|(
name|M_STRIPQ
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
block|{
name|stripquotes
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|stripquotes
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* 	**  See if this user name is "special". 	**	If the user is a program, diddle with the mailer spec. 	**	If the user name has a slash in it, assume that this 	**		is a file -- send it off without further ado. 	**		Note that this means that editfcn's will not 	**		be applied to the message. 	*/
end_comment

begin_if
if|if
condition|(
name|m
operator|==
name|Mailer
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|user
operator|==
literal|'|'
condition|)
block|{
name|user
operator|++
expr_stmt|;
name|m
operator|=
name|Mailer
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
argument_list|(
name|user
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|mailfile
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|giveresponse
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
block|}
end_if

begin_comment
comment|/* 	**  See if the user exists. 	**	Strictly, this is only needed to print a pretty 	**	error message. 	** 	**>>>>>>>>>> This clause assumes that the local mailer 	**>> NOTE>> cannot do any further aliasing; that 	**>>>>>>>>>> function is subsumed by postbox. 	*/
end_comment

begin_if
if|if
condition|(
name|m
operator|==
name|Mailer
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|getpwnam
argument_list|(
name|user
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|giveresponse
argument_list|(
name|EX_NOUSER
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_NOUSER
operator|)
return|;
block|}
block|}
end_if

begin_comment
comment|/* 	**  Call the mailer. 	**	The argument vector gets built, pipes 	**	are created as necessary, and we fork& exec as 	**	appropriate. 	*/
end_comment

begin_expr_stmt
name|pvp
operator|=
name|buildargv
argument_list|(
name|m
argument_list|,
name|host
argument_list|,
name|user
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
name|usrerr
argument_list|(
literal|"name too long"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|rewind
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* create a pipe to shove the mail through */
end_comment

begin_if
if|if
condition|(
name|pipe
argument_list|(
name|pvect
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_expr_stmt
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot fork"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* child -- set up input& exec mailer */
comment|/* make diagnostic output be standard output */
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"Cannot dup to zero!"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitset
argument_list|(
name|M_RESTR
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VFORK
comment|/* 		**  We have to be careful with vfork - we can't mung up the 		**  memory but we don't want the mailer to inherit any extra 		**  open files.  Chances are the mailer won't 		**  care about an extra file, but then again you never know. 		**  Actually, we would like to close(fileno(pwf)), but it's 		**  declared static so we can't.  But if we fclose(pwf), which 		**  is what endpwent does, it closes it in the parent too and 		**  the next getpwnam will be slower.  If you have a weird 		**  mailer that chokes on the extra file you should do the 		**  endpwent(). 		** 		**  Similar comments apply to log.  However, openlog is 		**  clever enough to set the FIOCLEX mode on the file, 		**  so it will be closed automatically on the exec. 		*/
name|endpwent
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
name|closelog
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|LOG
endif|#
directive|endif
endif|VFORK
name|execv
argument_list|(
name|m
operator|->
name|m_mailer
argument_list|,
name|pvp
argument_list|)
expr_stmt|;
comment|/* syserr fails because log is closed */
comment|/* syserr("Cannot exec %s", m->m_mailer); */
name|printf
argument_list|(
literal|"Cannot exec %s\n"
argument_list|,
name|m
operator|->
name|m_mailer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_UNAVAILABLE
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* write out message to mailer */
end_comment

begin_expr_stmt
name|close
argument_list|(
name|pvect
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipesig
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mfile
operator|=
name|fdopen
argument_list|(
name|pvect
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|editfcn
operator|==
name|NULL
condition|)
name|editfcn
operator|=
name|putmessage
expr_stmt|;
end_if

begin_expr_stmt
call|(
modifier|*
name|editfcn
call|)
argument_list|(
name|mfile
argument_list|,
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fclose
argument_list|(
name|mfile
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	**  Wait for child to die and report status. 	**	We should never get fatal errors (e.g., segmentation 	**	violation), so we report those specially.  For other 	**	errors, we choose a status message (into statmsg), 	**	and if it represents an error, we print it. 	*/
end_comment

begin_while
while|while
condition|(
operator|(
name|i
operator|=
name|wait
argument_list|(
operator|&
name|st
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|i
operator|!=
name|pid
condition|)
continue|continue;
end_while

begin_if
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|st
operator|&
literal|0377
operator|)
operator|!=
literal|0
condition|)
block|{
name|syserr
argument_list|(
literal|"%s: stat %o"
argument_list|,
name|pvp
index|[
literal|0
index|]
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|ExitStat
operator|=
name|EX_UNAVAILABLE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|i
operator|=
operator|(
name|st
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|giveresponse
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|,
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|i
operator|)
return|;
end_return

begin_escape
unit|}
end_escape

begin_comment
comment|/* **  GIVERESPONSE -- Interpret an error response from a mailer ** **	Parameters: **		stat -- the status code from the mailer (high byte **			only; core dumps must have been taken care of **			already). **		force -- if set, force an error message output, even **			if the mailer seems to like to print its own **			messages. **		m -- the mailer descriptor for this mailer. ** **	Returns: **		stat. ** **	Side Effects: **		Errors may be incremented. **		ExitStat may be set. ** **	Called By: **		deliver */
end_comment

begin_expr_stmt
unit|giveresponse
operator|(
name|stat
operator|,
name|force
operator|,
name|m
operator|)
name|int
name|stat
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|force
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|statmsg
decl_stmt|;
specifier|extern
name|char
modifier|*
name|SysExMsg
index|[]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|int
name|N_SysEx
decl_stmt|;
specifier|extern
name|long
name|MsgSize
decl_stmt|;
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
name|i
operator|=
name|stat
operator|-
name|EX__BASE
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|N_SysEx
condition|)
name|statmsg
operator|=
name|NULL
expr_stmt|;
else|else
name|statmsg
operator|=
name|SysExMsg
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
name|statmsg
operator|=
literal|"ok"
expr_stmt|;
else|else
block|{
name|Errors
operator|++
expr_stmt|;
if|if
condition|(
name|statmsg
operator|==
name|NULL
operator|&&
name|m
operator|->
name|m_badstat
operator|!=
literal|0
condition|)
block|{
name|stat
operator|=
name|m
operator|->
name|m_badstat
expr_stmt|;
name|i
operator|=
name|stat
operator|-
name|EX__BASE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|N_SysEx
condition|)
name|syserr
argument_list|(
literal|"Bad m_badstat %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|DEBUG
name|statmsg
operator|=
name|SysExMsg
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|statmsg
operator|==
name|NULL
condition|)
name|usrerr
argument_list|(
literal|"unknown mailer response %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|force
operator|||
operator|!
name|bitset
argument_list|(
name|M_QUIET
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
name|usrerr
argument_list|(
literal|"%s"
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Final cleanup. 	**	Log a record of the transaction.  Compute the new 	**	ExitStat -- if we already had an error, stick with 	**	that. 	*/
if|if
condition|(
name|statmsg
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"error %d"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|statmsg
operator|=
name|buf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s->%s: %ld: %s"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|,
name|To
argument_list|,
name|MsgSize
argument_list|,
name|statmsg
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|setstat
argument_list|(
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PUTMESSAGE -- output a message to the final mailer. ** **	then passes the rest of the message through.  If we have **	managed to extract a date already, use that; otherwise, **	use the current date/time. ** **	Parameters: **		fp -- file to output onto. **		m -- a mailer descriptor. ** **	Returns: **		none. ** **	Side Effects: **		The message is written onto fp. */
end_comment

begin_macro
name|putmessage
argument_list|(
argument|fp
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|HDR
modifier|*
name|h
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|extern
name|char
modifier|*
name|arpadate
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|hvalue
parameter_list|()
function_decl|;
name|bool
name|anyheader
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|char
modifier|*
name|translate
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|capitalize
parameter_list|()
function_decl|;
specifier|extern
name|char
name|SentDate
index|[]
decl_stmt|;
comment|/* clear all "used" bits */
for|for
control|(
name|h
operator|=
name|Header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
name|h
operator|->
name|h_flags
operator|&=
operator|~
name|H_USED
expr_stmt|;
comment|/* output date if needed by mailer */
name|p
operator|=
name|hvalue
argument_list|(
literal|"date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|M_NEEDDATE
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|arpadate
argument_list|(
name|Date
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|anyheader
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* output from line if needed by mailer */
name|p
operator|=
name|hvalue
argument_list|(
literal|"from"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|M_NEEDFROM
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|p
operator|==
name|NULL
condition|)
block|{
specifier|extern
name|char
modifier|*
name|FullName
decl_stmt|;
name|p
operator|=
name|translate
argument_list|(
literal|"$g"
argument_list|,
name|Mailer
index|[
name|From
operator|.
name|q_mailer
index|]
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FullName
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s<%s>\n"
argument_list|,
name|FullName
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|anyheader
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"From: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|anyheader
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* output message-id field if needed */
name|p
operator|=
name|hvalue
argument_list|(
literal|"message-id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitset
argument_list|(
name|M_MSGID
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|MsgId
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Message-Id: %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|anyheader
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* output any other header lines */
for|for
control|(
name|h
operator|=
name|Header
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|h_link
control|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|H_USED
argument_list|,
name|h
operator|->
name|h_flags
argument_list|)
condition|)
continue|continue;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|capitalize
argument_list|(
name|h
operator|->
name|h_field
argument_list|)
argument_list|,
name|h
operator|->
name|h_value
argument_list|)
expr_stmt|;
name|h
operator|->
name|h_flags
operator||=
name|H_USED
expr_stmt|;
name|anyheader
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|anyheader
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* output the body of the message */
while|while
condition|(
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|syserr
argument_list|(
literal|"putmessage: write error"
argument_list|)
expr_stmt|;
name|setstat
argument_list|(
name|EX_IOERR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  PIPESIG -- Handle broken pipe signals ** **	This just logs an error. ** **	Parameters: **		none ** **	Returns: **		none ** **	Side Effects: **		logs an error message. */
end_comment

begin_macro
name|pipesig
argument_list|()
end_macro

begin_block
block|{
name|syserr
argument_list|(
literal|"Broken pipe"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  SENDTO -- Designate a send list. ** **	The parameter is a comma-separated list of people to send to. **	This routine arranges to send to all of them. ** **	Parameters: **		list -- the send list. **		copyf -- the copy flag; passed to parse. ** **	Returns: **		none ** **	Side Effects: **		none. ** **	Called By: **		main **		alias */
end_comment

begin_macro
name|sendto
argument_list|(
argument|list
argument_list|,
argument|copyf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|copyf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|ADDRESS
modifier|*
name|a
decl_stmt|;
specifier|extern
name|ADDRESS
modifier|*
name|parse
parameter_list|()
function_decl|;
name|bool
name|more
decl_stmt|;
comment|/* more keeps track of what the previous delimiter was */
name|more
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|more
condition|;
control|)
block|{
comment|/* find the end of this address */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
continue|continue;
name|more
operator|=
name|c
operator|!=
literal|'\0'
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|p
operator|++
expr_stmt|;
comment|/* parse the address */
if|if
condition|(
operator|(
name|a
operator|=
name|parse
argument_list|(
name|q
argument_list|,
operator|(
name|ADDRESS
operator|*
operator|)
name|NULL
argument_list|,
name|copyf
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* arrange to send to this person */
name|recipient
argument_list|(
name|a
argument_list|,
operator|&
name|SendQ
argument_list|)
expr_stmt|;
block|}
name|To
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  RECIPIENT -- Designate a message recipient ** **	Saves the named person for future mailing. ** **	Designates a person as a recipient.  This routine **	does the initial parsing, and checks to see if **	this person has already received the mail. **	It also supresses local network names and turns them into **	local names. ** **	Parameters: **		a -- the (preparsed) address header for the recipient. **		targetq -- the queue to add the name to. ** **	Returns: **		none. ** **	Side Effects: **		none. ** **	Called By: **		sendto **		main */
end_comment

begin_expr_stmt
name|recipient
argument_list|(
name|a
argument_list|,
name|targetq
argument_list|)
specifier|register
name|ADDRESS
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ADDRESS
modifier|*
name|targetq
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ADDRESS
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
specifier|extern
name|bool
name|forward
parameter_list|()
function_decl|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|bool
name|sameaddr
parameter_list|()
function_decl|;
name|To
operator|=
name|a
operator|->
name|q_paddr
expr_stmt|;
name|m
operator|=
name|Mailer
index|[
name|a
operator|->
name|q_mailer
index|]
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"recipient(%s)\n"
argument_list|,
name|To
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 	**  Look up this person in the recipient list.  If they 	**  are there already, return, otherwise continue. 	*/
if|if
condition|(
operator|!
name|ForceMail
condition|)
block|{
for|for
control|(
name|q
operator|=
operator|&
name|SendQ
init|;
operator|(
name|q
operator|=
name|nxtinq
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"(%s in SendQ)\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return;
block|}
for|for
control|(
name|q
operator|=
operator|&
name|AliasQ
init|;
operator|(
name|q
operator|=
name|nxtinq
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|sameaddr
argument_list|(
name|q
argument_list|,
name|a
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"(%s in AliasQ)\n"
argument_list|,
name|a
operator|->
name|q_paddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return;
block|}
block|}
comment|/* 	**  See if the user wants hir mail forwarded. 	**	`Forward' must do the forwarding recursively. 	*/
if|if
condition|(
name|m
operator|==
name|Mailer
index|[
literal|0
index|]
operator|&&
operator|!
name|NoAlias
operator|&&
name|targetq
operator|==
operator|&
name|SendQ
operator|&&
name|forward
argument_list|(
name|a
argument_list|)
condition|)
return|return;
comment|/* 	**  Put the user onto the target queue. 	*/
if|if
condition|(
name|targetq
operator|!=
name|NULL
condition|)
block|{
name|putonq
argument_list|(
name|a
argument_list|,
name|targetq
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **  BUILDARGV -- Build an argument vector for a mail server. ** **	Using a template defined in config.c, an argv is built. **	The format of the template is already a vector.  The **	items of this vector are copied, unless a dollar sign **	is encountered.  In this case, the next character **	specifies something else to copy in.  These can be **		$f	The from address. **		$h	The host. **		$u	The user. **		$c	The hop count. **	The vector is built in a local buffer.  A pointer to **	the static argv is returned. ** **	Parameters: **		m -- a pointer to the mailer descriptor. **		host -- the host name to send to. **		user -- the user name to send to. **		from -- the person this mail is from. ** **	Returns: **		A pointer to an argv. ** **	Side Effects: **		none ** **	WARNING: **		Since the argv is staticly allocated, any subsequent **		calls will clobber the old argv. ** **	Called By: **		deliver */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|buildargv
parameter_list|(
name|m
parameter_list|,
name|host
parameter_list|,
name|user
parameter_list|,
name|from
parameter_list|)
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
modifier|*
name|pv
index|[
name|MAXPV
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|pvp
decl_stmt|;
name|char
modifier|*
modifier|*
name|mvp
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|translate
parameter_list|()
function_decl|;
comment|/* 	**  Do initial argv setup. 	**	Insert the mailer name.  Notice that $x expansion is 	**	NOT done on the mailer name.  Then, if the mailer has 	**	a picky -f flag, we insert it as appropriate.  This 	**	code does not check for 'pv' overflow; this places a 	**	manifest lower limit of 4 for MAXPV. 	*/
name|pvp
operator|=
name|pv
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|m
operator|->
name|m_argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* insert -f or -r flag as appropriate */
if|if
condition|(
name|bitset
argument_list|(
name|M_FOPT
operator||
name|M_ROPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
operator|&&
name|FromFlag
condition|)
block|{
if|if
condition|(
name|bitset
argument_list|(
name|M_FOPT
argument_list|,
name|m
operator|->
name|m_flags
argument_list|)
condition|)
operator|*
name|pvp
operator|++
operator|=
literal|"-f"
expr_stmt|;
else|else
operator|*
name|pvp
operator|++
operator|=
literal|"-r"
expr_stmt|;
operator|*
name|pvp
operator|++
operator|=
name|translate
argument_list|(
name|from
argument_list|,
name|m
argument_list|,
name|from
argument_list|,
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
comment|/* 	**  Build the rest of argv. 	**	For each prototype parameter, the prototype is 	**	scanned character at a time.  If a dollar-sign is 	**	found, 'q' is set to the appropriate expansion, 	**	otherwise it is null.  Then either the string 	**	pointed to by q, or the original character, is 	**	interpolated into the buffer.  Buffer overflow is 	**	checked. 	*/
for|for
control|(
name|mvp
operator|=
name|m
operator|->
name|m_argv
init|;
operator|(
name|p
operator|=
operator|*
operator|++
name|mvp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|pvp
operator|>=
operator|&
name|pv
index|[
name|MAXPV
index|]
condition|)
block|{
name|syserr
argument_list|(
literal|"Too many parameters to %s"
argument_list|,
name|pv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|pvp
operator|++
operator|=
name|translate
argument_list|(
name|p
argument_list|,
name|m
argument_list|,
name|from
argument_list|,
name|user
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
operator|*
name|pvp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"Interpolated argv is:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mvp
operator|=
name|pv
init|;
operator|*
name|mvp
operator|!=
name|NULL
condition|;
name|mvp
operator|++
control|)
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
operator|*
name|mvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  TRANSLATE -- translate a string using $x escapes. ** **	Parameters: **		s -- string to translate. **		m -- pointer to mailer descriptor. ** **	Returns: **		pointer to translated string. ** **	Side Effects: **		none. */
end_comment

begin_function
name|char
modifier|*
name|translate
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|,
name|from
parameter_list|,
name|user
parameter_list|,
name|host
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|mailer
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|host
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXNAME
index|]
decl_stmt|;
name|char
name|pbuf
index|[
literal|10
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|newstr
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|Macro
index|[]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|trans2
parameter_list|()
function_decl|;
comment|/* predefine system macros */
name|Macro
index|[
literal|'f'
index|]
operator|=
name|From
operator|.
name|q_paddr
expr_stmt|;
name|Macro
index|[
literal|'g'
index|]
operator|=
name|m
operator|->
name|m_from
expr_stmt|;
name|Macro
index|[
literal|'u'
index|]
operator|=
name|user
expr_stmt|;
name|Macro
index|[
literal|'h'
index|]
operator|=
name|host
expr_stmt|;
name|sprintf
argument_list|(
name|pbuf
argument_list|,
literal|"%d"
argument_list|,
name|HopCount
argument_list|)
expr_stmt|;
name|Macro
index|[
literal|'c'
index|]
operator|=
name|pbuf
expr_stmt|;
name|trans2
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"translate ==> '%s'\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|newstr
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  TRANS2 -- internal routine to translate. */
end_comment

begin_function
name|char
modifier|*
name|trans2
parameter_list|(
name|s
parameter_list|,
name|bp
parameter_list|,
name|buflim
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|buflim
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|extern
name|char
modifier|*
name|Macro
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"translate(%s)\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
for|for
control|(
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
comment|/* q will be the interpolated quantity */
name|q
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
condition|)
name|q
operator|=
name|Macro
index|[
operator|*
operator|++
name|s
index|]
expr_stmt|;
comment|/* 		**  Interpolate q or output one character 		**	Strip quote bits as we proceed..... 		*/
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|bp
operator|=
name|trans2
argument_list|(
name|q
argument_list|,
name|bp
argument_list|,
name|buflim
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|<
name|buflim
operator|-
literal|1
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  MAILFILE -- Send a message to a file. ** **	Parameters: **		filename -- the name of the file to send to. ** **	Returns: **		The exit code associated with the operation. ** **	Side Effects: **		none. ** **	Called By: **		deliver */
end_comment

begin_macro
name|mailfile
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|MAXLINE
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|auto
name|long
name|tim
decl_stmt|;
specifier|extern
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|EX_CANTCREAT
operator|)
return|;
comment|/* output the timestamp */
name|time
argument_list|(
operator|&
name|tim
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"From %s %s"
argument_list|,
name|From
operator|.
name|q_paddr
argument_list|,
name|ctime
argument_list|(
operator|&
name|tim
argument_list|)
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_IOERR
operator|)
return|;
block|}
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_OK
operator|)
return|;
block|}
end_block

end_unit

