begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)master.c	2.9 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<protocols/timed.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|machup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|measure_delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|sequence
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MEASURE
end_ifdef

begin_decl_stmt
name|int
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The main function of `master' is to periodically compute the differences   * (deltas) between its clock and the clocks of the slaves, to compute the   * network average delta, and to send to the slaves the differences between   * their individual deltas and the network delta.  * While waiting, it receives messages from the slaves (i.e. requests for  * master's name, remote requests to set the network time, ...), and  * takes the appropriate action.  */
end_comment

begin_macro
name|master
argument_list|()
end_macro

begin_block
block|{
name|int
name|ind
decl_stmt|;
name|long
name|pollingtime
decl_stmt|;
name|struct
name|timeval
name|wait
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|struct
name|timeval
name|otime
decl_stmt|;
name|struct
name|timezone
name|tzone
decl_stmt|;
name|struct
name|tsp
modifier|*
name|msg
decl_stmt|,
name|to
decl_stmt|;
name|struct
name|sockaddr_in
name|saveaddr
decl_stmt|;
name|int
name|findhost
parameter_list|()
function_decl|;
name|char
modifier|*
name|date
parameter_list|()
function_decl|;
name|struct
name|tsp
modifier|*
name|readmsg
parameter_list|()
function_decl|;
name|struct
name|tsp
modifier|*
name|answer
decl_stmt|,
modifier|*
name|acksend
argument_list|()
decl_stmt|;
name|char
name|olddate
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|server
decl_stmt|;
specifier|register
name|struct
name|netinfo
modifier|*
name|ntp
decl_stmt|;
ifdef|#
directive|ifdef
name|MEASURE
name|fi
operator|=
literal|"/usr/adm/timed.masterlog"
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fi
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"This machine is master"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"THIS MACHINE IS MASTER\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
if|if
condition|(
name|ntp
operator|->
name|status
operator|==
name|MASTER
condition|)
name|masterup
argument_list|(
name|ntp
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
literal|0
expr_stmt|;
name|loop
label|:
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|>=
name|pollingtime
condition|)
block|{
name|pollingtime
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
expr_stmt|;
name|synch
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
for|for
control|(
name|ntp
operator|=
name|nettab
init|;
name|ntp
operator|!=
name|NULL
condition|;
name|ntp
operator|=
name|ntp
operator|->
name|next
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_LOOP
expr_stmt|;
name|to
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
name|to
operator|.
name|tsp_seq
operator|=
name|sequence
operator|++
expr_stmt|;
name|to
operator|.
name|tsp_hopcnt
operator|=
literal|10
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|ntp
operator|->
name|dest_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|wait
operator|.
name|tv_sec
operator|=
name|pollingtime
operator|-
name|time
operator|.
name|tv_sec
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|readmsg
argument_list|(
name|TSP_ANY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|wait
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|tsp_type
condition|)
block|{
case|case
name|TSP_MASTERREQ
case|:
break|break;
case|case
name|TSP_SLAVEUP
case|:
name|ind
operator|=
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
name|newslave
argument_list|(
name|ind
argument_list|,
name|msg
operator|->
name|tsp_seq
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_SETDATE
case|:
name|saveaddr
operator|=
name|from
expr_stmt|;
name|msg
operator|->
name|tsp_time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 			 * the following line is necessary due to syslog 			 * calling ctime() which clobbers the static buffer 			 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|olddate
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|tzone
argument_list|)
expr_stmt|;
name|otime
operator|=
name|time
expr_stmt|;
name|time
operator|.
name|tv_sec
operator|=
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
expr_stmt|;
name|time
operator|.
name|tv_usec
operator|=
name|msg
operator|->
name|tsp_time
operator|.
name|tv_usec
expr_stmt|;
operator|(
name|void
operator|)
name|settimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|tzone
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"date changed from: %s"
argument_list|,
name|olddate
argument_list|)
expr_stmt|;
name|logwtmp
argument_list|(
name|otime
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|msg
operator|->
name|tsp_type
operator|=
name|TSP_DATEACK
expr_stmt|;
name|msg
operator|->
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|bytenetorder
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|saveaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|spreadtime
argument_list|()
expr_stmt|;
name|pollingtime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TSP_SETDATEREQ
case|:
name|ind
operator|=
name|findhost
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"DATEREQ from uncontrolled machine"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
index|[
name|ind
index|]
operator|.
name|seq
operator|!=
name|msg
operator|->
name|tsp_seq
condition|)
block|{
name|hp
index|[
name|ind
index|]
operator|.
name|seq
operator|=
name|msg
operator|->
name|tsp_seq
expr_stmt|;
name|msg
operator|->
name|tsp_time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 				 * the following line is necessary due to syslog 				 * calling ctime() which clobbers the static buffer 				 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|olddate
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|tzone
argument_list|)
expr_stmt|;
name|otime
operator|=
name|time
expr_stmt|;
name|time
operator|.
name|tv_sec
operator|=
name|msg
operator|->
name|tsp_time
operator|.
name|tv_sec
expr_stmt|;
name|time
operator|.
name|tv_usec
operator|=
name|msg
operator|->
name|tsp_time
operator|.
name|tv_usec
expr_stmt|;
operator|(
name|void
operator|)
name|settimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|tzone
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"date changed by %s from: %s"
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|olddate
argument_list|)
expr_stmt|;
name|logwtmp
argument_list|(
name|otime
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|spreadtime
argument_list|()
expr_stmt|;
name|pollingtime
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|TSP_MSITE
case|:
case|case
name|TSP_MSITEREQ
case|:
break|break;
case|case
name|TSP_TRACEON
case|:
if|if
condition|(
operator|!
operator|(
name|trace
operator|)
condition|)
block|{
name|fd
operator|=
name|fopen
argument_list|(
name|tracefile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Tracing started on: %s\n\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|trace
operator|=
name|ON
expr_stmt|;
break|break;
case|case
name|TSP_TRACEOFF
case|:
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Tracing ended on: %s\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GPROF
name|moncontrol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_mcleanup
argument_list|()
expr_stmt|;
name|moncontrol
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|trace
operator|=
name|OFF
expr_stmt|;
break|break;
case|case
name|TSP_ELECTION
case|:
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|server
operator|=
name|from
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|server
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|TSP_ACK
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"election error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
name|pollingtime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TSP_CONFLICT
case|:
comment|/* 			 * After a network partition, there can be  			 * more than one master: the first slave to  			 * come up will notify here the situation. 			 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromnet
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
init|;
condition|;
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_RESOLVE
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|fromnet
operator|->
name|dest_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|,
name|fromnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
break|break;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
name|server
operator|=
name|from
expr_stmt|;
name|msg
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|server
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|,
name|TSP_ACK
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error on sending QUIT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|addmach
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
block|}
name|masterup
argument_list|(
name|fromnet
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TSP_RESOLVE
case|:
comment|/* 			 * do not want to call synch() while waiting 			 * to be killed! 			 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pollingtime
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|SAMPLEINTVL
expr_stmt|;
break|break;
case|case
name|TSP_QUIT
case|:
comment|/* become slave */
ifdef|#
directive|ifdef
name|MEASURE
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|longjmp
argument_list|(
name|jmpenv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSP_LOOP
case|:
comment|/* 			 * We should not have received this from a net 			 * we are master on.  There must be two masters 			 * in this case. 			 */
name|to
operator|.
name|tsp_type
operator|=
name|TSP_QUIT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|server
operator|=
name|from
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|server
argument_list|,
name|msg
operator|->
name|tsp_name
argument_list|,
name|TSP_ACK
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"loop breakage: no reply to QUIT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
default|default:
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"garbage: "
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|msg
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * `synch' synchronizes all the slaves by calling measure,   * networkdelta and correct   */
end_comment

begin_macro
name|synch
argument_list|(
argument|mydelta
argument_list|)
end_macro

begin_decl_stmt
name|long
name|mydelta
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|measure_status
decl_stmt|;
name|long
name|netdelta
decl_stmt|;
name|struct
name|timeval
name|tack
decl_stmt|;
ifdef|#
directive|ifdef
name|MEASURE
define|#
directive|define
name|MAXLINES
value|8
specifier|static
name|int
name|lines
init|=
literal|1
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|,
name|end
decl_stmt|;
endif|#
directive|endif
name|int
name|measure
parameter_list|()
function_decl|;
name|int
name|correct
parameter_list|()
function_decl|;
name|long
name|networkdelta
parameter_list|()
function_decl|;
name|char
modifier|*
name|date
parameter_list|()
function_decl|;
if|if
condition|(
name|slvcount
operator|>
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MEASURE
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|ON
operator|||
operator|--
name|lines
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.7s\t"
argument_list|,
name|hp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|lines
operator|=
name|MAXLINES
expr_stmt|;
name|header
operator|=
name|OFF
expr_stmt|;
block|}
endif|#
directive|endif
name|machup
operator|=
literal|1
expr_stmt|;
name|hp
index|[
literal|0
index|]
operator|.
name|delta
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
block|{
name|tack
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tack
operator|.
name|tv_usec
operator|=
literal|500000
expr_stmt|;
if|if
condition|(
operator|(
name|measure_status
operator|=
name|measure
argument_list|(
operator|&
name|tack
argument_list|,
operator|&
name|hp
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"measure: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hp
index|[
name|i
index|]
operator|.
name|delta
operator|=
name|measure_delta
expr_stmt|;
if|if
condition|(
name|measure_status
operator|==
name|GOOD
condition|)
name|machup
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|SLAVE
condition|)
block|{
comment|/* called by a submaster */
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"submaster correct: %d ms.\n"
argument_list|,
name|mydelta
argument_list|)
expr_stmt|;
name|correct
argument_list|(
name|mydelta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|machup
operator|>
literal|1
condition|)
block|{
name|netdelta
operator|=
name|networkdelta
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"master correct: %d ms.\n"
argument_list|,
name|mydelta
argument_list|)
expr_stmt|;
name|correct
argument_list|(
name|netdelta
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MEASURE
name|gettimeofday
argument_list|(
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|end
operator|.
name|tv_sec
operator|-=
name|start
operator|.
name|tv_sec
expr_stmt|;
name|end
operator|.
name|tv_usec
operator|-=
name|start
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|end
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|end
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|end
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d ms.\n"
argument_list|,
operator|(
name|end
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|end
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hp
index|[
name|i
index|]
operator|.
name|delta
operator|==
name|HOSTDOWN
condition|)
block|{
name|rmmach
argument_list|(
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MEASURE
name|header
operator|=
name|ON
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|SLAVE
condition|)
block|{
name|correct
argument_list|(
name|mydelta
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * 'spreadtime' sends the time to each slave after the master  * has received the command to set the network time   */
end_comment

begin_macro
name|spreadtime
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|tsp
name|to
decl_stmt|;
name|struct
name|tsp
modifier|*
name|answer
decl_stmt|,
modifier|*
name|acksend
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
block|{
name|to
operator|.
name|tsp_type
operator|=
name|TSP_SETTIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|to
operator|.
name|tsp_time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|hp
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|hp
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|TSP_ACK
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no reply to SETTIME from: %s"
argument_list|,
name|hp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|findhost
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|ind
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|hp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ind
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|ind
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * 'addmach' adds a host to the list of controlled machines  * if not already there   */
end_comment

begin_macro
name|addmach
argument_list|(
argument|name
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|;
name|int
name|findhost
parameter_list|()
function_decl|;
name|ret
operator|=
name|findhost
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|hp
index|[
name|slvcount
index|]
operator|.
name|addr
operator|=
operator|*
name|addr
expr_stmt|;
name|hp
index|[
name|slvcount
index|]
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
index|[
name|slvcount
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|hp
index|[
name|slvcount
index|]
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|slvcount
expr_stmt|;
if|if
condition|(
name|slvcount
operator|<
name|NHOSTS
condition|)
name|slvcount
operator|++
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no more slots in host table"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* need to clear sequence number anyhow */
name|hp
index|[
name|ret
index|]
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MEASURE
name|header
operator|=
name|ON
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Remove all the machines from the host table that exist on the given  * network.  This is called when a master transitions to a slave on a  * given network.  */
end_comment

begin_expr_stmt
name|rmnetmachs
argument_list|(
name|ntp
argument_list|)
specifier|register
expr|struct
name|netinfo
operator|*
name|ntp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|prthp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|hp
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|&
name|ntp
operator|->
name|mask
operator|)
operator|==
name|ntp
operator|->
name|net
condition|)
name|rmmach
argument_list|(
name|i
operator|--
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|prthp
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove the machine with the given index in the host table.  */
end_comment

begin_macro
name|rmmach
argument_list|(
argument|ind
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ind
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"rmmach: %s\n"
argument_list|,
name|hp
index|[
name|ind
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
index|[
name|ind
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|hp
index|[
name|ind
index|]
operator|=
name|hp
index|[
operator|--
name|slvcount
index|]
expr_stmt|;
block|}
end_block

begin_macro
name|prthp
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"host table:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|slvcount
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|" %s"
argument_list|,
name|hp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|masterup
argument_list|(
argument|net
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|netinfo
modifier|*
name|net
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|wait
decl_stmt|;
name|struct
name|tsp
name|to
decl_stmt|,
modifier|*
name|msg
decl_stmt|,
modifier|*
name|readmsg
argument_list|()
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_MASTERUP
expr_stmt|;
name|to
operator|.
name|tsp_vers
operator|=
name|TSPVERSION
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|bytenetorder
argument_list|(
operator|&
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|sock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|net
operator|->
name|dest_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"sendto: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|wait
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|msg
operator|=
name|readmsg
argument_list|(
name|TSP_SLAVEUP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|wait
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|ind
operator|=
name|addmach
argument_list|(
name|msg
operator|->
name|tsp_name
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_block

begin_macro
name|newslave
argument_list|(
argument|ind
argument_list|,
argument|seq
argument_list|)
end_macro

begin_block
block|{
name|struct
name|tsp
name|to
decl_stmt|;
name|struct
name|tsp
modifier|*
name|answer
decl_stmt|,
modifier|*
name|acksend
argument_list|()
decl_stmt|;
name|struct
name|timeval
name|mytime
decl_stmt|;
if|if
condition|(
name|trace
condition|)
name|prthp
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq
operator|==
literal|0
operator|||
name|hp
index|[
name|ind
index|]
operator|.
name|seq
operator|!=
name|seq
condition|)
block|{
name|hp
index|[
name|ind
index|]
operator|.
name|seq
operator|=
name|seq
expr_stmt|;
name|to
operator|.
name|tsp_type
operator|=
name|TSP_SETTIME
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|to
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
comment|/* 		 * give the upcoming slave the time 		 * to check its input queue before 		 * setting the time 		 */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|mytime
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|to
operator|.
name|tsp_time
operator|.
name|tv_sec
operator|=
name|mytime
operator|.
name|tv_sec
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|to
argument_list|,
operator|&
name|hp
index|[
name|ind
index|]
operator|.
name|addr
argument_list|,
name|hp
index|[
name|ind
index|]
operator|.
name|name
argument_list|,
name|TSP_ACK
argument_list|,
operator|(
expr|struct
name|netinfo
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no reply to initial SETTIME from: %s"
argument_list|,
name|hp
index|[
name|ind
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|rmmach
argument_list|(
name|ind
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|wtmpfile
init|=
literal|"/usr/adm/wtmp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|utmp
name|wtmp
index|[
literal|2
index|]
init|=
block|{
block|{
literal|"|"
block|,
literal|""
block|,
literal|""
block|,
literal|0
block|}
block|,
block|{
literal|"{"
block|,
literal|""
block|,
literal|""
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Rounding doesn't work well because new time is always  * truncated, but oldtime is normally distributed.  */
end_comment

begin_macro
name|logwtmp
argument_list|(
argument|otime
argument_list|,
argument|ntime
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|timeval
name|otime
decl_stmt|,
name|ntime
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|f
decl_stmt|;
if|if
condition|(
name|otime
operator|.
name|tv_sec
operator|==
name|ntime
operator|.
name|tv_sec
condition|)
return|return;
name|wtmp
index|[
literal|0
index|]
operator|.
name|ut_time
operator|=
name|otime
operator|.
name|tv_sec
expr_stmt|;
comment|/* +(otime.tv_usec + 500000)/1000000;*/
name|wtmp
index|[
literal|1
index|]
operator|.
name|ut_time
operator|=
name|ntime
operator|.
name|tv_sec
expr_stmt|;
comment|/* +(ntime.tv_usec + 500000)/1000000;*/
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|wtmpfile
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|wtmp
argument_list|,
sizeof|sizeof
argument_list|(
name|wtmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

