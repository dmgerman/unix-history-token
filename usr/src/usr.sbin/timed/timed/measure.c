begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)measure.c	2.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|<protocols/timed.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_define
define|#
directive|define
name|BIASP
value|43199999
end_define

begin_define
define|#
directive|define
name|BIASN
value|-43200000
end_define

begin_define
define|#
directive|define
name|MODULO
value|86400000
end_define

begin_define
define|#
directive|define
name|PROCESSING_TIME
value|5
end_define

begin_comment
comment|/* ms. to reduce error in measurement */
end_comment

begin_define
define|#
directive|define
name|PACKET_IN
value|1024
end_define

begin_decl_stmt
specifier|extern
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|measure_delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sock_raw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|n_short
name|seqno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Measures the differences between machines' clocks using  * ICMP timestamp messages.  */
end_comment

begin_macro
name|measure
argument_list|(
argument|wait
argument_list|,
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|wait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|msgcount
decl_stmt|,
name|trials
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|count
decl_stmt|;
name|fd_set
name|ready
decl_stmt|;
name|long
name|sendtime
decl_stmt|,
name|recvtime
decl_stmt|,
name|histime
decl_stmt|;
name|long
name|min1
decl_stmt|,
name|min2
decl_stmt|,
name|diff
decl_stmt|;
specifier|register
name|long
name|delta1
decl_stmt|,
name|delta2
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|,
name|tout
decl_stmt|;
name|u_char
name|packet
index|[
name|PACKET_IN
index|]
decl_stmt|,
name|opacket
index|[
literal|64
index|]
decl_stmt|;
specifier|register
name|struct
name|icmp
modifier|*
name|icp
init|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|packet
decl_stmt|;
specifier|register
name|struct
name|icmp
modifier|*
name|oicp
init|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|opacket
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packet
decl_stmt|;
name|min1
operator|=
name|min2
operator|=
literal|0x7fffffff
expr_stmt|;
name|status
operator|=
name|HOSTDOWN
expr_stmt|;
name|measure_delta
operator|=
name|HOSTDOWN
expr_stmt|;
comment|/* empties the icmp input queue */
name|FD_ZERO
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|empty
label|:
name|tout
operator|.
name|tv_sec
operator|=
name|tout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_SET
argument_list|(
name|sock_raw
argument_list|,
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|ready
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tout
argument_list|)
condition|)
block|{
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|cc
operator|=
name|recvfrom
argument_list|(
name|sock_raw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|packet
argument_list|,
name|PACKET_IN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|empty
goto|;
block|}
comment|/* 	 * To measure the difference, select MSGS messages whose round-trip 	 * time is smaller than RANGE if ckrange is 1, otherwise simply 	 * select MSGS messages regardless of round-trip transmission time. 	 * Choose the smallest transmission time in each of the two directions. 	 * Use these two latter quantities to compute the delta between 	 * the two clocks. 	 */
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|oicp
operator|->
name|icmp_type
operator|=
name|ICMP_TSTAMP
expr_stmt|;
name|oicp
operator|->
name|icmp_code
operator|=
literal|0
expr_stmt|;
name|oicp
operator|->
name|icmp_cksum
operator|=
literal|0
expr_stmt|;
name|oicp
operator|->
name|icmp_id
operator|=
name|id
expr_stmt|;
name|oicp
operator|->
name|icmp_rtime
operator|=
literal|0
expr_stmt|;
name|oicp
operator|->
name|icmp_ttime
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ready
argument_list|)
expr_stmt|;
name|msgcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|trials
operator|=
literal|0
init|;
name|msgcount
operator|<
name|MSGS
operator|&&
name|trials
operator|<
name|TRIALS
condition|;
operator|++
name|trials
control|)
block|{
name|oicp
operator|->
name|icmp_seq
operator|=
operator|++
name|seqno
expr_stmt|;
name|oicp
operator|->
name|icmp_cksum
operator|=
literal|0
expr_stmt|;
name|tout
operator|.
name|tv_sec
operator|=
name|wait
operator|->
name|tv_sec
expr_stmt|;
name|tout
operator|.
name|tv_usec
operator|=
name|wait
operator|->
name|tv_usec
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|sendtime
operator|=
name|oicp
operator|->
name|icmp_otime
operator|=
operator|(
name|tv1
operator|.
name|tv_sec
operator|%
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
operator|)
operator|*
literal|1000
operator|+
name|tv1
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|oicp
operator|->
name|icmp_cksum
operator|=
name|in_cksum
argument_list|(
operator|(
name|u_short
operator|*
operator|)
name|oicp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oicp
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|sendto
argument_list|(
name|sock_raw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|opacket
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oicp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|status
operator|=
name|UNREACHABLE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_SET
argument_list|(
name|sock_raw
argument_list|,
operator|&
name|ready
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|=
name|select
argument_list|(
name|FD_SETSIZE
argument_list|,
operator|&
name|ready
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tout
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|cc
operator|=
name|recvfrom
argument_list|(
name|sock_raw
argument_list|,
operator|(
name|char
operator|*
operator|)
name|packet
argument_list|,
name|PACKET_IN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|packet
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|icp
operator|->
name|icmp_type
operator|==
name|ICMP_TSTAMPREPLY
operator|)
operator|&&
name|icp
operator|->
name|icmp_id
operator|==
name|id
operator|&&
name|icp
operator|->
name|icmp_seq
operator|==
name|seqno
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
continue|continue;
comment|/* resend */
name|recvtime
operator|=
operator|(
name|tv1
operator|.
name|tv_sec
operator|%
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
operator|)
operator|*
literal|1000
operator|+
name|tv1
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|diff
operator|=
name|recvtime
operator|-
name|sendtime
expr_stmt|;
comment|/* 		 * diff can be less than 0 aroud midnight 		 */
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
continue|continue;
name|msgcount
operator|++
expr_stmt|;
name|histime
operator|=
name|ntohl
argument_list|(
operator|(
name|u_long
operator|)
name|icp
operator|->
name|icmp_rtime
argument_list|)
expr_stmt|;
comment|/* 		 * a hosts using a time format different from  		 * ms. since midnight UT (as per RFC792) should 		 * set the high order bit of the 32-bit time 		 * value it transmits. 		 */
if|if
condition|(
operator|(
name|histime
operator|&
literal|0x80000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
name|NONSTDTIME
expr_stmt|;
break|break;
block|}
name|status
operator|=
name|GOOD
expr_stmt|;
name|delta1
operator|=
name|histime
operator|-
name|sendtime
expr_stmt|;
comment|/* 		 * Handles wrap-around to avoid that around  		 * midnight small time differences appear  		 * enormous. However, the two machine's clocks 		 * must be within 12 hours from each other. 		 */
if|if
condition|(
name|delta1
operator|<
name|BIASN
condition|)
name|delta1
operator|+=
name|MODULO
expr_stmt|;
elseif|else
if|if
condition|(
name|delta1
operator|>
name|BIASP
condition|)
name|delta1
operator|-=
name|MODULO
expr_stmt|;
name|delta2
operator|=
name|recvtime
operator|-
name|histime
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
name|BIASN
condition|)
name|delta2
operator|+=
name|MODULO
expr_stmt|;
elseif|else
if|if
condition|(
name|delta2
operator|>
name|BIASP
condition|)
name|delta2
operator|-=
name|MODULO
expr_stmt|;
if|if
condition|(
name|delta1
operator|<
name|min1
condition|)
name|min1
operator|=
name|delta1
expr_stmt|;
if|if
condition|(
name|delta2
operator|<
name|min2
condition|)
name|min2
operator|=
name|delta2
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|RANGE
condition|)
block|{
name|min1
operator|=
name|delta1
expr_stmt|;
name|min2
operator|=
name|delta2
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If no answer is received for TRIALS consecutive times,  	 * the machine is assumed to be down 	 */
if|if
condition|(
name|status
operator|==
name|GOOD
condition|)
block|{
name|measure_delta
operator|=
operator|(
name|min1
operator|-
name|min2
operator|)
operator|/
literal|2
operator|+
name|PROCESSING_TIME
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_block

end_unit

