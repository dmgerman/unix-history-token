begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1983 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)timed.c	1.3 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_define
define|#
directive|define
name|TSPTYPES
end_define

begin_include
include|#
directive|include
file|<protocols/timed.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|int
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sock
decl_stmt|,
name|sock_raw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* either MASTER or SLAVE */
end_comment

begin_decl_stmt
name|int
name|backoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slvcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no. of slaves controlled by master */
end_comment

begin_decl_stmt
name|int
name|machup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|sequence
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sequence number */
end_comment

begin_decl_stmt
name|long
name|delay1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|delay2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|broadcastaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local net broadcast address */
end_comment

begin_decl_stmt
name|u_long
name|netmask
decl_stmt|,
name|mynet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* my network number& netmask */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|host
name|hp
index|[
name|NHOSTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|jmpenv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sockaddr_in
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The timedaemons synchronize the clocks of hosts in a local area network.  * One daemon runs as master, all the others as slaves. The master  * performs the task of computing clock differences and sends correction  * values to the slaves.   * Slaves start an election to choose a new master when the latter disappears   * because of a machine crash, network partition, or when killed.  * A resolution protocol is used to kill all but one of the masters  * that happen to exist in segments of a partitioned network when the   * network partition is fixed.  *  * Authors: Riccardo Gusella& Stefano Zatti  *  * For problems and suggestions, please send mail to gusella@BERKELEY  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|on
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|long
name|seed
decl_stmt|;
name|int
name|Mflag
decl_stmt|;
name|int
name|nflag
decl_stmt|;
name|char
name|mastername
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|netname
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|struct
name|servent
modifier|*
name|srvp
decl_stmt|;
name|struct
name|netent
modifier|*
name|getnetent
parameter_list|()
function_decl|;
name|struct
name|netent
modifier|*
name|localnet
decl_stmt|;
name|struct
name|sockaddr_in
name|masteraddr
decl_stmt|;
name|struct
name|tsp
name|resp
decl_stmt|,
name|conflict
decl_stmt|,
modifier|*
name|answer
decl_stmt|,
modifier|*
name|readmsg
argument_list|()
decl_stmt|,
modifier|*
name|acksend
argument_list|()
decl_stmt|;
name|long
name|casual
parameter_list|()
function_decl|;
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|strcpy
argument_list|()
decl_stmt|;
name|char
modifier|*
name|date
parameter_list|()
function_decl|;
name|int
name|n
decl_stmt|;
name|int
name|n_addrlen
decl_stmt|;
name|char
modifier|*
name|n_addr
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ifreq
decl_stmt|,
modifier|*
name|ifr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|Mflag
operator|=
literal|0
expr_stmt|;
name|on
operator|=
literal|1
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
name|fj
operator|=
literal|"/usr/adm/timed.log"
expr_stmt|;
name|trace
operator|=
name|OFF
expr_stmt|;
name|nflag
operator|=
name|OFF
expr_stmt|;
name|openlog
argument_list|(
literal|"timed"
argument_list|,
name|LOG_ODELAY
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Timed: not superuser\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
operator|(
operator|*
name|argv
operator|)
operator|++
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'M'
case|:
name|Mflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|trace
operator|=
name|ON
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
name|nflag
operator|=
name|ON
expr_stmt|;
name|netname
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
operator|*
operator|(
operator|++
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
operator|)
condition|)
empty_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"timed: -%c: unknown option\n"
argument_list|,
operator|*
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
operator|++
operator|(
operator|*
name|argv
operator|)
condition|)
do|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|10
condition|;
name|s
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|s
argument_list|,
operator|(
name|int
operator|)
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|trace
operator|==
name|ON
condition|)
block|{
name|fd
operator|=
name|fopen
argument_list|(
name|fj
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Tracing started on: %s\n\n"
argument_list|,
name|date
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|openlog
argument_list|(
literal|"timed"
argument_list|,
name|LOG_ODELAY
operator||
name|LOG_CONS
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|srvp
operator|=
name|getservbyname
argument_list|(
literal|"timed"
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|srvp
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"unknown service 'timed/udp'"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|sin_port
operator|=
name|srvp
operator|->
name|s_port
expr_stmt|;
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsockopt: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"server already running"
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* choose a unique seed for random number generation */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|seed
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|time
operator|.
name|tv_usec
expr_stmt|;
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|casual
argument_list|(
operator|(
name|long
operator|)
literal|1
argument_list|,
operator|(
name|long
operator|)
name|MAXSEQ
argument_list|)
expr_stmt|;
comment|/* initial seq number */
comment|/* rounds kernel variable time to multiple of 5 ms. */
name|time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|time
operator|.
name|tv_usec
operator|=
operator|-
operator|(
operator|(
name|time
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|%
literal|5
operator|)
operator|*
literal|1000
expr_stmt|;
operator|(
name|void
operator|)
name|adjtime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|id
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gethostname: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hp
index|[
literal|0
index|]
operator|.
name|name
operator|=
name|hostname
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
block|{
name|localnet
operator|=
name|getnetbyname
argument_list|(
name|netname
argument_list|)
expr_stmt|;
if|if
condition|(
name|localnet
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getnetbyname: unknown net %s"
argument_list|,
name|netname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
operator|(
name|int
operator|)
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface configuration: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
expr_stmt|;
for|for
control|(
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
init|;
name|n
operator|>
literal|0
condition|;
name|n
operator|--
operator|,
name|ifr
operator|++
control|)
block|{
name|ifreq
operator|=
operator|*
name|ifr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
operator|(
name|int
operator|)
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get interface flags: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifreq
operator|.
name|ifr_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
operator|(
name|int
operator|)
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get broadaddr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|netmask
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sock
argument_list|,
operator|(
name|int
operator|)
name|SIOCGIFBRDADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"get broadaddr: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|n_addrlen
operator|=
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_addr
argument_list|)
expr_stmt|;
name|n_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|n_addrlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifreq
operator|.
name|ifr_broadaddr
argument_list|,
name|n_addr
argument_list|,
name|n_addrlen
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|n_addr
expr_stmt|;
name|broadcastaddr
operator|=
name|sin
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
block|{
name|u_long
name|addr
decl_stmt|,
name|mask
decl_stmt|;
name|addr
operator|=
name|ntohl
argument_list|(
name|broadcastaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ntohl
argument_list|(
name|netmask
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|mask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|>>=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|!=
name|localnet
operator|->
name|n_net
condition|)
continue|continue;
block|}
name|mynet
operator|=
name|netmask
operator|&
name|broadcastaddr
operator|.
name|s_addr
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|mynet
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No network usable"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* us. delay to be used in response to broadcast */
name|delay1
operator|=
name|casual
argument_list|(
operator|(
name|long
operator|)
literal|10000
argument_list|,
literal|200000
argument_list|)
expr_stmt|;
comment|/* election timer delay in secs. */
name|delay2
operator|=
name|casual
argument_list|(
operator|(
name|long
operator|)
name|MINTOUT
argument_list|,
operator|(
name|long
operator|)
name|MAXTOUT
argument_list|)
expr_stmt|;
comment|/* look for master */
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_MASTERREQ
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|answer
operator|=
name|acksend
argument_list|(
operator|&
name|resp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
name|TSP_MASTERACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|MASTER
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|SLAVE
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mastername
argument_list|,
name|answer
operator|->
name|tsp_name
argument_list|)
expr_stmt|;
name|masteraddr
operator|=
name|from
expr_stmt|;
comment|/* 		 * If network has been partitioned, there might be other 		 * masters; tell the one we have just acknowledged that  		 * it has to gain control over the others.  		 */
name|time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|time
operator|.
name|tv_usec
operator|=
literal|300000
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERACK
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
comment|/* 		 * checking also not to send CONFLICT to ack'ed master 		 * due to duplicated MASTERACKs 		 */
if|if
condition|(
name|answer
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|answer
operator|->
name|tsp_name
argument_list|,
name|mastername
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|conflict
operator|.
name|tsp_type
operator|=
name|TSP_CONFLICT
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|conflict
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|server
operator|=
name|masteraddr
expr_stmt|;
if|if
condition|(
name|acksend
argument_list|(
operator|&
name|conflict
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mastername
argument_list|,
name|TSP_ACK
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"error on sending TSP_CONFLICT"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|Mflag
condition|)
block|{
comment|/* open raw socket used to measure time differences */
name|sock_raw
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock_raw
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"opening raw socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * number (increased by 1) of slaves controlled by master:  		 * used in master.c, candidate.c, networkdelta.c, and  		 * correct.c  		 */
name|slvcount
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Various conditions can cause conflict: race between 		 * two just started timedaemons when no master is present, 		 * or timedaemon started during an election. 		 * Conservative approach is taken: give up and became a 		 * slave postponing election of a master until first 		 * timer expires. 		 */
if|if
condition|(
name|status
operator|==
name|MASTER
condition|)
block|{
name|time
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERREQ
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|SLAVE
expr_stmt|;
goto|goto
name|startd
goto|;
block|}
name|time
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_MASTERUP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
condition|)
block|{
name|status
operator|=
name|SLAVE
expr_stmt|;
goto|goto
name|startd
goto|;
block|}
name|time
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|answer
operator|=
name|readmsg
argument_list|(
name|TSP_ELECTION
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ANYADDR
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|!=
name|NULL
condition|)
name|status
operator|=
name|SLAVE
expr_stmt|;
block|}
name|startd
label|:
name|ret
operator|=
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
comment|/* from slave */
name|status
operator|=
name|election
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* from master */
name|status
operator|=
name|SLAVE
expr_stmt|;
break|break;
default|default:
comment|/* this should not happen */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Attempt to enter invalid state"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|MASTER
condition|)
name|master
argument_list|()
expr_stmt|;
else|else
name|slave
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|SLAVE
expr_stmt|;
comment|/* if Mflag is not set timedaemon is forced to act as a slave */
if|if
condition|(
name|setjmp
argument_list|(
name|jmpenv
argument_list|)
condition|)
block|{
name|resp
operator|.
name|tsp_type
operator|=
name|TSP_SLAVEUP
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|resp
operator|.
name|tsp_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|broadcast
argument_list|(
operator|&
name|resp
argument_list|)
expr_stmt|;
block|}
name|slave
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * `casual' returns a random number in the range [inf, sup]  */
end_comment

begin_function
name|long
name|casual
parameter_list|(
name|inf
parameter_list|,
name|sup
parameter_list|)
name|long
name|inf
decl_stmt|;
name|long
name|sup
decl_stmt|;
block|{
name|float
name|value
decl_stmt|;
name|long
name|random
parameter_list|()
function_decl|;
name|value
operator|=
call|(
name|float
call|)
argument_list|(
name|random
argument_list|()
operator|&
literal|0x7fffffff
argument_list|)
operator|/
literal|0x7fffffff
expr_stmt|;
return|return
operator|(
name|inf
operator|+
operator|(
name|sup
operator|-
name|inf
operator|)
operator|*
name|value
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|date
parameter_list|()
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|asctime
parameter_list|()
function_decl|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|ret
operator|=
name|asctime
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ret
index|[
literal|19
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

