begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980 Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pstat.c	5.35 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Print system stuff  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/map.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
end_define

begin_define
define|#
directive|define
name|NFS
end_define

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SPPWAIT
end_ifdef

begin_define
define|#
directive|define
name|NEWVM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NEWVM
end_ifndef

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/pte.h>
end_include

begin_include
include|#
directive|include
file|<sys/text.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kinfo.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|mask
parameter_list|(
name|x
parameter_list|)
value|(x&0377)
end_define

begin_define
define|#
directive|define
name|clear
parameter_list|(
name|x
parameter_list|)
value|((int)x&~ KERNBASE)
end_define

begin_decl_stmt
name|char
modifier|*
name|fnlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fcore
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|SWAPMAP
value|0
block|{
literal|"_swapmap"
block|}
block|,
define|#
directive|define
name|SNSWAPMAP
value|1
block|{
literal|"_nswapmap"
block|}
block|,
define|#
directive|define
name|SDMMIN
value|2
block|{
literal|"_dmmin"
block|}
block|,
define|#
directive|define
name|SDMMAX
value|3
block|{
literal|"_dmmax"
block|}
block|,
define|#
directive|define
name|SNSWDEV
value|4
block|{
literal|"_nswdev"
block|}
block|,
define|#
directive|define
name|SSWDEVT
value|5
block|{
literal|"_swdevt"
block|}
block|,
ifdef|#
directive|ifdef
name|NEWVM
define|#
directive|define
name|NLMANDATORY
value|SSWDEVT
comment|/* names up to here are mandatory */
else|#
directive|else
define|#
directive|define
name|STEXT
value|8
block|{
literal|"_text"
block|}
block|,
define|#
directive|define
name|SNTEXT
value|9
block|{
literal|"_ntext"
block|}
block|,
define|#
directive|define
name|SPROC
value|10
block|{
literal|"_proc"
block|}
block|,
define|#
directive|define
name|SNPROC
value|11
block|{
literal|"_nproc"
block|}
block|,
define|#
directive|define
name|NLMANDATORY
value|SNPROC
comment|/* names up to here are mandatory */
endif|#
directive|endif
define|#
directive|define
name|SCONS
value|NLMANDATORY + 1
block|{
literal|"_cons"
block|}
block|,
define|#
directive|define
name|SPTY
value|NLMANDATORY + 2
block|{
literal|"_pt_tty"
block|}
block|,
define|#
directive|define
name|SNPTY
value|NLMANDATORY + 3
block|{
literal|"_npty"
block|}
block|,
ifdef|#
directive|ifdef
name|vax
define|#
directive|define
name|SDZ
value|(SNPTY+1)
block|{
literal|"_dz_tty"
block|}
block|,
define|#
directive|define
name|SNDZ
value|(SNPTY+2)
block|{
literal|"_dz_cnt"
block|}
block|,
define|#
directive|define
name|SDMF
value|(SNPTY+3)
block|{
literal|"_dmf_tty"
block|}
block|,
define|#
directive|define
name|SNDMF
value|(SNPTY+4)
block|{
literal|"_ndmf"
block|}
block|,
define|#
directive|define
name|SDH
value|(SNPTY+5)
block|{
literal|"_dh11"
block|}
block|,
define|#
directive|define
name|SNDH
value|(SNPTY+6)
block|{
literal|"_ndh11"
block|}
block|,
define|#
directive|define
name|SDHU
value|(SNPTY+7)
block|{
literal|"_dhu_tty"
block|}
block|,
define|#
directive|define
name|SNDHU
value|(SNPTY+8)
block|{
literal|"_ndhu"
block|}
block|,
define|#
directive|define
name|SDMZ
value|(SNPTY+9)
block|{
literal|"_dmz_tty"
block|}
block|,
define|#
directive|define
name|SNDMZ
value|(SNPTY+10)
block|{
literal|"_ndmz"
block|}
block|,
define|#
directive|define
name|SQD
value|(SNPTY+11)
block|{
literal|"_qd_tty"
block|}
block|,
define|#
directive|define
name|SNQD
value|(SNPTY+12)
block|{
literal|"_nNQD"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tahoe
define|#
directive|define
name|SVX
value|(SNPTY+1)
block|{
literal|"_vx_tty"
block|}
block|,
define|#
directive|define
name|SNVX
value|(SNPTY+2)
block|{
literal|"_nvx"
block|}
block|,
define|#
directive|define
name|SMP
value|(SNPTY+3)
block|{
literal|"_mp_tty"
block|}
block|,
define|#
directive|define
name|SNMP
value|(SNPTY+4)
block|{
literal|"_nmp"
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
define|#
directive|define
name|SDCA
value|(SNPTY+1)
block|{
literal|"_dca_tty"
block|}
block|,
define|#
directive|define
name|SNDCA
value|(SNPTY+2)
block|{
literal|"_ndca"
block|}
block|,
define|#
directive|define
name|SDCM
value|(SNPTY+3)
block|{
literal|"_dcm_tty"
block|}
block|,
define|#
directive|define
name|SNDCM
value|(SNPTY+4)
block|{
literal|"_ndcm"
block|}
block|,
define|#
directive|define
name|SDCL
value|(SNPTY+5)
block|{
literal|"_dcl_tty"
block|}
block|,
define|#
directive|define
name|SNDCL
value|(SNPTY+6)
block|{
literal|"_ndcl"
block|}
block|,
define|#
directive|define
name|SITE
value|(SNPTY+7)
block|{
literal|"_ite_tty"
block|}
block|,
define|#
directive|define
name|SNITE
value|(SNPTY+8)
block|{
literal|"_nite"
block|}
block|,
endif|#
directive|endif
block|{
literal|""
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vnof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|txtf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prcf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ttyf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usrf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|upid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swpf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|totflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|partab
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cdevsw
name|cdevsw
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bdevsw
name|bdevsw
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nflg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|u_long
name|getword
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|off_t
name|mkphys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|Program
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|V
parameter_list|(
name|x
parameter_list|)
value|(void *)(x)
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|ret
decl_stmt|;
name|Program
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"TafvikptU:sxnu"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'T'
case|:
name|totflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|allflg
operator|++
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'p'
case|:
name|prcf
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|filf
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
case|case
literal|'i'
case|:
name|vnof
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ttyf
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|usrf
operator|++
expr_stmt|;
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|upid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|swpf
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|txtf
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nflg
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pstat: use [ -U pid ] for -u\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'?'
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: pstat -[Tafiptsx] [-U [pid]] [system] [core]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|fcore
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|fnlist
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|kvm_openfiles
argument_list|(
name|fnlist
argument_list|,
name|fcore
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"kvm_openfiles: %s"
argument_list|,
name|kvm_geterr
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|kvm_nlist
argument_list|(
name|nl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|quit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"kvm_nlist: %s"
argument_list|,
name|kvm_geterr
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NLMANDATORY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nl
index|[
name|i
index|]
operator|.
name|n_value
condition|)
block|{
name|quit
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"undefined symbol: %s\n"
argument_list|,
name|nl
index|[
name|i
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|quit
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|filf
operator||
name|totflg
operator||
name|vnof
operator||
name|prcf
operator||
name|txtf
operator||
name|ttyf
operator||
name|usrf
operator||
name|swpf
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pstat: one or more of -[aivxptfsU] is required\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filf
operator|||
name|totflg
condition|)
name|dofile
argument_list|()
expr_stmt|;
if|if
condition|(
name|vnof
operator|||
name|totflg
condition|)
name|dovnode
argument_list|()
expr_stmt|;
if|if
condition|(
name|prcf
operator|||
name|totflg
condition|)
name|doproc
argument_list|()
expr_stmt|;
if|if
condition|(
name|txtf
operator|||
name|totflg
condition|)
name|dotext
argument_list|()
expr_stmt|;
if|if
condition|(
name|ttyf
condition|)
name|dotty
argument_list|()
expr_stmt|;
if|if
condition|(
name|usrf
condition|)
name|dousr
argument_list|()
expr_stmt|;
if|if
condition|(
name|swpf
operator|||
name|totflg
condition|)
name|doswap
argument_list|()
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|e_vnode
block|{
name|struct
name|vnode
modifier|*
name|avnode
decl_stmt|;
name|struct
name|vnode
name|vnode
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|dovnode
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|e_vnode
modifier|*
name|e_vnodebase
decl_stmt|,
modifier|*
name|endvnode
decl_stmt|,
modifier|*
name|evp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|mount
modifier|*
name|maddr
init|=
name|NULL
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|int
name|numvnodes
decl_stmt|;
name|struct
name|e_vnode
modifier|*
name|loadvnodes
parameter_list|()
function_decl|;
name|struct
name|mount
modifier|*
name|getmnt
parameter_list|()
function_decl|;
name|e_vnodebase
operator|=
name|loadvnodes
argument_list|(
operator|&
name|numvnodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|totflg
condition|)
block|{
name|printf
argument_list|(
literal|"%7d vnodes\n"
argument_list|,
name|numvnodes
argument_list|)
expr_stmt|;
return|return;
block|}
name|endvnode
operator|=
name|e_vnodebase
operator|+
name|numvnodes
expr_stmt|;
name|printf
argument_list|(
literal|"%d active vnodes\n"
argument_list|,
name|numvnodes
argument_list|)
expr_stmt|;
define|#
directive|define
name|ST
value|mp->mnt_stat
for|for
control|(
name|evp
operator|=
name|e_vnodebase
init|;
name|evp
operator|<
name|endvnode
condition|;
name|evp
operator|++
control|)
block|{
name|vp
operator|=
operator|&
name|evp
operator|->
name|vnode
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|maddr
condition|)
block|{
comment|/* 			 * New filesystem 			 */
if|if
condition|(
operator|(
name|mp
operator|=
name|getmnt
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|maddr
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|mount_print
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vnode_header
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ST
operator|.
name|f_type
condition|)
block|{
case|case
name|MOUNT_UFS
case|:
case|case
name|MOUNT_MFS
case|:
name|ufs_header
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOUNT_NFS
case|:
name|nfs_header
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOUNT_NONE
case|:
case|case
name|MOUNT_PC
case|:
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|vnode_print
argument_list|(
name|evp
operator|->
name|avnode
argument_list|,
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ST
operator|.
name|f_type
condition|)
block|{
case|case
name|MOUNT_UFS
case|:
case|case
name|MOUNT_MFS
case|:
name|ufs_print
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUNT_NFS
case|:
name|nfs_print
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUNT_NONE
case|:
case|case
name|MOUNT_PC
case|:
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|e_vnodebase
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vnode_header
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"ADDR     TYP VFLAG  USE HOLD"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|vnode_print
argument_list|(
argument|avnode
argument_list|,
argument|vp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|avnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|type
decl_stmt|,
name|flags
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|fp
init|=
name|flags
decl_stmt|;
specifier|register
name|flag
expr_stmt|;
comment|/* 	 * set type 	 */
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VNON
case|:
name|type
operator|=
literal|"non"
expr_stmt|;
break|break;
case|case
name|VREG
case|:
name|type
operator|=
literal|"reg"
expr_stmt|;
break|break;
case|case
name|VDIR
case|:
name|type
operator|=
literal|"dir"
expr_stmt|;
break|break;
case|case
name|VBLK
case|:
name|type
operator|=
literal|"blk"
expr_stmt|;
break|break;
case|case
name|VCHR
case|:
name|type
operator|=
literal|"chr"
expr_stmt|;
break|break;
case|case
name|VLNK
case|:
name|type
operator|=
literal|"lnk"
expr_stmt|;
break|break;
case|case
name|VSOCK
case|:
name|type
operator|=
literal|"soc"
expr_stmt|;
break|break;
case|case
name|VFIFO
case|:
name|type
operator|=
literal|"fif"
expr_stmt|;
break|break;
case|case
name|VBAD
case|:
name|type
operator|=
literal|"bad"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"unk"
expr_stmt|;
break|break;
block|}
comment|/* 	 * gather flags 	 */
name|flag
operator|=
name|vp
operator|->
name|v_flag
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VROOT
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'R'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VTEXT
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'T'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VSYSTEM
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VXLOCK
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'L'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VXWANT
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'W'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VBWAIT
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'B'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|VALIASED
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
operator|*
name|fp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|fp
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * print it 	 */
name|printf
argument_list|(
literal|"%8x %s %5s %4d %4d"
argument_list|,
name|avnode
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|vp
operator|->
name|v_holdcnt
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ufs_header
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|" FILEID IFLAG RDEV|SZ"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|ufs_print
argument_list|(
argument|vp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|inode
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|char
name|flagbuf
index|[
literal|16
index|]
decl_stmt|,
modifier|*
name|flags
init|=
name|flagbuf
decl_stmt|;
specifier|register
name|flag
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
specifier|extern
name|char
modifier|*
name|devname
parameter_list|()
function_decl|;
name|flag
operator|=
name|ip
operator|->
name|i_flag
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|ILOCKED
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'L'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|IWANT
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'W'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|IRENAME
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'R'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|IUPD
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'U'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|IACC
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|ICHG
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'C'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|IMOD
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|ISHLOCK
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|IEXLOCK
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'E'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|ILWAIT
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'Z'
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|flags
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|" %6d %5s"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|,
name|flagbuf
argument_list|)
expr_stmt|;
name|type
operator|=
name|ip
operator|->
name|i_mode
operator|&
name|S_IFMT
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|S_IFCHR
operator|||
name|type
operator|==
name|S_IFBLK
condition|)
if|if
condition|(
name|nflg
operator|||
operator|(
operator|(
name|name
operator|=
name|devname
argument_list|(
name|ip
operator|->
name|i_rdev
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
name|printf
argument_list|(
literal|"   %2d,%-2d"
argument_list|,
name|major
argument_list|(
name|ip
operator|->
name|i_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|ip
operator|->
name|i_rdev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7d"
argument_list|,
name|ip
operator|->
name|i_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nfs_header
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|" FILEID NFLAG RDEV|SZ"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nfs_print
argument_list|(
argument|vp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|char
name|flagbuf
index|[
literal|16
index|]
decl_stmt|,
modifier|*
name|flags
init|=
name|flagbuf
decl_stmt|;
specifier|register
name|flag
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
specifier|extern
name|char
modifier|*
name|devname
parameter_list|()
function_decl|;
name|flag
operator|=
name|np
operator|->
name|n_flag
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|NLOCKED
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'L'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|NWANT
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'W'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|NMODIFIED
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|NWRITEERR
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'E'
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
operator|*
name|flags
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|flags
operator|=
literal|'\0'
expr_stmt|;
define|#
directive|define
name|VT
value|np->n_vattr
name|printf
argument_list|(
literal|" %6d %5s"
argument_list|,
name|VT
operator|.
name|va_fileid
argument_list|,
name|flagbuf
argument_list|)
expr_stmt|;
name|type
operator|=
name|VT
operator|.
name|va_mode
operator|&
name|S_IFMT
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|S_IFCHR
operator|||
name|type
operator|==
name|S_IFBLK
condition|)
if|if
condition|(
name|nflg
operator|||
operator|(
operator|(
name|name
operator|=
name|devname
argument_list|(
name|VT
operator|.
name|va_rdev
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
name|printf
argument_list|(
literal|"   %2d,%-2d"
argument_list|,
name|major
argument_list|(
name|VT
operator|.
name|va_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|VT
operator|.
name|va_rdev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %7d"
argument_list|,
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Given a pointer to a mount structure in kernel space,  * read it in and return a usable pointer to it.  */
end_comment

begin_function
name|struct
name|mount
modifier|*
name|getmnt
parameter_list|(
name|maddr
parameter_list|)
name|struct
name|mount
modifier|*
name|maddr
decl_stmt|;
block|{
specifier|static
struct|struct
name|mtab
block|{
name|struct
name|mtab
modifier|*
name|next
decl_stmt|;
name|struct
name|mount
modifier|*
name|maddr
decl_stmt|;
name|struct
name|mount
name|mount
decl_stmt|;
block|}
modifier|*
name|mhead
init|=
name|NULL
struct|;
specifier|register
name|struct
name|mtab
modifier|*
name|mt
decl_stmt|;
for|for
control|(
name|mt
operator|=
name|mhead
init|;
name|mt
operator|!=
name|NULL
condition|;
name|mt
operator|=
name|mt
operator|->
name|next
control|)
if|if
condition|(
name|maddr
operator|==
name|mt
operator|->
name|maddr
condition|)
return|return
operator|(
operator|&
name|mt
operator|->
name|mount
operator|)
return|;
if|if
condition|(
operator|(
name|mt
operator|=
operator|(
expr|struct
name|mtab
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mtab
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kvm_read
argument_list|(
name|V
argument_list|(
name|maddr
argument_list|)
argument_list|,
operator|&
name|mt
operator|->
name|mount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mount
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|mount
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't read mount table at %x"
argument_list|,
name|maddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mt
operator|->
name|maddr
operator|=
name|maddr
expr_stmt|;
name|mt
operator|->
name|next
operator|=
name|mhead
expr_stmt|;
name|mhead
operator|=
name|mt
expr_stmt|;
return|return
operator|(
operator|&
name|mt
operator|->
name|mount
operator|)
return|;
block|}
end_function

begin_macro
name|mount_print
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|type
init|=
literal|"unknown"
decl_stmt|;
specifier|register
name|flags
expr_stmt|;
define|#
directive|define
name|ST
value|mp->mnt_stat
name|printf
argument_list|(
literal|"*** MOUNT "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ST
operator|.
name|f_type
condition|)
block|{
case|case
name|MOUNT_NONE
case|:
name|type
operator|=
literal|"none"
expr_stmt|;
break|break;
case|case
name|MOUNT_UFS
case|:
name|type
operator|=
literal|"ufs"
expr_stmt|;
break|break;
case|case
name|MOUNT_NFS
case|:
name|type
operator|=
literal|"nfs"
expr_stmt|;
break|break;
case|case
name|MOUNT_MFS
case|:
name|type
operator|=
literal|"mfs"
expr_stmt|;
break|break;
case|case
name|MOUNT_PC
case|:
name|type
operator|=
literal|"pc"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s %s on %s"
argument_list|,
name|type
argument_list|,
name|ST
operator|.
name|f_mntfromname
argument_list|,
name|ST
operator|.
name|f_mntonname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|=
name|mp
operator|->
name|mnt_flag
condition|)
block|{
name|char
modifier|*
name|comma
init|=
literal|"("
decl_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* user visable flags */
if|if
condition|(
name|flags
operator|&
name|MNT_RDONLY
condition|)
block|{
name|printf
argument_list|(
literal|"%srdonly"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_RDONLY
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_SYNCHRONOUS
condition|)
block|{
name|printf
argument_list|(
literal|"%ssynchronous"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_SYNCHRONOUS
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_NOEXEC
condition|)
block|{
name|printf
argument_list|(
literal|"%snoexec"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_NOEXEC
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_NOSUID
condition|)
block|{
name|printf
argument_list|(
literal|"%snosuid"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_NOSUID
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_NODEV
condition|)
block|{
name|printf
argument_list|(
literal|"%snodev"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_NODEV
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_EXPORTED
condition|)
block|{
name|printf
argument_list|(
literal|"%sexport"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_EXPORTED
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_EXRDONLY
condition|)
block|{
name|printf
argument_list|(
literal|"%sexrdonly"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_EXRDONLY
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_LOCAL
condition|)
block|{
name|printf
argument_list|(
literal|"%slocal"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_QUOTA
condition|)
block|{
name|printf
argument_list|(
literal|"%squota"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_QUOTA
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
comment|/* filesystem control flags */
if|if
condition|(
name|flags
operator|&
name|MNT_UPDATE
condition|)
block|{
name|printf
argument_list|(
literal|"%supdate"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_UPDATE
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_MLOCK
condition|)
block|{
name|printf
argument_list|(
literal|"%slock"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_MLOCK
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_MWAIT
condition|)
block|{
name|printf
argument_list|(
literal|"%swait"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_MWAIT
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_MPBUSY
condition|)
block|{
name|printf
argument_list|(
literal|"%sbusy"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_MPBUSY
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_MPWANT
condition|)
block|{
name|printf
argument_list|(
literal|"%swant"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_MPWANT
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|MNT_UNMOUNT
condition|)
block|{
name|printf
argument_list|(
literal|"%sunmount"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|MNT_UNMOUNT
expr_stmt|;
name|comma
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|flags
condition|)
name|printf
argument_list|(
literal|"%sunknown_flags:%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ST
block|}
end_block

begin_function
name|struct
name|e_vnode
modifier|*
name|loadvnodes
parameter_list|(
name|avnodes
parameter_list|)
name|int
modifier|*
name|avnodes
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|copysize
decl_stmt|;
name|struct
name|e_vnode
modifier|*
name|vnodebase
decl_stmt|;
if|if
condition|(
name|fcore
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * add emulation of KINFO_VNODE here 		 */
name|error
argument_list|(
literal|"vnodes on dead kernel, not impl\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|getkerninfo
argument_list|(
name|KINFO_VNODE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syserror
argument_list|(
literal|"can't get estimate for kerninfo"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|copysize
operator|=
name|ret
expr_stmt|;
if|if
condition|(
operator|(
name|vnodebase
operator|=
operator|(
expr|struct
name|e_vnode
operator|*
operator|)
name|malloc
argument_list|(
name|copysize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ret
operator|=
name|getkerninfo
argument_list|(
name|KINFO_VNODE
argument_list|,
name|vnodebase
argument_list|,
operator|&
name|copysize
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syserror
argument_list|(
literal|"can't get vnode list"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copysize
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|e_vnode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"vnode size mismatch"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|avnodes
operator|=
name|copysize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|e_vnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|vnodebase
operator|)
return|;
block|}
end_function

begin_function
name|u_long
name|getword
parameter_list|(
name|loc
parameter_list|)
name|int
name|loc
decl_stmt|;
block|{
name|u_long
name|word
decl_stmt|;
name|kvm_read
argument_list|(
name|V
argument_list|(
name|loc
argument_list|)
argument_list|,
operator|&
name|word
argument_list|,
sizeof|sizeof
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|word
operator|)
return|;
block|}
end_function

begin_macro
name|putf
argument_list|(
argument|v
argument_list|,
argument|n
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dotext
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NEWVM
name|printf
argument_list|(
literal|"no text table in this system\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|struct
name|text
modifier|*
name|xp
decl_stmt|;
name|int
name|ntext
decl_stmt|;
name|struct
name|text
modifier|*
name|xtext
decl_stmt|,
modifier|*
name|atext
decl_stmt|;
name|int
name|ntx
decl_stmt|,
name|ntxca
decl_stmt|;
name|ntx
operator|=
name|ntxca
operator|=
literal|0
expr_stmt|;
name|ntext
operator|=
name|getword
argument_list|(
name|nl
index|[
name|SNTEXT
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|xtext
operator|=
operator|(
expr|struct
name|text
operator|*
operator|)
name|calloc
argument_list|(
name|ntext
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|atext
operator|=
operator|(
expr|struct
name|text
operator|*
operator|)
name|getword
argument_list|(
name|nl
index|[
name|STEXT
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntext
operator|<
literal|0
operator|||
name|ntext
operator|>
literal|10000
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"number of texts is preposterous (%d)\n"
argument_list|,
name|ntext
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xtext
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't allocate memory for text table\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|kvm_read
argument_list|(
name|atext
argument_list|,
name|xtext
argument_list|,
name|ntext
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|text
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|xtext
init|;
name|xp
operator|<
operator|&
name|xtext
index|[
name|ntext
index|]
condition|;
name|xp
operator|++
control|)
block|{
if|if
condition|(
name|xp
operator|->
name|x_vptr
operator|!=
name|NULL
condition|)
name|ntxca
operator|++
expr_stmt|;
if|if
condition|(
name|xp
operator|->
name|x_count
operator|!=
literal|0
condition|)
name|ntx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|totflg
condition|)
block|{
name|printf
argument_list|(
literal|"%3d/%3d texts active, %3d used\n"
argument_list|,
name|ntx
argument_list|,
name|ntext
argument_list|,
name|ntxca
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%d/%d active texts, %d used\n"
argument_list|,
name|ntx
argument_list|,
name|ntext
argument_list|,
name|ntxca
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\    LOC   FLAGS DADDR     CADDR  RSS SIZE     VPTR   CNT CCNT      FORW     BACK\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|xp
operator|=
name|xtext
init|;
name|xp
operator|<
operator|&
name|xtext
index|[
name|ntext
index|]
condition|;
name|xp
operator|++
control|)
block|{
if|if
condition|(
name|xp
operator|->
name|x_vptr
operator|==
name|NULL
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%8.1x"
argument_list|,
name|atext
operator|+
operator|(
name|xp
operator|-
name|xtext
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|putf
argument_list|(
name|xp
operator|->
name|x_flag
operator|&
name|XPAGV
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
name|putf
argument_list|(
name|xp
operator|->
name|x_flag
operator|&
name|XTRC
argument_list|,
literal|'T'
argument_list|)
expr_stmt|;
name|putf
argument_list|(
name|xp
operator|->
name|x_flag
operator|&
name|XWRIT
argument_list|,
literal|'W'
argument_list|)
expr_stmt|;
name|putf
argument_list|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOAD
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|putf
argument_list|(
name|xp
operator|->
name|x_flag
operator|&
name|XLOCK
argument_list|,
literal|'K'
argument_list|)
expr_stmt|;
name|putf
argument_list|(
name|xp
operator|->
name|x_flag
operator|&
name|XWANT
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5x"
argument_list|,
name|xp
operator|->
name|x_daddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%10x"
argument_list|,
name|xp
operator|->
name|x_caddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|xp
operator|->
name|x_rssize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|xp
operator|->
name|x_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%10.1x"
argument_list|,
name|xp
operator|->
name|x_vptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|xp
operator|->
name|x_count
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|xp
operator|->
name|x_ccount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%10x"
argument_list|,
name|xp
operator|->
name|x_forw
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%9x"
argument_list|,
name|xp
operator|->
name|x_back
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xtext
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|doproc
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|NEWVM
name|printf
argument_list|(
literal|"pstat: -p no longer supported (use ps)\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|xproc
decl_stmt|,
modifier|*
name|aproc
decl_stmt|;
name|int
name|nproc
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|loc
operator|,
name|np
expr_stmt|;
comment|/* 	struct pte apte; 	*/
name|nproc
operator|=
name|getword
argument_list|(
name|nl
index|[
name|SNPROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
name|xproc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|calloc
argument_list|(
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|aproc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|getword
argument_list|(
name|nl
index|[
name|SPROC
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nproc
operator|<
literal|0
operator|||
name|nproc
operator|>
literal|100000
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"number of procs is preposterous (%d)\n"
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xproc
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't allocate memory for proc table\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|kvm_read
argument_list|(
name|aproc
argument_list|,
name|xproc
argument_list|,
name|nproc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|xproc
init|;
name|pp
operator|<
operator|&
name|xproc
index|[
name|nproc
index|]
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_stat
condition|)
name|np
operator|++
expr_stmt|;
if|if
condition|(
name|totflg
condition|)
block|{
name|printf
argument_list|(
literal|"%3d/%3d processes\n"
argument_list|,
name|np
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%d/%d processes\n"
argument_list|,
name|np
argument_list|,
name|nproc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   LOC    S        F POIP PRI      SIG  UID SLP TIM  CPU  NI    PID   PPID    ADDR   RSS SRSS SIZE    WCHAN    LINK   TEXTP\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|xproc
init|;
name|pp
operator|<
operator|&
name|xproc
index|[
name|nproc
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_stat
operator|==
literal|0
operator|&&
name|allflg
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"%8x"
argument_list|,
name|aproc
operator|+
operator|(
name|pp
operator|-
name|xproc
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %2d"
argument_list|,
name|pp
operator|->
name|p_stat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %8x"
argument_list|,
name|pp
operator|->
name|p_flag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4d"
argument_list|,
name|pp
operator|->
name|p_poip
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d"
argument_list|,
name|pp
operator|->
name|p_pri
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %8x"
argument_list|,
name|pp
operator|->
name|p_sig
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4d"
argument_list|,
name|pp
operator|->
name|p_uid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d"
argument_list|,
name|pp
operator|->
name|p_slptime
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d"
argument_list|,
name|pp
operator|->
name|p_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4d"
argument_list|,
name|pp
operator|->
name|p_cpu
operator|&
literal|0377
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d"
argument_list|,
name|pp
operator|->
name|p_nice
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6d"
argument_list|,
name|pp
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %6d"
argument_list|,
name|pp
operator|->
name|p_ppid
argument_list|)
expr_stmt|;
comment|/*  		if (pp->p_flag& SLOAD) { 			kvm_read(pp->p_addr,&apte, sizeof(apte)); 			printf(" %8x", apte.pg_pfnum); 		} else 			printf(" %8x", pp->p_swaddr); 		*/
name|printf
argument_list|(
literal|" %4x"
argument_list|,
name|pp
operator|->
name|p_rssize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4x"
argument_list|,
name|pp
operator|->
name|p_swrss
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %5x"
argument_list|,
name|pp
operator|->
name|p_dsize
operator|+
name|pp
operator|->
name|p_ssize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %7x"
argument_list|,
name|clear
argument_list|(
name|pp
operator|->
name|p_wchan
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %7x"
argument_list|,
name|clear
argument_list|(
name|pp
operator|->
name|p_link
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %7x"
argument_list|,
name|clear
argument_list|(
name|pp
operator|->
name|p_textp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|xproc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
name|char
name|mesg
index|[]
init|=
literal|"  LINE RAW CAN OUT  HWT LWT     ADDR COL STATE  SESS  PGID DISC\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ttyspace
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
end_decl_stmt

begin_macro
name|dotty
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|(
name|tty
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|malloc
argument_list|(
name|ttyspace
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|tty
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pstat: out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|hp300
name|printf
argument_list|(
literal|"1 cons\n"
argument_list|)
expr_stmt|;
name|kvm_read
argument_list|(
name|V
argument_list|(
name|nl
index|[
name|SCONS
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tty
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
name|ttyprt
argument_list|(
operator|&
name|tty
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
if|if
condition|(
name|nl
index|[
name|SNQD
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|doqdss
argument_list|()
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDZ
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dz"
argument_list|,
name|SDZ
argument_list|,
name|SNDZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDH
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dh"
argument_list|,
name|SDH
argument_list|,
name|SNDH
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDMF
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dmf"
argument_list|,
name|SDMF
argument_list|,
name|SNDMF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDHU
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dhu"
argument_list|,
name|SDHU
argument_list|,
name|SNDHU
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDMZ
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dmz"
argument_list|,
name|SDMZ
argument_list|,
name|SNDMZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|tahoe
if|if
condition|(
name|nl
index|[
name|SNVX
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"vx"
argument_list|,
name|SVX
argument_list|,
name|SNVX
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNMP
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"mp"
argument_list|,
name|SMP
argument_list|,
name|SNMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hp300
if|if
condition|(
name|nl
index|[
name|SNITE
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"ite"
argument_list|,
name|SITE
argument_list|,
name|SNITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDCA
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dca"
argument_list|,
name|SDCA
argument_list|,
name|SNDCA
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDCM
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dcm"
argument_list|,
name|SDCM
argument_list|,
name|SNDCM
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
index|[
name|SNDCL
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"dcl"
argument_list|,
name|SDCL
argument_list|,
name|SNDCL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nl
index|[
name|SNPTY
index|]
operator|.
name|n_type
operator|!=
literal|0
condition|)
name|dottytype
argument_list|(
literal|"pty"
argument_list|,
name|SPTY
argument_list|,
name|SNPTY
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*   * Special case the qdss: there are 4 ttys per qdss,  * but only the first of each is used as a tty.    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|vax
end_ifdef

begin_macro
name|doqdss
argument_list|()
end_macro

begin_block
block|{
name|int
name|nqd
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|kvm_read
argument_list|(
name|V
argument_list|(
name|nl
index|[
name|SNQD
index|]
operator|.
name|n_value
argument_list|)
argument_list|,
operator|&
name|nqd
argument_list|,
sizeof|sizeof
argument_list|(
name|nqd
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d qd\n"
argument_list|,
name|nqd
argument_list|)
expr_stmt|;
name|kvm_read
argument_list|(
argument|(V(nl[SQD].n_value), tty, nqd * sizeof(struct tty) *
literal|4
argument|); 	printf(mesg); 	for (tp = tty; tp<&tty[nqd *
literal|4
argument|]; tp +=
literal|4
argument|) 		ttyprt(tp, tp - tty); }
endif|#
directive|endif
argument|dottytype(name, type, number) char *name; { 	int ntty; 	register struct tty *tp; 	extern char *realloc();  	if (tty == (struct tty *)
literal|0
argument|)  		return; 	kvm_read(V(nl[number].n_value),&ntty, sizeof(ntty)); 	printf(
literal|"%d %s lines\n"
argument|, ntty, name); 	if (ntty> ttyspace) { 		ttyspace = ntty; 		if ((tty = (struct tty *)realloc(tty, ttyspace * sizeof(*tty))) ==
literal|0
argument|) { 			printf(
literal|"pstat: out of memory\n"
argument|); 			return; 		} 	} 	kvm_read(V(nl[type].n_value), tty, ntty * sizeof(struct tty)); 	printf(mesg); 	for (tp = tty; tp<&tty[ntty]; tp++) 		ttyprt(tp, tp - tty); }  struct { 	int flag; 	char val; } ttystates[] = { 	TS_WOPEN
argument_list|,
literal|'W'
argument_list|,
argument|TS_ISOPEN
argument_list|,
literal|'O'
argument_list|,
argument|TS_CARR_ON
argument_list|,
literal|'C'
argument_list|,
argument|TS_TIMEOUT
argument_list|,
literal|'T'
argument_list|,
argument|TS_FLUSH
argument_list|,
literal|'F'
argument_list|,
argument|TS_BUSY
argument_list|,
literal|'B'
argument_list|,
argument|TS_ASLEEP
argument_list|,
literal|'A'
argument_list|,
argument|TS_XCLUDE
argument_list|,
literal|'X'
argument_list|,
argument|TS_TTSTOP
argument_list|,
literal|'S'
argument_list|,
argument|TS_TBLOCK
argument_list|,
literal|'K'
argument_list|,
argument|TS_RCOLL
argument_list|,
literal|'R'
argument_list|,
argument|TS_WCOLL
argument_list|,
literal|'I'
argument_list|,
comment|/* running short on letters ! */
argument|TS_ASYNC
argument_list|,
literal|'Y'
argument_list|,
argument|TS_BKSL
argument_list|,
literal|'D'
argument_list|,
argument|TS_ERASE
argument_list|,
literal|'E'
argument_list|,
argument|TS_LNCH
argument_list|,
literal|'L'
argument_list|,
argument|TS_TYPEN
argument_list|,
literal|'P'
argument_list|,
argument|TS_CNTTB
argument_list|,
literal|'N'
argument_list|,
literal|0
argument_list|,
literal|0
argument|};  ttyprt(atp, line) struct tty *atp; { 	register struct tty *tp; 	char state[
literal|20
argument|]; 	register i
argument_list|,
argument|j; 	char *name; 	extern char *devname(); 	pid_t pgid;  	tp = atp; 	if (nflg || tp->t_dev ==
literal|0
argument||| 	   (name = devname(tp->t_dev, S_IFCHR)) == NULL) 		printf(
literal|"%7d "
argument|, line);  	else 		printf(
literal|"%7s "
argument|, name); 	printf(
literal|"%2d %3d "
argument|, tp->t_rawq.c_cc, tp->t_canq.c_cc); 	printf(
literal|"%3d %4d %3d %8x %3d "
argument|, tp->t_outq.c_cc,  		tp->t_hiwat, tp->t_lowat, tp->t_addr, tp->t_col); 	for (i = j =
literal|0
argument|; ttystates[i].flag; i++) 		if (tp->t_state&ttystates[i].flag) 			state[j++] = ttystates[i].val; 	if (j ==
literal|0
argument|) 		state[j++] =
literal|'-'
argument|; 	state[j] =
literal|'\0'
argument|; 	printf(
literal|"%-4s %6x"
argument|, state, (u_long)tp->t_session& ~KERNBASE); 	if (tp->t_pgrp == NULL || kvm_read(&tp->t_pgrp->pg_id,&pgid,  	    sizeof (pid_t)) != sizeof (pid_t)) 		pgid =
literal|0
argument|; 	printf(
literal|"%6d "
argument|, pgid); 	switch (tp->t_line) {  	case TTYDISC: 		printf(
literal|"term\n"
argument|); 		break;  	case TABLDISC: 		printf(
literal|"tab\n"
argument|); 		break;  	case SLIPDISC: 		printf(
literal|"slip\n"
argument|); 		break;  	default: 		printf(
literal|"%d\n"
argument|, tp->t_line); 	} }
comment|/*  * The user structure is going away.  What's left here won't  * be around for long.  */
argument|dousr() {
ifdef|#
directive|ifdef
name|NEWVM
argument|printf(
literal|"nothing left in user structure in this system\n"
argument|);
else|#
directive|else
argument|register struct user *up; 	register i
argument_list|,
argument|j
argument_list|,
argument|*ip; 	register struct nameidata *nd; 	struct proc *p; 	int ret;  	if ((ret = kvm_getprocs(KINFO_PROC_PID, upid)) !=
literal|1
argument|) { 		if (ret == -
literal|1
argument|) 			error(
literal|"kvm_getproc: %s"
argument|, kvm_geterr()); 		else 			error(
literal|"can't locate process %d"
argument|, upid); 		return (
literal|1
argument|); 	} 	if ((p = kvm_nextproc()) == NULL) { 		error(
literal|"kvm_nextproc: %s"
argument|, kvm_geterr()); 		return (
literal|1
argument|); 	} 	if ((up = kvm_getu(p)) == NULL) { 		error(
literal|"kvm_getu: %s"
argument|, kvm_geterr()); 		return (
literal|1
argument|); 	} 	nd =&up->u_nd; 	printf(
literal|"pcb"
argument|); 	ip = (int *)&up->u_pcb; 	i =
literal|0
argument|; 	while (ip< (int *)((char *)&up->u_pcb + sizeof (struct pcb))) { 		if (i%
literal|4
argument|==
literal|0
argument|) 			putchar(
literal|'\t'
argument|); 		printf(
literal|"%#10x "
argument|, *ip++); 		if (i%
literal|4
argument|==
literal|3
argument|) 			putchar(
literal|'\n'
argument|); 		i++; 	} 	if (i%
literal|4
argument|) 		putchar(
literal|'\n'
argument|); 	printf(
literal|"procp\t%#x\n"
argument|, up->u_procp); 	printf(
literal|"ar0\t%#x\n"
argument|, up->u_ar0); 	printf(
literal|"sizes\ttext %d data %d stack %d\n"
argument|,  		up->u_tsize, up->u_dsize, up->u_ssize); 	printf(
literal|"ssave"
argument|); 	for (i=
literal|0
argument|; i<sizeof(label_t)/sizeof(int); i++) { 		if (i%
literal|5
argument|==
literal|0
argument|) 			printf(
literal|"\t"
argument|); 		printf(
literal|"%#11x"
argument|, up->u_ssave.val[i]); 		if (i%
literal|5
argument|==
literal|4
argument|) 			printf(
literal|"\n"
argument|); 	} 	if (i%
literal|5
argument|) 		printf(
literal|"\n"
argument|); 	printf(
literal|"odsize\t%#x\n"
argument|, up->u_odsize); 	printf(
literal|"ossize\t%#x\n"
argument|, up->u_ossize); 	printf(
literal|"outime\t%d\n"
argument|, up->u_outime); 	printf(
literal|"mmap\t%#x\n"
argument|, up->u_mmap); 	printf(
literal|"sigs"
argument|); 	for (i=
literal|0
argument|; i<NSIG; i++) { 		if (i %
literal|8
argument|==
literal|0
argument|) 			printf(
literal|"\t"
argument|); 		printf(
literal|"%#x "
argument|, up->u_signal[i]); 		if (i %
literal|8
argument|==
literal|7
argument|) 			printf(
literal|"\n"
argument|); 	} 	if (i %
literal|8
argument|) 		printf(
literal|"\n"
argument|); 	printf(
literal|"sigmask"
argument|); 	for (i=
literal|0
argument|; i<NSIG; i++) { 		if (i %
literal|8
argument|==
literal|0
argument|) 			printf(
literal|"\t"
argument|); 		printf(
literal|"%#x "
argument|, up->u_sigmask[i]); 		if (i %
literal|8
argument|==
literal|7
argument|) 			printf(
literal|"\n"
argument|); 	} 	if (i %
literal|8
argument|) 		printf(
literal|"\n"
argument|); 	printf(
literal|"sigonstack\t%#x\n"
argument|, up->u_sigonstack); 	printf(
literal|"sigintr\t%#x\n"
argument|, up->u_sigintr); 	printf(
literal|"oldmask\t%#x\n"
argument|, up->u_oldmask); 	printf(
literal|"sigstack\t%#x %#x\n"
argument|,  		up->u_sigstack.ss_sp, up->u_sigstack.ss_onstack); 	printf(
literal|"sig\t%#x\n"
argument|, up->u_sig); 	printf(
literal|"code\t%#x\n"
argument|, up->u_code); 	printf(
literal|"start\t%ld secs %ld usecs\n"
argument|,  		up->u_start.tv_sec, up->u_start.tv_usec); 	printf(
literal|"acflag\t%#x\n"
argument|, up->u_acflag); 	printf(
literal|"prof\t%#x %#x %#x %#x\n"
argument|, up->u_prof.pr_base, up->u_prof.pr_size, 	    up->u_prof.pr_off, up->u_prof.pr_scale); 	printf(
literal|"ru\t"
argument|); 	ip = (int *)&up->u_ru; 	for (i =
literal|0
argument|; i< sizeof(up->u_ru)/sizeof(int); i++) 		printf(
literal|"%ld "
argument|, ip[i]); 	printf(
literal|"\n"
argument|); 	ip = (int *)&up->u_cru; 	printf(
literal|"cru\t"
argument|); 	for (i =
literal|0
argument|; i< sizeof(up->u_cru)/sizeof(int); i++) 		printf(
literal|"%ld "
argument|, ip[i]); 	printf(
literal|"\n"
argument|);
endif|#
directive|endif
argument|}  oatoi(s) char *s; { 	register v;  	v =
literal|0
argument|; 	while (*s) 		v = (v<<
literal|3
argument|) + *s++ -
literal|'0'
argument|; 	return(v); }  dofile() { 	register struct file *fp; 	struct file *addr; 	char *buf; 	int len
argument_list|,
argument|maxfile
argument_list|,
argument|nfile; 	struct nlist fnl[] = {
define|#
directive|define
name|FNL_NFILE
value|0
argument|{
literal|"_nfiles"
argument|}
argument_list|,
define|#
directive|define
name|FNL_MAXFILE
value|1
argument|{
literal|"_maxfiles"
argument|}
argument_list|,
argument|{
literal|""
argument|} 	}; 	static char *dtypes[] = {
literal|"???"
argument_list|,
literal|"inode"
argument_list|,
literal|"socket"
argument|};  	if (kvm_nlist(fnl) !=
literal|0
argument|) { 		error(
literal|"kvm_nlist: no _nfiles or _maxfiles: %s"
argument|,  			kvm_geterr()); 		return; 	} 	kvm_read(V(fnl[FNL_MAXFILE].n_value),&maxfile, 		sizeof (maxfile)); 	if (totflg) { 		kvm_read(V(fnl[FNL_NFILE].n_value),&nfile, sizeof (nfile)); 		printf(
literal|"%3d/%3d files\n"
argument|, nfile, maxfile); 		return; 	} 	if (getfiles(&buf,&len) == -
literal|1
argument|) 		return;
comment|/* 	 * getfiles returns in malloc'd buf a pointer to the first file 	 * structure, and then an array of file structs (whose 	 * addresses are derivable from the previous entry) 	 */
argument|addr = *((struct file **)buf); 	fp = (struct file *)(buf + sizeof (struct file *)); 	nfile = (len - sizeof (struct file *)) / sizeof (struct file); 	 	printf(
literal|"%d/%d open files\n"
argument|, nfile, maxfile); 	printf(
literal|"   LOC   TYPE    FLG     CNT  MSG    DATA    OFFSET\n"
argument|); 	for (; (char *)fp< buf + len; addr = fp->f_filef, fp++) { 		printf(
literal|"%x "
argument|, addr); 		if (fp->f_type<= DTYPE_SOCKET) 			printf(
literal|"%-8.8s"
argument|, dtypes[fp->f_type]); 		else 			printf(
literal|"%8d"
argument|, fp->f_type); 		putf(fp->f_flag&FREAD,
literal|'R'
argument|); 		putf(fp->f_flag&FWRITE,
literal|'W'
argument|); 		putf(fp->f_flag&FAPPEND,
literal|'A'
argument|);
ifdef|#
directive|ifdef
name|FSHLOCK
comment|/* currently gone */
argument|putf(fp->f_flag&FSHLOCK,
literal|'S'
argument|); 		putf(fp->f_flag&FEXLOCK,
literal|'X'
argument|);
else|#
directive|else
argument|putf(
literal|0
argument|,
literal|' '
argument|); 		putf(
literal|0
argument|,
literal|' '
argument|);
endif|#
directive|endif
argument|putf(fp->f_flag&FASYNC,
literal|'I'
argument|); 		printf(
literal|"  %3d"
argument|, fp->f_count); 		printf(
literal|"  %3d"
argument|, fp->f_msgcount); 		printf(
literal|"  %8.1x"
argument|, fp->f_data); 		if (fp->f_offset<
literal|0
argument|) 			printf(
literal|"  %x\n"
argument|, fp->f_offset); 		else 			printf(
literal|"  %ld\n"
argument|, fp->f_offset); 	} 	free(buf); }  getfiles(abuf, alen) 	char **abuf; 	int *alen; { 	char *buf; 	int len;  	if (fcore != NULL) {
comment|/* 		 * add emulation of KINFO_FILE here 		 */
argument|error(
literal|"files on dead kernel, not impl\n"
argument|); 		exit(
literal|1
argument|); 	} 	if ((len = getkerninfo(KINFO_FILE, NULL, NULL,
literal|0
argument|)) == -
literal|1
argument|) { 		syserror(
literal|"getkerninfo estimate"
argument|); 		return (-
literal|1
argument|); 	} 	if ((buf = (char *)malloc(len)) == NULL) { 		error(
literal|"out of memory"
argument|); 		return (-
literal|1
argument|); 	} 	if ((len = getkerninfo(KINFO_FILE, buf,&len,
literal|0
argument|)) == -
literal|1
argument|) { 		syserror(
literal|"getkerninfo"
argument|); 		return (-
literal|1
argument|); 	} 	*abuf = buf; 	*alen = len; 	return (
literal|0
argument|); }
ifdef|#
directive|ifdef
name|NEWVM
argument|doswap() { 	printf(
literal|"swap statistics not yet supported in this system\n"
argument|); }
else|#
directive|else
comment|/* NEWVM */
argument|int dmmin
argument_list|,
argument|dmmax
argument_list|,
argument|nswdev;  doswap() { 	struct proc *proc; 	int nproc; 	struct text *xtext; 	int ntext; 	struct map *swapmap; 	int nswapmap; 	struct swdevt *swdevt
argument_list|,
argument|*sw; 	register struct proc *pp; 	int nswap
argument_list|,
argument|used
argument_list|,
argument|tused
argument_list|,
argument|free
argument_list|,
argument|waste; 	int db
argument_list|,
argument|sb; 	register struct mapent *me; 	register struct text *xp; 	int i
argument_list|,
argument|j; 	long rmalloc();  	nproc = getword(nl[SNPROC].n_value); 	ntext = getword(nl[SNTEXT].n_value); 	if (nproc<
literal|0
argument||| nproc>
literal|10000
argument||| ntext<
literal|0
argument||| ntext>
literal|10000
argument|) { 		fprintf(stderr,
literal|"number of procs/texts is preposterous (%d, %d)\n"
argument|, 			nproc, ntext); 		return; 	} 	proc = (struct proc *)calloc(nproc, sizeof (struct proc)); 	if (proc == NULL) { 		fprintf(stderr,
literal|"can't allocate memory for proc table\n"
argument|); 		exit(
literal|1
argument|); 	} 	xtext = (struct text *)calloc(ntext, sizeof (struct text)); 	if (xtext == NULL) { 		fprintf(stderr,
literal|"can't allocate memory for text table\n"
argument|); 		exit(
literal|1
argument|); 	} 	nswapmap = getword(nl[SNSWAPMAP].n_value); 	swapmap = (struct map *)calloc(nswapmap, sizeof (struct map)); 	if (swapmap == NULL) { 		fprintf(stderr,
literal|"can't allocate memory for swapmap\n"
argument|); 		exit(
literal|1
argument|); 	} 	nswdev = getword(nl[SNSWDEV].n_value); 	swdevt = (struct swdevt *)calloc(nswdev, sizeof (struct swdevt)); 	if (swdevt == NULL) { 		fprintf(stderr,
literal|"can't allocate memory for swdevt table\n"
argument|); 		exit(
literal|1
argument|); 	} 	kvm_read(V(nl[SSWDEVT].n_value), swdevt, 		nswdev * sizeof (struct swdevt)); 	kvm_read(V(getword(nl[SPROC].n_value)), proc, 		nproc * sizeof (struct proc)); 	kvm_read(V(getword(nl[STEXT].n_value)), xtext, 		ntext * sizeof (struct text)); 	kvm_read(V(getword(nl[SWAPMAP].n_value)), swapmap, 		nswapmap * sizeof (struct map));  	swapmap->m_name =
literal|"swap"
argument|; 	swapmap->m_limit = (struct mapent *)&swapmap[nswapmap]; 	dmmin = getword(nl[SDMMIN].n_value); 	dmmax = getword(nl[SDMMAX].n_value); 	nswap =
literal|0
argument|; 	for (sw = swdevt; sw<&swdevt[nswdev]; sw++) 		if (sw->sw_freed) 			nswap += sw->sw_nblks; 	free =
literal|0
argument|; 	for (me = (struct mapent *)(swapmap+
literal|1
argument|); 	    me< (struct mapent *)&swapmap[nswapmap]; me++) 		free += me->m_size; 	tused =
literal|0
argument|; 	for (xp = xtext; xp<&xtext[ntext]; xp++) 		if (xp->x_vptr!=NULL) { 			tused += ctod(clrnd(xp->x_size)); 			if (xp->x_flag& XPAGV) 				tused += ctod(clrnd(ctopt(xp->x_size))); 		} 	used = tused; 	waste =
literal|0
argument|; 	for (pp = proc; pp<&proc[nproc]; pp++) { 		if (pp->p_stat ==
literal|0
argument||| pp->p_stat == SZOMB) 			continue; 		if (pp->p_flag& SSYS) 			continue; 		db = ctod(pp->p_dsize)
argument_list|,
argument|sb = up(db); 		used += sb; 		waste += sb - db; 		db = ctod(pp->p_ssize)
argument_list|,
argument|sb = up(db); 		used += sb; 		waste += sb - db; 		if ((pp->p_flag&SLOAD) ==
literal|0
argument|) 			used += ctod(vusize(pp)); 	} 	if (totflg) {
define|#
directive|define
name|btok
parameter_list|(
name|x
parameter_list|)
value|((x) / (1024 / DEV_BSIZE))
argument|printf(
literal|"%3d/%3d 00k swap\n"
argument|, 		    btok(used/
literal|100
argument|), btok((used+free)/
literal|100
argument|)); 		return; 	} 	printf(
literal|"%dk used (%dk text), %dk free, %dk wasted, %dk missing\n"
argument|, 	    btok(used), btok(tused), btok(free), btok(waste),
comment|/* a dmmax/2 block goes to argmap */
argument|btok(nswap - dmmax/
literal|2
argument|- (used + free))); 	printf(
literal|"avail: "
argument|); 	for (i = dmmax; i>= dmmin; i /=
literal|2
argument|) { 		j =
literal|0
argument|; 		while (rmalloc(swapmap, i) !=
literal|0
argument|) 			j++; 		if (j) printf(
literal|"%d*%dk "
argument|, j, btok(i)); 	} 	free =
literal|0
argument|; 	for (me = (struct mapent *)(swapmap+
literal|1
argument|); 	    me< (struct mapent *)&swapmap[nswapmap]; me++) 		free += me->m_size; 	printf(
literal|"%d*1k\n"
argument|, btok(free)); }  up(size) 	register int size; { 	register int i
argument_list|,
argument|block;  	i =
literal|0
argument|; 	block = dmmin; 	while (i< size) { 		i += block; 		if (block< dmmax) 			block *=
literal|2
argument|; 	} 	return (i); }
comment|/*  * Compute number of pages to be allocated to the u. area  * and data and stack area page tables, which are stored on the  * disk immediately after the u. area.  */
argument|vusize(p) 	register struct proc *p; { 	register int tsz = p->p_tsize / NPTEPG;
comment|/* 	 * We do not need page table space on the disk for page 	 * table pages wholly containing text.  	 */
argument|return (clrnd(UPAGES + 	    clrnd(ctopt(p->p_tsize+p->p_dsize+p->p_ssize+UPAGES)) - tsz)); }
comment|/*  * Allocate 'size' units from the given  * map. Return the base of the allocated space.  * In a map, the addresses are increasing and the  * list is terminated by a 0 size.  *  * Algorithm is first-fit.  *  * This routine knows about the interleaving of the swapmap  * and handles that.  */
argument|long rmalloc(mp, size) 	register struct map *mp; 	long size; { 	register struct mapent *ep = (struct mapent *)(mp+
literal|1
argument|); 	register int addr; 	register struct mapent *bp; 	swblk_t first
argument_list|,
argument|rest;  	if (size<=
literal|0
argument||| size> dmmax) 		return (
literal|0
argument|);
comment|/* 	 * Search for a piece of the resource map which has enough 	 * free space to accomodate the request. 	 */
argument|for (bp = ep; bp->m_size; bp++) { 		if (bp->m_size>= size) {
comment|/* 			 * If allocating from swapmap, 			 * then have to respect interleaving 			 * boundaries. 			 */
argument|if (nswdev>
literal|1
argument|&& 			    (first = dmmax - bp->m_addr%dmmax)< bp->m_size) { 				if (bp->m_size - first< size) 					continue; 				addr = bp->m_addr + first; 				rest = bp->m_size - first - size; 				bp->m_size = first; 				if (rest) 					rmfree(mp, rest, addr+size); 				return (addr); 			}
comment|/* 			 * Allocate from the map. 			 * If there is no space left of the piece 			 * we allocated from, move the rest of 			 * the pieces to the left. 			 */
argument|addr = bp->m_addr; 			bp->m_addr += size; 			if ((bp->m_size -= size) ==
literal|0
argument|) { 				do { 					bp++; 					(bp-
literal|1
argument|)->m_addr = bp->m_addr; 				} while ((bp-
literal|1
argument|)->m_size = bp->m_size); 			} 			if (addr % CLSIZE) 				return (
literal|0
argument|); 			return (addr); 		} 	} 	return (
literal|0
argument|); }
comment|/*  * Free the previously allocated space at addr  * of size units into the specified map.  * Sort addr into map and combine on  * one or both ends if possible.  */
argument|rmfree(mp, size, addr) 	struct map *mp; 	long size
argument_list|,
argument|addr; { 	struct mapent *firstbp; 	register struct mapent *bp; 	register int t;
comment|/* 	 * Both address and size must be 	 * positive, or the protocol has broken down. 	 */
argument|if (addr<=
literal|0
argument||| size<=
literal|0
argument|) 		goto badrmfree;
comment|/* 	 * Locate the piece of the map which starts after the 	 * returned space (or the end of the map). 	 */
argument|firstbp = bp = (struct mapent *)(mp +
literal|1
argument|); 	for (; bp->m_addr<= addr&& bp->m_size !=
literal|0
argument|; bp++) 		continue;
comment|/* 	 * If the piece on the left abuts us, 	 * then we should combine with it. 	 */
argument|if (bp> firstbp&& (bp-
literal|1
argument|)->m_addr+(bp-
literal|1
argument|)->m_size>= addr) {
comment|/* 		 * Check no overlap (internal error). 		 */
argument|if ((bp-
literal|1
argument|)->m_addr+(bp-
literal|1
argument|)->m_size> addr) 			goto badrmfree;
comment|/* 		 * Add into piece on the left by increasing its size. 		 */
argument|(bp-
literal|1
argument|)->m_size += size;
comment|/* 		 * If the combined piece abuts the piece on 		 * the right now, compress it in also, 		 * by shifting the remaining pieces of the map over. 		 */
argument|if (bp->m_addr&& addr+size>= bp->m_addr) { 			if (addr+size> bp->m_addr) 				goto badrmfree; 			(bp-
literal|1
argument|)->m_size += bp->m_size; 			while (bp->m_size) { 				bp++; 				(bp-
literal|1
argument|)->m_addr = bp->m_addr; 				(bp-
literal|1
argument|)->m_size = bp->m_size; 			} 		} 		goto done; 	}
comment|/* 	 * Don't abut on the left, check for abutting on 	 * the right. 	 */
argument|if (addr+size>= bp->m_addr&& bp->m_size) { 		if (addr+size> bp->m_addr) 			goto badrmfree; 		bp->m_addr -= size; 		bp->m_size += size; 		goto done; 	}
comment|/* 	 * Don't abut at all.  Make a new entry 	 * and check for map overflow. 	 */
argument|do { 		t = bp->m_addr; 		bp->m_addr = addr; 		addr = t; 		t = bp->m_size; 		bp->m_size = size; 		bp++; 	} while (size = t);
comment|/* 	 * Segment at bp is to be the delimiter; 	 * If there is not room for it  	 * then the table is too full 	 * and we must discard something. 	 */
argument|if (bp+
literal|1
argument|> mp->m_limit) {
comment|/* 		 * Back bp up to last available segment. 		 * which contains a segment already and must 		 * be made into the delimiter. 		 * Discard second to last entry, 		 * since it is presumably smaller than the last 		 * and move the last entry back one. 		 */
argument|bp--; 		printf(
literal|"%s: rmap ovflo, lost [%d,%d)\n"
argument|, mp->m_name, 		    (bp-
literal|1
argument|)->m_addr, (bp-
literal|1
argument|)->m_addr+(bp-
literal|1
argument|)->m_size); 		bp[-
literal|1
argument|] = bp[
literal|0
argument|]; 		bp[
literal|0
argument|].m_size = bp[
literal|0
argument|].m_addr =
literal|0
argument|; 	} done: 	return; badrmfree: 	printf(
literal|"bad rmfree\n"
argument|); }
endif|#
directive|endif
comment|/* NEWVM */
include|#
directive|include
file|<varargs.h>
argument|error(va_alist) 	va_dcl { 	char *fmt; 	va_list ap; 	extern errno;  	fprintf(stderr,
literal|"%s: "
argument|, Program); 	va_start(ap); 	fmt = va_arg(ap, char *); 	(void) vfprintf(stderr, fmt, ap); 	va_end(ap); 	fprintf(stderr,
literal|"\n"
argument|); }  syserror(va_alist) 	va_dcl { 	char *fmt; 	va_list ap; 	extern errno;  	fprintf(stderr,
literal|"%s: "
argument|, Program); 	va_start(ap); 	fmt = va_arg(ap, char *); 	(void) vfprintf(stderr, fmt, ap); 	va_end(ap); 	fprintf(stderr,
literal|": %s\n"
argument|, strerror(errno)); }
end_block

end_unit

