begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)sliplogin.c	1.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from static char *sccsid = "@(#)sliplogin.c	1.3	MS/ACF	89/04/18"; */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * sliplogin.c  * [MUST BE RUN SUID, SLOPEN DOES A SUSER()!]  *  * This program initializes its own tty port to be an async TCP/IP interface.  * It merely sets up the SLIP module all by its lonesome on the STREAMS stack,  * initializes the network interface, and pauses forever waiting for hangup.  *  * It is a remote descendant of several similar programs with incestuous ties:  * - Kirk Smith's slipconf, modified by Richard Johnsson @ DEC WRL.  * - slattach, probably by Rick Adams but touched by countless hordes.  * - the original sliplogin for 4.2bsd, Doug Kingston the mover behind it.  * - a simple slattach-like program used to test the STREAMS SLIP code.  *  * There are three basic forms of usage:  *  * "sliplogin"  * Invoked simply as "sliplogin" and a realuid != 0, the program looks up  * the uid in /etc/passwd, and then the username in the file /etc/hosts.slip.  * If and entry is found, the line on fd0 is configured for SLIP operation  * as specified in the file.  *  * "sliplogin IPhost1</dev/ttyb"  * Invoked by root with a username, the name is looked up in the  * /etc/hosts.slip file and if found fd0 is configured as in case 1.  *  * "sliplogin 192.100.1.1 192.100.1.2 255.255.255.0< /dev/ttyb"  * Finally, if invoked with a remote addr, local addr, and optionally  * a net mask, the line on fd0 is setup as specified if the user is root.  *  * Doug Kingston 8810??		- logging + first pass at adding I_STR ioctl's  * Rayan Zachariassen 881011	- version for SunOS STREAMS SLIP  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_slvar.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ttyent.h>
end_include

begin_define
define|#
directive|define
name|SLIPIFNAME
value|"sl"
end_define

begin_define
define|#
directive|define
name|ADDR
value|1
end_define

begin_define
define|#
directive|define
name|MASK
value|2
end_define

begin_define
define|#
directive|define
name|DCD_CHECK_INTERVAL
value|0
end_define

begin_comment
comment|/* if> 0, time between automatic DCD checks */
end_comment

begin_define
define|#
directive|define
name|DCD_SETTLING_TIME
value|1
end_define

begin_comment
comment|/* time between DCD change and status check */
end_comment

begin_decl_stmt
name|int
name|gotalarm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|timeleft
init|=
name|DCD_CHECK_INTERVAL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIGDCD
argument_list|)
operator|&&
name|SIGDCD
operator|>
literal|0
end_if

begin_function
name|void
name|dcd_handler
parameter_list|()
block|{
if|#
directive|if
name|DCD_SETTLING_TIME
operator|>
literal|0
name|timeleft
operator|=
name|alarm
argument_list|(
name|DCD_SETTLING_TIME
argument_list|)
expr_stmt|;
else|#
directive|else
name|gotalarm
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* DCD_SETTLING_TIME */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DCD_CHECK_INTERVAL
operator|>
literal|0
end_if

begin_function
name|void
name|alarm_handler
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|SIGDCD
if|if
condition|(
name|timeleft
operator|>
name|DCD_SETTLING_TIME
condition|)
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|timeleft
operator|-
name|DCD_SETTLING_TIME
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* SIGDCD */
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|DCD_CHECK_INTERVAL
argument_list|)
expr_stmt|;
name|gotalarm
operator|=
literal|1
expr_stmt|;
name|timeleft
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use TIOCMGET to test if DCD is low on the port of the passed descriptor */
end_comment

begin_function
name|int
name|lowdcd
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|mbits
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCMGET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mbits
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
comment|/* port is dead, we die */
return|return
operator|!
operator|(
name|mbits
operator|&
name|TIOCM_CAR
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DCD_CHECK_INTERVAL> 0 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Accessfile
init|=
literal|"/etc/hosts.slip"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|ttyname
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|dstaddr
decl_stmt|,
modifier|*
name|localaddr
decl_stmt|,
modifier|*
name|netmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|slip_mode
decl_stmt|,
name|unit
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|slip_modes
block|{
name|char
modifier|*
name|sm_name
decl_stmt|;
name|int
name|sm_value
decl_stmt|;
block|}
name|modes
index|[]
init|=
block|{
literal|"normal"
block|,
literal|0
block|,
comment|/* slip "standard" ala Rick Adams */
literal|"compress"
block|,
name|SC_COMPRESS
block|,
comment|/* Van Jacobsen's tcp header comp. */
literal|"noicmp"
block|,
name|SC_NOICMP
block|,
comment|/* Sam's(?) ICMP suppression */
block|}
struct|;
end_struct

begin_function
name|void
name|hup_handler
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s%d: connection closed: process aborted, sig %d, remote %s\n"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|,
name|s
argument_list|,
name|dstaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"(hup) close: %m"
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"(hup) close completed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|s
decl_stmt|,
name|ldisc
decl_stmt|,
name|odisc
decl_stmt|;
name|struct
name|termios
name|tios
decl_stmt|,
name|otios
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|s
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|3
init|;
name|fd
operator|<
name|s
condition|;
name|fd
operator|++
control|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|openlog
argument_list|(
literal|"sliplogin"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s loginname\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"   or: %s dstaddr localaddr [mask]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|findid
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"local %s remote %s mask %s\n"
argument_list|,
name|localaddr
argument_list|,
name|dstaddr
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
operator|||
name|argc
operator|>
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s dstaddr localaddr [mask]\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dstaddr
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|localaddr
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|4
condition|)
name|netmask
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
else|else
name|netmask
operator|=
literal|"default"
expr_stmt|;
block|}
comment|/* 		 * Disassociate from current controlling terminal, if any, 		 * and ensure that the slip line is our controlling terminal. 		 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|BSD
operator|<
literal|198810
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCNOTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* open slip tty again to acquire as controlling tty? */
name|fd
operator|=
name|open
argument_list|(
name|ttyname
argument_list|(
literal|0
argument_list|)
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setsid
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* not sure this will work */
endif|#
directive|endif
block|}
else|else
name|findid
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fchmod
argument_list|(
literal|0
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
comment|/* set up the line parameters */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETA
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (TIOCGETA): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|otios
operator|=
name|tios
expr_stmt|;
name|tios
operator|.
name|c_cflag
operator|=
name|CS8
operator||
name|CREAD
operator||
name|HUPCL
expr_stmt|;
name|tios
operator|.
name|c_iflag
operator|=
name|IGNBRK
expr_stmt|;
name|tios
operator|.
name|c_oflag
operator|=
name|tios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETA
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (TIOCSETA) (1): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* find out what ldisc we started with */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|odisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCGETD) (1): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ldisc
operator|=
name|SLIPDISC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ldisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETD): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* find out what unit number we were assigned */
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|unit
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (TIOCGETD) (2): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"attaching %s%d: local %s remote %s mask %s\n"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|,
name|localaddr
argument_list|,
name|dstaddr
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* set the local and remote interface addresses */
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
operator|||
name|argc
operator|==
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
literal|"%s%d"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|in_getaddr
argument_list|(
name|netmask
argument_list|,
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|,
name|MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFNETMASK
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (SIOCSIFNETMASK): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
literal|"%s%d"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|in_getaddr
argument_list|(
name|dstaddr
argument_list|,
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|,
name|ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFDSTADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (SIOCSIFDSTADDR): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
literal|"%s%d"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|in_getaddr
argument_list|(
name|localaddr
argument_list|,
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|,
name|ADDR
argument_list|)
expr_stmt|;
comment|/* this has the side-effect of marking the interface up */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (SIOCSIFADDR): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* XXX -- give up for now and just invoke ifconfig XXX */
block|{
name|char
name|cmd
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"/sbin/ifconfig %s%d inet %s %s netmask %s"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|,
name|localaddr
argument_list|,
name|dstaddr
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|SLIOCSFLAGS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|slip_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (SLIOCSFLAGS): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set up signal handlers */
if|#
directive|if
name|defined
argument_list|(
name|SIGDCD
argument_list|)
operator|&&
name|SIGDCD
operator|>
literal|0
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGDCD
argument_list|,
name|dcd_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hup_handler
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|hup_handler
argument_list|)
expr_stmt|;
if|#
directive|if
name|DCD_CHECK_INTERVAL
operator|>
literal|0
comment|/* timeleft = 60 * 60 * 24 * 365 ; (void) alarm(timeleft); */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|alarm_handler
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|DCD_CHECK_INTERVAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* twiddle thumbs until we get a signal */
while|while
condition|(
literal|1
condition|)
block|{
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|DCD_CHECK_INTERVAL
operator|>
literal|0
operator|(
name|void
operator|)
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotalarm
operator|&&
name|lowdcd
argument_list|(
literal|0
argument_list|)
condition|)
break|break;
name|gotalarm
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* DCD_CHECK_INTERVAL> 0 */
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|lowdcd
argument_list|(
literal|0
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"connection closed: loss of carrier %s%d: remote %s\n"
argument_list|,
name|SLIPIFNAME
argument_list|,
name|unit
argument_list|,
name|dstaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|odisc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETD) (2): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETA
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|otios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl (TIOCSETA) (2): %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"close: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|findid
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
name|mode
index|[
literal|16
index|]
decl_stmt|;
specifier|static
name|char
name|laddr
index|[
literal|16
index|]
decl_stmt|;
specifier|static
name|char
name|raddr
index|[
literal|16
index|]
decl_stmt|;
specifier|static
name|char
name|mask
index|[
literal|16
index|]
decl_stmt|;
name|char
name|user
index|[
literal|16
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Your UID (%d) is unknown\n"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"UID (%d) is unknown\n"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|Accessfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|Accessfile
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m\n"
argument_list|,
name|Accessfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
name|n
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%15s%*[ \t]%15s%*[ \t]%15s%*[ \t]%15s%*[ \t]%15s\n"
argument_list|,
name|user
argument_list|,
name|mode
argument_list|,
name|laddr
argument_list|,
name|raddr
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
index|[
literal|0
index|]
operator|==
literal|'#'
operator|||
name|n
operator|!=
literal|5
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|user
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|val
decl_stmt|,
name|i
decl_stmt|,
name|domore
decl_stmt|;
name|p
operator|=
name|q
operator|=
name|mode
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|loop
label|:
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|ispunct
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ispunct
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|domore
operator|=
literal|1
expr_stmt|;
else|else
name|domore
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|slip_modes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|modes
index|[
name|i
index|]
operator|.
name|sm_name
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
name|val
operator||=
name|modes
index|[
name|i
index|]
operator|.
name|sm_value
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
name|q
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|domore
condition|)
goto|goto
name|loop
goto|;
block|}
name|slip_mode
operator|=
name|val
expr_stmt|;
name|localaddr
operator|=
name|laddr
expr_stmt|;
name|dstaddr
operator|=
name|raddr
expr_stmt|;
name|netmask
operator|=
name|mask
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
block|}
name|fputs
argument_list|(
literal|"SLIP access denied\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SLIP access denied for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|in_getaddr
argument_list|(
argument|s
argument_list|,
argument|saddr
argument_list|,
argument|which
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|saddr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|netent
modifier|*
name|np
decl_stmt|;
name|int
name|val
decl_stmt|;
specifier|extern
name|struct
name|in_addr
name|inet_makeaddr
parameter_list|()
function_decl|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|saddr
argument_list|,
sizeof|sizeof
expr|*
name|saddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|which
operator|==
name|ADDR
condition|)
block|{
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
block|}
else|else
name|sin
operator|->
name|sin_len
operator|=
literal|8
expr_stmt|;
name|val
operator|=
name|inet_addr
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
operator|-
literal|1
condition|)
block|{
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|val
expr_stmt|;
return|return;
block|}
name|hp
operator|=
name|gethostbyname
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
name|sin
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
return|return;
block|}
name|np
operator|=
name|getnetbyname
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|sin
operator|->
name|sin_family
operator|=
name|np
operator|->
name|n_addrtype
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|inet_makeaddr
argument_list|(
name|np
operator|->
name|n_net
argument_list|,
name|INADDR_ANY
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sliplogin: %s: bad value\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: bad value\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

