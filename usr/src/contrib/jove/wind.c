begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* This creates/deletes/divides/grows/shrinks windows.  */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_decl_stmt
name|private
name|char
name|onlyone
index|[]
init|=
literal|"You only have one window!"
decl_stmt|,
name|toosmall
index|[]
init|=
literal|"Resulting window would be too small."
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Window
modifier|*
name|curwind
decl_stmt|,
modifier|*
name|fwind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line in a Window */
end_comment

begin_function
name|int
name|FLine
parameter_list|(
name|w
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|wp
init|=
name|fwind
decl_stmt|;
specifier|register
name|int
name|lineno
init|=
operator|-
literal|1
decl_stmt|;
do|do
block|{
if|if
condition|(
name|wp
operator|==
name|w
condition|)
return|return
name|lineno
operator|+
literal|1
return|;
name|lineno
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
name|wp
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|wp
operator|!=
name|fwind
condition|)
do|;
name|complain
argument_list|(
literal|"window?"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* Delete `wp' from the screen.  If it is the only window left    on the screen, then complain.  It gives its body    to the next window if there is one, otherwise the previous    window gets the body.  */
end_comment

begin_function
name|void
name|del_wind
parameter_list|(
name|wp
parameter_list|)
specifier|register
name|Window
modifier|*
name|wp
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|prev
init|=
name|wp
operator|->
name|w_prev
decl_stmt|;
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|prev
operator|->
name|w_next
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|wp
operator|->
name|w_next
operator|->
name|w_prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|fwind
operator|==
name|wp
condition|)
block|{
name|fwind
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|fwind
operator|->
name|w_height
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
comment|/* Here try to do something intelligent for redisplay() */
name|SetTop
argument_list|(
name|fwind
argument_list|,
name|prev_line
argument_list|(
name|fwind
operator|->
name|w_top
argument_list|,
name|wp
operator|->
name|w_height
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curwind
operator|==
name|wp
condition|)
name|SetWind
argument_list|(
name|fwind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|w_height
operator|+=
name|wp
operator|->
name|w_height
expr_stmt|;
if|if
condition|(
name|curwind
operator|==
name|wp
condition|)
name|SetWind
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|RemoveScrollBar
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|Windchange
operator|++
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Divide the window WP N times, or at least once.  Complains if WP is too    small to be split into that many pieces.  It returns the new window. */
end_comment

begin_function
name|Window
modifier|*
name|div_wind
parameter_list|(
name|wp
parameter_list|,
name|n
parameter_list|)
specifier|register
name|Window
modifier|*
name|wp
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|new
decl_stmt|;
name|int
name|amt
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|amt
operator|=
name|wp
operator|->
name|w_height
operator|/
operator|(
name|n
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|amt
operator|<
literal|2
condition|)
name|complain
argument_list|(
name|toosmall
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
name|new
operator|=
operator|(
name|Window
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Window
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|w_flags
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|w_LRscroll
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|w_height
operator|=
name|amt
expr_stmt|;
name|wp
operator|->
name|w_height
operator|-=
name|amt
expr_stmt|;
comment|/* set the lines such that w_line is the center in 		   each Window */
name|new
operator|->
name|w_line
operator|=
name|wp
operator|->
name|w_line
expr_stmt|;
name|new
operator|->
name|w_char
operator|=
name|wp
operator|->
name|w_char
expr_stmt|;
name|new
operator|->
name|w_bufp
operator|=
name|wp
operator|->
name|w_bufp
expr_stmt|;
name|new
operator|->
name|w_top
operator|=
name|prev_line
argument_list|(
name|new
operator|->
name|w_line
argument_list|,
name|HALF
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Link the new window into the list */
name|new
operator|->
name|w_prev
operator|=
name|wp
expr_stmt|;
name|new
operator|->
name|w_next
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
name|new
operator|->
name|w_next
operator|->
name|w_prev
operator|=
name|new
expr_stmt|;
name|wp
operator|->
name|w_next
operator|=
name|new
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|new
operator|->
name|w_control
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MAC
name|Windchange
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Initialze the first window setting the bounds to the size of the    screen.  There is no buffer with this window.  See parse for the    setting of this window. */
end_comment

begin_function
name|void
name|winit
parameter_list|()
block|{
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
name|w
operator|=
name|curwind
operator|=
name|fwind
operator|=
operator|(
name|Window
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Window
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_line
operator|=
name|w
operator|->
name|w_top
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_LRscroll
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_flags
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
literal|0
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|w
operator|->
name|w_prev
operator|=
name|fwind
expr_stmt|;
name|w
operator|->
name|w_height
operator|=
name|ILI
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|w
operator|->
name|w_control
operator|=
literal|0
expr_stmt|;
name|Windchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Change to previous window. */
end_comment

begin_function
name|void
name|PrevWindow
parameter_list|()
block|{
specifier|register
name|Window
modifier|*
name|new
init|=
name|curwind
operator|->
name|w_prev
decl_stmt|;
if|if
condition|(
name|Asking
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make NEW the current Window */
end_comment

begin_function
name|void
name|SetWind
parameter_list|(
name|new
parameter_list|)
specifier|register
name|Window
modifier|*
name|new
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|Asking
operator|&&
name|curbuf
operator|!=
name|NULL
condition|)
block|{
comment|/* can you say kludge? */
name|curwind
operator|->
name|w_line
operator|=
name|curline
expr_stmt|;
name|curwind
operator|->
name|w_char
operator|=
name|curchar
expr_stmt|;
name|curwind
operator|->
name|w_bufp
operator|=
name|curbuf
expr_stmt|;
block|}
if|if
condition|(
name|new
operator|==
name|curwind
condition|)
return|return;
name|SetBuf
argument_list|(
name|new
operator|->
name|w_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inlist
argument_list|(
name|new
operator|->
name|w_bufp
operator|->
name|b_first
argument_list|,
name|new
operator|->
name|w_line
argument_list|)
condition|)
block|{
name|new
operator|->
name|w_line
operator|=
name|curline
expr_stmt|;
name|new
operator|->
name|w_char
operator|=
name|curchar
expr_stmt|;
block|}
name|DotTo
argument_list|(
name|new
operator|->
name|w_line
argument_list|,
name|new
operator|->
name|w_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
operator|>
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|linebuf
argument_list|)
condition|)
name|new
operator|->
name|w_char
operator|=
name|curchar
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
name|curwind
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* delete the current window if it isn't the only one left */
end_comment

begin_function
name|void
name|DelCurWindow
parameter_list|()
block|{
name|SetABuf
argument_list|(
name|curwind
operator|->
name|w_bufp
argument_list|)
expr_stmt|;
name|del_wind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put the current line of `w' in the middle of the window */
end_comment

begin_function
name|void
name|CentWind
parameter_list|(
name|w
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
block|{
name|SetTop
argument_list|(
name|w
argument_list|,
name|prev_line
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
name|HALF
argument_list|(
name|w
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|ScrollStep
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* full scrolling */
end_comment

begin_comment
comment|/* Calculate the new topline of the window.  If ScrollStep == 0    it means we should center the current line in the window. */
end_comment

begin_function
name|void
name|CalcWind
parameter_list|(
name|w
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
block|{
specifier|register
name|int
name|up
decl_stmt|;
name|int
name|scr_step
decl_stmt|;
name|Line
modifier|*
name|newtop
decl_stmt|;
if|if
condition|(
name|ScrollStep
operator|==
literal|0
condition|)
comment|/* Means just center it */
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
block|{
name|up
operator|=
name|inorder
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
literal|0
argument_list|,
name|w
operator|->
name|w_top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
operator|-
literal|1
condition|)
block|{
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
name|scr_step
operator|=
operator|(
name|ScrollStep
operator|<
literal|0
operator|)
condition|?
name|SIZE
argument_list|(
name|w
argument_list|)
operator|+
name|ScrollStep
else|:
name|ScrollStep
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|up
condition|)
comment|/* point is above the screen */
name|newtop
operator|=
name|prev_line
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
name|scr_step
argument_list|)
expr_stmt|;
else|else
name|newtop
operator|=
name|prev_line
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
operator|(
name|SIZE
argument_list|(
name|w
argument_list|)
operator|-
literal|1
operator|-
name|scr_step
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LineDist
argument_list|(
name|newtop
argument_list|,
name|w
operator|->
name|w_top
argument_list|)
operator|>=
name|SIZE
argument_list|(
name|w
argument_list|)
operator|-
literal|1
condition|)
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
else|else
name|SetTop
argument_list|(
name|w
argument_list|,
name|newtop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is bound to C-X 4 [BTF].  To make the screen stay the    same we have to remember various things, like the current    top line in the current window.  It's sorta gross, but it's    necessary because of the way this is implemented (i.e., in    terms of do_find(), do_select() which manipulate the windows. */
end_comment

begin_function
name|void
name|WindFind
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|obuf
init|=
name|curbuf
decl_stmt|,
modifier|*
name|nbuf
decl_stmt|;
name|Line
modifier|*
name|ltop
init|=
name|curwind
operator|->
name|w_top
decl_stmt|;
name|Bufpos
name|odot
decl_stmt|,
name|ndot
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|odot
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|waitchar
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
condition|)
block|{
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|FindTag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL
argument_list|(
literal|'T'
argument_list|)
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|FDotTag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|BufSelect
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|ExecCmd
argument_list|(
operator|(
name|data_obj
operator|*
operator|)
name|FindCmd
argument_list|(
name|FindFile
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
literal|"T: find-tag, ^T: find-tag-at-point, F: find-file, B: select-buffer."
argument_list|)
expr_stmt|;
block|}
name|nbuf
operator|=
name|curbuf
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|ndot
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|odot
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|ltop
argument_list|)
expr_stmt|;
comment|/* there! it's as if we did nothing */
if|if
condition|(
name|one_windp
argument_list|()
condition|)
operator|(
name|void
operator|)
name|div_wind
argument_list|(
name|curwind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tiewind
argument_list|(
name|curwind
operator|->
name|w_next
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|curwind
operator|->
name|w_next
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|ndot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go into one window mode by deleting all the other windows */
end_comment

begin_function
name|void
name|OneWindow
parameter_list|()
block|{
while|while
condition|(
name|curwind
operator|->
name|w_next
operator|!=
name|curwind
condition|)
name|del_wind
argument_list|(
name|curwind
operator|->
name|w_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Window
modifier|*
name|windbp
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|wp
init|=
name|fwind
decl_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
do|do
block|{
if|if
condition|(
name|wp
operator|->
name|w_bufp
operator|==
name|bp
condition|)
return|return
name|wp
return|;
name|wp
operator|=
name|wp
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|wp
operator|!=
name|fwind
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Change window into the next window.  Curwind becomes the new window. */
end_comment

begin_function
name|void
name|NextWindow
parameter_list|()
block|{
specifier|register
name|Window
modifier|*
name|new
init|=
name|curwind
operator|->
name|w_next
decl_stmt|;
if|if
condition|(
name|Asking
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scroll the next Window */
end_comment

begin_function
name|void
name|PageNWind
parameter_list|()
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
name|NextWindow
argument_list|()
expr_stmt|;
name|NextPage
argument_list|()
expr_stmt|;
name|PrevWindow
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Window
modifier|*
name|w_nam_typ
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf_exists
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|w
operator|=
name|fwind
expr_stmt|;
if|if
condition|(
name|b
condition|)
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|==
name|b
condition|)
return|return
name|w
return|;
block|}
do|while
condition|(
operator|(
name|w
operator|=
name|w
operator|->
name|w_next
operator|)
operator|!=
name|fwind
condition|)
do|;
name|w
operator|=
name|fwind
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|->
name|b_type
operator|==
name|type
condition|)
return|return
name|w
return|;
block|}
do|while
condition|(
operator|(
name|w
operator|=
name|w
operator|->
name|w_next
operator|)
operator|!=
name|fwind
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Put a window with the buffer `name' in it.  Erase the buffer if    `clobber' is non-zero. */
end_comment

begin_function
name|void
name|pop_wind
parameter_list|(
name|name
parameter_list|,
name|clobber
parameter_list|,
name|btype
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|clobber
decl_stmt|;
name|int
name|btype
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|wp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|newb
decl_stmt|;
if|if
condition|(
operator|(
name|newb
operator|=
name|buf_exists
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NIL
condition|)
name|btype
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* if the buffer exists, don't change 				   it's type */
if|if
condition|(
operator|(
name|wp
operator|=
name|w_nam_typ
argument_list|(
name|name
argument_list|,
name|btype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|SetWind
argument_list|(
name|div_wind
argument_list|(
name|curwind
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PrevWindow
argument_list|()
expr_stmt|;
block|}
else|else
name|SetWind
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|newb
operator|=
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|clobber
condition|)
block|{
name|initlist
argument_list|(
name|newb
argument_list|)
expr_stmt|;
name|newb
operator|->
name|b_modified
operator|=
name|NO
expr_stmt|;
block|}
name|tiewind
argument_list|(
name|curwind
argument_list|,
name|newb
argument_list|)
expr_stmt|;
if|if
condition|(
name|btype
operator|!=
operator|-
literal|1
condition|)
name|newb
operator|->
name|b_type
operator|=
name|btype
expr_stmt|;
name|SetBuf
argument_list|(
name|newb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|GrowWindow
parameter_list|()
block|{
name|WindSize
argument_list|(
name|curwind
argument_list|,
name|abs
argument_list|(
name|arg_value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ShrWindow
parameter_list|()
block|{
name|WindSize
argument_list|(
name|curwind
argument_list|,
operator|-
name|abs
argument_list|(
name|arg_value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the size of the window by inc.  First arg is the window,    second is the increment. */
end_comment

begin_function
name|void
name|WindSize
parameter_list|(
name|w
parameter_list|,
name|inc
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|int
name|inc
decl_stmt|;
block|{
if|if
condition|(
name|one_windp
argument_list|()
condition|)
name|complain
argument_list|(
name|onlyone
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|inc
operator|<
literal|0
condition|)
block|{
comment|/* Shrinking this Window. */
if|if
condition|(
name|w
operator|->
name|w_height
operator|+
name|inc
operator|<
literal|2
condition|)
name|complain
argument_list|(
name|toosmall
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_height
operator|+=
name|inc
expr_stmt|;
name|w
operator|->
name|w_prev
operator|->
name|w_height
operator|-=
name|inc
expr_stmt|;
block|}
else|else
block|{
comment|/* Growing the window. */
comment|/* Change made from original code so that growing a window 		   exactly offsets effect of shrinking a window, i.e. 		   doing either followed by the other restores original 		   sizes of all affected windows. */
if|if
condition|(
name|w
operator|->
name|w_prev
operator|->
name|w_height
operator|-
name|inc
operator|<
literal|2
condition|)
name|complain
argument_list|(
name|toosmall
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_height
operator|+=
name|inc
expr_stmt|;
name|w
operator|->
name|w_prev
operator|->
name|w_height
operator|-=
name|inc
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|Windchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Set the topline of the window, calculating its number in the buffer.    This is for numbering the lines only. */
end_comment

begin_function
name|void
name|SetTop
parameter_list|(
name|w
parameter_list|,
name|line
parameter_list|)
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|lp
init|=
name|w
operator|->
name|w_bufp
operator|->
name|b_first
decl_stmt|;
specifier|register
name|int
name|num
init|=
literal|0
decl_stmt|;
name|w
operator|->
name|w_top
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
condition|)
block|{
while|while
condition|(
name|lp
condition|)
block|{
name|num
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|lp
condition|)
break|break;
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
block|}
name|w
operator|->
name|w_topnum
operator|=
name|num
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|WNumLines
parameter_list|()
block|{
name|curwind
operator|->
name|w_flags
operator|^=
name|W_NUMLINES
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_top
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|WVisSpace
parameter_list|()
block|{
name|curwind
operator|->
name|w_flags
operator|^=
name|W_VISSPACE
expr_stmt|;
name|ClAndRedraw
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the line number that `line' occupies in `windes' */
end_comment

begin_function
name|int
name|in_window
parameter_list|(
name|windes
parameter_list|,
name|line
parameter_list|)
specifier|register
name|Window
modifier|*
name|windes
decl_stmt|;
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Line
modifier|*
name|top
init|=
name|windes
operator|->
name|w_top
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|top
operator|&&
name|i
operator|<
name|windes
operator|->
name|w_height
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|top
operator|=
name|top
operator|->
name|l_next
control|)
if|if
condition|(
name|top
operator|==
name|line
condition|)
return|return
name|FLine
argument_list|(
name|windes
argument_list|)
operator|+
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|SplitWind
parameter_list|()
block|{
name|SetWind
argument_list|(
name|div_wind
argument_list|(
name|curwind
argument_list|,
name|is_an_arg
argument_list|()
condition|?
operator|(
name|arg_value
argument_list|()
operator|-
literal|1
operator|)
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Goto the window with the named buffer.  If no such window    exists, pop one and attach the buffer to it. */
end_comment

begin_function
name|void
name|GotoWind
parameter_list|()
block|{
name|char
modifier|*
name|bname
decl_stmt|;
name|Window
modifier|*
name|w
decl_stmt|;
name|bname
operator|=
name|ask_buf
argument_list|(
name|lastbuf
argument_list|)
expr_stmt|;
name|w
operator|=
name|curwind
operator|->
name|w_next
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|->
name|b_name
operator|==
name|bname
condition|)
block|{
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|curwind
condition|)
do|;
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|bname
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ScrollRight
parameter_list|()
block|{
name|int
name|amt
init|=
operator|(
name|is_an_arg
argument_list|()
condition|?
name|arg_value
argument_list|()
else|:
literal|10
operator|)
decl_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_LRscroll
operator|-
name|amt
operator|<
literal|0
condition|)
name|curwind
operator|->
name|w_LRscroll
operator|=
literal|0
expr_stmt|;
else|else
name|curwind
operator|->
name|w_LRscroll
operator|-=
name|amt
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ScrollLeft
parameter_list|()
block|{
name|int
name|amt
init|=
operator|(
name|is_an_arg
argument_list|()
condition|?
name|arg_value
argument_list|()
else|:
literal|10
operator|)
decl_stmt|;
name|curwind
operator|->
name|w_LRscroll
operator|+=
name|amt
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
block|}
end_function

end_unit

