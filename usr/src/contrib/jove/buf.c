begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* Contains commands that deal with creating, selecting, killing and    listing buffers, and buffer modes, and find-file, etc. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPROCS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"iproc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|Buffer
modifier|*
name|buf_alloc
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
modifier|*
name|mak_buf
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|line_cnt
name|proto
argument_list|(
operator|(
name|Buffer
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|defb_wind
name|proto
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
argument_list|)
decl_stmt|,
name|kill_buf
name|proto
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
argument_list|)
decl_stmt|,
name|mkbuflist
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|Mainbuf
init|=
literal|"Main"
decl_stmt|,
modifier|*
name|NoName
init|=
literal|"Sans un nom!"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|world
init|=
literal|0
decl_stmt|,
comment|/* First in the list */
modifier|*
name|curbuf
init|=
literal|0
decl_stmt|,
comment|/* pointer into world for current buffer */
modifier|*
name|lastbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last buffer we were in so we have a default 			   buffer during a select buffer. */
end_comment

begin_comment
comment|/* Toggle BIT in the current buffer's minor mode flags.  If argument is    supplied, a positive one always turns on the mode and zero argument    always turns it off. */
end_comment

begin_function
name|void
name|TogMinor
parameter_list|(
name|bit
parameter_list|)
name|int
name|bit
decl_stmt|;
block|{
if|if
condition|(
name|is_an_arg
argument_list|()
condition|)
block|{
if|if
condition|(
name|arg_value
argument_list|()
operator|==
literal|0
condition|)
name|curbuf
operator|->
name|b_minor
operator|&=
operator|~
name|bit
expr_stmt|;
else|else
name|curbuf
operator|->
name|b_minor
operator||=
name|bit
expr_stmt|;
block|}
else|else
name|curbuf
operator|->
name|b_minor
operator|^=
name|bit
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Creates a new buffer, links it at the end of the buffer chain, and    returns it. */
end_comment

begin_function
name|private
name|Buffer
modifier|*
name|buf_alloc
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|lastbp
decl_stmt|;
name|lastbp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|lastbp
operator|=
name|b
operator|,
name|b
operator|=
name|b
operator|->
name|b_next
control|)
empty_stmt|;
name|b
operator|=
operator|(
name|Buffer
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastbp
condition|)
name|lastbp
operator|->
name|b_next
operator|=
name|b
expr_stmt|;
else|else
name|world
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|b_first
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_next
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
name|b
operator|->
name|Type
operator|=
name|BUFFER
expr_stmt|;
comment|/* kludge, but simplifies menu handlers */
name|b
operator|->
name|Name
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Makes a buffer and initializes it.  Obsolete.  Used to take two    arguments, a buffer name and a file name. */
end_comment

begin_function
name|private
name|Buffer
modifier|*
name|mak_buf
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|newb
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|newb
operator|=
name|buf_alloc
argument_list|()
expr_stmt|;
name|newb
operator|->
name|b_fname
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_name
operator|=
name|NoName
expr_stmt|;
name|set_ino
argument_list|(
name|newb
argument_list|)
expr_stmt|;
name|newb
operator|->
name|b_marks
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_themark
operator|=
literal|0
expr_stmt|;
comment|/* Index into markring */
comment|/* No marks yet */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMARKS
condition|;
name|i
operator|++
control|)
name|newb
operator|->
name|b_markring
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_modified
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_type
operator|=
name|B_FILE
expr_stmt|;
comment|/* File until proven SCRATCH */
name|newb
operator|->
name|b_ntbf
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_minor
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_major
operator|=
name|TEXT
expr_stmt|;
name|newb
operator|->
name|b_first
operator|=
literal|0
expr_stmt|;
name|newb
operator|->
name|b_map
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPROCS
argument_list|)
name|newb
operator|->
name|b_process
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|initlist
argument_list|(
name|newb
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
name|Bufchange
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|newb
return|;
block|}
end_function

begin_function
name|void
name|ReNamBuf
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|new
init|=
literal|0
decl_stmt|,
modifier|*
name|prompt
init|=
name|ProcFmt
decl_stmt|,
modifier|*
name|second
init|=
literal|"%s already exists; new name? "
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|new
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf_exists
argument_list|(
name|new
argument_list|)
condition|)
break|break;
name|prompt
operator|=
name|second
expr_stmt|;
block|}
name|setbname
argument_list|(
name|curbuf
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FindFile
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|name
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|do_find
argument_list|(
name|curwind
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|mkbuflist
parameter_list|(
name|bnamp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|bnamp
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|->
name|b_name
operator|!=
literal|0
condition|)
operator|*
name|bnamp
operator|++
operator|=
name|b
operator|->
name|b_name
expr_stmt|;
operator|*
name|bnamp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|ask_buf
parameter_list|(
name|def
parameter_list|)
name|Buffer
modifier|*
name|def
decl_stmt|;
block|{
name|char
modifier|*
name|bnames
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|bname
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
name|char
name|prompt
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|def
operator|!=
literal|0
operator|&&
name|def
operator|->
name|b_name
operator|!=
literal|0
condition|)
name|swritef
argument_list|(
name|prompt
argument_list|,
literal|": %f (default %s) "
argument_list|,
name|def
operator|->
name|b_name
argument_list|)
expr_stmt|;
else|else
name|swritef
argument_list|(
name|prompt
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
name|mkbuflist
argument_list|(
name|bnames
argument_list|)
expr_stmt|;
name|offset
operator|=
name|complete
argument_list|(
name|bnames
argument_list|,
name|prompt
argument_list|,
name|RET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|EOF
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|ORIGINAL
operator|||
name|offset
operator|==
name|AMBIGUOUS
condition|)
name|bname
operator|=
name|Minibuf
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|==
name|NULLSTRING
condition|)
block|{
if|if
condition|(
name|def
condition|)
name|bname
operator|=
name|def
operator|->
name|b_name
expr_stmt|;
else|else
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|bname
operator|=
name|bnames
index|[
name|offset
index|]
expr_stmt|;
return|return
name|bname
return|;
block|}
end_function

begin_function
name|void
name|BufSelect
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|bname
decl_stmt|;
name|bname
operator|=
name|ask_buf
argument_list|(
name|lastbuf
argument_list|)
expr_stmt|;
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|bname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|private
name|void
name|BufNSelect
parameter_list|(
name|n
parameter_list|)
block|{
name|char
modifier|*
name|bnames
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|bname
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mkbuflist
argument_list|(
name|bnames
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bnames
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No such buffer]"
argument_list|)
expr_stmt|;
name|bname
operator|=
name|bnames
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|bname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf1Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf2Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf3Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf4Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf5Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf6Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf7Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf8Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf9Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Buf10Select
parameter_list|()
block|{
name|BufNSelect
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|private
name|void
name|defb_wind
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
name|char
modifier|*
name|alt
decl_stmt|;
if|if
condition|(
name|lastbuf
operator|==
name|b
operator|||
name|lastbuf
operator|==
literal|0
condition|)
block|{
name|lastbuf
operator|=
literal|0
expr_stmt|;
name|alt
operator|=
operator|(
name|b
operator|->
name|b_next
operator|!=
literal|0
operator|)
condition|?
name|b
operator|->
name|b_next
operator|->
name|b_name
else|:
name|Mainbuf
expr_stmt|;
block|}
else|else
name|alt
operator|=
name|lastbuf
operator|->
name|b_name
expr_stmt|;
do|do
block|{
if|if
condition|(
name|w
operator|->
name|w_bufp
operator|==
name|b
condition|)
block|{
if|if
condition|(
name|one_windp
argument_list|()
operator|||
name|alt
operator|!=
name|Mainbuf
condition|)
operator|(
name|void
operator|)
name|do_select
argument_list|(
name|w
argument_list|,
name|alt
argument_list|)
expr_stmt|;
else|else
block|{
name|Window
modifier|*
name|save
init|=
name|w
operator|->
name|w_next
decl_stmt|;
name|del_wind
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
name|save
operator|->
name|w_prev
expr_stmt|;
block|}
block|}
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
operator|||
name|w
operator|->
name|w_bufp
operator|==
name|b
condition|)
do|;
block|}
end_function

begin_function
name|private
name|Buffer
modifier|*
name|getNMbuf
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|delbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|bname
decl_stmt|;
name|bname
operator|=
name|ask_buf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|delbuf
operator|=
name|buf_exists
argument_list|(
name|bname
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No such buffer]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|delbuf
operator|->
name|b_modified
condition|)
name|confirm
argument_list|(
literal|"%s modified, are you sure? "
argument_list|,
name|bname
argument_list|)
expr_stmt|;
return|return
name|delbuf
return|;
block|}
end_function

begin_function
name|void
name|BufErase
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|delbuf
decl_stmt|;
if|if
condition|(
operator|(
name|delbuf
operator|=
name|getNMbuf
argument_list|()
operator|)
operator|!=
name|NIL
condition|)
block|{
name|initlist
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
name|delbuf
operator|->
name|b_modified
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|kill_buf
parameter_list|(
name|delbuf
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|delbuf
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|lastb
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPROCS
argument_list|)
name|pbuftiedp
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
comment|/* check for lingering processes */
endif|#
directive|endif
comment|/* clean up windows associated with this buffer */
if|if
condition|(
name|delbuf
operator|==
name|curbuf
condition|)
name|curbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|delbuf
operator|==
name|lastbuf
condition|)
name|lastbuf
operator|=
name|curbuf
expr_stmt|;
comment|/* even if NULL */
name|defb_wind
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbuf
operator|==
name|NULL
condition|)
name|SetBuf
argument_list|(
name|curwind
operator|->
name|w_bufp
argument_list|)
expr_stmt|;
comment|/* unlink the buffer */
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|lastb
operator|=
name|b
operator|,
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|==
name|delbuf
condition|)
break|break;
if|if
condition|(
name|lastb
condition|)
name|lastb
operator|->
name|b_next
operator|=
name|delbuf
operator|->
name|b_next
expr_stmt|;
else|else
name|world
operator|=
name|delbuf
operator|->
name|b_next
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC
argument_list|)
if|if
condition|(
name|perr_buf
operator|==
name|delbuf
condition|)
block|{
name|ErrFree
argument_list|()
expr_stmt|;
name|perr_buf
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|lfreelist
argument_list|(
name|delbuf
operator|->
name|b_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|delbuf
operator|->
name|b_name
condition|)
name|free
argument_list|(
name|delbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|delbuf
operator|->
name|b_fname
condition|)
name|free
argument_list|(
name|delbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
name|flush_marks
argument_list|(
name|delbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|delbuf
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
name|Bufchange
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* offer to kill some buffers */
end_comment

begin_function
name|void
name|KillSome
parameter_list|()
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|Buffer
modifier|*
name|oldb
decl_stmt|;
specifier|register
name|char
modifier|*
name|y_or_n
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|next
control|)
block|{
name|next
operator|=
name|b
operator|->
name|b_next
expr_stmt|;
if|if
condition|(
name|yes_or_no_p
argument_list|(
literal|"Kill %s? "
argument_list|,
name|b
operator|->
name|b_name
argument_list|)
operator|==
name|NO
condition|)
continue|continue;
if|if
condition|(
name|IsModified
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|y_or_n
operator|=
name|ask
argument_list|(
literal|"No"
argument_list|,
literal|"%s modified; should I save it? "
argument_list|,
name|b
operator|->
name|b_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CharUpcase
argument_list|(
operator|*
name|y_or_n
argument_list|)
operator|==
literal|'Y'
condition|)
block|{
name|oldb
operator|=
name|curbuf
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SaveFile
argument_list|()
expr_stmt|;
name|SetBuf
argument_list|(
name|oldb
argument_list|)
expr_stmt|;
block|}
block|}
name|kill_buf
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|BufKill
parameter_list|()
block|{
name|Buffer
modifier|*
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|getNMbuf
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return;
name|kill_buf
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|line_cnt
parameter_list|(
name|b
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
init|=
literal|0
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|b
operator|->
name|b_first
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
operator|,
name|nlines
operator|++
control|)
empty_stmt|;
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
name|private
specifier|const
name|char
modifier|*
specifier|const
name|TypeNames
index|[]
init|=
block|{
literal|0
block|,
literal|"Scratch"
block|,
literal|"File"
block|,
literal|"Process"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|BufList
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
literal|"%-2s %-5s %-11s %-1s %-*s  %-s"
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|int
name|bcount
init|=
literal|1
decl_stmt|,
comment|/* To give each buffer a number */
name|buf_width
init|=
literal|11
decl_stmt|;
name|char
name|nbuf
index|[
literal|10
index|]
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
name|buf_width
operator|=
name|max
argument_list|(
name|buf_width
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|b
operator|->
name|b_name
argument_list|)
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Buffer list"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* true means auto-newline */
name|Typeout
argument_list|(
literal|"(* means buffer needs saving)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"(+ means file hasn't been read yet)"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
literal|"NO"
argument_list|,
literal|"Lines"
argument_list|,
literal|"Type"
argument_list|,
name|NullStr
argument_list|,
name|buf_width
argument_list|,
literal|"Name"
argument_list|,
literal|"File"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
literal|"--"
argument_list|,
literal|"-----"
argument_list|,
literal|"----"
argument_list|,
name|NullStr
argument_list|,
name|buf_width
argument_list|,
literal|"----"
argument_list|,
literal|"----"
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
name|Typeout
argument_list|(
name|fmt
argument_list|,
name|itoa
argument_list|(
name|bcount
operator|++
argument_list|)
argument_list|,
name|line_cnt
argument_list|(
name|b
argument_list|,
name|nbuf
argument_list|)
argument_list|,
name|TypeNames
index|[
name|b
operator|->
name|b_type
index|]
argument_list|,
name|IsModified
argument_list|(
name|b
argument_list|)
condition|?
literal|"*"
else|:
name|b
operator|->
name|b_ntbf
condition|?
literal|"+"
else|:
name|NullStr
argument_list|,
name|buf_width
argument_list|,
comment|/* For the * (variable length field) */
name|b
operator|->
name|b_name
argument_list|,
name|filename
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOabort
condition|)
break|break;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bufname
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
name|char
name|tmp
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|try
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[No file name]"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|basename
argument_list|(
name|b
operator|->
name|b_fname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf_exists
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|swritef
argument_list|(
name|tmp
argument_list|,
literal|"%s.%d"
argument_list|,
name|cp
argument_list|,
name|try
argument_list|)
expr_stmt|;
name|try
operator|+=
literal|1
expr_stmt|;
block|}
name|setbname
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initlist
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
name|lfreelist
argument_list|(
name|b
operator|->
name|b_first
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_first
operator|=
name|b
operator|->
name|b_dot
operator|=
name|b
operator|->
name|b_last
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|listput
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|b_first
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|b
operator|->
name|b_dot
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_char
operator|=
literal|0
expr_stmt|;
name|AllMarkSet
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|b_dot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|curbuf
condition|)
name|getDOT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns pointer to buffer with name NAME, or if NAME is a string of digits    returns the buffer whose number equals those digits.  Otherwise, returns    0. */
end_comment

begin_function
name|Buffer
modifier|*
name|buf_exists
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|bp
operator|=
name|world
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|b_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bp
return|;
comment|/* Doesn't match any names.  Try for a buffer number... */
if|if
condition|(
name|chr_to_int
argument_list|(
name|name
argument_list|,
literal|10
argument_list|,
name|YES
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
name|INT_BAD
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|world
init|;
name|n
operator|>
literal|1
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
break|break;
name|n
operator|-=
literal|1
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns buffer pointer with a file name NAME, if one exists.  Stat's the    file and compares inodes, in case NAME is a link, as well as the actual    characters that make up the file name. */
end_comment

begin_function
name|Buffer
modifier|*
name|file_exists
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|s
init|=
operator|&
name|stbuf
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
init|=
literal|0
decl_stmt|;
name|char
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|strlwr
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|name
condition|)
block|{
name|PathParse
argument_list|(
name|name
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fnamebuf
argument_list|,
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|s
operator|->
name|st_ino
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
block|{
if|if
condition|(
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|(
name|b
operator|->
name|b_ino
operator|!=
literal|0
operator|&&
name|b
operator|->
name|b_ino
operator|==
name|s
operator|->
name|st_ino
operator|&&
name|b
operator|->
name|b_dev
operator|!=
literal|0
operator|&&
name|b
operator|->
name|b_dev
operator|==
name|s
operator|->
name|st_dev
operator|)
operator|||
endif|#
directive|endif
comment|/* MSDOS */
operator|(
name|b
operator|->
name|b_fname
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|b
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
block|}
return|return
name|b
return|;
block|}
end_function

begin_function
name|void
name|setbname
parameter_list|(
name|b
parameter_list|,
name|name
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* Kludge ... but speeds things up considerably */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|b_name
operator|==
name|NoName
condition|)
name|b
operator|->
name|b_name
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_name
operator|=
name|ralloc
argument_list|(
name|b
operator|->
name|b_name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|b
operator|->
name|b_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|->
name|b_name
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
name|Bufchange
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|setfname
parameter_list|(
name|b
parameter_list|,
name|name
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|wholename
index|[
name|FILESIZE
index|]
decl_stmt|,
name|oldname
index|[
name|FILESIZE
index|]
decl_stmt|,
modifier|*
name|oldptr
init|=
name|oldname
decl_stmt|;
name|Buffer
modifier|*
name|save
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* Kludge ... but speeds things up considerably */
if|if
condition|(
name|b
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|oldptr
operator|=
literal|0
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|oldname
argument_list|,
name|b
operator|->
name|b_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|strlwr
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|PathParse
argument_list|(
name|name
argument_list|,
name|wholename
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_fname
operator|=
name|ralloc
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|strlen
argument_list|(
name|wholename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|wholename
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|->
name|b_fname
operator|=
literal|0
expr_stmt|;
name|DoAutoExec
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|oldptr
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_mtime
operator|=
name|curbuf
operator|->
name|b_dev
operator|=
name|curbuf
operator|->
name|b_ino
operator|=
literal|0
expr_stmt|;
comment|/* until they're known. */
name|SetBuf
argument_list|(
name|save
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
name|Bufchange
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|set_ino
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|b_fname
operator|==
literal|0
operator|||
name|stat
argument_list|(
name|pr_name
argument_list|(
name|b
operator|->
name|b_fname
argument_list|,
name|NO
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|b
operator|->
name|b_dev
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_ino
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b_mtime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|b_dev
operator|=
name|stbuf
operator|.
name|st_dev
expr_stmt|;
name|b
operator|->
name|b_ino
operator|=
name|stbuf
operator|.
name|st_ino
expr_stmt|;
name|b
operator|->
name|b_mtime
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the file `fname' into buf and put in in window `w' */
end_comment

begin_function
name|Buffer
modifier|*
name|do_find
parameter_list|(
name|w
parameter_list|,
name|fname
parameter_list|,
name|force
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|file_exists
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
block|{
name|b
operator|=
name|mak_buf
argument_list|()
expr_stmt|;
name|setfname
argument_list|(
name|b
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|bufname
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|set_ino
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_ntbf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
block|{
name|Buffer
modifier|*
name|oldb
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* this'll read the file */
name|SetBuf
argument_list|(
name|oldb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
condition|)
name|tiewind
argument_list|(
name|w
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* set alternate buffer */
end_comment

begin_function
name|void
name|SetABuf
parameter_list|(
name|b
parameter_list|)
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|!=
literal|0
condition|)
name|lastbuf
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* check to see if BP is a valid buffer pointer */
end_comment

begin_function
name|private
name|int
name|valid_bp
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|world
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_next
control|)
if|if
condition|(
name|b
operator|==
name|bp
condition|)
break|break;
return|return
name|b
operator|!=
literal|0
return|;
block|}
end_function

begin_function
name|void
name|SetBuf
parameter_list|(
name|newbuf
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|newbuf
decl_stmt|;
block|{
if|if
condition|(
name|newbuf
operator|==
name|curbuf
operator|||
name|newbuf
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|valid_bp
argument_list|(
name|newbuf
argument_list|)
condition|)
name|complain
argument_list|(
literal|"Internal error: (0x%x) is not a valid buffer pointer!"
argument_list|,
name|newbuf
argument_list|)
expr_stmt|;
name|lsave
argument_list|()
expr_stmt|;
name|curbuf
operator|=
name|newbuf
expr_stmt|;
name|curline
operator|=
name|newbuf
operator|->
name|b_dot
expr_stmt|;
name|curchar
operator|=
name|newbuf
operator|->
name|b_char
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
comment|/* do the read now ... */
if|if
condition|(
name|curbuf
operator|->
name|b_ntbf
condition|)
name|read_file
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
name|Modechange
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|Buffer
modifier|*
name|do_select
parameter_list|(
name|w
parameter_list|,
name|name
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|Buffer
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|buf_exists
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|mak_buf
argument_list|()
expr_stmt|;
name|setfname
argument_list|(
name|new
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|setbname
argument_list|(
name|new
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|w
condition|)
name|tiewind
argument_list|(
name|w
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|void
name|buf_init
parameter_list|()
block|{
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|Mainbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

