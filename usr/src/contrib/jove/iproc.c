begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPROCS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"iproc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdargs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_decl_stmt
name|private
name|void
name|proc_rec
name|proto
argument_list|(
operator|(
name|Process
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|proc_close
name|proto
argument_list|(
operator|(
name|Process
operator|*
operator|)
argument_list|)
decl_stmt|,
name|proc_kill
name|proto
argument_list|(
operator|(
name|Process
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|SendData
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|proc_child
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PIPEPROCS
end_ifdef

begin_include
include|#
directive|include
file|"iproc-pipes.c"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"iproc-ptys.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|proc_prompt
index|[
literal|128
index|]
init|=
literal|"% "
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pstate
parameter_list|(
name|p
parameter_list|)
name|Process
modifier|*
name|p
decl_stmt|;
block|{
switch|switch
condition|(
name|proc_state
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|NEW
case|:
return|return
literal|"New"
return|;
case|case
name|STOPPED
case|:
return|return
literal|"Stopped"
return|;
case|case
name|RUNNING
case|:
return|return
literal|"Running"
return|;
case|case
name|DEAD
case|:
if|if
condition|(
name|p
operator|->
name|p_howdied
operator|==
name|EXITED
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_reason
operator|==
literal|0
condition|)
return|return
literal|"Done"
return|;
return|return
name|sprint
argument_list|(
literal|"Exit %d"
argument_list|,
name|p
operator|->
name|p_reason
argument_list|)
return|;
block|}
return|return
name|sprint
argument_list|(
literal|"Killed %d"
argument_list|,
name|p
operator|->
name|p_reason
argument_list|)
return|;
default|default:
return|return
literal|"Unknown state"
return|;
block|}
block|}
end_function

begin_function
name|void
name|KillProcs
parameter_list|()
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|killem
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means undetermined */
specifier|register
name|char
modifier|*
name|yorn
decl_stmt|;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|p_next
control|)
if|if
condition|(
operator|!
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|killem
operator|==
operator|-
literal|1
condition|)
block|{
name|yorn
operator|=
name|ask
argument_list|(
literal|"y"
argument_list|,
literal|"Should I kill your i-processes? "
argument_list|)
expr_stmt|;
name|killem
operator|=
operator|(
name|CharUpcase
argument_list|(
operator|*
name|yorn
argument_list|)
operator|==
literal|'Y'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|killem
condition|)
name|proc_kill
argument_list|(
name|p
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pbuftiedp
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|p
init|=
name|b
operator|->
name|b_process
decl_stmt|;
if|if
condition|(
operator|!
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
name|complain
argument_list|(
literal|"Process %s, attached to %b, is %s."
argument_list|,
name|proc_cmd
argument_list|(
name|p
argument_list|)
argument_list|,
name|b
argument_list|,
name|pstate
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|dbx_parse_fmt
index|[
literal|128
index|]
init|=
literal|"line \\([0-9]*\\) in \\{file,\\} *\"\\([^\"]*\\)\""
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|DBXpoutput
parameter_list|()
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_process
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[Must be in a process buffer to enable dbx mode]"
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_process
operator|->
name|p_dbx_mode
operator|=
operator|!
name|curbuf
operator|->
name|b_process
operator|->
name|p_dbx_mode
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|watch_input
parameter_list|(
name|m
parameter_list|)
name|Mark
modifier|*
name|m
decl_stmt|;
block|{
name|Bufpos
name|save
decl_stmt|;
name|char
name|fname
index|[
name|FILESIZE
index|]
decl_stmt|,
name|lineno
index|[
name|FILESIZE
index|]
decl_stmt|;
name|int
name|lnum
decl_stmt|;
name|Window
modifier|*
name|savew
init|=
name|curwind
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosearch
argument_list|(
name|dbx_parse_fmt
argument_list|,
name|FORWARD
argument_list|,
name|YES
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|get_FL_info
argument_list|(
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|buf
operator|=
name|do_find
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
name|fname
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lnum
operator|=
name|atoi
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|buf
operator|->
name|b_first
argument_list|,
name|lnum
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|savew
argument_list|)
expr_stmt|;
block|}
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process receive: receives the characters in buf, and appends them to    the buffer associated with p. */
end_comment

begin_function
name|private
name|void
name|proc_rec
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|Buffer
modifier|*
name|saveb
init|=
name|curbuf
decl_stmt|;
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
specifier|register
name|Mark
modifier|*
name|savepoint
decl_stmt|;
name|int
name|sameplace
init|=
name|NO
decl_stmt|,
name|do_disp
init|=
name|NO
decl_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_bufp
operator|==
name|p
operator|->
name|p_buffer
condition|)
name|w
operator|=
name|curwind
expr_stmt|;
else|else
name|w
operator|=
name|windbp
argument_list|(
name|p
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
comment|/* Is this window visible? */
if|if
condition|(
name|w
operator|!=
literal|0
condition|)
name|do_disp
operator|=
operator|(
name|in_window
argument_list|(
name|w
argument_list|,
name|p
operator|->
name|p_mark
operator|->
name|m_line
argument_list|)
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
name|SetBuf
argument_list|(
name|p
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
name|savepoint
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|p
operator|->
name|p_mark
argument_list|)
expr_stmt|;
comment|/* where output last stopped */
if|if
condition|(
name|savepoint
operator|->
name|m_line
operator|==
name|curline
operator|&&
name|savepoint
operator|->
name|m_char
operator|==
name|curchar
condition|)
name|sameplace
operator|=
name|YES
expr_stmt|;
name|ins_str
argument_list|(
name|buf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_disp
operator|==
name|YES
operator|&&
name|p
operator|->
name|p_dbx_mode
operator|==
name|YES
condition|)
name|watch_input
argument_list|(
name|p
operator|->
name|p_mark
argument_list|)
expr_stmt|;
name|MarkSet
argument_list|(
name|p
operator|->
name|p_mark
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sameplace
condition|)
name|ToMark
argument_list|(
name|savepoint
argument_list|)
expr_stmt|;
comment|/* back to where we were */
name|DelMark
argument_list|(
name|savepoint
argument_list|)
expr_stmt|;
comment|/* redisplay now, instead of right after the ins_str, so that 	   we don't get a bouncing effect if point is not the same as 	   the process output position */
if|if
condition|(
name|do_disp
condition|)
block|{
name|w
operator|->
name|w_line
operator|=
name|curline
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
name|curchar
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
name|SetBuf
argument_list|(
name|saveb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|proc_kill
parameter_list|(
name|p
parameter_list|,
name|sig
parameter_list|)
specifier|register
name|Process
modifier|*
name|p
decl_stmt|;
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
return|return;
if|if
condition|(
name|killpg
argument_list|(
name|p
operator|->
name|p_pid
argument_list|,
name|sig
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|s_mess
argument_list|(
literal|"Cannot kill %s!"
argument_list|,
name|proc_buf
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free process CHILD.  Do all the necessary cleaning up (closing fd's,    etc.). */
end_comment

begin_function
name|private
name|void
name|free_proc
parameter_list|(
name|child
parameter_list|)
name|Process
modifier|*
name|child
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|isdead
argument_list|(
name|child
argument_list|)
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
name|child
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|p_next
control|)
empty_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
name|procs
operator|=
name|child
operator|->
name|p_next
expr_stmt|;
else|else
name|prev
operator|->
name|p_next
operator|=
name|child
operator|->
name|p_next
expr_stmt|;
name|proc_close
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* if not already closed */
comment|/* It's possible that the buffer has been given another process 	   between the time CHILD dies and CHILD's death is noticed (via 	   list-processes).  So we only set it the buffer's process to 	   0 if CHILD is still the controlling process. */
if|if
condition|(
name|child
operator|->
name|p_buffer
operator|->
name|b_process
operator|==
name|child
condition|)
block|{
name|child
operator|->
name|p_buffer
operator|->
name|b_process
operator|=
literal|0
expr_stmt|;
block|}
block|{
name|Buffer
modifier|*
name|old
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|child
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|child
operator|->
name|p_mark
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|child
operator|->
name|p_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ProcList
parameter_list|()
block|{
specifier|register
name|Process
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
literal|"%-15s  %-15s  %-8s %s"
decl_stmt|,
name|pidstr
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|procs
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
literal|"[No subprocesses]"
argument_list|)
expr_stmt|;
return|return;
block|}
name|TOstart
argument_list|(
literal|"Process list"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
literal|"Buffer"
argument_list|,
literal|"Status"
argument_list|,
literal|"Pid "
argument_list|,
literal|"Command"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
literal|"------"
argument_list|,
literal|"------"
argument_list|,
literal|"--- "
argument_list|,
literal|"-------"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|procs
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|p_next
expr_stmt|;
name|swritef
argument_list|(
name|pidstr
argument_list|,
literal|"%d"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
name|fmt
argument_list|,
name|proc_buf
argument_list|(
name|p
argument_list|)
argument_list|,
name|pstate
argument_list|(
name|p
argument_list|)
argument_list|,
name|pidstr
argument_list|,
name|p
operator|->
name|p_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|free_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
block|}
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|do_rtp
parameter_list|(
name|mp
parameter_list|)
specifier|register
name|Mark
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|p
init|=
name|curbuf
operator|->
name|b_process
decl_stmt|;
name|Line
modifier|*
name|line1
init|=
name|curline
decl_stmt|,
modifier|*
name|line2
init|=
name|mp
operator|->
name|m_line
decl_stmt|;
name|int
name|char1
init|=
name|curchar
decl_stmt|,
name|char2
init|=
name|mp
operator|->
name|m_char
decl_stmt|;
name|char
modifier|*
name|gp
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
operator|||
name|p
operator|->
name|p_buffer
operator|!=
name|curbuf
condition|)
return|return;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|line2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
while|while
condition|(
name|line1
operator|!=
name|line2
operator|->
name|l_next
condition|)
block|{
name|gp
operator|=
name|ltobuf
argument_list|(
name|line1
argument_list|,
name|genbuf
argument_list|)
operator|+
name|char1
expr_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
name|gp
index|[
name|char2
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcat
argument_list|(
name|gp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nbytes
operator|=
name|strlen
argument_list|(
name|gp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|proc_write
argument_list|(
name|p
argument_list|,
name|gp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|line1
operator|=
name|line1
operator|->
name|l_next
expr_stmt|;
name|char1
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ProcNewline
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ABBREV
name|MaybeAbbrevExpand
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SendData
argument_list|(
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ProcSendData
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ABBREV
name|MaybeAbbrevExpand
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SendData
argument_list|(
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|SendData
parameter_list|(
name|newlinep
parameter_list|)
name|int
name|newlinep
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|p
init|=
name|curbuf
operator|->
name|b_process
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|gp
decl_stmt|;
comment|/* JF fix for better prompt handling */
if|if
condition|(
name|isdead
argument_list|(
name|p
argument_list|)
condition|)
return|return;
comment|/* If the process mark was involved in a big deletion, because 	   the user hit ^W or something, then let's do some magic with 	   the process mark.  Problem is that if the user yanks back the 	   text he deleted, the mark stays at the beginning of the region, 	   and so the next time SendData() is called the entire region 	   will be sent.  That's not good.  So, to deal with that we reset 	   the mark to the last line, after skipping over the prompt, etc. */
if|if
condition|(
name|p
operator|->
name|p_mark
operator|->
name|m_flags
operator|&
name|M_BIG_DELETE
condition|)
block|{
name|Bufpos
name|bp
decl_stmt|;
name|p
operator|->
name|p_mark
operator|->
name|m_flags
operator|&=
operator|~
name|M_BIG_DELETE
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
name|ToLast
argument_list|()
expr_stmt|;
name|Bol
argument_list|()
expr_stmt|;
comment|/* While we're looking at a prompt, and while we're 		   moving forward.  This is for people who accidently 		   set their process-prompt to ">*" which will always 		   match! */
while|while
condition|(
operator|(
name|LookingAt
argument_list|(
name|proc_prompt
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|)
operator|&&
operator|(
name|REeom
operator|>
name|curchar
operator|)
condition|)
name|curchar
operator|=
name|REeom
expr_stmt|;
name|MarkSet
argument_list|(
name|p
operator|->
name|p_mark
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|newlinep
condition|)
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|do_rtp
argument_list|(
name|p
operator|->
name|p_mark
argument_list|)
expr_stmt|;
name|MarkSet
argument_list|(
name|p
operator|->
name|p_mark
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either we're looking at a prompt, or we're not, in 		   which case we want to strip off the beginning of the 		   line anything that looks like what the prompt at the 		   end of the file is.  In other words, if "(dbx) stop in 		   ProcessNewline" is the line we're on, and the last 		   line in the buffer is "(dbx) ", then we strip off the 		   leading "(dbx) " from this line, because we know it's 		   part of the prompt.  But this only happens if "(dbx) " 		   isn't one of the process prompts ... follow what I'm 		   saying? */
name|Bol
argument_list|()
expr_stmt|;
if|if
condition|(
name|LookingAt
argument_list|(
name|proc_prompt
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
condition|)
block|{
do|do
name|curchar
operator|=
name|REeom
expr_stmt|;
do|while
condition|(
operator|(
name|LookingAt
argument_list|(
name|proc_prompt
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|)
operator|&&
operator|(
name|REeom
operator|>
name|curchar
operator|)
condition|)
do|;
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|)
expr_stmt|;
name|Eof
argument_list|()
expr_stmt|;
name|ins_str
argument_list|(
name|genbuf
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|genbuf
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|)
expr_stmt|;
name|Eof
argument_list|()
expr_stmt|;
name|gp
operator|=
name|genbuf
expr_stmt|;
name|lp
operator|=
name|linebuf
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|==
operator|*
name|gp
operator|&&
operator|*
name|lp
operator|!=
literal|'\0'
condition|)
block|{
name|lp
operator|+=
literal|1
expr_stmt|;
name|gp
operator|+=
literal|1
expr_stmt|;
block|}
name|ins_str
argument_list|(
name|gp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ShellProc
parameter_list|()
block|{
name|char
modifier|*
name|shbuf
init|=
literal|"*shell*"
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|buf_exists
argument_list|(
name|shbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
operator|||
name|isdead
argument_list|(
name|b
operator|->
name|b_process
argument_list|)
condition|)
name|proc_strt
argument_list|(
name|shbuf
argument_list|,
name|NO
argument_list|,
name|Shell
argument_list|,
literal|"-i"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|shbuf
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Iprocess
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|command
decl_stmt|;
name|char
name|scratch
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|bnm
decl_stmt|;
name|int
name|cnt
init|=
literal|1
decl_stmt|;
name|Buffer
modifier|*
name|bp
decl_stmt|;
name|command
operator|=
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|command
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bnm
operator|=
name|MakeName
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scratch
argument_list|,
name|bnm
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|buf_exists
argument_list|(
name|scratch
argument_list|)
operator|)
operator|!=
name|NIL
operator|&&
operator|!
name|isdead
argument_list|(
name|bp
operator|->
name|b_process
argument_list|)
condition|)
name|swritef
argument_list|(
name|scratch
argument_list|,
literal|"%s.%d"
argument_list|,
name|bnm
argument_list|,
name|cnt
operator|++
argument_list|)
expr_stmt|;
name|proc_strt
argument_list|(
name|scratch
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|SIGRESULT
name|proc_child
parameter_list|(
name|junk
parameter_list|)
name|int
name|junk
decl_stmt|;
comment|/* needed for signal handler; not used */
block|{
name|union
name|wait
name|w
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|WAIT3
name|pid
operator|=
name|wait2
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|pid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
break|break;
name|kill_off
argument_list|(
name|pid
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
name|SIGRETURN
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kill_off
parameter_list|(
name|pid
parameter_list|,
name|w
parameter_list|)
specifier|register
name|int
name|pid
decl_stmt|;
name|union
name|wait
name|w
decl_stmt|;
block|{
specifier|register
name|Process
modifier|*
name|child
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|proc_pid
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
comment|/* we're changing state ... */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
name|child
operator|->
name|p_state
operator|=
name|STOPPED
expr_stmt|;
else|else
block|{
name|child
operator|->
name|p_state
operator|=
name|DEAD
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
condition|)
name|child
operator|->
name|p_howdied
operator|=
name|EXITED
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|child
operator|->
name|p_reason
operator|=
name|w_termsignum
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|child
operator|->
name|p_howdied
operator|=
name|KILLED
expr_stmt|;
block|}
block|{
name|Buffer
modifier|*
name|save
init|=
name|curbuf
decl_stmt|;
name|char
name|mesg
index|[
literal|128
index|]
decl_stmt|;
comment|/* insert status message now */
name|swritef
argument_list|(
name|mesg
argument_list|,
literal|"[Process %s: %s]\n"
argument_list|,
name|proc_cmd
argument_list|(
name|child
argument_list|)
argument_list|,
name|pstate
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|child
operator|->
name|p_buffer
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|mesg
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|save
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPROCS */
end_comment

end_unit

