begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPROCS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"iproc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
name|private
name|void
ifdef|#
directive|ifdef
name|ID_CHAR
name|DeTab
name|proto
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|DelChar
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|InsChar
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|DoIDline
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|do_cl_eol
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|ModeLine
name|proto
argument_list|(
operator|(
name|Window
operator|*
operator|)
argument_list|)
decl_stmt|,
name|GotoDot
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|UpdLine
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|UpdWindow
name|proto
argument_list|(
operator|(
name|Window
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|dobell
name|proto
argument_list|(
operator|(
name|int
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|private
name|void
name|dobell
name|proto
argument_list|(
operator|(
name|int
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|int
ifdef|#
directive|ifdef
name|ID_CHAR
name|IDchar
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|NumSimilar
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|IDcomp
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|OkayDelete
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|OkayInsert
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|AddLines
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|DelLines
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|UntilEqual
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DisabledRedisplay
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kludge windows gets called by the routines that delete lines from the    buffer.  If the w->w_line or w->w_top are deleted and this procedure    is not called, the redisplay routine will barf. */
end_comment

begin_function
name|void
name|ChkWindows
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|Line
modifier|*
name|line1
decl_stmt|;
specifier|register
name|Line
modifier|*
name|line2
decl_stmt|;
block|{
specifier|register
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
do|do
block|{
for|for
control|(
name|lp
operator|=
name|line1
operator|->
name|l_next
init|;
name|lp
operator|!=
name|line2
operator|->
name|l_next
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_top
condition|)
name|w
operator|->
name|w_flags
operator||=
name|W_TOPGONE
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_line
condition|)
name|w
operator|->
name|w_flags
operator||=
name|W_CURGONE
expr_stmt|;
block|}
name|w
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|fwind
condition|)
do|;
block|}
end_function

begin_decl_stmt
name|private
name|int
name|RingBell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* So if we have a lot of errors ... 				  ring the bell only ONCE */
end_comment

begin_function
name|void
name|redisplay
parameter_list|()
block|{
specifier|register
name|Window
modifier|*
name|w
init|=
name|fwind
decl_stmt|;
name|int
name|lineno
decl_stmt|,
name|done_ID
init|=
name|NO
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
decl_stmt|,
modifier|*
name|phys_p
decl_stmt|;
if|if
condition|(
name|DisabledRedisplay
operator|==
name|YES
condition|)
return|return;
name|curwind
operator|->
name|w_line
operator|=
name|curwind
operator|->
name|w_bufp
operator|->
name|b_dot
expr_stmt|;
name|curwind
operator|->
name|w_char
operator|=
name|curwind
operator|->
name|w_bufp
operator|->
name|b_char
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|InputPending
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* calls CheckEvent, which could */
return|return;
comment|/* result in a call to rediplay(). We don't want that. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|JOB_CONTROL
if|if
condition|(
name|UpdFreq
condition|)
name|SigHold
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|RingBell
condition|)
block|{
name|dobell
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|RingBell
operator|=
literal|0
expr_stmt|;
block|}
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
comment|/* initialize this now */
if|if
condition|(
name|UpdMesg
condition|)
name|DrawMesg
argument_list|(
name|YES
argument_list|)
expr_stmt|;
for|for
control|(
name|lineno
operator|=
literal|0
operator|,
name|w
operator|=
name|fwind
init|;
name|lineno
operator|<
name|ILI
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
block|{
name|UpdWindow
argument_list|(
name|w
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|lineno
operator|+=
name|w
operator|->
name|w_height
expr_stmt|;
block|}
name|UpdModLine
operator|=
literal|0
expr_stmt|;
comment|/* Now that we've called update window, we can 			   assume that the modeline will be updated.  But 			   if while redrawing the modeline the user types 			   a character, ModeLine() is free to set this on 			   again so that the modeline will be fully drawn 			   at the next redisplay. */
name|des_p
operator|=
name|DesiredScreen
expr_stmt|;
name|phys_p
operator|=
name|PhysScreen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ILI
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|done_ID
operator|&&
operator|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
condition|)
block|{
name|DoIDline
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|done_ID
operator|=
name|YES
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|des_p
operator|->
name|s_flags
operator|&
operator|(
name|DIRTY
operator||
name|L_MOD
operator|)
operator|)
operator|||
operator|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
operator|||
operator|(
name|des_p
operator|->
name|s_vln
operator|!=
name|phys_p
operator|->
name|s_vln
operator|)
operator|||
operator|(
name|des_p
operator|->
name|s_offset
operator|!=
name|phys_p
operator|->
name|s_offset
operator|)
condition|)
name|UpdLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|InputPending
condition|)
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|Asking
condition|)
block|{
name|Placur
argument_list|(
name|LI
operator|-
literal|1
argument_list|,
name|min
argument_list|(
name|CO
operator|-
literal|2
argument_list|,
name|calc_pos
argument_list|(
name|mesgbuf
argument_list|,
name|Asking
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nice kludge */
name|flusho
argument_list|()
expr_stmt|;
block|}
else|else
name|GotoDot
argument_list|()
expr_stmt|;
name|ret
label|:
ifdef|#
directive|ifdef
name|JOB_CONTROL
if|if
condition|(
name|UpdFreq
condition|)
name|SigRelse
argument_list|(
name|SIGALRM
argument_list|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
comment|/* yuck */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|Windchange
condition|)
name|docontrols
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_function
name|private
name|void
name|dobell
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|VisBell
operator|&&
name|VB
condition|)
name|putstr
argument_list|(
name|VB
argument_list|)
expr_stmt|;
else|else
name|putpad
argument_list|(
name|BL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|SysBeep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|flusho
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_comment
comment|/* find_pos() returns the position on the line, that C_CHAR represents    in LINE */
end_comment

begin_function
name|int
name|find_pos
parameter_list|(
name|line
parameter_list|,
name|c_char
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
name|int
name|c_char
decl_stmt|;
block|{
return|return
name|calc_pos
argument_list|(
name|lcontents
argument_list|(
name|line
argument_list|)
argument_list|,
name|c_char
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|calc_pos
parameter_list|(
name|lp
parameter_list|,
name|c_char
parameter_list|)
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|c_char
decl_stmt|;
block|{
specifier|register
name|int
name|pos
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
operator|--
name|c_char
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|&
name|CHARMASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|pos
operator|+=
operator|(
name|tabstop
operator|-
operator|(
name|pos
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|pos
operator|+=
literal|2
expr_stmt|;
else|else
name|pos
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|pos
return|;
block|}
end_function

begin_decl_stmt
name|int
name|UpdModLine
init|=
literal|0
decl_stmt|,
name|UpdMesg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|DoIDline
parameter_list|(
name|start
parameter_list|)
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
init|=
operator|&
name|DesiredScreen
index|[
name|start
index|]
decl_stmt|;
name|struct
name|scrimage
modifier|*
name|phys_p
init|=
operator|&
name|PhysScreen
index|[
name|start
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Some changes have been made.  Try for insert or delete lines. 	   If either case has happened, Addlines and/or DelLines will do 	   necessary scrolling, also CONVERTING PhysScreen to account for the 	   physical changes.  The comparison continues from where the 	   insertion/deletion takes place; this doesn't happen very often, 	   usually it happens with more than one window with the same 	   buffer. */
if|if
condition|(
operator|!
name|CanScroll
condition|)
return|return;
comment|/* We should never have been called! */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|ILI
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
control|)
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
condition|)
break|break;
for|for
control|(
init|;
name|i
operator|<
name|ILI
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ILI
condition|;
name|j
operator|++
control|)
block|{
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|j
index|]
expr_stmt|;
name|phys_p
operator|=
operator|&
name|PhysScreen
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|!=
literal|0
operator|&&
name|des_p
operator|->
name|s_id
operator|==
name|phys_p
operator|->
name|s_id
condition|)
break|break;
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|==
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
condition|)
block|{
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|AddLines
argument_list|(
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
condition|)
block|{
name|DoIDline
argument_list|(
name|j
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|i
index|]
operator|)
operator|->
name|s_id
operator|==
name|phys_p
operator|->
name|s_id
condition|)
block|{
if|if
condition|(
name|des_p
operator|->
name|s_id
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|DelLines
argument_list|(
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
condition|)
block|{
name|DoIDline
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make DesiredScreen reflect what the screen should look like when we are done    with the redisplay.  This deals with horizontal scrolling.  Also makes    sure the current line of the Window is in the window. */
end_comment

begin_decl_stmt
name|int
name|ScrollAll
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|UpdWindow
parameter_list|(
name|w
parameter_list|,
name|start
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
name|Line
modifier|*
name|lp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|upper
decl_stmt|,
comment|/* top of window */
name|lower
decl_stmt|,
comment|/* bottom of window */
name|strt_col
decl_stmt|,
comment|/* starting print column of current line */
name|ntries
init|=
literal|0
decl_stmt|;
comment|/* # of tries at updating window */
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
decl_stmt|,
modifier|*
name|phys_p
decl_stmt|;
name|Buffer
modifier|*
name|bp
init|=
name|w
operator|->
name|w_bufp
decl_stmt|;
name|retry
label|:
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_CURGONE
condition|)
block|{
name|w
operator|->
name|w_line
operator|=
name|bp
operator|->
name|b_dot
expr_stmt|;
name|w
operator|->
name|w_char
operator|=
name|bp
operator|->
name|b_char
expr_stmt|;
block|}
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_TOPGONE
condition|)
name|CentWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* reset topline of screen */
name|w
operator|->
name|w_flags
operator|&=
operator|~
operator|(
name|W_CURGONE
operator||
name|W_TOPGONE
operator|)
expr_stmt|;
comment|/* make sure that the current line is in the window */
name|upper
operator|=
name|start
expr_stmt|;
name|lower
operator|=
name|upper
operator|+
name|w
operator|->
name|w_height
operator|-
literal|1
expr_stmt|;
comment|/* don't include modeline */
for|for
control|(
name|i
operator|=
name|upper
operator|,
name|lp
operator|=
name|w
operator|->
name|w_top
init|;
name|i
operator|<
name|lower
operator|&&
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_line
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|lower
operator|||
name|lp
operator|==
literal|0
condition|)
block|{
name|ntries
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ntries
operator|==
literal|1
condition|)
block|{
name|CalcWind
argument_list|(
name|w
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|ntries
operator|==
literal|2
condition|)
block|{
name|w
operator|->
name|w_top
operator|=
name|w
operator|->
name|w_line
operator|=
name|w
operator|->
name|w_bufp
operator|->
name|b_first
expr_stmt|;
name|writef
argument_list|(
literal|"\rERROR in redisplay: I got hopelessly lost!"
argument_list|)
expr_stmt|;
name|dobell
argument_list|(
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
elseif|else
if|if
condition|(
name|ntries
operator|==
literal|3
condition|)
block|{
name|writef
argument_list|(
literal|"\n\rOops, still lost, quitting ...\r\n"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* first do some calculations for the current line */
block|{
name|int
name|diff
init|=
operator|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
operator|)
condition|?
literal|8
else|:
literal|0
decl_stmt|,
name|end_col
decl_stmt|;
name|strt_col
operator|=
operator|(
name|ScrollAll
operator|==
name|YES
operator|)
condition|?
name|w
operator|->
name|w_LRscroll
else|:
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_offset
expr_stmt|;
name|end_col
operator|=
name|strt_col
operator|+
operator|(
name|CO
operator|-
literal|2
operator|)
operator|-
name|diff
expr_stmt|;
comment|/* Right now we are displaying from strt_col to 		   end_col of the buffer line.  These are PRINT 		   columns, not actual characters. */
name|w
operator|->
name|w_dotcol
operator|=
name|find_pos
argument_list|(
name|w
operator|->
name|w_line
argument_list|,
name|w
operator|->
name|w_char
argument_list|)
expr_stmt|;
comment|/* if the new dotcol is out of range, reselect 		   a horizontal window */
if|if
condition|(
operator|(
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_offset
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|w
operator|->
name|w_dotcol
operator|<
name|strt_col
operator|)
operator|||
operator|(
name|w
operator|->
name|w_dotcol
operator|>=
name|end_col
operator|)
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|w_dotcol
operator|<
operator|(
operator|(
name|CO
operator|-
literal|2
operator|)
operator|-
name|diff
operator|)
condition|)
name|strt_col
operator|=
literal|0
expr_stmt|;
else|else
name|strt_col
operator|=
name|w
operator|->
name|w_dotcol
operator|-
operator|(
name|CO
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|ScrollAll
operator|==
name|YES
condition|)
block|{
if|if
condition|(
name|w
operator|->
name|w_LRscroll
operator|!=
name|strt_col
condition|)
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|w
operator|->
name|w_LRscroll
operator|=
name|strt_col
expr_stmt|;
block|}
block|}
name|w
operator|->
name|w_dotline
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|w_dotcol
operator|+=
name|diff
expr_stmt|;
block|}
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|upper
index|]
expr_stmt|;
name|phys_p
operator|=
operator|&
name|PhysScreen
index|[
name|upper
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|upper
operator|,
name|lp
operator|=
name|w
operator|->
name|w_top
init|;
name|lp
operator|!=
literal|0
operator|&&
name|i
operator|<
name|lower
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
name|des_p
operator|->
name|s_window
operator|=
name|w
expr_stmt|;
name|des_p
operator|->
name|s_lp
operator|=
name|lp
expr_stmt|;
name|des_p
operator|->
name|s_id
operator|=
name|lp
operator|->
name|l_dline
operator|&
operator|~
name|DIRTY
expr_stmt|;
name|des_p
operator|->
name|s_flags
operator|=
name|isdirty
argument_list|(
name|lp
argument_list|)
condition|?
name|L_MOD
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
condition|)
name|des_p
operator|->
name|s_vln
operator|=
name|w
operator|->
name|w_topnum
operator|+
operator|(
name|i
operator|-
name|upper
operator|)
expr_stmt|;
else|else
name|des_p
operator|->
name|s_vln
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|w
operator|->
name|w_line
condition|)
name|des_p
operator|->
name|s_offset
operator|=
name|strt_col
expr_stmt|;
else|else
name|des_p
operator|->
name|s_offset
operator|=
name|w
operator|->
name|w_LRscroll
expr_stmt|;
block|}
comment|/* Is structure assignment faster than copy each field separately? */
if|if
condition|(
name|i
operator|<
name|lower
condition|)
block|{
specifier|static
specifier|const
name|struct
name|scrimage
name|dirty_plate
init|=
block|{
literal|0
block|,
name|DIRTY
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|clean_plate
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|lower
condition|;
name|i
operator|++
operator|,
name|des_p
operator|++
operator|,
name|phys_p
operator|++
control|)
if|if
condition|(
name|phys_p
operator|->
name|s_id
operator|!=
literal|0
condition|)
operator|*
name|des_p
operator|=
name|dirty_plate
expr_stmt|;
else|else
operator|*
name|des_p
operator|=
name|clean_plate
expr_stmt|;
block|}
name|des_p
operator|->
name|s_window
operator|=
name|w
expr_stmt|;
name|des_p
operator|->
name|s_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|des_p
operator|->
name|s_id
operator|=
operator|(
name|int
operator|)
name|w
operator|->
name|w_bufp
operator|)
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
operator|||
name|UpdModLine
condition|)
name|des_p
operator|->
name|s_flags
operator|=
name|MODELINE
operator||
name|DIRTY
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|UpdModLine
condition|)
name|Modechange
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|curwind
operator|&&
name|w
operator|->
name|w_control
condition|)
name|SetScrollBar
argument_list|(
name|w
operator|->
name|w_control
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Write whatever is in mesgbuf (maybe we are Asking, or just printed    a message).  Turns off the UpdateMesg line flag. */
end_comment

begin_function
name|void
name|DrawMesg
parameter_list|(
name|abortable
parameter_list|)
name|int
name|abortable
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MAC
comment|/* same reason as in redisplay() */
if|if
condition|(
name|charp
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|i_set
argument_list|(
name|ILI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|swrite
argument_list|(
name|mesgbuf
argument_list|,
name|NO
argument_list|,
name|abortable
argument_list|)
condition|)
block|{
name|cl_eol
argument_list|()
expr_stmt|;
name|UpdMesg
operator|=
literal|0
expr_stmt|;
block|}
name|flusho
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Goto the current position in the current window.  Presumably redisplay()    has already been called, and curwind->{w_dotline,w_dotcol} have been set    correctly. */
end_comment

begin_function
name|private
name|void
name|GotoDot
parameter_list|()
block|{
if|if
condition|(
name|InputPending
condition|)
return|return;
name|Placur
argument_list|(
name|curwind
operator|->
name|w_dotline
argument_list|,
name|curwind
operator|->
name|w_dotcol
operator|-
name|PhysScreen
index|[
name|curwind
operator|->
name|w_dotline
index|]
operator|.
name|s_offset
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|int
name|UntilEqual
parameter_list|(
name|start
parameter_list|)
specifier|register
name|int
name|start
decl_stmt|;
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
init|=
operator|&
name|DesiredScreen
index|[
name|start
index|]
decl_stmt|,
modifier|*
name|phys_p
init|=
operator|&
name|PhysScreen
index|[
name|start
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|start
operator|<
name|ILI
operator|)
operator|&&
operator|(
name|des_p
operator|->
name|s_id
operator|!=
name|phys_p
operator|->
name|s_id
operator|)
condition|)
block|{
name|des_p
operator|+=
literal|1
expr_stmt|;
name|phys_p
operator|+=
literal|1
expr_stmt|;
name|start
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Calls the routine to do the physical changes, and changes PhysScreen to    reflect those changes. */
end_comment

begin_function
name|private
name|int
name|AddLines
parameter_list|(
name|at
parameter_list|,
name|num
parameter_list|)
specifier|register
name|int
name|at
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|bottom
init|=
name|UntilEqual
argument_list|(
name|at
operator|+
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|num
operator|>=
operator|(
operator|(
name|bottom
operator|-
literal|1
operator|)
operator|-
name|at
operator|)
condition|)
return|return
name|NO
return|;
comment|/* we did nothing */
name|v_ins_line
argument_list|(
name|num
argument_list|,
name|at
argument_list|,
name|bottom
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Now change PhysScreen to account for the physical change. */
for|for
control|(
name|i
operator|=
name|bottom
operator|-
literal|1
init|;
name|i
operator|-
name|num
operator|>=
name|at
condition|;
name|i
operator|--
control|)
name|PhysScreen
index|[
name|i
index|]
operator|=
name|PhysScreen
index|[
name|i
operator|-
name|num
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|at
operator|+
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
return|return
name|YES
return|;
comment|/* we did something */
block|}
end_function

begin_function
name|private
name|int
name|DelLines
parameter_list|(
name|at
parameter_list|,
name|num
parameter_list|)
specifier|register
name|int
name|at
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|bottom
init|=
name|UntilEqual
argument_list|(
name|at
operator|+
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|num
operator|>=
operator|(
operator|(
name|bottom
operator|-
literal|1
operator|)
operator|-
name|at
operator|)
condition|)
return|return
name|NO
return|;
name|v_del_line
argument_list|(
name|num
argument_list|,
name|at
argument_list|,
name|bottom
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|at
init|;
name|num
operator|+
name|i
operator|<
name|bottom
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|i
index|]
operator|=
name|PhysScreen
index|[
name|num
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bottom
operator|-
name|num
init|;
name|i
operator|<
name|bottom
condition|;
name|i
operator|++
control|)
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
return|return
name|YES
return|;
block|}
end_function

begin_comment
comment|/* Update line linenum in window w.  Only set PhysScreen to DesiredScreen    if the swrite or cl_eol works, that is nothing is interupted by    characters typed. */
end_comment

begin_function
name|private
name|void
name|UpdLine
parameter_list|(
name|linenum
parameter_list|)
specifier|register
name|int
name|linenum
decl_stmt|;
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|des_p
init|=
operator|&
name|DesiredScreen
index|[
name|linenum
index|]
decl_stmt|;
specifier|register
name|Window
modifier|*
name|w
init|=
name|des_p
operator|->
name|s_window
decl_stmt|;
name|i_set
argument_list|(
name|linenum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|des_p
operator|->
name|s_flags
operator|&
name|MODELINE
condition|)
name|ModeLine
argument_list|(
name|w
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|des_p
operator|->
name|s_id
condition|)
block|{
name|des_p
operator|->
name|s_lp
operator|->
name|l_dline
operator|&=
operator|~
name|DIRTY
expr_stmt|;
name|des_p
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|DIRTY
operator||
name|L_MOD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
operator|!
name|UseIC
operator|&&
operator|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|swrite
argument_list|(
name|sprint
argument_list|(
literal|"%6d  "
argument_list|,
name|des_p
operator|->
name|s_vln
argument_list|)
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|UseIC
condition|)
block|{
name|char
name|outbuf
index|[
name|MAXCOLS
index|]
decl_stmt|,
modifier|*
name|lptr
decl_stmt|;
name|int
name|fromcol
init|=
operator|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
operator|)
condition|?
literal|8
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|w
operator|->
name|w_flags
operator|&
name|W_NUMLINES
condition|)
name|swritef
argument_list|(
name|outbuf
argument_list|,
literal|"%6d  "
argument_list|,
name|des_p
operator|->
name|s_vln
argument_list|)
expr_stmt|;
name|lptr
operator|=
name|lcontents
argument_list|(
name|des_p
operator|->
name|s_lp
argument_list|)
expr_stmt|;
name|DeTab
argument_list|(
name|des_p
operator|->
name|s_offset
argument_list|,
name|lptr
argument_list|,
name|outbuf
operator|+
name|fromcol
argument_list|,
operator|(
sizeof|sizeof
name|outbuf
operator|)
operator|-
literal|1
operator|-
name|fromcol
argument_list|,
name|des_p
operator|->
name|s_window
operator|->
name|w_flags
operator|&
name|W_VISSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IDchar
argument_list|(
name|outbuf
argument_list|,
name|linenum
argument_list|,
literal|0
argument_list|)
condition|)
name|PhysScreen
index|[
name|linenum
index|]
operator|=
operator|*
name|des_p
expr_stmt|;
elseif|else
if|if
condition|(
name|i_set
argument_list|(
name|linenum
argument_list|,
literal|0
argument_list|)
operator|,
name|swrite
argument_list|(
name|outbuf
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
condition|)
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
else|else
name|PhysScreen
index|[
name|linenum
index|]
operator|.
name|s_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* ID_CHAR */
if|if
condition|(
name|BufSwrite
argument_list|(
name|linenum
argument_list|)
condition|)
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
else|else
name|PhysScreen
index|[
name|linenum
index|]
operator|.
name|s_id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PhysScreen
index|[
name|linenum
index|]
operator|.
name|s_id
condition|)
comment|/* not the same ... make sure */
name|do_cl_eol
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|do_cl_eol
parameter_list|(
name|linenum
parameter_list|)
specifier|register
name|int
name|linenum
decl_stmt|;
block|{
name|cl_eol
argument_list|()
expr_stmt|;
name|PhysScreen
index|[
name|linenum
index|]
operator|=
name|DesiredScreen
index|[
name|linenum
index|]
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ID_CHAR
end_ifdef

begin_comment
comment|/* From here to the end of the file is code that tries to utilize the    insert/delete character feature on some terminals.  It is very confusing    and not so well written code, AND there is a lot of it.  You may want    to use the space for something else. */
end_comment

begin_decl_stmt
name|int
name|IN_INSmode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|UseIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|DClen
decl_stmt|,
name|MDClen
decl_stmt|,
name|IClen
decl_stmt|,
name|MIClen
decl_stmt|,
name|IMlen
decl_stmt|,
name|CElen
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|disp_opt_init
parameter_list|()
block|{
name|DClen
operator|=
name|DC
condition|?
name|strlen
argument_list|(
name|DC
argument_list|)
else|:
literal|0
expr_stmt|;
name|MDClen
operator|=
name|M_DC
condition|?
name|strlen
argument_list|(
name|M_DC
argument_list|)
else|:
literal|9999
expr_stmt|;
name|IClen
operator|=
name|IC
condition|?
name|strlen
argument_list|(
name|IC
argument_list|)
else|:
literal|0
expr_stmt|;
name|MIClen
operator|=
name|M_IC
condition|?
name|strlen
argument_list|(
name|M_IC
argument_list|)
else|:
literal|9999
expr_stmt|;
name|IMlen
operator|=
name|IM
condition|?
name|strlen
argument_list|(
name|IM
argument_list|)
else|:
literal|0
expr_stmt|;
name|CElen
operator|=
name|CE
condition|?
name|strlen
argument_list|(
name|CE
argument_list|)
else|:
literal|0
expr_stmt|;
name|UseIC
operator|=
operator|(
name|IC
operator|||
name|IM
operator|||
name|M_IC
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|INSmode
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
if|if
condition|(
name|on
operator|&&
operator|!
name|IN_INSmode
condition|)
block|{
name|putpad
argument_list|(
name|IM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IN_INSmode
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|on
operator|&&
name|IN_INSmode
condition|)
block|{
name|putpad
argument_list|(
name|EI
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IN_INSmode
operator|=
name|NO
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|DeTab
parameter_list|(
name|s_offset
parameter_list|,
name|buf
parameter_list|,
name|outbuf
parameter_list|,
name|limit
parameter_list|,
name|visspace
parameter_list|)
name|int
name|s_offset
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
name|size_t
name|limit
decl_stmt|;
name|int
name|visspace
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|phys_p
init|=
name|outbuf
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|limitp
init|=
operator|&
name|outbuf
index|[
name|limit
index|]
decl_stmt|;
define|#
directive|define
name|OkayOut
parameter_list|(
name|ch
parameter_list|)
value|{ \ 	if ((pos++>= s_offset)&& (phys_p< limitp)) \ 		*phys_p++ = (ch); \ }
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|buf
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
init|=
operator|(
name|tabstop
operator|-
operator|(
name|pos
operator|%
name|tabstop
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|visspace
condition|)
block|{
name|OkayOut
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|nchars
operator|-=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|OkayOut
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|OkayOut
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|OkayOut
argument_list|(
name|c
operator|==
literal|0177
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|visspace
operator|&&
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
name|OkayOut
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|-
name|s_offset
operator|>=
name|CO
condition|)
block|{
name|phys_p
operator|=
operator|&
name|outbuf
index|[
name|CO
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|phys_p
operator|++
operator|=
literal|'!'
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|phys_p
operator|=
literal|0
expr_stmt|;
undef|#
directive|undef
name|OkayOut
block|}
end_function

begin_comment
comment|/* ID character routines full of special cases and other fun stuff like that.    It actually works though ...  	Returns Non-Zero if you are finished (no differences left). */
end_comment

begin_function
name|private
name|int
name|IDchar
parameter_list|(
name|new
parameter_list|,
name|lineno
parameter_list|,
name|col
parameter_list|)
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|lineno
decl_stmt|,
name|col
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|,
name|oldlen
decl_stmt|,
name|NumSaved
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|sline
init|=
operator|&
name|Screen
index|[
name|lineno
index|]
decl_stmt|;
name|oldlen
operator|=
name|sline
operator|->
name|s_length
operator|-
name|sline
operator|->
name|s_line
expr_stmt|;
for|for
control|(
name|i
operator|=
name|col
init|;
name|i
operator|<
name|oldlen
operator|&&
name|new
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sline
operator|->
name|s_line
index|[
name|i
index|]
operator|!=
name|new
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|new
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|i
operator|==
name|oldlen
condition|)
return|return
operator|(
name|new
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|i
operator|==
name|oldlen
operator|)
return|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|oldlen
operator|&&
name|new
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|new
index|[
name|j
index|]
operator|==
name|sline
operator|->
name|s_line
index|[
name|i
index|]
condition|)
block|{
name|NumSaved
operator|=
name|IDcomp
argument_list|(
name|new
operator|+
name|j
argument_list|,
name|sline
operator|->
name|s_line
operator|+
name|i
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|new
argument_list|)
argument_list|)
operator|+
name|NumSimilar
argument_list|(
name|new
operator|+
name|i
argument_list|,
name|sline
operator|->
name|s_line
operator|+
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|OkayInsert
argument_list|(
name|NumSaved
argument_list|,
name|j
operator|-
name|i
argument_list|)
condition|)
block|{
name|InsChar
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|IDchar
argument_list|(
name|new
argument_list|,
name|lineno
argument_list|,
name|j
argument_list|)
operator|)
return|;
block|}
block|}
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|oldlen
operator|&&
name|new
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|new
index|[
name|i
index|]
operator|==
name|sline
operator|->
name|s_line
index|[
name|j
index|]
condition|)
block|{
name|NumSaved
operator|=
name|IDcomp
argument_list|(
name|new
operator|+
name|i
argument_list|,
name|sline
operator|->
name|s_line
operator|+
name|j
argument_list|,
name|oldlen
operator|-
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|OkayDelete
argument_list|(
name|NumSaved
argument_list|,
name|j
operator|-
name|i
argument_list|,
name|new
index|[
name|oldlen
index|]
operator|==
literal|0
argument_list|)
condition|)
block|{
name|DelChar
argument_list|(
name|lineno
argument_list|,
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|IDchar
argument_list|(
name|new
argument_list|,
name|lineno
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|NumSimilar
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|t
operator|++
condition|)
name|num
operator|+=
literal|1
expr_stmt|;
return|return
name|num
return|;
block|}
end_block

begin_function
name|private
name|int
name|IDcomp
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|,
name|nonspace
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
operator|*
name|t
operator|++
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|nonspace
operator|++
expr_stmt|;
if|if
condition|(
name|nonspace
condition|)
name|num
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
end_block

begin_function
name|private
name|int
name|OkayDelete
parameter_list|(
name|Saved
parameter_list|,
name|num
parameter_list|,
name|samelength
parameter_list|)
name|int
name|Saved
decl_stmt|,
name|num
decl_stmt|,
name|samelength
decl_stmt|;
block|{
comment|/* If the old and the new are the same length, then we don't 	 * have to clear to end of line.  We take that into consideration. 	 */
return|return
operator|(
operator|(
name|Saved
operator|+
operator|(
operator|!
name|samelength
condition|?
name|CElen
else|:
literal|0
operator|)
operator|)
operator|>
name|min
argument_list|(
name|MDClen
argument_list|,
name|DClen
operator|*
name|num
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|OkayInsert
parameter_list|(
name|Saved
parameter_list|,
name|num
parameter_list|)
name|int
name|Saved
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IC
condition|)
comment|/* Per character prefixes */
name|n
operator|=
name|min
argument_list|(
name|num
operator|*
name|IClen
argument_list|,
name|MIClen
argument_list|)
expr_stmt|;
if|if
condition|(
name|IM
operator|&&
operator|!
name|IN_INSmode
condition|)
block|{
comment|/* Good terminal.  Fewer characters in this case */
name|n
operator|+=
name|IMlen
expr_stmt|;
block|}
name|n
operator|+=
name|num
expr_stmt|;
comment|/* The characters themselves */
return|return
name|Saved
operator|>
name|n
return|;
block|}
end_function

begin_function
name|private
name|void
name|DelChar
parameter_list|(
name|lineno
parameter_list|,
name|col
parameter_list|,
name|num
parameter_list|)
name|int
name|lineno
decl_stmt|,
name|col
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|screenline
modifier|*
name|sp
init|=
operator|(
operator|&
name|Screen
index|[
name|lineno
index|]
operator|)
decl_stmt|;
name|Placur
argument_list|(
name|lineno
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DC
operator|&&
name|num
operator|>
literal|1
condition|)
block|{
name|putargpad
argument_list|(
name|M_DC
argument_list|,
name|num
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|num
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|putpad
argument_list|(
name|DC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|sp
operator|->
name|s_line
operator|+
name|col
expr_stmt|;
name|from
operator|=
name|to
operator|+
name|num
expr_stmt|;
name|byte_copy
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|sp
operator|->
name|s_length
operator|-
name|from
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|clrline
argument_list|(
name|sp
operator|->
name|s_length
operator|-
name|num
argument_list|,
name|sp
operator|->
name|s_length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_length
operator|-=
name|num
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|InsChar
parameter_list|(
name|lineno
parameter_list|,
name|col
parameter_list|,
name|num
parameter_list|,
name|new
parameter_list|)
name|int
name|lineno
decl_stmt|,
name|col
decl_stmt|,
name|num
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|sp2
decl_stmt|,
comment|/* To push over the array. */
modifier|*
name|sp3
decl_stmt|;
comment|/* Last character to push over. */
name|int
name|i
decl_stmt|;
name|i_set
argument_list|(
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sp2
operator|=
name|Curline
operator|->
name|s_length
operator|+
name|num
expr_stmt|;
if|if
condition|(
name|sp2
operator|>=
name|cursend
condition|)
block|{
name|i_set
argument_list|(
name|lineno
argument_list|,
name|CO
operator|-
name|num
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cl_eol
argument_list|()
expr_stmt|;
name|sp2
operator|=
name|cursend
operator|-
literal|1
expr_stmt|;
block|}
name|Curline
operator|->
name|s_length
operator|=
name|sp2
expr_stmt|;
name|sp1
operator|=
name|sp2
operator|-
name|num
expr_stmt|;
name|sp3
operator|=
name|Curline
operator|->
name|s_line
operator|+
name|col
expr_stmt|;
while|while
condition|(
name|sp1
operator|>=
name|sp3
condition|)
operator|*
name|sp2
operator|--
operator|=
operator|*
name|sp1
operator|--
expr_stmt|;
name|new
operator|+=
name|col
expr_stmt|;
name|byte_copy
argument_list|(
name|new
argument_list|,
name|sp3
argument_list|,
operator|(
name|size_t
operator|)
name|num
argument_list|)
expr_stmt|;
comment|/* The internal screen is correct, and now we have to do 	   the physical stuff. */
name|Placur
argument_list|(
name|lineno
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|IM
condition|)
block|{
if|if
condition|(
operator|!
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|M_IC
operator|&&
name|num
operator|>
literal|1
condition|)
block|{
name|putargpad
argument_list|(
name|M_IC
argument_list|,
name|num
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|IC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|jputchar
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_INSmode
condition|)
name|putpad
argument_list|(
name|IP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|CapCol
operator|+=
name|num
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ID_CHAR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_comment
comment|/* obviously ... no mail today if not Unix*/
end_comment

begin_comment
comment|/* chkmail() returns nonzero if there is new mail since the    last time we checked. */
end_comment

begin_decl_stmt
name|char
name|Mailbox
index|[
name|FILESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialized in main */
end_comment

begin_decl_stmt
name|int
name|MailInt
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check no more often than 60 seconds */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIFF
end_ifdef

begin_decl_stmt
name|int
name|BiffChk
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether to turn off biff while in JOVE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|chkmail
parameter_list|(
name|force
parameter_list|)
name|int
name|force
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
specifier|static
name|int
name|state
init|=
name|NO
decl_stmt|;
comment|/* assume unknown */
specifier|static
name|time_t
name|last_chk
init|=
literal|0
decl_stmt|,
name|mbox_time
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|MailInt
operator|==
literal|0
condition|)
return|return
name|NO
return|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|force
operator|==
name|NO
operator|)
operator|&&
operator|(
name|now
operator|<
name|last_chk
operator|+
name|MailInt
operator|)
condition|)
return|return
name|state
return|;
name|last_chk
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|Mailbox
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|state
operator|=
name|NO
expr_stmt|;
comment|/* no mail */
return|return
name|NO
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|stbuf
operator|.
name|st_atime
operator|>
name|stbuf
operator|.
name|st_mtime
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_atime
operator|>
name|mbox_time
operator|)
operator|)
operator|||
operator|(
name|stbuf
operator|.
name|st_size
operator|==
literal|0
operator|)
condition|)
block|{
name|mbox_time
operator|=
name|stbuf
operator|.
name|st_atime
expr_stmt|;
name|state
operator|=
name|NO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|mbox_time
condition|)
block|{
if|if
condition|(
name|mbox_time
operator|>
literal|0
condition|)
name|dobell
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* announce the change */
name|mbox_time
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
name|state
operator|=
name|YES
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_comment
comment|/* Print the mode line. */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|mode_p
decl_stmt|,
modifier|*
name|mend_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|BriteMode
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modeline should standout */
end_comment

begin_function
name|private
name|void
name|mode_app
parameter_list|(
name|str
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|(
name|mode_p
operator|<
name|mend_p
operator|)
operator|&&
operator|(
operator|*
name|mode_p
operator|++
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
name|mode_p
operator|-=
literal|1
expr_stmt|;
comment|/* back over the null */
block|}
end_function

begin_decl_stmt
name|char
name|ModeFmt
index|[
literal|120
index|]
init|=
literal|"%3c %w %[%sJOVE (%M)   Buffer: %b  \"%f\" %]%s%m*- %((%t)%s%)%e"
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|ModeLine
parameter_list|(
name|w
parameter_list|)
specifier|register
name|Window
modifier|*
name|w
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ign_some
init|=
name|NO
decl_stmt|,
name|glue
init|=
literal|0
decl_stmt|;
name|char
name|line
index|[
name|MAXCOLS
index|]
decl_stmt|,
modifier|*
name|fmt
init|=
name|ModeFmt
decl_stmt|,
name|fillc
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|thisbuf
init|=
name|w
operator|->
name|w_bufp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|bp
decl_stmt|;
name|mode_p
operator|=
name|line
expr_stmt|;
name|mend_p
operator|=
operator|&
name|line
index|[
operator|(
sizeof|sizeof
name|line
operator|)
operator|-
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
comment|/* very subtle - don't mess up attributes too much */
name|fillc
operator|=
literal|'-'
expr_stmt|;
else|#
directive|else
comment|/* !IBMPC */
ifdef|#
directive|ifdef
name|MAC
name|fillc
operator|=
literal|'_'
expr_stmt|;
comment|/* looks better on a Mac */
else|#
directive|else
comment|/* !MAC */
if|if
condition|(
name|SO
operator|==
literal|0
condition|)
name|BriteMode
operator|=
literal|0
expr_stmt|;
name|fillc
operator|=
name|BriteMode
condition|?
literal|' '
else|:
literal|'-'
expr_stmt|;
endif|#
directive|endif
comment|/* !MAC */
endif|#
directive|endif
comment|/* !IBMPC */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|mode_p
operator|<
name|mend_p
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
name|ign_some
condition|)
operator|*
name|mode_p
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|==
literal|'\0'
condition|)
comment|/* char after the '%' */
break|break;
if|if
condition|(
name|ign_some
operator|&&
name|c
operator|!=
literal|')'
condition|)
continue|continue;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
if|if
condition|(
name|w
operator|->
name|w_next
operator|!=
name|fwind
condition|)
comment|/* Not bottom window. */
name|ign_some
operator|=
name|YES
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|ign_some
operator|=
name|NO
expr_stmt|;
break|break;
case|case
literal|'['
case|:
case|case
literal|']'
case|:
for|for
control|(
name|n
operator|=
name|RecDepth
init|;
name|n
operator|>
literal|0
operator|&&
name|mode_p
operator|<
name|mend_p
condition|;
name|n
operator|--
control|)
operator|*
name|mode_p
operator|++
operator|=
name|c
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|UNIX
case|case
literal|'C'
case|:
comment|/* check mail here */
if|if
condition|(
name|chkmail
argument_list|(
name|NO
argument_list|)
operator|==
name|YES
condition|)
name|mode_app
argument_list|(
literal|"[New mail]"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* UNIX */
case|case
literal|'M'
case|:
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mmodes
index|[]
init|=
block|{
literal|"Fundamental "
block|,
literal|"Text "
block|,
literal|"C "
block|,
ifdef|#
directive|ifdef
name|LISP
literal|"Lisp "
block|,
endif|#
directive|endif
literal|0
block|}
decl_stmt|;
name|mode_app
argument_list|(
name|mmodes
index|[
name|thisbuf
operator|->
name|b_major
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|Fill
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"Fill "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|Abbrev
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"Abbrev "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|OverWrite
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"OvrWt "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|Indent
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"AI "
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufMinorMode
argument_list|(
name|thisbuf
argument_list|,
name|ReadOnly
argument_list|)
condition|)
name|mode_app
argument_list|(
literal|"RO "
argument_list|)
expr_stmt|;
if|if
condition|(
name|InMacDefine
condition|)
name|mode_app
argument_list|(
literal|"Def "
argument_list|)
expr_stmt|;
name|mode_p
operator|-=
literal|1
expr_stmt|;
comment|/* Back over the extra space. */
break|break;
block|}
case|case
literal|'c'
case|:
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
name|mode_p
operator|<
name|mend_p
condition|)
operator|*
name|mode_p
operator|++
operator|=
name|fillc
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* print working directory */
name|mode_app
argument_list|(
name|pr_name
argument_list|(
name|pwd
argument_list|()
argument_list|,
name|YES
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* stretchable glue */
operator|*
name|mode_p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* glue marker */
name|glue
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|mode_app
argument_list|(
name|thisbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|thisbuf
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|mode_app
argument_list|(
literal|"[No file]"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|mode_app
argument_list|(
name|pr_name
argument_list|(
name|thisbuf
operator|->
name|b_fname
argument_list|,
name|YES
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mode_app
argument_list|(
name|basename
argument_list|(
name|thisbuf
operator|->
name|b_fname
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|LOAD_AV
case|case
literal|'l'
case|:
block|{
name|double
name|theavg
decl_stmt|;
name|char
name|minibuf
index|[
literal|10
index|]
decl_stmt|;
name|get_la
argument_list|(
operator|&
name|theavg
argument_list|)
expr_stmt|;
name|theavg
operator|+=
literal|.005
expr_stmt|;
comment|/* round to nearest .01 */
name|swritef
argument_list|(
name|minibuf
argument_list|,
literal|"%d.%02d"
argument_list|,
operator|(
name|int
operator|)
name|theavg
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|theavg
operator|-
operator|(
name|int
operator|)
name|theavg
operator|)
operator|*
literal|100
argument_list|)
argument_list|)
expr_stmt|;
name|mode_app
argument_list|(
name|minibuf
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
literal|'m'
case|:
block|{
name|char
name|yea
init|=
operator|(
operator|*
name|fmt
operator|==
literal|'\0'
operator|)
condition|?
literal|'*'
else|:
operator|*
name|fmt
operator|++
decl_stmt|;
name|char
name|nay
init|=
operator|(
operator|*
name|fmt
operator|==
literal|'\0'
operator|)
condition|?
literal|' '
else|:
operator|*
name|fmt
operator|++
decl_stmt|;
operator|*
name|mode_p
operator|++
operator|=
name|IsModified
argument_list|(
name|w
operator|->
name|w_bufp
argument_list|)
condition|?
name|yea
else|:
name|nay
expr_stmt|;
break|break;
block|}
case|case
literal|'n'
case|:
block|{
name|char
name|tmp
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|world
operator|,
name|n
operator|=
literal|1
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
operator|,
name|n
operator|++
control|)
if|if
condition|(
name|bp
operator|==
name|thisbuf
condition|)
break|break;
name|swritef
argument_list|(
name|tmp
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mode_app
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|IPROCS
case|case
literal|'p'
case|:
if|if
condition|(
name|thisbuf
operator|->
name|b_type
operator|==
name|B_PROCESS
condition|)
block|{
name|char
name|tmp
index|[
literal|40
index|]
decl_stmt|;
name|Process
modifier|*
name|p
init|=
name|thisbuf
operator|->
name|b_process
decl_stmt|;
name|swritef
argument_list|(
name|tmp
argument_list|,
literal|"(%s%s)"
argument_list|,
operator|(
operator|(
name|p
operator|==
literal|0
operator|||
name|p
operator|->
name|p_dbx_mode
operator|==
name|NO
operator|)
condition|?
literal|""
else|:
literal|"DBX "
operator|)
argument_list|,
operator|(
operator|(
name|p
operator|==
literal|0
operator|)
condition|?
literal|"No process"
else|:
name|pstate
argument_list|(
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mode_app
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
literal|'s'
case|:
if|if
condition|(
name|mode_p
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
operator|*
name|mode_p
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
block|{
name|char
name|timestr
index|[
literal|12
index|]
decl_stmt|;
name|mode_app
argument_list|(
name|get_time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|,
name|timestr
argument_list|,
literal|11
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'w'
case|:
if|if
condition|(
name|w
operator|->
name|w_LRscroll
operator|>
literal|0
condition|)
name|mode_app
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Glue (Knuth's term) is a field that expands to fill 	 * any leftover space.  Multiple glue fields compete 	 * on an equal basis.  This is a generalization of a 	 * mechanism to allow centring and right-justification. 	 * The original meaning of %e (fill the rest of the 	 * line) has also been generalized.  %e can now 	 * meaningfully be used 0 or more times. 	 */
if|if
condition|(
name|glue
condition|)
block|{
comment|/* 2 space pad plus padding for magic cookies */
specifier|register
name|char
modifier|*
name|to
init|=
operator|&
name|line
index|[
name|CO
operator|-
literal|2
operator|-
operator|(
literal|2
operator|*
name|SG
operator|)
index|]
decl_stmt|,
modifier|*
name|from
init|=
name|mode_p
decl_stmt|;
if|if
condition|(
name|to
operator|<
name|from
condition|)
name|to
operator|=
name|from
expr_stmt|;
name|mode_p
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|from
operator|!=
name|line
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|--
name|to
operator|=
operator|*
operator|--
name|from
operator|)
operator|==
literal|'\0'
condition|)
block|{
specifier|register
name|int
name|portion
init|=
operator|(
name|to
operator|-
name|from
operator|)
operator|/
name|glue
decl_stmt|;
name|glue
operator|--
expr_stmt|;
operator|*
name|to
operator|=
name|fillc
expr_stmt|;
while|while
condition|(
operator|--
name|portion
operator|>=
literal|0
condition|)
operator|*
operator|--
name|to
operator|=
name|fillc
expr_stmt|;
block|}
block|}
block|}
operator|*
name|mode_p
operator|=
literal|0
expr_stmt|;
comment|/* Highlight mode line. */
if|if
condition|(
name|BriteMode
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SO_on
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|swrite
argument_list|(
name|line
argument_list|,
name|BriteMode
argument_list|,
name|YES
argument_list|)
condition|)
name|do_cl_eol
argument_list|(
name|i_line
argument_list|)
expr_stmt|;
else|else
name|UpdModLine
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|BriteMode
condition|)
name|SO_off
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|v_clear
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
specifier|register
name|int
name|line1
decl_stmt|;
name|int
name|line2
decl_stmt|;
block|{
specifier|register
name|struct
name|scrimage
modifier|*
name|phys_p
decl_stmt|,
modifier|*
name|des_p
decl_stmt|;
name|phys_p
operator|=
operator|&
name|PhysScreen
index|[
name|line1
index|]
expr_stmt|;
name|des_p
operator|=
operator|&
name|DesiredScreen
index|[
name|line1
index|]
expr_stmt|;
while|while
condition|(
name|line1
operator|<=
name|line2
condition|)
block|{
name|i_set
argument_list|(
name|line1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cl_eol
argument_list|()
expr_stmt|;
name|phys_p
operator|->
name|s_id
operator|=
name|des_p
operator|->
name|s_id
operator|=
literal|0
expr_stmt|;
name|phys_p
operator|+=
literal|1
expr_stmt|;
name|des_p
operator|+=
literal|1
expr_stmt|;
name|line1
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This tries to place the current line of the current window in the    center of the window, OR to place it at the arg'th line of the window.    This also causes the horizontal position of the line to be centered,    if the line needs scrolling, or moved all the way back to the left,    if that's possible. */
end_comment

begin_function
name|void
name|RedrawDisplay
parameter_list|()
block|{
name|int
name|line
decl_stmt|;
name|Line
modifier|*
name|newtop
init|=
name|prev_line
argument_list|(
operator|(
name|curwind
operator|->
name|w_line
operator|=
name|curline
operator|)
argument_list|,
name|is_an_arg
argument_list|()
condition|?
name|arg_value
argument_list|()
else|:
name|HALF
argument_list|(
name|curwind
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|line
operator|=
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_line
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|PhysScreen
index|[
name|line
index|]
operator|.
name|s_offset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newtop
operator|==
name|curwind
operator|->
name|w_top
condition|)
name|v_clear
argument_list|(
name|FLine
argument_list|(
name|curwind
argument_list|)
argument_list|,
name|FLine
argument_list|(
name|curwind
argument_list|)
operator|+
name|SIZE
argument_list|(
name|curwind
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|newtop
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ClAndRedraw
parameter_list|()
block|{
name|cl_scr
argument_list|(
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|NextPage
parameter_list|()
block|{
name|Line
modifier|*
name|newline
decl_stmt|;
if|if
condition|(
name|Asking
condition|)
return|return;
if|if
condition|(
name|arg_value
argument_list|()
operator|<
literal|0
condition|)
block|{
name|negate_arg_value
argument_list|()
expr_stmt|;
name|PrevPage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg_type
argument_list|()
operator|==
name|YES
condition|)
name|UpScroll
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_bufp
operator|->
name|b_last
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|newline
operator|=
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|max
argument_list|(
literal|1
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_line
operator|=
name|newline
argument_list|)
expr_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
condition|)
name|SetLine
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_comment
comment|/* kg */
end_comment

begin_function
name|void
name|PageScrollUp
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|UpScroll
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|PageScrollDown
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|DownScroll
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|void
name|PrevPage
parameter_list|()
block|{
name|Line
modifier|*
name|newline
decl_stmt|;
if|if
condition|(
name|Asking
condition|)
return|return;
if|if
condition|(
name|arg_value
argument_list|()
operator|<
literal|0
condition|)
block|{
name|negate_arg_value
argument_list|()
expr_stmt|;
name|NextPage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg_type
argument_list|()
operator|==
name|YES
condition|)
name|DownScroll
argument_list|()
expr_stmt|;
else|else
block|{
name|newline
operator|=
name|prev_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|max
argument_list|(
literal|1
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|curwind
operator|->
name|w_line
operator|=
name|newline
argument_list|)
expr_stmt|;
if|if
condition|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
condition|)
name|SetLine
argument_list|(
name|newline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|UpScroll
parameter_list|()
block|{
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|arg_value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
operator|)
operator|&&
operator|(
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curline
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|SetLine
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|DownScroll
parameter_list|()
block|{
name|SetTop
argument_list|(
name|curwind
argument_list|,
name|prev_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|arg_value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|curwind
operator|->
name|w_bufp
operator|==
name|curbuf
operator|)
operator|&&
operator|(
name|in_window
argument_list|(
name|curwind
argument_list|,
name|curline
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|)
name|SetLine
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|VisBell
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|rbell
parameter_list|()
block|{
name|RingBell
operator|=
name|YES
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Message prints the null terminated string onto the bottom line of the    terminal. */
end_comment

begin_function
name|void
name|message
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|InJoverc
condition|)
return|return;
name|UpdMesg
operator|=
name|YES
expr_stmt|;
name|errormsg
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|mesgbuf
condition|)
name|null_ncpy
argument_list|(
name|mesgbuf
argument_list|,
name|str
argument_list|,
operator|(
sizeof|sizeof
name|mesgbuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End of Window */
end_comment

begin_function
name|void
name|Eow
parameter_list|()
block|{
if|if
condition|(
name|Asking
condition|)
return|return;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
operator|-
name|min
argument_list|(
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|,
name|arg_value
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_an_arg
argument_list|()
condition|)
name|Eol
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Beginning of Window */
end_comment

begin_function
name|void
name|Bow
parameter_list|()
block|{
if|if
condition|(
name|Asking
condition|)
return|return;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curwind
operator|->
name|w_top
argument_list|,
name|min
argument_list|(
name|SIZE
argument_list|(
name|curwind
argument_list|)
operator|-
literal|1
argument_list|,
name|arg_value
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|int
name|LineNo
decl_stmt|,
name|last_col
decl_stmt|,
name|DoAutoNL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|Window
modifier|*
name|old_wind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save the window we were in BEFORE 				   before we were called, if UseBuffers 				   is nonzero */
end_comment

begin_decl_stmt
name|int
name|UseBuffers
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TOabort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This initializes the typeout.  If send-typeout-to-buffers is set    the buffer NAME is created (emptied if it already exists) and output    goes to the buffer.  Otherwise output is drawn on the screen and    erased by TOstop() */
end_comment

begin_function
name|void
name|TOstart
parameter_list|(
name|name
parameter_list|,
name|auto_newline
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|auto_newline
decl_stmt|;
block|{
if|if
condition|(
name|UseBuffers
condition|)
block|{
name|old_wind
operator|=
name|curwind
expr_stmt|;
name|pop_wind
argument_list|(
name|name
argument_list|,
name|YES
argument_list|,
name|B_SCRATCH
argument_list|)
expr_stmt|;
block|}
else|else
name|DisabledRedisplay
operator|=
name|YES
expr_stmt|;
name|TOabort
operator|=
name|LineNo
operator|=
name|last_col
operator|=
literal|0
expr_stmt|;
name|DoAutoNL
operator|=
name|auto_newline
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_function
name|void
name|Typeout
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS1*/
function|void Typeout
parameter_list|(
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
if|if
condition|(
name|TOabort
condition|)
return|return;
if|if
condition|(
operator|!
name|UseBuffers
operator|&&
operator|(
name|LineNo
operator|==
name|ILI
operator|-
literal|1
operator|)
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|LineNo
operator|=
literal|0
expr_stmt|;
name|last_col
operator|=
literal|0
expr_stmt|;
name|f_mess
argument_list|(
literal|"--more--"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|jgetchar
argument_list|()
operator|)
operator|!=
literal|' '
condition|)
block|{
name|TOabort
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|AbortChar
operator|&&
name|c
operator|!=
name|RUBOUT
condition|)
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_mess
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fmt
condition|)
block|{
name|char
name|string
index|[
literal|132
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|format
argument_list|(
name|string
argument_list|,
sizeof|sizeof
name|string
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|UseBuffers
condition|)
name|ins_str
argument_list|(
name|string
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
block|{
name|i_set
argument_list|(
name|LineNo
argument_list|,
name|last_col
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|swrite
argument_list|(
name|string
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|last_col
operator|=
name|i_col
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|UseBuffers
condition|)
block|{
name|PhysScreen
index|[
name|LineNo
index|]
operator|.
name|s_id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
literal|0
operator|||
name|DoAutoNL
operator|==
name|YES
condition|)
block|{
name|cl_eol
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|LineNo
operator|+=
literal|1
expr_stmt|;
name|last_col
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
literal|0
operator|||
name|DoAutoNL
operator|!=
literal|0
condition|)
name|ins_str
argument_list|(
literal|"\n"
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|TOstop
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|UseBuffers
condition|)
block|{
name|ToFirst
argument_list|()
expr_stmt|;
name|SetWind
argument_list|(
name|old_wind
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TOabort
condition|)
block|{
name|DisabledRedisplay
operator|=
name|NO
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|last_col
operator|!=
literal|0
condition|)
name|Typeout
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"----------"
argument_list|)
expr_stmt|;
name|cl_eol
argument_list|()
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|c
operator|=
name|jgetchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DisabledRedisplay
operator|=
name|NO
expr_stmt|;
block|}
block|}
end_function

end_unit

