begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_decl_stmt
name|int
name|AbortCnt
decl_stmt|,
name|CanScroll
init|=
literal|0
decl_stmt|,
name|tabstop
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
end_if

begin_decl_stmt
name|private
name|void
argument_list|(
operator|*
name|TTins_line
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
argument_list|(
operator|*
name|TTdel_line
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(IBMPC) || defined(MAC)) */
end_comment

begin_decl_stmt
name|struct
name|scrimage
modifier|*
name|DesiredScreen
init|=
literal|0
decl_stmt|,
modifier|*
name|PhysScreen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|screenline
modifier|*
name|Screen
init|=
literal|0
decl_stmt|,
comment|/* the screen (a bunch of screenline) */
modifier|*
name|Curline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line */
end_comment

begin_decl_stmt
name|private
name|struct
name|screenline
modifier|*
name|Savelines
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* another bunch (LI of them) */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|cursor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset into current Line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cursend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|CapCol
decl_stmt|,
name|CapLine
decl_stmt|,
name|i_line
decl_stmt|,
name|i_col
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|CHPL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|near
name|normfun
argument_list|()
decl_stmt|,
name|near
name|scr_win
argument_list|()
decl_stmt|,
name|near
name|clr_page
argument_list|()
decl_stmt|,
name|near
name|clr_eoln
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|make_scr
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|ns
decl_stmt|;
specifier|register
name|char
modifier|*
name|nsp
decl_stmt|;
ifdef|#
directive|ifdef
name|RESHAPING
comment|/* In case we are RESHAPING the window! */
if|if
condition|(
name|DesiredScreen
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|DesiredScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|PhysScreen
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|PhysScreen
argument_list|)
expr_stmt|;
if|if
condition|(
name|Savelines
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Savelines
argument_list|)
expr_stmt|;
if|if
condition|(
name|Screen
condition|)
block|{
name|free
argument_list|(
name|Screen
operator|->
name|s_line
argument_list|)
expr_stmt|;
comment|/* free all the screen data */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Screen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RESHAPING */
name|DesiredScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|PhysScreen
operator|=
operator|(
expr|struct
name|scrimage
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scrimage
argument_list|)
argument_list|)
expr_stmt|;
name|Savelines
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|Screen
operator|=
operator|(
expr|struct
name|screenline
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|LI
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|screenline
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|CO
operator|*
name|LI
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
operator|==
literal|0
condition|)
block|{
name|writef
argument_list|(
literal|"\n\rCannot malloc screen!\n"
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
control|)
block|{
name|ns
operator|->
name|s_line
operator|=
name|nsp
expr_stmt|;
name|nsp
operator|+=
name|CO
expr_stmt|;
name|ns
operator|->
name|s_length
operator|=
name|nsp
operator|-
literal|1
expr_stmt|;
comment|/* End of Line */
name|ns
operator|+=
literal|1
expr_stmt|;
block|}
name|cl_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clrline
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
decl|*
name|cp2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|cp1
operator|<=
name|cp2
condition|)
operator|*
name|cp1
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|((*cursor != (char) (c)) ? dosputc((c)) : (cursor++, i_col++))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (defined(IBMPC) || defined(MAC)) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IBMPC
end_ifdef

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|dosputc((c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_define
define|#
directive|define
name|sputc
parameter_list|(
name|c
parameter_list|)
value|bufputc((c))
end_define

begin_comment
comment|/* line buffered for mac display */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_define
define|#
directive|define
name|soutputc
parameter_list|(
name|c
parameter_list|)
value|{ if (--n<= 0) break; else sputc((c)); }
end_define

begin_function
name|void
name|cl_eol
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|>
name|cursend
condition|)
return|return;
if|if
condition|(
name|cursor
operator|<
name|Curline
operator|->
name|s_length
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
if|if
condition|(
name|CE
condition|)
block|{
endif|#
directive|endif
comment|/* (defined(IBMPC) || defined(MAC)) */
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMCAP
name|putpad
argument_list|(
name|CE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|clr_eoln
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TERMCAP */
name|clrline
argument_list|(
name|cursor
argument_list|,
name|Curline
operator|->
name|s_length
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
block|}
else|else
block|{
comment|/* Ugh.  The slow way for dumb terminals. */
specifier|register
name|char
modifier|*
name|savecp
init|=
name|cursor
decl_stmt|;
while|while
condition|(
name|cursor
operator|<=
name|Curline
operator|->
name|s_length
condition|)
name|sputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|savecp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (defined(IBMPC) || defined(MAC)) */
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cl_scr
parameter_list|(
name|doit
parameter_list|)
name|int
name|doit
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|screenline
modifier|*
name|sp
init|=
name|Screen
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LI
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
name|clrline
argument_list|(
name|sp
operator|->
name|s_line
argument_list|,
name|sp
operator|->
name|s_length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_length
operator|=
name|sp
operator|->
name|s_line
expr_stmt|;
name|PhysScreen
index|[
name|i
index|]
operator|.
name|s_id
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|doit
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMCAP
name|putpad
argument_list|(
name|CL
argument_list|,
name|LI
argument_list|)
expr_stmt|;
else|#
directive|else
name|clr_page
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* TERMCAP */
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|UpdMesg
operator|=
name|YES
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output one character (if necessary) at the current position */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|int
comment|/* only for lints sake */
name|dosputc
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
operator|*
name|cursor
operator|!=
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* IBMPC */
if|if
condition|(
operator|(
name|force
operator|)
operator|||
operator|(
operator|*
name|cursor
operator|!=
name|c
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* IBMPC */
if|if
condition|(
name|i_line
operator|!=
name|CapLine
operator|||
name|i_col
operator|!=
name|CapCol
condition|)
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
name|UL
operator|&&
operator|(
name|c
operator|&
name|CHARMASK
operator|)
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|cursor
operator|&
name|CHARMASK
operator|)
operator|!=
literal|' '
condition|)
name|putstr
argument_list|(
literal|" \b"
argument_list|)
expr_stmt|;
comment|/* Erase so '_' looks right. */
endif|#
directive|endif
comment|/* IBMPC */
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|jputchar
argument_list|(
name|c
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|normfun
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|AbortCnt
operator|-=
literal|1
expr_stmt|;
name|CapCol
operator|+=
literal|1
expr_stmt|;
name|i_col
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|+=
literal|1
expr_stmt|;
name|i_col
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* useless result */
block|}
else|#
directive|else
comment|/* MAC */
comment|/* Character output to bit-mapped screen is very expensive. It makes    much more sense to write the entire line at once. So, we print all    the characters, whether already there or not, once the line is    complete.  */
define|#
directive|define
name|BUFFLUSH
value|(char) 0
define|#
directive|define
name|BUFSTART
value|(char) 1
name|bufputc
argument_list|(
name|c
argument_list|)
specifier|register
name|char
name|c
expr_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|BUFSTART
condition|)
block|{
comment|/*		if (i_line != CapLine || i_col != CapCol)*/
name|NPlacur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
name|BUFFLUSH
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|len
expr_stmt|;
name|writechr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
literal|255
condition|)
return|return;
operator|*
name|cursor
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
name|buf
index|[
operator|++
name|len
index|]
operator|=
literal|0xAF
expr_stmt|;
comment|/* slashed zero */
else|else
name|buf
index|[
operator|++
name|len
index|]
operator|=
name|c
expr_stmt|;
name|CapCol
operator|++
expr_stmt|;
name|i_col
operator|++
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* MAC */
comment|/* Write `line' at the current position of `cursor'.  Stop when we    reach the end of the screen.  Aborts if there is a character    waiting.  */
ifdef|#
directive|ifdef
name|MAC
comment|/* This was getting too complicated with ifdefs ... */
name|int
name|swrite
parameter_list|(
name|line
parameter_list|,
name|inversep
parameter_list|,
name|abortable
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|int
name|abortable
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
name|i_col
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|sputc
argument_list|(
name|BUFSTART
argument_list|)
expr_stmt|;
comment|/* Okay, because no interruption possible */
while|while
condition|(
name|c
operator|=
operator|*
name|line
operator|++
condition|)
block|{
if|if
condition|(
name|abortable
operator|&&
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
name|InputPending
operator|=
name|charp
argument_list|()
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
decl_stmt|;
name|nchars
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
while|while
condition|(
name|nchars
operator|--
condition|)
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|sputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
name|sputc
argument_list|(
name|BUFFLUSH
argument_list|)
expr_stmt|;
return|return
operator|!
name|aborted
return|;
block|}
else|#
directive|else
comment|/* MAC */
name|int
name|swrite
parameter_list|(
name|line
parameter_list|,
name|inversep
parameter_list|,
name|abortable
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|inversep
decl_stmt|;
specifier|register
name|int
name|abortable
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|col
init|=
name|i_col
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|int
name|or_byte
init|=
name|inversep
condition|?
literal|0200
else|:
literal|0
decl_stmt|,
name|thebyte
decl_stmt|;
else|#
directive|else
name|int
name|thebyte
decl_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
ifdef|#
directive|ifdef
name|IBMPC
name|force
operator|=
name|inversep
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* to force a redraw of the modeline */
endif|#
directive|endif
comment|/* IBMPC */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|line
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|abortable
operator|&&
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
decl_stmt|;
name|nchars
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|thebyte
operator|=
operator|(
literal|' '
operator||
name|or_byte
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
while|while
condition|(
name|nchars
operator|--
condition|)
ifndef|#
directive|ifndef
name|IBMPC
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|IBMPC
name|thebyte
operator|=
operator|(
literal|'^'
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
name|thebyte
operator|=
operator|(
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|col
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMCAP
block|}
elseif|else
if|if
condition|(
name|HZ
operator|&&
name|c
operator|==
literal|'~'
condition|)
block|{
name|thebyte
operator|=
operator|(
literal|'`'
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|IBMPC
name|thebyte
operator|=
operator|(
name|c
operator||
name|or_byte
operator|)
expr_stmt|;
name|soutputc
argument_list|(
name|thebyte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
if|if
condition|(
name|c
operator|==
literal|255
condition|)
name|c
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|inversep
condition|)
name|c
operator|=
literal|255
expr_stmt|;
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|line
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
ifndef|#
directive|ifndef
name|IBMPC
name|sputc
argument_list|(
name|c
operator||
name|or_byte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|sputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
else|else
ifndef|#
directive|ifndef
name|IBMPC
name|sputc
argument_list|(
literal|'!'
operator||
name|or_byte
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
name|force
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|aborted
return|;
block|}
endif|#
directive|endif
comment|/* MAC */
comment|/* This is for writing a buffer line to the screen.  This is to    minimize the amount of copying from one buffer to another buffer.    This gets the info directly from the disk buffers. */
name|int
name|BufSwrite
parameter_list|(
name|linenum
parameter_list|)
name|int
name|linenum
decl_stmt|;
block|{
specifier|register
name|int
name|n
init|=
name|cursend
operator|-
name|cursor
decl_stmt|,
name|col
init|=
literal|0
decl_stmt|,
name|c
init|=
operator|-
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|StartCol
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
decl_stmt|,
name|visspace
init|=
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_window
operator|->
name|w_flags
operator|&
name|W_VISSPACE
decl_stmt|,
name|aborted
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|lcontents
argument_list|(
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_lp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|col
operator|>=
name|StartCol
condition|)
block|{
name|DesiredScreen
index|[
name|linenum
index|]
operator|.
name|s_offset
operator|=
name|col
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
operator|&
name|CHARMASK
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
name|col
operator|+=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|col
operator|+=
literal|2
expr_stmt|;
else|else
name|col
operator|+=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|sputc
argument_list|(
name|BUFSTART
argument_list|)
expr_stmt|;
comment|/* Okay because we can't be interrupted */
endif|#
directive|endif
if|if
condition|(
name|c
operator|!=
literal|'\0'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|AbortCnt
operator|<
literal|0
condition|)
block|{
name|AbortCnt
operator|=
name|BufSize
expr_stmt|;
if|if
condition|(
operator|(
name|InputPending
operator|=
name|charp
argument_list|()
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|aborted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|int
name|nchars
init|=
operator|(
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
operator|)
decl_stmt|;
name|col
operator|+=
name|nchars
expr_stmt|;
if|if
condition|(
name|visspace
condition|)
block|{
name|soutputc
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|nchars
operator|-=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|soutputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|soutputc
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|soutputc
argument_list|(
operator|(
name|c
operator|==
literal|'\177'
operator|)
condition|?
literal|'?'
else|:
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMCAP
block|}
elseif|else
if|if
condition|(
name|HZ
operator|&&
name|c
operator|==
literal|'~'
condition|)
block|{
name|soutputc
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|&&
name|visspace
condition|)
name|c
operator|=
literal|'_'
expr_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|c
operator|==
literal|255
condition|)
name|c
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|soutputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|bp
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\t'
operator|)
operator|&&
operator|!
name|isctrl
argument_list|(
name|c
argument_list|)
condition|)
name|sputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|sputc
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|>
name|Curline
operator|->
name|s_length
condition|)
name|Curline
operator|->
name|s_length
operator|=
name|cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|sputc
argument_list|(
name|BUFFLUSH
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|!
name|aborted
return|;
comment|/* Didn't abort */
block|}
name|void
name|i_set
parameter_list|(
name|nline
parameter_list|,
name|ncol
parameter_list|)
specifier|register
name|int
name|nline
decl_stmt|,
name|ncol
decl_stmt|;
block|{
name|Curline
operator|=
operator|&
name|Screen
index|[
name|nline
index|]
expr_stmt|;
name|cursor
operator|=
name|Curline
operator|->
name|s_line
operator|+
name|ncol
expr_stmt|;
name|cursend
operator|=
operator|&
name|Curline
operator|->
name|s_line
index|[
name|CO
operator|-
literal|1
index|]
expr_stmt|;
name|i_line
operator|=
name|nline
expr_stmt|;
name|i_col
operator|=
name|ncol
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|)
name|void
name|SO_on
parameter_list|()
block|{
comment|/* If there are magic cookies, then WHERE the SO string is 	   printed decides where the SO actually starts on the screen. 	   So it's important to make sure the cursor is positioned there 	   anyway.  I think this is right. */
if|if
condition|(
name|SG
operator|!=
literal|0
condition|)
block|{
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|i_col
operator|+=
name|SG
expr_stmt|;
name|CapCol
operator|+=
name|SG
expr_stmt|;
block|}
name|putpad
argument_list|(
name|SO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|SO_off
parameter_list|()
block|{
comment|/* see comment in SO_on() */
if|if
condition|(
name|SG
operator|!=
literal|0
condition|)
block|{
name|Placur
argument_list|(
name|i_line
argument_list|,
name|i_col
argument_list|)
expr_stmt|;
name|i_col
operator|+=
name|SG
expr_stmt|;
name|CapCol
operator|+=
name|SG
expr_stmt|;
block|}
name|putpad
argument_list|(
name|SE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Insert `num' lines a top, but leave all the lines BELOW `bottom'    alone (at least they won't look any different when we are done).    This changes the screen array AND does the physical changes. */
name|void
name|v_ins_line
parameter_list|(
name|num
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
name|int
name|num
decl_stmt|,
name|top
decl_stmt|,
name|bottom
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Save the screen pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
expr_stmt|;
comment|/* Num number of bottom lines will be lost. 	   Copy everything down num number of times. */
for|for
control|(
name|i
operator|=
name|bottom
init|;
name|i
operator|>
name|top
operator|&&
name|i
operator|-
name|num
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|-
name|num
index|]
expr_stmt|;
comment|/* Restore the saved ones, making them blank. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
operator|.
name|s_line
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
call|(
modifier|*
name|TTins_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|i_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMPC
name|scr_win
argument_list|(
operator|(
name|int
operator|)
operator|-
name|num
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|top
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|bottom
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Delete `num' lines starting at `top' leaving the lines below `bottom'    alone.  This updates the internal image as well as the physical image.  */
name|void
name|v_del_line
parameter_list|(
name|num
parameter_list|,
name|top
parameter_list|,
name|bottom
parameter_list|)
name|int
name|num
decl_stmt|,
name|top
decl_stmt|,
name|bottom
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|bot
decl_stmt|;
name|bot
operator|=
name|bottom
expr_stmt|;
comment|/* Save the lost lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
operator|&&
name|top
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Savelines
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|top
operator|+
name|i
index|]
expr_stmt|;
comment|/* Copy everything up num number of lines. */
for|for
control|(
name|i
operator|=
name|top
init|;
name|num
operator|+
name|i
operator|<=
name|bottom
condition|;
name|i
operator|++
control|)
name|Screen
index|[
name|i
index|]
operator|=
name|Screen
index|[
name|i
operator|+
name|num
index|]
expr_stmt|;
comment|/* Restore the lost ones, clearing them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|Screen
index|[
name|bottom
operator|-
name|i
index|]
operator|=
name|Savelines
index|[
name|i
index|]
expr_stmt|;
name|clrline
argument_list|(
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
argument_list|,
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
argument_list|)
expr_stmt|;
name|Screen
index|[
name|bot
index|]
operator|.
name|s_length
operator|=
name|Screen
index|[
name|bot
index|]
operator|.
name|s_line
expr_stmt|;
name|bot
operator|-=
literal|1
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
call|(
modifier|*
name|TTdel_line
call|)
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|d_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBMPC
name|scr_win
argument_list|(
name|num
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|top
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|bottom
argument_list|,
name|CHPL
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|)
comment|/* remainder of this file */
comment|/* The cursor optimization happens here.  You may decide that this    is going too far with cursor optimization, or perhaps it should    limit the amount of checking to when the output speed is slow.    What ever turns you on ...   */
struct|struct
name|cursaddr
block|{
name|int
name|cm_numchars
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cm_proc
function_decl|)
parameter_list|()
function_decl|;
block|}
struct|;
name|private
name|char
modifier|*
name|Cmstr
decl_stmt|;
name|private
name|struct
name|cursaddr
modifier|*
name|HorMin
decl_stmt|,
modifier|*
name|VertMin
decl_stmt|,
modifier|*
name|DirectMin
decl_stmt|;
name|private
name|void
name|GENi_lines
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|GENd_lines
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|ForMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|ForTab
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|BackMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|RetTab
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|DownMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|UpMotion
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|GoDirect
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|HomeGo
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|BottomUp
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
name|private
name|struct
name|cursaddr
name|WarpHor
index|[]
init|=
block|{
literal|0
block|,
name|ForMotion
block|,
literal|0
block|,
name|ForTab
block|,
literal|0
block|,
name|BackMotion
block|,
literal|0
block|,
name|RetTab
block|}
decl_stmt|;
name|private
name|struct
name|cursaddr
name|WarpVert
index|[]
init|=
block|{
literal|0
block|,
name|DownMotion
block|,
literal|0
block|,
name|UpMotion
block|}
decl_stmt|;
name|private
name|struct
name|cursaddr
name|WarpDirect
index|[]
init|=
block|{
literal|0
block|,
name|GoDirect
block|,
literal|0
block|,
name|HomeGo
block|,
literal|0
block|,
name|BottomUp
block|}
decl_stmt|;
undef|#
directive|undef
name|FORWARD
define|#
directive|define
name|FORWARD
value|0
comment|/* Move forward */
define|#
directive|define
name|FORTAB
value|1
comment|/* Forward using tabs */
undef|#
directive|undef
name|BACKWARD
define|#
directive|define
name|BACKWARD
value|2
comment|/* Move backward */
define|#
directive|define
name|RETFORWARD
value|3
comment|/* Beginning of line and then tabs */
define|#
directive|define
name|NUMHOR
value|4
define|#
directive|define
name|DOWN
value|0
comment|/* Move down */
define|#
directive|define
name|UPMOVE
value|1
comment|/* Move up */
define|#
directive|define
name|NUMVERT
value|2
define|#
directive|define
name|DIRECT
value|0
comment|/* Using CM */
define|#
directive|define
name|HOME
value|1
comment|/* HOME	*/
define|#
directive|define
name|LOWER
value|2
comment|/* Lower Line */
define|#
directive|define
name|NUMDIRECT
value|3
define|#
directive|define
name|home
parameter_list|()
value|Placur(0, 0)
define|#
directive|define
name|LowLine
parameter_list|()
value|{ putpad(LL, 1); CapLine = ILI; CapCol = 0; }
define|#
directive|define
name|PrintHo
parameter_list|()
value|{ putpad(HO, 1); CapLine = CapCol = 0; }
name|int
name|phystab
init|=
literal|8
decl_stmt|;
name|private
name|void
name|GoDirect
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|putpad
argument_list|(
name|Cmstr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|line
expr_stmt|;
name|CapCol
operator|=
name|col
expr_stmt|;
block|}
name|private
name|void
name|RetTab
parameter_list|(
name|col
parameter_list|)
specifier|register
name|int
name|col
decl_stmt|;
block|{
name|jputchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
literal|0
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|HomeGo
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|PrintHo
argument_list|()
expr_stmt|;
name|DownMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|BottomUp
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
specifier|register
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|LowLine
argument_list|()
expr_stmt|;
name|UpMotion
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|ForTab
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
comment|/* Tries to move forward using tabs (if possible).  It tabs to the    closest tabstop which means it may go past 'destcol' and backspace    to it. */
name|private
name|void
name|ForTab
parameter_list|(
name|destcol
parameter_list|)
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|ntabs
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|destcol
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
comment|/* Don't tab to last place or else it is likely to screw up. */
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|ntabs
operator|=
operator|(
name|tabgoal
operator|/
name|tabstp
operator|)
operator|-
operator|(
name|CapCol
operator|/
name|tabstp
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|ntabs
operator|>=
literal|0
condition|)
name|jputchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|tabgoal
expr_stmt|;
block|}
if|if
condition|(
name|CapCol
operator|>
name|destcol
condition|)
name|BackMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CapCol
operator|<
name|destcol
condition|)
name|ForMotion
argument_list|(
name|destcol
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|ForMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|destcol
operator|-
name|CapCol
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
operator|&
name|Screen
index|[
name|CapLine
index|]
operator|.
name|s_line
index|[
name|CapCol
index|]
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|jputchar
argument_list|(
operator|*
name|cp
operator|++
operator|&
name|CHARMASK
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
name|private
name|void
name|BackMotion
parameter_list|(
name|destcol
parameter_list|)
specifier|register
name|int
name|destcol
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapCol
operator|-
name|destcol
decl_stmt|;
if|if
condition|(
name|BC
condition|)
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|BC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|jputchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|destcol
expr_stmt|;
block|}
name|private
name|void
name|DownMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
init|=
name|destline
operator|-
name|CapLine
decl_stmt|;
while|while
condition|(
operator|--
name|nlines
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|DO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
name|private
name|void
name|UpMotion
parameter_list|(
name|destline
parameter_list|)
specifier|register
name|int
name|destline
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
name|CapLine
operator|-
name|destline
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
name|putpad
argument_list|(
name|UP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|destline
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ID_CHAR
specifier|static
name|int
name|EIlen
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|IBMPC
name|void
name|InitCM
parameter_list|()
block|{
name|HOlen
operator|=
name|HO
condition|?
name|strlen
argument_list|(
name|HO
argument_list|)
else|:
literal|1000
expr_stmt|;
name|LLlen
operator|=
name|LL
condition|?
name|strlen
argument_list|(
name|LL
argument_list|)
else|:
literal|1000
expr_stmt|;
name|UPlen
operator|=
name|UP
condition|?
name|strlen
argument_list|(
name|UP
argument_list|)
else|:
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|EI
condition|)
name|EIlen
operator|=
name|strlen
argument_list|(
name|EI
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|private
name|int
name|ForNum
name|proto
argument_list|(
operator|(
name|int
name|from
operator|,
name|int
name|to
operator|)
argument_list|)
decl_stmt|;
name|void
name|Placur
parameter_list|(
name|line
parameter_list|,
name|col
parameter_list|)
name|int
name|line
decl_stmt|,
name|col
decl_stmt|;
block|{
name|int
name|dline
decl_stmt|,
comment|/* Number of lines to move */
name|dcol
decl_stmt|;
comment|/* Number of columns to move */
specifier|register
name|int
name|best
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|cursaddr
modifier|*
name|cp
decl_stmt|;
name|int
name|xtracost
init|=
literal|0
decl_stmt|;
comment|/* Misc addition to cost. */
define|#
directive|define
name|CursMin
parameter_list|(
name|which
parameter_list|,
name|addrs
parameter_list|,
name|max
parameter_list|)
value|{ \ 	for (best = 0, cp =&(addrs)[1], i = 1; i< (max); i++, cp++) \ 		if (cp->cm_numchars< (addrs)[best].cm_numchars) \ 			best = i; \ 	(which) =&(addrs)[best]; \ }
if|if
condition|(
name|line
operator|==
name|CapLine
operator|&&
name|col
operator|==
name|CapCol
condition|)
return|return;
comment|/* We are already there. */
name|dline
operator|=
name|line
operator|-
name|CapLine
expr_stmt|;
name|dcol
operator|=
name|col
operator|-
name|CapCol
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
name|MI
condition|)
name|xtracost
operator|=
name|EIlen
operator|+
name|IMlen
expr_stmt|;
comment|/* If we're already in insert mode, it is likely that we will 	   want to be in insert mode again, after the insert. */
endif|#
directive|endif
comment|/* Number of characters to move horizontally for each case. 	   1: Just move forward by typing the right character on the screen. 	   2: Print the correct number of back spaces. 	   3: Try tabbing to the correct place. 	   4: Try going to the beginning of the line, and then tab. */
if|if
condition|(
name|dcol
operator|==
literal|1
operator|||
name|dcol
operator|==
literal|0
condition|)
block|{
comment|/* Most common case. */
name|HorMin
operator|=
operator|&
name|WarpHor
index|[
name|FORWARD
index|]
expr_stmt|;
name|HorMin
operator|->
name|cm_numchars
operator|=
name|dcol
operator|+
name|xtracost
expr_stmt|;
block|}
else|else
block|{
name|WarpHor
index|[
name|FORWARD
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|>=
literal|0
condition|?
name|dcol
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|BACKWARD
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|<
literal|0
condition|?
operator|-
operator|(
name|dcol
operator|+
name|xtracost
operator|)
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|FORTAB
index|]
operator|.
name|cm_numchars
operator|=
name|dcol
operator|>=
literal|0
operator|&&
name|TABS
condition|?
name|ForNum
argument_list|(
name|CapCol
argument_list|,
name|col
argument_list|)
operator|+
name|xtracost
else|:
literal|1000
expr_stmt|;
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
operator|=
operator|(
name|xtracost
operator|+
literal|1
operator|+
operator|(
name|TABS
condition|?
name|ForNum
argument_list|(
literal|0
argument_list|,
name|col
argument_list|)
else|:
name|col
operator|)
operator|)
expr_stmt|;
comment|/* Which is the shortest of the bunch */
name|CursMin
argument_list|(
name|HorMin
argument_list|,
name|WarpHor
argument_list|,
name|NUMHOR
argument_list|)
expr_stmt|;
block|}
comment|/* Moving vertically is more simple. */
name|WarpVert
index|[
name|DOWN
index|]
operator|.
name|cm_numchars
operator|=
name|dline
operator|>=
literal|0
condition|?
name|dline
else|:
literal|1000
expr_stmt|;
name|WarpVert
index|[
name|UPMOVE
index|]
operator|.
name|cm_numchars
operator|=
name|dline
operator|<
literal|0
condition|?
operator|(
operator|(
operator|-
name|dline
operator|)
operator|*
name|UPlen
operator|)
else|:
literal|1000
expr_stmt|;
comment|/* Which of these is simpler */
name|CursMin
argument_list|(
name|VertMin
argument_list|,
name|WarpVert
argument_list|,
name|NUMVERT
argument_list|)
expr_stmt|;
comment|/* Homing first and lowering first are considered 	   direct motions. 	   Homing first's total is the sum of the cost of homing 	   and the sum of tabbing (if possible) to the right. */
if|if
condition|(
name|VertMin
operator|->
name|cm_numchars
operator|+
name|HorMin
operator|->
name|cm_numchars
operator|<=
literal|3
condition|)
block|{
name|DirectMin
operator|=
operator|&
name|WarpDirect
index|[
name|DIRECT
index|]
expr_stmt|;
comment|/* A dummy ... */
name|DirectMin
operator|->
name|cm_numchars
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|WarpDirect
index|[
name|DIRECT
index|]
operator|.
name|cm_numchars
operator|=
name|CM
condition|?
name|strlen
argument_list|(
name|Cmstr
operator|=
name|tgoto
argument_list|(
name|CM
argument_list|,
name|col
argument_list|,
name|line
argument_list|)
argument_list|)
else|:
literal|1000
expr_stmt|;
name|WarpDirect
index|[
name|HOME
index|]
operator|.
name|cm_numchars
operator|=
name|HOlen
operator|+
name|line
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
expr_stmt|;
name|WarpDirect
index|[
name|LOWER
index|]
operator|.
name|cm_numchars
operator|=
name|LLlen
operator|+
operator|(
operator|(
name|ILI
operator|-
name|line
operator|)
operator|*
name|UPlen
operator|)
operator|+
name|WarpHor
index|[
name|RETFORWARD
index|]
operator|.
name|cm_numchars
expr_stmt|;
name|CursMin
argument_list|(
name|DirectMin
argument_list|,
name|WarpDirect
argument_list|,
name|NUMDIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|HorMin
operator|->
name|cm_numchars
operator|+
name|VertMin
operator|->
name|cm_numchars
operator|<
name|DirectMin
operator|->
name|cm_numchars
condition|)
block|{
if|if
condition|(
name|line
operator|!=
name|CapLine
condition|)
call|(
modifier|*
name|VertMin
operator|->
name|cm_proc
call|)
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|!=
name|CapCol
condition|)
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
condition|)
comment|/* We may use real characters ... */
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|HorMin
operator|->
name|cm_proc
call|)
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ID_CHAR
if|if
condition|(
name|IN_INSmode
operator|&&
operator|!
name|MI
condition|)
name|INSmode
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|DirectMin
operator|->
name|cm_proc
call|)
argument_list|(
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* IBMPC */
define|#
directive|define
name|abs
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0 ? (x) : -(x))
name|private
name|int
name|ForNum
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
specifier|register
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|tabgoal
decl_stmt|,
name|tabstp
init|=
name|phystab
decl_stmt|;
name|int
name|numchars
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|>=
name|to
condition|)
return|return
name|from
operator|-
name|to
return|;
if|if
condition|(
name|TABS
operator|&&
operator|(
name|tabstp
operator|>
literal|0
operator|)
condition|)
block|{
name|tabgoal
operator|=
name|to
operator|+
operator|(
name|tabstp
operator|/
literal|2
operator|)
expr_stmt|;
name|tabgoal
operator|-=
operator|(
name|tabgoal
operator|%
name|tabstp
operator|)
expr_stmt|;
if|if
condition|(
name|tabgoal
operator|>=
name|CO
condition|)
name|tabgoal
operator|-=
name|tabstp
expr_stmt|;
name|numchars
operator|=
operator|(
name|tabgoal
operator|/
name|tabstop
operator|)
operator|-
operator|(
name|from
operator|/
name|tabstp
operator|)
expr_stmt|;
name|from
operator|=
name|tabgoal
expr_stmt|;
block|}
return|return
name|numchars
operator|+
name|abs
argument_list|(
name|from
operator|-
name|to
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|WIRED_TERMS
name|private
name|void
name|BGi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|writef
argument_list|(
literal|"\033[%d;%dr\033[%dL\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
name|private
name|void
name|SUNi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|C100i_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENi_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WIRED_TERMS */
name|private
name|void
name|GENi_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SR
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|bottom
operator|-
name|num
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_DL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_AL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|WIRED_TERMS
name|private
name|void
name|BGd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|writef
argument_list|(
literal|"\033[%d;%dr\033[%dM\033[r"
argument_list|,
name|top
operator|+
literal|1
argument_list|,
name|bottom
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
name|private
name|void
name|SUNd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dM"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033[%dL"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|C100d_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<=
literal|1
condition|)
block|{
name|GENd_lines
argument_list|(
name|top
argument_list|,
name|bottom
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|bottom
operator|+
literal|1
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
name|writef
argument_list|(
literal|"\033v%c%c%c%c"
argument_list|,
literal|' '
argument_list|,
literal|' '
argument_list|,
literal|' '
operator|+
name|LI
argument_list|,
literal|' '
operator|+
name|CO
argument_list|)
expr_stmt|;
name|CapLine
operator|=
name|CapCol
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* WIRED_TERMS */
name|private
name|void
name|GENd_lines
parameter_list|(
name|top
parameter_list|,
name|bottom
parameter_list|,
name|num
parameter_list|)
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|CS
condition|)
block|{
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|bottom
argument_list|,
name|top
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
name|Placur
argument_list|(
name|bottom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|SF
argument_list|,
name|bottom
operator|-
name|top
argument_list|)
expr_stmt|;
name|putpad
argument_list|(
name|tgoto
argument_list|(
name|CS
argument_list|,
name|ILI
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CapCol
operator|=
name|CapLine
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Placur
argument_list|(
name|top
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_DL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_DL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|DL
argument_list|,
name|ILI
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
name|Placur
argument_list|(
name|bottom
operator|+
literal|1
operator|-
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_AL
operator|&&
operator|(
name|num
operator|>
literal|1
operator|)
condition|)
block|{
name|putargpad
argument_list|(
name|M_AL
argument_list|,
name|num
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|putpad
argument_list|(
name|AL
argument_list|,
name|ILI
operator|-
name|CapLine
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|private
specifier|const
expr|struct
name|ID_lookup
block|{
name|char
operator|*
name|ID_name
block|;
name|void
argument_list|(
argument|*I_proc
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
block|;
comment|/* proc to insert lines */
name|void
argument_list|(
argument|*D_proc
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
block|;
comment|/* proc to delete lines */
block|}
name|ID_trms
index|[]
operator|=
block|{
literal|"generic"
block|,
name|GENi_lines
block|,
name|GENd_lines
block|,
comment|/* This should stay here */
ifdef|#
directive|ifdef
name|WIRED_TERMS
literal|"sun"
block|,
name|SUNi_lines
block|,
name|SUNd_lines
block|,
literal|"bg"
block|,
name|BGi_lines
block|,
name|BGd_lines
block|,
literal|"c1"
block|,
name|C100i_lines
block|,
name|C100d_lines
block|,
endif|#
directive|endif
comment|/* WIRED_TERMS */
literal|0
block|,
literal|0
block|,
literal|0
block|}
expr_stmt|;
name|void
name|IDline_setup
parameter_list|(
name|tname
parameter_list|)
name|char
modifier|*
name|tname
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|ID_lookup
modifier|*
name|idp
decl_stmt|;
for|for
control|(
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|1
index|]
init|;
name|idp
operator|->
name|ID_name
condition|;
name|idp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|,
name|tname
argument_list|,
name|strlen
argument_list|(
name|idp
operator|->
name|ID_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|idp
operator|->
name|ID_name
operator|==
literal|0
condition|)
name|idp
operator|=
operator|&
name|ID_trms
index|[
literal|0
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|IBMPC
name|TTins_line
operator|=
name|idp
operator|->
name|I_proc
expr_stmt|;
name|TTdel_line
operator|=
name|idp
operator|->
name|D_proc
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

end_unit

