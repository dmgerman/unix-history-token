begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* Recovers JOVE files after a system/editor crash.    Usage: recover [-d directory] [-syscrash]    The -syscrash option is specified in /etc/rc and what it does it    move all the jove tmp files from TMP_DIR (/tmp) to REC_DIR (/usr/preserve).    recover -syscrash must be invoked in /ect/rc BEFORE /tmp gets cleared out.    (about the same place as expreserve gets invoked to save ed/vi/ex files.     The -d option lets you specify the directory to search for tmp files when    the default isn't the right one.     Look in Makefile to change the default directories. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Do stdio first so it doesn't override OUR 			   definitions. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"temp.h"
end_include

begin_include
include|#
directive|include
file|"rec.h"
end_include

begin_include
include|#
directive|include
file|"rectune.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|L_SET
end_ifndef

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_define
define|#
directive|define
name|L_INCR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ctime
name|proto
argument_list|(
operator|(
specifier|const
name|time_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|blk_buf
index|[
name|JBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|nleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|FILE
modifier|*
name|ptrs_fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|data_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|struct
name|rec_head
name|Header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|long
name|Nchars
decl_stmt|,
name|Nlines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
name|tty
index|[]
init|=
literal|"/dev/tty"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|UserID
decl_stmt|,
name|Verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|Directory
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the directory we're looking in */
end_comment

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|file_pair
block|{
name|char
modifier|*
name|file_data
decl_stmt|,
modifier|*
name|file_rec
decl_stmt|;
define|#
directive|define
name|INSPECTED
value|01
name|int
name|file_flags
decl_stmt|;
name|struct
name|file_pair
modifier|*
name|file_next
decl_stmt|;
block|}
modifier|*
name|First
init|=
literal|0
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|rec_entry
modifier|*
name|buflist
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system initializes to 0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BSD_DIR
end_ifndef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|d_fd
decl_stmt|;
comment|/* File descriptor for this directory */
block|}
name|DIR
typedef|;
end_typedef

begin_function
name|DIR
modifier|*
name|opendir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dp
init|=
operator|(
name|DIR
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|d_fd
operator|=
name|open
argument_list|(
name|dir
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
return|return
name|dp
return|;
block|}
end_function

begin_macro
name|closedir
argument_list|(
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|DIR
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|dp
operator|->
name|d_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|direct
modifier|*
name|readdir
parameter_list|(
name|dp
parameter_list|)
name|DIR
modifier|*
name|dp
decl_stmt|;
block|{
specifier|static
name|struct
name|direct
name|dir
decl_stmt|;
do|do
if|if
condition|(
name|read
argument_list|(
name|dp
operator|->
name|d_fd
argument_list|,
operator|&
name|dir
argument_list|,
sizeof|sizeof
name|dir
argument_list|)
operator|!=
sizeof|sizeof
name|dir
condition|)
return|return
name|NULL
return|;
if|#
directive|if
name|defined
argument_list|(
name|elxsi
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYSV
argument_list|)
comment|/* 	 * Elxsi has a BSD4.2 implementation which may or may not use 	 * `twisted inodes' ...  Anyone able to check? 	 */
do|while
condition|(
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|dir
operator|.
name|d_ino
operator|==
literal|0
condition|)
do|;
else|#
directive|else
while|while
condition|(
name|dir
operator|.
name|d_ino
operator|==
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
return|return
operator|&
name|dir
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD4_2 */
end_comment

begin_comment
comment|/* Get a line at `tl' in the tmp file into `buf' which should be LBSIZE    long. */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|getblock
name|proto
argument_list|(
operator|(
name|daddr
name|atl
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|getline
parameter_list|(
name|tl
parameter_list|,
name|buf
parameter_list|)
name|daddr
name|tl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|tl
operator|=
name|blk_round
argument_list|(
name|tl
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
name|tl
operator|=
name|forward_block
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|tl
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|getblock
parameter_list|(
name|atl
parameter_list|)
name|daddr
name|atl
decl_stmt|;
block|{
name|int
name|bno
decl_stmt|,
name|off
decl_stmt|;
specifier|static
name|int
name|curblock
init|=
operator|-
literal|1
decl_stmt|;
name|bno
operator|=
name|da_to_bno
argument_list|(
name|atl
argument_list|)
expr_stmt|;
name|off
operator|=
name|da_to_off
argument_list|(
name|atl
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|JBUFSIZ
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|bno
operator|!=
name|curblock
condition|)
block|{
specifier|extern
name|long
name|lseek
name|proto
argument_list|(
operator|(
name|int
operator|,
name|long
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
name|lseek
argument_list|(
name|data_fd
argument_list|,
operator|(
name|long
operator|)
name|bno
operator|*
name|JBUFSIZ
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|data_fd
argument_list|,
name|blk_buf
argument_list|,
operator|(
name|size_t
operator|)
name|JBUFSIZ
argument_list|)
expr_stmt|;
name|curblock
operator|=
name|bno
expr_stmt|;
block|}
return|return
name|blk_buf
operator|+
name|off
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|copystr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Scandir returns the number of entries or -1 if the directory cannoot    be opened or malloc fails. */
end_comment

begin_function_decl
name|private
name|int
name|scandir
parameter_list|(
name|dir
parameter_list|,
name|nmptr
parameter_list|,
name|qualify
parameter_list|,
name|sorter
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|struct
name|direct
modifier|*
modifier|*
modifier|*
name|nmptr
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*qualify
end_function_decl

begin_expr_stmt
unit|)
name|proto
argument_list|(
operator|(
expr|struct
name|direct
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|int
argument_list|(
argument|*sorter
argument_list|)
end_macro

begin_expr_stmt
name|proto
argument_list|(
operator|(
name|UnivConstPtr
operator|,
name|UnivConstPtr
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|direct
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|ourarray
decl_stmt|;
name|int
name|nalloc
init|=
literal|10
decl_stmt|,
name|nentries
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|ourarray
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nalloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direct
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qualify
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|qualify
call|)
argument_list|(
name|entry
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nentries
operator|==
name|nalloc
condition|)
block|{
name|ourarray
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
operator|(
name|nalloc
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourarray
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|ourarray
index|[
name|nentries
index|]
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|entry
argument_list|)
expr_stmt|;
operator|*
name|ourarray
index|[
name|nentries
index|]
operator|=
operator|*
name|entry
expr_stmt|;
name|nentries
operator|+=
literal|1
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentries
operator|!=
name|nalloc
condition|)
name|ourarray
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ourarray
argument_list|,
operator|(
name|nentries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sorter
operator|!=
name|NULL
condition|)
name|qsort
argument_list|(
operator|(
name|UnivPtr
operator|)
name|ourarray
argument_list|,
operator|(
name|size_t
operator|)
name|nentries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|direct
operator|*
operator|*
argument_list|)
argument_list|,
name|sorter
argument_list|)
expr_stmt|;
operator|*
name|nmptr
operator|=
name|ourarray
expr_stmt|;
return|return
name|nentries
return|;
block|}
end_block

begin_decl_stmt
name|private
name|char
modifier|*
name|CurDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scan the DIRNAME directory for jove tmp files, and make a linked list    out of them. */
end_comment

begin_decl_stmt
name|private
name|int
name|add_name
name|proto
argument_list|(
operator|(
expr|struct
name|direct
operator|*
name|dp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|get_files
parameter_list|(
name|dirname
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
name|struct
name|direct
modifier|*
modifier|*
name|nmptr
decl_stmt|;
name|CurDir
operator|=
name|dirname
expr_stmt|;
name|First
operator|=
name|NULL
expr_stmt|;
name|scandir
argument_list|(
name|dirname
argument_list|,
operator|&
name|nmptr
argument_list|,
name|add_name
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|proto
argument_list|(
operator|(
name|UnivConstPtr
operator|,
name|UnivConstPtr
operator|)
argument_list|)
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|int
name|add_name
parameter_list|(
name|dp
parameter_list|)
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
block|{
name|char
name|dfile
index|[
literal|128
index|]
decl_stmt|,
name|rfile
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
name|struct
name|rec_head
name|header
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"jrec"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we get here, we found a "recover" tmp file, so now 	   we look for the corresponding "data" tmp file.  First, 	   though, we check to see whether there is anything in 	   the "recover" file.  If it's 0 length, there's no point 	   in saving its name. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rfile
argument_list|,
literal|"%s/%s"
argument_list|,
name|CurDir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|dfile
argument_list|,
literal|"%s/jove%s"
argument_list|,
name|CurDir
argument_list|,
name|dp
operator|->
name|d_name
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|rfile
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
name|header
argument_list|)
operator|!=
sizeof|sizeof
name|header
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|access
argument_list|(
name|dfile
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: can't find the data file for %s/%s\n"
argument_list|,
name|Directory
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"so deleting...\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|dfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we get here, we've found both files, so we put them 	   in the list. */
name|fp
operator|=
operator|(
expr|struct
name|file_pair
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|fp
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot malloc for file_pair.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|file_data
operator|=
name|copystr
argument_list|(
name|dfile
argument_list|)
expr_stmt|;
name|fp
operator|->
name|file_rec
operator|=
name|copystr
argument_list|(
name|rfile
argument_list|)
expr_stmt|;
name|fp
operator|->
name|file_flags
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|file_next
operator|=
name|First
expr_stmt|;
name|First
operator|=
name|fp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|private
name|void
name|options
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Options are:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	?		list options.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	get		get a buffer to a file.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	list		list known buffers.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	print		print a buffer to terminal.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	quit		quit and delete jove tmp files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	restore		restore all buffers.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a legitimate buffer # */
end_comment

begin_decl_stmt
name|private
name|void
name|tellme
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|list
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|struct
name|rec_entry
modifier|*
modifier|*
name|getsrc
parameter_list|()
block|{
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|int
name|number
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tellme
argument_list|(
literal|"Which buffer ('?' for list)? "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|list
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|number
operator|=
name|atoi
argument_list|(
name|name
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|number
operator|<=
name|Header
operator|.
name|Nbuffers
condition|)
return|return
operator|&
name|buflist
index|[
name|number
index|]
return|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|buflist
index|[
name|i
index|]
return|;
name|printf
argument_list|(
literal|"%s: unknown buffer.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a destination file name. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getdest
parameter_list|()
block|{
specifier|static
name|char
name|filebuf
index|[
literal|256
index|]
decl_stmt|;
name|tellme
argument_list|(
literal|"Output file: "
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|filebuf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
return|return
name|filebuf
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_function
name|private
name|char
modifier|*
name|readword
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
while|while
condition|(
name|strchr
argument_list|(
literal|" \t\n"
argument_list|,
name|c
operator|=
name|getchar
argument_list|()
argument_list|)
condition|)
empty_stmt|;
do|do
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|" \t\n"
argument_list|,
name|c
argument_list|)
condition|)
break|break;
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
do|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|private
name|void
name|tellme
parameter_list|(
name|quest
parameter_list|,
name|answer
parameter_list|)
name|char
modifier|*
name|quest
decl_stmt|,
decl|*
name|answer
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|stdin
operator|->
name|_cnt
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|quest
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|readword
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print the specified file to standard output. */
end_comment

begin_decl_stmt
name|private
name|jmp_buf
name|int_env
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|SIGRESULT
name|catch
parameter_list|(
name|junk
parameter_list|)
name|int
name|junk
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|int_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_decl_stmt
name|private
name|void
name|get
name|proto
argument_list|(
operator|(
expr|struct
name|rec_entry
operator|*
operator|*
name|src
operator|,
name|char
operator|*
name|dest
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|restore
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|tofile
index|[
literal|100
index|]
decl_stmt|,
name|answer
index|[
literal|30
index|]
decl_stmt|;
name|int
name|nrecovered
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tofile
argument_list|,
literal|"#%s"
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|)
expr_stmt|;
name|tryagain
label|:
name|printf
argument_list|(
literal|"Restoring %s to %s, okay?"
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
name|tellme
argument_list|(
literal|" "
argument_list|,
name|answer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|answer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'y'
case|:
break|break;
case|case
literal|'n'
case|:
continue|continue;
default|default:
name|tellme
argument_list|(
literal|"What file should I use instead? "
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|get
argument_list|(
operator|&
name|buflist
index|[
name|i
index|]
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
name|nrecovered
operator|+=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Recovered %d buffers.\n"
argument_list|,
name|nrecovered
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|void
name|dump_file
name|proto
argument_list|(
operator|(
name|int
name|which
operator|,
name|FILE
operator|*
name|out
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|get
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|)
name|struct
name|rec_entry
modifier|*
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
block|{
name|FILE
modifier|*
name|outfile
decl_stmt|;
if|if
condition|(
name|src
operator|==
literal|0
operator|||
name|dest
operator|==
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|catch
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|int_env
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|tty
condition|)
name|outfile
operator|=
name|stdout
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|outfile
operator|=
name|fopen
argument_list|(
name|dest
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"recover: cannot create %s.\n"
argument_list|,
name|dest
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\"%s\""
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|dump_file
argument_list|(
name|src
operator|-
name|buflist
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\nAborted!\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|tty
condition|)
block|{
name|fclose
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %ld lines, %ld characters.\n"
argument_list|,
name|Nlines
argument_list|,
name|Nchars
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|char
modifier|*
modifier|*
name|scanvec
parameter_list|(
name|args
parameter_list|,
name|str
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|args
decl_stmt|,
decl|*
name|str
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|args
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|args
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
return|return
name|args
return|;
name|args
operator|+=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|private
name|void
name|read_rec
parameter_list|(
name|recptr
parameter_list|)
name|struct
name|rec_entry
modifier|*
name|recptr
decl_stmt|;
block|{
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|recptr
argument_list|,
sizeof|sizeof
expr|*
name|recptr
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|ptrs_fp
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot read record.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|seekto
parameter_list|(
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
operator|+
operator|(
name|Header
operator|.
name|Nbuffers
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rec_entry
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|which
condition|;
name|i
operator|++
control|)
name|offset
operator|+=
name|buflist
index|[
name|i
index|]
operator|->
name|r_nlines
operator|*
sizeof|sizeof
argument_list|(
name|daddr
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|ptrs_fp
argument_list|,
name|offset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|makblist
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|fseek
argument_list|(
name|ptrs_fp
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buflist
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|buflist
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|rec_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rec_entry
argument_list|)
argument_list|)
expr_stmt|;
name|read_rec
argument_list|(
name|buflist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|buflist
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buflist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buflist
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|daddr
name|getaddr
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|int
name|nchars
init|=
sizeof|sizeof
argument_list|(
name|daddr
argument_list|)
decl_stmt|;
name|daddr
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
decl_stmt|;
while|while
condition|(
operator|--
name|nchars
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_function
name|private
name|void
name|dump_file
parameter_list|(
name|which
parameter_list|,
name|out
parameter_list|)
name|int
name|which
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
specifier|register
name|int
name|nlines
decl_stmt|;
specifier|register
name|daddr
name|addr
decl_stmt|;
name|char
name|buf
index|[
name|JBUFSIZ
index|]
decl_stmt|;
name|seekto
argument_list|(
name|which
argument_list|)
expr_stmt|;
name|nlines
operator|=
name|buflist
index|[
name|which
index|]
operator|->
name|r_nlines
expr_stmt|;
name|Nchars
operator|=
name|Nlines
operator|=
literal|0L
expr_stmt|;
while|while
condition|(
operator|--
name|nlines
operator|>=
literal|0
condition|)
block|{
name|addr
operator|=
name|getaddr
argument_list|(
name|ptrs_fp
argument_list|)
expr_stmt|;
name|getline
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|Nlines
operator|+=
literal|1
expr_stmt|;
name|Nchars
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|0
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* List all the buffers. */
end_comment

begin_function
name|private
name|void
name|list
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|Header
operator|.
name|Nbuffers
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%d) buffer %s  \"%s\" (%d lines)\n"
argument_list|,
name|i
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_bname
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_fname
argument_list|,
name|buflist
index|[
name|i
index|]
operator|->
name|r_nlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|void
name|ask_del
name|proto
argument_list|(
operator|(
name|char
operator|*
name|prompt
operator|,
expr|struct
name|file_pair
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|doit
parameter_list|(
name|fp
parameter_list|)
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|answer
index|[
literal|30
index|]
decl_stmt|;
name|char
modifier|*
name|datafile
init|=
name|fp
operator|->
name|file_data
decl_stmt|,
modifier|*
name|pntrfile
init|=
name|fp
operator|->
name|file_rec
decl_stmt|;
name|ptrs_fp
operator|=
name|fopen
argument_list|(
name|pntrfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrs_fp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot read rec file (%s).\n"
argument_list|,
name|pntrfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|Header
argument_list|,
sizeof|sizeof
name|Header
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|ptrs_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Header
operator|.
name|Uid
operator|!=
name|UserID
condition|)
return|return
literal|0
return|;
comment|/* Don't ask about JOVE's that are still running ... */
ifdef|#
directive|ifdef
name|KILL0
if|if
condition|(
name|kill
argument_list|(
name|Header
operator|.
name|Pid
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* KILL0 */
if|if
condition|(
name|Header
operator|.
name|Nbuffers
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"There are no modified buffers in %s; should I delete the tmp file?"
argument_list|,
name|pntrfile
argument_list|)
expr_stmt|;
name|ask_del
argument_list|(
literal|" "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|Header
operator|.
name|Nbuffers
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: %s doesn't look like a jove file.\n"
argument_list|,
name|pntrfile
argument_list|)
expr_stmt|;
name|ask_del
argument_list|(
literal|"Should I delete it? "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* We'll, we sort of found something. */
block|}
name|printf
argument_list|(
literal|"Found %d buffer%s last updated: %s"
argument_list|,
name|Header
operator|.
name|Nbuffers
argument_list|,
name|Header
operator|.
name|Nbuffers
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|ctime
argument_list|(
operator|&
name|Header
operator|.
name|UpdTime
argument_list|)
argument_list|)
expr_stmt|;
name|data_fd
operator|=
name|open
argument_list|(
name|datafile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: but I can't read the data file (%s).\n"
argument_list|,
name|datafile
argument_list|)
expr_stmt|;
name|ask_del
argument_list|(
literal|"Should I delete the tmp files? "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|makblist
argument_list|()
expr_stmt|;
name|list
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tellme
argument_list|(
literal|"(Type '?' for options): "
argument_list|,
name|answer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|answer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
continue|continue;
case|case
literal|'?'
case|:
name|options
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|get
argument_list|(
name|getsrc
argument_list|()
argument_list|,
name|tty
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|ask_del
argument_list|(
literal|"Shall I delete the tmp files? "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'g'
case|:
block|{
comment|/* So it asks for src first. */
name|char
modifier|*
name|dest
decl_stmt|;
name|struct
name|rec_entry
modifier|*
modifier|*
name|src
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|=
name|getsrc
argument_list|()
operator|)
operator|==
literal|0
condition|)
break|break;
name|dest
operator|=
name|getdest
argument_list|()
expr_stmt|;
name|get
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'r'
case|:
name|restore
argument_list|()
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"I don't know how to \"%s\"!\n"
argument_list|,
name|answer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|private
name|void
name|del_files
name|proto
argument_list|(
operator|(
expr|struct
name|file_pair
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|ask_del
parameter_list|(
name|prompt
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|yorn
index|[
literal|20
index|]
decl_stmt|;
name|tellme
argument_list|(
name|prompt
argument_list|,
name|yorn
argument_list|)
expr_stmt|;
if|if
condition|(
name|yorn
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
name|del_files
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|del_files
parameter_list|(
name|fp
parameter_list|)
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fp
operator|->
name|file_data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fp
operator|->
name|file_rec
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|MailUser
argument_list|(
argument|rec
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|rec_head
modifier|*
name|rec
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SYSV
name|struct
name|utsname
name|mach
decl_stmt|;
else|#
directive|else
name|char
name|mach
index|[
name|BUFSIZ
index|]
decl_stmt|;
endif|#
directive|endif
name|char
name|mail_cmd
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|last_update
decl_stmt|;
name|char
modifier|*
name|buf_string
decl_stmt|;
name|FILE
modifier|*
name|mail_pipe
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|struct
name|passwd
modifier|*
name|getpwuid
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|rec
operator|->
name|Uid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|SYSV
if|if
condition|(
name|uname
argument_list|(
operator|&
name|mach
argument_list|)
operator|<
literal|0
condition|)
name|strcpy
argument_list|(
name|mach
operator|.
name|sysname
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
else|#
directive|else
name|gethostname
argument_list|(
name|mach
argument_list|,
sizeof|sizeof
argument_list|(
name|mach
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|last_update
operator|=
name|ctime
argument_list|(
operator|&
operator|(
name|rec
operator|->
name|UpdTime
operator|)
argument_list|)
expr_stmt|;
comment|/* Start up mail */
name|sprintf
argument_list|(
name|mail_cmd
argument_list|,
literal|"/bin/mail %s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mail_pipe
operator|=
name|popen
argument_list|(
name|mail_cmd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|setbuf
argument_list|(
name|mail_pipe
argument_list|,
name|mail_cmd
argument_list|)
expr_stmt|;
comment|/* Let's be grammatically correct! */
if|if
condition|(
name|rec
operator|->
name|Nbuffers
operator|==
literal|1
condition|)
name|buf_string
operator|=
literal|"buffer"
expr_stmt|;
else|else
name|buf_string
operator|=
literal|"buffers"
expr_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|"Subject: System crash\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|" \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
argument|mail_pipe
argument_list|,
literal|"Jove saved %d %s when the system \"%s\"\n"
argument_list|,
argument|rec->Nbuffers
argument_list|,
argument|buf_string
argument_list|,
ifdef|#
directive|ifdef
name|SYSV
argument|mach.sysname
else|#
directive|else
argument|mach
endif|#
directive|endif
argument_list|)
empty_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|"crashed on %s\n\n"
argument_list|,
name|last_update
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|"You can retrieve the %s using Jove's -r\n"
argument_list|,
name|buf_string
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|"(recover option) i.e. give the command.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|"\tjove -r\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mail_pipe
argument_list|,
literal|"See the Jove manual for more details\n"
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|mail_pipe
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|savetmps
argument_list|()
end_macro

begin_block
block|{
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
name|int
name|status
decl_stmt|,
name|pid
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|rec_head
name|header
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TMP_DIR
argument_list|,
name|REC_DIR
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Files are moved to the same place. */
name|get_files
argument_list|(
name|TMP_DIR
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|First
init|;
name|fp
operator|!=
literal|0
condition|;
name|fp
operator|=
name|fp
operator|->
name|file_next
control|)
block|{
name|stat
argument_list|(
name|fp
operator|->
name|file_data
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: can't fork\n!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Recovering: %s, %s\n"
argument_list|,
name|fp
operator|->
name|file_data
argument_list|,
name|fp
operator|->
name|file_rec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fp
operator|->
name|file_rec
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
name|header
argument_list|)
operator|!=
sizeof|sizeof
name|header
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|MailUser
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/mv"
argument_list|,
literal|"mv"
argument_list|,
name|fp
operator|->
name|file_data
argument_list|,
name|fp
operator|->
name|file_rec
argument_list|,
name|REC_DIR
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: cannot execl /bin/mv.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
default|default:
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recover: non-zero status (%d) returned from copy.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|fname
operator|=
name|fp
operator|->
name|file_data
operator|+
name|strlen
argument_list|(
name|TMP_DIR
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|REC_DIR
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_uid
argument_list|,
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_gid
argument_list|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"recover: chown failed."
argument_list|)
expr_stmt|;
name|fname
operator|=
name|fp
operator|->
name|file_rec
operator|+
name|strlen
argument_list|(
name|TMP_DIR
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|REC_DIR
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_uid
argument_list|,
operator|(
name|int
operator|)
name|stbuf
operator|.
name|st_gid
argument_list|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"recover: chown failed."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|private
name|int
name|lookup
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|struct
name|file_pair
modifier|*
name|fp
decl_stmt|;
name|int
name|nfound
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"Checking %s ...\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|Directory
operator|=
name|dir
expr_stmt|;
name|get_files
argument_list|(
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|First
init|;
name|fp
operator|!=
literal|0
condition|;
name|fp
operator|=
name|fp
operator|->
name|file_next
control|)
block|{
name|nfound
operator|+=
name|doit
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrs_fp
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ptrs_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_fd
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|data_fd
argument_list|)
expr_stmt|;
block|}
return|return
name|nfound
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|nfound
decl_stmt|;
name|char
modifier|*
modifier|*
name|argvp
decl_stmt|;
name|char
modifier|*
name|tmp_dir
decl_stmt|;
name|UserID
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-help"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"recover: usage: recover [-d directory] [-syscrash]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"jove -r\" after JOVE has died for some\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unknown reason.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"%s -syscrash\"\n"
argument_list|,
name|Recover
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"when the system is in the process of rebooting."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"This is done automatically at reboot time\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"and so most of you don't have to worry about that.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Use \"recover -d directory\" when the tmp files are store\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"in DIRECTORY instead of the default one (/tmp).\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-v"
argument_list|)
condition|)
name|Verbose
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-syscrash"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Recovering jove files ... "
argument_list|)
expr_stmt|;
name|savetmps
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Done.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|argvp
operator|=
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-uid"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|UserID
operator|=
name|atoi
argument_list|(
name|argvp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argvp
operator|=
name|scanvec
argument_list|(
name|argv
argument_list|,
literal|"-d"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|tmp_dir
operator|=
name|argvp
index|[
literal|1
index|]
expr_stmt|;
else|else
name|tmp_dir
operator|=
name|TmpFilePath
expr_stmt|;
comment|/* Check default directory */
name|nfound
operator|=
name|lookup
argument_list|(
name|tmp_dir
argument_list|)
expr_stmt|;
comment|/* Check whether anything was saved when system died? */
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_dir
argument_list|,
name|REC_DIR
argument_list|)
operator|!=
literal|0
condition|)
name|nfound
operator|+=
name|lookup
argument_list|(
name|REC_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"There's nothing to recover.\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

