begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* search package */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_decl_stmt
name|private
name|char
modifier|*
name|insert
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|REreset
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|search
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|backref
name|proto
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|do_comp
name|proto
argument_list|(
operator|(
expr|struct
name|RE_block
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|member
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|REgetc
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|REmatch
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|searchstr
index|[
literal|128
index|]
decl_stmt|,
comment|/* global search string */
name|rep_search
index|[
literal|128
index|]
decl_stmt|,
comment|/* replace search string */
name|rep_str
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contains replacement string */
end_comment

begin_decl_stmt
name|int
name|REdirection
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current direction we're searching in */
end_comment

begin_decl_stmt
name|int
name|CaseIgnore
init|=
literal|0
decl_stmt|,
comment|/* ignore case? */
name|WrapScan
init|=
literal|0
decl_stmt|,
comment|/* wrap at end of buffer? */
name|UseRE
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use regular expressions */
end_comment

begin_define
define|#
directive|define
name|cind_cmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(CaseEquiv[a] == CaseEquiv[b])
end_define

begin_decl_stmt
name|private
name|int
name|REpeekc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|REptr
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|REgetc
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|REpeekc
operator|)
operator|!=
operator|-
literal|1
condition|)
name|REpeekc
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|REptr
condition|)
name|c
operator|=
operator|*
name|REptr
operator|++
expr_stmt|;
else|else
name|c
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STAR
value|01
end_define

begin_comment
comment|/* Match any number of last RE. */
end_comment

begin_define
define|#
directive|define
name|AT_BOL
value|2
end_define

begin_comment
comment|/* ^ */
end_comment

begin_define
define|#
directive|define
name|AT_EOL
value|4
end_define

begin_comment
comment|/* $ */
end_comment

begin_define
define|#
directive|define
name|AT_BOW
value|6
end_define

begin_comment
comment|/* \< */
end_comment

begin_define
define|#
directive|define
name|AT_EOW
value|8
end_define

begin_comment
comment|/* \> */
end_comment

begin_define
define|#
directive|define
name|OPENP
value|10
end_define

begin_comment
comment|/* \( */
end_comment

begin_define
define|#
directive|define
name|CLOSEP
value|12
end_define

begin_comment
comment|/* \) */
end_comment

begin_define
define|#
directive|define
name|CURLYB
value|14
end_define

begin_comment
comment|/* \{ */
end_comment

begin_define
define|#
directive|define
name|NOSTR
value|14
end_define

begin_comment
comment|/* Codes<= NOSTR can't be *'d. */
end_comment

begin_define
define|#
directive|define
name|ANYC
value|(NOSTR+2)
end_define

begin_comment
comment|/* . */
end_comment

begin_define
define|#
directive|define
name|NORMC
value|(ANYC+2)
end_define

begin_comment
comment|/* normal character */
end_comment

begin_define
define|#
directive|define
name|CINDC
value|(NORMC+2)
end_define

begin_comment
comment|/* case independent character */
end_comment

begin_define
define|#
directive|define
name|ONE_OF
value|(CINDC+2)
end_define

begin_comment
comment|/* [xxx] */
end_comment

begin_define
define|#
directive|define
name|NONE_OF
value|(ONE_OF+2)
end_define

begin_comment
comment|/* [^xxx] */
end_comment

begin_define
define|#
directive|define
name|BACKREF
value|(NONE_OF+2)
end_define

begin_comment
comment|/* \# */
end_comment

begin_define
define|#
directive|define
name|EOP
value|(BACKREF+2)
end_define

begin_comment
comment|/* end of pattern */
end_comment

begin_comment
comment|/* ONE_OF/NONE_OF is represented as a bit vector.  * These symbols parameterize the representation.  */
end_comment

begin_define
define|#
directive|define
name|BYTESIZE
value|8
end_define

begin_define
define|#
directive|define
name|SETSIZE
value|(NCHARS / BYTESIZE)
end_define

begin_define
define|#
directive|define
name|SETBYTE
parameter_list|(
name|c
parameter_list|)
value|((c) / BYTESIZE)
end_define

begin_define
define|#
directive|define
name|SETBIT
parameter_list|(
name|c
parameter_list|)
value|(1<< ((c) % BYTESIZE))
end_define

begin_define
define|#
directive|define
name|NPAR
value|10
end_define

begin_comment
comment|/* [0-9] - 0th is the entire matched string, i.e.& */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|comp_ptr
decl_stmt|,
modifier|*
modifier|*
name|alt_p
decl_stmt|,
modifier|*
modifier|*
name|alt_endp
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|REcompile
parameter_list|(
name|pattern
parameter_list|,
name|re
parameter_list|,
name|re_blk
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|re
decl_stmt|;
name|struct
name|RE_block
modifier|*
name|re_blk
decl_stmt|;
block|{
name|REptr
operator|=
name|pattern
expr_stmt|;
name|REpeekc
operator|=
operator|-
literal|1
expr_stmt|;
name|comp_ptr
operator|=
name|re_blk
operator|->
name|r_compbuf
expr_stmt|;
name|alt_p
operator|=
name|re_blk
operator|->
name|r_alternates
expr_stmt|;
name|alt_endp
operator|=
name|alt_p
operator|+
name|NALTS
expr_stmt|;
operator|*
name|alt_p
operator|++
operator|=
name|comp_ptr
expr_stmt|;
name|re_blk
operator|->
name|r_nparens
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|do_comp
argument_list|(
name|re_blk
argument_list|,
name|re
condition|?
name|OKAY_RE
else|:
name|NORM
argument_list|)
expr_stmt|;
operator|*
name|alt_p
operator|=
name|NULL
expr_stmt|;
name|re_blk
operator|->
name|r_anchored
operator|=
name|NO
expr_stmt|;
name|re_blk
operator|->
name|r_firstc
operator|=
literal|'\0'
expr_stmt|;
comment|/* do a little post processing */
if|if
condition|(
name|re_blk
operator|->
name|r_alternates
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|re_blk
operator|->
name|r_alternates
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|OPENP
case|:
case|case
name|CLOSEP
case|:
name|p
operator|+=
literal|2
expr_stmt|;
continue|continue;
case|case
name|AT_BOW
case|:
case|case
name|AT_EOW
case|:
name|p
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|AT_BOL
case|:
name|re_blk
operator|->
name|r_anchored
operator|=
name|YES
expr_stmt|;
comment|/* don't set firstc -- won't work */
break|break;
case|case
name|NORMC
case|:
case|case
name|CINDC
case|:
name|re_blk
operator|->
name|r_firstc
operator|=
name|CaseEquiv
index|[
name|p
index|[
literal|2
index|]
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* compile the pattern into an internal code */
end_comment

begin_function
name|private
name|int
name|do_comp
parameter_list|(
name|re_blk
parameter_list|,
name|kind
parameter_list|)
name|struct
name|RE_block
modifier|*
name|re_blk
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|{
name|char
modifier|*
name|this_verb
decl_stmt|,
modifier|*
name|prev_verb
decl_stmt|,
modifier|*
name|start_p
decl_stmt|,
modifier|*
name|comp_endp
decl_stmt|;
name|int
name|parens
index|[
name|NPAR
index|]
decl_stmt|,
modifier|*
name|parenp
decl_stmt|,
name|c
decl_stmt|,
name|ret_code
decl_stmt|;
name|parenp
operator|=
name|parens
expr_stmt|;
name|this_verb
operator|=
name|NULL
expr_stmt|;
name|ret_code
operator|=
literal|1
expr_stmt|;
name|comp_endp
operator|=
operator|&
name|re_blk
operator|->
name|r_compbuf
index|[
name|COMPSIZE
operator|-
literal|6
index|]
expr_stmt|;
comment|/* wrap the whole expression around (implied) parens */
if|if
condition|(
name|kind
operator|==
name|OKAY_RE
condition|)
block|{
operator|*
name|comp_ptr
operator|++
operator|=
name|OPENP
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|re_blk
operator|->
name|r_nparens
expr_stmt|;
operator|*
name|parenp
operator|++
operator|=
name|re_blk
operator|->
name|r_nparens
operator|++
expr_stmt|;
block|}
name|start_p
operator|=
name|comp_ptr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|REgetc
argument_list|()
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|comp_ptr
operator|>
name|comp_endp
condition|)
name|toolong
label|:
name|complain
argument_list|(
literal|"Search string too long/complex."
argument_list|)
expr_stmt|;
name|prev_verb
operator|=
name|this_verb
expr_stmt|;
name|this_verb
operator|=
name|comp_ptr
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|NORM
operator|&&
name|strchr
argument_list|(
literal|".[*"
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|defchar
goto|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
name|REgetc
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|complain
argument_list|(
literal|"[Premature end of pattern]"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|'{'
case|:
block|{
name|char
modifier|*
name|wcntp
decl_stmt|;
comment|/* word count */
operator|*
name|comp_ptr
operator|++
operator|=
name|CURLYB
expr_stmt|;
name|wcntp
operator|=
name|comp_ptr
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|comp_val
decl_stmt|;
name|char
modifier|*
name|comp_len
decl_stmt|;
name|comp_len
operator|=
name|comp_ptr
operator|++
expr_stmt|;
name|comp_val
operator|=
name|do_comp
argument_list|(
name|re_blk
argument_list|,
name|IN_CB
argument_list|)
expr_stmt|;
operator|*
name|comp_len
operator|=
name|comp_ptr
operator|-
name|comp_len
expr_stmt|;
operator|(
operator|*
name|wcntp
operator|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|comp_val
operator|==
literal|0
condition|)
break|break;
block|}
break|break;
block|}
case|case
literal|'}'
case|:
if|if
condition|(
name|kind
operator|!=
name|IN_CB
condition|)
name|complain
argument_list|(
literal|"Unexpected \\}."
argument_list|)
expr_stmt|;
name|ret_code
operator|=
literal|0
expr_stmt|;
goto|goto
name|outahere
goto|;
case|case
literal|'('
case|:
if|if
condition|(
name|re_blk
operator|->
name|r_nparens
operator|>=
name|NPAR
condition|)
name|complain
argument_list|(
literal|"Too many ('s; max is %d."
argument_list|,
name|NPAR
argument_list|)
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|OPENP
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|re_blk
operator|->
name|r_nparens
expr_stmt|;
operator|*
name|parenp
operator|++
operator|=
name|re_blk
operator|->
name|r_nparens
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
name|parenp
operator|==
name|parens
condition|)
name|complain
argument_list|(
literal|"Too many )'s."
argument_list|)
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|CLOSEP
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
operator|*
operator|--
name|parenp
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|alt_p
operator|>=
name|alt_endp
condition|)
name|complain
argument_list|(
literal|"Too many alternates; max %d."
argument_list|,
name|NALTS
argument_list|)
expr_stmt|;
comment|/* close off previous alternate */
operator|*
name|comp_ptr
operator|++
operator|=
name|CLOSEP
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
operator|*
operator|--
name|parenp
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|EOP
expr_stmt|;
operator|*
name|alt_p
operator|++
operator|=
name|comp_ptr
expr_stmt|;
comment|/* start a new one */
name|re_blk
operator|->
name|r_nparens
operator|=
literal|0
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|OPENP
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|re_blk
operator|->
name|r_nparens
expr_stmt|;
operator|*
name|parenp
operator|++
operator|=
name|re_blk
operator|->
name|r_nparens
operator|++
expr_stmt|;
name|start_p
operator|=
name|comp_ptr
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
operator|*
name|comp_ptr
operator|++
operator|=
name|BACKREF
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
operator|*
name|comp_ptr
operator|++
operator|=
name|AT_BOW
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
operator|*
name|comp_ptr
operator|++
operator|=
name|AT_EOW
expr_stmt|;
break|break;
default|default:
goto|goto
name|defchar
goto|;
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|kind
operator|!=
name|IN_CB
condition|)
goto|goto
name|defchar
goto|;
goto|goto
name|outahere
goto|;
case|case
literal|'.'
case|:
operator|*
name|comp_ptr
operator|++
operator|=
name|ANYC
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
name|comp_ptr
operator|==
name|start_p
condition|)
block|{
operator|*
name|comp_ptr
operator|++
operator|=
name|AT_BOL
expr_stmt|;
break|break;
block|}
goto|goto
name|defchar
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|(
name|REpeekc
operator|=
name|REgetc
argument_list|()
operator|)
operator|!=
literal|0
operator|&&
name|REpeekc
operator|!=
literal|'\\'
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|comp_ptr
operator|++
operator|=
name|AT_EOL
expr_stmt|;
break|break;
case|case
literal|'['
case|:
block|{
name|int
name|chrcnt
decl_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|ONE_OF
expr_stmt|;
if|if
condition|(
name|comp_ptr
operator|+
name|SETSIZE
operator|>=
name|comp_endp
condition|)
goto|goto
name|toolong
goto|;
name|byte_zero
argument_list|(
name|comp_ptr
argument_list|,
operator|(
name|size_t
operator|)
name|SETSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|REpeekc
operator|=
name|REgetc
argument_list|()
operator|)
operator|==
literal|'^'
condition|)
block|{
operator|*
name|this_verb
operator|=
name|NONE_OF
expr_stmt|;
comment|/* Get it for real this time. */
operator|(
name|void
operator|)
name|REgetc
argument_list|()
expr_stmt|;
block|}
name|chrcnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|REgetc
argument_list|()
operator|)
operator|!=
literal|']'
operator|&&
name|c
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|REgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|REpeekc
operator|=
name|REgetc
argument_list|()
operator|)
operator|==
literal|'-'
condition|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|c
expr_stmt|;
operator|(
name|void
operator|)
name|REgetc
argument_list|()
expr_stmt|;
comment|/* reread '-' */
name|c
operator|=
name|REgetc
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
while|while
condition|(
name|i
operator|<
name|c
condition|)
block|{
name|comp_ptr
index|[
name|SETBYTE
argument_list|(
name|i
argument_list|)
index|]
operator||=
name|SETBIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|comp_ptr
index|[
name|SETBYTE
argument_list|(
name|c
argument_list|)
index|]
operator||=
name|SETBIT
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|chrcnt
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"Missing ]."
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrcnt
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"Empty []."
argument_list|)
expr_stmt|;
name|comp_ptr
operator|+=
name|SETSIZE
expr_stmt|;
break|break;
block|}
case|case
literal|'*'
case|:
if|if
condition|(
name|prev_verb
operator|==
name|NULL
operator|||
operator|*
name|prev_verb
operator|<=
name|NOSTR
operator|||
operator|(
operator|*
name|prev_verb
operator|&
name|STAR
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|defchar
goto|;
if|if
condition|(
operator|*
name|prev_verb
operator|==
name|NORMC
operator|||
operator|*
name|prev_verb
operator|==
name|CINDC
condition|)
block|{
name|char
name|lastc
init|=
name|comp_ptr
index|[
operator|-
literal|1
index|]
decl_stmt|;
comment|/* The * operator applies only to the 				 * previous character.  Since we were 				 * building a string-matching command 				 * (NORMC or CINDC), we must split it 				 * up and work with the last character. 				 * 				 * Note that the STARed versions of these 				 * commands do not operate on strings, and 				 * so do not need or have character counts. 				 */
if|if
condition|(
name|prev_verb
index|[
literal|1
index|]
operator|==
literal|1
condition|)
block|{
comment|/* Only one char in string: 					 * delete old command. 					 */
name|this_verb
operator|=
name|prev_verb
expr_stmt|;
block|}
else|else
block|{
comment|/* Several chars in string: 					 * strip off the last. 					 * New verb is derived from old. 					 */
name|prev_verb
index|[
literal|1
index|]
operator|-=
literal|1
expr_stmt|;
name|this_verb
operator|-=
literal|1
expr_stmt|;
operator|*
name|this_verb
operator|=
operator|*
name|prev_verb
expr_stmt|;
block|}
name|comp_ptr
operator|=
name|this_verb
operator|+
literal|1
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|lastc
expr_stmt|;
block|}
else|else
block|{
comment|/* This command is just the previous one, 				 * whose verb we will modify. 				 */
name|this_verb
operator|=
name|prev_verb
expr_stmt|;
block|}
operator|*
name|this_verb
operator||=
name|STAR
expr_stmt|;
break|break;
default|default:
name|defchar
label|:
if|if
condition|(
operator|(
name|prev_verb
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
operator|*
name|prev_verb
operator|==
name|NORMC
operator|||
operator|*
name|prev_verb
operator|==
name|CINDC
operator|)
condition|)
block|{
comment|/* create new string command */
operator|*
name|comp_ptr
operator|++
operator|=
operator|(
name|CaseIgnore
operator|)
condition|?
name|CINDC
else|:
name|NORMC
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* merge this into previous string command */
name|this_verb
operator|=
name|prev_verb
expr_stmt|;
block|}
name|this_verb
index|[
literal|1
index|]
operator|+=
literal|1
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
name|outahere
label|:
comment|/* End of pattern, let's do some error checking. */
if|if
condition|(
name|kind
operator|==
name|OKAY_RE
condition|)
block|{
operator|*
name|comp_ptr
operator|++
operator|=
name|CLOSEP
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
operator|*
operator|--
name|parenp
expr_stmt|;
block|}
if|if
condition|(
name|parenp
operator|!=
name|parens
condition|)
name|complain
argument_list|(
literal|"Unmatched ()'s."
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|IN_CB
operator|&&
name|c
operator|==
literal|0
condition|)
comment|/* end of pattern with missing \}. */
name|complain
argument_list|(
literal|"Missing \\}."
argument_list|)
expr_stmt|;
operator|*
name|comp_ptr
operator|++
operator|=
name|EOP
expr_stmt|;
return|return
name|ret_code
return|;
block|}
end_function

begin_decl_stmt
name|private
name|char
modifier|*
name|pstrtlst
index|[
name|NPAR
index|]
decl_stmt|,
comment|/* index into re_blk->r_lbuf */
modifier|*
name|pendlst
index|[
name|NPAR
index|]
decl_stmt|,
modifier|*
name|REbolp
decl_stmt|,
comment|/* begining-of-line pointer */
modifier|*
name|locrater
decl_stmt|,
comment|/* roof of last substitution */
modifier|*
name|loc1
decl_stmt|,
comment|/* start of matched text */
modifier|*
name|loc2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* roof of matched text */
end_comment

begin_decl_stmt
name|int
name|REbom
decl_stmt|,
comment|/* beginning and end columns of match */
name|REeom
decl_stmt|,
name|REdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* increase in line length due to last re_dosub */
end_comment

begin_function
name|private
name|int
name|backref
parameter_list|(
name|n
parameter_list|,
name|linep
parameter_list|)
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|linep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|backsp
decl_stmt|,
modifier|*
name|backep
decl_stmt|;
name|backsp
operator|=
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
name|backep
operator|=
name|pendlst
index|[
name|n
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|backsp
operator|++
operator|==
operator|*
name|linep
operator|++
condition|)
if|if
condition|(
name|backsp
operator|>=
name|backep
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|int
name|member
parameter_list|(
name|comp_ptr
parameter_list|,
name|c
parameter_list|,
name|af
parameter_list|)
specifier|register
name|char
modifier|*
name|comp_ptr
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|af
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* try to match EOL always fails */
if|if
condition|(
name|comp_ptr
index|[
name|SETBYTE
argument_list|(
name|c
argument_list|)
index|]
operator|&
name|SETBIT
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|af
return|;
return|return
operator|!
name|af
return|;
block|}
end_function

begin_function
name|private
name|int
name|REmatch
parameter_list|(
name|linep
parameter_list|,
name|comp_ptr
parameter_list|)
specifier|register
name|char
modifier|*
name|linep
decl_stmt|,
decl|*
name|comp_ptr
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|first_p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|comp_ptr
operator|++
condition|)
block|{
case|case
name|NORMC
case|:
name|n
operator|=
operator|*
name|comp_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|linep
operator|++
operator|!=
operator|*
name|comp_ptr
operator|++
condition|)
return|return
name|NO
return|;
continue|continue;
case|case
name|CINDC
case|:
comment|/* case independent comparison */
name|n
operator|=
operator|*
name|comp_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
name|cind_cmp
argument_list|(
operator|*
name|linep
operator|++
argument_list|,
operator|*
name|comp_ptr
operator|++
argument_list|)
condition|)
return|return
name|NO
return|;
continue|continue;
case|case
name|EOP
case|:
name|loc2
operator|=
name|linep
expr_stmt|;
name|REeom
operator|=
operator|(
name|loc2
operator|-
name|REbolp
operator|)
expr_stmt|;
return|return
name|YES
return|;
comment|/* Success! */
case|case
name|AT_BOL
case|:
if|if
condition|(
name|linep
operator|==
name|REbolp
operator|&&
name|linep
operator|!=
name|locrater
condition|)
continue|continue;
return|return
name|NO
return|;
case|case
name|AT_EOL
case|:
if|if
condition|(
operator|*
name|linep
operator|==
literal|'\0'
condition|)
continue|continue;
return|return
name|NO
return|;
case|case
name|ANYC
case|:
if|if
condition|(
operator|*
name|linep
operator|++
operator|!=
literal|0
condition|)
continue|continue;
return|return
name|NO
return|;
case|case
name|AT_BOW
case|:
if|if
condition|(
name|linep
operator|!=
name|locrater
operator|&&
name|ismword
argument_list|(
operator|*
name|linep
argument_list|)
operator|&&
operator|(
name|linep
operator|==
name|REbolp
operator|||
operator|!
name|ismword
argument_list|(
name|linep
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
continue|continue;
return|return
name|NO
return|;
case|case
name|AT_EOW
case|:
if|if
condition|(
name|linep
operator|!=
name|locrater
operator|&&
operator|(
operator|*
name|linep
operator|==
literal|0
operator|||
operator|!
name|ismword
argument_list|(
operator|*
name|linep
argument_list|)
operator|)
operator|&&
operator|(
name|linep
operator|!=
name|REbolp
operator|&&
name|ismword
argument_list|(
name|linep
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
continue|continue;
return|return
name|NO
return|;
case|case
name|ONE_OF
case|:
case|case
name|NONE_OF
case|:
if|if
condition|(
name|member
argument_list|(
name|comp_ptr
argument_list|,
operator|*
name|linep
operator|++
argument_list|,
name|comp_ptr
index|[
operator|-
literal|1
index|]
operator|==
name|ONE_OF
argument_list|)
condition|)
block|{
name|comp_ptr
operator|+=
name|SETSIZE
expr_stmt|;
continue|continue;
block|}
return|return
name|NO
return|;
case|case
name|OPENP
case|:
name|pstrtlst
index|[
operator|*
name|comp_ptr
operator|++
index|]
operator|=
name|linep
expr_stmt|;
continue|continue;
case|case
name|CLOSEP
case|:
name|pendlst
index|[
operator|*
name|comp_ptr
operator|++
index|]
operator|=
name|linep
expr_stmt|;
continue|continue;
case|case
name|BACKREF
case|:
if|if
condition|(
name|pstrtlst
index|[
name|n
operator|=
operator|*
name|comp_ptr
operator|++
index|]
operator|==
literal|0
condition|)
block|{
name|s_mess
argument_list|(
literal|"\\%d was not specified."
argument_list|,
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NO
return|;
block|}
if|if
condition|(
name|backref
argument_list|(
name|n
argument_list|,
name|linep
argument_list|)
condition|)
block|{
name|linep
operator|+=
name|pendlst
index|[
name|n
index|]
operator|-
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
continue|continue;
block|}
return|return
name|NO
return|;
case|case
name|CURLYB
case|:
block|{
name|int
name|wcnt
decl_stmt|,
name|any
decl_stmt|;
name|wcnt
operator|=
operator|*
name|comp_ptr
operator|++
expr_stmt|;
name|any
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|wcnt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|any
operator|==
literal|0
condition|)
name|any
operator|=
name|REmatch
argument_list|(
name|linep
argument_list|,
name|comp_ptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|comp_ptr
operator|+=
operator|*
name|comp_ptr
expr_stmt|;
block|}
if|if
condition|(
name|any
operator|==
literal|0
condition|)
return|return
name|NO
return|;
name|linep
operator|=
name|loc2
expr_stmt|;
continue|continue;
block|}
case|case
name|ANYC
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
operator|*
name|linep
operator|++
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|NORMC
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
operator|*
name|comp_ptr
operator|==
operator|*
name|linep
operator|++
condition|)
empty_stmt|;
name|comp_ptr
operator|+=
literal|1
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CINDC
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
name|cind_cmp
argument_list|(
operator|*
name|comp_ptr
argument_list|,
operator|*
name|linep
operator|++
argument_list|)
condition|)
empty_stmt|;
name|comp_ptr
operator|+=
literal|1
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|ONE_OF
operator||
name|STAR
case|:
case|case
name|NONE_OF
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
while|while
condition|(
name|member
argument_list|(
name|comp_ptr
argument_list|,
operator|*
name|linep
operator|++
argument_list|,
name|comp_ptr
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|ONE_OF
operator||
name|STAR
operator|)
argument_list|)
condition|)
empty_stmt|;
name|comp_ptr
operator|+=
name|SETSIZE
expr_stmt|;
comment|/* fall through */
name|star
label|:
comment|/* linep points *after* first unmatched char. 		 * first_p points at where starred element started matching. 		 */
while|while
condition|(
operator|--
name|linep
operator|>
name|first_p
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|comp_ptr
operator|!=
name|NORMC
operator|||
operator|*
name|linep
operator|==
name|comp_ptr
index|[
literal|2
index|]
operator|)
operator|&&
name|REmatch
argument_list|(
name|linep
argument_list|,
name|comp_ptr
argument_list|)
condition|)
return|return
name|YES
return|;
block|}
continue|continue;
case|case
name|BACKREF
operator||
name|STAR
case|:
name|first_p
operator|=
name|linep
expr_stmt|;
name|n
operator|=
operator|*
name|comp_ptr
operator|++
expr_stmt|;
while|while
condition|(
name|backref
argument_list|(
name|n
argument_list|,
name|linep
argument_list|)
condition|)
name|linep
operator|+=
name|pendlst
index|[
name|n
index|]
operator|-
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
while|while
condition|(
name|linep
operator|>
name|first_p
condition|)
block|{
if|if
condition|(
name|REmatch
argument_list|(
name|linep
argument_list|,
name|comp_ptr
argument_list|)
condition|)
return|return
name|YES
return|;
name|linep
operator|-=
name|pendlst
index|[
name|n
index|]
operator|-
name|pstrtlst
index|[
name|n
index|]
expr_stmt|;
block|}
continue|continue;
default|default:
name|complain
argument_list|(
literal|"RE error match (%d)."
argument_list|,
name|comp_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_function
name|private
name|void
name|REreset
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPAR
condition|;
name|i
operator|++
control|)
name|pstrtlst
index|[
name|i
index|]
operator|=
name|pendlst
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Index LINE at OFFSET.  If lbuf_okay is nonzero it's okay to use linebuf    if LINE is the current line.  This should save lots of time in things    like paren matching in LISP mode.  Saves all that copying from linebuf    to a local buffer.  substitute() is the guy who calls re_lindex with    lbuf_okay as 0, since the substitution gets placed in linebuf ...    doesn't work too well when the source and destination strings are the    same.  I hate all these arguments!     This code is cumbersome, repetetive for reasons of efficiency.  Fast    search is a must as far as I am concerned. */
end_comment

begin_function
name|int
name|re_lindex
parameter_list|(
name|line
parameter_list|,
name|offset
parameter_list|,
name|re_blk
parameter_list|,
name|lbuf_okay
parameter_list|,
name|crater
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|RE_block
modifier|*
name|re_blk
decl_stmt|;
name|int
name|lbuf_okay
decl_stmt|;
name|int
name|crater
decl_stmt|;
comment|/* offset of previous substitute (or -1) */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|firstc
init|=
name|re_blk
operator|->
name|r_firstc
decl_stmt|;
specifier|register
name|int
name|anchored
init|=
name|re_blk
operator|->
name|r_anchored
decl_stmt|;
name|int
name|re_dir
init|=
name|REdirection
decl_stmt|;
name|char
modifier|*
modifier|*
name|alts
init|=
name|re_blk
operator|->
name|r_alternates
decl_stmt|;
name|REreset
argument_list|()
expr_stmt|;
if|if
condition|(
name|lbuf_okay
condition|)
block|{
name|REbolp
operator|=
name|lbptr
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
name|offset
operator|=
name|strlen
argument_list|(
name|REbolp
argument_list|)
expr_stmt|;
comment|/* arg! */
block|}
else|else
block|{
name|REbolp
operator|=
name|ltobuf
argument_list|(
name|line
argument_list|,
name|re_blk
operator|->
name|r_lbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Reverse search, find end of line. */
name|offset
operator|=
name|Jr_Len
expr_stmt|;
comment|/* Just Read Len. */
block|}
block|}
if|if
condition|(
name|anchored
operator|==
name|YES
condition|)
block|{
if|if
condition|(
name|re_dir
operator|==
name|FORWARD
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|crater
operator|!=
operator|-
literal|1
condition|)
return|return
name|NO
return|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|REbolp
operator|+
name|offset
expr_stmt|;
name|locrater
operator|=
name|REbolp
operator|+
name|crater
expr_stmt|;
if|if
condition|(
name|firstc
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|first_alt
init|=
operator|*
name|alts
decl_stmt|;
if|if
condition|(
name|re_dir
operator|==
name|FORWARD
condition|)
block|{
while|while
condition|(
name|CaseEquiv
index|[
operator|*
name|p
index|]
operator|!=
name|firstc
operator|||
operator|!
name|REmatch
argument_list|(
name|p
argument_list|,
name|first_alt
argument_list|)
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|NO
return|;
block|}
else|else
block|{
while|while
condition|(
name|CaseEquiv
index|[
operator|*
name|p
index|]
operator|!=
name|firstc
operator|||
operator|!
name|REmatch
argument_list|(
name|p
argument_list|,
name|first_alt
argument_list|)
condition|)
if|if
condition|(
operator|--
name|p
operator|<
name|REbolp
condition|)
return|return
name|NO
return|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|altp
init|=
name|alts
decl_stmt|;
while|while
condition|(
operator|*
name|altp
operator|!=
name|NULL
condition|)
if|if
condition|(
name|REmatch
argument_list|(
name|p
argument_list|,
operator|*
name|altp
operator|++
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|anchored
operator|||
operator|(
name|re_dir
operator|==
name|FORWARD
condition|?
operator|*
name|p
operator|++
operator|==
literal|'\0'
else|:
operator|--
name|p
operator|<
name|REbolp
operator|)
condition|)
return|return
name|NO
return|;
block|}
name|success
label|:
empty_stmt|;
block|}
name|loc1
operator|=
name|p
expr_stmt|;
name|REbom
operator|=
name|loc1
operator|-
name|REbolp
expr_stmt|;
return|return
name|YES
return|;
block|}
end_function

begin_decl_stmt
name|int
name|okay_wrap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a wrap search ... not when we're 			   parsing errors ... */
end_comment

begin_function
name|Bufpos
modifier|*
name|dosearch
parameter_list|(
name|pattern
parameter_list|,
name|dir
parameter_list|,
name|re
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|re
decl_stmt|;
block|{
name|Bufpos
modifier|*
name|pos
decl_stmt|;
name|struct
name|RE_block
name|re_blk
decl_stmt|;
comment|/* global re-compiled buffer */
if|if
condition|(
name|bobp
argument_list|()
operator|&&
name|eobp
argument_list|()
condition|)
comment|/* Can't match!  There's no buffer. */
return|return
literal|0
return|;
name|REcompile
argument_list|(
name|pattern
argument_list|,
name|re
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
name|pos
operator|=
name|docompiled
argument_list|(
name|dir
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
return|return
name|pos
return|;
block|}
end_function

begin_function
name|Bufpos
modifier|*
name|docompiled
parameter_list|(
name|dir
parameter_list|,
name|re_blk
parameter_list|)
name|int
name|dir
decl_stmt|;
specifier|register
name|struct
name|RE_block
modifier|*
name|re_blk
decl_stmt|;
block|{
specifier|static
name|Bufpos
name|ret
decl_stmt|;
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
name|int
name|we_wrapped
init|=
name|NO
decl_stmt|;
name|lsave
argument_list|()
expr_stmt|;
comment|/* Search now lsave()'s so it doesn't make any assumptions on 	   whether the the contents of curline/curchar are in linebuf. 	   Nowhere does search write all over linebuf.  However, we have to 	   be careful about what calls we make here, because many of them 	   assume (and rightly so) that curline is in linebuf. */
name|REdirection
operator|=
name|dir
expr_stmt|;
name|lp
operator|=
name|curline
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
condition|)
block|{
if|if
condition|(
name|bobp
argument_list|()
condition|)
block|{
if|if
condition|(
name|okay_wrap
operator|&&
name|WrapScan
condition|)
goto|goto
name|doit
goto|;
return|return
literal|0
return|;
block|}
comment|/* here we simulate BackChar() */
if|if
condition|(
name|bolp
argument_list|()
condition|)
block|{
name|lp
operator|=
name|lp
operator|->
name|l_prev
expr_stmt|;
name|offset
operator|=
name|length
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dir
operator|==
name|FORWARD
operator|)
operator|&&
operator|(
name|lbptr
argument_list|(
name|lp
argument_list|)
index|[
name|offset
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|!
name|lastp
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|re_lindex
argument_list|(
name|lp
argument_list|,
name|offset
argument_list|,
name|re_blk
argument_list|,
name|YES
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
break|break;
name|doit
label|:
name|lp
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|lp
operator|->
name|l_next
else|:
name|lp
operator|->
name|l_prev
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|okay_wrap
operator|&&
name|WrapScan
condition|)
block|{
name|lp
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|curbuf
operator|->
name|b_first
else|:
name|curbuf
operator|->
name|b_last
expr_stmt|;
name|we_wrapped
operator|=
name|YES
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* signals re_lindex ... */
block|}
do|while
condition|(
name|lp
operator|!=
name|curline
condition|)
do|;
if|if
condition|(
name|lp
operator|==
name|curline
operator|&&
name|we_wrapped
condition|)
name|lp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ret
operator|.
name|p_line
operator|=
name|lp
expr_stmt|;
name|ret
operator|.
name|p_char
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|REeom
else|:
name|REbom
expr_stmt|;
return|return
operator|&
name|ret
return|;
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|insert
parameter_list|(
name|off
parameter_list|,
name|endp
parameter_list|,
name|which
parameter_list|)
name|char
modifier|*
name|off
decl_stmt|,
decl|*
name|endp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
name|pendlst
index|[
name|which
index|]
operator|-
name|pstrtlst
index|[
name|which
index|]
expr_stmt|;
name|pp
operator|=
name|pstrtlst
index|[
name|which
index|]
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|off
operator|++
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
return|return
name|off
return|;
block|}
end_block

begin_comment
comment|/* Perform the substitution.  If DELP is nonzero the matched string is    deleted, i.e., the substitution string is not inserted. */
end_comment

begin_function
name|void
name|re_dosub
parameter_list|(
name|re_blk
parameter_list|,
name|tobuf
parameter_list|,
name|delp
parameter_list|)
name|struct
name|RE_block
modifier|*
name|re_blk
decl_stmt|;
name|char
modifier|*
name|tobuf
decl_stmt|;
name|int
name|delp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|tp
operator|=
name|tobuf
expr_stmt|;
name|endp
operator|=
name|tp
operator|+
name|LBSIZE
expr_stmt|;
name|rp
operator|=
name|re_blk
operator|->
name|r_lbuf
expr_stmt|;
while|while
condition|(
name|rp
operator|<
name|loc1
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|delp
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|rp
operator|=
name|rep_str
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|rp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<
name|re_blk
operator|->
name|r_nparens
operator|+
literal|'0'
condition|)
block|{
name|tp
operator|=
name|insert
argument_list|(
name|tp
argument_list|,
name|endp
argument_list|,
name|c
operator|-
literal|'0'
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|rp
operator|--
expr_stmt|;
comment|/* be sure to hit again */
block|}
block|}
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tp
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|rp
operator|=
name|loc2
expr_stmt|;
name|REdelta
operator|=
operator|-
name|REeom
expr_stmt|;
name|REeom
operator|=
name|tp
operator|-
name|tobuf
expr_stmt|;
name|REdelta
operator|+=
name|REeom
expr_stmt|;
if|if
condition|(
name|loc1
operator|==
name|rp
operator|&&
operator|*
name|rp
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Skip an extra character if the matched text was a null 		 * string, but don't skip over the end of line.  This is to 		 * prevent an infinite number of replacements in the same 		 * position, e.g., replace "^" with "". 		 */
name|REeom
operator|+=
literal|1
expr_stmt|;
block|}
name|loc2
operator|=
name|re_blk
operator|->
name|r_lbuf
operator|+
name|REeom
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|rp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|tp
operator|>=
name|endp
condition|)
name|len_error
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|putmatch
parameter_list|(
name|which
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
operator|*
operator|(
name|insert
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|size
argument_list|,
name|which
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setsearch
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|strcpy
argument_list|(
name|searchstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|getsearch
parameter_list|()
block|{
return|return
name|searchstr
return|;
block|}
end_function

begin_function
name|void
name|RErecur
parameter_list|()
block|{
name|char
name|repbuf
index|[
sizeof|sizeof
name|rep_str
index|]
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|REbom
argument_list|,
name|M_FLOATER
argument_list|)
decl_stmt|;
name|message
argument_list|(
literal|"Type C-X C-C to continue with query replace."
argument_list|)
expr_stmt|;
name|byte_copy
argument_list|(
name|rep_str
argument_list|,
name|repbuf
argument_list|,
sizeof|sizeof
name|rep_str
argument_list|)
expr_stmt|;
name|Recur
argument_list|()
expr_stmt|;
name|byte_copy
argument_list|(
name|repbuf
argument_list|,
name|rep_str
argument_list|,
sizeof|sizeof
name|rep_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_an_arg
argument_list|()
condition|)
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ForSearch
parameter_list|()
block|{
name|search
argument_list|(
name|FORWARD
argument_list|,
name|UseRE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RevSearch
parameter_list|()
block|{
name|search
argument_list|(
name|BACKWARD
argument_list|,
name|UseRE
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FSrchND
parameter_list|()
block|{
name|search
argument_list|(
name|FORWARD
argument_list|,
name|UseRE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RSrchND
parameter_list|()
block|{
name|search
argument_list|(
name|BACKWARD
argument_list|,
name|UseRE
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|search
parameter_list|(
name|dir
parameter_list|,
name|re
parameter_list|,
name|setdefault
parameter_list|)
name|int
name|dir
decl_stmt|,
name|re
decl_stmt|,
name|setdefault
decl_stmt|;
block|{
name|Bufpos
modifier|*
name|newdot
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|ask
argument_list|(
name|searchstr
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|setdefault
condition|)
name|setsearch
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|okay_wrap
operator|=
name|YES
expr_stmt|;
name|newdot
operator|=
name|dosearch
argument_list|(
name|s
argument_list|,
name|dir
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|okay_wrap
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|newdot
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|WrapScan
condition|)
name|complain
argument_list|(
literal|"No \"%s\" in buffer."
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"No \"%s\" found to %s."
argument_list|,
name|s
argument_list|,
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
literal|"bottom"
else|:
literal|"top"
argument_list|)
expr_stmt|;
block|}
name|PushPntp
argument_list|(
name|newdot
operator|->
name|p_line
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|newdot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do we match PATTERN at OFFSET in BUF? */
end_comment

begin_function
name|int
name|LookingAt
parameter_list|(
name|pattern
parameter_list|,
name|buf
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|RE_block
name|re_blk
decl_stmt|;
name|char
modifier|*
modifier|*
name|alt
init|=
name|re_blk
operator|.
name|r_alternates
decl_stmt|;
name|REcompile
argument_list|(
name|pattern
argument_list|,
name|YES
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
name|REreset
argument_list|()
expr_stmt|;
name|locrater
operator|=
name|NULL
expr_stmt|;
name|REbolp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|alt
condition|)
if|if
condition|(
name|REmatch
argument_list|(
name|buf
operator|+
name|offset
argument_list|,
operator|*
name|alt
operator|++
argument_list|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_block

begin_function
name|int
name|look_at
parameter_list|(
name|expr
parameter_list|)
name|char
modifier|*
name|expr
decl_stmt|;
block|{
name|struct
name|RE_block
name|re_blk
decl_stmt|;
name|REcompile
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
name|REreset
argument_list|()
expr_stmt|;
name|locrater
operator|=
name|NULL
expr_stmt|;
name|REbolp
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|REmatch
argument_list|(
name|linebuf
operator|+
name|curchar
argument_list|,
name|re_blk
operator|.
name|r_alternates
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|YES
return|;
return|return
name|NO
return|;
block|}
end_function

end_unit

