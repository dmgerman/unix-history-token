begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
operator|||
name|defined
argument_list|(
name|IPROCS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|void
name|DefAutoExec
name|proto
argument_list|(
operator|(
expr|struct
name|data_obj
operator|*
call|(
modifier|*
name|proc
call|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|match
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|InJoverc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auto execute code */
end_comment

begin_define
define|#
directive|define
name|NEXECS
value|20
end_define

begin_macro
name|private
end_macro

begin_struct
struct|struct
block|{
name|char
modifier|*
name|a_pattern
decl_stmt|;
name|data_obj
modifier|*
name|a_cmd
decl_stmt|;
block|}
name|AutoExecs
index|[
name|NEXECS
index|]
struct|;
end_struct

begin_comment
comment|/* must be initialized by system to 0 */
end_comment

begin_decl_stmt
name|private
name|int
name|ExecIndex
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command auto-execute. */
end_comment

begin_function
name|void
name|CAutoExec
parameter_list|()
block|{
name|DefAutoExec
argument_list|(
name|findcom
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Macro auto-execute. */
end_comment

begin_function
name|void
name|MAutoExec
parameter_list|()
block|{
name|DefAutoExec
argument_list|(
name|findmac
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|private
name|void
name|DefAutoExec
argument_list|(
name|proc
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBMPC
argument_list|)
name|data_obj
modifier|*
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|data_obj
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|proc
operator|)
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ExecIndex
operator|>=
name|NEXECS
condition|)
name|complain
argument_list|(
literal|"Too many auto-executes, max %d."
argument_list|,
name|NEXECS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|pattern
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|": %f %s "
argument_list|,
name|d
operator|->
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ExecIndex
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_cmd
operator|==
name|d
condition|)
block|{
name|char
modifier|*
name|ipat
init|=
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
decl_stmt|;
if|if
condition|(
operator|(
name|pattern
operator|==
name|NULL
operator|||
name|ipat
operator|==
name|NULL
operator|)
condition|?
operator|(
name|pattern
operator|==
name|ipat
operator|)
else|:
operator|(
name|strcmp
argument_list|(
name|pattern
argument_list|,
name|ipat
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* eliminate duplicates */
block|}
block|}
name|AutoExecs
index|[
name|ExecIndex
index|]
operator|.
name|a_pattern
operator|=
name|copystr
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|AutoExecs
index|[
name|ExecIndex
index|]
operator|.
name|a_cmd
operator|=
name|d
expr_stmt|;
name|ExecIndex
operator|+=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* DoAutoExec: NEW and OLD are file names, and if NEW and OLD aren't the    same kind of file (i.e., match the same pattern) or OLD is 0 and it    matches, OR if the pattern is 0 (none was specified) then, we execute    the command associated with that kind of file. */
end_comment

begin_function
name|void
name|DoAutoExec
parameter_list|(
name|new
parameter_list|,
name|old
parameter_list|)
specifier|register
name|char
modifier|*
name|new
decl_stmt|,
decl|*
name|old
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|set_arg_value
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ExecIndex
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|new
operator|!=
literal|0
operator|&&
name|LookingAt
argument_list|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|old
operator|==
literal|0
operator|||
operator|!
name|LookingAt
argument_list|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_pattern
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
condition|)
name|ExecCmd
argument_list|(
name|AutoExecs
index|[
name|i
index|]
operator|.
name|a_cmd
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|addgetc
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|InJoverc
condition|)
block|{
name|Asking
operator|=
name|strlen
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
name|Asking
operator|=
literal|0
expr_stmt|;
name|add_mess
argument_list|(
literal|"%p "
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|EOF
return|;
comment|/* this isn't part of the sequence */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
name|LF
condition|)
name|complain
argument_list|(
literal|"[Premature end of line]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
literal|'?'
condition|)
name|c
operator|=
name|RUBOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"@[\\]^_"
argument_list|,
name|c
argument_list|)
condition|)
name|c
operator|=
name|CTL
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"[Unknown control character]"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
name|void
name|Extend
parameter_list|()
block|{
name|data_obj
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|findcom
argument_list|(
literal|": "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ExecCmd
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a positive integer from CP.  It must be in base BASE, and    complains if it isn't.  If allints is nonzero, all the characters    in the string must be integers or we return -1; otherwise we stop    reading at the first nondigit. */
end_comment

begin_function
name|int
name|chr_to_int
parameter_list|(
name|cp
parameter_list|,
name|base
parameter_list|,
name|allints
parameter_list|,
name|result
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|base
decl_stmt|,
name|allints
decl_stmt|;
specifier|register
name|int
modifier|*
name|result
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|,
name|sign
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|allints
operator|==
name|YES
condition|)
return|return
name|INT_BAD
return|;
break|break;
block|}
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
name|complain
argument_list|(
literal|"You must specify in base %d."
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|value
operator|=
name|value
operator|*
name|base
operator|+
name|c
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|value
operator|*
name|sign
expr_stmt|;
return|return
name|INT_OKAY
return|;
block|}
end_function

begin_function
name|int
name|ask_int
parameter_list|(
name|prompt
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
name|char
modifier|*
name|val
init|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|prompt
argument_list|)
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|chr_to_int
argument_list|(
name|val
argument_list|,
name|base
argument_list|,
name|YES
argument_list|,
operator|&
name|value
argument_list|)
operator|==
name|INT_BAD
condition|)
name|complain
argument_list|(
literal|"That's not a number!"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
name|vpr_aux
parameter_list|(
name|vp
parameter_list|,
name|buf
parameter_list|)
specifier|register
specifier|const
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
condition|)
block|{
case|case
name|V_BASE10
case|:
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_BASE8
case|:
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%o"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_BOOL
case|:
name|swritef
argument_list|(
name|buf
argument_list|,
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_STRING
case|:
case|case
name|V_FILENAME
case|:
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%s"
argument_list|,
name|vp
operator|->
name|v_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_CHAR
case|:
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%p"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|PrVar
parameter_list|()
block|{
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|char
name|prbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
operator|(
expr|struct
name|variable
operator|*
operator|)
name|findvar
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|vpr_aux
argument_list|(
name|vp
argument_list|,
name|prbuf
argument_list|)
expr_stmt|;
name|s_mess
argument_list|(
literal|": %f %s => %s"
argument_list|,
name|vp
operator|->
name|Name
argument_list|,
name|prbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetVar
parameter_list|()
block|{
name|struct
name|variable
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
operator|(
expr|struct
name|variable
operator|*
operator|)
name|findvar
argument_list|(
name|ProcFmt
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|prompt
operator|=
name|sprint
argument_list|(
literal|": %f %s "
argument_list|,
name|vp
operator|->
name|Name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
condition|)
block|{
case|case
name|V_BASE10
case|:
case|case
name|V_BASE8
case|:
block|{
name|int
name|value
decl_stmt|;
name|value
operator|=
name|ask_int
argument_list|(
name|prompt
argument_list|,
operator|(
operator|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TYPEMASK
operator|)
operator|==
name|V_BASE10
operator|)
condition|?
literal|10
else|:
literal|8
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
operator|=
name|value
expr_stmt|;
break|break;
block|}
case|case
name|V_BOOL
case|:
block|{
name|char
modifier|*
name|def
init|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
condition|?
literal|"off"
else|:
literal|"on"
decl_stmt|,
modifier|*
name|on_off
decl_stmt|;
name|int
name|value
decl_stmt|;
name|on_off
operator|=
name|ask
argument_list|(
name|def
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|casecmp
argument_list|(
name|on_off
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|ON
expr_stmt|;
elseif|else
if|if
condition|(
name|casecmp
argument_list|(
name|on_off
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|=
name|OFF
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"Boolean variables must be ON or OFF."
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
operator|=
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|MarkVar
argument_list|(
name|vp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mark the menu item */
endif|#
directive|endif
name|s_mess
argument_list|(
literal|"%s%s"
argument_list|,
name|prompt
argument_list|,
name|value
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|V_FILENAME
case|:
block|{
name|char
name|fbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|ask_file
argument_list|(
name|prompt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|V_STRING
case|:
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Do_ask() so you can set string to "" if you so desire. */
name|str
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vp
operator|->
name|v_value
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
literal|0
condition|)
name|str
operator|=
name|NullStr
expr_stmt|;
name|strcpy
argument_list|(
name|vp
operator|->
name|v_value
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* ... and hope there is enough room. */
break|break;
block|}
case|case
name|V_CHAR
case|:
name|f_mess
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|vp
operator|->
name|v_value
operator|)
operator|=
name|addgetc
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_MODELINE
condition|)
name|UpdModLine
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_CLRSCREEN
condition|)
block|{
ifdef|#
directive|ifdef
name|IBMPC
name|setcolor
argument_list|(
name|Fgcolor
argument_list|,
name|Bgcolor
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
name|ClAndRedraw
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flags
operator|&
name|V_TTY_RESET
condition|)
name|tty_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Command completion - possible is an array of strings, prompt is    the prompt to use, and flags are ... well read jove.h.     If flags are RET_STATE, and the user hits<return> what they typed    so far is in the Minibuf string. */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
modifier|*
name|Possible
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|comp_value
decl_stmt|,
name|comp_flags
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|aux_complete
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|int
name|command
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|comp_flags
operator|&
name|CASEIND
condition|)
block|{
name|char
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|linebuf
init|;
operator|*
name|lp
operator|!=
literal|'\0'
condition|;
name|lp
operator|++
control|)
if|#
directive|if
operator|(
name|defined
argument_list|(
name|IBMPC
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
name|lower
argument_list|(
name|lp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
operator|*
name|lp
operator|=
name|tolower
argument_list|(
operator|*
name|lp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|comp_value
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|command
operator|=
name|match
argument_list|(
name|Possible
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|>=
literal|0
condition|)
block|{
name|comp_value
operator|=
name|command
expr_stmt|;
return|return
literal|0
return|;
comment|/* tells ask to stop */
block|}
if|if
condition|(
name|eolp
argument_list|()
operator|&&
name|bolp
argument_list|()
condition|)
block|{
name|comp_value
operator|=
name|NULLSTRING
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|comp_flags
operator|&
name|RET_STATE
condition|)
block|{
name|comp_value
operator|=
name|command
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|InJoverc
condition|)
name|complain
argument_list|(
literal|"[\"%s\" unknown]"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
block|{
name|int
name|minmatch
init|=
literal|1000
decl_stmt|,
name|maxmatch
init|=
literal|0
decl_stmt|,
name|numfound
init|=
literal|0
decl_stmt|,
name|lastmatch
init|=
operator|-
literal|1
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Possible
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|int
name|this_len
decl_stmt|;
name|this_len
operator|=
name|numcomp
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|maxmatch
operator|=
name|max
argument_list|(
name|maxmatch
argument_list|,
name|this_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_len
operator|>=
name|len
condition|)
block|{
if|if
condition|(
name|numfound
condition|)
name|minmatch
operator|=
name|min
argument_list|(
name|minmatch
argument_list|,
name|numcomp
argument_list|(
name|Possible
index|[
name|lastmatch
index|]
argument_list|,
name|Possible
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|minmatch
operator|=
name|strlen
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|numfound
operator|+=
literal|1
expr_stmt|;
name|lastmatch
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|linebuf
argument_list|,
name|Possible
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|numfound
operator|==
literal|0
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
if|if
condition|(
name|InJoverc
condition|)
name|complain
argument_list|(
literal|"[\"%s\" unknown]"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
comment|/* If we're not in the .joverc then 			   let's do something helpful for the 			   user. */
if|if
condition|(
name|maxmatch
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|linebuf
operator|+
name|maxmatch
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\t'
operator|&&
name|numfound
operator|==
literal|1
condition|)
block|{
name|comp_value
operator|=
name|lastmatch
expr_stmt|;
return|return
literal|0
return|;
block|}
name|null_ncpy
argument_list|(
name|linebuf
argument_list|,
name|Possible
index|[
name|lastmatch
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|minmatch
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|minmatch
operator|==
name|len
condition|)
comment|/* No difference */
name|rbell
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
literal|'?'
case|:
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|InJoverc
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* kludge: in case we're using UseBuffers, in which case 		   linebuf gets written all over */
name|strcpy
argument_list|(
name|Minibuf
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|Minibuf
argument_list|)
expr_stmt|;
name|TOstart
argument_list|(
literal|"Completion"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* for now ... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Possible
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|numcomp
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|,
name|Minibuf
argument_list|)
operator|>=
name|len
condition|)
block|{
name|Typeout
argument_list|(
name|Possible
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TOabort
operator|!=
literal|0
condition|)
break|break;
block|}
name|TOstop
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|!
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|complete
parameter_list|(
name|possible
parameter_list|,
name|prompt
parameter_list|,
name|flags
parameter_list|)
specifier|register
name|char
modifier|*
name|possible
index|[]
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
comment|/* protect static "Possible" from being overwritten due to recursion */
if|if
condition|(
name|InRealAsk
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Possible
operator|=
name|possible
expr_stmt|;
name|comp_flags
operator|=
name|flags
expr_stmt|;
operator|(
name|void
operator|)
name|do_ask
argument_list|(
literal|"\r\n \t?"
argument_list|,
name|aux_complete
argument_list|,
name|NullStr
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
return|return
name|comp_value
return|;
block|}
end_function

begin_function
name|private
name|int
name|match
parameter_list|(
name|choices
parameter_list|,
name|what
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|choices
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|,
name|save
decl_stmt|,
name|exactmatch
init|=
operator|-
literal|1
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULLSTRING
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|choices
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|what
argument_list|,
name|choices
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|what
argument_list|,
name|choices
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|exactmatch
operator|=
name|i
expr_stmt|;
name|save
operator|=
name|i
expr_stmt|;
name|found
operator|+=
literal|1
expr_stmt|;
comment|/* found one */
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|save
operator|=
name|ORIGINAL
expr_stmt|;
elseif|else
if|if
condition|(
name|found
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|exactmatch
operator|!=
operator|-
literal|1
condition|)
name|save
operator|=
name|exactmatch
expr_stmt|;
else|else
name|save
operator|=
name|AMBIGUOUS
expr_stmt|;
block|}
return|return
name|save
return|;
block|}
end_block

begin_function
name|void
name|Source
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|char
modifier|*
name|com
decl_stmt|,
name|buf
index|[
name|FILESIZE
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%s/.joverc"
argument_list|,
name|HomeDir
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
if|if
condition|(
name|com
operator|=
name|getenv
argument_list|(
literal|"JOVERC"
argument_list|)
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|com
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|Joverc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|com
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|buf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|joverc
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
name|IOerr
argument_list|(
literal|"read"
argument_list|,
name|com
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BufPos
parameter_list|()
block|{
specifier|register
name|Line
modifier|*
name|lp
init|=
name|curbuf
operator|->
name|b_first
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|dotline
decl_stmt|;
name|long
name|dotchar
decl_stmt|,
name|nchars
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nchars
operator|=
literal|0
init|;
name|lp
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
if|if
condition|(
name|lp
operator|==
name|curline
condition|)
block|{
name|dotchar
operator|=
name|nchars
operator|+
name|curchar
expr_stmt|;
name|dotline
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|nchars
operator|+=
name|length
argument_list|(
name|lp
argument_list|)
operator|+
operator|(
name|lp
operator|->
name|l_next
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* include the NL */
block|}
name|s_mess
argument_list|(
literal|"[\"%s\" line %d/%d, char %D/%D (%d%%), cursor = %d/%d]"
argument_list|,
name|filename
argument_list|(
name|curbuf
argument_list|)
argument_list|,
name|dotline
argument_list|,
name|i
argument_list|,
name|dotchar
argument_list|,
name|nchars
argument_list|,
operator|(
name|nchars
operator|==
literal|0
operator|)
condition|?
literal|100
else|:
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|dotchar
operator|*
literal|100
operator|)
operator|/
name|nchars
argument_list|)
argument_list|,
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
argument_list|,
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|linebuf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IF_UNBOUND
value|(-1)
end_define

begin_define
define|#
directive|define
name|IF_TRUE
value|1
end_define

begin_define
define|#
directive|define
name|IF_FALSE
value|(!IF_TRUE)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|private
name|int
name|do_if
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MSDOS
name|int
name|status
decl_stmt|;
else|#
directive|else
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
ifndef|#
directive|ifndef
name|MSDOS
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|complain
argument_list|(
literal|"[Fork failed: if]"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
block|{
endif|#
directive|endif
comment|/* MSDOS */
name|char
modifier|*
name|args
index|[
literal|12
index|]
decl_stmt|,
modifier|*
name|cp
init|=
name|cmd
decl_stmt|,
modifier|*
modifier|*
name|ap
init|=
name|args
decl_stmt|;
operator|*
name|ap
operator|++
operator|=
name|cmd
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|cp
expr_stmt|;
block|}
operator|*
name|ap
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*	we want reads to fail */
comment|/* close(1);	 but not writes or ioctl's 		close(2);    */
else|#
directive|else
comment|/* MSDOS */
if|if
condition|(
operator|(
name|status
operator|=
name|spawnvp
argument_list|(
literal|0
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"[Spawn failed: if]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
ifndef|#
directive|ifndef
name|MSDOS
operator|(
name|void
operator|)
name|execvp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|10
argument_list|)
expr_stmt|;
comment|/* signals exec error (see below) */
block|}
block|}
ifdef|#
directive|ifdef
name|IPROCS
name|SigHold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dowait
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
operator|-
literal|10
condition|)
name|complain
argument_list|(
literal|"[Exec failed]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"[Exit %d]"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
return|return
operator|(
name|status
operator|==
literal|0
operator|)
return|;
comment|/* 0 means successful */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_function
name|int
name|joverc
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
name|buf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|lbuf
index|[
name|LBSIZE
index|]
decl_stmt|;
name|int
name|lnum
init|=
literal|0
decl_stmt|,
name|eof
init|=
name|FALSE
decl_stmt|;
name|jmp_buf
name|savejmp
decl_stmt|;
name|int
name|IfStatus
init|=
name|IF_UNBOUND
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|F_READ
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
return|return
name|NO
return|;
comment|/* joverc returns an integer */
comment|/* Catch any errors, here, and do the right thing with them, 	   and then restore the error handle to whoever did a setjmp 	   last. */
name|InJoverc
operator|+=
literal|1
expr_stmt|;
name|push_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|mainjmp
argument_list|)
condition|)
block|{
name|Buffer
modifier|*
name|savebuf
init|=
name|curbuf
decl_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
literal|"RC errors"
argument_list|)
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|sprint
argument_list|(
literal|"%s:%d:%s\t%s\n"
argument_list|,
name|pr_name
argument_list|(
name|file
argument_list|,
name|YES
argument_list|)
argument_list|,
name|lnum
argument_list|,
name|lbuf
argument_list|,
name|mesgbuf
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|unmodify
argument_list|()
expr_stmt|;
name|SetBuf
argument_list|(
name|savebuf
argument_list|)
expr_stmt|;
name|Asking
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|eof
condition|)
do|do
block|{
name|eof
operator|=
operator|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|lbuf
argument_list|,
sizeof|sizeof
name|lbuf
argument_list|)
operator|==
name|EOF
operator|)
expr_stmt|;
name|lnum
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|lbuf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* a comment */
continue|continue;
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|casencmp
argument_list|(
name|lbuf
argument_list|,
literal|"if"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|cmd
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|IfStatus
operator|!=
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Cannot have nested if's]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LookingAt
argument_list|(
literal|"if[ \t]*\\(.*\\)$"
argument_list|,
name|lbuf
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[If syntax error]"
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|1
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
name|IfStatus
operator|=
name|do_if
argument_list|(
name|cmd
argument_list|)
condition|?
name|IF_TRUE
else|:
name|IF_FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|casencmp
argument_list|(
name|lbuf
argument_list|,
literal|"else"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IfStatus
operator|==
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Unexpected `else']"
argument_list|)
expr_stmt|;
name|IfStatus
operator|=
operator|!
name|IfStatus
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|casencmp
argument_list|(
name|lbuf
argument_list|,
literal|"endif"
argument_list|,
operator|(
name|size_t
operator|)
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|IfStatus
operator|==
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Unexpected `endif']"
argument_list|)
expr_stmt|;
name|IfStatus
operator|=
name|IF_UNBOUND
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|IfStatus
operator|==
name|IF_FALSE
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|lbuf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|Inputp
operator|=
name|lbuf
expr_stmt|;
while|while
condition|(
operator|*
name|Inputp
operator|==
literal|' '
operator|||
operator|*
name|Inputp
operator|==
literal|'\t'
condition|)
name|Inputp
operator|+=
literal|1
expr_stmt|;
comment|/* skip white space */
name|Extend
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|pop_env
argument_list|(
name|savejmp
argument_list|)
expr_stmt|;
name|Inputp
operator|=
literal|0
expr_stmt|;
name|Asking
operator|=
literal|0
expr_stmt|;
name|InJoverc
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|IfStatus
operator|!=
name|IF_UNBOUND
condition|)
name|complain
argument_list|(
literal|"[Missing endif]"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

