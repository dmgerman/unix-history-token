begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_decl_stmt
name|int
name|MarksShouldFloat
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|Mark
modifier|*
name|MakeMark
parameter_list|(
name|line
parameter_list|,
name|column
parameter_list|,
name|type
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
name|int
name|column
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|Mark
modifier|*
name|newmark
init|=
operator|(
name|Mark
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|newmark
argument_list|)
decl_stmt|;
name|MarkSet
argument_list|(
name|newmark
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|newmark
operator|->
name|m_next
operator|=
name|curbuf
operator|->
name|b_marks
expr_stmt|;
name|newmark
operator|->
name|m_flags
operator|=
name|type
expr_stmt|;
name|curbuf
operator|->
name|b_marks
operator|=
name|newmark
expr_stmt|;
return|return
name|newmark
return|;
block|}
end_function

begin_function
name|void
name|flush_marks
parameter_list|(
name|b
parameter_list|)
name|Buffer
modifier|*
name|b
decl_stmt|;
block|{
specifier|register
name|Mark
modifier|*
name|m
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|m
operator|=
name|b
operator|->
name|b_marks
expr_stmt|;
while|while
condition|(
name|m
operator|!=
literal|0
condition|)
block|{
name|next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|DelMark
parameter_list|(
name|m
parameter_list|)
specifier|register
name|Mark
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|Mark
modifier|*
name|mp
init|=
name|curbuf
operator|->
name|b_marks
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|mp
condition|)
name|curbuf
operator|->
name|b_marks
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
else|else
block|{
while|while
condition|(
name|mp
operator|!=
literal|0
operator|&&
name|mp
operator|->
name|m_next
operator|!=
name|m
condition|)
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"Unknown mark!"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|AllMarkSet
parameter_list|(
name|b
parameter_list|,
name|line
parameter_list|,
name|col
parameter_list|)
name|Buffer
modifier|*
name|b
decl_stmt|;
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
name|int
name|col
decl_stmt|;
block|{
specifier|register
name|Mark
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|b
operator|->
name|b_marks
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|MarkSet
argument_list|(
name|mp
argument_list|,
name|line
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MarkSet
parameter_list|(
name|m
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|)
name|Mark
modifier|*
name|m
decl_stmt|;
name|Line
modifier|*
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
block|{
name|m
operator|->
name|m_line
operator|=
name|line
expr_stmt|;
name|m
operator|->
name|m_char
operator|=
name|column
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PopMark
parameter_list|()
block|{
name|int
name|pmark
decl_stmt|;
if|if
condition|(
name|curmark
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|curbuf
operator|->
name|b_markring
index|[
operator|(
name|curbuf
operator|->
name|b_themark
operator|+
literal|1
operator|)
operator|%
name|NMARKS
index|]
operator|==
literal|0
condition|)
block|{
name|pmark
operator|=
name|curbuf
operator|->
name|b_themark
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|pmark
operator|<
literal|0
condition|)
name|pmark
operator|=
name|NMARKS
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|curbuf
operator|->
name|b_markring
index|[
name|pmark
index|]
operator|!=
literal|0
condition|)
do|;
name|curbuf
operator|->
name|b_markring
index|[
name|pmark
index|]
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|MarksShouldFloat
condition|?
name|M_FLOATER
else|:
name|M_FIXED
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|curmark
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|curmark
argument_list|)
expr_stmt|;
name|curmark
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|PtToMark
argument_list|()
expr_stmt|;
name|pmark
operator|=
name|curbuf
operator|->
name|b_themark
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pmark
operator|<
literal|0
condition|)
name|pmark
operator|=
name|NMARKS
operator|-
literal|1
expr_stmt|;
name|curbuf
operator|->
name|b_themark
operator|=
name|pmark
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SetMark
parameter_list|()
block|{
if|if
condition|(
name|is_an_arg
argument_list|()
condition|)
name|PopMark
argument_list|()
expr_stmt|;
else|else
name|set_mark
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_mark
parameter_list|()
block|{
name|do_set_mark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_set_mark
parameter_list|(
name|l
parameter_list|,
name|c
parameter_list|)
name|Line
modifier|*
name|l
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|curbuf
operator|->
name|b_themark
operator|=
operator|(
name|curbuf
operator|->
name|b_themark
operator|+
literal|1
operator|)
operator|%
name|NMARKS
expr_stmt|;
if|if
condition|(
name|curmark
operator|==
literal|0
condition|)
name|curmark
operator|=
name|MakeMark
argument_list|(
name|l
argument_list|,
name|c
argument_list|,
name|MarksShouldFloat
condition|?
name|M_FLOATER
else|:
name|M_FIXED
argument_list|)
expr_stmt|;
else|else
name|MarkSet
argument_list|(
name|curmark
argument_list|,
name|l
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|s_mess
argument_list|(
literal|"[Point pushed]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move point to Mark */
end_comment

begin_function
name|void
name|ToMark
parameter_list|(
name|m
parameter_list|)
name|Mark
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|DotTo
argument_list|(
name|m
operator|->
name|m_line
argument_list|,
name|m
operator|->
name|m_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
operator|>
operator|(
name|len
operator|=
name|length
argument_list|(
name|curline
argument_list|)
operator|)
condition|)
name|curchar
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_function
name|Mark
modifier|*
name|CurMark
parameter_list|()
block|{
if|if
condition|(
name|curmark
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"No mark."
argument_list|)
expr_stmt|;
return|return
name|curmark
return|;
block|}
end_function

begin_function
name|void
name|PtToMark
parameter_list|()
block|{
name|Line
modifier|*
name|mline
decl_stmt|;
name|int
name|mchar
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|mline
operator|=
name|curline
expr_stmt|;
name|mchar
operator|=
name|curchar
expr_stmt|;
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|MarkSet
argument_list|(
name|m
argument_list|,
name|mline
argument_list|,
name|mchar
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix marks for after a deletion.  For now, even marks that don't    float will actually float, because we can't allow marks to point    to non-existant lines. */
end_comment

begin_function
name|void
name|DFixMarks
parameter_list|(
name|line1
parameter_list|,
name|char1
parameter_list|,
name|line2
parameter_list|,
name|char2
parameter_list|)
specifier|register
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|char1
decl_stmt|,
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Mark
modifier|*
name|m
decl_stmt|;
name|Line
modifier|*
name|lp
init|=
name|line1
decl_stmt|;
if|if
condition|(
name|curbuf
operator|->
name|b_marks
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|lp
operator|!=
name|line2
operator|->
name|l_next
condition|)
block|{
for|for
control|(
name|m
operator|=
name|curbuf
operator|->
name|b_marks
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
name|m
operator|->
name|m_line
operator|==
name|lp
condition|)
name|m
operator|->
name|m_char
operator||=
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
block|}
for|for
control|(
name|m
operator|=
name|curbuf
operator|->
name|b_marks
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_char
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Not effected */
name|m
operator|->
name|m_char
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|15
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_line
operator|==
name|line1
operator|&&
name|m
operator|->
name|m_char
operator|<
name|char1
condition|)
continue|continue;
comment|/* This mark is not affected */
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_char
operator|>=
name|char1
operator|&&
name|m
operator|->
name|m_char
operator|<=
name|char2
condition|)
name|m
operator|->
name|m_char
operator|=
name|char1
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|m_char
operator|>
name|char2
condition|)
name|m
operator|->
name|m_char
operator|-=
operator|(
name|char2
operator|-
name|char1
operator|)
expr_stmt|;
comment|/* Same line move the mark backward */
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_line
operator|==
name|line2
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_char
operator|>
name|char2
condition|)
name|m
operator|->
name|m_char
operator|=
name|char1
operator|+
operator|(
name|m
operator|->
name|m_char
operator|-
name|char2
operator|)
expr_stmt|;
else|else
name|m
operator|->
name|m_char
operator|=
name|char1
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_BIG_DELETE
expr_stmt|;
name|m
operator|->
name|m_line
operator|=
name|line1
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_char
operator|=
name|char1
expr_stmt|;
name|m
operator|->
name|m_line
operator|=
name|line1
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_BIG_DELETE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Fix marks after an insertion.  Marks that don't float are ignored    on insertion, which means PtToMark has to be careful ... */
end_comment

begin_function
name|void
name|IFixMarks
parameter_list|(
name|line1
parameter_list|,
name|char1
parameter_list|,
name|line2
parameter_list|,
name|char2
parameter_list|)
specifier|register
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|char1
decl_stmt|,
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|Mark
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|curbuf
operator|->
name|b_marks
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOATER
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|m
operator|->
name|m_line
operator|==
name|line1
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_char
operator|>
name|char1
condition|)
block|{
name|m
operator|->
name|m_line
operator|=
name|line2
expr_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
name|m
operator|->
name|m_char
operator|+=
operator|(
name|char2
operator|-
name|char1
operator|)
expr_stmt|;
else|else
name|m
operator|->
name|m_char
operator|=
name|char2
operator|+
operator|(
name|m
operator|->
name|m_char
operator|-
name|char1
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

end_unit

