begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_comment
comment|/* most of the file... */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_comment
comment|/* Termcap definitions */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|CS
decl_stmt|,
modifier|*
name|SO
decl_stmt|,
modifier|*
name|SE
decl_stmt|,
modifier|*
name|CM
decl_stmt|,
modifier|*
name|CL
decl_stmt|,
modifier|*
name|CE
decl_stmt|,
modifier|*
name|HO
decl_stmt|,
modifier|*
name|AL
decl_stmt|,
modifier|*
name|DL
decl_stmt|,
modifier|*
name|VS
decl_stmt|,
modifier|*
name|VE
decl_stmt|,
modifier|*
name|KS
decl_stmt|,
modifier|*
name|KE
decl_stmt|,
modifier|*
name|TI
decl_stmt|,
modifier|*
name|TE
decl_stmt|,
modifier|*
name|IC
decl_stmt|,
modifier|*
name|DC
decl_stmt|,
modifier|*
name|IM
decl_stmt|,
modifier|*
name|EI
decl_stmt|,
modifier|*
name|LL
decl_stmt|,
modifier|*
name|M_IC
decl_stmt|,
comment|/* Insert char with arg */
modifier|*
name|M_DC
decl_stmt|,
comment|/* Delete char with arg */
modifier|*
name|M_AL
decl_stmt|,
comment|/* Insert line with arg */
modifier|*
name|M_DL
decl_stmt|,
comment|/* Delete line with arg */
modifier|*
name|SF
decl_stmt|,
comment|/* Scroll forward */
modifier|*
name|SR
decl_stmt|,
modifier|*
name|SP
decl_stmt|,
comment|/* Send Cursor Position */
modifier|*
name|VB
decl_stmt|,
modifier|*
name|BL
decl_stmt|,
modifier|*
name|IP
decl_stmt|,
comment|/* insert pad after character inserted */
modifier|*
name|lPC
decl_stmt|,
modifier|*
name|NL
decl_stmt|,
modifier|*
name|DO
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|LI
decl_stmt|,
name|ILI
decl_stmt|,
comment|/* Internal lines, i.e., 23 of LI is 24. */
name|CO
decl_stmt|,
name|UL
decl_stmt|,
name|MI
decl_stmt|,
name|SG
decl_stmt|,
comment|/* number of magic cookies left by SO and SE */
name|XS
decl_stmt|,
comment|/* whether standout is braindamaged */
name|HZ
decl_stmt|,
comment|/* Hazeltine tilde kludge */
name|TABS
decl_stmt|,
name|UPlen
decl_stmt|,
name|HOlen
decl_stmt|,
name|LLlen
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* 	 * Are you sure about this one Jon?  On the SYSV system I tried this 	 * on I got a multiple definition of PC because it was already 	 * defined in -ltermcap.  Similarly for BC and UP ... 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVR2
end_ifdef

begin_comment
comment|/* release 2, at least */
end_comment

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSVR2 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_decl_stmt
name|private
name|char
name|tspace
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The ordering of ts and meas must agree !! */
end_comment

begin_decl_stmt
name|private
specifier|const
name|char
name|ts
index|[]
init|=
literal|"vsvealdlspcssosecmclcehoupbcicimdceillsfsrvbksketiteALDLICDCpcipblnldo"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
modifier|*
specifier|const
name|meas
index|[]
init|=
block|{
operator|&
name|VS
block|,
operator|&
name|VE
block|,
operator|&
name|AL
block|,
operator|&
name|DL
block|,
operator|&
name|SP
block|,
operator|&
name|CS
block|,
operator|&
name|SO
block|,
operator|&
name|SE
block|,
operator|&
name|CM
block|,
operator|&
name|CL
block|,
operator|&
name|CE
block|,
operator|&
name|HO
block|,
operator|&
name|UP
block|,
operator|&
name|BC
block|,
operator|&
name|IC
block|,
operator|&
name|IM
block|,
operator|&
name|DC
block|,
operator|&
name|EI
block|,
operator|&
name|LL
block|,
operator|&
name|SF
block|,
operator|&
name|SR
block|,
operator|&
name|VB
block|,
operator|&
name|KS
block|,
operator|&
name|KE
block|,
operator|&
name|TI
block|,
operator|&
name|TE
block|,
operator|&
name|M_AL
block|,
operator|&
name|M_DL
block|,
operator|&
name|M_IC
block|,
operator|&
name|M_DC
block|,
operator|&
name|lPC
block|,
operator|&
name|IP
block|,
operator|&
name|BL
block|,
operator|&
name|NL
block|,
operator|&
name|DO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|TermError
parameter_list|()
block|{
name|flusho
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getTERM
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|tgetstr
argument_list|()
decl_stmt|;
name|char
name|termbuf
index|[
literal|13
index|]
decl_stmt|,
modifier|*
name|termname
init|=
name|NULL
decl_stmt|,
modifier|*
name|termp
init|=
name|tspace
decl_stmt|,
name|tbuff
index|[
literal|2048
index|]
decl_stmt|;
comment|/* Good grief! */
specifier|const
name|char
modifier|*
name|tsp
init|=
name|ts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|termname
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|termname
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|termname
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|termname
argument_list|,
literal|"dumb"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|termname
argument_list|,
literal|"unknown"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|termname
argument_list|,
literal|"network"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|putstr
argument_list|(
literal|"Enter terminal type (e.g, vt100): "
argument_list|)
expr_stmt|;
name|flusho
argument_list|()
expr_stmt|;
name|termbuf
index|[
name|read
argument_list|(
literal|0
argument_list|,
name|termbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|termbuf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|TermError
argument_list|()
expr_stmt|;
name|termname
operator|=
name|termbuf
expr_stmt|;
block|}
if|if
condition|(
name|tgetent
argument_list|(
name|tbuff
argument_list|,
name|termname
argument_list|)
operator|<
literal|1
condition|)
block|{
name|writef
argument_list|(
literal|"[\"%s\" unknown terminal type?]"
argument_list|,
name|termname
argument_list|)
expr_stmt|;
name|TermError
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|CO
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|wimperr
label|:
name|writef
argument_list|(
literal|"You can't run JOVE on a %s terminal.\n"
argument_list|,
name|termname
argument_list|)
expr_stmt|;
name|TermError
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
elseif|else
if|if
condition|(
name|CO
operator|>
name|MAXCOLS
condition|)
name|CO
operator|=
name|MAXCOLS
expr_stmt|;
if|if
condition|(
operator|(
name|LI
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|wimperr
goto|;
if|if
condition|(
operator|(
name|SG
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|SG
operator|=
literal|0
expr_stmt|;
comment|/* Used for mode line only */
if|if
condition|(
operator|(
name|XS
operator|=
name|tgetflag
argument_list|(
literal|"xs"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|XS
operator|=
literal|0
expr_stmt|;
comment|/* Used for mode line only */
if|if
condition|(
operator|(
name|HZ
operator|=
name|tgetflag
argument_list|(
literal|"hz"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|HZ
operator|=
literal|0
expr_stmt|;
comment|/* Hazeltine tilde kludge */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|meas
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|static
name|char
name|nm
index|[
literal|3
index|]
init|=
literal|"xx"
decl_stmt|;
name|nm
index|[
literal|0
index|]
operator|=
operator|*
name|tsp
operator|++
expr_stmt|;
name|nm
index|[
literal|1
index|]
operator|=
operator|*
name|tsp
operator|++
expr_stmt|;
operator|*
operator|(
name|meas
index|[
name|i
index|]
operator|)
operator|=
operator|(
name|char
operator|*
operator|)
name|tgetstr
argument_list|(
name|nm
argument_list|,
operator|&
name|termp
argument_list|)
expr_stmt|;
if|if
condition|(
name|termp
operator|>
name|tspace
operator|+
sizeof|sizeof
argument_list|(
name|tspace
argument_list|)
condition|)
goto|goto
name|wimperr
goto|;
block|}
if|if
condition|(
name|lPC
condition|)
name|PC
operator|=
operator|*
name|lPC
expr_stmt|;
if|if
condition|(
name|XS
condition|)
name|SO
operator|=
name|SE
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CS
operator|&&
operator|!
name|SR
condition|)
name|CS
operator|=
name|SR
operator|=
name|SF
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CS
operator|&&
operator|!
name|SF
condition|)
name|SF
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|IM
operator|&&
operator|(
operator|*
name|IM
operator|==
literal|0
operator|)
condition|)
name|IM
operator|=
literal|0
expr_stmt|;
else|else
name|MI
operator|=
name|tgetflag
argument_list|(
literal|"mi"
argument_list|)
expr_stmt|;
name|UL
operator|=
name|tgetflag
argument_list|(
literal|"ul"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NL
operator|==
literal|0
condition|)
name|NL
operator|=
literal|"\n"
expr_stmt|;
else|else
block|{
comment|/* strip stupid padding information */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|NL
argument_list|)
condition|)
name|NL
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|NL
operator|==
literal|'*'
condition|)
name|NL
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DO
condition|)
name|DO
operator|=
name|NL
expr_stmt|;
if|if
condition|(
name|BL
operator|==
literal|0
condition|)
name|BL
operator|=
literal|"\007"
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"km"
argument_list|)
operator|>
literal|0
condition|)
comment|/* has meta-key */
name|MetaKey
operator|=
name|YES
expr_stmt|;
ifdef|#
directive|ifdef
name|ID_CHAR
name|disp_opt_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|CanScroll
operator|=
operator|(
operator|(
name|AL
operator|&&
name|DL
operator|)
operator|||
name|CS
operator|)
operator|)
operator|!=
literal|0
condition|)
name|IDline_setup
argument_list|(
name|termname
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|InitCM
parameter_list|()
block|{ }
end_function

begin_decl_stmt
name|int
name|EGA
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|getTERM
parameter_list|()
block|{
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|tgetstr
argument_list|()
decl_stmt|;
name|char
modifier|*
name|termname
decl_stmt|;
name|void
name|init_43
argument_list|()
decl_stmt|,
name|init_term
argument_list|()
decl_stmt|;
name|unsigned
name|char
name|lpp
argument_list|()
decl_stmt|,
name|chpl
argument_list|()
decl_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"EGA"
argument_list|)
operator|||
operator|(
operator|!
name|stricmp
argument_list|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
literal|"EGA"
argument_list|)
operator|)
condition|)
block|{
name|termname
operator|=
literal|"ega"
expr_stmt|;
name|init_43
argument_list|()
expr_stmt|;
name|EGA
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|termname
operator|=
literal|"ibmpc"
expr_stmt|;
name|init_term
argument_list|()
expr_stmt|;
name|EGA
operator|=
literal|0
expr_stmt|;
block|}
name|CO
operator|=
name|chpl
argument_list|()
expr_stmt|;
name|LI
operator|=
name|lpp
argument_list|()
expr_stmt|;
name|SG
operator|=
literal|0
expr_stmt|;
comment|/* Used for mode line only */
name|XS
operator|=
literal|0
expr_stmt|;
comment|/* Used for mode line only */
name|CanScroll
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MAC */
end_comment

begin_decl_stmt
name|int
name|LI
decl_stmt|,
name|ILI
decl_stmt|,
comment|/* Internal lines, i.e., 23 of LI is 24. */
name|CO
decl_stmt|,
name|TABS
decl_stmt|,
name|SG
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|getTERM
parameter_list|()
block|{
name|SG
operator|=
literal|0
expr_stmt|;
name|CanScroll
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_comment
comment|/* put a string with padding */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IBMPC
end_ifndef

begin_function
name|private
name|void
name|tputc
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|jputchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IBMPC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAC
end_ifndef

begin_function
name|void
name|putpad
parameter_list|(
name|str
parameter_list|,
name|lines
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|lines
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
name|str
condition|)
name|tputs
argument_list|(
name|str
argument_list|,
name|lines
argument_list|,
name|tputc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* IBMPC */
name|write_emif
argument_list|(
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_function
name|void
name|putargpad
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|lines
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|lines
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IBMPC
if|if
condition|(
name|str
condition|)
block|{
name|tputs
argument_list|(
ifdef|#
directive|ifdef
name|TERMINFO
name|tparm
argument_list|(
name|str
argument_list|,
name|arg
argument_list|)
argument_list|,
else|#
directive|else
comment|/* TERMINFO */
name|tgoto
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
name|arg
argument_list|)
argument_list|,
comment|/* fudge */
endif|#
directive|endif
comment|/* TERMINFO */
name|lines
argument_list|,
name|tputc
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* IBMPC */
comment|/* This code is only a guess: I don't know if any M_* termcap 	 * attributes are defined for the PC.  If they are not used, 	 * this routine is not called.  Perhaps this routine should 	 * simply abort. 	 */
if|if
condition|(
name|str
condition|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* hope that this is long enough */
name|swritef
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* hope only %d appears in str */
name|write_em
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IBMPC */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_comment
comment|/* Determine the number of characters to buffer at each baud rate.  The    lower the number, the quicker the response when new input arrives.  Of    course the lower the number, the more prone the program is to stop in    output.  Decide what matters most to you. This sets BufSize to the right    number or chars, and initializes `stdout'.  */
end_comment

begin_function
name|void
name|settout
parameter_list|(
name|ttbuf
parameter_list|)
name|char
modifier|*
name|ttbuf
decl_stmt|;
block|{
name|int
name|speed_chars
decl_stmt|;
specifier|static
specifier|const
name|int
name|speeds
index|[]
init|=
block|{
literal|1
block|,
comment|/* 0	*/
literal|1
block|,
comment|/* 50	*/
literal|1
block|,
comment|/* 75	*/
literal|1
block|,
comment|/* 110	*/
literal|1
block|,
comment|/* 134	*/
literal|1
block|,
comment|/* 150	*/
literal|1
block|,
comment|/* 200	*/
literal|2
block|,
comment|/* 300	*/
literal|4
block|,
comment|/* 600	*/
literal|8
block|,
comment|/* 1200 */
literal|16
block|,
comment|/* 1800	*/
literal|32
block|,
comment|/* 2400	*/
literal|128
block|,
comment|/* 4800	*/
literal|256
block|,
comment|/* 9600	*/
literal|512
block|,
comment|/* EXTA	*/
literal|1024
comment|/* EXT	*/
block|}
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
name|speed_chars
operator|=
literal|256
expr_stmt|;
else|#
directive|else
name|speed_chars
operator|=
name|speeds
index|[
name|ospeed
index|]
expr_stmt|;
endif|#
directive|endif
name|flusho
argument_list|()
expr_stmt|;
comment|/* flush the one character buffer */
name|BufSize
operator|=
name|min
argument_list|(
name|MAXTTYBUF
argument_list|,
name|speed_chars
operator|*
name|max
argument_list|(
name|LI
operator|/
literal|24
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stdout
operator|=
name|fd_open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|F_WRITE
operator||
name|F_LOCKED
argument_list|,
literal|1
argument_list|,
name|ttbuf
argument_list|,
name|BufSize
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

