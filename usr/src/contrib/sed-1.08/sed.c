begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  GNU SED, a batch stream editor.     Copyright (C) 1989-1991 Free Software Foundation, Inc.      This program is free software; you can redistribute it and/or modify     it under the terms of the GNU General Public License as published by     the Free Software Foundation; either version 2, or (at your option)     any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU General Public License for more details.      You should have received a copy of the GNU General Public License     along with this program; if not, write to the Free Software     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|VOID
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VOID
value|char
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|(memcpy((d), (s), (n)))
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_function_decl
name|VOID
modifier|*
name|memchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|version_string
init|=
literal|"GNU sed version 1.08"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Struct vector is used to describe a chunk of a sed program.  There is one    vector for the main program, and one for each { } pair. */
end_comment

begin_struct
struct|struct
name|vector
block|{
name|struct
name|sed_cmd
modifier|*
name|v
decl_stmt|;
name|int
name|v_length
decl_stmt|;
name|int
name|v_allocated
decl_stmt|;
name|struct
name|vector
modifier|*
name|up_one
decl_stmt|;
name|struct
name|vector
modifier|*
name|next_one
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Goto structure is used to hold both GOTO's and labels.  There are two    separate lists, one of goto's, called 'jumps', and one of labels, called    'labels'.    the V element points to the descriptor for the program-chunk in which the    goto was encountered.    the v_index element counts which element of the vector actually IS the    goto/label.  The first element of the vector is zero.    the NAME element is the null-terminated name of the label.    next is the next goto/label in the list. */
end_comment

begin_struct
struct|struct
name|sed_label
block|{
name|struct
name|vector
modifier|*
name|v
decl_stmt|;
name|int
name|v_index
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|sed_label
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ADDR_TYPE is zero for a null address,    one if addr_number is valid, or    two if addr_regex is valid,    three, if the address is '$'     Other values are undefined.  */
end_comment

begin_define
define|#
directive|define
name|ADDR_NULL
value|0
end_define

begin_define
define|#
directive|define
name|ADDR_NUM
value|1
end_define

begin_define
define|#
directive|define
name|ADDR_REGEX
value|2
end_define

begin_define
define|#
directive|define
name|ADDR_LAST
value|3
end_define

begin_struct
struct|struct
name|addr
block|{
name|int
name|addr_type
decl_stmt|;
name|struct
name|re_pattern_buffer
modifier|*
name|addr_regex
decl_stmt|;
name|int
name|addr_number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Aflags:  If the low order bit is set, a1 has been    matched; apply this command until a2 matches.    If the next bit is set, apply this command to all    lines that DON'T match the address(es).  */
end_comment

begin_define
define|#
directive|define
name|A1_MATCHED_BIT
value|01
end_define

begin_define
define|#
directive|define
name|ADDR_BANG_BIT
value|02
end_define

begin_struct
struct|struct
name|sed_cmd
block|{
name|struct
name|addr
name|a1
decl_stmt|,
name|a2
decl_stmt|;
name|int
name|aflags
decl_stmt|;
name|char
name|cmd
decl_stmt|;
union|union
block|{
comment|/* This structure is used for a, i, and c commands */
struct|struct
block|{
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|text_len
decl_stmt|;
block|}
name|cmd_txt
struct|;
comment|/* This is used for b and t commands */
name|struct
name|sed_cmd
modifier|*
name|label
decl_stmt|;
comment|/* This for r and w commands */
name|FILE
modifier|*
name|io_file
decl_stmt|;
comment|/* This for the hairy s command */
comment|/* For the flags var: 		   low order bit means the 'g' option was given, 		   next bit means the 'p' option was given, 		   and the next bit means a 'w' option was given, 		      and wio_file contains the file to write to. */
define|#
directive|define
name|S_GLOBAL_BIT
value|01
define|#
directive|define
name|S_PRINT_BIT
value|02
define|#
directive|define
name|S_WRITE_BIT
value|04
define|#
directive|define
name|S_NUM_BIT
value|010
struct|struct
block|{
name|struct
name|re_pattern_buffer
modifier|*
name|regx
decl_stmt|;
name|char
modifier|*
name|replacement
decl_stmt|;
name|int
name|replace_length
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|numb
decl_stmt|;
name|FILE
modifier|*
name|wio_file
decl_stmt|;
block|}
name|cmd_regex
struct|;
comment|/* This for the y command */
name|unsigned
name|char
modifier|*
name|translate
decl_stmt|;
comment|/* For { and } */
name|struct
name|vector
modifier|*
name|sub
decl_stmt|;
name|struct
name|sed_label
modifier|*
name|jump
decl_stmt|;
block|}
name|x
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Sed operates a line at a time. */
end_comment

begin_struct
struct|struct
name|line
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* Pointer to line allocated by malloc. */
name|int
name|length
decl_stmt|;
comment|/* Length of text. */
name|int
name|alloc
decl_stmt|;
comment|/* Allocated space for text. */
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information about files opend by the 'r', 'w',    and 's///w' commands.  In paticular, it holds the FILE pointer to    use, the file's name, a flag that is non-zero if the file is being    read instead of written. */
end_comment

begin_define
define|#
directive|define
name|NUM_FPS
value|32
end_define

begin_struct
struct|struct
block|{
name|FILE
modifier|*
name|phile
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|readit
decl_stmt|;
block|}
name|file_ptrs
index|[
name|NUM_FPS
index|]
struct|;
end_struct

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|P_
parameter_list|(
name|s
parameter_list|)
value|s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P_
parameter_list|(
name|s
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|panic
name|P_
argument_list|(
operator|(
name|char
operator|*
name|str
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|__fp_name
name|P_
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ck_fopen
name|P_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ck_fwrite
name|P_
argument_list|(
operator|(
name|char
operator|*
name|ptr
operator|,
name|int
name|size
operator|,
name|int
name|nmemb
operator|,
name|FILE
operator|*
name|stream
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ck_fclose
name|P_
argument_list|(
operator|(
name|FILE
operator|*
name|stream
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOID
modifier|*
name|ck_malloc
name|P_
argument_list|(
operator|(
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOID
modifier|*
name|ck_realloc
name|P_
argument_list|(
operator|(
name|VOID
operator|*
name|ptr
operator|,
name|int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ck_strdup
name|P_
argument_list|(
operator|(
name|char
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VOID
modifier|*
name|init_buffer
name|P_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|flush_buffer
name|P_
argument_list|(
operator|(
name|VOID
operator|*
name|bb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_buffer
name|P_
argument_list|(
operator|(
name|VOID
operator|*
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add_buffer
name|P_
argument_list|(
operator|(
name|VOID
operator|*
name|bb
operator|,
name|char
operator|*
name|p
operator|,
name|int
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add1_buffer
name|P_
argument_list|(
operator|(
name|VOID
operator|*
name|bb
operator|,
name|int
name|ch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|get_buffer
name|P_
argument_list|(
operator|(
name|VOID
operator|*
name|bb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|compile_string
name|P_
argument_list|(
operator|(
name|char
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|compile_file
name|P_
argument_list|(
operator|(
name|char
operator|*
name|str
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vector
modifier|*
name|compile_program
name|P_
argument_list|(
operator|(
expr|struct
name|vector
operator|*
name|vector
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|bad_prog
name|P_
argument_list|(
operator|(
name|char
operator|*
name|why
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inchar
name|P_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|savchar
name|P_
argument_list|(
operator|(
name|int
name|ch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|compile_address
name|P_
argument_list|(
operator|(
expr|struct
name|addr
operator|*
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|compile_regex
name|P_
argument_list|(
operator|(
name|int
name|slash
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sed_label
modifier|*
name|setup_jump
name|P_
argument_list|(
operator|(
expr|struct
name|sed_label
operator|*
name|list
operator|,
expr|struct
name|sed_cmd
operator|*
name|cmd
operator|,
expr|struct
name|vector
operator|*
name|vec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|compile_filename
name|P_
argument_list|(
operator|(
name|int
name|readit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|read_file
name|P_
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|execute_program
name|P_
argument_list|(
operator|(
expr|struct
name|vector
operator|*
name|vec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_address
name|P_
argument_list|(
operator|(
expr|struct
name|addr
operator|*
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|read_pattern_space
name|P_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|append_pattern_space
name|P_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|line_copy
name|P_
argument_list|(
operator|(
expr|struct
name|line
operator|*
name|from
operator|,
expr|struct
name|line
operator|*
name|to
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|line_append
name|P_
argument_list|(
operator|(
expr|struct
name|line
operator|*
name|from
operator|,
expr|struct
name|line
operator|*
name|to
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|str_append
name|P_
argument_list|(
operator|(
expr|struct
name|line
operator|*
name|to
operator|,
name|char
operator|*
name|string
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usage
name|P_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set, don't write out the line unless explictly told to */
end_comment

begin_decl_stmt
name|int
name|no_default_output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current input line # */
end_comment

begin_decl_stmt
name|int
name|input_line_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we on the last input file? */
end_comment

begin_decl_stmt
name|int
name|last_input_file
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have we hit EOF on the last input file?  This is used to decide if we    have hit the '$' address yet. */
end_comment

begin_decl_stmt
name|int
name|input_EOF
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-zero if a quit command has been executed. */
end_comment

begin_decl_stmt
name|int
name|quit_cmd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have we done any replacements lately?  This is used by the 't' command. */
end_comment

begin_decl_stmt
name|int
name|replaced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many '{'s are we executing at the moment */
end_comment

begin_decl_stmt
name|int
name|program_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The complete compiled SED program that we are going to run */
end_comment

begin_decl_stmt
name|struct
name|vector
modifier|*
name|the_program
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* information about labels and jumps-to-labels.  This is used to do    the required backpatching after we have compiled all the scripts. */
end_comment

begin_decl_stmt
name|struct
name|sed_label
modifier|*
name|jumps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sed_label
modifier|*
name|labels
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The 'current' input line. */
end_comment

begin_decl_stmt
name|struct
name|line
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An input line that's been stored by later use by the program */
end_comment

begin_decl_stmt
name|struct
name|line
name|hold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A 'line' to append to the current line when it comes time to write it out */
end_comment

begin_decl_stmt
name|struct
name|line
name|append
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we're reading a script command from a string, 'prog_start' and    'prog_end' point to the beginning and end of the string.  This    would allow us to compile script strings that contain nulls, except    that script strings are only read from the command line, which is    null-terminated */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prog_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prog_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we're reading a script command from a string, 'prog_cur' points    to the current character in the string */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prog_cur
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the name of the current script file.    It is used for error messages. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prog_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the current script file.  If it is zero, we are reading    from a string stored in 'prog_start' instead.  If both 'prog_file'    and 'prog_start' are zero, we're in trouble! */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|prog_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is the number of the current script line that we're compiling.  It is    used to give out useful and informative error messages. */
end_comment

begin_decl_stmt
name|int
name|prog_line
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the file pointer that we're currently reading data from.  It may    be stdin */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|input_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If this variable is non-zero at exit, one or more of the input    files couldn't be opened. */
end_comment

begin_decl_stmt
name|int
name|bad_input
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'an empty regular expression is equivalent to the last regular    expression read' so we have to keep track of the last regex used.    Here's where we store a pointer to it (it is only malloc()'d once) */
end_comment

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|last_regex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various error messages we may want to print */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ONE_ADDR
index|[]
init|=
literal|"Command only uses one address"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|NO_ADDR
index|[]
init|=
literal|"Command doesn't take any addresses"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|LINE_JUNK
index|[]
init|=
literal|"Extra characters after command"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|BAD_EOF
index|[]
init|=
literal|"Unexpected End-of-file"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|NO_REGEX
index|[]
init|=
literal|"No previous regular expression"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"expression"
block|,
literal|1
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"quiet"
block|,
literal|0
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"silent"
block|,
literal|0
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Yes, the main program, which parses arguments, and does the right    thing with them; it also inits the temporary storage, etc. */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|opt
decl_stmt|;
name|char
modifier|*
name|e_strings
init|=
name|NULL
decl_stmt|;
name|int
name|compiled
init|=
literal|0
decl_stmt|;
name|struct
name|sed_label
modifier|*
name|go
decl_stmt|,
modifier|*
name|lbl
decl_stmt|;
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ne:f:V"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'n'
case|:
name|no_default_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|e_strings
operator|==
name|NULL
condition|)
block|{
name|e_strings
operator|=
name|ck_malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|e_strings
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e_strings
operator|=
name|ck_realloc
argument_list|(
name|e_strings
argument_list|,
name|strlen
argument_list|(
name|e_strings
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|e_strings
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|e_strings
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|compiled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|compile_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|compiled
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e_strings
condition|)
block|{
name|compile_string
argument_list|(
name|e_strings
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e_strings
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compiled
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|compile_string
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|go
operator|=
name|jumps
init|;
name|go
condition|;
name|go
operator|=
name|go
operator|->
name|next
control|)
block|{
for|for
control|(
name|lbl
operator|=
name|labels
init|;
name|lbl
condition|;
name|lbl
operator|=
name|lbl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lbl
operator|->
name|name
argument_list|,
name|go
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|go
operator|->
name|name
operator|&&
operator|!
name|lbl
condition|)
name|panic
argument_list|(
literal|"Can't find label for jump to '%s'"
argument_list|,
name|go
operator|->
name|name
argument_list|)
expr_stmt|;
name|go
operator|->
name|v
operator|->
name|v
index|[
name|go
operator|->
name|v_index
index|]
operator|.
name|x
operator|.
name|jump
operator|=
name|lbl
expr_stmt|;
block|}
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|line
operator|.
name|alloc
operator|=
literal|50
expr_stmt|;
name|line
operator|.
name|text
operator|=
name|ck_malloc
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|append
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|append
operator|.
name|alloc
operator|=
literal|50
expr_stmt|;
name|append
operator|.
name|text
operator|=
name|ck_malloc
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|hold
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|hold
operator|.
name|alloc
operator|=
literal|50
expr_stmt|;
name|hold
operator|.
name|text
operator|=
name|ck_malloc
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
name|optind
condition|)
block|{
name|last_input_file
operator|++
expr_stmt|;
name|read_file
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
name|last_input_file
operator|++
expr_stmt|;
name|read_file
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|quit_cmd
condition|)
break|break;
block|}
if|if
condition|(
name|bad_input
condition|)
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 'str' is a string (from the command line) that contains a sed command.    Compile the command, and add it to the end of 'the_program' */
end_comment

begin_function
name|void
name|compile_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|prog_file
operator|=
literal|0
expr_stmt|;
name|prog_line
operator|=
literal|0
expr_stmt|;
name|prog_start
operator|=
name|prog_cur
operator|=
name|str
expr_stmt|;
name|prog_end
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|the_program
operator|=
name|compile_program
argument_list|(
name|the_program
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 'str' is the name of a file containing sed commands.  Read them in    and add them to the end of 'the_program' */
end_comment

begin_function
name|void
name|compile_file
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|prog_start
operator|=
name|prog_cur
operator|=
name|prog_end
operator|=
literal|0
expr_stmt|;
name|prog_name
operator|=
name|str
expr_stmt|;
name|prog_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|str
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|prog_file
operator|=
name|stdin
expr_stmt|;
else|else
name|prog_file
operator|=
name|ck_fopen
argument_list|(
name|str
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|prog_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|prog_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
name|no_default_output
operator|++
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|=
name|getc
argument_list|(
name|prog_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|prog_file
argument_list|)
expr_stmt|;
name|the_program
operator|=
name|compile_program
argument_list|(
name|the_program
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MORE_CMDS
value|40
end_define

begin_comment
comment|/* Read a program (or a subprogram within '{' '}' pairs) in and store    the compiled form in *'vector'  Return a pointer to the new vector.  */
end_comment

begin_function
name|struct
name|vector
modifier|*
name|compile_program
parameter_list|(
name|vector
parameter_list|)
name|struct
name|vector
modifier|*
name|vector
decl_stmt|;
block|{
name|struct
name|sed_cmd
modifier|*
name|cur_cmd
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|slash
decl_stmt|;
name|VOID
modifier|*
name|b
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
operator|!
name|vector
condition|)
block|{
name|vector
operator|=
operator|(
expr|struct
name|vector
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|vector
operator|->
name|v
operator|=
operator|(
expr|struct
name|sed_cmd
operator|*
operator|)
name|ck_malloc
argument_list|(
name|MORE_CMDS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sed_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|vector
operator|->
name|v_allocated
operator|=
name|MORE_CMDS
expr_stmt|;
name|vector
operator|->
name|v_length
operator|=
literal|0
expr_stmt|;
name|vector
operator|->
name|up_one
operator|=
literal|0
expr_stmt|;
name|vector
operator|->
name|next_one
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|skip_comment
label|:
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|(
name|isblank
argument_list|(
name|ch
argument_list|)
operator|||
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
literal|';'
operator|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|->
name|v_length
operator|==
name|vector
operator|->
name|v_allocated
condition|)
block|{
name|vector
operator|->
name|v
operator|=
operator|(
expr|struct
name|sed_cmd
operator|*
operator|)
name|ck_realloc
argument_list|(
operator|(
name|VOID
operator|*
operator|)
name|vector
operator|->
name|v
argument_list|,
operator|(
name|vector
operator|->
name|v_length
operator|+
name|MORE_CMDS
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sed_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|vector
operator|->
name|v_allocated
operator|+=
name|MORE_CMDS
expr_stmt|;
block|}
name|cur_cmd
operator|=
name|vector
operator|->
name|v
operator|+
name|vector
operator|->
name|v_length
expr_stmt|;
name|vector
operator|->
name|v_length
operator|++
expr_stmt|;
name|cur_cmd
operator|->
name|a1
operator|.
name|addr_type
operator|=
literal|0
expr_stmt|;
name|cur_cmd
operator|->
name|a2
operator|.
name|addr_type
operator|=
literal|0
expr_stmt|;
name|cur_cmd
operator|->
name|aflags
operator|=
literal|0
expr_stmt|;
name|cur_cmd
operator|->
name|cmd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compile_address
argument_list|(
operator|&
operator|(
name|cur_cmd
operator|->
name|a1
operator|)
argument_list|)
condition|)
block|{
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
block|{
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
do|;
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_address
argument_list|(
operator|&
operator|(
name|cur_cmd
operator|->
name|a2
operator|)
argument_list|)
condition|)
empty_stmt|;
else|else
name|bad_prog
argument_list|(
literal|"Unexpected ','"
argument_list|)
expr_stmt|;
block|}
else|else
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
name|new_cmd
label|:
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'#'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|a1
operator|.
name|addr_type
operator|!=
literal|0
condition|)
name|bad_prog
argument_list|(
name|NO_ADDR
argument_list|)
expr_stmt|;
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
do|;
name|vector
operator|->
name|v_length
operator|--
expr_stmt|;
goto|goto
name|skip_comment
goto|;
case|case
literal|'!'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|aflags
operator|&
name|ADDR_BANG_BIT
condition|)
name|bad_prog
argument_list|(
literal|"Multiple '!'s"
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|aflags
operator||=
name|ADDR_BANG_BIT
expr_stmt|;
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|bad_prog
argument_list|(
name|BAD_EOF
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|savchar(ch);
endif|#
directive|endif
goto|goto
name|new_cmd
goto|;
case|case
literal|'a'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|a2
operator|.
name|addr_type
operator|!=
literal|0
condition|)
name|bad_prog
argument_list|(
name|ONE_ADDR
argument_list|)
expr_stmt|;
comment|/* Fall Through */
case|case
literal|'c'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|inchar
argument_list|()
operator|!=
literal|'\\'
operator|||
name|inchar
argument_list|()
operator|!=
literal|'\n'
condition|)
name|bad_prog
argument_list|(
name|LINE_JUNK
argument_list|)
expr_stmt|;
name|b
operator|=
name|init_buffer
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|num
operator|=
name|size_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|string
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|get_buffer
argument_list|(
name|b
argument_list|)
argument_list|,
name|string
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text_len
operator|=
name|num
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|string
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
name|program_depth
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|while((ch=inchar())!=EOF&& ch!='\n') 				if(!isblank(ch)) 					bad_prog(LINE_JUNK);
endif|#
directive|endif
name|cur_cmd
operator|->
name|x
operator|.
name|sub
operator|=
name|compile_program
argument_list|(
operator|(
expr|struct
name|vector
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* FOO JF is this the right thing to do? */
break|break;
case|case
literal|'}'
case|:
if|if
condition|(
operator|!
name|program_depth
condition|)
name|bad_prog
argument_list|(
literal|"Unexpected '}'"
argument_list|)
expr_stmt|;
operator|--
operator|(
name|vector
operator|->
name|v_length
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|';'
condition|)
if|if
condition|(
operator|!
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
name|bad_prog
argument_list|(
name|LINE_JUNK
argument_list|)
expr_stmt|;
return|return
name|vector
return|;
case|case
literal|':'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|a1
operator|.
name|addr_type
operator|!=
literal|0
condition|)
name|bad_prog
argument_list|(
literal|": doesn't want any addresses"
argument_list|)
expr_stmt|;
name|labels
operator|=
name|setup_jump
argument_list|(
name|labels
argument_list|,
name|cur_cmd
argument_list|,
name|vector
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'t'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
name|jumps
operator|=
name|setup_jump
argument_list|(
name|jumps
argument_list|,
name|cur_cmd
argument_list|,
name|vector
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'='
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|a2
operator|.
name|addr_type
condition|)
name|bad_prog
argument_list|(
name|ONE_ADDR
argument_list|)
expr_stmt|;
comment|/* Fall Through */
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'l'
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
case|case
literal|'x'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|';'
condition|)
do|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|';'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
name|bad_prog
argument_list|(
name|LINE_JUNK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|a2
operator|.
name|addr_type
operator|!=
literal|0
condition|)
name|bad_prog
argument_list|(
name|ONE_ADDR
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'w'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|io_file
operator|=
name|compile_filename
argument_list|(
name|ch
operator|==
literal|'r'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
name|slash
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|compile_regex
argument_list|(
name|slash
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|regx
operator|=
name|last_regex
expr_stmt|;
name|b
operator|=
name|init_buffer
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
name|slash
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ci
decl_stmt|;
name|ci
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ci
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|ci
operator|!=
literal|'\n'
condition|)
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replace_length
operator|=
name|size_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replacement
operator|=
name|ck_malloc
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replace_length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|get_buffer
argument_list|(
name|b
argument_list|)
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replacement
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replace_length
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|numb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'p'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_PRINT_BIT
condition|)
name|bad_prog
argument_list|(
literal|"multiple 'p' options to 's' command"
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator||=
name|S_PRINT_BIT
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_NUM_BIT
condition|)
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&=
operator|~
name|S_NUM_BIT
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_GLOBAL_BIT
condition|)
name|bad_prog
argument_list|(
literal|"multiple 'g' options to 's' command"
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator||=
name|S_GLOBAL_BIT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator||=
name|S_WRITE_BIT
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|wio_file
operator|=
name|compile_filename
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_NUM_BIT
condition|)
name|bad_prog
argument_list|(
literal|"multiple number options to 's' command"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_GLOBAL_BIT
operator|)
operator|==
literal|0
condition|)
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator||=
name|S_NUM_BIT
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
block|}
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|numb
operator|=
name|num
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
case|case
name|EOF
case|:
break|break;
default|default:
name|bad_prog
argument_list|(
literal|"Unknown option to 's'"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|';'
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
break|break;
case|case
literal|'y'
case|:
name|cur_cmd
operator|->
name|cmd
operator|=
name|ch
expr_stmt|;
name|string
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|num
operator|=
literal|0
init|;
name|num
operator|<
literal|256
condition|;
name|num
operator|++
control|)
name|string
index|[
name|num
index|]
operator|=
name|num
expr_stmt|;
name|b
operator|=
name|init_buffer
argument_list|()
expr_stmt|;
name|slash
operator|=
name|inchar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
name|slash
condition|)
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|translate
operator|=
name|string
expr_stmt|;
name|string
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|get_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|num
operator|=
name|size_buffer
argument_list|(
name|b
argument_list|)
init|;
name|num
condition|;
operator|--
name|num
control|)
block|{
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|bad_prog
argument_list|(
name|BAD_EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|slash
condition|)
name|bad_prog
argument_list|(
literal|"strings for y command are different lengths"
argument_list|)
expr_stmt|;
name|cur_cmd
operator|->
name|x
operator|.
name|translate
index|[
operator|*
name|string
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|inchar
argument_list|()
operator|!=
name|slash
operator|||
operator|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|';'
operator|)
condition|)
name|bad_prog
argument_list|(
name|LINE_JUNK
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bad_prog
argument_list|(
literal|"Unknown command"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|vector
return|;
block|}
end_function

begin_comment
comment|/* Complain about a programming error and exit. */
end_comment

begin_function
name|void
name|bad_prog
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
if|if
condition|(
name|prog_line
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: file %s line %d: %s\n"
argument_list|,
name|myname
argument_list|,
name|prog_name
argument_list|,
name|prog_line
argument_list|,
name|why
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|myname
argument_list|,
name|why
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the next character from the program.  Return EOF if there isn't    anything to read.  Keep prog_line up to date, so error messages can    be meaningful. */
end_comment

begin_function
name|int
name|inchar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|prog_file
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|prog_file
argument_list|)
condition|)
return|return
name|EOF
return|;
else|else
name|ch
operator|=
name|getc
argument_list|(
name|prog_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|prog_cur
condition|)
return|return
name|EOF
return|;
elseif|else
if|if
condition|(
name|prog_cur
operator|==
name|prog_end
condition|)
block|{
name|ch
operator|=
name|EOF
expr_stmt|;
name|prog_cur
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ch
operator|=
operator|*
name|prog_cur
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|prog_line
condition|)
name|prog_line
operator|++
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* unget 'ch' so the next call to inchar will return it.  'ch' must not be    EOF or anything nasty like that. */
end_comment

begin_function
name|void
name|savchar
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|&&
name|prog_line
operator|>
literal|1
condition|)
operator|--
name|prog_line
expr_stmt|;
if|if
condition|(
name|prog_file
condition|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|prog_file
argument_list|)
expr_stmt|;
else|else
operator|*
operator|--
name|prog_cur
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to read an address for a sed command.  If it succeeeds,    return non-zero and store the resulting address in *'addr'.    If the input doesn't look like an address read nothing    and return zero. */
end_comment

begin_function
name|int
name|compile_address
parameter_list|(
name|addr
parameter_list|)
name|struct
name|addr
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|num
decl_stmt|;
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|num
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|num
operator|=
name|num
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|addr
operator|->
name|addr_type
operator|=
name|ADDR_NUM
expr_stmt|;
name|addr
operator|->
name|addr_number
operator|=
name|num
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|addr
operator|->
name|addr_type
operator|=
name|ADDR_REGEX
expr_stmt|;
name|compile_regex
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|addr
operator|->
name|addr_regex
operator|=
name|last_regex
expr_stmt|;
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
do|;
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
block|{
name|addr
operator|->
name|addr_type
operator|=
name|ADDR_LAST
expr_stmt|;
do|do
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
do|;
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|compile_regex
parameter_list|(
name|slash
parameter_list|)
name|int
name|slash
decl_stmt|;
block|{
name|VOID
modifier|*
name|b
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|in_char_class
init|=
literal|0
decl_stmt|;
name|b
operator|=
name|init_buffer
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|ch
operator|!=
name|slash
operator|||
name|in_char_class
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
name|size_buffer
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
block|{
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'`'
argument_list|)
expr_stmt|;
block|}
else|else
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
block|{
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|slash
condition|)
block|{
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
block|}
else|else
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'['
condition|)
block|{
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|in_char_class
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|']'
condition|)
block|{
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|in_char_class
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|'\\'
condition|)
block|{
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 'b': 			add1_buffer(b,'\b'); 			break; 		case 'f': 			add1_buffer(b,'\f'); 			break; 		case 'r': 			add1_buffer(b,'\r'); 			break; 		case 't': 			add1_buffer(b,'\t'); 			break;
endif|#
directive|endif
comment|/* 0 */
case|case
name|EOF
case|:
break|break;
default|default:
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|bad_prog
argument_list|(
name|BAD_EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_buffer
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|last_regex
operator|=
operator|(
expr|struct
name|re_pattern_buffer
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_pattern_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|last_regex
operator|->
name|allocated
operator|=
name|size_buffer
argument_list|(
name|b
argument_list|)
operator|+
literal|10
expr_stmt|;
name|last_regex
operator|->
name|buffer
operator|=
name|ck_malloc
argument_list|(
name|last_regex
operator|->
name|allocated
argument_list|)
expr_stmt|;
name|last_regex
operator|->
name|fastmap
operator|=
name|ck_malloc
argument_list|(
literal|256
argument_list|)
expr_stmt|;
name|last_regex
operator|->
name|translate
operator|=
literal|0
expr_stmt|;
name|re_compile_pattern
argument_list|(
name|get_buffer
argument_list|(
name|b
argument_list|)
argument_list|,
name|size_buffer
argument_list|(
name|b
argument_list|)
argument_list|,
name|last_regex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|last_regex
condition|)
name|bad_prog
argument_list|(
name|NO_REGEX
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store a label (or label reference) created by a ':', 'b', or 't'    comand so that the jump to/from the lable can be backpatched after    compilation is complete */
end_comment

begin_function
name|struct
name|sed_label
modifier|*
name|setup_jump
parameter_list|(
name|list
parameter_list|,
name|cmd
parameter_list|,
name|vec
parameter_list|)
name|struct
name|sed_label
modifier|*
name|list
decl_stmt|;
name|struct
name|sed_cmd
modifier|*
name|cmd
decl_stmt|;
name|struct
name|vector
modifier|*
name|vec
decl_stmt|;
block|{
name|struct
name|sed_label
modifier|*
name|tmp
decl_stmt|;
name|VOID
modifier|*
name|b
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|b
operator|=
name|init_buffer
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|isblank
argument_list|(
name|ch
argument_list|)
condition|)
empty_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|=
name|inchar
argument_list|()
expr_stmt|;
block|}
name|savchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
expr|struct
name|sed_label
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sed_label
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|v
operator|=
name|vec
expr_stmt|;
name|tmp
operator|->
name|v_index
operator|=
name|cmd
operator|-
name|vec
operator|->
name|v
expr_stmt|;
name|tmp
operator|->
name|name
operator|=
name|ck_strdup
argument_list|(
name|get_buffer
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* read in a filename for a 'r', 'w', or 's///w' command, and    update the internal structure about files.  The file is    opened if it isn't already open. */
end_comment

begin_function
name|FILE
modifier|*
name|compile_filename
parameter_list|(
name|readit
parameter_list|)
name|int
name|readit
decl_stmt|;
block|{
name|char
modifier|*
name|file_name
decl_stmt|;
name|int
name|n
decl_stmt|;
name|VOID
modifier|*
name|b
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|inchar
argument_list|()
operator|!=
literal|' '
condition|)
name|bad_prog
argument_list|(
literal|"missing ' ' before filename"
argument_list|)
expr_stmt|;
name|b
operator|=
name|init_buffer
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|inchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|add1_buffer
argument_list|(
name|b
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|add1_buffer
argument_list|(
name|b
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|get_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|NUM_FPS
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|file_ptrs
index|[
name|n
index|]
operator|.
name|name
condition|)
break|break;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|file_ptrs
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|file_name
argument_list|)
condition|)
block|{
if|if
condition|(
name|file_ptrs
index|[
name|n
index|]
operator|.
name|readit
operator|!=
name|readit
condition|)
name|bad_prog
argument_list|(
literal|"Can't open file for both reading and writing"
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|file_ptrs
index|[
name|n
index|]
operator|.
name|phile
return|;
block|}
block|}
if|if
condition|(
name|n
operator|<
name|NUM_FPS
condition|)
block|{
name|file_ptrs
index|[
name|n
index|]
operator|.
name|name
operator|=
name|ck_strdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|file_ptrs
index|[
name|n
index|]
operator|.
name|readit
operator|=
name|readit
expr_stmt|;
if|if
condition|(
operator|!
name|readit
condition|)
name|file_ptrs
index|[
name|n
index|]
operator|.
name|phile
operator|=
name|ck_fopen
argument_list|(
name|file_name
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
argument_list|(
name|file_name
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|file_ptrs
index|[
name|n
index|]
operator|.
name|phile
operator|=
name|ck_fopen
argument_list|(
name|file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|file_ptrs
index|[
name|n
index|]
operator|.
name|phile
operator|=
name|ck_fopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|flush_buffer
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|file_ptrs
index|[
name|n
index|]
operator|.
name|phile
return|;
block|}
else|else
block|{
name|bad_prog
argument_list|(
literal|"Hopelessely evil compiled in limit on number of open files.  re-compile sed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse a filename given by a 'r' 'w' or 's///w' command. */
end_comment

begin_function
name|void
name|read_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|input_file
operator|=
name|stdin
expr_stmt|;
else|else
block|{
name|input_file
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file
operator|==
literal|0
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
name|errno
operator|>=
literal|0
operator|&&
name|errno
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"Unknown error code"
expr_stmt|;
name|bad_input
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't read %s: %s\n"
argument_list|,
name|myname
argument_list|,
name|name
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
while|while
condition|(
name|read_pattern_space
argument_list|()
condition|)
block|{
name|execute_program
argument_list|(
name|the_program
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_default_output
condition|)
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|append
operator|.
name|length
condition|)
block|{
name|ck_fwrite
argument_list|(
name|append
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|append
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|append
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|quit_cmd
condition|)
break|break;
block|}
name|ck_fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute the program 'vec' on the current input line. */
end_comment

begin_function
name|void
name|execute_program
parameter_list|(
name|vec
parameter_list|)
name|struct
name|vector
modifier|*
name|vec
decl_stmt|;
block|{
name|struct
name|sed_cmd
modifier|*
name|cur_cmd
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|addr_matched
decl_stmt|;
specifier|static
name|int
name|end_cycle
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|remain
decl_stmt|;
name|int
name|offset
decl_stmt|;
specifier|static
name|struct
name|line
name|tmp
decl_stmt|;
name|struct
name|line
name|t
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|,
modifier|*
name|rep_end
decl_stmt|,
modifier|*
name|rep_next
decl_stmt|,
modifier|*
name|rep_cur
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|end_cycle
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur_cmd
operator|=
name|vec
operator|->
name|v
operator|,
name|n
operator|=
name|vec
operator|->
name|v_length
init|;
name|n
condition|;
name|cur_cmd
operator|++
operator|,
name|n
operator|--
control|)
block|{
name|exe_loop
label|:
name|addr_matched
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|aflags
operator|&
name|A1_MATCHED_BIT
condition|)
block|{
name|addr_matched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|match_address
argument_list|(
operator|&
operator|(
name|cur_cmd
operator|->
name|a2
operator|)
argument_list|)
condition|)
name|cur_cmd
operator|->
name|aflags
operator|&=
operator|~
name|A1_MATCHED_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match_address
argument_list|(
operator|&
operator|(
name|cur_cmd
operator|->
name|a1
operator|)
argument_list|)
condition|)
block|{
name|addr_matched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|a2
operator|.
name|addr_type
operator|!=
name|ADDR_NULL
condition|)
name|cur_cmd
operator|->
name|aflags
operator||=
name|A1_MATCHED_BIT
expr_stmt|;
block|}
if|if
condition|(
name|cur_cmd
operator|->
name|aflags
operator|&
name|ADDR_BANG_BIT
condition|)
name|addr_matched
operator|=
operator|!
name|addr_matched
expr_stmt|;
if|if
condition|(
operator|!
name|addr_matched
condition|)
continue|continue;
switch|switch
condition|(
name|cur_cmd
operator|->
name|cmd
condition|)
block|{
case|case
literal|'{'
case|:
comment|/* Execute sub-program */
name|execute_program
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|sub
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* Executing labels is easy. */
break|break;
case|case
literal|'='
case|:
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|input_line_number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
while|while
condition|(
name|append
operator|.
name|alloc
operator|-
name|append
operator|.
name|length
operator|<
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text_len
condition|)
block|{
name|append
operator|.
name|alloc
operator|*=
literal|2
expr_stmt|;
name|append
operator|.
name|text
operator|=
name|ck_realloc
argument_list|(
name|append
operator|.
name|text
argument_list|,
name|append
operator|.
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text
argument_list|,
name|append
operator|.
name|text
operator|+
name|append
operator|.
name|length
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text_len
argument_list|)
expr_stmt|;
name|append
operator|.
name|length
operator|+=
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text_len
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
name|cur_cmd
operator|->
name|x
operator|.
name|jump
condition|)
name|end_cycle
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|sed_label
modifier|*
name|j
init|=
name|cur_cmd
operator|->
name|x
operator|.
name|jump
decl_stmt|;
name|n
operator|=
name|j
operator|->
name|v
operator|->
name|v_length
operator|-
name|j
operator|->
name|v_index
expr_stmt|;
name|cur_cmd
operator|=
name|j
operator|->
name|v
operator|->
name|v
operator|+
name|j
operator|->
name|v_index
expr_stmt|;
goto|goto
name|exe_loop
goto|;
block|}
break|break;
case|case
literal|'c'
case|:
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_cmd
operator|->
name|aflags
operator|&
name|A1_MATCHED_BIT
operator|)
condition|)
name|ck_fwrite
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text_len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|end_cycle
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|line
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|end_cycle
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|newlength
decl_stmt|;
name|tmp
operator|=
name|memchr
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|'\n'
argument_list|,
name|line
operator|.
name|length
argument_list|)
expr_stmt|;
name|newlength
operator|=
name|line
operator|.
name|length
operator|-
operator|(
name|tmp
operator|-
name|line
operator|.
name|text
operator|)
expr_stmt|;
if|if
condition|(
name|newlength
condition|)
name|memmove
argument_list|(
name|line
operator|.
name|text
argument_list|,
name|tmp
argument_list|,
name|newlength
argument_list|)
expr_stmt|;
name|line
operator|.
name|length
operator|=
name|newlength
expr_stmt|;
block|}
name|end_cycle
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|line_copy
argument_list|(
operator|&
name|hold
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|line_append
argument_list|(
operator|&
name|hold
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|line_copy
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|line_append
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|hold
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ck_fwrite
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_txt
operator|.
name|text_len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|width
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|line
operator|.
name|length
expr_stmt|;
name|tmp
operator|=
name|line
operator|.
name|text
expr_stmt|;
comment|/* Use --n so this'll skip the trailing newline */
while|while
condition|(
operator|--
name|n
condition|)
block|{
if|if
condition|(
name|width
operator|>
literal|77
condition|)
block|{
name|width
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tmp
operator|==
literal|'\\'
condition|)
block|{
name|printf
argument_list|(
literal|"\\\\"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
name|width
operator|++
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|*
name|tmp
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Should print \00 instead of \0 because (a) POSIX requires it, and      (b) this way \01 is unambiguous.  */
block|case '\0': 						printf("\\0"); 						width+=2; 						break;
endif|#
directive|endif
case|case
literal|007
case|:
name|printf
argument_list|(
literal|"\\a"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|printf
argument_list|(
literal|"\\b"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|printf
argument_list|(
literal|"\\f"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|printf
argument_list|(
literal|"\\n"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|printf
argument_list|(
literal|"\\r"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|printf
argument_list|(
literal|"\\t"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|printf
argument_list|(
literal|"\\v"
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\\%02x"
argument_list|,
operator|(
operator|*
name|tmp
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|width
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|tmp
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|feof
argument_list|(
name|input_file
argument_list|)
condition|)
goto|goto
name|quit
goto|;
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|read_pattern_space
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|feof
argument_list|(
name|input_file
argument_list|)
condition|)
goto|goto
name|quit
goto|;
name|append_pattern_space
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|memchr
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|'\n'
argument_list|,
name|line
operator|.
name|length
argument_list|)
expr_stmt|;
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|tmp
condition|?
name|tmp
operator|-
name|line
operator|.
name|text
operator|+
literal|1
else|:
name|line
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
name|quit
label|:
name|quit_cmd
operator|++
expr_stmt|;
name|end_cycle
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|rewind
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|io_file
argument_list|)
expr_stmt|;
do|do
block|{
name|append
operator|.
name|length
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|append
operator|.
name|length
operator|==
name|append
operator|.
name|alloc
condition|)
block|{
name|append
operator|.
name|alloc
operator|*=
literal|2
expr_stmt|;
name|append
operator|.
name|text
operator|=
name|ck_realloc
argument_list|(
name|append
operator|.
name|text
argument_list|,
name|append
operator|.
name|alloc
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|n
operator|=
name|fread
argument_list|(
name|append
operator|.
name|text
operator|+
name|append
operator|.
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|append
operator|.
name|alloc
operator|-
name|append
operator|.
name|length
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|io_file
argument_list|)
operator|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|ferror
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|io_file
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Read error on input file to 'r' command"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|tmp
operator|.
name|alloc
condition|)
block|{
name|tmp
operator|.
name|alloc
operator|=
literal|50
expr_stmt|;
name|tmp
operator|.
name|text
operator|=
name|ck_malloc
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|remain
operator|=
name|line
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|tmp
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|rep
operator|=
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replacement
expr_stmt|;
name|rep_end
operator|=
name|rep
operator|+
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|replace_length
expr_stmt|;
while|while
condition|(
operator|(
name|offset
operator|=
name|re_search
argument_list|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|regx
argument_list|,
name|line
operator|.
name|text
argument_list|,
name|line
operator|.
name|length
operator|-
literal|1
argument_list|,
name|start
argument_list|,
name|remain
argument_list|,
operator|&
name|regs
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|-
name|start
condition|)
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|line
operator|.
name|text
operator|+
name|start
argument_list|,
name|offset
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_NUM_BIT
condition|)
block|{
if|if
condition|(
name|count
operator|!=
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|numb
condition|)
block|{
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|line
operator|.
name|text
operator|+
name|regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|,
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|offset
operator|==
name|regs
operator|.
name|end
index|[
literal|0
index|]
condition|?
name|offset
operator|+
literal|1
else|:
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|remain
operator|=
operator|(
name|line
operator|.
name|length
operator|-
literal|1
operator|)
operator|-
name|start
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
name|rep_next
operator|=
name|rep_cur
operator|=
name|rep
init|;
name|rep_next
operator|<
name|rep_end
condition|;
name|rep_next
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|rep_next
operator|==
literal|'&'
condition|)
block|{
if|if
condition|(
name|rep_next
operator|-
name|rep_cur
condition|)
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|rep_cur
argument_list|,
name|rep_next
operator|-
name|rep_cur
argument_list|)
expr_stmt|;
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|line
operator|.
name|text
operator|+
name|regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|,
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|regs
operator|.
name|start
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rep_cur
operator|=
name|rep_next
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rep_next
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|rep_next
operator|-
name|rep_cur
condition|)
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|rep_cur
argument_list|,
name|rep_next
operator|-
name|rep_cur
argument_list|)
expr_stmt|;
name|rep_next
operator|++
expr_stmt|;
if|if
condition|(
name|rep_next
operator|!=
name|rep_end
condition|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|*
name|rep_next
operator|>=
literal|'0'
operator|&&
operator|*
name|rep_next
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|=
operator|*
name|rep_next
operator|-
literal|'0'
expr_stmt|;
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|line
operator|.
name|text
operator|+
name|regs
operator|.
name|start
index|[
name|n
index|]
argument_list|,
name|regs
operator|.
name|end
index|[
name|n
index|]
operator|-
name|regs
operator|.
name|start
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|rep_next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rep_cur
operator|=
name|rep_next
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rep_next
operator|-
name|rep_cur
condition|)
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|rep_cur
argument_list|,
name|rep_next
operator|-
name|rep_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|regs
operator|.
name|end
index|[
literal|0
index|]
condition|)
block|{
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|line
operator|.
name|text
operator|+
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
name|start
operator|=
name|regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
name|remain
operator|=
operator|(
name|line
operator|.
name|length
operator|-
literal|1
operator|)
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|remain
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_GLOBAL_BIT
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|count
condition|)
break|break;
name|replaced
operator|=
literal|1
expr_stmt|;
name|str_append
argument_list|(
operator|&
name|tmp
argument_list|,
name|line
operator|.
name|text
operator|+
name|start
argument_list|,
name|remain
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|.
name|text
operator|=
name|line
operator|.
name|text
expr_stmt|;
name|t
operator|.
name|length
operator|=
name|line
operator|.
name|length
expr_stmt|;
name|t
operator|.
name|alloc
operator|=
name|line
operator|.
name|alloc
expr_stmt|;
name|line
operator|.
name|text
operator|=
name|tmp
operator|.
name|text
expr_stmt|;
name|line
operator|.
name|length
operator|=
name|tmp
operator|.
name|length
expr_stmt|;
name|line
operator|.
name|alloc
operator|=
name|tmp
operator|.
name|alloc
expr_stmt|;
name|tmp
operator|.
name|text
operator|=
name|t
operator|.
name|text
expr_stmt|;
name|tmp
operator|.
name|length
operator|=
name|t
operator|.
name|length
expr_stmt|;
name|tmp
operator|.
name|alloc
operator|=
name|t
operator|.
name|alloc
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_WRITE_BIT
condition|)
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|wio_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_cmd
operator|->
name|x
operator|.
name|cmd_regex
operator|.
name|flags
operator|&
name|S_PRINT_BIT
condition|)
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|replaced
condition|)
block|{
name|replaced
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|cur_cmd
operator|->
name|x
operator|.
name|jump
condition|)
name|end_cycle
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|sed_label
modifier|*
name|j
init|=
name|cur_cmd
operator|->
name|x
operator|.
name|jump
decl_stmt|;
name|n
operator|=
name|j
operator|->
name|v
operator|->
name|v_length
operator|-
name|j
operator|->
name|v_index
expr_stmt|;
name|cur_cmd
operator|=
name|j
operator|->
name|v
operator|->
name|v
operator|+
name|j
operator|->
name|v_index
expr_stmt|;
goto|goto
name|exe_loop
goto|;
block|}
block|}
break|break;
case|case
literal|'w'
case|:
name|ck_fwrite
argument_list|(
name|line
operator|.
name|text
argument_list|,
literal|1
argument_list|,
name|line
operator|.
name|length
argument_list|,
name|cur_cmd
operator|->
name|x
operator|.
name|io_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
block|{
name|struct
name|line
name|tmp
decl_stmt|;
name|tmp
operator|=
name|line
expr_stmt|;
name|line
operator|=
name|hold
expr_stmt|;
name|hold
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|line
operator|.
name|text
operator|)
operator|,
name|e
operator|=
name|p
operator|+
name|line
operator|.
name|length
init|;
name|p
operator|<
name|e
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|cur_cmd
operator|->
name|x
operator|.
name|translate
index|[
operator|*
name|p
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"INTERNAL ERROR: Bad cmd %c"
argument_list|,
name|cur_cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_cycle
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the current line matches the address    pointed to by 'addr'. */
end_comment

begin_function
name|int
name|match_address
parameter_list|(
name|addr
parameter_list|)
name|struct
name|addr
modifier|*
name|addr
decl_stmt|;
block|{
switch|switch
condition|(
name|addr
operator|->
name|addr_type
condition|)
block|{
case|case
name|ADDR_NULL
case|:
return|return
literal|1
return|;
case|case
name|ADDR_NUM
case|:
return|return
operator|(
name|input_line_number
operator|==
name|addr
operator|->
name|addr_number
operator|)
return|;
case|case
name|ADDR_REGEX
case|:
return|return
operator|(
name|re_search
argument_list|(
name|addr
operator|->
name|addr_regex
argument_list|,
name|line
operator|.
name|text
argument_list|,
name|line
operator|.
name|length
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|line
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|(
expr|struct
name|re_registers
operator|*
operator|)
literal|0
argument_list|)
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
return|;
case|case
name|ADDR_LAST
case|:
return|return
operator|(
name|input_EOF
operator|)
condition|?
literal|1
else|:
literal|0
return|;
default|default:
name|panic
argument_list|(
literal|"INTERNAL ERROR: bad address type"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read in the next line of input, and store it in the    pattern space.  Return non-zero if this is the last line of input */
end_comment

begin_function
name|int
name|read_pattern_space
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|p
operator|=
name|line
operator|.
name|text
expr_stmt|;
name|n
operator|=
name|line
operator|.
name|alloc
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|input_file
argument_list|)
condition|)
return|return
literal|0
return|;
name|input_line_number
operator|++
expr_stmt|;
name|replaced
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|line
operator|.
name|text
operator|=
name|ck_realloc
argument_list|(
name|line
operator|.
name|text
argument_list|,
name|line
operator|.
name|alloc
operator|*
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
operator|.
name|text
operator|+
name|line
operator|.
name|alloc
expr_stmt|;
name|n
operator|=
name|line
operator|.
name|alloc
expr_stmt|;
name|line
operator|.
name|alloc
operator|*=
literal|2
expr_stmt|;
block|}
name|ch
operator|=
name|getc
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|line
operator|.
name|alloc
condition|)
return|return
literal|0
return|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|--
name|n
expr_stmt|;
name|line
operator|.
name|length
operator|=
name|line
operator|.
name|alloc
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|last_input_file
condition|)
name|input_EOF
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|--
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|line
operator|.
name|length
operator|=
name|line
operator|.
name|alloc
operator|-
name|n
expr_stmt|;
break|break;
block|}
block|}
name|ch
operator|=
name|getc
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_input_file
condition|)
name|input_EOF
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Inplement the 'N' command, which appends the next line of input to    the pattern space. */
end_comment

begin_function
name|void
name|append_pattern_space
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|p
operator|=
name|line
operator|.
name|text
operator|+
name|line
operator|.
name|length
expr_stmt|;
name|n
operator|=
name|line
operator|.
name|alloc
operator|-
name|line
operator|.
name|length
expr_stmt|;
name|input_line_number
operator|++
expr_stmt|;
name|replaced
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|line
operator|.
name|alloc
condition|)
return|return;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|--
name|n
expr_stmt|;
name|line
operator|.
name|length
operator|=
name|line
operator|.
name|alloc
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|last_input_file
condition|)
name|input_EOF
operator|++
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|--
name|n
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
name|line
operator|.
name|length
operator|=
name|line
operator|.
name|alloc
operator|-
name|n
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|line
operator|.
name|text
operator|=
name|ck_realloc
argument_list|(
name|line
operator|.
name|text
argument_list|,
name|line
operator|.
name|alloc
operator|*
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
operator|.
name|text
operator|+
name|line
operator|.
name|alloc
expr_stmt|;
name|n
operator|=
name|line
operator|.
name|alloc
expr_stmt|;
name|line
operator|.
name|alloc
operator|*=
literal|2
expr_stmt|;
block|}
block|}
name|ch
operator|=
name|getc
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|input_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_input_file
condition|)
name|input_EOF
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the contents of the line 'from' into the line 'to'.    This destroys the old contents of 'to'.  It will still work    if the line 'from' contains nulls. */
end_comment

begin_function
name|void
name|line_copy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|struct
name|line
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|from
operator|->
name|length
operator|>
name|to
operator|->
name|alloc
condition|)
block|{
name|to
operator|->
name|alloc
operator|=
name|from
operator|->
name|length
expr_stmt|;
name|to
operator|->
name|text
operator|=
name|ck_realloc
argument_list|(
name|to
operator|->
name|text
argument_list|,
name|to
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|from
operator|->
name|text
argument_list|,
name|to
operator|->
name|text
argument_list|,
name|from
operator|->
name|length
argument_list|)
expr_stmt|;
name|to
operator|->
name|length
operator|=
name|from
operator|->
name|length
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Append the contents of the line 'from' to the line 'to'.    This routine will work even if the line 'from' contains nulls */
end_comment

begin_function
name|void
name|line_append
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|struct
name|line
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|from
operator|->
name|length
operator|>
operator|(
name|to
operator|->
name|alloc
operator|-
name|to
operator|->
name|length
operator|)
condition|)
block|{
name|to
operator|->
name|alloc
operator|+=
name|from
operator|->
name|length
expr_stmt|;
name|to
operator|->
name|text
operator|=
name|ck_realloc
argument_list|(
name|to
operator|->
name|text
argument_list|,
name|to
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|from
operator|->
name|text
argument_list|,
name|to
operator|->
name|text
operator|+
name|to
operator|->
name|length
argument_list|,
name|from
operator|->
name|length
argument_list|)
expr_stmt|;
name|to
operator|->
name|length
operator|+=
name|from
operator|->
name|length
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Append 'length' bytes from 'string' to the line 'to'    This routine *will* append bytes with nulls in them, without    failing. */
end_comment

begin_function
name|void
name|str_append
parameter_list|(
name|to
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|)
name|struct
name|line
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
if|if
condition|(
name|length
operator|>
name|to
operator|->
name|alloc
operator|-
name|to
operator|->
name|length
condition|)
block|{
name|to
operator|->
name|alloc
operator|+=
name|length
expr_stmt|;
name|to
operator|->
name|text
operator|=
name|ck_realloc
argument_list|(
name|to
operator|->
name|text
argument_list|,
name|to
operator|->
name|alloc
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|string
argument_list|,
name|to
operator|->
name|text
operator|+
name|to
operator|->
name|length
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|to
operator|->
name|length
operator|+=
name|length
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-nV] [+quiet] [+silent] [+version] [-e script] [-f script-file]\n\        [+expression=script] [+file=script-file] [file...]\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

