begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	SC	A Spreadsheet Calculator  *		Expression interpreter and assorted support routines.  *  *		original by James Gosling, September 1982  *		modified by Mark Weiser and Bruce Israel,   *			University of Maryland  *  *              More mods Robert Bond, 12/86  *		More mods by Alan Silverstein, 3-4/88, see list of changes.  *		$Revision: 6.8 $  */
end_comment

begin_define
define|#
directive|define
name|DEBUGDTS
value|1
end_define

begin_comment
comment|/* REMOVE ME */
end_comment

begin_comment
comment|/* #define EXPRTREE	/* expr. dependency tree stuff, not ready yet */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|aiws
end_ifdef

begin_undef
undef|#
directive|undef
name|_C_func
end_undef

begin_comment
comment|/* Fixes for undefined symbols on AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_MATH
end_ifdef

begin_include
include|#
directive|include
file|<ieeefp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE_MATH */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set by math functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYSIII
end_ifndef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD43
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|re_comp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV3
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|regcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|regex
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGVOID
end_ifdef

begin_function_decl
name|void
name|quit
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|int
name|quit
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use this structure to save the the last 'g' command */
end_comment

begin_struct
struct|struct
name|go_save
block|{
name|int
name|g_type
decl_stmt|;
name|double
name|g_n
decl_stmt|;
name|char
modifier|*
name|g_s
decl_stmt|;
name|int
name|g_row
decl_stmt|;
name|int
name|g_col
decl_stmt|;
block|}
name|gs
struct|;
end_struct

begin_comment
comment|/* g_type can be: */
end_comment

begin_define
define|#
directive|define
name|G_NONE
value|0
end_define

begin_comment
comment|/* Starting value - must be 0*/
end_comment

begin_define
define|#
directive|define
name|G_NUM
value|1
end_define

begin_define
define|#
directive|define
name|G_STR
value|2
end_define

begin_define
define|#
directive|define
name|G_CELL
value|3
end_define

begin_define
define|#
directive|define
name|ISVALID
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
value|((r)>=0&& (r)<maxrows&& (c)>=0&& (c)<maxcols)
end_define

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|jmp_buf
name|fpe_save
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exprerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by eval() and seval() if expression errors */
end_comment

begin_decl_stmt
name|double
name|prescale
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prescale for constants in let() */
end_comment

begin_decl_stmt
name|int
name|extfunc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable/disable external functions */
end_comment

begin_decl_stmt
name|int
name|loading
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set when readfile() is active */
end_comment

begin_function_decl
name|double
name|fn1_eval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|double
name|fn2_eval
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|ent
modifier|*
name|firstev
init|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first expr in the eval list */
end_comment

begin_define
define|#
directive|define
name|PI
value|(double)3.14159265358979323846
end_define

begin_define
define|#
directive|define
name|dtr
parameter_list|(
name|x
parameter_list|)
value|((x)*(PI/(double)180.0))
end_define

begin_define
define|#
directive|define
name|rtd
parameter_list|(
name|x
parameter_list|)
value|((x)*(180.0/(double)PI))
end_define

begin_function
name|double
name|finfunc
parameter_list|(
name|fun
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|)
name|int
name|fun
decl_stmt|;
name|double
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|;
block|{
name|double
name|answer
decl_stmt|,
name|p
decl_stmt|;
name|p
operator|=
name|fn2_eval
argument_list|(
name|pow
argument_list|,
literal|1
operator|+
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fun
condition|)
block|{
case|case
name|PV
case|:
name|answer
operator|=
name|v1
operator|*
operator|(
literal|1
operator|-
literal|1
operator|/
name|p
operator|)
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|FV
case|:
name|answer
operator|=
name|v1
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|/
name|v2
expr_stmt|;
break|break;
case|case
name|PMT
case|:
name|answer
operator|=
name|v1
operator|*
name|v2
operator|/
operator|(
literal|1
operator|-
literal|1
operator|/
name|p
operator|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Unknown function in finfunc"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dostindex
parameter_list|(
name|val
parameter_list|,
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|double
name|val
decl_stmt|;
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|pr
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
name|r
operator|=
name|minr
expr_stmt|;
name|c
operator|=
name|minc
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|minr
operator|==
name|maxr
condition|)
block|{
comment|/* look along the row */
name|c
operator|=
name|minc
operator|+
name|x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|maxc
operator|&&
name|c
operator|>=
name|minc
condition|)
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minc
operator|==
name|maxc
condition|)
block|{
comment|/* look down the column */
name|r
operator|=
name|minr
operator|+
name|x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|<=
name|maxr
operator|&&
name|r
operator|>=
name|minr
condition|)
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"range specified to @stindex"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|label
condition|)
block|{
name|pr
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|p
operator|->
name|label
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pr
argument_list|,
name|p
operator|->
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|pr
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|double
name|doindex
parameter_list|(
name|val
parameter_list|,
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|double
name|val
decl_stmt|;
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|v
decl_stmt|;
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
name|v
operator|=
operator|(
name|double
operator|)
literal|0
expr_stmt|;
name|r
operator|=
name|minr
expr_stmt|;
name|c
operator|=
name|minc
expr_stmt|;
if|if
condition|(
name|minr
operator|==
name|maxr
condition|)
block|{
comment|/* look along the row */
name|c
operator|=
name|minc
operator|+
name|x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|maxc
operator|&&
name|c
operator|>=
name|minc
operator|&&
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
return|return
name|p
operator|->
name|v
return|;
block|}
elseif|else
if|if
condition|(
name|minc
operator|==
name|maxc
condition|)
block|{
comment|/* look down the column */
name|r
operator|=
name|minr
operator|+
name|x
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|<=
name|maxr
operator|&&
name|r
operator|>=
name|minr
operator|&&
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
return|return
name|p
operator|->
name|v
return|;
block|}
else|else
name|error
argument_list|(
literal|" range specified to @index"
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|double
name|dolookup
parameter_list|(
name|val
parameter_list|,
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|,
name|offr
parameter_list|,
name|offc
parameter_list|)
name|struct
name|enode
modifier|*
name|val
decl_stmt|;
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|,
name|offr
decl_stmt|,
name|offc
decl_stmt|;
block|{
name|double
name|v
decl_stmt|,
name|ret
init|=
operator|(
name|double
operator|)
literal|0
decl_stmt|;
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
init|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|incr
decl_stmt|,
name|incc
decl_stmt|,
name|fndr
decl_stmt|,
name|fndc
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|incr
operator|=
operator|(
name|offc
operator|!=
literal|0
operator|)
expr_stmt|;
name|incc
operator|=
operator|(
name|offr
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|etype
argument_list|(
name|val
argument_list|)
operator|==
name|NUM
condition|)
block|{
name|v
operator|=
name|eval
argument_list|(
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
operator|,
name|c
operator|=
name|minc
init|;
name|r
operator|<=
name|maxr
operator|&&
name|c
operator|<=
name|maxc
condition|;
name|r
operator|+=
name|incr
operator|,
name|c
operator|+=
name|incc
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|v
operator|<=
name|v
condition|)
block|{
name|fndr
operator|=
name|incc
condition|?
operator|(
name|minr
operator|+
name|offr
operator|)
else|:
name|r
expr_stmt|;
name|fndc
operator|=
name|incr
condition|?
operator|(
name|minc
operator|+
name|offc
operator|)
else|:
name|c
expr_stmt|;
if|if
condition|(
name|ISVALID
argument_list|(
name|fndr
argument_list|,
name|fndc
argument_list|)
condition|)
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|fndr
argument_list|,
name|fndc
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|" range specified to @[hv]lookup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
name|ret
operator|=
name|p
operator|->
name|v
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
block|}
else|else
block|{
name|s
operator|=
name|seval
argument_list|(
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
operator|,
name|c
operator|=
name|minc
init|;
name|r
operator|<=
name|maxr
operator|&&
name|c
operator|<=
name|maxc
condition|;
name|r
operator|+=
name|incr
operator|,
name|c
operator|+=
name|incc
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|label
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|label
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fndr
operator|=
name|incc
condition|?
operator|(
name|minr
operator|+
name|offr
operator|)
else|:
name|r
expr_stmt|;
name|fndc
operator|=
name|incr
condition|?
operator|(
name|minc
operator|+
name|offc
operator|)
else|:
name|c
expr_stmt|;
if|if
condition|(
name|ISVALID
argument_list|(
name|fndr
argument_list|,
name|fndc
argument_list|)
condition|)
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|fndr
argument_list|,
name|fndc
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|" range specified to @[hv]lookup"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
name|ret
operator|=
name|p
operator|->
name|v
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|double
name|docount
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
name|v
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|double
name|dosum
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|v
decl_stmt|;
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|v
operator|=
operator|(
name|double
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
name|v
operator|+=
name|p
operator|->
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|double
name|doprod
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|v
decl_stmt|;
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|v
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
name|v
operator|*=
name|p
operator|->
name|v
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|double
name|doavg
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|v
decl_stmt|;
specifier|register
name|r
operator|,
name|c
operator|,
name|count
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|v
operator|=
operator|(
name|double
operator|)
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
name|v
operator|+=
name|p
operator|->
name|v
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
return|return
operator|(
name|v
operator|/
operator|(
name|double
operator|)
name|count
operator|)
return|;
block|}
end_function

begin_function
name|double
name|dostddev
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|lp
decl_stmt|,
name|rp
decl_stmt|,
name|v
decl_stmt|,
name|nd
decl_stmt|;
specifier|register
name|r
operator|,
name|c
operator|,
name|n
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
literal|0
expr_stmt|;
name|rp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
name|v
operator|=
name|p
operator|->
name|v
expr_stmt|;
name|lp
operator|+=
name|v
operator|*
name|v
expr_stmt|;
name|rp
operator|+=
name|v
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|||
operator|(
name|n
operator|==
literal|1
operator|)
condition|)
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
name|nd
operator|=
operator|(
name|double
operator|)
name|n
expr_stmt|;
return|return
operator|(
name|sqrt
argument_list|(
operator|(
name|nd
operator|*
name|lp
operator|-
name|rp
operator|*
name|rp
operator|)
operator|/
operator|(
name|nd
operator|*
operator|(
name|nd
operator|-
literal|1
operator|)
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|double
name|domax
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|v
init|=
operator|(
name|double
operator|)
literal|0
decl_stmt|;
specifier|register
name|r
operator|,
name|c
operator|,
name|count
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|v
operator|=
name|p
operator|->
name|v
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|v
operator|>
name|v
condition|)
name|v
operator|=
name|p
operator|->
name|v
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|double
name|domin
parameter_list|(
name|minr
parameter_list|,
name|minc
parameter_list|,
name|maxr
parameter_list|,
name|maxc
parameter_list|)
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|,
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
block|{
name|double
name|v
init|=
operator|(
name|double
operator|)
literal|0
decl_stmt|;
specifier|register
name|r
operator|,
name|c
operator|,
name|count
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
name|p
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|v
operator|=
name|p
operator|->
name|v
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|v
operator|<
name|v
condition|)
name|v
operator|=
name|p
operator|->
name|v
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|sec_min
value|60
end_define

begin_define
define|#
directive|define
name|sec_hr
value|3600L
end_define

begin_define
define|#
directive|define
name|sec_day
value|86400L
end_define

begin_define
define|#
directive|define
name|sec_yr
value|31471200L
end_define

begin_comment
comment|/* 364.25 days/yr */
end_comment

begin_define
define|#
directive|define
name|sec_mo
value|2622600L
end_define

begin_comment
comment|/* sec_yr/12: sort of an average */
end_comment

begin_decl_stmt
name|int
name|mdays
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|dodts
parameter_list|(
name|mo
parameter_list|,
name|day
parameter_list|,
name|yr
parameter_list|)
name|int
name|mo
decl_stmt|,
name|day
decl_stmt|,
name|yr
decl_stmt|;
block|{
name|long
name|trial
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|jdate
decl_stmt|;
name|mdays
index|[
literal|1
index|]
operator|=
literal|28
operator|+
operator|(
name|yr
operator|%
literal|4
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|mo
operator|<
literal|1
operator|||
name|mo
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
operator|||
name|day
operator|>
name|mdays
index|[
operator|--
name|mo
index|]
operator|||
name|yr
operator|>
literal|1999
operator|||
name|yr
operator|<
literal|1970
condition|)
block|{
name|error
argument_list|(
literal|"@dts: invalid argument"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0.0
operator|)
return|;
block|}
name|jdate
operator|=
name|day
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mo
condition|;
name|i
operator|++
control|)
name|jdate
operator|+=
name|mdays
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1970
init|;
name|i
operator|<
name|yr
condition|;
name|i
operator|++
control|)
name|jdate
operator|+=
literal|365
operator|+
operator|(
name|i
operator|%
literal|4
operator|==
literal|0
operator|)
expr_stmt|;
name|trial
operator|=
name|jdate
operator|*
name|sec_day
expr_stmt|;
name|yr
operator|-=
literal|1900
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tm_year
operator|!=
name|yr
condition|)
block|{
comment|/* 	    * We may fail this test once a year because of time zone 	     * and daylight savings time errors.  This bounces the 	     * trial time past the boundary.  The error introduced is 	     * corrected below. 	     */
name|trial
operator|+=
name|sec_day
operator|*
operator|(
name|yr
operator|-
name|tp
operator|->
name|tm_year
operator|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|trial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|tm_mon
operator|!=
name|mo
condition|)
block|{
comment|/* We may fail this test once a month.  */
name|trial
operator|+=
name|sec_day
operator|*
operator|(
name|mo
operator|-
name|tp
operator|->
name|tm_mon
operator|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|trial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|tm_mday
operator|+
name|tp
operator|->
name|tm_hour
operator|+
name|tp
operator|->
name|tm_min
operator|+
name|tp
operator|->
name|tm_sec
operator|!=
name|day
condition|)
block|{
name|trial
operator|-=
operator|(
name|tp
operator|->
name|tm_mday
operator|-
name|day
operator|)
operator|*
name|sec_day
operator|+
name|tp
operator|->
name|tm_hour
operator|*
name|sec_hr
operator|+
name|tp
operator|->
name|tm_min
operator|*
name|sec_min
operator|+
name|tp
operator|->
name|tm_sec
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGDTS
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tm_mday
operator|+
name|tp
operator|->
name|tm_hour
operator|+
name|tp
operator|->
name|tm_min
operator|+
name|tp
operator|->
name|tm_sec
operator|+
name|tp
operator|->
name|tm_year
operator|+
name|tp
operator|->
name|tm_mon
operator|!=
name|yr
operator|+
name|mo
operator|+
name|day
condition|)
name|error
argument_list|(
literal|"Dts broke down"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|double
operator|)
name|trial
operator|)
return|;
block|}
end_function

begin_function
name|double
name|dotts
parameter_list|(
name|hr
parameter_list|,
name|min
parameter_list|,
name|sec
parameter_list|)
name|int
name|hr
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
block|{
if|if
condition|(
name|hr
operator|<
literal|0
operator|||
name|hr
operator|>
literal|23
operator|||
name|min
operator|<
literal|0
operator|||
name|min
operator|>
literal|59
operator|||
name|sec
operator|<
literal|0
operator|||
name|sec
operator|>
literal|59
condition|)
block|{
name|error
argument_list|(
literal|"@tts: Invalid argument"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
block|}
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|sec
operator|+
name|min
operator|*
literal|60
operator|+
name|hr
operator|*
literal|3600
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|double
name|dotime
parameter_list|(
name|which
parameter_list|,
name|when
parameter_list|)
name|int
name|which
decl_stmt|;
name|double
name|when
decl_stmt|;
block|{
name|long
name|time
parameter_list|()
function_decl|;
specifier|static
name|long
name|t_cache
decl_stmt|;
specifier|static
name|struct
name|tm
name|tm_cache
decl_stmt|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
name|long
name|tloc
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|NOW
condition|)
return|return
operator|(
name|double
operator|)
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
return|;
name|tloc
operator|=
operator|(
name|long
operator|)
name|when
expr_stmt|;
if|if
condition|(
name|tloc
operator|!=
name|t_cache
condition|)
block|{
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|tloc
argument_list|)
expr_stmt|;
name|tm_cache
operator|=
operator|*
name|tp
expr_stmt|;
name|tm_cache
operator|.
name|tm_mon
operator|+=
literal|1
expr_stmt|;
name|tm_cache
operator|.
name|tm_year
operator|+=
literal|1900
expr_stmt|;
name|t_cache
operator|=
name|tloc
expr_stmt|;
block|}
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|HOUR
case|:
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|tm_cache
operator|.
name|tm_hour
argument_list|)
operator|)
return|;
case|case
name|MINUTE
case|:
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|tm_cache
operator|.
name|tm_min
argument_list|)
operator|)
return|;
case|case
name|SECOND
case|:
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|tm_cache
operator|.
name|tm_sec
argument_list|)
operator|)
return|;
case|case
name|MONTH
case|:
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|tm_cache
operator|.
name|tm_mon
argument_list|)
operator|)
return|;
case|case
name|DAY
case|:
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|tm_cache
operator|.
name|tm_mday
argument_list|)
operator|)
return|;
case|case
name|YEAR
case|:
return|return
operator|(
call|(
name|double
call|)
argument_list|(
name|tm_cache
operator|.
name|tm_year
argument_list|)
operator|)
return|;
block|}
comment|/* Safety net */
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|double
name|doston
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|strtof
parameter_list|()
function_decl|;
name|double
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
operator|(
operator|(
name|double
operator|)
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strtof
argument_list|(
name|s
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|double
name|doeqs
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
name|double
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|s1
operator|&&
operator|!
name|s2
condition|)
return|return
operator|(
operator|(
name|double
operator|)
literal|1.0
operator|)
return|;
if|if
condition|(
operator|!
name|s1
operator|||
operator|!
name|s2
condition|)
name|v
operator|=
literal|0.0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
operator|==
literal|0
condition|)
name|v
operator|=
literal|1.0
expr_stmt|;
else|else
name|v
operator|=
literal|0.0
expr_stmt|;
if|if
condition|(
name|s1
condition|)
name|xfree
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
condition|)
name|xfree
argument_list|(
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Given a string representing a column name and a value which is a column  * number, return a pointer to the selected cell's entry, if any, else 0.  Use  * only the integer part of the column number.  Always free the string.  */
end_comment

begin_function
name|struct
name|ent
modifier|*
name|getent
parameter_list|(
name|colstr
parameter_list|,
name|rowdoub
parameter_list|)
name|char
modifier|*
name|colstr
decl_stmt|;
name|double
name|rowdoub
decl_stmt|;
block|{
name|int
name|collen
decl_stmt|;
comment|/* length of string */
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
comment|/* integer values   */
name|struct
name|ent
modifier|*
name|ep
init|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* selected entry   */
if|if
condition|(
operator|(
operator|(
name|row
operator|=
operator|(
name|int
operator|)
name|floor
argument_list|(
name|rowdoub
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|row
operator|<
name|maxrows
operator|)
comment|/* in range */
operator|&&
operator|(
operator|(
name|collen
operator|=
name|strlen
argument_list|(
name|colstr
argument_list|)
operator|)
operator|<=
literal|2
operator|)
comment|/* not too long */
operator|&&
operator|(
operator|(
name|col
operator|=
name|atocol
argument_list|(
name|colstr
argument_list|,
name|collen
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|col
operator|<
name|maxcols
operator|)
condition|)
comment|/* in range */
block|{
name|ep
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|colstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a string representing a column name and a value which is a column  * number, return the selected cell's numeric value, if any.  */
end_comment

begin_function
name|double
name|donval
parameter_list|(
name|colstr
parameter_list|,
name|rowdoub
parameter_list|)
name|char
modifier|*
name|colstr
decl_stmt|;
name|double
name|rowdoub
decl_stmt|;
block|{
name|struct
name|ent
modifier|*
name|ep
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|ep
operator|=
name|getent
argument_list|(
name|colstr
argument_list|,
name|rowdoub
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|ep
operator|->
name|flags
operator|)
operator|&
name|is_valid
operator|)
operator|)
condition|?
operator|(
name|ep
operator|->
name|v
operator|)
else|:
operator|(
name|double
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	The list routines (e.g. dolmax) are called with an LMAX enode.  *	The left pointer is a chain of ELIST nodes, the right pointer  *	is a value.  */
end_comment

begin_function
name|double
name|dolmax
parameter_list|(
name|ep
parameter_list|)
name|struct
name|enode
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|double
name|maxval
init|=
literal|0
decl_stmt|;
comment|/* Assignment to shut up lint */
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
specifier|register
name|double
name|v
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ep
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|left
control|)
block|{
name|v
operator|=
name|eval
argument_list|(
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
operator|||
name|v
operator|>
name|maxval
condition|)
block|{
name|maxval
operator|=
name|v
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
return|return
name|maxval
return|;
else|else
return|return
operator|(
name|double
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|double
name|dolmin
parameter_list|(
name|ep
parameter_list|)
name|struct
name|enode
modifier|*
name|ep
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|double
name|minval
init|=
literal|0
decl_stmt|;
comment|/* Assignment to shut up lint */
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
specifier|register
name|double
name|v
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ep
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|left
control|)
block|{
name|v
operator|=
name|eval
argument_list|(
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
operator|||
name|v
operator|<
name|minval
condition|)
block|{
name|minval
operator|=
name|v
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
return|return
name|minval
return|;
else|else
return|return
operator|(
name|double
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|double
name|eval
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
operator|==
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|double
operator|)
literal|0
return|;
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
case|case
literal|'+'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|+
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'-'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|-
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'*'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|*
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'/'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|/
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'%'
case|:
block|{
name|double
name|num
decl_stmt|,
name|denom
decl_stmt|;
name|num
operator|=
name|floor
argument_list|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|)
expr_stmt|;
name|denom
operator|=
name|floor
argument_list|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|denom
condition|?
name|num
operator|-
name|floor
argument_list|(
name|num
operator|/
name|denom
argument_list|)
operator|*
name|denom
else|:
operator|(
name|double
operator|)
literal|0
return|;
block|}
case|case
literal|'^'
case|:
return|return
operator|(
name|fn2_eval
argument_list|(
name|pow
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'<'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|<
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'='
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|==
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'>'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|>
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'&'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|&&
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'|'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|||
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|IF
case|:
case|case
literal|'?'
case|:
return|return
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
condition|?
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
else|:
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
return|;
case|case
literal|'m'
case|:
return|return
operator|(
operator|-
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
literal|'~'
case|:
return|return
operator|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|==
literal|0.0
operator|)
return|;
case|case
literal|'k'
case|:
return|return
operator|(
name|e
operator|->
name|e
operator|.
name|k
operator|)
return|;
case|case
literal|'v'
case|:
return|return
operator|(
name|e
operator|->
name|e
operator|.
name|v
operator|.
name|vp
operator|->
name|v
operator|)
return|;
case|case
name|INDEX
case|:
case|case
name|LOOKUP
case|:
case|case
name|HLOOKUP
case|:
case|case
name|VLOOKUP
case|:
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|maxr
operator|,
name|maxc
expr_stmt|;
specifier|register
name|minr
operator|,
name|minc
expr_stmt|;
name|maxr
operator|=
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|row
expr_stmt|;
name|maxc
operator|=
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|col
expr_stmt|;
name|minr
operator|=
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|row
expr_stmt|;
name|minc
operator|=
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|minr
operator|>
name|maxr
condition|)
name|r
operator|=
name|maxr
operator|,
name|maxr
operator|=
name|minr
operator|,
name|minr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|minc
operator|>
name|maxc
condition|)
name|c
operator|=
name|maxc
operator|,
name|maxc
operator|=
name|minc
operator|,
name|minc
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
case|case
name|LOOKUP
case|:
return|return
name|dolookup
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|,
name|minr
operator|==
name|maxr
argument_list|,
name|minc
operator|==
name|maxc
argument_list|)
return|;
case|case
name|HLOOKUP
case|:
return|return
name|dolookup
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|VLOOKUP
case|:
return|return
name|dolookup
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
return|;
case|case
name|INDEX
case|:
return|return
name|doindex
argument_list|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
block|}
block|}
case|case
name|REDUCE
operator||
literal|'+'
case|:
case|case
name|REDUCE
operator||
literal|'*'
case|:
case|case
name|REDUCE
operator||
literal|'a'
case|:
case|case
name|REDUCE
operator||
literal|'c'
case|:
case|case
name|REDUCE
operator||
literal|'s'
case|:
case|case
name|REDUCE
operator||
name|MAX
case|:
case|case
name|REDUCE
operator||
name|MIN
case|:
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|maxr
operator|,
name|maxc
expr_stmt|;
specifier|register
name|minr
operator|,
name|minc
expr_stmt|;
name|maxr
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|row
expr_stmt|;
name|maxc
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|col
expr_stmt|;
name|minr
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|row
expr_stmt|;
name|minc
operator|=
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|minr
operator|>
name|maxr
condition|)
name|r
operator|=
name|maxr
operator|,
name|maxr
operator|=
name|minr
operator|,
name|minr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|minc
operator|>
name|maxc
condition|)
name|c
operator|=
name|maxc
operator|,
name|maxc
operator|=
name|minc
operator|,
name|minc
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
case|case
name|REDUCE
operator||
literal|'+'
case|:
return|return
name|dosum
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
case|case
name|REDUCE
operator||
literal|'*'
case|:
return|return
name|doprod
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
case|case
name|REDUCE
operator||
literal|'a'
case|:
return|return
name|doavg
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
case|case
name|REDUCE
operator||
literal|'c'
case|:
return|return
name|docount
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
case|case
name|REDUCE
operator||
literal|'s'
case|:
return|return
name|dostddev
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
case|case
name|REDUCE
operator||
name|MAX
case|:
return|return
name|domax
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
case|case
name|REDUCE
operator||
name|MIN
case|:
return|return
name|domin
argument_list|(
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
block|}
block|}
case|case
name|ABS
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|fabs
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ACOS
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|acos
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ASIN
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|asin
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ATAN
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|atan
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|ATAN2
case|:
return|return
operator|(
name|fn2_eval
argument_list|(
name|atan2
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CEIL
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|ceil
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|COS
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|cos
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|EXP
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|exp
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|FABS
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|fabs
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|FLOOR
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|floor
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|HYPOT
case|:
return|return
operator|(
name|fn2_eval
argument_list|(
name|hypot
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|LOG
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|log
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|LOG10
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|log10
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|POW
case|:
return|return
operator|(
name|fn2_eval
argument_list|(
name|pow
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SIN
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|sin
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SQRT
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|sqrt
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|TAN
case|:
return|return
operator|(
name|fn1_eval
argument_list|(
name|tan
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|DTR
case|:
return|return
operator|(
name|dtr
argument_list|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|RTD
case|:
return|return
operator|(
name|rtd
argument_list|(
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|RND
case|:
block|{
name|double
name|temp
decl_stmt|;
name|temp
operator|=
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|-
name|floor
argument_list|(
name|temp
argument_list|)
operator|<
literal|0.5
condition|?
name|floor
argument_list|(
name|temp
argument_list|)
else|:
name|ceil
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
case|case
name|ROUND
case|:
block|{
name|double
name|temp
init|=
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
decl_stmt|;
name|int
name|prec
init|=
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
decl_stmt|,
name|scal
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|prec
operator|--
operator|>
literal|0
condition|)
name|scal
operator|*=
literal|10
expr_stmt|;
name|temp
operator|*=
name|scal
expr_stmt|;
name|temp
operator|=
operator|(
operator|(
name|temp
operator|-
name|floor
argument_list|(
name|temp
argument_list|)
operator|)
operator|<
literal|0.5
condition|?
name|floor
argument_list|(
name|temp
argument_list|)
else|:
name|ceil
argument_list|(
name|temp
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|temp
operator|/
name|scal
operator|)
return|;
block|}
case|case
name|FV
case|:
case|case
name|PV
case|:
case|case
name|PMT
case|:
return|return
operator|(
name|finfunc
argument_list|(
name|e
operator|->
name|op
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|HOUR
case|:
return|return
operator|(
name|dotime
argument_list|(
name|HOUR
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MINUTE
case|:
return|return
operator|(
name|dotime
argument_list|(
name|MINUTE
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SECOND
case|:
return|return
operator|(
name|dotime
argument_list|(
name|SECOND
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|MONTH
case|:
return|return
operator|(
name|dotime
argument_list|(
name|MONTH
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|DAY
case|:
return|return
operator|(
name|dotime
argument_list|(
name|DAY
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|YEAR
case|:
return|return
operator|(
name|dotime
argument_list|(
name|YEAR
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|NOW
case|:
return|return
operator|(
name|dotime
argument_list|(
name|NOW
argument_list|,
operator|(
name|double
operator|)
literal|0.0
argument_list|)
operator|)
return|;
case|case
name|DTS
case|:
return|return
operator|(
name|dodts
argument_list|(
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|TTS
case|:
return|return
operator|(
name|dotts
argument_list|(
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|STON
case|:
return|return
operator|(
name|doston
argument_list|(
name|seval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|EQS
case|:
return|return
operator|(
name|doeqs
argument_list|(
name|seval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|,
name|seval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|LMAX
case|:
return|return
name|dolmax
argument_list|(
name|e
argument_list|)
return|;
case|case
name|LMIN
case|:
return|return
name|dolmin
argument_list|(
name|e
argument_list|)
return|;
case|case
name|NVAL
case|:
return|return
operator|(
name|donval
argument_list|(
name|seval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"Illegal numeric expression"
argument_list|)
expr_stmt|;
name|exprerr
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|double
operator|)
literal|0.0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SIGVOID
end_ifdef

begin_function
name|void
endif|#
directive|endif
name|eval_fpe
parameter_list|(
name|signo
parameter_list|)
comment|/* Trap for FPE errors in eval */
name|int
name|signo
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IEEE_MATH
operator|(
name|void
operator|)
name|fpsetsticky
argument_list|(
operator|(
name|fp_except
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear exception */
endif|#
directive|endif
comment|/* IEEE_MATH */
name|longjmp
argument_list|(
name|fpe_save
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|double
name|fn1_eval
argument_list|(
name|fn
argument_list|,
name|arg
argument_list|)
name|double
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|res
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|res
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|eval_fpe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_decl_stmt
name|double
name|fn2_eval
argument_list|(
name|fn
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
name|double
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|res
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|res
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|eval_fpe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*   * Rules for string functions:  * Take string arguments which they xfree.  * All returned strings are assumed to be xalloced.  */
end_comment

begin_function
name|char
modifier|*
name|docat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|;
if|if
condition|(
operator|!
name|s1
operator|&&
operator|!
name|s2
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
name|arg1
operator|=
name|s1
condition|?
name|s1
else|:
literal|""
expr_stmt|;
name|arg2
operator|=
name|s2
condition|?
name|s2
else|:
literal|""
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|arg1
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg2
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|p
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
condition|)
name|xfree
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
condition|)
name|xfree
argument_list|(
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|dodate
parameter_list|(
name|tloc
parameter_list|)
name|long
name|tloc
decl_stmt|;
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|tp
operator|=
name|ctime
argument_list|(
operator|&
name|tloc
argument_list|)
expr_stmt|;
name|tp
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|25
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|dofmt
parameter_list|(
name|fmtstr
parameter_list|,
name|v
parameter_list|)
name|char
modifier|*
name|fmtstr
decl_stmt|;
name|double
name|v
decl_stmt|;
block|{
name|char
name|buff
index|[
name|FBUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|fmtstr
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|fmtstr
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|buff
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fmtstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a command name and a value, run the command with the given value and  * read and return its first output line (only) as an allocated string, always  * a copy of prevstr, which is set appropriately first unless external  * functions are disabled, in which case the previous value is used.  The  * handling of prevstr and freeing of command is tricky.  Returning an  * allocated string in all cases, even if null, insures cell expressions are  * written to files, etc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_function
name|char
modifier|*
name|doext
parameter_list|(
name|command
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|double
name|value
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Warning: External functions unavailable on VMS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
condition|)
name|xfree
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
argument_list|,
literal|"\0"
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS */
end_comment

begin_function
name|char
modifier|*
name|doext
parameter_list|(
name|command
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|double
name|value
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|prevstr
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* previous result */
name|char
name|buff
index|[
name|FBUFLEN
index|]
decl_stmt|;
comment|/* command line/return, not permanently alloc */
if|if
condition|(
operator|!
name|prevstr
condition|)
block|{
name|prevstr
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
operator|*
name|prevstr
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extfunc
condition|)
block|{
name|error
argument_list|(
literal|"Warning: external functions disabled; using %s value"
argument_list|,
name|prevstr
condition|?
literal|"previous"
else|:
literal|"null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
condition|)
name|xfree
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prevstr
condition|)
name|xfree
argument_list|(
name|prevstr
argument_list|)
expr_stmt|;
comment|/* no longer needed */
name|prevstr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|command
operator|)
operator|||
operator|(
operator|!
operator|*
name|command
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Warning: external function given null command name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
condition|)
name|xfree
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE
modifier|*
name|pp
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s %g"
argument_list|,
name|command
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* build cmd line */
name|xfree
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Running external function..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|popen
argument_list|(
name|buff
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
comment|/* run it */
name|error
argument_list|(
literal|"Warning: running \"%s\" failed"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
argument_list|,
name|pp
argument_list|)
operator|==
name|NULL
condition|)
comment|/* one line */
name|error
argument_list|(
literal|"Warning: external function returned nothing"
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|error
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* erase notice */
name|buff
index|[
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
condition|)
comment|/* contains newline */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* end string there */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prevstr
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|buff
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|buff
argument_list|)
expr_stmt|;
comment|/* save alloc'd copy */
block|}
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
comment|/* else */
block|}
comment|/* else */
block|}
comment|/* else */
return|return
operator|(
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|prevstr
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|prevstr
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_comment
comment|/*  * Given a string representing a column name and a value which is a column  * number, return the selected cell's string value, if any.  Even if none,  * still allocate and return a null string so the cell has a label value so  * the expression is saved in a file, etc.  */
end_comment

begin_function
name|char
modifier|*
name|dosval
parameter_list|(
name|colstr
parameter_list|,
name|rowdoub
parameter_list|)
name|char
modifier|*
name|colstr
decl_stmt|;
name|double
name|rowdoub
decl_stmt|;
block|{
name|struct
name|ent
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|label
operator|=
operator|(
name|ep
operator|=
name|getent
argument_list|(
name|colstr
argument_list|,
name|rowdoub
argument_list|)
operator|)
condition|?
operator|(
name|ep
operator|->
name|label
operator|)
else|:
literal|""
expr_stmt|;
return|return
operator|(
name|strcpy
argument_list|(
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|label
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|label
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Substring:  Note that v1 and v2 are one-based to users, but zero-based  * when calling this routine.  */
end_comment

begin_function
name|char
modifier|*
name|dosubstr
parameter_list|(
name|s
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|v1
decl_stmt|,
name|v2
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
if|if
condition|(
name|v2
operator|>=
name|strlen
argument_list|(
name|s
argument_list|)
condition|)
comment|/* past end */
name|v2
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* to end   */
if|if
condition|(
name|v1
operator|<
literal|0
operator|||
name|v1
operator|>
name|v2
condition|)
block|{
comment|/* out of range, return null string */
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|s2
operator|=
name|p
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|v2
operator|-
name|v1
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|s1
operator|=
operator|&
name|s
index|[
name|v1
index|]
expr_stmt|;
for|for
control|(
init|;
name|v1
operator|<=
name|v2
condition|;
name|s1
operator|++
operator|,
name|s2
operator|++
operator|,
name|v1
operator|++
control|)
operator|*
name|s2
operator|=
operator|*
name|s1
expr_stmt|;
operator|*
name|s2
operator|=
literal|'\0'
expr_stmt|;
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|seval
parameter_list|(
name|se
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|se
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|se
operator|==
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
switch|switch
condition|(
name|se
operator|->
name|op
condition|)
block|{
case|case
name|O_SCONST
case|:
name|p
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|se
operator|->
name|e
operator|.
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|se
operator|->
name|e
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
case|case
name|O_VAR
case|:
block|{
name|struct
name|ent
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|se
operator|->
name|e
operator|.
name|v
operator|.
name|vp
expr_stmt|;
if|if
condition|(
operator|!
name|ep
operator|->
name|label
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
name|p
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|ep
operator|->
name|label
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|ep
operator|->
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
case|case
literal|'#'
case|:
return|return
operator|(
name|docat
argument_list|(
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|IF
case|:
case|case
literal|'?'
case|:
return|return
operator|(
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
condition|?
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
else|:
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|)
return|;
case|case
name|DATE
case|:
return|return
operator|(
name|dodate
argument_list|(
call|(
name|long
call|)
argument_list|(
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|FMT
case|:
return|return
operator|(
name|dofmt
argument_list|(
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|STINDEX
case|:
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|maxr
operator|,
name|maxc
expr_stmt|;
specifier|register
name|minr
operator|,
name|minc
expr_stmt|;
name|maxr
operator|=
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|row
expr_stmt|;
name|maxc
operator|=
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
operator|->
name|col
expr_stmt|;
name|minr
operator|=
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|row
expr_stmt|;
name|minc
operator|=
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|minr
operator|>
name|maxr
condition|)
name|r
operator|=
name|maxr
operator|,
name|maxr
operator|=
name|minr
operator|,
name|minr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|minc
operator|>
name|maxc
condition|)
name|c
operator|=
name|maxc
operator|,
name|maxc
operator|=
name|minc
operator|,
name|minc
operator|=
name|c
expr_stmt|;
return|return
name|dostindex
argument_list|(
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|minr
argument_list|,
name|minc
argument_list|,
name|maxr
argument_list|,
name|maxc
argument_list|)
return|;
block|}
case|case
name|EXT
case|:
return|return
operator|(
name|doext
argument_list|(
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SVAL
case|:
return|return
operator|(
name|dosval
argument_list|(
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|SUBSTR
case|:
return|return
operator|(
name|dosubstr
argument_list|(
name|seval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|eval
argument_list|(
name|se
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"Illegal string expression"
argument_list|)
expr_stmt|;
name|exprerr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * The graph formed by cell expressions which use other cells's values is not  * evaluated "bottom up".  The whole table is merely re-evaluated cell by cell,  * top to bottom, left to right, in RealEvalAll().  Each cell's expression uses  * constants in other cells.  However, RealEvalAll() notices when a cell gets a  * new numeric or string value, and reports if this happens for any cell.  * EvalAll() repeats calling RealEvalAll() until there are no changes or the  * evaluation count expires.  */
end_comment

begin_decl_stmt
name|int
name|propagation
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max number of times to try calculation */
end_comment

begin_function
name|void
name|setiterations
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|i
operator|<
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"iteration count must be at least 1"
argument_list|)
expr_stmt|;
name|propagation
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|propagation
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
name|void
name|EvalAll
parameter_list|()
block|{
name|int
name|lastcnt
decl_stmt|,
name|repct
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|lastcnt
operator|=
name|RealEvalAll
argument_list|()
operator|)
operator|&&
operator|(
name|repct
operator|++
operator|<=
name|propagation
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|propagation
operator|>
literal|1
operator|)
operator|&&
operator|(
name|lastcnt
operator|>
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"Still changing after %d iterations"
argument_list|,
name|propagation
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evaluate all cells which have expressions and alter their numeric or string  * values.  Return the number of cells which changed.  */
end_comment

begin_function
name|int
name|RealEvalAll
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|chgct
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|eval_fpe
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPRTREE
for|for
control|(
name|p
operator|=
name|firstev
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|evnext
control|)
name|RealEvalOne
argument_list|(
name|p
argument_list|,
operator|&
name|chgct
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|calc_order
operator|==
name|BYROWS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxrow
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxcol
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|tbl
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|&&
name|p
operator|->
name|expr
condition|)
name|RealEvalOne
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|&
name|chgct
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|calc_order
operator|==
name|BYCOLS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|maxcol
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|maxrow
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|tbl
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|&&
name|p
operator|->
name|expr
condition|)
name|RealEvalOne
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
operator|&
name|chgct
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|"Internal error calc_order"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|quit
argument_list|)
expr_stmt|;
return|return
operator|(
name|chgct
operator|)
return|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|EXPRTREE
name|RealEvalOne
parameter_list|(
name|p
parameter_list|,
name|chgct
parameter_list|)
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|chgct
decl_stmt|;
else|#
directive|else
function|RealEvalOne
parameter_list|(
name|p
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|,
name|chgct
parameter_list|)
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
decl|*
name|chgct
decl_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|is_strexpr
condition|)
block|{
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|fpe_save
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EXPRTREE
name|error
argument_list|(
literal|"Floating point exception %s"
argument_list|,
name|v_name
argument_list|(
name|p
operator|->
name|row
argument_list|,
name|p
operator|->
name|col
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Floating point exception %s"
argument_list|,
name|v_name
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|seval
argument_list|(
name|p
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|v
operator|&&
operator|!
name|p
operator|->
name|label
condition|)
comment|/* Everything's fine */
return|return;
if|if
condition|(
operator|!
name|p
operator|->
name|label
operator|||
operator|!
name|v
operator|||
name|strcmp
argument_list|(
name|v
argument_list|,
name|p
operator|->
name|label
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|chgct
operator|)
operator|++
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|is_changed
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|label
condition|)
name|xfree
argument_list|(
name|p
operator|->
name|label
argument_list|)
expr_stmt|;
name|p
operator|->
name|label
operator|=
name|v
expr_stmt|;
block|}
else|else
block|{
name|double
name|v
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|fpe_save
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EXPRTREE
name|error
argument_list|(
literal|"Floating point exception %s"
argument_list|,
name|v_name
argument_list|(
name|p
operator|->
name|row
argument_list|,
name|p
operator|->
name|col
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"Floating point exception %s"
argument_list|,
name|v_name
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v
operator|=
operator|(
name|double
operator|)
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|eval
argument_list|(
name|p
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|!=
name|p
operator|->
name|v
condition|)
block|{
name|p
operator|->
name|v
operator|=
name|v
expr_stmt|;
operator|(
operator|*
name|chgct
operator|)
operator|++
expr_stmt|;
name|p
operator|->
name|flags
operator||=
name|is_changed
operator||
name|is_valid
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|struct
name|enode
modifier|*
name|new
parameter_list|(
name|op
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
name|int
name|op
decl_stmt|;
name|struct
name|enode
modifier|*
name|a1
decl_stmt|,
decl|*
name|a2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|=
name|a1
expr_stmt|;
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|=
name|a2
expr_stmt|;
return|return
name|p
return|;
block|}
end_block

begin_function
name|struct
name|enode
modifier|*
name|new_var
parameter_list|(
name|op
parameter_list|,
name|a1
parameter_list|)
name|int
name|op
decl_stmt|;
name|struct
name|ent_ptr
name|a1
decl_stmt|;
block|{
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|p
operator|->
name|e
operator|.
name|v
operator|=
name|a1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|enode
modifier|*
name|new_range
parameter_list|(
name|op
parameter_list|,
name|a1
parameter_list|)
name|int
name|op
decl_stmt|;
name|struct
name|range_s
name|a1
decl_stmt|;
block|{
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|p
operator|->
name|e
operator|.
name|r
operator|=
name|a1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|enode
modifier|*
name|new_const
parameter_list|(
name|op
parameter_list|,
name|a1
parameter_list|)
name|int
name|op
decl_stmt|;
name|double
name|a1
decl_stmt|;
block|{
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|p
operator|->
name|e
operator|.
name|k
operator|=
name|a1
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|struct
name|enode
modifier|*
name|new_str
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|enode
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|op
operator|=
name|O_SCONST
expr_stmt|;
name|p
operator|->
name|e
operator|.
name|s
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|void
name|copy
parameter_list|(
name|dv1
parameter_list|,
name|dv2
parameter_list|,
name|v1
parameter_list|,
name|v2
parameter_list|)
name|struct
name|ent
modifier|*
name|dv1
decl_stmt|,
decl|*
name|dv2
decl_stmt|,
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|minsr
decl_stmt|,
name|minsc
decl_stmt|;
name|int
name|maxsr
decl_stmt|,
name|maxsc
decl_stmt|;
name|int
name|mindr
decl_stmt|,
name|mindc
decl_stmt|;
name|int
name|maxdr
decl_stmt|,
name|maxdc
decl_stmt|;
name|int
name|vr
decl_stmt|,
name|vc
decl_stmt|;
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|mindr
operator|=
name|dv1
operator|->
name|row
expr_stmt|;
name|mindc
operator|=
name|dv1
operator|->
name|col
expr_stmt|;
name|maxdr
operator|=
name|dv2
operator|->
name|row
expr_stmt|;
name|maxdc
operator|=
name|dv2
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|mindr
operator|>
name|maxdr
condition|)
name|r
operator|=
name|maxdr
operator|,
name|maxdr
operator|=
name|mindr
operator|,
name|mindr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|mindc
operator|>
name|maxdc
condition|)
name|c
operator|=
name|maxdc
operator|,
name|maxdc
operator|=
name|mindc
operator|,
name|mindc
operator|=
name|c
expr_stmt|;
name|maxsr
operator|=
name|v2
operator|->
name|row
expr_stmt|;
name|maxsc
operator|=
name|v2
operator|->
name|col
expr_stmt|;
name|minsr
operator|=
name|v1
operator|->
name|row
expr_stmt|;
name|minsc
operator|=
name|v1
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|minsr
operator|>
name|maxsr
condition|)
name|r
operator|=
name|maxsr
operator|,
name|maxsr
operator|=
name|minsr
operator|,
name|minsr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|minsc
operator|>
name|maxsc
condition|)
name|c
operator|=
name|maxsc
operator|,
name|maxsc
operator|=
name|minsc
operator|,
name|minsc
operator|=
name|c
expr_stmt|;
name|checkbounds
argument_list|(
operator|&
name|maxdr
argument_list|,
operator|&
name|maxdc
argument_list|)
expr_stmt|;
name|erase_area
argument_list|(
name|mindr
argument_list|,
name|mindc
argument_list|,
name|maxdr
argument_list|,
name|maxdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|minsr
operator|==
name|maxsr
operator|&&
name|minsc
operator|==
name|maxsc
condition|)
block|{
comment|/* Source is a single cell */
for|for
control|(
name|vr
operator|=
name|mindr
init|;
name|vr
operator|<=
name|maxdr
condition|;
name|vr
operator|++
control|)
for|for
control|(
name|vc
operator|=
name|mindc
init|;
name|vc
operator|<=
name|maxdc
condition|;
name|vc
operator|++
control|)
name|copyrtv
argument_list|(
name|vr
argument_list|,
name|vc
argument_list|,
name|minsr
argument_list|,
name|minsc
argument_list|,
name|maxsr
argument_list|,
name|maxsc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minsr
operator|==
name|maxsr
condition|)
block|{
comment|/* Source is a single row */
for|for
control|(
name|vr
operator|=
name|mindr
init|;
name|vr
operator|<=
name|maxdr
condition|;
name|vr
operator|++
control|)
name|copyrtv
argument_list|(
name|vr
argument_list|,
name|mindc
argument_list|,
name|minsr
argument_list|,
name|minsc
argument_list|,
name|maxsr
argument_list|,
name|maxsc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|minsc
operator|==
name|maxsc
condition|)
block|{
comment|/* Source is a single column */
for|for
control|(
name|vc
operator|=
name|mindc
init|;
name|vc
operator|<=
name|maxdc
condition|;
name|vc
operator|++
control|)
name|copyrtv
argument_list|(
name|mindr
argument_list|,
name|vc
argument_list|,
name|minsr
argument_list|,
name|minsc
argument_list|,
name|maxsr
argument_list|,
name|maxsc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Everything else */
name|copyrtv
argument_list|(
name|mindr
argument_list|,
name|mindc
argument_list|,
name|minsr
argument_list|,
name|minsc
argument_list|,
name|maxsr
argument_list|,
name|maxsc
argument_list|)
expr_stmt|;
block|}
name|sync_refs
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|void
name|copyrtv
parameter_list|(
name|vr
parameter_list|,
name|vc
parameter_list|,
name|minsr
parameter_list|,
name|minsc
parameter_list|,
name|maxsr
parameter_list|,
name|maxsc
parameter_list|)
name|int
name|vr
decl_stmt|,
name|vc
decl_stmt|,
name|minsr
decl_stmt|,
name|minsc
decl_stmt|,
name|maxsr
decl_stmt|,
name|maxsc
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|sr
decl_stmt|,
name|sc
decl_stmt|;
specifier|register
name|int
name|dr
decl_stmt|,
name|dc
decl_stmt|;
for|for
control|(
name|dr
operator|=
name|vr
operator|,
name|sr
operator|=
name|minsr
init|;
name|sr
operator|<=
name|maxsr
condition|;
name|sr
operator|++
operator|,
name|dr
operator|++
control|)
for|for
control|(
name|dc
operator|=
name|vc
operator|,
name|sc
operator|=
name|minsc
init|;
name|sc
operator|<=
name|maxsc
condition|;
name|sc
operator|++
operator|,
name|dc
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|sr
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|n
operator|=
name|lookat
argument_list|(
name|dr
argument_list|,
name|dc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|copyent
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|dr
operator|-
name|sr
argument_list|,
name|dc
operator|-
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|dr
argument_list|,
name|dc
argument_list|)
condition|)
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|eraser
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|struct
name|ent
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|FullUpdate
operator|++
expr_stmt|;
name|flush_saved
argument_list|()
expr_stmt|;
name|erase_area
argument_list|(
name|v1
operator|->
name|row
argument_list|,
name|v1
operator|->
name|col
argument_list|,
name|v2
operator|->
name|row
argument_list|,
name|v2
operator|->
name|col
argument_list|)
expr_stmt|;
name|sync_refs
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Goto subroutines */
end_comment

begin_function
name|void
name|g_free
parameter_list|()
block|{
switch|switch
condition|(
name|gs
operator|.
name|g_type
condition|)
block|{
case|case
name|G_STR
case|:
name|xfree
argument_list|(
name|gs
operator|.
name|g_s
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|gs
operator|.
name|g_type
operator|=
name|G_NONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|go_last
parameter_list|()
block|{
switch|switch
condition|(
name|gs
operator|.
name|g_type
condition|)
block|{
case|case
name|G_NONE
case|:
name|error
argument_list|(
literal|"Nothing to repeat"
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_NUM
case|:
name|num_search
argument_list|(
name|gs
operator|.
name|g_n
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_CELL
case|:
name|moveto
argument_list|(
name|gs
operator|.
name|g_row
argument_list|,
name|gs
operator|.
name|g_col
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_STR
case|:
name|gs
operator|.
name|g_type
operator|=
name|G_NONE
expr_stmt|;
comment|/* Don't free the string */
name|str_search
argument_list|(
name|gs
operator|.
name|g_s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"go_last: internal error"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|moveto
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
block|{
name|currow
operator|=
name|row
expr_stmt|;
name|curcol
operator|=
name|col
expr_stmt|;
name|g_free
argument_list|()
expr_stmt|;
name|gs
operator|.
name|g_type
operator|=
name|G_CELL
expr_stmt|;
name|gs
operator|.
name|g_row
operator|=
name|currow
expr_stmt|;
name|gs
operator|.
name|g_col
operator|=
name|curcol
expr_stmt|;
block|}
end_function

begin_function
name|void
name|num_search
parameter_list|(
name|n
parameter_list|)
name|double
name|n
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|endr
decl_stmt|,
name|endc
decl_stmt|;
name|g_free
argument_list|()
expr_stmt|;
name|gs
operator|.
name|g_type
operator|=
name|G_NUM
expr_stmt|;
name|gs
operator|.
name|g_n
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|currow
operator|>
name|maxrow
condition|)
name|endr
operator|=
name|maxrow
condition|?
name|maxrow
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|endr
operator|=
name|currow
expr_stmt|;
if|if
condition|(
name|curcol
operator|>
name|maxcol
condition|)
name|endc
operator|=
name|maxcol
condition|?
name|maxcol
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|endc
operator|=
name|curcol
expr_stmt|;
name|r
operator|=
name|endr
expr_stmt|;
name|c
operator|=
name|endc
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|<
name|maxcol
condition|)
name|c
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|r
operator|<
name|maxrow
condition|)
block|{
while|while
condition|(
operator|++
name|r
operator|<
name|maxrow
operator|&&
name|row_hidden
index|[
name|r
index|]
condition|)
comment|/* */
empty_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|endr
operator|&&
name|c
operator|==
name|endc
condition|)
block|{
name|error
argument_list|(
literal|"Number not found"
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|col_hidden
index|[
name|c
index|]
operator|||
operator|!
name|p
operator|||
name|p
operator|&&
operator|(
operator|!
operator|(
name|p
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|||
operator|(
name|p
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|&&
name|p
operator|->
name|v
operator|!=
name|n
operator|)
condition|)
do|;
name|currow
operator|=
name|r
expr_stmt|;
name|curcol
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|void
name|str_search
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|,
name|c
decl_stmt|;
name|int
name|endr
decl_stmt|,
name|endc
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD43
argument_list|)
if|if
condition|(
operator|(
name|tmp
operator|=
name|re_comp
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYSV2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV3
argument_list|)
if|if
condition|(
operator|(
name|tmp
operator|=
name|regcmp
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid search string"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|g_free
argument_list|()
expr_stmt|;
name|gs
operator|.
name|g_type
operator|=
name|G_STR
expr_stmt|;
name|gs
operator|.
name|g_s
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|currow
operator|>
name|maxrow
condition|)
name|endr
operator|=
name|maxrow
condition|?
name|maxrow
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|endr
operator|=
name|currow
expr_stmt|;
if|if
condition|(
name|curcol
operator|>
name|maxcol
condition|)
name|endc
operator|=
name|maxcol
condition|?
name|maxcol
operator|-
literal|1
else|:
literal|0
expr_stmt|;
else|else
name|endc
operator|=
name|curcol
expr_stmt|;
name|r
operator|=
name|endr
expr_stmt|;
name|c
operator|=
name|endc
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|<
name|maxcol
condition|)
name|c
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|r
operator|<
name|maxrow
condition|)
block|{
while|while
condition|(
operator|++
name|r
operator|<
name|maxrow
operator|&&
name|row_hidden
index|[
name|r
index|]
condition|)
comment|/* */
empty_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|==
name|endr
operator|&&
name|c
operator|==
name|endc
condition|)
block|{
name|error
argument_list|(
literal|"String not found"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYSV2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV3
argument_list|)
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|p
operator|=
operator|*
name|ATBL
argument_list|(
name|tbl
argument_list|,
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|col_hidden
index|[
name|c
index|]
operator|||
operator|!
name|p
operator|||
name|p
operator|&&
operator|(
operator|!
operator|(
name|p
operator|->
name|label
operator|)
if|#
directive|if
name|defined
argument_list|(
name|BSD42
argument_list|)
operator|||
name|defined
argument_list|(
name|BSD43
argument_list|)
operator|||
operator|(
name|re_exec
argument_list|(
name|p
operator|->
name|label
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
do|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|SYSV2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV3
argument_list|)
operator|||
operator|(
name|regex
argument_list|(
name|tmp
argument_list|,
name|p
operator|->
name|label
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
block|)
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|||
operator|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|label
argument_list|)
operator|!=
literal|0
operator|)
end_expr_stmt

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|currow
operator|=
name|r
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|curcol
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSV2
argument_list|)
operator|||
name|defined
argument_list|(
name|SYSV3
argument_list|)
end_if

begin_expr_stmt
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
unit|}  void
name|fill
argument_list|(
argument|v1
argument_list|,
argument|v2
argument_list|,
argument|start
argument_list|,
argument|inc
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ent
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|start
decl_stmt|,
name|inc
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|r
operator|,
name|c
expr_stmt|;
specifier|register
name|struct
name|ent
modifier|*
name|n
decl_stmt|;
name|int
name|maxr
decl_stmt|,
name|maxc
decl_stmt|;
name|int
name|minr
decl_stmt|,
name|minc
decl_stmt|;
name|maxr
operator|=
name|v2
operator|->
name|row
expr_stmt|;
name|maxc
operator|=
name|v2
operator|->
name|col
expr_stmt|;
name|minr
operator|=
name|v1
operator|->
name|row
expr_stmt|;
name|minc
operator|=
name|v1
operator|->
name|col
expr_stmt|;
if|if
condition|(
name|minr
operator|>
name|maxr
condition|)
name|r
operator|=
name|maxr
operator|,
name|maxr
operator|=
name|minr
operator|,
name|minr
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|minc
operator|>
name|maxc
condition|)
name|c
operator|=
name|maxc
operator|,
name|maxc
operator|=
name|minc
operator|,
name|minc
operator|=
name|c
expr_stmt|;
name|checkbounds
argument_list|(
operator|&
name|maxr
argument_list|,
operator|&
name|maxc
argument_list|)
expr_stmt|;
if|if
condition|(
name|minr
operator|<
literal|0
condition|)
name|minr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|minr
operator|<
literal|0
condition|)
name|minr
operator|=
literal|0
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
if|if
condition|(
name|calc_order
operator|==
name|BYROWS
condition|)
block|{
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
block|{
name|n
operator|=
name|lookat
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|v
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|inc
expr_stmt|;
name|n
operator|->
name|flags
operator||=
operator|(
name|is_changed
operator||
name|is_valid
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|calc_order
operator|==
name|BYCOLS
condition|)
block|{
for|for
control|(
name|c
operator|=
name|minc
init|;
name|c
operator|<=
name|maxc
condition|;
name|c
operator|++
control|)
for|for
control|(
name|r
operator|=
name|minr
init|;
name|r
operator|<=
name|maxr
condition|;
name|r
operator|++
control|)
block|{
name|n
operator|=
name|lookat
argument_list|(
name|r
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clearent
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|->
name|v
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|inc
expr_stmt|;
name|n
operator|->
name|flags
operator||=
operator|(
name|is_changed
operator||
name|is_valid
operator|)
expr_stmt|;
block|}
block|}
else|else
name|error
argument_list|(
literal|" Internal error calc_order"
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|void
name|let
parameter_list|(
name|v
parameter_list|,
name|e
parameter_list|)
name|struct
name|ent
modifier|*
name|v
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
name|double
name|val
decl_stmt|;
name|exprerr
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|eval_fpe
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|fpe_save
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Floating point exception in cell %s"
argument_list|,
name|v_name
argument_list|(
name|v
operator|->
name|row
argument_list|,
name|v
operator|->
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|double
operator|)
literal|0.0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|eval
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprerr
condition|)
block|{
name|efree
argument_list|(
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constant
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|loading
condition|)
name|v
operator|->
name|v
operator|=
name|val
operator|*
name|prescale
expr_stmt|;
else|else
name|v
operator|->
name|v
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|flags
operator|&
name|is_strexpr
operator|)
condition|)
block|{
name|efree
argument_list|(
name|v
argument_list|,
name|v
operator|->
name|expr
argument_list|)
expr_stmt|;
name|v
operator|->
name|expr
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|efree
argument_list|(
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|v
operator|->
name|flags
operator||=
operator|(
name|is_changed
operator||
name|is_valid
operator|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
return|return;
block|}
name|efree
argument_list|(
name|v
argument_list|,
name|v
operator|->
name|expr
argument_list|)
expr_stmt|;
name|v
operator|->
name|expr
operator|=
name|e
expr_stmt|;
name|v
operator|->
name|flags
operator||=
operator|(
name|is_changed
operator||
name|is_valid
operator|)
expr_stmt|;
name|v
operator|->
name|flags
operator|&=
operator|~
name|is_strexpr
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPRTREE
name|totoptree
argument_list|(
name|v
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|changed
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|slet
parameter_list|(
name|v
parameter_list|,
name|se
parameter_list|,
name|flushdir
parameter_list|)
name|struct
name|ent
modifier|*
name|v
decl_stmt|;
name|struct
name|enode
modifier|*
name|se
decl_stmt|;
name|int
name|flushdir
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|exprerr
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|eval_fpe
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|fpe_save
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Floating point exception in cell %s"
argument_list|,
name|v_name
argument_list|(
name|v
operator|->
name|row
argument_list|,
name|v
operator|->
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|seval
argument_list|(
name|se
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|quit
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprerr
condition|)
block|{
name|efree
argument_list|(
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
argument_list|,
name|se
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|constant
argument_list|(
name|se
argument_list|)
condition|)
block|{
name|label
argument_list|(
name|v
argument_list|,
name|p
argument_list|,
name|flushdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|efree
argument_list|(
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
argument_list|,
name|se
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|flags
operator|&
name|is_strexpr
condition|)
block|{
name|efree
argument_list|(
name|v
argument_list|,
name|v
operator|->
name|expr
argument_list|)
expr_stmt|;
name|v
operator|->
name|expr
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
name|v
operator|->
name|flags
operator|&=
operator|~
name|is_strexpr
expr_stmt|;
block|}
return|return;
block|}
name|efree
argument_list|(
name|v
argument_list|,
name|v
operator|->
name|expr
argument_list|)
expr_stmt|;
name|v
operator|->
name|expr
operator|=
name|se
expr_stmt|;
name|v
operator|->
name|flags
operator||=
operator|(
name|is_changed
operator||
name|is_strexpr
operator|)
expr_stmt|;
if|if
condition|(
name|flushdir
operator|<
literal|0
condition|)
name|v
operator|->
name|flags
operator||=
name|is_leftflush
expr_stmt|;
else|else
name|v
operator|->
name|flags
operator|&=
operator|~
name|is_leftflush
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPRTREE
name|totoptree
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FullUpdate
operator|++
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EXPRTREE
end_ifdef

begin_comment
comment|/*  * put an expression in the expression tree, only the top of each branch is  * in the firstev list  */
end_comment

begin_macro
name|totoptree
argument_list|(
argument|v
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ent
modifier|*
name|v
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|right
decl_stmt|;
name|int
name|left
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|expr
condition|)
return|return;
ifdef|#
directive|ifdef
name|notdef
name|right
operator|=
name|FALSE
expr_stmt|;
name|left
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|v
operator|->
name|expr
operator|->
name|op
condition|)
block|{
comment|/* no real expression */
case|case
literal|'v'
case|:
if|if
condition|(
name|v
operator|->
name|expr
operator|->
name|o
operator|.
name|v
operator|->
name|evnext
condition|)
name|evdel
argument_list|(
name|v
operator|->
name|expr
operator|->
name|o
operator|.
name|v
argument_list|)
expr_stmt|;
case|case
literal|'k'
case|:
case|case
name|LMAX
case|:
case|case
name|LMIN
case|:
case|case
name|NOW
case|:
case|case
name|O_SCONST
case|:
case|case
name|O_VAR
case|:
default|default:
return|return;
comment|/* left&& right */
case|case
literal|'#'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'/'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'^'
case|:
case|case
literal|'|'
case|:
case|case
name|ATAN2
case|:
case|case
name|DTS
case|:
case|case
name|EQS
case|:
case|case
name|EXT
case|:
case|case
name|FMT
case|:
case|case
name|FV
case|:
case|case
name|HYPOT
case|:
case|case
name|IF
case|:
case|case
name|NVAL
case|:
case|case
name|PMT
case|:
case|case
name|POW
case|:
case|case
name|PV
case|:
case|case
name|REDUCE
operator||
literal|'*'
case|:
case|case
name|REDUCE
operator||
literal|'+'
case|:
case|case
name|REDUCE
operator||
literal|'a'
case|:
case|case
name|REDUCE
operator||
literal|'c'
case|:
case|case
name|REDUCE
operator||
literal|'s'
case|:
case|case
name|REDUCE
operator||
name|MAX
case|:
case|case
name|REDUCE
operator||
name|MIN
case|:
case|case
name|ROUND
case|:
case|case
name|STINDEX
case|:
case|case
name|SUBSTR
case|:
case|case
name|SVAL
case|:
case|case
name|TTS
case|:
name|left
operator|=
name|right
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* right only */
case|case
literal|'f'
case|:
case|case
literal|'m'
case|:
case|case
literal|'~'
case|:
case|case
name|ABS
case|:
case|case
name|ACOS
case|:
case|case
name|ASIN
case|:
case|case
name|ATAN
case|:
case|case
name|CEIL
case|:
case|case
name|COS
case|:
case|case
name|DATE
case|:
case|case
name|DAY
case|:
case|case
name|DTR
case|:
case|case
name|EXP
case|:
case|case
name|FABS
case|:
case|case
name|FLOOR
case|:
case|case
name|HLOOKUP
case|:
case|case
name|HOUR
case|:
case|case
name|IF
case|:
case|case
name|INDEX
case|:
case|case
name|LOG10
case|:
case|case
name|LOG
case|:
case|case
name|LOOKUP
case|:
case|case
name|MINUTE
case|:
case|case
name|MONTH
case|:
case|case
name|RND
case|:
case|case
name|RTD
case|:
case|case
name|SECOND
case|:
case|case
name|SIN
case|:
case|case
name|SQRT
case|:
case|case
name|STON
case|:
case|case
name|TAN
case|:
case|case
name|VLOOKUP
case|:
case|case
name|YEAR
case|:
name|right
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* for now insert at the beginning of the list */
name|v
operator|->
name|evnext
operator|=
name|firstev
expr_stmt|;
name|v
operator|->
name|evprev
operator|=
operator|(
expr|struct
name|ent
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|firstev
condition|)
name|firstev
operator|->
name|evprev
operator|=
name|v
expr_stmt|;
name|firstev
operator|=
name|v
expr_stmt|;
endif|#
directive|endif
name|firstev
operator|=
name|v
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXPRTREE*/
end_comment

begin_function
name|void
name|hide_row
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid Range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg
operator|>=
name|maxrows
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|growtbl
argument_list|(
name|GROWROW
argument_list|,
name|arg
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"You can't hide the last row"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|row_hidden
index|[
name|arg
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hide_col
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Invalid Range"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arg
operator|>=
name|maxcols
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|arg
operator|>=
name|ABSMAXCOLS
operator|-
literal|1
operator|)
operator|||
operator|!
name|growtbl
argument_list|(
name|GROWCOL
argument_list|,
literal|0
argument_list|,
name|arg
operator|+
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"You can't hide the last col"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|FullUpdate
operator|++
expr_stmt|;
name|col_hidden
index|[
name|arg
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clearent
parameter_list|(
name|v
parameter_list|)
name|struct
name|ent
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|v
condition|)
return|return;
name|label
argument_list|(
name|v
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|v
operator|->
name|v
operator|=
operator|(
name|double
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|expr
condition|)
name|efree
argument_list|(
name|v
argument_list|,
name|v
operator|->
name|expr
argument_list|)
expr_stmt|;
name|v
operator|->
name|expr
operator|=
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
expr_stmt|;
name|v
operator|->
name|flags
operator||=
operator|(
name|is_changed
operator|)
expr_stmt|;
name|v
operator|->
name|flags
operator|&=
operator|~
operator|(
name|is_valid
operator|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Say if an expression is a constant (return 1) or not.  */
end_comment

begin_function
name|int
name|constant
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|e
operator|==
operator|(
expr|struct
name|enode
operator|*
operator|)
literal|0
operator|)
operator|||
operator|(
operator|(
name|e
operator|->
name|op
operator|)
operator|==
name|O_CONST
operator|)
operator|||
operator|(
operator|(
name|e
operator|->
name|op
operator|)
operator|==
name|O_SCONST
operator|)
operator|||
operator|(
operator|(
operator|(
name|e
operator|->
name|op
operator|)
operator|!=
name|O_VAR
operator|)
operator|&&
operator|(
operator|(
operator|(
name|e
operator|->
name|op
operator|)
operator|&
name|REDUCE
operator|)
operator|!=
name|REDUCE
operator|)
operator|&&
name|constant
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
operator|&&
name|constant
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
operator|&&
operator|(
name|e
operator|->
name|op
operator|!=
name|EXT
operator|)
comment|/* functions look like constants but aren't */
operator|&&
operator|(
name|e
operator|->
name|op
operator|!=
name|NVAL
operator|)
operator|&&
operator|(
name|e
operator|->
name|op
operator|!=
name|SVAL
operator|)
operator|&&
operator|(
name|e
operator|->
name|op
operator|!=
name|NOW
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|efree
parameter_list|(
name|v
parameter_list|,
name|e
parameter_list|)
name|struct
name|ent
modifier|*
name|v
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
if|if
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|op
operator|!=
name|O_VAR
operator|&&
name|e
operator|->
name|op
operator|!=
name|O_CONST
operator|&&
name|e
operator|->
name|op
operator|!=
name|O_SCONST
operator|&&
operator|(
name|e
operator|->
name|op
operator|&
name|REDUCE
operator|)
operator|!=
name|REDUCE
condition|)
block|{
name|efree
argument_list|(
name|v
argument_list|,
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|v
argument_list|,
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|op
operator|==
name|O_SCONST
operator|&&
name|e
operator|->
name|e
operator|.
name|s
condition|)
name|xfree
argument_list|(
name|e
operator|->
name|e
operator|.
name|s
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXPRTREE
comment|/* delete this cell from the eval list */
if|if
condition|(
name|v
condition|)
block|{
if|if
condition|(
name|v
operator|->
name|evprev
condition|)
name|v
operator|->
name|evprev
operator|->
name|evnext
operator|=
name|v
operator|->
name|evnext
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|evnext
condition|)
name|v
operator|->
name|evnext
operator|->
name|evprev
operator|=
name|v
operator|->
name|evprev
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* EXPRTREE */
block|}
block|}
end_function

begin_function
name|void
name|label
parameter_list|(
name|v
parameter_list|,
name|s
parameter_list|,
name|flushdir
parameter_list|)
specifier|register
name|struct
name|ent
modifier|*
name|v
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|flushdir
decl_stmt|;
block|{
if|if
condition|(
name|v
condition|)
block|{
if|if
condition|(
name|flushdir
operator|==
literal|0
operator|&&
name|v
operator|->
name|flags
operator|&
name|is_valid
condition|)
block|{
specifier|register
name|struct
name|ent
modifier|*
name|tv
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|col
operator|>
literal|0
operator|&&
operator|(
operator|(
name|tv
operator|=
name|lookat
argument_list|(
name|v
operator|->
name|row
argument_list|,
name|v
operator|->
name|col
operator|-
literal|1
argument_list|)
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|==
literal|0
condition|)
name|v
operator|=
name|tv
operator|,
name|flushdir
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|tv
operator|=
name|lookat
argument_list|(
name|v
operator|->
name|row
argument_list|,
name|v
operator|->
name|col
operator|+
literal|1
argument_list|)
operator|)
operator|->
name|flags
operator|&
name|is_valid
operator|)
operator|==
literal|0
condition|)
name|v
operator|=
name|tv
operator|,
name|flushdir
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|flushdir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|label
condition|)
name|xfree
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|v
operator|->
name|label
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
index|[
literal|0
index|]
condition|)
block|{
name|v
operator|->
name|label
operator|=
name|xmalloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|v
operator|->
name|label
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|v
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|flushdir
operator|<
literal|0
condition|)
name|v
operator|->
name|flags
operator||=
name|is_leftflush
expr_stmt|;
else|else
name|v
operator|->
name|flags
operator|&=
operator|~
name|is_leftflush
expr_stmt|;
name|FullUpdate
operator|++
expr_stmt|;
name|modflg
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|decodev
parameter_list|(
name|v
parameter_list|)
name|struct
name|ent_ptr
name|v
decl_stmt|;
block|{
specifier|register
name|struct
name|range
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|v
operator|.
name|vp
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"VAR?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|r
operator|=
name|find_range
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|v
operator|.
name|vp
argument_list|,
name|v
operator|.
name|vp
argument_list|)
operator|)
operator|&&
operator|!
name|r
operator|->
name|r_is_range
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"%s"
argument_list|,
name|r
operator|->
name|r_name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"%s%s%s%d"
argument_list|,
name|v
operator|.
name|vf
operator|&
name|FIX_COL
condition|?
literal|"$"
else|:
literal|""
argument_list|,
name|coltoa
argument_list|(
name|v
operator|.
name|vp
operator|->
name|col
argument_list|)
argument_list|,
name|v
operator|.
name|vf
operator|&
name|FIX_ROW
condition|?
literal|"$"
else|:
literal|""
argument_list|,
name|v
operator|.
name|vp
operator|->
name|row
argument_list|)
expr_stmt|;
name|linelim
operator|+=
name|strlen
argument_list|(
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|coltoa
parameter_list|(
name|col
parameter_list|)
name|int
name|col
decl_stmt|;
block|{
specifier|static
name|char
name|rname
index|[
literal|3
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|rname
decl_stmt|;
if|if
condition|(
name|col
operator|>
literal|25
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|col
operator|/
literal|26
operator|+
literal|'A'
operator|-
literal|1
expr_stmt|;
name|col
operator|%=
literal|26
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|col
operator|+
literal|'A'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|rname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	To make list elements come out in the same order  *	they were entered, we must do a depth-first eval  *	of the ELIST tree  */
end_comment

begin_function
specifier|static
name|void
name|decompile_list
parameter_list|(
name|p
parameter_list|)
name|struct
name|enode
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
name|decompile_list
argument_list|(
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
expr_stmt|;
comment|/* depth first */
name|decompile
argument_list|(
name|p
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|','
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decompile
parameter_list|(
name|e
parameter_list|,
name|priority
parameter_list|)
specifier|register
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
name|int
name|priority
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|int
name|mypriority
decl_stmt|;
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
default|default:
name|mypriority
operator|=
literal|99
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|mypriority
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|mypriority
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|mypriority
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|mypriority
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
name|mypriority
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'#'
case|:
name|mypriority
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
name|mypriority
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|mypriority
operator|=
literal|12
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mypriority
operator|<
name|priority
condition|)
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|'('
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|op
condition|)
block|{
case|case
literal|'f'
case|:
for|for
control|(
name|s
operator|=
literal|"fixed "
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|'~'
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|decodev
argument_list|(
name|e
operator|->
name|e
operator|.
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"%.15g"
argument_list|,
name|e
operator|->
name|e
operator|.
name|k
argument_list|)
expr_stmt|;
name|linelim
operator|+=
name|strlen
argument_list|(
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"\"%s\""
argument_list|,
name|e
operator|->
name|e
operator|.
name|s
argument_list|)
expr_stmt|;
name|linelim
operator|+=
name|strlen
argument_list|(
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
literal|'+'
case|:
name|range_arg
argument_list|(
literal|"@sum("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
literal|'*'
case|:
name|range_arg
argument_list|(
literal|"@prod("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
literal|'a'
case|:
name|range_arg
argument_list|(
literal|"@avg("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
literal|'c'
case|:
name|range_arg
argument_list|(
literal|"@count("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
literal|'s'
case|:
name|range_arg
argument_list|(
literal|"@stddev("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
name|MAX
case|:
name|range_arg
argument_list|(
literal|"@max("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|REDUCE
operator||
name|MIN
case|:
name|range_arg
argument_list|(
literal|"@min("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABS
case|:
name|one_arg
argument_list|(
literal|"@abs("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACOS
case|:
name|one_arg
argument_list|(
literal|"@acos("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASIN
case|:
name|one_arg
argument_list|(
literal|"@asin("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATAN
case|:
name|one_arg
argument_list|(
literal|"@atan("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATAN2
case|:
name|two_arg
argument_list|(
literal|"@atan2("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|CEIL
case|:
name|one_arg
argument_list|(
literal|"@ceil("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|COS
case|:
name|one_arg
argument_list|(
literal|"@cos("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXP
case|:
name|one_arg
argument_list|(
literal|"@exp("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|FABS
case|:
name|one_arg
argument_list|(
literal|"@fabs("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOOR
case|:
name|one_arg
argument_list|(
literal|"@floor("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|HYPOT
case|:
name|two_arg
argument_list|(
literal|"@hypot("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG
case|:
name|one_arg
argument_list|(
literal|"@ln("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOG10
case|:
name|one_arg
argument_list|(
literal|"@log("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|POW
case|:
name|two_arg
argument_list|(
literal|"@pow("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIN
case|:
name|one_arg
argument_list|(
literal|"@sin("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SQRT
case|:
name|one_arg
argument_list|(
literal|"@sqrt("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAN
case|:
name|one_arg
argument_list|(
literal|"@tan("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTR
case|:
name|one_arg
argument_list|(
literal|"@dtr("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|RTD
case|:
name|one_arg
argument_list|(
literal|"@rtd("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|RND
case|:
name|one_arg
argument_list|(
literal|"@rnd("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|ROUND
case|:
name|two_arg
argument_list|(
literal|"@round("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|HOUR
case|:
name|one_arg
argument_list|(
literal|"@hour("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUTE
case|:
name|one_arg
argument_list|(
literal|"@minute("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SECOND
case|:
name|one_arg
argument_list|(
literal|"@second("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|MONTH
case|:
name|one_arg
argument_list|(
literal|"@month("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DAY
case|:
name|one_arg
argument_list|(
literal|"@day("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|YEAR
case|:
name|one_arg
argument_list|(
literal|"@year("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATE
case|:
name|one_arg
argument_list|(
literal|"@date("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTS
case|:
name|three_arg
argument_list|(
literal|"@dts("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TTS
case|:
name|three_arg
argument_list|(
literal|"@tts("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STON
case|:
name|one_arg
argument_list|(
literal|"@ston("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|FMT
case|:
name|two_arg
argument_list|(
literal|"@fmt("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQS
case|:
name|two_arg
argument_list|(
literal|"@eqs("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOW
case|:
for|for
control|(
name|s
operator|=
literal|"@now"
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
break|break;
case|case
name|LMAX
case|:
name|list_arg
argument_list|(
literal|"@max("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LMIN
case|:
name|list_arg
argument_list|(
literal|"@min("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|FV
case|:
name|three_arg
argument_list|(
literal|"@fv("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|PV
case|:
name|three_arg
argument_list|(
literal|"@pv("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMT
case|:
name|three_arg
argument_list|(
literal|"@pmt("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVAL
case|:
name|two_arg
argument_list|(
literal|"@nval("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVAL
case|:
name|two_arg
argument_list|(
literal|"@sval("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXT
case|:
name|two_arg
argument_list|(
literal|"@ext("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBSTR
case|:
name|three_arg
argument_list|(
literal|"@substr("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|STINDEX
case|:
name|index_arg
argument_list|(
literal|"@stindex("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDEX
case|:
name|index_arg
argument_list|(
literal|"@index("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOKUP
case|:
name|index_arg
argument_list|(
literal|"@lookup("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|HLOOKUP
case|:
name|two_arg_index
argument_list|(
literal|"@hlookup("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|VLOOKUP
case|:
name|two_arg_index
argument_list|(
literal|"@vlookup("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|IF
case|:
name|three_arg
argument_list|(
literal|"@if("
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
default|default:
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
name|mypriority
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
name|e
operator|->
name|op
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
name|mypriority
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mypriority
operator|<
name|priority
condition|)
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
else|else
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|index_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range_arg
argument_list|(
literal|", "
argument_list|,
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|two_arg_index
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range_arg
argument_list|(
literal|","
argument_list|,
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|)
expr_stmt|;
name|linelim
operator|--
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|list_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|decompile_list
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|one_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|two_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|three_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|left
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|decompile
argument_list|(
name|e
operator|->
name|e
operator|.
name|o
operator|.
name|right
operator|->
name|e
operator|.
name|o
operator|.
name|right
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|range_arg
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|struct
name|enode
modifier|*
name|e
decl_stmt|;
block|{
name|struct
name|range
modifier|*
name|r
decl_stmt|;
for|for
control|(
init|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|linelim
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|find_range
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
operator|.
name|vp
argument_list|,
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
operator|.
name|vp
argument_list|)
operator|)
operator|&&
name|r
operator|->
name|r_is_range
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"%s"
argument_list|,
name|r
operator|->
name|r_name
argument_list|)
expr_stmt|;
name|linelim
operator|+=
name|strlen
argument_list|(
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decodev
argument_list|(
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|left
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|decodev
argument_list|(
name|e
operator|->
name|e
operator|.
name|r
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
name|line
index|[
name|linelim
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|editv
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|lookat
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"let %s = "
argument_list|,
name|v_name
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|is_strexpr
operator|||
name|p
operator|->
name|expr
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"%.15g"
argument_list|,
name|p
operator|->
name|v
argument_list|)
expr_stmt|;
name|linelim
operator|+=
name|strlen
argument_list|(
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|editexp
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|editexp
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|lookat
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|decompile
argument_list|(
name|p
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|line
index|[
name|linelim
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|edits
parameter_list|(
name|row
parameter_list|,
name|col
parameter_list|)
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
block|{
specifier|register
name|struct
name|ent
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|lookat
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%sstring %s = "
argument_list|,
operator|(
operator|(
name|p
operator|->
name|flags
operator|&
name|is_leftflush
operator|)
condition|?
literal|"left"
else|:
literal|"right"
operator|)
argument_list|,
name|v_name
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
argument_list|)
expr_stmt|;
name|linelim
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|flags
operator|&
name|is_strexpr
operator|&&
name|p
operator|->
name|expr
condition|)
block|{
name|editexp
argument_list|(
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|label
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"\"%s\""
argument_list|,
name|p
operator|->
name|label
argument_list|)
expr_stmt|;
name|linelim
operator|+=
name|strlen
argument_list|(
name|line
operator|+
name|linelim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
operator|+
name|linelim
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|linelim
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

end_unit

