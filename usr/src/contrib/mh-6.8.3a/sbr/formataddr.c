begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* formataddr.c - format an address field (from formatsbr) */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* our current working buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bufend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of working buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buf ptr at end of last call */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|bufsiz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size of buf */
end_comment

begin_define
define|#
directive|define
name|BUFINCR
value|512
end_define

begin_comment
comment|/* how much to expand buf when if fills */
end_comment

begin_define
define|#
directive|define
name|CPY
parameter_list|(
name|s
parameter_list|)
value|{ cp = (s); while (*dst++ = *cp++) ; --dst; }
end_define

begin_comment
comment|/* check if there's enough room in buf for str.  add more mem if needed */
end_comment

begin_define
define|#
directive|define
name|CHECKMEM
parameter_list|(
name|str
parameter_list|)
define|\
value|if ((len = strlen (str))>= bufend - dst) {\ 		int i = dst - buf;\ 		int n = last_dst - buf;\ 		bufsiz += ((dst + len - bufend) / BUFINCR + 1) * BUFINCR;\ 		buf = realloc (buf, bufsiz);\ 		dst = buf + i;\ 		last_dst = buf + n;\ 		if (! buf)\ 		    adios (NULLCP, "formataddr: couldn't get buffer space");\ 		bufend = buf + bufsiz;\ 	    }
end_define

begin_comment
comment|/* fmtscan will call this routine if the user includes the function  * "(formataddr {component})" in a format string.  "orig" is the  * original contents of the string register.  "str" is the address  * string to be formatted and concatenated onto orig.  This routine  * returns a pointer to the concatenated address string.  *  * We try to not do a lot of malloc/copy/free's (which is why we  * don't call "getcpy") but still place no upper limit on the  * length of the result string.  *  * This routine is placed in a separate library so it can be  * overridden by particular programs (e.g., "replsbr").  */
end_comment

begin_function
name|char
modifier|*
name|formataddr
parameter_list|(
name|orig
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|orig
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|isgroup
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
comment|/* if we don't have a buffer yet, get one */
if|if
condition|(
name|bufsiz
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|BUFINCR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"formataddr: couldn't allocate buffer space"
argument_list|)
expr_stmt|;
name|last_dst
operator|=
name|buf
expr_stmt|;
comment|/* XXX */
name|bufsiz
operator|=
name|BUFINCR
operator|-
literal|6
expr_stmt|;
comment|/* leave some slop */
name|bufend
operator|=
name|buf
operator|+
name|bufsiz
expr_stmt|;
block|}
comment|/*      * If "orig" points to our buffer we can just pick up where we      * left off.  Otherwise we have to copy orig into our buffer.      */
if|if
condition|(
name|orig
operator|==
name|buf
condition|)
name|dst
operator|=
name|last_dst
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|orig
operator|||
operator|!
operator|*
name|orig
condition|)
block|{
name|dst
operator|=
name|buf
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|=
name|last_dst
expr_stmt|;
comment|/* XXX */
name|CHECKMEM
argument_list|(
name|orig
argument_list|)
expr_stmt|;
name|CPY
argument_list|(
name|orig
argument_list|)
expr_stmt|;
block|}
comment|/* concatenate all the new addresses onto 'buf' */
for|for
control|(
name|isgroup
operator|=
literal|0
init|;
name|cp
operator|=
name|getname
argument_list|(
name|str
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|mp
operator|=
name|getm
argument_list|(
name|cp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|fmt_norm
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|isgroup
operator|&&
operator|(
name|mp
operator|->
name|m_gname
operator|||
operator|!
name|mp
operator|->
name|m_ingrp
operator|)
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
literal|';'
expr_stmt|;
name|isgroup
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if we get here we're going to add an address */
if|if
condition|(
name|dst
operator|!=
name|buf
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_gname
condition|)
block|{
name|CHECKMEM
argument_list|(
name|mp
operator|->
name|m_gname
argument_list|)
expr_stmt|;
name|CPY
argument_list|(
name|mp
operator|->
name|m_gname
argument_list|)
expr_stmt|;
name|isgroup
operator|++
expr_stmt|;
block|}
name|sp
operator|=
name|adrformat
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|CHECKMEM
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|CPY
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|mnfree
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isgroup
condition|)
operator|*
name|dst
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|last_dst
operator|=
name|dst
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

