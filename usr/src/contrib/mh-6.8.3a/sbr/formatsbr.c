begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* formatsbr.c - format string interpretation */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"@(#)$Id: formatsbr.c,v 1.24 1993/08/20 15:48:14 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_include
include|#
directive|include
file|"../h/fmtcompile.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_define
define|#
directive|define
name|NFMTS
value|MAXARGS
end_define

begin_define
define|#
directive|define
name|QUOTE
value|'\\'
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|formats
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|formataddr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* hook for custom address formatting */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LBL
end_ifdef

begin_decl_stmt
name|struct
name|msgs
modifier|*
name|fmt_current_folder
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current folder (set by main program) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|normalize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|get_x400_comp
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|fmt_norm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in sbr/formatdef.c = AD_NAME */
end_comment

begin_decl_stmt
name|struct
name|mailname
name|fmt_mnull
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* MAJOR HACK:	See MHCHANGES for discussion */
end_comment

begin_function
name|char
modifier|*
name|new_fs
parameter_list|(
name|form
parameter_list|,
name|format
parameter_list|,
name|def
parameter_list|)
specifier|register
name|char
modifier|*
name|form
decl_stmt|,
decl|*
name|format
decl_stmt|,
modifier|*
name|def
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|formats
condition|)
name|free
argument_list|(
name|formats
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
condition|)
block|{
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|libpath
argument_list|(
name|form
argument_list|)
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"unable to open format file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"unable to stat format file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|formats
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|st
operator|.
name|st_size
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULLCP
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"unable to allocate space for format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|formats
argument_list|,
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
argument_list|)
operator|!=
name|st
operator|.
name|st_size
condition|)
name|adios
argument_list|(
name|form
argument_list|,
literal|"error reading format file"
argument_list|)
expr_stmt|;
name|formats
index|[
name|st
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formats
operator|=
name|getcpy
argument_list|(
name|format
condition|?
name|format
else|:
name|def
argument_list|)
expr_stmt|;
block|}
name|normalize
argument_list|(
name|formats
argument_list|)
expr_stmt|;
return|return
name|formats
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|normalize
argument_list|(
name|cp
argument_list|)
specifier|register
name|char
operator|*
name|cp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|cp
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|!=
name|QUOTE
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
else|else
switch|switch
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
define|#
directive|define
name|grot
parameter_list|(
name|y
parameter_list|,
name|z
parameter_list|)
value|case y: *dp++ = z; break;
name|grot
argument_list|(
literal|'b'
argument_list|,
literal|'\b'
argument_list|)
expr_stmt|;
name|grot
argument_list|(
literal|'f'
argument_list|,
literal|'\f'
argument_list|)
expr_stmt|;
name|grot
argument_list|(
literal|'n'
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|grot
argument_list|(
literal|'r'
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|grot
argument_list|(
literal|'t'
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
break|break;
case|case
literal|0
case|:
name|cp
operator|--
expr_stmt|;
comment|/* fall */
default|default:
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
expr_stmt|;
break|break;
block|}
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/*  * test if string "sub" appears anywhere in string "str"  * (case insensitive).  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|str
parameter_list|,
name|sub
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|sub
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|c1
decl_stmt|;
specifier|register
name|int
name|c2
decl_stmt|;
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
specifier|register
name|char
modifier|*
name|s2
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCALE
while|while
condition|(
name|c1
operator|=
operator|*
name|sub
condition|)
block|{
name|c1
operator|=
operator|(
name|isalpha
argument_list|(
name|c1
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c1
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|c1
argument_list|)
else|:
name|c1
expr_stmt|;
while|while
condition|(
operator|(
name|c2
operator|=
operator|*
name|str
operator|++
operator|)
operator|&&
name|c1
operator|!=
operator|(
operator|(
name|isalpha
argument_list|(
name|c2
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c2
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|c2
argument_list|)
else|:
name|c2
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c2
condition|)
return|return
literal|0
return|;
name|s1
operator|=
name|sub
operator|+
literal|1
expr_stmt|;
name|s2
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|c1
operator|=
operator|*
name|s1
operator|++
operator|)
operator|&&
operator|(
operator|(
name|isalpha
argument_list|(
name|c1
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c1
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|c1
argument_list|)
else|:
name|c1
operator|)
operator|==
operator|(
operator|(
name|isalpha
argument_list|(
name|c2
operator|=
operator|*
name|s2
operator|++
argument_list|)
operator|&&
name|isupper
argument_list|(
name|c2
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|c2
argument_list|)
else|:
name|c2
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
return|return
literal|1
return|;
block|}
else|#
directive|else
while|while
condition|(
name|c1
operator|=
operator|*
name|sub
condition|)
block|{
while|while
condition|(
operator|(
name|c2
operator|=
operator|*
name|str
operator|++
operator|)
operator|&&
operator|(
name|c1
operator||
literal|040
operator|)
operator|!=
operator|(
name|c2
operator||
literal|040
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c2
condition|)
return|return
literal|0
return|;
name|s1
operator|=
name|sub
operator|+
literal|1
expr_stmt|;
name|s2
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
name|c1
operator|=
operator|*
name|s1
operator|++
operator|)
operator|&&
operator|(
name|c1
operator||
literal|040
operator|)
operator|==
operator|(
operator|*
name|s2
operator|++
operator||
literal|040
operator|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
return|return
literal|1
return|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* macros to format data */
end_comment

begin_define
define|#
directive|define
name|PUTDF
parameter_list|(
name|cp
parameter_list|,
name|num
parameter_list|,
name|wid
parameter_list|,
name|fill
parameter_list|)
value|if (cp + wid< ep){\ 		if((i = (num))<0) i = -(num);\ 		if((c = (wid))<0) c = -c;\ 		sp = cp + c;\ 		do {\ 		    *--sp = (i % 10) + '0';\ 		    i /= 10;\ 		} while (i> 0&& sp> cp);\ 		if (i> 0)\ 		    *sp = '?';\ 		else if ((num)< 0&& sp> cp)\ 		    *--sp = '-';\ 		while (sp> cp)\ 		    *--sp = fill;\ 		cp += c;\ 		}
end_define

begin_define
define|#
directive|define
name|PUTD
parameter_list|(
name|cp
parameter_list|,
name|num
parameter_list|)
value|if (cp< ep){\ 		if((i = (num))==0) *cp++ = '0';\ 		else {\ 		    if((i = (num))<0) \ 			*cp++ = '-', i = -(num);\ 		    c = 10;\ 		    while (c<= i) \ 			c *= 10;\ 		    while (cp< ep&& c> 1) {\ 			c /= 10;\ 			*cp++ = (i / c) + '0';\ 			i %= c;\ 			}\ 		    }\ 		}
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALE
end_ifdef

begin_define
define|#
directive|define
name|PUTSF
parameter_list|(
name|cp
parameter_list|,
name|str
parameter_list|,
name|wid
parameter_list|,
name|fill
parameter_list|)
value|{\ 		ljust = 0;\ 		if ((i = (wid))< 0) {\ 			i = -i;\ 			ljust++;\ 		}\ 		if (sp = (str)) {\ 			if (ljust) {\ 				c = strlen(sp);\ 				if (c> i)\ 					sp += c - i;\ 				else {\ 					while( --i>= c&& cp< ep)\ 						*cp++ = fill;\ 					i++;\ 				}\ 			} else {\ 			    while ((c = *sp)&& (iscntrl(c) || isspace(c)))\ 				sp++;\ 			}\ 			while ((c = *sp++)&& --i>= 0&& cp< ep)\ 				if (isgraph(c)) \ 				    *cp++ = c;\ 				else {\ 					while ((c = *sp)&& (iscntrl(c) || isspace(c)))\ 						sp++;\ 					    *cp++ = ' ';\ 				}\ 		}\ 		if (!ljust)\ 		while( --i>= 0&& cp< ep)\ 		    *cp++ = fill;\ 	}
end_define

begin_define
define|#
directive|define
name|PUTS
parameter_list|(
name|cp
parameter_list|,
name|str
parameter_list|)
value|{\ 		if (sp = (str)) {\ 		    while ((c = *sp)&& (iscntrl(c) || isspace(c)))\ 			sp++;\ 		    while((c = *sp++)&& cp< ep)\ 			if (isgraph(c)) \ 			    *cp++ = c;\ 			else {\ 			    while ((c = *sp)&& (iscntrl(c) || isspace(c)))\ 				sp++;\ 			    *cp++ = ' ';\ 			}\ 		}\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* LOCALE */
end_comment

begin_define
define|#
directive|define
name|PUTSF
parameter_list|(
name|cp
parameter_list|,
name|str
parameter_list|,
name|wid
parameter_list|,
name|fill
parameter_list|)
value|{\ 		ljust = 0;\ 		if ((i = (wid))< 0) {\ 			i = -i;\ 			ljust++;\ 		}\ 		if (sp = (str)) {\ 			if (ljust) {\ 				c = strlen(sp);\ 				if (c> i)\ 					sp += c - i;\ 				else {\ 					while( --i>= c&& cp< ep)\ 						*cp++ = fill;\ 					i++;\ 				}\ 			} else {\ 		    while ((c = *sp)&& c<= 32)\ 			sp++;\ 			}\ 			while ((c = *sp++)&& --i>= 0&& cp< ep)\ 				if (c> 32) \ 			    *cp++ = c;\ 			else {\ 					while ((c = *sp)&& c<= 32)\ 				sp++;\ 			    *cp++ = ' ';\ 			}\ 		}\ 		if (!ljust)\ 		while( --i>= 0&& cp< ep)\ 		    *cp++ = fill;\ 		}
end_define

begin_define
define|#
directive|define
name|PUTS
parameter_list|(
name|cp
parameter_list|,
name|str
parameter_list|)
value|{\ 		if (sp = (str)) {\ 		    while ((c = *sp)&& c<= 32)\ 			sp++;\ 		    while( (c = *sp++)&& cp< ep)\ 			if ( c> 32 ) \ 			    *cp++ = c;\ 			else {\ 			    while ( (c = *sp)&& c<= 32 )\ 				sp++;\ 			    *cp++ = ' ';\ 			}\ 		}\ 		}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lmonth
index|[]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|get_x400_friendly
parameter_list|(
name|mbox
parameter_list|,
name|buffer
parameter_list|)
name|char
modifier|*
name|mbox
decl_stmt|,
decl|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
name|char
name|given
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|surname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|mbox
operator|==
name|NULLCP
condition|)
return|return
name|NULLCP
return|;
if|if
condition|(
operator|*
name|mbox
operator|==
literal|'"'
condition|)
name|mbox
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|mbox
operator|!=
literal|'/'
condition|)
return|return
name|NULLCP
return|;
if|if
condition|(
name|get_x400_comp
argument_list|(
name|mbox
argument_list|,
literal|"/PN="
argument_list|,
name|buffer
argument_list|)
condition|)
block|{
for|for
control|(
name|mbox
operator|=
name|buffer
init|;
name|mbox
operator|=
name|index
argument_list|(
name|mbox
argument_list|,
literal|'.'
argument_list|)
condition|;
control|)
operator|*
name|mbox
operator|++
operator|=
literal|' '
expr_stmt|;
return|return
name|buffer
return|;
block|}
if|if
condition|(
operator|!
name|get_x400_comp
argument_list|(
name|mbox
argument_list|,
literal|"/S="
argument_list|,
name|surname
argument_list|)
condition|)
return|return
name|NULLCP
return|;
if|if
condition|(
name|get_x400_comp
argument_list|(
name|mbox
argument_list|,
literal|"/G="
argument_list|,
name|given
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s %s"
argument_list|,
name|given
argument_list|,
name|surname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|surname
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|get_x400_comp
parameter_list|(
name|mbox
parameter_list|,
name|key
parameter_list|,
name|buffer
parameter_list|)
name|char
modifier|*
name|mbox
decl_stmt|,
decl|*
name|key
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
end_function

begin_block
block|{
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|idx
operator|=
name|stringdex
argument_list|(
name|key
argument_list|,
name|mbox
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|!
operator|(
name|cp
operator|=
name|index
argument_list|(
name|mbox
operator|+=
name|idx
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%*.*s"
argument_list|,
name|cp
operator|-
name|mbox
argument_list|,
name|cp
operator|-
name|mbox
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_function
name|struct
name|format
modifier|*
name|fmtscan
parameter_list|(
name|format
parameter_list|,
name|scanl
parameter_list|,
name|width
parameter_list|,
name|dat
parameter_list|)
name|struct
name|format
modifier|*
name|format
decl_stmt|;
name|char
modifier|*
name|scanl
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|dat
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|scanl
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
init|=
name|scanl
operator|+
name|width
operator|-
literal|1
decl_stmt|;
specifier|register
name|struct
name|format
modifier|*
name|fmt
init|=
name|format
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
init|=
name|NULLCP
decl_stmt|;
specifier|register
name|int
name|value
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|comp
modifier|*
name|comp
decl_stmt|;
specifier|register
name|struct
name|tws
modifier|*
name|tws
decl_stmt|;
specifier|register
name|struct
name|mailname
modifier|*
name|mn
decl_stmt|;
name|int
name|ljust
decl_stmt|;
name|long
name|l
decl_stmt|;
name|char
modifier|*
name|savestr
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
switch|switch
condition|(
name|fmt
operator|->
name|f_type
condition|)
block|{
case|case
name|FT_COMP
case|:
name|PUTS
argument_list|(
name|cp
argument_list|,
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COMPF
case|:
name|PUTSF
argument_list|(
name|cp
argument_list|,
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
argument_list|,
name|fmt
operator|->
name|f_width
argument_list|,
name|fmt
operator|->
name|f_fill
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LIT
case|:
name|sp
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|FT_LITF
case|:
name|sp
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
name|ljust
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|fmt
operator|->
name|f_width
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
operator|-
name|i
expr_stmt|;
name|ljust
operator|++
expr_stmt|;
comment|/* XXX should do something with this */
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|&&
operator|--
name|i
operator|>=
literal|0
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|fmt
operator|->
name|f_fill
expr_stmt|;
break|break;
case|case
name|FT_STR
case|:
name|PUTS
argument_list|(
name|cp
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRF
case|:
name|PUTSF
argument_list|(
name|cp
argument_list|,
name|str
argument_list|,
name|fmt
operator|->
name|f_width
argument_list|,
name|fmt
operator|->
name|f_fill
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRFW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error (FT_STRFW)"
argument_list|)
expr_stmt|;
case|case
name|FT_NUM
case|:
name|PUTD
argument_list|(
name|cp
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_NUMF
case|:
name|PUTDF
argument_list|(
name|cp
argument_list|,
name|value
argument_list|,
name|fmt
operator|->
name|f_width
argument_list|,
name|fmt
operator|->
name|f_fill
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
operator|*
name|cp
operator|++
operator|=
name|fmt
operator|->
name|f_char
expr_stmt|;
break|break;
case|case
name|FT_DONE
case|:
goto|goto
name|finished
goto|;
case|case
name|FT_IF_S
case|:
if|if
condition|(
operator|!
operator|(
name|value
operator|=
operator|(
name|str
operator|&&
operator|*
name|str
operator|)
operator|)
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_S_NULL
case|:
if|if
condition|(
operator|!
operator|(
name|value
operator|=
operator|(
name|str
operator|==
name|NULLCP
operator|||
operator|*
name|str
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_V_EQ
case|:
if|if
condition|(
name|value
operator|!=
name|fmt
operator|->
name|f_value
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_V_NE
case|:
if|if
condition|(
name|value
operator|==
name|fmt
operator|->
name|f_value
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_V_GT
case|:
if|if
condition|(
name|value
operator|<=
name|fmt
operator|->
name|f_value
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_IF_MATCH
case|:
if|if
condition|(
operator|!
operator|(
name|value
operator|=
operator|(
name|str
operator|&&
name|match
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
operator|)
operator|)
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_V_MATCH
case|:
if|if
condition|(
name|str
condition|)
name|value
operator|=
name|match
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FT_IF_AMATCH
case|:
if|if
condition|(
operator|!
operator|(
name|value
operator|=
operator|(
name|str
operator|&&
name|uprf
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
operator|)
operator|)
condition|)
block|{
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|FT_V_AMATCH
case|:
name|value
operator|=
name|uprf
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_S_NONNULL
case|:
name|value
operator|=
operator|(
name|str
operator|!=
name|NULLCP
operator|&&
operator|*
name|str
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FT_S_NULL
case|:
name|value
operator|=
operator|(
name|str
operator|==
name|NULLCP
operator|||
operator|*
name|str
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FT_V_EQ
case|:
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_value
operator|==
name|value
operator|)
expr_stmt|;
break|break;
case|case
name|FT_V_NE
case|:
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_value
operator|!=
name|value
operator|)
expr_stmt|;
break|break;
case|case
name|FT_V_GT
case|:
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_value
operator|>
name|value
operator|)
expr_stmt|;
break|break;
case|case
name|FT_GOTO
case|:
name|fmt
operator|+=
name|fmt
operator|->
name|f_skip
expr_stmt|;
continue|continue;
case|case
name|FT_NOP
case|:
break|break;
case|case
name|FT_LS_COMP
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
expr_stmt|;
break|break;
case|case
name|FT_LS_LIT
case|:
name|str
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
break|break;
case|case
name|FT_LS_GETENV
case|:
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|getenv
argument_list|(
name|fmt
operator|->
name|f_text
argument_list|)
operator|)
condition|)
name|str
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|FT_LS_MFIND
case|:
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|m_find
argument_list|(
name|fmt
operator|->
name|f_text
argument_list|)
operator|)
condition|)
name|str
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|FT_LS_TRIM
case|:
if|if
condition|(
name|str
condition|)
block|{
specifier|register
name|char
modifier|*
name|xp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
name|ljust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|fmt
operator|->
name|f_width
operator|)
operator|<
literal|0
condition|)
block|{
name|i
operator|=
operator|-
name|i
expr_stmt|;
name|ljust
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ljust
operator|&&
name|i
operator|>
literal|0
operator|&&
name|strlen
argument_list|(
name|str
argument_list|)
operator|>
name|i
condition|)
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xp
operator|=
name|str
expr_stmt|;
name|xp
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|xp
operator|>
name|str
operator|&&
name|isspace
argument_list|(
operator|*
name|xp
argument_list|)
condition|)
operator|*
name|xp
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ljust
operator|&&
name|i
operator|>
literal|0
operator|&&
name|strlen
argument_list|(
name|str
argument_list|)
operator|>
name|i
condition|)
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
name|i
expr_stmt|;
block|}
break|break;
case|case
name|FT_LV_COMPFLAG
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_flags
expr_stmt|;
break|break;
case|case
name|FT_LV_COMP
case|:
name|value
operator|=
operator|(
name|comp
operator|=
name|fmt
operator|->
name|f_comp
operator|)
operator|->
name|c_text
condition|?
name|atoi
argument_list|(
name|comp
operator|->
name|c_text
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|FT_LV_LIT
case|:
name|value
operator|=
name|fmt
operator|->
name|f_value
expr_stmt|;
break|break;
case|case
name|FT_LV_DAT
case|:
name|value
operator|=
name|dat
index|[
name|fmt
operator|->
name|f_value
index|]
expr_stmt|;
break|break;
case|case
name|FT_LV_STRLEN
case|:
name|value
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_CHAR_LEFT
case|:
name|value
operator|=
name|width
operator|-
operator|(
name|cp
operator|-
name|scanl
operator|)
expr_stmt|;
break|break;
case|case
name|FT_LV_PLUS_L
case|:
name|value
operator|+=
name|fmt
operator|->
name|f_value
expr_stmt|;
break|break;
case|case
name|FT_LV_MINUS_L
case|:
name|value
operator|=
name|fmt
operator|->
name|f_value
operator|-
name|value
expr_stmt|;
break|break;
case|case
name|FT_LV_DIVIDE_L
case|:
if|if
condition|(
name|fmt
operator|->
name|f_value
condition|)
name|value
operator|=
name|value
operator|/
name|fmt
operator|->
name|f_value
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FT_LV_MODULO_L
case|:
if|if
condition|(
name|fmt
operator|->
name|f_value
condition|)
name|value
operator|=
name|value
operator|%
name|fmt
operator|->
name|f_value
expr_stmt|;
else|else
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FT_SAVESTR
case|:
name|savestr
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|FT_LV_SEC
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_sec
expr_stmt|;
break|break;
case|case
name|FT_LV_MIN
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_min
expr_stmt|;
break|break;
case|case
name|FT_LV_HOUR
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_hour
expr_stmt|;
break|break;
case|case
name|FT_LV_MDAY
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mday
expr_stmt|;
break|break;
case|case
name|FT_LV_MON
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mon
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|FT_LS_MONTH
case|:
name|str
operator|=
name|tw_moty
index|[
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mon
index|]
expr_stmt|;
break|break;
case|case
name|FT_LS_LMONTH
case|:
name|str
operator|=
name|lmonth
index|[
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_mon
index|]
expr_stmt|;
break|break;
case|case
name|FT_LS_ZONE
case|:
name|str
operator|=
name|dtwszone
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_YEAR
case|:
ifndef|#
directive|ifndef
name|YEARMOD
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_year
expr_stmt|;
else|#
directive|else
comment|/* YEARMOD */
name|value
operator|=
operator|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_year
operator|)
operator|%
literal|100
expr_stmt|;
endif|#
directive|endif
comment|/* YEARMOD */
break|break;
case|case
name|FT_LV_WDAY
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
name|value
operator|=
name|tws
operator|->
name|tw_wday
expr_stmt|;
break|break;
case|case
name|FT_LS_DAY
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
name|str
operator|=
name|tw_dotw
index|[
name|tws
operator|->
name|tw_wday
index|]
expr_stmt|;
break|break;
case|case
name|FT_LS_WEEKDAY
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
name|str
operator|=
name|tw_ldotw
index|[
name|tws
operator|->
name|tw_wday
index|]
expr_stmt|;
break|break;
case|case
name|FT_LV_YDAY
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_yday
expr_stmt|;
break|break;
case|case
name|FT_LV_ZONE
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_zone
expr_stmt|;
break|break;
case|case
name|FT_LV_CLOCK
case|:
if|if
condition|(
operator|(
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_clock
operator|)
operator|==
literal|0
condition|)
name|value
operator|=
name|twclock
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_RCLOCK
case|:
if|if
condition|(
operator|(
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_clock
operator|)
operator|==
literal|0
condition|)
name|value
operator|=
name|twclock
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
name|value
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
operator|-
name|value
expr_stmt|;
break|break;
case|case
name|FT_LV_DAYF
case|:
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|tws
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|)
operator|->
name|tw_flags
operator|)
operator|&
operator|(
name|TW_SEXP
operator||
name|TW_SIMP
operator|)
operator|)
condition|)
name|set_dotw
argument_list|(
name|tws
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_flags
operator|&
name|TW_SDAY
condition|)
block|{
case|case
name|TW_SEXP
case|:
name|value
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TW_SIMP
case|:
name|value
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|value
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|FT_LV_ZONEF
case|:
if|if
condition|(
operator|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_flags
operator|&
name|TW_SZONE
operator|)
operator|==
name|TW_SZEXP
condition|)
name|value
operator|=
literal|1
expr_stmt|;
else|else
name|value
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|FT_LV_DST
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
operator|->
name|tw_flags
operator|&
name|TW_DST
expr_stmt|;
break|break;
case|case
name|FT_LS_822DATE
case|:
name|str
operator|=
name|dasctime
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|,
name|TW_ZONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LS_PRETTY
case|:
name|str
operator|=
name|dasctime
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_tws
argument_list|,
name|TW_NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LS_PERS
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_pers
expr_stmt|;
break|break;
case|case
name|FT_LS_MBOX
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_mbox
expr_stmt|;
break|break;
case|case
name|FT_LS_HOST
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_host
expr_stmt|;
break|break;
case|case
name|FT_LS_PATH
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_path
expr_stmt|;
break|break;
case|case
name|FT_LS_GNAME
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_gname
expr_stmt|;
break|break;
case|case
name|FT_LS_NOTE
case|:
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_note
expr_stmt|;
break|break;
case|case
name|FT_LS_822ADDR
case|:
name|str
operator|=
name|adrformat
argument_list|(
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LV_HOSTTYPE
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_type
expr_stmt|;
break|break;
case|case
name|FT_LV_INGRPF
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_ingrp
expr_stmt|;
break|break;
case|case
name|FT_LV_NOHOSTF
case|:
name|value
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_nohost
expr_stmt|;
break|break;
case|case
name|FT_LS_ADDR
case|:
case|case
name|FT_LS_FRIENDLY
case|:
ifdef|#
directive|ifdef
name|BERK
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|->
name|m_mbox
expr_stmt|;
else|#
directive|else
comment|/* not BERK */
if|if
condition|(
operator|(
name|mn
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_mn
operator|)
operator|==
operator|&
name|fmt_mnull
condition|)
block|{
name|str
operator|=
name|fmt
operator|->
name|f_comp
operator|->
name|c_text
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fmt
operator|->
name|f_type
operator|==
name|FT_LS_ADDR
condition|)
goto|goto
name|unfriendly
goto|;
if|if
condition|(
operator|(
name|str
operator|=
name|mn
operator|->
name|m_pers
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|str
operator|=
name|mn
operator|->
name|m_note
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
name|str
operator|++
expr_stmt|;
name|sp
operator|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|')'
condition|)
block|{
operator|*
name|sp
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|sp
operator|>=
name|str
condition|)
if|if
condition|(
operator|*
name|sp
operator|==
literal|' '
condition|)
operator|*
name|sp
operator|--
operator|=
literal|'\0'
expr_stmt|;
else|else
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|get_x400_friendly
argument_list|(
name|mn
operator|->
name|m_mbox
argument_list|,
name|buffer
argument_list|)
operator|)
condition|)
block|{
name|unfriendly
label|:
empty_stmt|;
switch|switch
condition|(
name|mn
operator|->
name|m_type
condition|)
block|{
case|case
name|LOCALHOST
case|:
name|str
operator|=
name|mn
operator|->
name|m_mbox
expr_stmt|;
break|break;
case|case
name|UUCPHOST
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s!%s"
argument_list|,
name|mn
operator|->
name|m_host
argument_list|,
name|mn
operator|->
name|m_mbox
argument_list|)
expr_stmt|;
name|str
operator|=
name|buffer
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|mn
operator|->
name|m_mbox
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s@%s"
argument_list|,
name|mn
operator|->
name|m_mbox
argument_list|,
name|mn
operator|->
name|m_host
argument_list|)
expr_stmt|;
name|str
operator|=
name|buffer
expr_stmt|;
block|}
else|else
name|str
operator|=
name|mn
operator|->
name|m_text
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* BERK */
break|break;
case|case
name|FT_LOCALDATE
case|:
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|comp
operator|->
name|c_tws
operator|->
name|tw_clock
operator|)
operator|==
literal|0
condition|)
name|l
operator|=
name|twclock
argument_list|(
name|comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
name|tws
operator|=
name|dlocaltime
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
operator|*
name|comp
operator|->
name|c_tws
operator|=
operator|*
name|tws
expr_stmt|;
break|break;
case|case
name|FT_GMTDATE
case|:
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|comp
operator|->
name|c_tws
operator|->
name|tw_clock
operator|)
operator|==
literal|0
condition|)
name|l
operator|=
name|twclock
argument_list|(
name|comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
name|tws
operator|=
name|dgmtime
argument_list|(
operator|&
name|l
argument_list|)
expr_stmt|;
operator|*
name|comp
operator|->
name|c_tws
operator|=
operator|*
name|tws
expr_stmt|;
break|break;
case|case
name|FT_PARSEDATE
case|:
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|comp
operator|->
name|c_text
operator|)
operator|&&
operator|(
name|tws
operator|=
name|dparsetime
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
operator|*
name|comp
operator|->
name|c_tws
operator|=
operator|*
name|tws
expr_stmt|;
name|comp
operator|->
name|c_flags
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|->
name|c_flags
operator|>=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
operator|->
name|c_tws
argument_list|,
sizeof|sizeof
expr|*
name|comp
operator|->
name|c_tws
argument_list|)
expr_stmt|;
name|comp
operator|->
name|c_flags
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|FT_FORMATADDR
case|:
comment|/* hook for custom address list formatting (see replsbr.c) */
name|str
operator|=
name|formataddr
argument_list|(
name|savestr
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_PUTADDR
case|:
comment|/* output the str register as an address component, 	     * splitting it into multiple lines if necessary.  The 	     * value reg. contains the max line length.  The lit. 	     * field may contain a string to prepend to the result 	     * (e.g., "To: ") 	     */
block|{
specifier|register
name|char
modifier|*
name|lp
init|=
name|str
decl_stmt|;
specifier|register
name|int
name|indent
decl_stmt|;
specifier|register
name|int
name|wid
init|=
name|value
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|lastb
decl_stmt|;
name|sp
operator|=
name|fmt
operator|->
name|f_text
expr_stmt|;
name|indent
operator|=
name|strlen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|wid
operator|-=
name|indent
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|&&
name|cp
operator|<
name|ep
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|wid
condition|)
block|{
comment|/* try to break at a comma; failing that, break at a 		 * space, failing that, just split the line. 		 */
name|lastb
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|lp
operator|+
name|wid
expr_stmt|;
while|while
condition|(
name|sp
operator|>
name|lp
operator|&&
operator|(
name|c
operator|=
operator|*
operator|--
name|sp
operator|)
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|!
name|lastb
operator|&&
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
name|lastb
operator|=
name|sp
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|lp
condition|)
if|if
condition|(
operator|!
operator|(
name|sp
operator|=
name|lastb
operator|)
condition|)
name|sp
operator|=
name|lp
operator|+
name|wid
operator|-
literal|1
expr_stmt|;
name|len
operator|-=
name|sp
operator|-
name|lp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
operator|&&
name|lp
operator|<=
name|sp
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|lp
operator|++
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indent
init|;
name|cp
operator|<
name|ep
operator|&&
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|lp
argument_list|)
condition|)
name|lp
operator|++
operator|,
name|len
operator|--
expr_stmt|;
block|}
name|PUTS
argument_list|(
name|cp
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FT_PARSEADDR
case|:
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|c_mn
operator|!=
operator|&
name|fmt_mnull
condition|)
name|mnfree
argument_list|(
name|comp
operator|->
name|c_mn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|comp
operator|->
name|c_text
operator|)
operator|&&
operator|(
name|sp
operator|=
name|getname
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
operator|(
name|mn
operator|=
name|getm
argument_list|(
name|sp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|fmt_norm
argument_list|,
name|NULLCP
argument_list|)
operator|)
condition|)
block|{
name|comp
operator|->
name|c_mn
operator|=
name|mn
expr_stmt|;
while|while
condition|(
name|getname
argument_list|(
literal|""
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getname
argument_list|(
literal|""
argument_list|)
condition|)
comment|/* XXX */
empty_stmt|;
name|comp
operator|->
name|c_mn
operator|=
operator|&
name|fmt_mnull
expr_stmt|;
block|}
break|break;
case|case
name|FT_MYMBOX
case|:
comment|/* 	     * if there's no component, we say true.  Otherwise we 	     * say "true" only if we can parse the address and it 	     * matches one of our addresses. 	     */
name|comp
operator|=
name|fmt
operator|->
name|f_comp
expr_stmt|;
if|if
condition|(
name|comp
operator|->
name|c_mn
operator|!=
operator|&
name|fmt_mnull
condition|)
name|mnfree
argument_list|(
name|comp
operator|->
name|c_mn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|comp
operator|->
name|c_text
operator|)
operator|&&
operator|(
name|sp
operator|=
name|getname
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
operator|(
name|mn
operator|=
name|getm
argument_list|(
name|sp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|NULLCP
argument_list|)
operator|)
condition|)
block|{
name|comp
operator|->
name|c_mn
operator|=
name|mn
expr_stmt|;
name|comp
operator|->
name|c_flags
operator|=
name|ismymbox
argument_list|(
name|mn
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
operator|=
name|getname
argument_list|(
name|sp
argument_list|)
condition|)
if|if
condition|(
name|comp
operator|->
name|c_flags
operator|==
literal|0
operator|&&
operator|(
name|mn
operator|=
name|getm
argument_list|(
name|sp
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|AD_NAME
argument_list|,
name|NULLCP
argument_list|)
operator|)
condition|)
name|comp
operator|->
name|c_flags
operator||=
name|ismymbox
argument_list|(
name|mn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|getname
argument_list|(
literal|""
argument_list|)
condition|)
comment|/* XXX */
empty_stmt|;
name|comp
operator|->
name|c_flags
operator|=
operator|(
name|comp
operator|->
name|c_text
operator|==
literal|0
operator|)
expr_stmt|;
name|comp
operator|->
name|c_mn
operator|=
operator|&
name|fmt_mnull
expr_stmt|;
block|}
break|break;
case|case
name|FT_ADDTOSEQ
case|:
ifdef|#
directive|ifdef
name|LBL
comment|/* If we're working on a folder (as opposed to a file), add the 	     * current msg to sequence given in literal field.  Don't 	     * disturb string or value registers. 	     */
if|if
condition|(
name|fmt_current_folder
condition|)
operator|(
name|void
operator|)
name|m_seqadd
argument_list|(
name|fmt_current_folder
argument_list|,
name|fmt
operator|->
name|f_text
argument_list|,
name|dat
index|[
literal|0
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|fmt
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|JLR
name|finished
label|:
empty_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|format
operator|*
operator|)
literal|0
operator|)
return|;
else|#
directive|else
comment|/* JLR */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
name|fmt
operator|->
name|f_type
operator|!=
name|FT_DONE
condition|)
name|fmt
operator|++
expr_stmt|;
name|finished
label|:
empty_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|fmt
operator|->
name|f_value
condition|?
operator|++
name|fmt
else|:
operator|(
expr|struct
name|format
operator|*
operator|)
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* JLR */
block|}
end_function

end_unit

