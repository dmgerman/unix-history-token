begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to search a file for a pattern.  */
end_comment

begin_include
include|#
directive|include
file|"less.h"
end_include

begin_include
include|#
directive|include
file|"position.h"
end_include

begin_if
if|#
directive|if
name|REGCOMP
end_if

begin_include
include|#
directive|include
file|"regexp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|sigs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|how_search
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|caseless
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|linenums
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|jump_sline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Search for the n-th occurrence of a specified pattern,   * either forward or backward.  * Return the number of matches not yet found in this file  * (that is, n minus the number of matches found).  * Return -1 if the search should be aborted.  * Caller may continue the search in another file   * if less than n matches are found in this file.  */
end_comment

begin_function
name|public
name|int
name|search
parameter_list|(
name|search_type
parameter_list|,
name|pattern
parameter_list|,
name|n
parameter_list|)
name|int
name|search_type
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|POSITION
name|pos
decl_stmt|,
name|linepos
decl_stmt|,
name|oldpos
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|goforw
decl_stmt|;
specifier|register
name|int
name|want_match
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|linenum
decl_stmt|;
name|int
name|line_match
decl_stmt|;
specifier|static
name|int
name|is_caseless
decl_stmt|;
if|#
directive|if
name|RECOMP
name|char
modifier|*
name|re_comp
parameter_list|()
function_decl|;
name|PARG
name|parg
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|REGCMP
name|char
modifier|*
name|regcmp
parameter_list|()
function_decl|;
specifier|static
name|char
modifier|*
name|cpattern
init|=
name|NULL
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|REGCOMP
specifier|static
name|struct
name|regexp
modifier|*
name|regpattern
init|=
name|NULL
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|lpbuf
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|last_pattern
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Extract flags and type of search. 	 */
name|goforw
operator|=
operator|(
name|SRCH_DIR
argument_list|(
name|search_type
argument_list|)
operator|==
name|SRCH_FORW
operator|)
expr_stmt|;
name|want_match
operator|=
operator|!
operator|(
name|search_type
operator|&
name|SRCH_NOMATCH
operator|)
expr_stmt|;
if|if
condition|(
name|pattern
operator|!=
name|NULL
operator|&&
operator|*
name|pattern
operator|!=
literal|'\0'
operator|&&
operator|(
name|is_caseless
operator|=
name|caseless
operator|)
condition|)
block|{
comment|/* 		 * Search will ignore case, unless 		 * there are any uppercase letters in the pattern. 		 */
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|)
block|{
name|is_caseless
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|RECOMP
comment|/* 	 * (re_comp handles a null pattern internally,  	 *  so there is no need to check for a null pattern here.) 	 */
if|if
condition|(
operator|(
name|parg
operator|.
name|p_string
operator|=
name|re_comp
argument_list|(
name|pattern
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s"
argument_list|,
operator|&
name|parg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|#
directive|else
if|#
directive|if
name|REGCMP
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * A null pattern means use the previous pattern. 		 * The compiled previous pattern is in cpattern, so just use it. 		 */
if|if
condition|(
name|cpattern
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Otherwise compile the given pattern. 		 */
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|regcmp
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid pattern"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cpattern
argument_list|)
expr_stmt|;
name|cpattern
operator|=
name|s
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|REGCOMP
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * A null pattern means use the previous pattern. 		 * The compiled previous pattern is in regpattern,  		 * so just use it. 		 */
if|if
condition|(
name|regpattern
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * Otherwise compile the given pattern. 		 */
name|struct
name|regexp
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|regcomp
argument_list|(
name|pattern
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid pattern"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|regpattern
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|regpattern
argument_list|)
expr_stmt|;
name|regpattern
operator|=
name|s
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|pattern
operator|==
name|NULL
operator|||
operator|*
name|pattern
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Null pattern means use the previous pattern. 		 */
if|if
condition|(
name|last_pattern
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No previous regular expression"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pattern
operator|=
name|last_pattern
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|lpbuf
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|last_pattern
operator|=
name|lpbuf
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Figure out where to start the search. 	 */
if|if
condition|(
name|empty_screen
argument_list|()
condition|)
block|{
comment|/* 		 * Start at the beginning (or end) of the file. 		 * (The empty_screen() case is mainly for  		 * command line initiated searches; 		 * for example, "+/xyz" on the command line.) 		 */
if|if
condition|(
name|goforw
condition|)
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
else|else
block|{
name|pos
operator|=
name|ch_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
name|pos
operator|=
name|ch_zero
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|how_search
condition|)
block|{
if|if
condition|(
name|goforw
condition|)
name|linenum
operator|=
name|BOTTOM_PLUS_ONE
expr_stmt|;
else|else
name|linenum
operator|=
name|TOP
expr_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linenum
operator|=
name|adjsline
argument_list|(
name|jump_sline
argument_list|)
expr_stmt|;
name|pos
operator|=
name|position
argument_list|(
name|linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|goforw
condition|)
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 		 * Can't find anyplace to start searching from. 		 */
name|error
argument_list|(
literal|"Nothing to search"
argument_list|,
name|NULL_PARG
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|linenum
operator|=
name|find_linenum
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get lines until we find a matching one or  		 * until we hit end-of-file (or beginning-of-file  		 * if we're going backwards). 		 */
if|if
condition|(
name|sigs
condition|)
comment|/* 			 * A signal aborts the search. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|goforw
condition|)
block|{
comment|/* 			 * Read the next line, and save the  			 * starting position of that line in linepos. 			 */
name|linepos
operator|=
name|pos
expr_stmt|;
name|pos
operator|=
name|forw_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read the previous line and save the 			 * starting position of that line in linepos. 			 */
name|pos
operator|=
name|back_raw_line
argument_list|(
name|pos
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|linepos
operator|=
name|pos
expr_stmt|;
if|if
condition|(
name|linenum
operator|!=
literal|0
condition|)
name|linenum
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|==
name|NULL_POSITION
condition|)
block|{
comment|/* 			 * We hit EOF/BOF without a match. 			 */
return|return
operator|(
name|n
operator|)
return|;
block|}
comment|/* 		 * If we're using line numbers, we might as well 		 * remember the information we have now (the position 		 * and line number of the current line). 		 * Don't do it for every line because it slows down 		 * the search.  Remember the line number only if 		 * we're "far" from the last place we remembered it. 		 */
if|if
condition|(
name|linenums
operator|&&
name|abs
argument_list|(
name|pos
operator|-
name|oldpos
argument_list|)
operator|>
literal|1024
condition|)
block|{
name|add_lnum
argument_list|(
name|linenum
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|oldpos
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|is_caseless
condition|)
block|{
comment|/* 			 * If this is a caseless search, convert  			 * uppercase in the input line to lowercase. 			 * While we're at it, remove any backspaces 			 * along with the preceding char. 			 * This allows us to match text which is  			 * underlined or overstruck. 			 */
for|for
control|(
name|p
operator|=
name|q
operator|=
name|line
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|)
comment|/* Convert uppercase to lowercase. */
operator|*
name|q
operator|=
operator|*
name|p
operator|+
literal|'a'
operator|-
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|>
name|line
operator|&&
operator|*
name|p
operator|==
literal|'\b'
condition|)
comment|/* Delete BS and preceding char. */
name|q
operator|-=
literal|2
expr_stmt|;
else|else
comment|/* Otherwise, just copy. */
operator|*
name|q
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
comment|/* 		 * Test the next line to see if we have a match. 		 * This is done in a variety of ways, depending 		 * on what pattern matching functions are available. 		 */
if|#
directive|if
name|REGCMP
name|line_match
operator|=
operator|(
name|regex
argument_list|(
name|cpattern
argument_list|,
name|line
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|RECOMP
name|line_match
operator|=
operator|(
name|re_exec
argument_list|(
name|line
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|REGCOMP
name|line_match
operator|=
name|regexec
argument_list|(
name|regpattern
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|#
directive|else
name|line_match
operator|=
name|match
argument_list|(
name|pattern
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 		 * We are successful if want_match and line_match are 		 * both true (want a match and got it), 		 * or both false (want a non-match and got it). 		 */
if|if
condition|(
operator|(
operator|(
name|want_match
operator|&&
name|line_match
operator|)
operator|||
operator|(
operator|!
name|want_match
operator|&&
operator|!
name|line_match
operator|)
operator|)
operator|&&
operator|--
name|n
operator|<=
literal|0
condition|)
comment|/* 			 * Found the line. 			 */
break|break;
block|}
name|jump_loc
argument_list|(
name|linepos
argument_list|,
name|jump_sline
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
operator|!
name|REGCMP
operator|)
operator|&&
operator|(
operator|!
name|RECOMP
operator|)
operator|&&
operator|(
operator|!
name|REGCOMP
operator|)
end_if

begin_comment
comment|/*  * We have neither regcmp() nor re_comp().  * We use this function to do simple pattern matching.  * It supports no metacharacters like *, etc.  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|pattern
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
for|for
control|(
init|;
operator|*
name|buf
operator|!=
literal|'\0'
condition|;
name|buf
operator|++
control|)
block|{
for|for
control|(
name|pp
operator|=
name|pattern
operator|,
name|lp
operator|=
name|buf
init|;
operator|*
name|pp
operator|==
operator|*
name|lp
condition|;
name|pp
operator|++
operator|,
name|lp
operator|++
control|)
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
operator|||
operator|*
name|lp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|pp
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

