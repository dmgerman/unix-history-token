begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* popser.c - the POP service */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"@(#)$Id: popser.c,v 1.31 1993/08/25 17:23:14 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MPOP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_include
include|#
directive|include
file|"../h/formatsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/scansbr.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPOP */
end_comment

begin_include
include|#
directive|include
file|"../zotnet/bboards.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KPOP
end_ifdef

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KPOP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS5 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SHADOW
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHADOW */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|NVEC
value|5
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|POPSERVICE
end_ifndef

begin_define
define|#
directive|define
name|POPSERVICE
value|"pop"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|myhost
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|POP2
end_ifndef

begin_enum
specifier|static
enum|enum
name|state
block|{
name|auth1
block|,
name|auth2
block|,
name|trans
block|,
name|update
block|,
name|halt
block|,
name|error
block|}
name|mystate
enum|;
end_enum

begin_else
else|#
directive|else
end_else

begin_enum
specifier|static
enum|enum
name|state
block|{
name|auth1
block|,
name|auth2
block|,
name|trans
block|,
name|mbox
block|,
name|item
block|,
name|ack
block|,
name|update
block|,
name|halt
block|,
name|error
block|}
name|mystate
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|user
argument_list|()
decl_stmt|,
name|pass
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_expr_stmt
specifier|static
name|isguest
argument_list|()
operator|,
name|getbbmax
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MPOP
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|xtnd1
argument_list|()
decl_stmt|,
name|xtnd2
argument_list|()
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|xtnd1
argument_list|()
decl_stmt|,
name|xtnd2
argument_list|()
decl_stmt|,
name|xtnd3
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPOP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BPOP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RPOP
end_ifdef

begin_function_decl
specifier|static
name|int
name|rpop
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RPOP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|APOP
end_ifdef

begin_function_decl
specifier|static
name|int
name|apop
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|status
argument_list|()
decl_stmt|,
name|list
argument_list|()
decl_stmt|,
name|retrieve
argument_list|()
decl_stmt|,
name|delete
argument_list|()
decl_stmt|,
name|reset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|top
argument_list|()
decl_stmt|,
name|last
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_function_decl
specifier|static
name|int
name|xtnd
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BPOP */
end_comment

begin_function_decl
specifier|static
name|int
name|quit
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|POP2
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|helo
argument_list|()
decl_stmt|,
name|rdp2
argument_list|()
decl_stmt|,
name|acks
argument_list|()
decl_stmt|,
name|ack2
argument_list|()
decl_stmt|,
name|fold
argument_list|()
decl_stmt|,
name|nack
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POP2 */
end_comment

begin_struct
specifier|static
struct|struct
name|vector
block|{
name|char
modifier|*
name|v_cmd
decl_stmt|;
name|int
name|v_min
decl_stmt|,
name|v_max
decl_stmt|;
name|int
function_decl|(
modifier|*
name|v_vec
function_decl|)
parameter_list|()
function_decl|;
name|enum
name|state
name|v_valid
decl_stmt|;
name|enum
name|state
name|v_win
decl_stmt|,
name|v_lose
decl_stmt|;
block|}
name|vectors
index|[]
init|=
block|{
literal|"user"
block|,
literal|1
block|,
literal|1
block|,
name|user
block|,
name|auth1
block|,
name|auth2
block|,
name|auth1
block|,
literal|"pass"
block|,
literal|1
block|,
literal|1
block|,
name|pass
block|,
name|auth2
block|,
name|trans
block|,
name|auth1
block|,
ifdef|#
directive|ifdef
name|RPOP
literal|"rpop"
block|,
literal|1
block|,
literal|1
block|,
name|rpop
block|,
name|auth2
block|,
name|trans
block|,
name|auth1
block|,
endif|#
directive|endif
comment|/* RPOP */
ifdef|#
directive|ifdef
name|APOP
literal|"apop"
block|,
literal|2
block|,
literal|2
block|,
name|apop
block|,
name|auth1
block|,
name|trans
block|,
name|auth1
block|,
endif|#
directive|endif
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|auth1
block|,
name|halt
block|,
name|halt
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|auth2
block|,
name|halt
block|,
name|halt
block|,
literal|"stat"
block|,
literal|0
block|,
literal|0
block|,
name|status
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"list"
block|,
literal|0
block|,
literal|1
block|,
name|list
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"retr"
block|,
literal|1
block|,
literal|1
block|,
name|retrieve
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"dele"
block|,
literal|1
block|,
literal|1
block|,
name|delete
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"noop"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"rset"
block|,
literal|0
block|,
literal|0
block|,
name|reset
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"top"
block|,
literal|2
block|,
literal|2
block|,
name|top
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
literal|"last"
block|,
literal|0
block|,
literal|0
block|,
name|last
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
ifdef|#
directive|ifdef
name|BPOP
ifndef|#
directive|ifndef
name|MPOP
literal|"xtnd"
block|,
literal|1
block|,
literal|2
block|,
name|xtnd
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
else|#
directive|else
literal|"xtnd"
block|,
literal|1
block|,
literal|3
block|,
name|xtnd
block|,
name|trans
block|,
name|trans
block|,
name|trans
block|,
endif|#
directive|endif
comment|/* MPOP */
endif|#
directive|endif
comment|/* BPOP */
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|quit
block|,
name|trans
block|,
name|halt
block|,
name|halt
block|,
ifdef|#
directive|ifdef
name|POP2
literal|"helo"
block|,
literal|2
block|,
literal|2
block|,
name|helo
block|,
name|auth1
block|,
name|mbox
block|,
name|auth1
block|,
literal|"fold"
block|,
literal|1
block|,
literal|1
block|,
name|fold
block|,
name|mbox
block|,
name|mbox
block|,
name|mbox
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|quit
block|,
name|mbox
block|,
name|halt
block|,
name|halt
block|,
literal|"read"
block|,
literal|0
block|,
literal|1
block|,
name|rdp2
block|,
name|mbox
block|,
name|item
block|,
name|error
block|,
literal|"fold"
block|,
literal|1
block|,
literal|1
block|,
name|fold
block|,
name|item
block|,
name|mbox
block|,
name|mbox
block|,
literal|"read"
block|,
literal|0
block|,
literal|1
block|,
name|rdp2
block|,
name|item
block|,
name|item
block|,
name|error
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|quit
block|,
name|item
block|,
name|halt
block|,
name|halt
block|,
literal|"retr"
block|,
literal|0
block|,
literal|0
block|,
name|retrieve
block|,
name|item
block|,
name|ack
block|,
name|error
block|,
literal|"acks"
block|,
literal|0
block|,
literal|0
block|,
name|ack2
block|,
name|ack
block|,
name|item
block|,
name|error
block|,
literal|"ackd"
block|,
literal|0
block|,
literal|0
block|,
name|ack2
block|,
name|ack
block|,
name|item
block|,
name|error
block|,
literal|"nack"
block|,
literal|0
block|,
literal|0
block|,
name|rdp2
block|,
name|ack
block|,
name|item
block|,
name|error
block|,
literal|"quit"
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|ack
block|,
name|halt
block|,
name|halt
block|,
endif|#
directive|endif
comment|/* POP2 */
name|NULL
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|vector
modifier|*
name|getvector
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POP2
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pop2
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current pop2 msg, or NOTOK if pop3 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POP2 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DPOP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pop_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pop_gid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPOP */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rproto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|server
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|timestamp
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|username
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|maildrop
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|mtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lastseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rmsgs
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|xtnded
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|guest_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|guest_gid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bboard
modifier|*
name|BBhead
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bboard
modifier|*
name|BBtail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|BBtime
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|bboard
modifier|*
name|getbbaux
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BPOP */
end_comment

begin_struct
struct|struct
name|Msg
block|{
comment|/* Msgs[0] contains info for entire maildrop */
name|struct
name|drop
name|m_drop
decl_stmt|;
define|#
directive|define
name|m_id
value|m_drop.d_id
define|#
directive|define
name|m_size
value|m_drop.d_size
define|#
directive|define
name|m_last
value|m_drop.d_start
comment|/* Msgs[i = 0] */
define|#
directive|define
name|m_start
value|m_drop.d_start
comment|/* Msgs[i> 0] */
define|#
directive|define
name|m_stop
value|m_drop.d_stop
name|unsigned
name|m_flags
decl_stmt|;
define|#
directive|define
name|MNULL
value|0x00
define|#
directive|define
name|MDELE
value|0x01
define|#
directive|define
name|MREAD
value|0x02
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|nMsgs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Msg
modifier|*
name|Msgs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nmsgs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dmsgs
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MPOP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|_sc_width
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nfs
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPOP */
end_comment

begin_define
define|#
directive|define
name|TRM
value|"."
end_define

begin_define
define|#
directive|define
name|TRMLEN
value|(sizeof TRM - 1)
end_define

begin_define
define|#
directive|define
name|IAC
value|255
end_define

begin_function_decl
specifier|static
name|TYPESIG
name|pipeser
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|padvise
argument_list|()
decl_stmt|,
name|padios
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|crypt
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|POPUUMBOX
end_ifdef

begin_define
define|#
directive|define
name|MBX_READ
value|pmbx_read
end_define

begin_function_decl
specifier|static
name|int
name|pmbx_read
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_copy
argument_list|()
decl_stmt|,
modifier|*
name|p_copyin
argument_list|()
decl_stmt|,
modifier|*
name|p_nextword
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|p_cmatch
argument_list|()
operator|,
name|p_isdate
argument_list|()
operator|,
name|p_ishead
argument_list|()
operator|,
name|p_parse
argument_list|()
operator|,
name|any
argument_list|()
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MBX_READ
value|mbx_read
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|mbx_read
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|setup
argument_list|()
decl_stmt|,
name|setupaux
argument_list|()
decl_stmt|,
name|read_map
argument_list|()
decl_stmt|,
name|read_file
argument_list|()
decl_stmt|,
name|pmbx_size
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|quitaux
argument_list|()
decl_stmt|,
name|quitfile
argument_list|()
decl_stmt|,
name|respond
argument_list|()
decl_stmt|,
name|getline
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|m_gMsgs
argument_list|()
operator|,
name|multiline
argument_list|()
operator|,
name|multiend
argument_list|()
operator|,
name|putline
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_macro
name|popinit
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BPOP
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_INFO
argument_list|,
literal|"initialize list of BBoards"
argument_list|)
expr_stmt|;
name|BBhead
operator|=
name|BBtail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|getbbaux
argument_list|(
name|NULLCP
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* BPOP */
block|}
end_block

begin_macro
name|popassert
argument_list|()
end_macro

begin_block
block|{
ifdef|#
directive|ifdef
name|BPOP
specifier|register
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|BBtime
operator|==
name|getbbtime
argument_list|()
condition|)
return|return;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_INFO
argument_list|,
literal|"list of BBoards has changed"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|BBhead
init|;
name|bb
condition|;
name|bb
operator|=
name|bp
control|)
block|{
name|bp
operator|=
name|bb
operator|->
name|bb_next
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_name
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_file
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_archive
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_archive
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_info
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_map
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_passwd
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_date
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_addr
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_request
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|bb_relay
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_relay
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb
operator|->
name|bb_aka
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
operator|->
name|bb_aka
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb
operator|->
name|bb_leader
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
operator|->
name|bb_leader
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bb
operator|->
name|bb_dist
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
operator|->
name|bb_dist
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb
argument_list|)
expr_stmt|;
block|}
name|BBhead
operator|=
name|BBtail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|getbbaux
argument_list|(
name|NULLCP
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* BPOP */
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KPOP
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|kusername
decl_stmt|;
end_decl_stmt

begin_macro
name|kpop
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|principal
argument_list|,
argument|rhost
argument_list|,
argument|auth
argument_list|)
end_macro

begin_decl_stmt
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|principal
decl_stmt|,
modifier|*
name|rhost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|auth
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* KPOP */
end_comment

begin_macro
name|pop
argument_list|(
argument|in
argument_list|,
argument|out
argument_list|,
argument|priv
argument_list|,
argument|rhost
argument_list|)
end_macro

begin_decl_stmt
name|int
name|in
decl_stmt|,
name|out
decl_stmt|,
name|priv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rhost
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KPOP */
end_comment

begin_block
block|{
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|vec
index|[
name|NVEC
operator|+
literal|1
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DPOP
argument_list|)
operator|||
name|defined
argument_list|(
name|BPOP
argument_list|)
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
comment|/* defined (DPOP) || defined (BPOP) */
specifier|register
name|struct
name|vector
modifier|*
name|v
decl_stmt|;
name|m_foil
argument_list|(
name|NULLCP
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|myname
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|rhost
expr_stmt|;
ifdef|#
directive|ifdef
name|KPOP
name|rproto
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|server
argument_list|,
literal|"%s KPOP server"
argument_list|,
name|myhost
argument_list|)
expr_stmt|;
else|#
directive|else
name|rproto
operator|=
name|priv
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|server
argument_list|,
literal|"%s server"
argument_list|,
name|priv
condition|?
literal|"RPOP"
else|:
literal|"POP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KPOP */
if|if
condition|(
operator|(
name|input
operator|=
name|fdopen
argument_list|(
name|in
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|output
operator|=
name|fdopen
argument_list|(
name|out
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* you lose big */
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"%s loses on initialization"
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipeser
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KPOP
if|if
condition|(
name|principal
operator|==
name|NULLCP
condition|)
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"Authentication failed: "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|krb_err_txt
index|[
name|auth
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|kusername
operator|=
name|principal
expr_stmt|;
endif|#
directive|endif
comment|/* KPOP */
ifdef|#
directive|ifdef
name|DPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|POPUID
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
name|setpwinfo
argument_list|(
name|pw
argument_list|,
name|POPDB
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"%s loses on DB initialization -- %s"
argument_list|,
name|server
argument_list|,
name|pw
condition|?
name|getbberr
argument_list|()
else|:
literal|"POP user-id unknown"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|pop_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
endif|#
directive|endif
comment|/* DPOP */
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|popbbuser
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_uid
condition|)
block|{
name|guest_uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|guest_gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
block|}
else|else
name|guest_uid
operator|=
name|guest_gid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BPOP */
block|{
name|long
name|clock
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|clock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|timestamp
argument_list|,
literal|"<%d.%ld@%s>"
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|clock
argument_list|,
name|myhost
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s ready %s"
argument_list|,
name|server
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
for|for
control|(
name|mystate
operator|=
name|auth1
init|;
name|mystate
operator|!=
name|halt
operator|&&
name|mystate
operator|!=
name|error
condition|;
control|)
switch|switch
condition|(
name|getline
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|input
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
if|if
condition|(
operator|(
name|v
operator|=
name|getvector
argument_list|(
name|buffer
argument_list|,
name|vec
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|mystate
operator|=
operator|(
name|v
operator|->
name|v_vec
condition|?
call|(
name|v
operator|->
name|v_vec
call|)
argument_list|(
name|vec
argument_list|)
else|:
name|respond
argument_list|(
name|OK
argument_list|,
name|NULLCP
argument_list|)
operator|)
operator|==
name|OK
condition|?
name|v
operator|->
name|v_win
else|:
name|v
operator|->
name|v_lose
expr_stmt|;
break|break;
case|case
name|NOTOK
case|:
case|case
name|DONE
case|:
name|mystate
operator|=
name|error
expr_stmt|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"%s signing off"
argument_list|,
name|server
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POP2
end_ifdef

begin_function
specifier|static
name|int
name|helo
parameter_list|(
name|vec
parameter_list|)
comment|/* sort of "user" and "pass" */
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|pop2
operator|=
literal|0
expr_stmt|;
comment|/* now we're talkin' pop2! */
name|make_lower
argument_list|(
name|username
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* helo user pass */
return|return
name|pass
argument_list|(
operator|++
name|vec
argument_list|)
return|;
comment|/* user pass */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|user
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|make_lower
argument_list|(
name|username
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KPOP
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|username
argument_list|,
name|kusername
argument_list|)
condition|)
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"Kerberos authentication succeeded. Send username as password (%s)"
argument_list|,
name|username
argument_list|)
return|;
else|else
block|{
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"Wrong username supplied (%s vs. %s)"
argument_list|,
name|kusername
argument_list|,
name|username
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
else|#
directive|else
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"password required for %s"
argument_list|,
name|username
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|pass
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|guest
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|SHADOW
specifier|register
name|struct
name|spwd
modifier|*
name|shpw
decl_stmt|;
endif|#
directive|endif
comment|/* SHADOW */
else|#
directive|else
comment|/* DPOP */
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
comment|/* DPOP */
ifdef|#
directive|ifdef
name|KPOP
ifndef|#
directive|ifndef
name|DPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|setup
argument_list|(
name|pw
argument_list|,
name|FALSE
argument_list|)
return|;
else|else
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no local password entry"
argument_list|)
return|;
else|#
directive|else
block|{
specifier|static
name|struct
name|bboard
name|entry
decl_stmt|;
specifier|static
name|char
name|entry_file
index|[
name|BUFSIZ
index|]
init|=
literal|"/usr/spool/pop"
decl_stmt|;
name|pw
operator|=
operator|&
name|entry
expr_stmt|;
name|pw
operator|->
name|bb_name
operator|=
name|username
expr_stmt|;
name|strcat
argument_list|(
name|entry_file
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|pw
operator|->
name|bb_file
operator|=
name|entry_file
expr_stmt|;
return|return
name|setup
argument_list|(
name|pw
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
endif|#
directive|endif
else|#
directive|else
comment|/* KPOP */
ifndef|#
directive|ifndef
name|DPOP
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|isguest
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
specifier|static
name|passwd
name|gw
decl_stmt|;
name|gw
operator|.
name|pw_name
operator|=
name|popbbuser
expr_stmt|;
name|gw
operator|.
name|pw_uid
operator|=
name|guest_uid
expr_stmt|;
name|pw
operator|=
operator|&
name|gw
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
name|guest
operator|=
literal|1
expr_stmt|;
goto|goto
name|anonymous
goto|;
block|}
endif|#
directive|endif
comment|/* BPOP */
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
ifndef|#
directive|ifndef
name|SHADOW
operator|||
operator|*
name|pw
operator|->
name|pw_passwd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
condition|)
block|{
else|#
directive|else
comment|/* SHADOW */
operator|||
operator|(
name|shpw
operator|=
name|getspnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|shpw
operator|->
name|sp_pwdp
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|shpw
operator|->
name|sp_pwdp
argument_list|)
argument_list|,
name|shpw
operator|->
name|sp_pwdp
argument_list|)
block|)
block|{
endif|#
directive|endif
comment|/* SHADOW */
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|pw
condition|?
name|pw
operator|->
name|pw_name
else|:
name|username
argument_list|,
name|pw
operator|&&
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
name|POPSERVICE
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
else|#
directive|else
comment|/* DPOP */
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|isguest
argument_list|()
condition|)
block|{
specifier|static
name|struct
name|bboard
name|gw
decl_stmt|;
name|gw
operator|.
name|bb_name
operator|=
name|popbbuser
expr_stmt|;
name|pw
operator|=
operator|&
name|gw
expr_stmt|;
name|guest
operator|=
literal|1
expr_stmt|;
goto|goto
name|anonymous
goto|;
block|}
endif|#
directive|endif
comment|/* BPOP */
if|if
condition|(
operator|(
operator|(
name|pw
operator|=
name|getbbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getbbaka
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|*
name|pw
operator|->
name|bb_passwd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|pw
operator|->
name|bb_passwd
argument_list|)
argument_list|,
name|pw
operator|->
name|bb_passwd
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|pw
condition|?
name|pw
operator|->
name|bb_name
else|:
name|username
argument_list|,
literal|0
argument_list|,
name|POPSERVICE
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* DPOP */
ifdef|#
directive|ifdef
name|BPOP
name|anonymous
label|:
empty_stmt|;
endif|#
directive|endif
comment|/* BPOP */
ifdef|#
directive|ifdef
name|TRUSTED
if|if
condition|(
name|trusted
argument_list|(
literal|1
argument_list|,
name|hostname
argument_list|,
name|NULLCP
argument_list|,
literal|0
argument_list|,
name|myhost
argument_list|,
ifndef|#
directive|ifndef
name|DPOP
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
else|#
directive|else
comment|/* DPOP */
name|pw
operator|->
name|bb_name
argument_list|,
literal|0
argument_list|,
endif|#
directive|endif
comment|/* DPOP */
name|POPSERVICE
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|setup
argument_list|(
name|pw
argument_list|,
name|guest
argument_list|)
return|;
endif|#
directive|endif
comment|/* KPOP */
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_expr_stmt
specifier|static
name|isguest
argument_list|()
block|{
name|int
name|i
block|;
specifier|register
name|char
operator|*
name|cp
block|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
block|;
specifier|register
name|FILE
operator|*
name|fp
block|;
if|if
condition|(
name|strcmp
argument_list|(
name|username
argument_list|,
name|popbbuser
argument_list|)
operator|||
operator|!
name|guest_uid
condition|)
return|return
name|FALSE
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|popbblist
operator|==
name|NULL
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|popbblist
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
end_if

begin_expr_stmt
name|i
operator|=
name|FALSE
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|hostname
condition|)
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|hostname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|i
return|;
end_return

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/* BPOP */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RPOP
end_ifdef

begin_function
unit|static
name|int
name|rpop
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
else|#
directive|else
comment|/* DPOP */
specifier|register
name|int
name|hostok
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
comment|/* DPOP */
ifndef|#
directive|ifndef
name|DPOP
if|if
condition|(
operator|!
name|rproto
operator|||
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|username
argument_list|,
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|==
name|NOTOK
operator|&&
name|chdir
argument_list|(
literal|"/"
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no remote directory"
argument_list|)
return|;
if|if
condition|(
name|ruserok
argument_list|(
name|hostname
argument_list|,
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
name|username
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
block|}
else|#
directive|else
comment|/* DPOP */
if|if
condition|(
operator|!
name|rproto
operator|||
operator|(
operator|(
name|pw
operator|=
name|getbbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getbbaka
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|username
argument_list|,
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"login incorrect"
argument_list|)
return|;
block|}
comment|/*  * hacked by Dave Cohrs Tue Feb  4 14:12:15 CST 1986  *   to allow the hostname to be a list: user@host1,user@host2  *   NOTE: the separator must be a comma -- no spaces are allowed  */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s@%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|pw
operator|->
name|bb_addr
init|;
name|bp
condition|;
name|bp
operator|=
name|cp
control|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|bp
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|hostok
operator|=
name|uleq
argument_list|(
name|bp
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|hostok
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|hostok
condition|)
block|{
ifdef|#
directive|ifdef
name|TRUSTED
name|trusted
argument_list|(
literal|0
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|pw
operator|->
name|bb_name
argument_list|,
literal|0
argument_list|,
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* DPOP */
ifdef|#
directive|ifdef
name|TRUSTED
if|if
condition|(
name|trusted
argument_list|(
literal|1
argument_list|,
name|hostname
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|,
name|username
argument_list|,
ifndef|#
directive|ifndef
name|DPOP
name|pw
operator|->
name|pw_uid
operator|==
literal|0
argument_list|,
else|#
directive|else
comment|/* DPOP */
literal|0
argument_list|,
endif|#
directive|endif
comment|/* DPOP */
literal|"rpop"
argument_list|,
literal|"tcp"
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"permission denied"
argument_list|)
return|;
endif|#
directive|endif
comment|/* TRUSTED */
return|return
name|setup
argument_list|(
name|pw
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RPOP */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|APOP
end_ifdef

begin_include
include|#
directive|include
file|"popauth.h"
end_include

begin_include
include|#
directive|include
file|"../../uip/md5.c"
end_include

begin_include
include|#
directive|include
file|<ndbm.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|apop
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ep
decl_stmt|,
name|digest
index|[
literal|16
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
name|struct
name|stat
name|st
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|value
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
name|struct
name|authinfo
name|auth
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|username
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DPOP
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|*
name|pw
operator|->
name|pw_passwd
operator|==
name|NULL
condition|)
block|{
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"user invalid"
argument_list|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
operator|(
name|pw
operator|=
name|getbbnam
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|pw
operator|=
name|getbbaka
argument_list|(
name|username
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|*
name|pw
operator|->
name|bb_passwd
operator|==
name|NULL
condition|)
block|{
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"subscriber invalid"
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|db
operator|=
name|dbm_open
argument_list|(
name|APOP
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"POP authorization DB not available (%d)"
argument_list|,
name|errno
argument_list|)
return|;
if|if
condition|(
name|fstat
argument_list|(
name|dbm_pagfno
argument_list|(
name|db
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
operator|&&
operator|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
operator|)
operator|!=
literal|0600
condition|)
block|{
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"POP authorization DB has wrong mode (0%o)"
argument_list|,
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
return|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|dbm_pagfno
argument_list|(
name|db
argument_list|)
argument_list|,
name|LOCK_SH
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to lock POP authorization DB (%d)"
argument_list|,
name|errno
argument_list|)
return|;
block|}
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|key
operator|.
name|dptr
operator|=
name|vec
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|value
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|dptr
operator|==
name|NULL
condition|)
block|{
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"not authorized"
argument_list|)
return|;
block|}
name|bcopy
argument_list|(
name|value
operator|.
name|dptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auth
argument_list|,
sizeof|sizeof
name|auth
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
name|buffer
argument_list|,
literal|"%s%*.*s"
argument_list|,
name|timestamp
argument_list|,
name|auth
operator|.
name|auth_secretlen
argument_list|,
name|auth
operator|.
name|auth_secretlen
argument_list|,
name|auth
operator|.
name|auth_secret
argument_list|)
expr_stmt|;
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|timestamp
argument_list|)
operator|+
name|auth
operator|.
name|auth_secretlen
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|digest
argument_list|,
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ep
operator|=
operator|(
name|dp
operator|=
name|digest
operator|)
operator|+
sizeof|sizeof
name|digest
operator|/
sizeof|sizeof
name|digest
index|[
literal|0
index|]
init|;
name|dp
operator|<
name|ep
condition|;
name|cp
operator|+=
literal|2
control|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|dp
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|,
name|buffer
argument_list|)
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"authentication failure"
argument_list|)
return|;
return|return
name|setup
argument_list|(
name|pw
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|setup
parameter_list|(
name|pw
parameter_list|,
name|guest
parameter_list|)
ifndef|#
directive|ifndef
name|DPOP
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
else|#
directive|else
comment|/* DPOP */
specifier|register
name|struct
name|bboard
modifier|*
name|pw
decl_stmt|;
endif|#
directive|endif
comment|/* DPOP */
name|int
name|guest
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|guest
condition|)
block|{
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|guest_gid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|popbbuser
argument_list|,
name|guest_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS5 */
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|guest_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* BPOP */
ifndef|#
directive|ifndef
name|DPOP
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS5 */
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DPOP */
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pop_gid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SYS5
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|POPUID
argument_list|,
name|pop_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS5 */
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|pop_uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DPOP */
ifdef|#
directive|ifdef
name|BPOP
block|}
endif|#
directive|endif
comment|/* BPOP */
ifndef|#
directive|ifndef
name|DPOP
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|maildrop
argument_list|,
literal|"%s/%s"
argument_list|,
name|mmdfldir
operator|&&
operator|*
name|mmdfldir
condition|?
name|mmdfldir
else|:
name|pw
operator|->
name|pw_dir
argument_list|,
name|mmdflfil
operator|&&
operator|*
name|mmdflfil
condition|?
name|mmdflfil
else|:
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* DPOP */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|maildrop
argument_list|,
name|pw
operator|->
name|bb_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DPOP */
if|if
condition|(
name|setupaux
argument_list|(
name|guest
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|POP2
if|if
condition|(
name|pop2
operator|!=
name|NOTOK
condition|)
block|{
comment|/* in response to pop2 "helo" */
name|pop2
operator|=
name|nmsgs
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|respond
argument_list|(
literal|'#'
argument_list|,
literal|"%d message%s (%d octets)"
argument_list|,
name|nmsgs
argument_list|,
name|nmsgs
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
else|else
endif|#
directive|endif
comment|/* POP2 */
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|nmsgs
condition|?
literal|"maildrop has %d message%s (%d octets)"
else|:
literal|"maildrop empty"
argument_list|,
name|nmsgs
argument_list|,
name|nmsgs
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|setupaux
parameter_list|(
name|readonly
parameter_list|)
name|int
name|readonly
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|msgp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|BPOP
name|xtnded
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BPOP */
if|if
condition|(
operator|(
name|dp
operator|=
name|readonly
condition|?
name|fopen
argument_list|(
name|maildrop
argument_list|,
literal|"r"
argument_list|)
else|:
name|lkfopen
argument_list|(
name|maildrop
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|m_gMsgs
argument_list|(
name|msgp
operator|=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|no_mail
goto|;
default|default:
name|nmsgs
operator|=
name|dmsgs
operator|=
literal|0
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to %s maildrop: \"%s\""
argument_list|,
name|readonly
condition|?
literal|"read"
else|:
literal|"lock"
argument_list|,
name|maildrop
argument_list|)
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|)
block|{
name|mode
operator|=
call|(
name|int
call|)
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
operator|,
name|mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|msgp
operator|=
name|read_map
argument_list|(
name|maildrop
argument_list|,
operator|(
name|long
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
literal|0600
operator|,
name|mtime
operator|=
literal|0
expr_stmt|;
name|msgp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|msgp
operator|=
name|read_file
argument_list|(
name|msgp
condition|?
name|Msgs
index|[
name|msgp
index|]
operator|.
name|m_stop
else|:
literal|0L
argument_list|,
name|msgp
operator|+
literal|1
argument_list|)
operator|)
operator|<
literal|1
condition|)
name|m_gMsgs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|no_mail
label|:
empty_stmt|;
name|lastseen
operator|=
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"XXX: lastseen=%d"
argument_list|,
name|lastseen
argument_list|)
expr_stmt|;
name|dmsgs
operator|=
name|rmsgs
operator|=
literal|0
expr_stmt|;
name|nmsgs
operator|=
name|msgp
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|=
name|readonly
condition|?
name|MREAD
else|:
name|MNULL
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
operator|==
literal|0
condition|)
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
operator|=
name|pmbx_size
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|+=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
expr_stmt|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|=
name|MNULL
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_map
parameter_list|(
name|file
parameter_list|,
name|pos
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|long
name|pos
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|msgp
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|pp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|struct
name|drop
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"read_map (%s, %ld)"
argument_list|,
name|file
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|map_read
argument_list|(
name|file
argument_list|,
name|pos
argument_list|,
operator|&
name|rp
argument_list|,
name|debug
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|m_gMsgs
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|rp
operator|->
name|d_start
expr_stmt|;
name|msgp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|rp
operator|+
literal|1
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|msgp
operator|++
operator|,
name|pp
operator|++
control|)
block|{
name|mp
operator|=
operator|&
name|Msgs
index|[
name|msgp
index|]
operator|.
name|m_drop
expr_stmt|;
name|mp
operator|->
name|d_id
operator|=
name|pp
operator|->
name|d_id
expr_stmt|;
name|mp
operator|->
name|d_size
operator|=
name|pp
operator|->
name|d_size
expr_stmt|;
name|mp
operator|->
name|d_start
operator|=
name|pp
operator|->
name|d_start
expr_stmt|;
name|mp
operator|->
name|d_stop
operator|=
name|pp
operator|->
name|d_stop
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|>
name|msgp
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"lastseen adjusted from %d to %d"
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
argument_list|,
name|msgp
argument_list|)
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|msgp
expr_stmt|;
block|}
return|return
operator|(
name|msgp
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|read_file
parameter_list|(
name|pos
parameter_list|,
name|msgp
parameter_list|)
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|int
name|msgp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|pp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|struct
name|drop
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"read_file (%ld, %d)"
argument_list|,
name|pos
argument_list|,
name|msgp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|MBX_READ
argument_list|(
name|dp
argument_list|,
name|pos
argument_list|,
operator|&
name|rp
argument_list|,
name|debug
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|msgp
operator|-
literal|1
operator|)
return|;
name|m_gMsgs
argument_list|(
operator|(
name|msgp
operator|-
literal|1
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|rp
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|msgp
operator|++
operator|,
name|pp
operator|++
control|)
block|{
name|mp
operator|=
operator|&
name|Msgs
index|[
name|msgp
index|]
operator|.
name|m_drop
expr_stmt|;
name|mp
operator|->
name|d_id
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|d_size
operator|=
name|pp
operator|->
name|d_size
expr_stmt|;
name|mp
operator|->
name|d_start
operator|=
name|pp
operator|->
name|d_start
expr_stmt|;
name|mp
operator|->
name|d_stop
operator|=
name|pp
operator|->
name|d_stop
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
name|msgp
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|m_gMsgs
argument_list|(
argument|n
argument_list|)
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"m_gMsgs (%d) 0x%x %d"
argument_list|,
name|n
argument_list|,
name|Msgs
argument_list|,
name|nMsgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
operator|==
name|NULL
condition|)
block|{
name|nMsgs
operator|=
name|n
operator|+
name|MAXFOLDER
operator|/
literal|2
expr_stmt|;
name|Msgs
operator|=
operator|(
expr|struct
name|Msg
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|nMsgs
operator|+
literal|2
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|Msgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
operator|==
name|NULL
condition|)
name|padios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate Msgs structure"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nMsgs
operator|>=
name|n
condition|)
return|return;
name|nMsgs
operator|=
name|n
operator|+
name|MAXFOLDER
operator|/
literal|2
expr_stmt|;
name|Msgs
operator|=
operator|(
expr|struct
name|Msg
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Msgs
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|nMsgs
operator|+
literal|2
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|Msgs
argument_list|)
expr_stmt|;
if|if
condition|(
name|Msgs
operator|==
name|NULL
condition|)
name|padios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to reallocate Msgs structure"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|pmbx_size
parameter_list|(
name|m
parameter_list|)
specifier|register
name|int
name|m
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|Msgs
index|[
name|m
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pos
operator|=
name|Msgs
index|[
name|m
index|]
operator|.
name|m_stop
operator|-
name|Msgs
index|[
name|m
index|]
operator|.
name|m_start
init|;
name|pos
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|pos
operator|--
control|)
if|if
condition|(
name|fgetc
argument_list|(
name|dp
argument_list|)
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|status
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d %d"
argument_list|,
name|nmsgs
operator|-
name|dmsgs
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|POP2
end_ifdef

begin_function
specifier|static
name|int
name|rdp2
parameter_list|(
name|vec
parameter_list|)
comment|/* always returns OK */
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|vec
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|pop2
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|pop2
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pop2
operator|==
literal|0
condition|)
return|return
name|NOTOK
return|;
comment|/* close 'em down */
if|if
condition|(
name|pop2
operator|<=
literal|0
operator|||
name|pop2
operator|>
name|nmsgs
condition|)
block|{
name|pop2
operator|=
literal|0
expr_stmt|;
return|return
name|respond
argument_list|(
literal|'='
argument_list|,
literal|"0 no message"
argument_list|)
return|;
block|}
if|if
condition|(
name|Msgs
index|[
name|pop2
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
block|{
name|pop2
operator|=
literal|0
expr_stmt|;
return|return
name|respond
argument_list|(
literal|'='
argument_list|,
literal|"0 message %d is deleted"
argument_list|,
name|pop2
argument_list|)
return|;
block|}
return|return
name|respond
argument_list|(
literal|'='
argument_list|,
literal|"%d (message %d)"
argument_list|,
name|Msgs
index|[
name|pop2
index|]
operator|.
name|m_size
argument_list|,
name|pop2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ack2
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
literal|"ackd"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Msgs
index|[
name|pop2
index|]
operator|.
name|m_flags
operator||=
name|MDELE
expr_stmt|;
comment|/* ignored later if MREAD */
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|-=
name|Msgs
index|[
name|pop2
index|]
operator|.
name|m_size
expr_stmt|;
name|dmsgs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pop2
condition|)
block|{
comment|/* a current msg */
name|rmsgs
operator|++
expr_stmt|;
comment|/* mark this one as read */
if|if
condition|(
operator|++
name|pop2
operator|>
name|nmsgs
condition|)
name|pop2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* let rdp2 reset */
elseif|else
if|if
condition|(
name|Msgs
index|[
name|pop2
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
name|pop2
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* let rdp2 reset */
if|if
condition|(
name|pop2
operator|>
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
condition|)
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|pop2
expr_stmt|;
block|}
return|return
name|rdp2
argument_list|(
name|vec
argument_list|)
return|;
comment|/* vec = { "acks", 0 } */
block|}
end_function

begin_function
specifier|static
name|int
name|fold
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|pop2
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* This might work, or it might be a huge security hole.  For my purpose,  * it doesn't need to work, so I'm not going to make sure it's OK.  * 16Nov90/JLR  */
if|if
condition|(
name|quitaux
argument_list|(
name|NULLVP
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
literal|'#'
argument_list|,
literal|"0 unable to close folder"
argument_list|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|maildrop
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|setupaux
argument_list|(
name|access
argument_list|(
name|maildrop
argument_list|,
literal|2
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
literal|'#'
argument_list|,
literal|"0 unable to read %s"
argument_list|,
name|maildrop
argument_list|)
return|;
name|pop2
operator|=
name|nmsgs
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|respond
argument_list|(
literal|'#'
argument_list|,
literal|"%d message%s in %s (%d octets)"
argument_list|,
name|nmsgs
argument_list|,
name|nmsgs
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|maildrop
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
endif|#
directive|endif
name|respond
argument_list|(
literal|'#'
argument_list|,
literal|"0 unable to change folders"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POP2 */
end_comment

begin_function
specifier|static
name|int
name|list
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vec
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
ifndef|#
directive|ifndef
name|BPOP
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
return|;
else|#
directive|else
comment|/* BPOP */
ifdef|#
directive|ifdef
name|MPOP
if|if
condition|(
name|nfs
operator|&&
operator|!
name|xtnded
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scan
argument_list|(
name|dp
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|nfs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|long
operator|)
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|SCNMSG
case|:
case|case
name|SCNENC
case|:
case|case
name|SCNERR
case|:
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|scanl
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d %d #%s"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|scanl
argument_list|)
return|;
case|case
name|SCNEOF
case|:
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d %d #%*d  empty"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|DMAXFOLDER
argument_list|,
name|i
argument_list|)
return|;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* MPOP */
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|xtnded
condition|?
literal|"%d %d %d"
else|:
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_id
argument_list|)
return|;
endif|#
directive|endif
comment|/* BPOP */
block|}
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d message%s (%d octets)"
argument_list|,
name|nmsgs
operator|-
name|dmsgs
argument_list|,
name|nmsgs
operator|-
name|dmsgs
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|BPOP
name|multiline
argument_list|(
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BPOP */
ifdef|#
directive|ifdef
name|MPOP
if|if
condition|(
name|nfs
operator|&&
operator|!
name|xtnded
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|scan
argument_list|(
name|dp
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|nfs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULLCP
argument_list|,
operator|(
name|long
operator|)
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|SCNMSG
case|:
case|case
name|SCNENC
case|:
case|case
name|SCNERR
case|:
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|scanl
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|multiline
argument_list|(
literal|"%d %d #%s"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|scanl
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|SCNEOF
case|:
name|multiline
argument_list|(
literal|"%d %d #%*d  empty"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|DMAXFOLDER
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* MPOP */
name|multiline
argument_list|(
name|xtnded
condition|?
literal|"%d %d %d"
else|:
literal|"%d %d"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BPOP */
block|}
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|retrieve
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|POP2
if|if
condition|(
name|pop2
operator|==
literal|0
condition|)
return|return
name|NOTOK
return|;
elseif|else
if|if
condition|(
name|pop2
operator|==
name|NOTOK
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d octets"
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POP2
block|}
else|else
comment|/* if called by pop2, vec = { "retr", 0 } */
name|i
operator|=
name|pop2
expr_stmt|;
endif|#
directive|endif
for|for
control|(
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|pos
operator|=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|dp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
condition|;
name|pos
operator|+=
call|(
name|long
call|)
argument_list|(
name|cp
operator|-
name|buffer
operator|+
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POP2
if|if
condition|(
name|pop2
operator|==
name|NOTOK
condition|)
block|{
comment|/* then multiend */
endif|#
directive|endif
name|multiend
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
condition|)
block|{
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|i
expr_stmt|;
name|rmsgs
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|POP2
block|}
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|delete
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|&
name|MREAD
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"maildrop is read-only"
argument_list|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator||=
name|MDELE
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|-=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
expr_stmt|;
name|dmsgs
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
condition|)
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|i
expr_stmt|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"message %d deleted (%d octets)"
argument_list|,
name|i
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reset
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
block|{
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&=
operator|~
name|MDELE
expr_stmt|;
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
operator|+=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_size
expr_stmt|;
name|dmsgs
operator|--
expr_stmt|;
block|}
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|lastseen
expr_stmt|;
ifdef|#
directive|ifdef
name|MPOP
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|nfs
condition|)
block|{
if|if
condition|(
name|scanl
condition|)
name|free
argument_list|(
name|scanl
argument_list|)
operator|,
name|scanl
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|nfs
argument_list|)
operator|,
name|nfs
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* MPOP */
return|return
name|status
argument_list|(
name|vec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|top
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|body
decl_stmt|,
name|lines
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|i
operator|>
name|nmsgs
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"no such message: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"message %d is deleted"
argument_list|,
name|i
argument_list|)
return|;
if|if
condition|(
operator|(
name|j
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"bad number: \"%s\""
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|body
operator|=
name|lines
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|dp
argument_list|,
name|pos
operator|=
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
literal|0
argument_list|)
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|dp
argument_list|)
operator|!=
name|NULL
operator|&&
name|pos
operator|<
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
condition|;
name|pos
operator|+=
call|(
name|long
call|)
argument_list|(
name|cp
operator|-
name|buffer
operator|+
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|cp
operator|=
name|buffer
operator|+
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|body
condition|)
block|{
if|if
condition|(
name|lines
operator|++
operator|>=
name|j
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|buffer
operator|==
literal|0
condition|)
name|body
operator|++
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|last
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%d is the last msg seen"
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BPOP
end_ifdef

begin_function
specifier|static
name|int
name|xtnd
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|make_lower
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"bboards"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"archive"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xtnd1
argument_list|(
name|vec
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"x-bboards"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xtnd2
argument_list|(
name|vec
argument_list|)
return|;
ifdef|#
directive|ifdef
name|MPOP
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"scan"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xtnd3
argument_list|(
name|vec
argument_list|)
return|;
endif|#
directive|endif
comment|/* MPOP */
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown XTND command: \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xtnd1
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
condition|)
block|{
name|make_lower
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|getbbaux
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown BBoard: \"%s\""
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
return|;
if|if
condition|(
name|quitaux
argument_list|(
name|NULLVP
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|maildrop
argument_list|,
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"bboards"
argument_list|)
condition|?
name|bb
operator|->
name|bb_archive
else|:
name|bb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|setupaux
argument_list|(
name|TRUE
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
name|xtnded
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s %d"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vec
index|[
literal|1
index|]
argument_list|,
literal|"bboards"
argument_list|)
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too few arguments to XTND \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|BBhead
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|bb_next
control|)
block|{
name|getbbmax
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|bb_flags
operator|&
name|BB_INVIS
operator|)
condition|)
name|multiline
argument_list|(
literal|"%s %d"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bb
operator|=
name|getbbaux
argument_list|(
name|NULLCP
argument_list|)
condition|)
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|bb_flags
operator|&
name|BB_INVIS
operator|)
condition|)
name|multiline
argument_list|(
literal|"%s %d"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
block|}
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|xtnd2
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|;
if|if
condition|(
name|vec
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too few arguments to XTND \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
name|make_lower
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|getbbaux
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown BBoard: \"%s\""
argument_list|,
name|vec
index|[
literal|2
index|]
argument_list|)
return|;
operator|(
name|void
operator|)
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s"
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bb
operator|->
name|bb_aka
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|cp
operator|!=
name|buffer
condition|?
literal|" %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_file
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_archive
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_info
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_map
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_passwd
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bb
operator|->
name|bb_leader
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|cp
operator|!=
name|buffer
condition|?
literal|" %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_addr
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_request
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_relay
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|bb
operator|->
name|bb_dist
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
argument_list|,
name|cp
operator|!=
name|buffer
condition|?
literal|" %s"
else|:
literal|"%s"
argument_list|,
operator|*
name|ap
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|getbbmax
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"0%o %d"
argument_list|,
name|bb
operator|->
name|bb_flags
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|)
expr_stmt|;
name|multiline
argument_list|(
literal|"%s"
argument_list|,
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
name|multiend
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|bboard
modifier|*
name|getbbaux
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|bboard
modifier|*
name|bb
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|BBhead
operator|==
name|NULL
condition|)
if|if
condition|(
name|setbbinfo
argument_list|(
name|BBOARDS
argument_list|,
name|BBDB
argument_list|,
literal|1
argument_list|)
condition|)
name|BBtime
operator|=
name|getbbtime
argument_list|()
expr_stmt|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|!=
name|NULLCP
condition|)
for|for
control|(
name|bb
operator|=
name|BBhead
init|;
name|bb
condition|;
name|bb
operator|=
name|bb
operator|->
name|bb_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bb
operator|->
name|bb_name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"getbbaux: \"%s\" from cache"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
name|getbbmax
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
while|while
condition|(
name|bb
operator|=
name|getbbent
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|bb
operator|=
name|getbbcpy
argument_list|(
name|bb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|access
argument_list|(
name|bb
operator|->
name|bb_file
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|bb
operator|->
name|bb_flags
operator||=
name|BB_INVIS
expr_stmt|;
name|bb
operator|->
name|bb_mtime
operator|=
name|stat
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
name|NOTOK
condition|?
name|st
operator|.
name|st_mtime
else|:
literal|0L
expr_stmt|;
if|if
condition|(
name|BBtail
operator|!=
name|NULL
condition|)
name|BBtail
operator|->
name|bb_next
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|BBhead
operator|==
name|NULL
condition|)
name|BBhead
operator|=
name|bb
expr_stmt|;
name|BBtail
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|bb
operator|->
name|bb_name
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|&&
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"getbbaux: \"%s\" from scratch"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|getbbmax
argument_list|(
name|bb
argument_list|)
specifier|register
expr|struct
name|bboard
operator|*
name|bb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"getbbmax: \"%s\", 0%o, %d, %s"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_flags
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|,
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|bb_flags
operator|&
name|BB_INVIS
operator|)
operator|&&
name|access
argument_list|(
name|bb
operator|->
name|bb_file
argument_list|,
literal|04
argument_list|)
operator|==
name|NOTOK
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|bb
operator|->
name|bb_flags
operator||=
name|BB_INVIS
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
operator|||
name|bb
operator|->
name|bb_mtime
operator|==
name|st
operator|.
name|st_mtime
operator|||
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|bb
operator|->
name|bb_info
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|bb
operator|->
name|bb_mtime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|atoi
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|bb
operator|->
name|bb_maxima
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|bb_date
condition|)
name|free
argument_list|(
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|=
name|index
argument_list|(
name|buffer
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|NULL
expr_stmt|;
name|bb
operator|->
name|bb_date
operator|=
name|getcpy
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"updated: \"%s\", 0%o, %d, %s"
argument_list|,
name|bb
operator|->
name|bb_name
argument_list|,
name|bb
operator|->
name|bb_flags
argument_list|,
name|bb
operator|->
name|bb_maxima
argument_list|,
name|bb
operator|->
name|bb_date
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MPOP
end_ifdef

begin_function
specifier|static
name|int
name|xtnd3
parameter_list|(
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|vec
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too few arguments to XTND \"%s\""
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
if|if
condition|(
operator|(
name|_sc_width
operator|=
name|atoi
argument_list|(
name|vec
index|[
literal|2
index|]
argument_list|)
operator|)
operator|<
name|WIDTH
operator|/
literal|2
condition|)
name|_sc_width
operator|=
name|WIDTH
operator|/
literal|2
expr_stmt|;
name|nfs
operator|=
name|new_fs
argument_list|(
name|NULLCP
argument_list|,
name|vec
index|[
literal|3
index|]
argument_list|,
name|FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scanl
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|scanl
argument_list|)
operator|,
name|scanl
operator|=
name|NULL
expr_stmt|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|vec
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sc_width
parameter_list|()
block|{
return|return
name|_sc_width
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPOP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BPOP */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|quit
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|d
decl_stmt|,
name|n
decl_stmt|;
name|d
operator|=
name|dmsgs
operator|,
name|n
operator|=
name|nmsgs
expr_stmt|;
if|if
condition|(
name|quitaux
argument_list|(
name|vec
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|NOTOK
return|;
ifdef|#
directive|ifdef
name|BPOP
if|if
condition|(
name|xtnded
condition|)
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s signing off"
argument_list|,
name|server
argument_list|)
return|;
endif|#
directive|endif
comment|/* BPOP */
if|if
condition|(
name|n
operator|==
name|d
condition|)
return|return
name|respond
argument_list|(
name|OK
argument_list|,
literal|"%s signing off (maildrop empty)"
argument_list|,
name|server
argument_list|)
return|;
return|return
name|respond
argument_list|(
name|OK
argument_list|,
name|n
condition|?
literal|"%s signing off (%d message%s, %d octets left)"
else|:
literal|"%s signing off (maildrop empty)"
argument_list|,
name|server
argument_list|,
name|n
operator|-
name|d
argument_list|,
name|n
operator|-
name|d
operator|!=
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|quitaux
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
name|OK
return|;
name|i
operator|=
name|quitfile
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|nmsgs
operator|=
name|dmsgs
operator|=
name|rmsgs
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|lkfclose
argument_list|(
name|dp
argument_list|,
name|maildrop
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|quitfile
parameter_list|(
name|vec
parameter_list|)
name|char
modifier|*
modifier|*
name|vec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tmpDR
decl_stmt|,
name|md
decl_stmt|;
name|char
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|map1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|map2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"XXX: dmsgs=%d rmsgs=%d readonly=%d"
argument_list|,
name|dmsgs
argument_list|,
name|rmsgs
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|&
name|MREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmsgs
operator|==
literal|0
operator|||
operator|(
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_flags
operator|&
name|MREAD
operator|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|dp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to stat file"
argument_list|)
return|;
if|if
condition|(
name|mtime
operator|!=
name|st
operator|.
name|st_mtime
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"new messages have arrived, no update"
argument_list|)
return|;
name|mode
operator|=
call|(
name|int
call|)
argument_list|(
name|st
operator|.
name|st_mode
operator|&
literal|0777
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmsgs
operator|==
name|dmsgs
condition|)
block|{
ifndef|#
directive|ifndef
name|SYS5
name|i
operator|=
name|truncate
argument_list|(
name|maildrop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYS5 */
name|i
operator|=
name|open
argument_list|(
name|maildrop
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SYS5 */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map_name
argument_list|(
name|maildrop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to zero %s"
argument_list|,
name|maildrop
argument_list|)
return|;
return|return
name|OK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_backup
argument_list|(
name|maildrop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|=
name|mbx_open
argument_list|(
name|tmpfil
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|st
operator|.
name|st_gid
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
block|{
name|char
name|msgbuf0
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msgbuf0
argument_list|,
literal|"unable to create temporary file (%s)"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
name|msgbuf0
argument_list|)
return|;
block|}
name|j
operator|=
literal|0
operator|,
name|tmpDR
operator|=
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"XXX: last=%d"
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|tmpDR
condition|)
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"XXX: last=%d"
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|Msgs
index|[
name|i
index|]
operator|.
name|m_flags
operator|&
name|MDELE
operator|)
operator|&&
name|mbx_write
argument_list|(
name|tmpfil
argument_list|,
name|md
argument_list|,
name|dp
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_id
argument_list|,
name|Msgs
index|[
literal|0
index|]
operator|.
name|m_last
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_start
argument_list|,
name|Msgs
index|[
name|i
index|]
operator|.
name|m_stop
argument_list|,
name|TRUE
argument_list|,
name|debug
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|tmpfil
argument_list|,
name|md
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"error writing temporary file"
argument_list|)
return|;
block|}
operator|(
name|void
operator|)
name|mbx_close
argument_list|(
name|tmpfil
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|rename
argument_list|(
name|tmpfil
argument_list|,
name|maildrop
argument_list|)
operator|)
operator|==
name|OK
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|map1
argument_list|,
name|map_name
argument_list|(
name|tmpfil
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|map2
argument_list|,
name|map_name
argument_list|(
name|maildrop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|map1
argument_list|,
name|map2
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|map2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|NOTOK
condition|)
return|return
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unable to rename maildrop"
argument_list|)
return|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|struct
name|vector
modifier|*
name|getvector
parameter_list|(
name|bp
parameter_list|,
name|vec
parameter_list|)
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
decl|*
modifier|*
name|vec
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|vector
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVEC
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
operator|*
name|bp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|0
condition|)
block|{
name|vec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'"'
condition|)
block|{
for|for
control|(
name|vec
index|[
name|i
index|]
operator|=
operator|++
name|bp
init|;
operator|*
name|bp
operator|!=
literal|'\0'
operator|&&
operator|*
name|bp
operator|!=
literal|'"'
condition|;
name|bp
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|bp
condition|)
block|{
case|case
literal|'n'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
argument_list|,
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|--
name|bp
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* and fall... */
default|default:
name|bp
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'"'
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
name|vec
index|[
name|i
index|]
operator|=
name|bp
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|vec
index|[
name|NVEC
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too many arguments"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|vec
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"null command"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|make_lower
argument_list|(
name|vec
index|[
literal|0
index|]
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|vectors
init|;
name|v
operator|->
name|v_cmd
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|v
operator|->
name|v_cmd
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|v
operator|->
name|v_valid
operator|==
name|mystate
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|v
operator|->
name|v_min
operator|||
name|v
operator|->
name|v_max
operator|<
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"too %s arguments to \"%s\""
argument_list|,
name|i
operator|<
name|v
operator|->
name|v_min
condition|?
literal|"few"
else|:
literal|"many"
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
return|return
name|v
return|;
block|}
operator|(
name|void
operator|)
name|respond
argument_list|(
name|NOTOK
argument_list|,
literal|"unknown command: \"%s\""
argument_list|,
name|vec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
specifier|static
name|int
name|respond
parameter_list|(
name|code
parameter_list|,
name|fmt
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|,
decl|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|d
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
ifndef|#
directive|ifndef
name|POP2
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s"
argument_list|,
name|code
operator|==
name|OK
condition|?
literal|"+OK"
else|:
literal|"-ERR"
argument_list|,
name|fmt
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OK
case|:
case|case
name|NOTOK
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
literal|"%s%s"
argument_list|,
name|code
operator|==
name|OK
condition|?
literal|"+OK"
else|:
literal|"-ERR"
argument_list|,
name|fmt
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* only happens in pop2 */
operator|*
name|bp
operator|++
operator|=
name|code
expr_stmt|;
name|code
operator|=
name|OK
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fmt
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bp
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|putline
argument_list|(
name|buffer
argument_list|,
name|output
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_expr_stmt
specifier|static
name|multiline
argument_list|(
argument|fmt
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
name|char
operator|*
name|fmt
operator|,
operator|*
name|a
operator|,
operator|*
name|b
operator|,
operator|*
name|c
operator|,
operator|*
name|d
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
operator|+
name|TRMLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|TRM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cp
operator|=
operator|(
name|buffer
operator|+
name|TRMLEN
operator|)
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|TRM
argument_list|,
name|TRMLEN
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|=
name|buffer
expr_stmt|;
name|putline
argument_list|(
name|cp
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|multiend
argument_list|()
block|{
name|putline
argument_list|(
name|TRM
argument_list|,
name|output
argument_list|)
block|; }
comment|/*
comment|*/
specifier|static
name|int
name|getline
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
name|iop
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|iop
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
while|while
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
operator|(
name|void
operator|)
name|fgetc
argument_list|(
name|iop
argument_list|)
expr_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|c
operator|)
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|iop
argument_list|)
condition|)
return|return
name|NOTOK
return|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|p
operator|==
name|s
condition|)
return|return
name|DONE
return|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"<--- %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|OK
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|putline
argument_list|(
name|s
argument_list|,
name|iop
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|iop
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|iop
argument_list|,
literal|"%s\r\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"---> %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|iop
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|TYPESIG
name|pipeser
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|sc
parameter_list|)
name|int
name|sig
decl_stmt|;
name|long
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|sc
decl_stmt|;
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_WARNING
argument_list|,
literal|"lost connection"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|NOTOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* Some people don't want to use the POP delivery agent with Sendmail  * if they're going to run POP.  Sendmail writes maildrops in the old  * UUCP format, and popd doesn't know how to read them.  These people  * really should do what the MH manual says -- run the pop delivery  * agent and be done with it.  Some things never die.  *  * A real fix would be to make uip/dropsbr.c should use the same methods  * as sbr/m_getfld.c to determine the format of maildrops and read&  * write them.  Unfortunately, it'll take a lot of work to bring it into  * the fold.  20Mar90/JLR  *   * I really really hate to add this, but this lets stuff popd read  * UUCP style maildrops as well as MMDF (ctrl/A) style maildrops.  It was  * contributed by Steve Dempsey<steved@longs.LANCE.ColoState.Edu>.  *  * Here's what he says:  *   * Ideally, one should be able to do it with the mmdelim strings, but  * the MH parser is not intelligent enough to do this.  You have at  * least a couple of choices:  *   *   - use aliases to deliver mail to POP users (user: user@pop) and  *     install the POP delivery agent - should work well with sendmail.  *   - fix the POP server!  *   * We have all mail sent to one machine and users are given two options:  *   *   - MH on any machine.  *   - any user agent on the postoffice machine.  *   * Most of our workstations run xmh and users find that to be sufficient.  * New users are only taught to use MH, and a very few old timers stay  * with BSD mail.  In any case, several agents are available at the cost  * of a telnet/rlogin if a user does not like MH.  *   * I have made the changes to the POP server (MH-6.6/support/pop/popser.c)  * to look for the `\n\nFrom ' delimiter instead of the ^A's, using some  * code from the BSD agent.  Context diff is included below.  When this  * is installed, you just go back to the normal localmail and get rid of  * slocal completely.  *   * I have not tried this modification with anything but the MH client,  * but it should work.  Nothing in the POP protocol changes; the server  * just has different criteria for delimiting messages in the mailbox.  * If you decide to use this, I'd like to know what happens.  *   *         Steve Dempsey,  Center for Computer Assisted Engineering  *   Colorado State University, Fort Collins, CO  80523    +1 303 491 0630  * INET: steved@longs.LANCE.ColoState.Edu, dempsey@handel.CS.ColoState.Edu  * boulder!ccncsu!longs.LANCE.ColoState.Edu!steved, ...!ncar!handel!dempsey  */
end_comment

begin_comment
comment|/* From:    Jim Reid<jim@computer-science.strathclyde.ac.UK>  *   * MH-6.7 does not support MMDF-style mailboxes with POP as claimed. It  * appears that when code was added to popser.c to support UNIX-style  * mailboxes, the old behaviour was lost. i.e. The new popd worked with  * UNIX-style mailboxes, but not MMDF ones. Users would get "format error"  * error messages if they tried to inc a remote MMDF-style mailbox because  * the pop daemon didn't want to know or like the MMDF message delimiters.  */
end_comment

begin_comment
comment|/* So... Now there's an incredible hack in mhconfig.c to define POPUUMBOX  * in support/pop/Makefile if we're using Sendmail.  This causes this  * UUCP-mbox reading code to be used here.  Ugh.  05Nov90/JLR  */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POPUUMBOX
end_ifdef

begin_comment
comment|/* from dropsbr.c - read from a mailbox - pop server version */
end_comment

begin_comment
comment|/* ALMOST IDENTICAL to mbx_read */
end_comment

begin_function
specifier|static
name|int
name|pmbx_read
parameter_list|(
name|fp
parameter_list|,
name|pos
parameter_list|,
name|drops
parameter_list|,
name|noisy
parameter_list|)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
name|struct
name|drop
modifier|*
modifier|*
name|drops
decl_stmt|;
name|int
name|noisy
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|struct
name|drop
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
comment|/* MTR: tsk, tsk, tsk... */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|mmdlm1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mbx_read
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
name|drops
argument_list|,
name|noisy
argument_list|)
return|;
comment|/* get drop storage */
name|pp
operator|=
operator|(
expr|struct
name|drop
operator|*
operator|)
name|calloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|=
name|MAXFOLDER
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"pmbx_read (%d, %ld, %d, %d)"
argument_list|,
name|fp
argument_list|,
name|pos
argument_list|,
name|drops
argument_list|,
name|noisy
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate drop storage"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
comment|/* rewind drop file */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"rewind maildrop"
argument_list|)
expr_stmt|;
comment|/* read a buffer */
for|for
control|(
name|ep
operator|=
operator|(
name|dp
operator|=
name|pp
operator|)
operator|+
name|len
operator|-
literal|1
init|;
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
condition|;
control|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
comment|/* if beginning of msg then mark it */
if|if
condition|(
name|p_ishead
argument_list|(
name|buffer
argument_list|)
condition|)
comment|/*(strcmp (buffer, mmdlm1) == 0)*/
block|{
comment|/* (don't) inc pos to msg start, mark it */
comment|/*pos += ld1;*/
name|dp
operator|->
name|d_start
operator|=
name|pos
expr_stmt|;
name|pos
operator|+=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* inc pos after marking head */
block|}
else|else
block|{
comment|/* didn't find it; mark it anyway */
name|dp
operator|->
name|d_start
operator|=
name|pos
operator|,
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* count newlines and inc size if any found */
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
operator|,
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
comment|/* read more lines... */
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* found end? */
if|if
condition|(
name|p_ishead
argument_list|(
name|buffer
argument_list|)
condition|)
comment|/*(strcmp (buffer, mmdlm2) == 0)*/
block|{
comment|/* out of loop */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|fp
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* add buffer size to pos */
name|pos
operator|+=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* count newlines.... */
for|for
control|(
name|bp
operator|=
name|buffer
init|;
operator|*
name|bp
condition|;
name|bp
operator|++
operator|,
name|size
operator|++
control|)
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_start
operator|!=
name|pos
condition|)
block|{
comment|/* do this if pos was actually incremented; got some text */
name|dp
operator|->
name|d_id
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_size
operator|=
name|size
expr_stmt|;
comment|/* save the stuff we got */
name|dp
operator|->
name|d_stop
operator|=
name|pos
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
comment|/* (don't) advance pos */
comment|/* pos += ld2; */
comment|/* need more storage.... */
if|if
condition|(
name|dp
operator|>=
name|ep
condition|)
block|{
specifier|register
name|int
name|curlen
init|=
name|dp
operator|-
name|pp
decl_stmt|;
name|cp
operator|=
operator|(
expr|struct
name|drop
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|len
operator|+=
name|MAXFOLDER
argument_list|)
operator|*
sizeof|sizeof
expr|*
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|noisy
condition|)
name|admonish
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to allocate drop storage"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dp
operator|=
name|cp
operator|+
name|curlen
operator|,
name|ep
operator|=
operator|(
name|pp
operator|=
name|cp
operator|)
operator|+
name|len
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* return unused stuff */
if|if
condition|(
name|dp
operator|==
name|pp
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|)
expr_stmt|;
else|else
operator|*
name|drops
operator|=
name|pp
expr_stmt|;
return|return
operator|(
name|dp
operator|-
name|pp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The remainder of this file adapted from:  *  *	head.c	5.2 (Berkeley) 6/21/85  */
end_comment

begin_struct
struct|struct
name|p_hdline
block|{
name|char
modifier|*
name|l_from
decl_stmt|;
comment|/* The name of the sender */
name|char
modifier|*
name|l_tty
decl_stmt|;
comment|/* His tty string (if any) */
name|char
modifier|*
name|l_date
decl_stmt|;
comment|/* The entire date string */
block|}
struct|;
end_struct

begin_comment
comment|/*  *  * See if position in a file is a mail header.  * Return true if yes.  Note the extreme pains to  * accomodate all funny formats.  */
end_comment

begin_define
define|#
directive|define
name|NOSTR
value|((char *) 0)
end_define

begin_comment
comment|/* Null string pointer */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|p_copyin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|p_copy
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|p_ishead
argument_list|(
argument|buffer
argument_list|)
name|char
name|buffer
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|p_hdline
name|hl
decl_stmt|;
name|char
name|linebuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|parbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|cp
operator|=
name|linebuf
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
literal|0
index|]
operator|==
literal|'F'
condition|)
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"ishead: '%s'"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"From "
argument_list|,
name|cp
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"Fromline..."
argument_list|)
expr_stmt|;
comment|/* get full header */
name|p_parse
argument_list|(
name|cp
argument_list|,
operator|&
name|hl
argument_list|,
name|parbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hl
operator|.
name|l_from
operator|==
name|NOSTR
operator|||
name|hl
operator|.
name|l_date
operator|==
name|NOSTR
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"Fromline...NODATE"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|p_isdate
argument_list|(
name|hl
operator|.
name|l_date
argument_list|)
condition|)
block|{
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"Fromline...BADDATE %s"
argument_list|,
name|hl
operator|.
name|l_date
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* I guess we got it! */
name|padvise
argument_list|(
name|NULLCP
argument_list|,
name|LOG_DEBUG
argument_list|,
literal|"got a head.. "
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Split a headline into its useful components.  * Copy the line into dynamic string space, then set  * pointers into the copied line in the passed headline  * structure.  Actually, it scans.  */
end_comment

begin_expr_stmt
specifier|static
name|p_parse
argument_list|(
argument|line
argument_list|,
argument|hl
argument_list|,
argument|pbuf
argument_list|)
name|char
name|line
index|[]
operator|,
name|pbuf
index|[]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|p_hdline
modifier|*
name|hl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|char
name|word
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p_nextword
parameter_list|()
function_decl|;
name|hl
operator|->
name|l_from
operator|=
name|NOSTR
expr_stmt|;
name|hl
operator|->
name|l_tty
operator|=
name|NOSTR
expr_stmt|;
name|hl
operator|->
name|l_date
operator|=
name|NOSTR
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
name|sp
operator|=
name|pbuf
expr_stmt|;
comment|/* 	 * Skip the first "word" of the line, which should be "From" 	 * anyway. 	 */
name|cp
operator|=
name|p_nextword
argument_list|(
name|cp
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|dp
operator|=
name|p_nextword
argument_list|(
name|cp
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|hl
operator|->
name|l_from
operator|=
name|p_copyin
argument_list|(
name|word
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
comment|/* UNLIKELY */
if|if
condition|(
name|strncmp
argument_list|(
name|dp
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|p_nextword
argument_list|(
name|dp
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|hl
operator|->
name|l_tty
operator|=
name|p_copyin
argument_list|(
name|word
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NOSTR
condition|)
name|hl
operator|->
name|l_date
operator|=
name|p_copyin
argument_list|(
name|cp
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* USUAL */
elseif|else
if|if
condition|(
name|dp
operator|!=
name|NOSTR
condition|)
name|hl
operator|->
name|l_date
operator|=
name|p_copyin
argument_list|(
name|dp
argument_list|,
operator|&
name|sp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Copy the string on the left into the string on the right  * and bump the right (reference) string pointer by the length.  * Thus, dynamically allocate space in the right string, copying  * the left string into it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|p_copyin
parameter_list|(
name|src
parameter_list|,
name|space
parameter_list|)
name|char
name|src
index|[]
decl_stmt|;
name|char
modifier|*
modifier|*
name|space
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|top
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|*
name|space
expr_stmt|;
name|top
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|s
operator|+
literal|1
expr_stmt|;
operator|*
name|space
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect a liberal (space, tab delimited) word into the word buffer  * passed.  Also, return a pointer to the next word following that,  * or (empty) if none follow.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_nextword
argument_list|(
name|wp
argument_list|,
name|wbuf
argument_list|)
name|char
name|wp
index|[]
decl_stmt|,
name|wbuf
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|wp
operator|)
operator|==
name|NOSTR
condition|)
block|{
name|p_copy
argument_list|(
literal|""
argument_list|,
name|wbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOSTR
operator|)
return|;
block|}
name|cp2
operator|=
name|wbuf
expr_stmt|;
while|while
condition|(
operator|!
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
block|{
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'"'
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|any
argument_list|(
operator|*
name|cp
argument_list|,
literal|" \t"
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NOSTR
operator|)
return|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy str1 to str2, return pointer to null in str2.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|p_copy
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
name|char
modifier|*
name|str1
decl_stmt|,
decl|*
name|str2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|s1
operator|=
name|str1
expr_stmt|;
name|s2
operator|=
name|str2
expr_stmt|;
while|while
condition|(
operator|*
name|s1
condition|)
operator|*
name|s2
operator|++
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
operator|*
name|s2
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|s2
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|L
value|1
end_define

begin_comment
comment|/* A lower case char */
end_comment

begin_define
define|#
directive|define
name|S
value|2
end_define

begin_comment
comment|/* A space */
end_comment

begin_define
define|#
directive|define
name|D
value|3
end_define

begin_comment
comment|/* A digit */
end_comment

begin_define
define|#
directive|define
name|O
value|4
end_define

begin_comment
comment|/* An optional digit or space */
end_comment

begin_define
define|#
directive|define
name|C
value|5
end_define

begin_comment
comment|/* A colon */
end_comment

begin_define
define|#
directive|define
name|N
value|6
end_define

begin_comment
comment|/* A new line */
end_comment

begin_define
define|#
directive|define
name|U
value|7
end_define

begin_comment
comment|/* An upper case char */
end_comment

begin_decl_stmt
specifier|static
name|char
name|p_ctypes
index|[]
init|=
block|{
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|O
block|,
name|D
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|D
block|,
name|D
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*       T h u   S e p   2 9   1 5 : 2 0 : 1 9   1 9 8 8 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|p_tmztyp
index|[]
init|=
block|{
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|U
block|,
name|L
block|,
name|L
block|,
name|S
block|,
name|O
block|,
name|D
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|C
block|,
name|D
block|,
name|D
block|,
name|S
block|,
name|U
block|,
name|U
block|,
name|U
block|,
name|S
block|,
name|D
block|,
name|D
block|,
name|D
block|,
name|D
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*       T h u   S e p   2 9   1 5 : 2 0 : 1 9   M S T   1 9 8 8 */
end_comment

begin_expr_stmt
specifier|static
name|p_isdate
argument_list|(
argument|date
argument_list|)
name|char
name|date
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|date
expr_stmt|;
if|if
condition|(
name|p_cmatch
argument_list|(
name|cp
argument_list|,
name|p_ctypes
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|p_cmatch
argument_list|(
name|cp
argument_list|,
name|p_tmztyp
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Match the given string against the given template.  * Return 1 if they match, 0 if they don't  */
end_comment

begin_expr_stmt
specifier|static
name|p_cmatch
argument_list|(
argument|str
argument_list|,
argument|temp
argument_list|)
name|char
name|str
index|[]
operator|,
name|temp
index|[]
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
name|tp
operator|=
name|temp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|tp
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|tp
operator|++
condition|)
block|{
case|case
name|L
case|:
if|if
condition|(
name|c
operator|<
literal|'a'
operator|||
name|c
operator|>
literal|'z'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|U
case|:
if|if
condition|(
name|c
operator|<
literal|'A'
operator|||
name|c
operator|>
literal|'Z'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|S
case|:
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|D
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|O
case|:
if|if
condition|(
name|c
operator|!=
literal|' '
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|C
case|:
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|N
case|:
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|)
operator|||
operator|*
name|tp
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|any
argument_list|(
argument|ch
argument_list|,
argument|str
argument_list|)
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|f
operator|=
name|str
expr_stmt|;
name|c
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|f
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

