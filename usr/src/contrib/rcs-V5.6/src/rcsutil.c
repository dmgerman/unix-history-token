begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS utilities  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcsutil.c,v $  * Revision 5.10  1991/10/07  17:32:46  eggert  * Support piece tables even if !has_mmap.  *  * Revision 5.9  1991/08/19  03:13:55  eggert  * Add spawn() support.  Explicate assumptions about getting invoker's name.  * Standardize user-visible dates.  Tune.  *  * Revision 5.8  1991/04/21  11:58:30  eggert  * Plug setuid security hole.  *  * Revision 5.6  1991/02/26  17:48:39  eggert  * Fix setuid bug.  Use fread, fwrite more portably.  * Support waitpid.  Don't assume -1 is acceptable to W* macros.  * strsave -> str_save (DG/UX name clash)  *  * Revision 5.5  1990/12/04  05:18:49  eggert  * Don't output a blank line after a signal diagnostic.  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.4  1990/11/01  05:03:53  eggert  * Remove unneeded setid check.  Add awrite(), fremember().  *  * Revision 5.3  1990/10/06  00:16:45  eggert  * Don't fread F if feof(F).  *  * Revision 5.2  1990/09/04  08:02:31  eggert  * Store fread()'s result in an fread_type object.  *  * Revision 5.1  1990/08/29  07:14:07  eggert  * Declare getpwuid() more carefully.  *  * Revision 5.0  1990/08/22  08:13:46  eggert  * Add setuid support.  Permit multiple locks per user.  * Remove compile-time limits; use malloc instead.  * Switch to GMT.  Permit dates past 1999/12/31.  * Add -V.  Remove snooping.  Ansify and Posixate.  * Tune.  Some USG hosts define NSIG but not sys_siglist.  * Don't run /bin/sh if it's hopeless.  * Don't leave garbage behind if the output is an empty pipe.  * Clean up after SIGXCPU or SIGXFSZ.  Print name of signal that caused cleanup.  *  * Revision 4.6  89/05/01  15:13:40  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.5  88/11/08  16:01:02  narten  * corrected use of varargs routines  *   * Revision 4.4  88/08/09  19:13:24  eggert  * Check for memory exhaustion.  * Permit signal handlers to yield either 'void' or 'int'; fix oldSIGINT botch.  * Use execv(), not system(); yield exit status like diff(1)'s.  *   * Revision 4.3  87/10/18  10:40:22  narten  * Updating version numbers. Changes relative to 1.1 actually  * relative to 4.1  *   * Revision 1.3  87/09/24  14:01:01  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:43  jenkins  * Port to suns  *   * Revision 4.1  83/05/10  15:53:13  wft  * Added getcaller() and findlock().  * Changed catchints() to check SIGINT for SIG_IGN before setting up the signal  * (needed for background jobs in older shells). Added restoreints().  * Removed printing of full RCS path from logcommand().  *   * Revision 3.8  83/02/15  15:41:49  wft  * Added routine fastcopy() to copy remainder of a file in blocks.  *  * Revision 3.7  82/12/24  15:25:19  wft  * added catchints(), ignoreints() for catching and ingnoring interrupts;  * fixed catchsig().  *  * Revision 3.6  82/12/08  21:52:05  wft  * Using DATEFORM to format dates.  *  * Revision 3.5  82/12/04  18:20:49  wft  * Replaced SNOOPDIR with SNOOPFILE; changed addlock() to update  * lockedby-field.  *  * Revision 3.4  82/12/03  17:17:43  wft  * Added check to addlock() ensuring only one lock per person.  * Addlock also returns a pointer to the lock created. Deleted fancydate().  *  * Revision 3.3  82/11/27  12:24:37  wft  * moved rmsema(), trysema(), trydiraccess(), getfullRCSname() to rcsfnms.c.  * Introduced macro SNOOP so that snoop can be placed in directory other than  * TARGETDIR. Changed %02d to %.2d for compatibility reasons.  *  * Revision 3.2  82/10/18  21:15:11  wft  * added function getfullRCSname().  *  * Revision 3.1  82/10/13  16:17:37  wft  * Cleanup message is now suppressed in quiet mode.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|utilId
argument_list|,
literal|"$Id: rcsutil.c,v 5.10 1991/10/07 17:32:46 eggert Exp $"
argument_list|)
end_macro

begin_if
if|#
directive|if
operator|!
name|has_memcmp
end_if

begin_function
name|int
name|memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|void
specifier|const
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
specifier|const
modifier|*
name|p1
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s1
decl_stmt|,
modifier|*
name|p2
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s2
decl_stmt|;
specifier|register
name|size_t
name|i
init|=
name|n
decl_stmt|;
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
operator|!
operator|(
name|r
operator|=
operator|(
operator|*
name|p1
operator|++
operator|-
operator|*
name|p2
operator|++
operator|)
operator|)
condition|)
empty_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_memcpy
end_if

begin_function
name|void
modifier|*
name|memcpy
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|void
modifier|*
name|s1
decl_stmt|;
name|void
specifier|const
modifier|*
name|s2
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
operator|(
name|char
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p2
init|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|lint
end_if

begin_decl_stmt
name|malloc_type
name|lintalloc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * list of blocks allocated with ftestalloc()  * These blocks can be freed by ffree when we're done with the current file.  * We could put the free block inside struct alloclist, rather than a pointer  * to the free block, but that would be less portable.  */
end_comment

begin_struct
struct|struct
name|alloclist
block|{
name|malloc_type
name|alloc
decl_stmt|;
name|struct
name|alloclist
modifier|*
name|nextalloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|alloclist
modifier|*
name|alloced
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|malloc_type
name|okalloc
parameter_list|(
name|p
parameter_list|)
name|malloc_type
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
condition|)
name|faterror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|malloc_type
name|testalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
comment|/* Allocate a block, testing that the allocation succeeded.  */
block|{
return|return
name|okalloc
argument_list|(
name|malloc
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|malloc_type
name|testrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|malloc_type
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* Reallocate a block, testing that the allocation succeeded.  */
block|{
return|return
name|okalloc
argument_list|(
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|malloc_type
name|fremember
parameter_list|(
name|ptr
parameter_list|)
name|malloc_type
name|ptr
decl_stmt|;
comment|/* Remember PTR in 'alloced' so that it can be freed later.  Yield PTR.  */
block|{
specifier|register
name|struct
name|alloclist
modifier|*
name|q
init|=
name|talloc
argument_list|(
expr|struct
name|alloclist
argument_list|)
decl_stmt|;
name|q
operator|->
name|nextalloc
operator|=
name|alloced
expr_stmt|;
name|alloced
operator|=
name|q
expr_stmt|;
return|return
name|q
operator|->
name|alloc
operator|=
name|ptr
return|;
block|}
end_function

begin_function
name|malloc_type
name|ftestalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
comment|/* Allocate a block, putting it in 'alloced' so it can be freed later. */
block|{
return|return
name|fremember
argument_list|(
name|testalloc
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ffree
parameter_list|()
comment|/* Free all blocks allocated with ftestalloc().  */
block|{
specifier|register
name|struct
name|alloclist
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|alloced
init|;
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|p
operator|->
name|nextalloc
expr_stmt|;
name|tfree
argument_list|(
name|p
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|alloced
operator|=
name|nil
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffree1
parameter_list|(
name|f
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|f
decl_stmt|;
comment|/* Free the block f, which was allocated by ftestalloc.  */
block|{
specifier|register
name|struct
name|alloclist
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|a
init|=
operator|&
name|alloced
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|a
operator|)
operator|->
name|alloc
operator|!=
name|f
condition|)
name|a
operator|=
operator|&
name|p
operator|->
name|nextalloc
expr_stmt|;
operator|*
name|a
operator|=
name|p
operator|->
name|nextalloc
expr_stmt|;
name|tfree
argument_list|(
name|p
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|str_save
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Save s in permanently allocated storage. */
block|{
return|return
name|strcpy
argument_list|(
name|tnalloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fstr_save
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Save s in storage that will be deallocated when we're done with this file. */
block|{
return|return
name|strcpy
argument_list|(
name|ftnalloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cgetenv
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
comment|/* Like getenv(), but yield a copy; getenv() can overwrite old results. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
return|return
operator|(
name|p
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
operator|)
condition|?
name|str_save
argument_list|(
name|p
argument_list|)
else|:
name|p
return|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|getusername
parameter_list|(
name|suspicious
parameter_list|)
name|int
name|suspicious
decl_stmt|;
comment|/* Get the caller's login name.  Trust only getwpuid if SUSPICIOUS.  */
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
if|if
condition|(
comment|/* Prefer getenv() unless suspicious; it's much faster.  */
if|#
directive|if
name|getlogin_is_secure
operator|(
name|suspicious
operator|||
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
else|#
directive|else
name|suspicious
operator|||
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
endif|#
directive|endif
condition|)
block|{
if|#
directive|if
name|has_getuid
operator|&&
name|has_getpwuid
name|struct
name|passwd
specifier|const
modifier|*
name|pw
init|=
name|getpwuid
argument_list|(
name|ruid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
name|faterror
argument_list|(
literal|"no password entry for userid %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ruid
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has_setuid
name|faterror
argument_list|(
literal|"setuid not supported"
argument_list|)
expr_stmt|;
else|#
directive|else
name|faterror
argument_list|(
literal|"Who are you?  Please set LOGNAME."
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|checksid
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_signal
end_if

begin_comment
comment|/*  *	 Signal handling  *  * Standard C places too many restrictions on signal handlers.  * We obey as many of them as we can.  * Posix places fewer restrictions, and we are Posix-compatible here.  */
end_comment

begin_decl_stmt
specifier|static
name|sig_atomic_t
specifier|volatile
name|heldsignal
decl_stmt|,
name|holdlevel
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|signal_type
name|catchsig
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
name|sname
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|#
directive|if
name|sig_zaps_handler
comment|/* If a signal arrives before we reset the signal handler, we lose. */
name|VOID
name|signal
argument_list|(
name|s
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|holdlevel
condition|)
block|{
name|heldsignal
operator|=
name|s
expr_stmt|;
return|return;
block|}
name|ignoreints
argument_list|()
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
name|sname
operator|=
name|nil
expr_stmt|;
if|#
directive|if
name|has_sys_siglist
operator|&&
name|defined
argument_list|(
name|NSIG
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|s
operator|<
name|NSIG
condition|)
block|{
ifndef|#
directive|ifndef
name|sys_siglist
specifier|extern
name|char
specifier|const
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
endif|#
directive|endif
name|sname
operator|=
name|sys_siglist
index|[
name|s
index|]
expr_stmt|;
block|}
else|#
directive|else
switch|switch
condition|(
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGHUP
case|case
name|SIGHUP
case|:
name|sname
operator|=
literal|"Hangup"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
case|case
name|SIGINT
case|:
name|sname
operator|=
literal|"Interrupt"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
case|case
name|SIGPIPE
case|:
name|sname
operator|=
literal|"Broken pipe"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
name|sname
operator|=
literal|"Quit"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
case|case
name|SIGTERM
case|:
name|sname
operator|=
literal|"Terminated"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
case|case
name|SIGXCPU
case|:
name|sname
operator|=
literal|"Cputime limit exceeded"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
case|case
name|SIGXFSZ
case|:
name|sname
operator|=
literal|"Filesize limit exceeded"
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|if
condition|(
name|sname
condition|)
name|VOID
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\nRCS: %s.  Cleaning up.\n"
argument_list|,
name|sname
argument_list|)
decl_stmt|;
else|else
name|VOID
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\nRCS: Signal %d.  Cleaning up.\n"
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
block|}
name|exiterr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ignoreints
parameter_list|()
block|{
operator|++
name|holdlevel
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restoreints
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|--
name|holdlevel
operator|&&
name|heldsignal
condition|)
name|VOID
name|catchsig
argument_list|(
name|heldsignal
argument_list|)
decl_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
specifier|const
name|sig
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SIGHUP
name|SIGHUP
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
name|SIGINT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|SIGPIPE
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|SIGQUIT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|SIGTERM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
name|SIGXCPU
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|SIGXFSZ
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIGS
value|(sizeof(sig)/sizeof(*sig))
end_define

begin_if
if|#
directive|if
name|has_sigaction
end_if

begin_function
specifier|static
name|void
name|check_sig
parameter_list|(
name|r
parameter_list|)
name|int
name|r
decl_stmt|;
block|{
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"signal"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_catchsig
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|sigset_t
name|blocked
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|check_sig
argument_list|(
name|sigemptyset
argument_list|(
operator|&
name|blocked
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGS
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
name|check_sig
argument_list|(
name|sigaddset
argument_list|(
operator|&
name|blocked
argument_list|,
name|sig
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGS
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
block|{
name|check_sig
argument_list|(
name|sigaction
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|act
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|catchsig
expr_stmt|;
name|act
operator|.
name|sa_mask
operator|=
name|blocked
expr_stmt|;
name|check_sig
argument_list|(
name|sigaction
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|nil
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|has_sigblock
end_if

begin_function
specifier|static
name|void
name|setup_catchsig
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGS
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
name|mask
operator||=
name|sigmask
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGS
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|catchsig
argument_list|)
operator|==
name|SIG_IGN
operator|&&
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|catchsig
condition|)
name|faterror
argument_list|(
literal|"signal catcher failure"
argument_list|)
expr_stmt|;
name|VOID
name|sigsetmask
argument_list|(
name|mask
argument_list|)
decl_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|setup_catchsig
parameter_list|()
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SIGS
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
operator|&&
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|catchsig
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|faterror
argument_list|(
literal|"signal catcher failure"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|catchints
parameter_list|()
block|{
specifier|static
name|int
name|catching_ints
decl_stmt|;
if|if
condition|(
operator|!
name|catching_ints
condition|)
block|{
name|catching_ints
operator|=
name|true
expr_stmt|;
name|setup_catchsig
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* has_signal */
end_comment

begin_function
name|void
name|fastcopy
parameter_list|(
name|inf
parameter_list|,
name|outf
parameter_list|)
specifier|register
name|RILE
modifier|*
name|inf
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
comment|/* Function: copies the remainder of file inf to outf.  */
block|{
if|#
directive|if
name|large_memory
if|#
directive|if
name|has_mmap
name|awrite
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|inf
operator|->
name|ptr
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|inf
operator|->
name|lim
operator|-
name|inf
operator|->
name|ptr
argument_list|)
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|ptr
operator|=
name|inf
operator|->
name|lim
expr_stmt|;
else|#
directive|else
for|for
control|(
init|;
condition|;
control|)
block|{
name|awrite
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|inf
operator|->
name|ptr
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|inf
operator|->
name|readlim
operator|-
name|inf
operator|->
name|ptr
argument_list|)
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|ptr
operator|=
name|inf
operator|->
name|readlim
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|ptr
operator|==
name|inf
operator|->
name|lim
condition|)
break|break;
name|VOID
name|Igetmore
argument_list|(
name|inf
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
name|char
name|buf
index|[
name|BUFSIZ
operator|*
literal|8
index|]
decl_stmt|;
specifier|register
name|fread_type
name|rcount
decl_stmt|;
comment|/*now read the rest of the file in blocks*/
while|while
condition|(
operator|!
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rcount
operator|=
name|Fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|inf
argument_list|)
operator|)
condition|)
block|{
name|testIerror
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
name|awrite
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|rcount
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SSIZE_MAX
end_ifndef

begin_comment
comment|/* This does not work in #ifs, but it's good enough for us.  */
end_comment

begin_comment
comment|/* Underestimating SSIZE_MAX may slow us down, but it won't break us.  */
end_comment

begin_define
define|#
directive|define
name|SSIZE_MAX
value|((unsigned)-1>> 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|awrite
parameter_list|(
name|buf
parameter_list|,
name|chars
parameter_list|,
name|f
parameter_list|)
name|char
specifier|const
modifier|*
name|buf
decl_stmt|;
name|size_t
name|chars
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
comment|/* Posix 1003.1-1990 ssize_t hack */
while|while
condition|(
name|SSIZE_MAX
operator|<
name|chars
condition|)
block|{
if|if
condition|(
name|Fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|SSIZE_MAX
argument_list|,
name|f
argument_list|)
operator|!=
name|SSIZE_MAX
condition|)
name|Oerror
argument_list|()
expr_stmt|;
name|buf
operator|+=
name|SSIZE_MAX
expr_stmt|;
name|chars
operator|-=
name|SSIZE_MAX
expr_stmt|;
block|}
if|if
condition|(
name|Fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|chars
argument_list|,
name|f
argument_list|)
operator|!=
name|chars
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|movefd
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
block|{
if|if
condition|(
name|old
operator|<
literal|0
operator|||
name|old
operator|==
name|new
condition|)
return|return
name|old
return|;
ifdef|#
directive|ifdef
name|F_DUPFD
name|new
operator|=
name|fcntl
argument_list|(
name|old
argument_list|,
name|F_DUPFD
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|#
directive|else
name|new
operator|=
name|dup2
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|close
argument_list|(
name|old
argument_list|)
operator|==
literal|0
condition|?
name|new
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdreopen
parameter_list|(
name|fd
parameter_list|,
name|file
parameter_list|,
name|flags
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
specifier|const
modifier|*
name|file
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|newfd
decl_stmt|;
name|VOID
name|close
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|newfd
operator|=
if|#
directive|if
operator|!
name|open_can_creat
name|flags
operator|&
name|O_CREAT
condition|?
name|creat
argument_list|(
name|file
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
else|:
endif|#
directive|endif
name|open
argument_list|(
name|file
argument_list|,
name|flags
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
return|return
name|movefd
argument_list|(
name|newfd
argument_list|,
name|fd
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|has_spawn
end_if

begin_function
specifier|static
name|void
name|tryopen
parameter_list|(
name|fd
parameter_list|,
name|file
parameter_list|,
name|flags
parameter_list|)
name|int
name|fd
decl_stmt|,
name|flags
decl_stmt|;
name|char
specifier|const
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|file
operator|&&
name|fdreopen
argument_list|(
name|fd
argument_list|,
name|file
argument_list|,
name|flags
argument_list|)
operator|!=
name|fd
condition|)
name|efaterror
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|tryopen
parameter_list|(
name|fd
parameter_list|,
name|file
parameter_list|,
name|flags
parameter_list|)
name|int
name|fd
decl_stmt|,
name|flags
decl_stmt|;
name|char
specifier|const
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|newfd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|file
operator|&&
operator|(
operator|(
name|newfd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fdreopen
argument_list|(
name|fd
argument_list|,
name|file
argument_list|,
name|flags
argument_list|)
operator|!=
name|fd
operator|)
condition|)
name|efaterror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|newfd
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|redirect
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
block|{
if|if
condition|(
literal|0
operator|<=
name|old
operator|&&
operator|(
name|close
argument_list|(
name|new
argument_list|)
operator|!=
literal|0
operator|||
name|movefd
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|efaterror
argument_list|(
literal|"spawn I/O redirection"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_fork
operator|&&
operator|!
name|has_spawn
end_if

begin_function
specifier|static
name|void
name|bufargcat
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|s
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Append to B a copy of C, plus a quoted copy of S.  */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|t
decl_stmt|;
name|size_t
name|bl
decl_stmt|,
name|sl
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|,
name|sl
operator|=
literal|0
init|;
operator|*
name|t
condition|;
control|)
name|sl
operator|+=
literal|3
operator|*
operator|(
operator|*
name|t
operator|++
operator|==
literal|'\''
operator|)
operator|+
literal|1
expr_stmt|;
name|bl
operator|=
name|strlen
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
name|bufrealloc
argument_list|(
name|b
argument_list|,
name|bl
operator|+
name|sl
operator|+
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|string
operator|+
name|bl
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* * Run a command specified by the strings in 'inoutargs'. * inoutargs[0], if nonnil, is the name of the input file. * inoutargs[1], if nonnil, is the name of the output file. * inoutargs[2..] form the command to be run. */
end_comment

begin_function
name|int
name|runv
parameter_list|(
name|inoutargs
parameter_list|)
name|char
specifier|const
modifier|*
modifier|*
name|inoutargs
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
modifier|*
name|p
decl_stmt|;
name|int
name|wstatus
decl_stmt|;
name|oflush
argument_list|()
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|{
if|#
directive|if
name|has_spawn
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
name|p
operator|=
name|inoutargs
expr_stmt|;
name|in
operator|=
name|tryopen
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|O_BINARY
operator||
name|O_RDONLY
argument_list|)
expr_stmt|;
name|out
operator|=
name|tryopen
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|O_BINARY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|)
expr_stmt|;
name|wstatus
operator|=
name|spawn_RCS
argument_list|(
literal|0
argument_list|,
operator|*
name|p
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|wstatus
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
operator|*
operator|--
name|p
operator|=
name|RCS_SHELL
expr_stmt|;
name|wstatus
operator|=
name|spawnv
argument_list|(
literal|0
argument_list|,
operator|*
name|p
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|redirect
argument_list|(
name|in
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|redirect
argument_list|(
name|out
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has_fork
name|pid_t
name|pid
decl_stmt|;
if|#
directive|if
operator|!
name|has_waitpid
name|pid_t
name|w
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
condition|)
block|{
name|p
operator|=
name|inoutargs
expr_stmt|;
name|tryopen
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|O_BINARY
operator||
name|O_RDONLY
argument_list|)
expr_stmt|;
name|tryopen
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|O_BINARY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|)
expr_stmt|;
name|VOID
name|exec_RCS
argument_list|(
operator|*
name|p
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
operator|*
operator|--
name|p
operator|=
name|RCS_SHELL
expr_stmt|;
name|VOID
name|execv
argument_list|(
operator|*
name|p
argument_list|,
operator|(
name|char
operator|*
specifier|const
operator|*
operator|)
name|p
argument_list|)
decl_stmt|;
block|}
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
operator|*
name|p
argument_list|,
name|strlen
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
literal|": not found\n"
argument_list|,
literal|12
argument_list|)
decl_stmt|;
name|_exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|#
directive|if
name|has_waitpid
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
else|#
directive|else
do|do
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|pid
condition|)
do|;
endif|#
directive|endif
else|#
directive|else
specifier|static
name|struct
name|buf
name|b
decl_stmt|;
comment|/* Use system().  On many hosts system() discards signals.  Yuck!  */
name|p
operator|=
name|inoutargs
operator|+
literal|2
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|b
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
name|bufargcat
argument_list|(
operator|&
name|b
argument_list|,
literal|' '
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|inoutargs
index|[
literal|0
index|]
condition|)
name|bufargcat
argument_list|(
operator|&
name|b
argument_list|,
literal|'<'
argument_list|,
name|inoutargs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inoutargs
index|[
literal|1
index|]
condition|)
name|bufargcat
argument_list|(
operator|&
name|b
argument_list|,
literal|'>'
argument_list|,
name|inoutargs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|wstatus
operator|=
name|system
argument_list|(
name|b
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
condition|)
name|faterror
argument_list|(
literal|"%s failed"
argument_list|,
name|inoutargs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CARGSMAX
value|20
end_define

begin_comment
comment|/* * Run a command. * The first two arguments are the input and output files (if nonnil); * the rest specify the command and its arguments. */
end_comment

begin_function
name|int
if|#
directive|if
name|has_prototypes
name|run
parameter_list|(
name|char
specifier|const
modifier|*
name|infile
parameter_list|,
name|char
specifier|const
modifier|*
name|outfile
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|run
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|,
name|va_alist
parameter_list|)
name|char
specifier|const
modifier|*
name|infile
decl_stmt|;
name|char
specifier|const
modifier|*
name|outfile
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|char
specifier|const
modifier|*
name|rgargs
index|[
name|CARGSMAX
index|]
decl_stmt|;
specifier|register
name|i
operator|=
literal|0
expr_stmt|;
name|rgargs
index|[
literal|0
index|]
operator|=
name|infile
expr_stmt|;
name|rgargs
index|[
literal|1
index|]
operator|=
name|outfile
expr_stmt|;
name|vararg_start
argument_list|(
name|ap
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
operator|(
name|rgargs
index|[
name|i
operator|++
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
specifier|const
operator|*
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|CARGSMAX
operator|<=
name|i
condition|)
name|faterror
argument_list|(
literal|"too many command arguments"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|runv
argument_list|(
name|rgargs
argument_list|)
return|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|date2str
parameter_list|(
name|date
parameter_list|,
name|datebuf
parameter_list|)
name|char
specifier|const
name|date
index|[
name|datesize
index|]
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
index|]
decl_stmt|;
comment|/* * Format a user-readable form of the RCS format DATE into the buffer DATEBUF. * Yield DATEBUF. */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|p
init|=
name|date
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'.'
condition|)
empty_stmt|;
name|VOID
name|sprintf
argument_list|(
name|datebuf
argument_list|,
literal|"19%.*s/%.2s/%.2s %.2s:%.2s:%s"
operator|+
operator|(
name|date
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|?
literal|0
else|:
literal|2
operator|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|date
operator|-
literal|1
argument_list|)
argument_list|,
name|date
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|3
argument_list|,
name|p
operator|+
literal|6
argument_list|,
name|p
operator|+
literal|9
argument_list|,
name|p
operator|+
literal|12
argument_list|)
decl_stmt|;
return|return
name|datebuf
return|;
block|}
end_function

begin_decl_stmt
name|int
name|RCSversion
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setRCSversion
parameter_list|(
name|str
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
block|{
specifier|static
name|int
name|oldversion
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|s
init|=
name|str
operator|+
literal|2
decl_stmt|;
name|int
name|v
init|=
name|VERSION_DEFAULT
decl_stmt|;
if|if
condition|(
name|oldversion
condition|)
name|redefined
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|oldversion
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|v
operator|=
literal|10
operator|*
name|v
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|faterror
argument_list|(
literal|"%s isn't a number"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
name|VERSION_min
operator|||
name|VERSION_max
operator|<
name|v
condition|)
name|faterror
argument_list|(
literal|"%s out of range %d..%d"
argument_list|,
name|str
argument_list|,
name|VERSION_min
argument_list|,
name|VERSION_max
argument_list|)
expr_stmt|;
block|}
name|RCSversion
operator|=
name|VERSION
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|getRCSINIT
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|newargv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
modifier|*
name|newargv
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|=
name|cgetenv
argument_list|(
literal|"RCSINIT"
argument_list|)
operator|)
condition|)
operator|*
name|newargv
operator|=
name|argv
expr_stmt|;
else|else
block|{
name|n
operator|=
name|argc
operator|+
literal|2
expr_stmt|;
comment|/* 		 * Count spaces in RCSINIT to allocate a new arg vector. 		 * This is an upper bound, but it's OK even if too large. 		 */
for|for
control|(
name|p
operator|=
name|q
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
default|default:
continue|continue;
case|case
literal|' '
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
name|n
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
break|break;
block|}
break|break;
block|}
operator|*
name|newargv
operator|=
name|pp
operator|=
name|tnalloc
argument_list|(
name|char
operator|*
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
comment|/* copy program name */
for|for
control|(
name|p
operator|=
name|q
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|copyrest
goto|;
case|case
literal|' '
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
name|q
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
operator|++
name|argc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
operator|)
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|copyrest
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|!
operator|*
name|q
condition|)
goto|goto
name|copyrest
goto|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|q
operator|++
expr_stmt|;
continue|continue;
default|default:
continue|continue;
case|case
literal|' '
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
break|break;
block|}
break|break;
block|}
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|copyrest
label|:
while|while
condition|(
operator|(
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
operator|)
condition|)
empty_stmt|;
block|}
return|return
name|argc
return|;
block|}
end_block

begin_define
define|#
directive|define
name|cacheid
parameter_list|(
name|E
parameter_list|)
value|static uid_t i; static int s; if (!s){ s=1; i=(E); } return i
end_define

begin_if
if|#
directive|if
name|has_getuid
end_if

begin_function
name|uid_t
name|ruid
parameter_list|()
block|{
name|cacheid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_setuid
end_if

begin_function
name|uid_t
name|euid
parameter_list|()
block|{
name|cacheid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_setuid
end_if

begin_comment
comment|/*  * Setuid execution really works only with Posix 1003.1a Draft 5 seteuid(),  * because it lets us switch back and forth between arbitrary users.  * If seteuid() doesn't work, we fall back on setuid(),  * which works if saved setuid is supported,  * unless the real or effective user is root.  * This area is such a mess that we always check switches at runtime.  */
end_comment

begin_function
specifier|static
name|void
name|set_uid_to
parameter_list|(
name|u
parameter_list|)
name|uid_t
name|u
decl_stmt|;
comment|/* Become user u.  */
block|{
specifier|static
name|int
name|looping
decl_stmt|;
if|if
condition|(
name|euid
argument_list|()
operator|==
name|ruid
argument_list|()
condition|)
return|return;
if|#
directive|if
operator|(
name|has_fork
operator|||
name|has_spawn
operator|)
operator|&&
name|DIFF_ABSOLUTE
if|if
condition|(
name|seteuid
argument_list|(
name|u
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"setuid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
name|u
condition|)
block|{
if|if
condition|(
name|looping
condition|)
return|return;
name|looping
operator|=
name|true
expr_stmt|;
name|faterror
argument_list|(
literal|"root setuid not supported"
operator|+
operator|(
name|u
condition|?
literal|5
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|stick_with_euid
decl_stmt|;
end_decl_stmt

begin_function
name|void
comment|/* Ignore all calls to seteid() and setrid().  */
name|nosetid
parameter_list|()
block|{
name|stick_with_euid
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seteid
parameter_list|()
comment|/* Become effective user.  */
block|{
if|if
condition|(
operator|!
name|stick_with_euid
condition|)
name|set_uid_to
argument_list|(
name|euid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setrid
parameter_list|()
comment|/* Become real user.  */
block|{
if|if
condition|(
operator|!
name|stick_with_euid
condition|)
name|set_uid_to
argument_list|(
name|ruid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

