begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                      RCS create/change operation  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcs.c,v $  * Revision 5.12  1991/11/20  17:58:08  eggert  * Don't read the delta tree from a nonexistent RCS file.  *  * Revision 5.11  1991/10/07  17:32:46  eggert  * Remove lint.  *  * Revision 5.10  1991/08/19  23:17:54  eggert  * Add -m, -r$, piece tables.  Revision separator is `:', not `-'.  Tune.  *  * Revision 5.9  1991/04/21  11:58:18  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.8  1991/02/25  07:12:38  eggert  * strsave -> str_save (DG/UX name clash)  * 0444 -> S_IRUSR|S_IRGRP|S_IROTH for portability  *  * Revision 5.7  1990/12/18  17:19:21  eggert  * Fix bug with multiple -n and -N options.  *  * Revision 5.6  1990/12/04  05:18:40  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.5  1990/11/11  00:06:35  eggert  * Fix `rcs -e' core dump.  *  * Revision 5.4  1990/11/01  05:03:33  eggert  * Add -I and new -t behavior.  Permit arbitrary data in logs.  *  * Revision 5.3  1990/10/04  06:30:16  eggert  * Accumulate exit status across files.  *  * Revision 5.2  1990/09/04  08:02:17  eggert  * Standardize yes-or-no procedure.  *  * Revision 5.1  1990/08/29  07:13:51  eggert  * Remove unused setuid support.  Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:12:42  eggert  * Don't lose names when applying -a option to multiple files.  * Remove compile-time limits; use malloc instead.  Add setuid support.  * Permit dates past 1999/12/31.  Make lock and temp files faster and safer.  * Ansify and Posixate.  Add -V.  Fix umask bug.  Make linting easier.  Tune.  * Yield proper exit status.  Check diff's output.  *  * Revision 4.11  89/05/01  15:12:06  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.10  88/11/08  16:01:54  narten  * didn't install previous patch correctly  *   * Revision 4.9  88/11/08  13:56:01  narten  * removed include<sysexits.h> (not needed)  * minor fix for -A option  *   * Revision 4.8  88/08/09  19:12:27  eggert  * Don't access freed storage.  * Use execv(), not system(); yield proper exit status; remove lint.  *   * Revision 4.7  87/12/18  11:37:17  narten  * lint cleanups (Guy Harris)  *   * Revision 4.6  87/10/18  10:28:48  narten  * Updating verison numbers. Changes relative to 1.1 are actually   * relative to 4.3  *   * Revision 1.4  87/09/24  13:58:52  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.3  87/03/27  14:21:55  jenkins  * Port to suns  *   * Revision 1.2  85/12/17  13:59:09  albitz  * Changed setstate to rcs_setstate because of conflict with random.o.  *   * Revision 4.3  83/12/15  12:27:33  wft  * rcs -u now breaks most recent lock if it can't find a lock by the caller.  *   * Revision 4.2  83/12/05  10:18:20  wft  * Added conditional compilation for sending mail.  * Alternatives: V4_2BSD, V6, USG, and other.  *   * Revision 4.1  83/05/10  16:43:02  wft  * Simplified breaklock(); added calls to findlock() and getcaller().  * Added option -b (default branch). Updated -s and -w for -b.  * Removed calls to stat(); now done by pairfilenames().  * Replaced most catchints() calls with restoreints().  * Removed check for exit status of delivermail().  * Directed all interactive output to stderr.  *   * Revision 3.9.1.1  83/12/02  22:08:51  wft  * Added conditional compilation for 4.2 sendmail and 4.1 delivermail.  *   * Revision 3.9  83/02/15  15:38:39  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.8  83/01/18  17:37:51  wft  * Changed sendmail(): now uses delivermail, and asks whether to break the lock.  *  * Revision 3.7  83/01/15  18:04:25  wft  * Removed putree(); replaced with puttree() in rcssyn.c.  * Combined putdellog() and scanlogtext(); deleted putdellog().  * Cleaned up diagnostics and error messages. Fixed problem with  * mutilated files in case of deletions in 2 files in a single command.  * Changed marking of selector from 'D' to DELETE.  *  * Revision 3.6  83/01/14  15:37:31  wft  * Added ignoring of interrupts while new RCS file is renamed;  * Avoids deletion of RCS files by interrupts.  *  * Revision 3.5  82/12/10  21:11:39  wft  * Removed unused variables, fixed checking of return code from diff,  * introduced variant COMPAT2 for skipping Suffix on -A files.  *  * Revision 3.4  82/12/04  13:18:20  wft  * Replaced getdelta() with gettree(), changed breaklock to update  * field lockedby, added some diagnostics.  *  * Revision 3.3  82/12/03  17:08:04  wft  * Replaced getlogin() with getpwuid(), flcose() with ffclose(),  * /usr/ucb/Mail with macro MAIL. Removed handling of Suffix (-x).  * fixed -u for missing revno. Disambiguated structure members.  *  * Revision 3.2  82/10/18  21:05:07  wft  * rcs -i now generates a file mode given by the umask minus write permission;  * otherwise, rcs keeps the mode, but removes write permission.  * I added a check for write error, fixed call to getlogin(), replaced  * curdir() with getfullRCSname(), cleaned up handling -U/L, and changed  * conflicting, long identifiers.  *  * Revision 3.1  82/10/13  16:11:07  wft  * fixed type of variables receiving from getc() (char -> int).  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_struct
struct|struct
name|Lockrev
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|nextrev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Symrev
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|char
specifier|const
modifier|*
name|ssymbol
decl_stmt|;
name|int
name|override
decl_stmt|;
name|struct
name|Symrev
modifier|*
name|nextsym
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Message
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|struct
name|cbuf
name|message
decl_stmt|;
name|struct
name|Message
modifier|*
name|nextmessage
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Status
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|char
specifier|const
modifier|*
name|status
decl_stmt|;
name|struct
name|Status
modifier|*
name|nextstatus
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|changeaccess
block|{
name|append
block|,
name|erase
block|}
enum|;
end_enum

begin_struct
struct|struct
name|chaccess
block|{
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
name|enum
name|changeaccess
name|command
decl_stmt|;
name|struct
name|chaccess
modifier|*
name|nextchaccess
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|delrevpair
block|{
name|char
specifier|const
modifier|*
name|strt
decl_stmt|;
name|char
specifier|const
modifier|*
name|end
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|buildeltatext
name|P
argument_list|(
operator|(
expr|struct
name|hshentries
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|removerevs
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendmail
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Lockrev
modifier|*
name|rmnewlocklst
name|P
argument_list|(
operator|(
expr|struct
name|Lockrev
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|breaklock
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|buildtree
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doaccess
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doassoc
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dolocks
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|domessages
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getaccessor
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|changeaccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getassoclst
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getchaccess
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|enum
name|changeaccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getdelrev
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getmessage
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getstates
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rcs_setstate
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scanlogtext
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setlock
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
name|numrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|headstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chgheadstate
decl_stmt|,
name|exitstatus
decl_stmt|,
name|lockhead
decl_stmt|,
name|unlockcaller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Lockrev
modifier|*
name|newlocklst
decl_stmt|,
modifier|*
name|rmvlocklst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Message
modifier|*
name|messagelst
decl_stmt|,
modifier|*
name|lastmessage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Status
modifier|*
name|statelst
decl_stmt|,
modifier|*
name|laststate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Symrev
modifier|*
name|assoclst
decl_stmt|,
modifier|*
name|lastassoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|chaccess
modifier|*
name|chaccess
decl_stmt|,
modifier|*
modifier|*
name|nextchaccess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|delrevpair
name|delrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|cuthead
decl_stmt|,
modifier|*
name|cuttail
decl_stmt|,
modifier|*
name|delstrt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rcsId
argument_list|,
literal|"rcs"
argument_list|,
literal|"$Id: rcs.c,v 5.12 1991/11/20 17:58:08 eggert Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrcs usage: rcs -{ae}logins -Afile -{blu}[rev] -cstring -{iLU} -{nNs}name[:rev] -orange -t[file] -Vn file ..."
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|,
modifier|*
name|textfile
decl_stmt|;
name|char
specifier|const
modifier|*
name|branchsym
decl_stmt|,
modifier|*
name|commsyml
decl_stmt|;
name|int
name|branchflag
decl_stmt|,
name|expmode
decl_stmt|,
name|initflag
decl_stmt|;
name|int
name|e
decl_stmt|,
name|r
decl_stmt|,
name|strictlock
decl_stmt|,
name|strict_selected
decl_stmt|,
name|textflag
decl_stmt|;
name|mode_t
name|defaultRCSmode
decl_stmt|;
comment|/* default mode for new RCS files */
name|mode_t
name|RCSmode
decl_stmt|;
name|struct
name|buf
name|branchnum
decl_stmt|;
name|struct
name|stat
name|workstat
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|curlock
decl_stmt|,
modifier|*
name|rmvlock
decl_stmt|,
modifier|*
name|lockpt
decl_stmt|;
name|struct
name|Status
modifier|*
name|curstate
decl_stmt|;
name|nosetid
argument_list|()
expr_stmt|;
name|nextchaccess
operator|=
operator|&
name|chaccess
expr_stmt|;
name|branchsym
operator|=
name|commsyml
operator|=
name|textfile
operator|=
name|nil
expr_stmt|;
name|branchflag
operator|=
name|strictlock
operator|=
name|false
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|curlock
operator|=
name|rmvlock
operator|=
name|nil
expr_stmt|;
name|defaultRCSmode
operator|=
literal|0
expr_stmt|;
name|expmode
operator|=
operator|-
literal|1
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|initflag
operator|=
name|textflag
operator|=
name|false
expr_stmt|;
name|strict_selected
operator|=
literal|0
expr_stmt|;
comment|/*  preprocessing command options    */
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'i'
case|:
comment|/*  initial version  */
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* change default branch */
if|if
condition|(
name|branchflag
condition|)
name|redefined
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|branchflag
operator|=
name|true
expr_stmt|;
name|branchsym
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/*  change comment symbol   */
if|if
condition|(
name|commsyml
condition|)
name|redefined
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|commsyml
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/*  add new accessor   */
name|getaccessor
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|,
name|append
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/*  append access list according to accessfile  */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing file name after -A"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|argv
operator|=
name|a
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|pairfilenames
argument_list|(
literal|1
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
while|while
condition|(
name|AccessList
condition|)
block|{
name|getchaccess
argument_list|(
name|str_save
argument_list|(
name|AccessList
operator|->
name|login
argument_list|)
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|AccessList
operator|=
name|AccessList
operator|->
name|nextaccess
expr_stmt|;
block|}
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/*  remove accessors   */
name|getaccessor
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|,
name|erase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/*   lock a revision if it is unlocked   */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
comment|/* Lock head or default branch.  */
name|lockhead
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|lockpt
operator|=
name|talloc
argument_list|(
expr|struct
name|Lockrev
argument_list|)
expr_stmt|;
name|lockpt
operator|->
name|revno
operator|=
name|a
expr_stmt|;
name|lockpt
operator|->
name|nextrev
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|curlock
condition|)
name|curlock
operator|->
name|nextrev
operator|=
name|lockpt
expr_stmt|;
else|else
name|newlocklst
operator|=
name|lockpt
expr_stmt|;
name|curlock
operator|=
name|lockpt
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/*  release lock of a locked revision   */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|unlockcaller
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|lockpt
operator|=
name|talloc
argument_list|(
expr|struct
name|Lockrev
argument_list|)
expr_stmt|;
name|lockpt
operator|->
name|revno
operator|=
name|a
expr_stmt|;
name|lockpt
operator|->
name|nextrev
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|rmvlock
condition|)
name|rmvlock
operator|->
name|nextrev
operator|=
name|lockpt
expr_stmt|;
else|else
name|rmvlocklst
operator|=
name|lockpt
expr_stmt|;
name|rmvlock
operator|=
name|lockpt
expr_stmt|;
name|curlock
operator|=
name|rmnewlocklst
argument_list|(
name|lockpt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/*  set strict locking */
if|if
condition|(
name|strict_selected
operator|++
condition|)
block|{
comment|/* Already selected L or U? */
if|if
condition|(
operator|!
name|strictlock
condition|)
comment|/* Already selected -U? */
name|warn
argument_list|(
literal|"-L overrides -U."
argument_list|)
expr_stmt|;
block|}
name|strictlock
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/*  release strict locking */
if|if
condition|(
name|strict_selected
operator|++
condition|)
block|{
comment|/* Already selected L or U? */
if|if
condition|(
name|strictlock
condition|)
comment|/* Already selected -L? */
name|warn
argument_list|(
literal|"-L overrides -U."
argument_list|)
expr_stmt|;
block|}
else|else
name|strictlock
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/*  add new association: error, if name exists */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing symbolic name after -n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getassoclst
argument_list|(
name|false
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/*  add or change association   */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing symbolic name after -N"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getassoclst
argument_list|(
name|true
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/*  change log message  */
name|getmessage
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/*  delete revisions  */
if|if
condition|(
name|delrev
operator|.
name|strt
condition|)
name|redefined
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing revision range after -o"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getdelrev
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/*  change state attribute of a revision  */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"state missing after -s"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getstates
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/*  change descriptive text   */
name|textflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|textfile
condition|)
name|redefined
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|textfile
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
name|interactiveflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|setRCSversion
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/*  set keyword expand mode  */
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|redefined
argument_list|(
literal|'k'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|expmode
operator|=
name|str2expmode
argument_list|(
name|a
argument_list|)
operator|)
condition|)
break|break;
comment|/* fall into */
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end processing of options */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerror
condition|)
block|{
name|diagnose
argument_list|(
literal|"%s aborted\n"
argument_list|,
name|cmdid
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initflag
condition|)
block|{
name|defaultRCSmode
operator|=
name|umask
argument_list|(
operator|(
name|mode_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|VOID
name|umask
parameter_list|(
name|defaultRCSmode
parameter_list|)
function_decl|;
name|defaultRCSmode
operator|=
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator|)
operator|&
operator|~
name|defaultRCSmode
expr_stmt|;
block|}
comment|/* now handle all filenames */
do|do
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|initflag
condition|)
block|{
switch|switch
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcswriteopen
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
comment|/*  not exist; ok */
case|case
literal|0
case|:
continue|continue;
comment|/*  error         */
case|case
literal|1
case|:
name|error
argument_list|(
literal|"file %s exists already"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcswriteopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
continue|continue;
comment|/*  not exist      */
case|case
literal|0
case|:
continue|continue;
comment|/*  errors         */
case|case
literal|1
case|:
break|break;
comment|/*  file exists; ok*/
block|}
block|}
comment|/* now RCSfilename contains the name of the RCS file, and          * workfilename contains the name of the working file.          * if !initflag, finptr contains the file descriptor for the          * RCS file. The admin node is initialized.          */
name|diagnose
argument_list|(
literal|"RCS file: %s\n"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|RCSmode
operator|=
name|defaultRCSmode
expr_stmt|;
if|if
condition|(
name|initflag
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|workfilename
argument_list|,
operator|&
name|workstat
argument_list|)
operator|==
literal|0
condition|)
name|RCSmode
operator|=
name|workstat
operator|.
name|st_mode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|checkaccesslist
argument_list|()
condition|)
continue|continue;
name|gettree
argument_list|()
expr_stmt|;
comment|/* Read the delta tree.  */
name|RCSmode
operator|=
name|RCSstat
operator|.
name|st_mode
expr_stmt|;
block|}
name|RCSmode
operator|&=
operator|~
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
expr_stmt|;
comment|/*  update admin. node    */
if|if
condition|(
name|strict_selected
condition|)
name|StrictLocks
operator|=
name|strictlock
expr_stmt|;
if|if
condition|(
name|commsyml
condition|)
block|{
name|Comment
operator|.
name|string
operator|=
name|commsyml
expr_stmt|;
name|Comment
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|commsyml
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|Expand
operator|=
name|expmode
expr_stmt|;
comment|/* update default branch */
if|if
condition|(
name|branchflag
operator|&&
name|expandsym
argument_list|(
name|branchsym
argument_list|,
operator|&
name|branchnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|countnumflds
argument_list|(
name|branchnum
operator|.
name|string
argument_list|)
condition|)
block|{
name|Dbranch
operator|=
name|branchnum
operator|.
name|string
expr_stmt|;
block|}
else|else
name|Dbranch
operator|=
name|nil
expr_stmt|;
block|}
name|doaccess
argument_list|()
expr_stmt|;
comment|/* Update access list.  */
name|doassoc
argument_list|()
expr_stmt|;
comment|/* Update association list.  */
name|dolocks
argument_list|()
expr_stmt|;
comment|/* Update locks.  */
name|domessages
argument_list|()
expr_stmt|;
comment|/* Update log messages.  */
comment|/*  update state attribution  */
if|if
condition|(
name|chgheadstate
condition|)
block|{
comment|/* change state of default branch or head */
if|if
condition|(
name|Dbranch
operator|==
name|nil
condition|)
block|{
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
name|warn
argument_list|(
literal|"can't change states in an empty tree"
argument_list|)
expr_stmt|;
else|else
name|Head
operator|->
name|state
operator|=
name|headstate
expr_stmt|;
block|}
else|else
block|{
name|rcs_setstate
argument_list|(
name|Dbranch
argument_list|,
name|headstate
argument_list|)
expr_stmt|;
comment|/* Can't set directly */
block|}
block|}
name|curstate
operator|=
name|statelst
expr_stmt|;
while|while
condition|(
name|curstate
condition|)
block|{
name|rcs_setstate
argument_list|(
name|curstate
operator|->
name|revno
argument_list|,
name|curstate
operator|->
name|status
argument_list|)
expr_stmt|;
name|curstate
operator|=
name|curstate
operator|->
name|nextstatus
expr_stmt|;
block|}
name|cuthead
operator|=
name|cuttail
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|delrev
operator|.
name|strt
operator|&&
name|removerevs
argument_list|()
condition|)
block|{
comment|/*  rebuild delta tree if some deltas are deleted   */
if|if
condition|(
name|cuttail
condition|)
name|VOID
name|genrevs
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
decl_stmt|;
name|buildtree
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nerror
condition|)
continue|continue;
name|putadmin
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|Head
condition|)
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|putdesc
argument_list|(
name|textflag
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
operator|!
name|delrev
operator|.
name|strt
operator|&&
operator|!
name|messagelst
condition|)
block|{
comment|/* No revision was deleted and no message was changed.  */
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cuttail
operator|||
name|buildeltatext
argument_list|(
name|gendeltas
argument_list|)
condition|)
block|{
name|advise_access
argument_list|(
name|finptr
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
name|scanlogtext
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* copy rest of delta text nodes that are not deleted      */
block|}
block|}
block|}
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nerror
condition|)
block|{
comment|/*  move temporary file to RCS file if no error */
comment|/* update mode */
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|chnamemod
argument_list|(
operator|&
name|frewrite
argument_list|,
name|newRCSfilename
argument_list|,
name|RCSfilename
argument_list|,
name|RCSmode
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|newRCSfilename
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|enerror
argument_list|(
name|e
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"saved in %s"
argument_list|,
name|newRCSfilename
argument_list|)
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
break|break;
block|}
name|diagnose
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"%s aborted; %s unchanged.\n"
argument_list|,
name|cmdid
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|tempunlink
argument_list|()
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of main (rcs) */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|frewrite
argument_list|)
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getassoclst
parameter_list|(
name|flag
parameter_list|,
name|sp
parameter_list|)
name|int
name|flag
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*  Function:   associate a symbolic name to a revision or branch,      */
comment|/*              and store in assoclst                                   */
block|{
name|struct
name|Symrev
modifier|*
name|pt
decl_stmt|;
name|char
specifier|const
modifier|*
name|temp
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|temp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/*  check for invalid symbolic name  */
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"invalid string %s after option -n or -N"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Symrev
argument_list|)
expr_stmt|;
name|pt
operator|->
name|ssymbol
operator|=
name|temp
expr_stmt|;
name|pt
operator|->
name|override
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
comment|/*  delete symbol  */
name|pt
operator|->
name|revno
operator|=
name|nil
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|pt
operator|->
name|revno
operator|=
name|sp
expr_stmt|;
block|}
name|pt
operator|->
name|nextsym
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|lastassoc
condition|)
name|lastassoc
operator|->
name|nextsym
operator|=
name|pt
expr_stmt|;
else|else
name|assoclst
operator|=
name|pt
expr_stmt|;
name|lastassoc
operator|=
name|pt
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|getchaccess
parameter_list|(
name|login
parameter_list|,
name|command
parameter_list|)
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
name|enum
name|changeaccess
name|command
decl_stmt|;
block|{
specifier|register
name|struct
name|chaccess
modifier|*
name|pt
decl_stmt|;
operator|*
name|nextchaccess
operator|=
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|chaccess
argument_list|)
expr_stmt|;
name|pt
operator|->
name|login
operator|=
name|login
expr_stmt|;
name|pt
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|pt
operator|->
name|nextchaccess
operator|=
name|nil
expr_stmt|;
name|nextchaccess
operator|=
operator|&
name|pt
operator|->
name|nextchaccess
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getaccessor
parameter_list|(
name|opt
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|opt
decl_stmt|;
name|enum
name|changeaccess
name|command
decl_stmt|;
comment|/*   Function:  get the accessor list of options -e and -a,     */
comment|/*		and store in chaccess				*/
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|opt
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|command
operator|==
name|erase
operator|&&
name|sp
operator|-
name|opt
operator|==
literal|1
condition|)
block|{
name|getchaccess
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|nil
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"missing login name after option -a or -e"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|getchaccess
argument_list|(
name|sp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|sp
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getmessage
parameter_list|(
name|option
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
block|{
name|struct
name|Message
modifier|*
name|pt
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"-m option lacks revision number"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
name|cleanlogmsg
argument_list|(
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|size
condition|)
block|{
name|error
argument_list|(
literal|"-m option lacks log message"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Message
argument_list|)
expr_stmt|;
name|pt
operator|->
name|revno
operator|=
name|option
expr_stmt|;
name|pt
operator|->
name|message
operator|=
name|cb
expr_stmt|;
name|pt
operator|->
name|nextmessage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lastmessage
condition|)
name|lastmessage
operator|->
name|nextmessage
operator|=
name|pt
expr_stmt|;
else|else
name|messagelst
operator|=
name|pt
expr_stmt|;
name|lastmessage
operator|=
name|pt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getstates
parameter_list|(
name|sp
parameter_list|)
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*   Function:  get one state attribute and the corresponding   */
comment|/*              revision and store in statelst                  */
block|{
name|char
specifier|const
modifier|*
name|temp
decl_stmt|;
name|struct
name|Status
modifier|*
name|pt
decl_stmt|;
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|temp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* check for invalid state attribute */
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  change state of def. branch or Head  */
name|chgheadstate
operator|=
name|true
expr_stmt|;
name|headstate
operator|=
name|temp
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|error
argument_list|(
literal|"missing ':' after state in option -s"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Status
argument_list|)
expr_stmt|;
name|pt
operator|->
name|status
operator|=
name|temp
expr_stmt|;
name|pt
operator|->
name|revno
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|nextstatus
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|laststate
condition|)
name|laststate
operator|->
name|nextstatus
operator|=
name|pt
expr_stmt|;
else|else
name|statelst
operator|=
name|pt
expr_stmt|;
name|laststate
operator|=
name|pt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getdelrev
parameter_list|(
name|sp
parameter_list|)
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*   Function:  get revision range or branch to be deleted,     */
comment|/*              and place in delrev                             */
block|{
name|int
name|c
decl_stmt|;
name|struct
name|delrevpair
modifier|*
name|pt
decl_stmt|;
name|int
name|separator
decl_stmt|;
name|pt
operator|=
operator|&
name|delrev
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
comment|/* Support old ambiguous '-' syntax; this will go away.  */
if|if
condition|(
name|strchr
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
condition|)
name|separator
operator|=
literal|':'
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|sp
argument_list|,
literal|'-'
argument_list|)
operator|&&
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|)
name|warn
argument_list|(
literal|"`-' is obsolete in `-o%s'; use `:' instead"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|separator
condition|)
block|{
comment|/* -o:rev */
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
name|pt
operator|->
name|strt
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|pt
operator|->
name|end
operator|=
name|nil
expr_stmt|;
return|return;
block|}
else|else
block|{
name|pt
operator|->
name|strt
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|separator
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*   -o rev or branch   */
name|pt
operator|->
name|end
operator|=
name|nil
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|!=
name|separator
condition|)
block|{
name|faterror
argument_list|(
literal|"invalid range %s %s after -o"
argument_list|,
name|pt
operator|->
name|strt
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* -orev: */
name|pt
operator|->
name|end
operator|=
name|nil
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|2
expr_stmt|;
return|return;
block|}
block|}
comment|/* -orev1:rev2 */
name|pt
operator|->
name|end
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scanlogtext
parameter_list|(
name|delta
parameter_list|,
name|edit
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|int
name|edit
decl_stmt|;
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta, or up to last one present, if delta==nil.  * For the one given by delta (if delta!=nil), the log message is saved into  * delta->log if delta==cuttail; the text is edited if EDIT is set, else copied.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished, except if delta==nil.  */
block|{
name|struct
name|hshentry
specifier|const
modifier|*
name|nextdelta
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eoflex
argument_list|()
condition|)
block|{
if|if
condition|(
name|delta
condition|)
name|faterror
argument_list|(
literal|"can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
return|return;
comment|/* no more delta text nodes */
block|}
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
name|faterror
argument_list|(
literal|"delta number corrupted"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextdelta
operator|->
name|selector
condition|)
block|{
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|aprintf
argument_list|(
name|frewrite
argument_list|,
name|DELNUMFORM
argument_list|,
name|nextdelta
operator|->
name|num
argument_list|,
name|Klog
argument_list|)
expr_stmt|;
block|}
name|getkeystring
argument_list|(
name|Klog
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextdelta
operator|==
name|cuttail
condition|)
block|{
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|curlogbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
operator|->
name|log
operator|.
name|string
condition|)
name|delta
operator|->
name|log
operator|=
name|cleanlogmsg
argument_list|(
name|curlogbuf
operator|.
name|string
argument_list|,
name|cb
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextdelta
operator|->
name|log
operator|.
name|string
operator|&&
name|nextdelta
operator|->
name|selector
condition|)
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
name|readstring
argument_list|()
expr_stmt|;
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|putstring
argument_list|(
name|foutptr
argument_list|,
name|false
argument_list|,
name|nextdelta
operator|->
name|log
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
name|nextc
argument_list|,
name|foutptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readstring
argument_list|()
expr_stmt|;
block|}
name|nextlex
argument_list|()
expr_stmt|;
while|while
condition|(
name|nexttok
operator|==
name|ID
operator|&&
name|strcmp
argument_list|(
name|NextString
argument_list|,
name|Ktext
argument_list|)
operator|!=
literal|0
condition|)
name|ignorephrase
argument_list|()
expr_stmt|;
name|getkeystring
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
break|break;
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
comment|/* got the one we're looking for */
if|if
condition|(
name|edit
condition|)
name|editstring
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
else|else
name|enterstring
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|Lockrev
modifier|*
name|rmnewlocklst
parameter_list|(
name|which
parameter_list|)
name|struct
name|Lockrev
specifier|const
modifier|*
name|which
decl_stmt|;
comment|/*   Function:  remove lock to revision which->revno from newlocklst   */
block|{
name|struct
name|Lockrev
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
while|while
condition|(
name|newlocklst
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|newlocklst
operator|->
name|revno
argument_list|,
name|which
operator|->
name|revno
argument_list|)
operator|)
condition|)
block|{
name|struct
name|Lockrev
modifier|*
name|pn
init|=
name|newlocklst
operator|->
name|nextrev
decl_stmt|;
name|tfree
argument_list|(
name|newlocklst
argument_list|)
expr_stmt|;
name|newlocklst
operator|=
name|pn
expr_stmt|;
block|}
name|pt
operator|=
name|pre
operator|=
name|newlocklst
expr_stmt|;
while|while
condition|(
name|pt
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pt
operator|->
name|revno
argument_list|,
name|which
operator|->
name|revno
argument_list|)
condition|)
block|{
name|pre
operator|->
name|nextrev
operator|=
name|pt
operator|->
name|nextrev
expr_stmt|;
name|tfree
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pre
operator|->
name|nextrev
expr_stmt|;
block|}
else|else
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextrev
expr_stmt|;
block|}
block|}
return|return
name|pre
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doaccess
parameter_list|()
block|{
specifier|register
name|struct
name|chaccess
modifier|*
name|ch
decl_stmt|;
specifier|register
name|struct
name|access
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|ch
operator|=
name|chaccess
init|;
name|ch
condition|;
name|ch
operator|=
name|ch
operator|->
name|nextchaccess
control|)
block|{
switch|switch
condition|(
name|ch
operator|->
name|command
condition|)
block|{
case|case
name|erase
case|:
if|if
condition|(
operator|!
name|ch
operator|->
name|login
condition|)
name|AccessList
operator|=
name|nil
expr_stmt|;
else|else
for|for
control|(
name|p
operator|=
operator|&
name|AccessList
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ch
operator|->
name|login
argument_list|,
name|t
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
name|t
operator|->
name|nextaccess
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|t
operator|->
name|nextaccess
expr_stmt|;
break|break;
case|case
name|append
case|:
for|for
control|(
name|p
operator|=
operator|&
name|AccessList
init|;
condition|;
name|p
operator|=
operator|&
name|t
operator|->
name|nextaccess
control|)
if|if
condition|(
operator|!
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|)
block|{
operator|*
name|p
operator|=
name|t
operator|=
name|ftalloc
argument_list|(
expr|struct
name|access
argument_list|)
expr_stmt|;
name|t
operator|->
name|login
operator|=
name|ch
operator|->
name|login
expr_stmt|;
name|t
operator|->
name|nextaccess
operator|=
name|nil
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ch
operator|->
name|login
argument_list|,
name|t
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
break|break;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sendmail
parameter_list|(
name|Delta
parameter_list|,
name|who
parameter_list|)
name|char
specifier|const
modifier|*
name|Delta
decl_stmt|,
decl|*
name|who
decl_stmt|;
end_function

begin_comment
comment|/*   Function:  mail to who, informing him that his lock on delta was  *   broken by caller. Ask first whether to go ahead. Return false on  *   error or if user decides not to break the lock.  */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|SENDMAIL
name|char
specifier|const
modifier|*
name|messagefile
decl_stmt|;
name|int
name|old1
decl_stmt|,
name|old2
decl_stmt|,
name|c
decl_stmt|;
name|FILE
modifier|*
name|mailmess
decl_stmt|;
endif|#
directive|endif
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"Revision %s is already locked by %s.\n"
argument_list|,
name|Delta
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yesorno
argument_list|(
name|false
argument_list|,
literal|"Do you want to break the lock? [ny](n): "
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* go ahead with breaking  */
ifdef|#
directive|ifdef
name|SENDMAIL
name|messagefile
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mailmess
operator|=
name|fopen
argument_list|(
name|messagefile
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|efaterror
argument_list|(
name|messagefile
argument_list|)
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|mailmess
argument_list|,
literal|"Subject: Broken lock on %s\n\nYour lock on revision %s of file %s\nhas been broken by %s for the following reason:\n"
argument_list|,
name|basename
argument_list|(
name|RCSfilename
argument_list|)
argument_list|,
name|Delta
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"State the reason for breaking the lock:\n(terminate with single '.' or end of file)\n>> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getcstdin
argument_list|()
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|aprintf
argument_list|(
name|mailmess
argument_list|,
literal|"%c\n"
argument_list|,
name|old1
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
break|break;
else|else
block|{
name|afputc
argument_list|(
name|old1
argument_list|,
name|mailmess
argument_list|)
expr_stmt|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|aputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
name|Ozclose
argument_list|(
operator|&
name|mailmess
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
argument_list|(
name|messagefile
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
name|SENDMAIL
argument_list|,
name|who
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Mail may have failed."
argument_list|)
operator|,
else|#
directive|else
name|warn
argument_list|(
literal|"Mail notification of broken locks is not available."
argument_list|)
operator|,
endif|#
directive|endif
name|warn
argument_list|(
literal|"Please tell `%s' why you broke the lock."
argument_list|,
name|who
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|breaklock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* function: Finds the lock held by caller on delta,  * and removes it.  * Sends mail if a lock different from the caller's is broken.  * Prints an error message if there is no such lock or error.  */
block|{
specifier|register
name|struct
name|lock
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
name|struct
name|lock
name|dummy
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
name|dummy
operator|.
name|nextlock
operator|=
name|next
operator|=
name|Locks
expr_stmt|;
name|trail
operator|=
operator|&
name|dummy
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|sendmail
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s still locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
comment|/* exact match */
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
comment|/*found one */
name|diagnose
argument_list|(
literal|"%s unlocked\n"
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|trail
operator|->
name|nextlock
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
name|nil
expr_stmt|;
name|Locks
operator|=
name|dummy
operator|.
name|nextlock
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"no lock set on revision %s"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|hshentry
modifier|*
name|searchcutpt
parameter_list|(
name|object
parameter_list|,
name|length
parameter_list|,
name|store
parameter_list|)
name|char
specifier|const
modifier|*
name|object
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|store
decl_stmt|;
comment|/*   Function:  Search store and return entry with number being object. */
comment|/*              cuttail = nil, if the entry is Head; otherwise, cuttail */
comment|/*              is the entry point to the one with number being object  */
block|{
name|cuthead
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|compartial
argument_list|(
name|store
operator|->
name|first
operator|->
name|num
argument_list|,
name|object
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|cuthead
operator|=
name|store
operator|->
name|first
expr_stmt|;
name|store
operator|=
name|store
operator|->
name|rest
expr_stmt|;
block|}
return|return
name|store
operator|->
name|first
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|branchpoint
parameter_list|(
name|strt
parameter_list|,
name|tail
parameter_list|)
name|struct
name|hshentry
modifier|*
name|strt
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_comment
comment|/*   Function: check whether the deltas between strt and tail	*/
end_comment

begin_comment
comment|/*		are locked or branch point, return 1 if any is  */
end_comment

begin_comment
comment|/*		locked or branch point; otherwise, return 0 and */
end_comment

begin_comment
comment|/*		mark deleted					*/
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|pt
decl_stmt|;
name|struct
name|lock
specifier|const
modifier|*
name|lockpt
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|pt
operator|=
name|strt
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|pt
operator|->
name|branches
condition|)
block|{
comment|/*  a branch point  */
name|flag
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"can't remove branch point %s"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|lockpt
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|lockpt
operator|&&
name|lockpt
operator|->
name|delta
operator|!=
name|pt
condition|)
name|lockpt
operator|=
name|lockpt
operator|->
name|nextlock
expr_stmt|;
if|if
condition|(
name|lockpt
condition|)
block|{
name|flag
operator|=
name|true
expr_stmt|;
name|error
argument_list|(
literal|"can't remove locked revision %s"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag
condition|)
block|{
name|pt
operator|=
name|strt
expr_stmt|;
while|while
condition|(
name|pt
operator|!=
name|tail
condition|)
block|{
name|pt
operator|->
name|selector
operator|=
name|false
expr_stmt|;
name|diagnose
argument_list|(
literal|"deleting revision %s\n"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|flag
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|removerevs
parameter_list|()
comment|/*   Function:  get the revision range to be removed, and place the     */
comment|/*              first revision removed in delstrt, the revision before  */
comment|/*              delstrt in cuthead( nil, if delstrt is head), and the   */
comment|/*              revision after the last removed revision in cuttail(nil */
comment|/*              if the last is a leaf                                   */
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|,
modifier|*
name|target2
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|delrev
operator|.
name|strt
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|flag
operator|=
name|true
expr_stmt|;
name|length
operator|=
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|delrev
operator|.
name|code
operator|==
literal|0
condition|)
block|{
comment|/*  -o  rev    or    -o  branch   */
if|if
condition|(
name|length
operator|&
literal|1
condition|)
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
operator|+
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s doesn't exist."
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
comment|/* first revision to be removed   */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|length
operator|&
literal|1
condition|)
block|{
comment|/*  invalid branch after -o   */
name|error
argument_list|(
literal|"invalid branch range %s after -o"
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|delrev
operator|.
name|code
operator|==
literal|1
condition|)
block|{
comment|/*  -o  -rev   */
if|if
condition|(
name|length
operator|>
literal|2
condition|)
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
expr_stmt|;
while|while
condition|(
name|cuttail
operator|&&
operator|!
name|cmpnumfld
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|cuttail
operator|->
name|num
argument_list|,
literal|1
argument_list|)
condition|)
name|cuttail
operator|=
name|cuttail
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|delrev
operator|.
name|code
operator|==
literal|2
condition|)
block|{
comment|/*  -o  rev-   */
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|cuttail
operator|=
name|target
expr_stmt|;
else|else
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag
condition|)
block|{
name|cuthead
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|target
operator|->
name|next
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|getbranchno
argument_list|(
name|temp
operator|->
name|num
argument_list|,
operator|&
name|numrev
argument_list|)
expr_stmt|;
comment|/* get branch number */
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*   -o   rev1-rev2   */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|delrev
operator|.
name|end
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|!=
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|||
name|length
operator|>
literal|2
operator|&&
name|compartial
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|length
operator|-
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid revision range %s-%s"
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|target2
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|>
literal|2
condition|)
block|{
comment|/* delete revisions on branches  */
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cmpnum
argument_list|(
name|target2
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|flag
operator|=
name|true
expr_stmt|;
else|else
name|flag
operator|=
name|false
expr_stmt|;
name|temp
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|target2
expr_stmt|;
name|target2
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
operator|!
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Revisions %s-%s don't exist."
argument_list|,
name|delrev
operator|.
name|strt
argument_list|,
name|delrev
operator|.
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cuthead
operator|=
name|target
expr_stmt|;
name|temp
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target2
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/*  delete revisions on trunk  */
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|target2
expr_stmt|;
name|target2
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmpnum
argument_list|(
name|target2
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|flag
operator|=
name|true
expr_stmt|;
else|else
name|flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
if|if
condition|(
operator|!
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Revisions %s-%s don't exist."
argument_list|,
name|delrev
operator|.
name|strt
argument_list|,
name|delrev
operator|.
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cuttail
operator|=
name|target2
expr_stmt|;
block|}
else|else
name|cuttail
operator|=
name|target2
operator|->
name|next
expr_stmt|;
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
name|nil
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|doassoc
parameter_list|()
comment|/*   Function: add or delete(if revno is nil) association	*/
comment|/*		which is stored in assoclst			*/
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|struct
name|Symrev
specifier|const
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|assoc
modifier|*
name|pre
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
comment|/*  add new associations   */
name|curassoc
operator|=
name|assoclst
expr_stmt|;
while|while
condition|(
name|curassoc
condition|)
block|{
if|if
condition|(
name|curassoc
operator|->
name|revno
operator|==
name|nil
condition|)
block|{
comment|/* delete symbol  */
name|pre
operator|=
name|pt
operator|=
name|Symbols
expr_stmt|;
while|while
condition|(
name|pt
operator|&&
name|strcmp
argument_list|(
name|pt
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|ssymbol
argument_list|)
condition|)
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
block|}
if|if
condition|(
name|pt
condition|)
if|if
condition|(
name|pre
operator|==
name|pt
condition|)
name|Symbols
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
else|else
name|pre
operator|->
name|nextassoc
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"can't delete nonexisting symbol %s"
argument_list|,
name|curassoc
operator|->
name|ssymbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|curassoc
operator|->
name|revno
index|[
literal|0
index|]
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|curassoc
operator|->
name|revno
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
name|p
operator|=
name|fstr_save
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|tiprev
argument_list|()
operator|)
condition|)
name|error
argument_list|(
literal|"no latest revision to associate with symbol %s"
argument_list|,
name|curassoc
operator|->
name|ssymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|VOID
name|addsymbol
argument_list|(
name|p
argument_list|,
name|curassoc
operator|->
name|ssymbol
argument_list|,
name|curassoc
operator|->
name|override
argument_list|)
decl_stmt|;
block|}
name|curassoc
operator|=
name|curassoc
operator|->
name|nextsym
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dolocks
parameter_list|()
comment|/* Function: remove lock for caller or first lock if unlockcaller is set;  *           remove locks which are stored in rmvlocklst,  *           add new locks which are stored in newlocklst,  *           add lock for Dbranch or Head if lockhead is set.  */
block|{
name|struct
name|Lockrev
specifier|const
modifier|*
name|lockpt
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|unlockcaller
condition|)
block|{
comment|/*  find lock for caller  */
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
name|Locks
condition|)
block|{
switch|switch
condition|(
name|findlock
argument_list|(
name|true
argument_list|,
operator|&
name|target
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|breaklock
argument_list|(
name|Locks
operator|->
name|delta
argument_list|)
expr_stmt|;
comment|/* remove most recent lock */
break|break;
case|case
literal|1
case|:
name|diagnose
argument_list|(
literal|"%s unlocked\n"
argument_list|,
name|target
operator|->
name|num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|warn
argument_list|(
literal|"No locks are set."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|warn
argument_list|(
literal|"can't unlock an empty tree"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  remove locks which are stored in rmvlocklst   */
name|lockpt
operator|=
name|rmvlocklst
expr_stmt|;
while|while
condition|(
name|lockpt
condition|)
block|{
if|if
condition|(
name|expandsym
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't unlock nonexisting revision %s"
argument_list|,
name|lockpt
operator|->
name|revno
argument_list|)
expr_stmt|;
else|else
name|breaklock
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* breaklock does its own diagnose */
block|}
name|lockpt
operator|=
name|lockpt
operator|->
name|nextrev
expr_stmt|;
block|}
comment|/*  add new locks which stored in newlocklst  */
name|lockpt
operator|=
name|newlocklst
expr_stmt|;
while|while
condition|(
name|lockpt
condition|)
block|{
name|setlock
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|)
expr_stmt|;
name|lockpt
operator|=
name|lockpt
operator|->
name|nextrev
expr_stmt|;
block|}
if|if
condition|(
name|lockhead
condition|)
block|{
comment|/*  lock default branch or head  */
if|if
condition|(
name|Dbranch
condition|)
block|{
name|setlock
argument_list|(
name|Dbranch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
literal|0
operator|<=
name|addlock
argument_list|(
name|Head
argument_list|)
condition|)
name|diagnose
argument_list|(
literal|"%s locked\n"
argument_list|,
name|Head
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warn
argument_list|(
literal|"can't lock an empty tree"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setlock
parameter_list|(
name|rev
parameter_list|)
name|char
specifier|const
modifier|*
name|rev
decl_stmt|;
comment|/* Function: Given a revision or branch number, finds the corresponding  * delta and locks it for caller.  */
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't lock nonexisting revision %s"
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<=
name|addlock
argument_list|(
name|target
argument_list|)
condition|)
name|diagnose
argument_list|(
literal|"%s locked\n"
argument_list|,
name|target
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|domessages
parameter_list|()
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|struct
name|Message
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|messagelst
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextmessage
control|)
if|if
condition|(
name|expandsym
argument_list|(
name|p
operator|->
name|revno
argument_list|,
operator|&
name|numrev
argument_list|)
operator|&&
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
name|target
operator|->
name|log
operator|=
name|p
operator|->
name|message
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rcs_setstate
parameter_list|(
name|rev
parameter_list|,
name|status
parameter_list|)
name|char
specifier|const
modifier|*
name|rev
decl_stmt|,
decl|*
name|status
decl_stmt|;
end_function

begin_comment
comment|/* Function: Given a revision or branch number, finds the corresponding delta  * and sets its state to status.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|error
argument_list|(
literal|"can't set state of nonexisting revision %s to %s"
argument_list|,
name|numrev
operator|.
name|string
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|target
operator|->
name|state
operator|=
name|status
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|int
name|buildeltatext
parameter_list|(
name|deltas
parameter_list|)
name|struct
name|hshentries
specifier|const
modifier|*
name|deltas
decl_stmt|;
comment|/*   Function:  put the delta text on frewrite and make necessary   */
comment|/*              change to delta text                                */
block|{
specifier|register
name|FILE
modifier|*
name|fcut
decl_stmt|;
comment|/* temporary file to rebuild delta tree */
name|char
specifier|const
modifier|*
name|cutfilename
decl_stmt|,
modifier|*
name|diffilename
decl_stmt|;
name|cutfilename
operator|=
name|nil
expr_stmt|;
name|cuttail
operator|->
name|selector
operator|=
name|false
expr_stmt|;
name|scanlogtext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|cuthead
condition|)
block|{
name|cutfilename
operator|=
name|maketemp
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fcut
operator|=
name|fopen
argument_list|(
name|cutfilename
argument_list|,
name|FOPEN_W_WORK
argument_list|)
operator|)
condition|)
block|{
name|efaterror
argument_list|(
name|cutfilename
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deltas
operator|->
name|first
operator|!=
name|cuthead
condition|)
block|{
name|deltas
operator|=
name|deltas
operator|->
name|rest
expr_stmt|;
name|scanlogtext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|snapshotedit
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
name|Ofclose
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deltas
operator|->
name|first
operator|!=
name|cuttail
condition|)
name|scanlogtext
argument_list|(
operator|(
name|deltas
operator|=
name|deltas
operator|->
name|rest
operator|)
operator|->
name|first
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|cuthead
condition|)
block|{
name|diffilename
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|run
argument_list|(
argument|(char*)nil
argument_list|,
argument|diffilename
argument_list|,
argument|DIFF DIFF_FLAGS
argument_list|,
argument|cutfilename
argument_list|,
argument|resultfile
argument_list|,
argument|(char*)nil
argument_list|)
condition|)
block|{
case|case
name|DIFF_FAILURE
case|:
case|case
name|DIFF_SUCCESS
case|:
break|break;
default|default:
name|faterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
block|}
return|return
name|putdtext
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
name|cuttail
operator|->
name|log
argument_list|,
name|diffilename
argument_list|,
name|frewrite
argument_list|,
name|true
argument_list|)
return|;
block|}
else|else
return|return
name|putdtext
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
name|cuttail
operator|->
name|log
argument_list|,
name|resultfile
argument_list|,
name|frewrite
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buildtree
parameter_list|()
comment|/*   Function:  actually removes revisions whose selector field  */
comment|/*		is false, and rebuilds the linkage of deltas.	 */
comment|/*              asks for reconfirmation if deleting last revision*/
block|{
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
name|struct
name|branchhead
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
if|if
condition|(
name|cuthead
condition|)
if|if
condition|(
name|cuthead
operator|->
name|next
operator|==
name|delstrt
condition|)
name|cuthead
operator|->
name|next
operator|=
name|cuttail
expr_stmt|;
else|else
block|{
name|pre
operator|=
name|pt
operator|=
name|cuthead
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|pt
operator|&&
name|pt
operator|->
name|hsh
operator|!=
name|delstrt
condition|)
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
block|}
if|if
condition|(
name|cuttail
condition|)
name|pt
operator|->
name|hsh
operator|=
name|cuttail
expr_stmt|;
elseif|else
if|if
condition|(
name|pt
operator|==
name|pre
condition|)
name|cuthead
operator|->
name|branches
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
else|else
name|pre
operator|->
name|nextbranch
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cuttail
operator|==
name|nil
operator|&&
operator|!
name|quietflag
condition|)
block|{
if|if
condition|(
operator|!
name|yesorno
argument_list|(
name|false
argument_list|,
literal|"Do you really want to delete all revisions? [ny](n): "
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"No revision deleted"
argument_list|)
expr_stmt|;
name|Delta
operator|=
name|delstrt
expr_stmt|;
while|while
condition|(
name|Delta
condition|)
block|{
name|Delta
operator|->
name|selector
operator|=
name|true
expr_stmt|;
name|Delta
operator|=
name|Delta
operator|->
name|next
expr_stmt|;
block|}
return|return;
block|}
block|}
name|Head
operator|=
name|cuttail
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|lint
end_if

begin_comment
comment|/* This lets us lint everything all at once. */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|go
parameter_list|(
name|p
parameter_list|,
name|e
parameter_list|)
value|{int p P((int,char**)); void e P((void)); if(*argv)return p(argc,argv);if(*argv[1])e();}
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|go
argument_list|(
name|ciId
argument_list|,
name|ciExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|coId
argument_list|,
name|coExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|identId
argument_list|,
name|identExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|mergeId
argument_list|,
name|mergeExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcsId
argument_list|,
name|exiterr
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcscleanId
argument_list|,
name|rcscleanExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcsdiffId
argument_list|,
name|rdiffExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcsmergeId
argument_list|,
name|rmergeExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rlogId
argument_list|,
name|rlogExit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

