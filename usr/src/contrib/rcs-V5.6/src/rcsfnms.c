begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS file name handling  */
end_comment

begin_comment
comment|/****************************************************************************  *                     creation and deletion of /tmp temporaries  *                     pairing of RCS file names and working file names.  *                     Testprogram: define PAIRTEST  ****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcsfnms.c,v $  * Revision 5.8  1991/09/24  00:28:40  eggert  * Don't export bindex().  *  * Revision 5.7  1991/08/19  03:13:55  eggert  * Fix messages when rcswriteopen fails.  * Look in $TMP and $TEMP if $TMPDIR isn't set.  Tune.  *  * Revision 5.6  1991/04/21  11:58:23  eggert  * Fix errno bugs.  Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.5  1991/02/26  17:48:38  eggert  * Fix setuid bug.  Support new link behavior.  * Define more portable getcwd().  *  * Revision 5.4  1990/11/01  05:03:43  eggert  * Permit arbitrary data in comment leaders.  *  * Revision 5.3  1990/09/14  22:56:16  hammer  * added more filename extensions and their comment leaders  *  * Revision 5.2  1990/09/04  08:02:23  eggert  * Fix typo when !RCSSEP.  *  * Revision 5.1  1990/08/29  07:13:59  eggert  * Work around buggy compilers with defective argument promotion.  *  * Revision 5.0  1990/08/22  08:12:50  eggert  * Ignore signals when manipulating the semaphore file.  * Modernize list of file name extensions.  * Permit paths of arbitrary length.  Beware file names beginning with "-".  * Remove compile-time limits; use malloc instead.  * Permit dates past 1999/12/31.  Make lock and temp files faster and safer.  * Ansify and Posixate.  * Don't use access().  Fix test for non-regular files.  Tune.  *  * Revision 4.8  89/05/01  15:09:41  narten  * changed getwd to not stat empty directories.  *   * Revision 4.7  88/08/09  19:12:53  eggert  * Fix troff macro comment leader bug; add Prolog; allow cc -R; remove lint.  *   * Revision 4.6  87/12/18  11:40:23  narten  * additional file types added from 4.3 BSD version, and SPARC assembler  * comment character added. Also, more lint cleanups. (Guy Harris)  *   * Revision 4.5  87/10/18  10:34:16  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to verion 4.3  *   * Revision 1.3  87/03/27  14:22:21  jenkins  * Port to suns  *   * Revision 1.2  85/06/26  07:34:28  svb  * Comment leader '% ' for '*.tex' files added.  *   * Revision 4.3  83/12/15  12:26:48  wft  * Added check for KDELIM in file names to pairfilenames().  *   * Revision 4.2  83/12/02  22:47:45  wft  * Added csh, red, and sl file name suffixes.  *   * Revision 4.1  83/05/11  16:23:39  wft  * Added initialization of Dbranch to InitAdmin(). Canged pairfilenames():  * 1. added copying of path from workfile to RCS file, if RCS file is omitted;  * 2. added getting the file status of RCS and working files;  * 3. added ignoring of directories.  *   * Revision 3.7  83/05/11  15:01:58  wft  * Added comtable[] which pairs file name suffixes with comment leaders;  * updated InitAdmin() accordingly.  *   * Revision 3.6  83/04/05  14:47:36  wft  * fixed Suffix in InitAdmin().  *   * Revision 3.5  83/01/17  18:01:04  wft  * Added getwd() and rename(); these can be removed by defining  * V4_2BSD, since they are not needed in 4.2 bsd.  * Changed sys/param.h to sys/types.h.  *  * Revision 3.4  82/12/08  21:55:20  wft  * removed unused variable.  *  * Revision 3.3  82/11/28  20:31:37  wft  * Changed mktempfile() to store the generated file names.  * Changed getfullRCSname() to store the file and pathname, and to  * delete leading "../" and "./".  *  * Revision 3.2  82/11/12  14:29:40  wft  * changed pairfilenames() to handle file.sfx,v; also deleted checkpathnosfx(),  * checksuffix(), checkfullpath(). Semaphore name generation updated.  * mktempfile() now checks for nil path; freefilename initialized properly.  * Added Suffix .h to InitAdmin. Added testprogram PAIRTEST.  * Moved rmsema, trysema, trydiraccess, getfullRCSname from rcsutil.c to here.  *  * Revision 3.1  82/10/18  14:51:28  wft  * InitAdmin() now initializes StrictLocks=STRICT_LOCKING (def. in rcsbase.h).  * renamed checkpath() to checkfullpath().  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|fnmsId
argument_list|,
literal|"$Id: rcsfnms.c,v 5.8 1991/09/24 00:28:40 eggert Exp $"
argument_list|)
end_macro

begin_decl_stmt
name|char
specifier|const
modifier|*
name|RCSfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|workstdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|RCSstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|suffixes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|rcsdir
index|[]
init|=
literal|"RCS"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rcsdirlen
value|(sizeof(rcsdir)-1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|buf
name|RCSbuf
decl_stmt|,
name|RCSb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|RCSerrno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temp file names to be unlinked when done, if they are not nil.  */
end_comment

begin_define
define|#
directive|define
name|TEMPNAMES
value|5
end_define

begin_comment
comment|/* must be at least DIRTEMPNAMES (see rcsedit.c) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|volatile
name|tfnames
index|[
name|TEMPNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|compair
block|{
name|char
specifier|const
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|compair
specifier|const
name|comtable
index|[]
init|=
block|{
comment|/* comtable pairs each filename suffix with a comment leader. The comment   */
comment|/* leader is placed before each line generated by the $Log keyword. This    */
comment|/* table is used to guess the proper comment leader from the working file's */
comment|/* suffix during initial ci (see InitAdmin()). Comment leaders are needed   */
comment|/* for languages without multiline comments; for others they are optional.  */
literal|"a"
block|,
literal|"-- "
block|,
comment|/* Ada         */
literal|"ada"
block|,
literal|"-- "
block|,
literal|"asm"
block|,
literal|";; "
block|,
comment|/* assembler (MS-DOS) */
literal|"bat"
block|,
literal|":: "
block|,
comment|/* batch (MS-DOS) */
literal|"c"
block|,
literal|" * "
block|,
comment|/* C           */
literal|"c++"
block|,
literal|"// "
block|,
comment|/* C++ in all its infinite guises */
literal|"cc"
block|,
literal|"// "
block|,
literal|"cpp"
block|,
literal|"// "
block|,
literal|"cxx"
block|,
literal|"// "
block|,
literal|"cl"
block|,
literal|";;; "
block|,
comment|/* Common Lisp */
literal|"cmd"
block|,
literal|":: "
block|,
comment|/* command (OS/2) */
literal|"cmf"
block|,
literal|"c "
block|,
comment|/* CM Fortran  */
literal|"cs"
block|,
literal|" * "
block|,
comment|/* C*          */
literal|"el"
block|,
literal|"; "
block|,
comment|/* Emacs Lisp  */
literal|"f"
block|,
literal|"c "
block|,
comment|/* Fortran     */
literal|"for"
block|,
literal|"c "
block|,
literal|"h"
block|,
literal|" * "
block|,
comment|/* C-header    */
literal|"hpp"
block|,
literal|"// "
block|,
comment|/* C++ header  */
literal|"hxx"
block|,
literal|"// "
block|,
literal|"l"
block|,
literal|" * "
block|,
comment|/* lex      NOTE: conflict between lex and franzlisp */
literal|"lisp"
block|,
literal|";;; "
block|,
comment|/* Lucid Lisp  */
literal|"lsp"
block|,
literal|";; "
block|,
comment|/* Microsoft Lisp */
literal|"mac"
block|,
literal|";; "
block|,
comment|/* macro (DEC-10, MS-DOS, PDP-11, VMS, etc) */
literal|"me"
block|,
literal|".\\\" "
block|,
comment|/* me-macros   t/nroff*/
literal|"ml"
block|,
literal|"; "
block|,
comment|/* mocklisp    */
literal|"mm"
block|,
literal|".\\\" "
block|,
comment|/* mm-macros   t/nroff*/
literal|"ms"
block|,
literal|".\\\" "
block|,
comment|/* ms-macros   t/nroff*/
literal|"p"
block|,
literal|" * "
block|,
comment|/* Pascal      */
literal|"pas"
block|,
literal|" * "
block|,
literal|"pl"
block|,
literal|"% "
block|,
comment|/* Prolog      */
literal|"tex"
block|,
literal|"% "
block|,
comment|/* TeX	       */
literal|"y"
block|,
literal|" * "
block|,
comment|/* yacc        */
name|nil
block|,
literal|"# "
comment|/* default for unknown suffix; must always be last */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|has_mktemp
end_if

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|tmp
parameter_list|()
comment|/* Yield the name of the tmp directory.  */
block|{
specifier|static
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|&&
operator|!
operator|(
name|s
operator|=
name|cgetenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
comment|/* Unix tradition */
operator|&&
operator|!
operator|(
name|s
operator|=
name|cgetenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
comment|/* DOS tradition */
operator|&&
operator|!
operator|(
name|s
operator|=
name|cgetenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|)
comment|/* another DOS tradition */
condition|)
name|s
operator|=
name|TMPDIR
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
specifier|const
modifier|*
name|maketemp
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* Create a unique filename using n and the process id and store it  * into the nth slot in tfnames.  * Because of storage in tfnames, tempunlink() can unlink the file later.  * Returns a pointer to the filename created.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|t
init|=
name|tfnames
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
name|catchints
argument_list|()
expr_stmt|;
block|{
if|#
directive|if
name|has_mktemp
name|char
specifier|const
modifier|*
name|tp
init|=
name|tmp
argument_list|()
decl_stmt|;
name|p
operator|=
name|testalloc
argument_list|(
name|strlen
argument_list|(
name|tp
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%cT%cXXXXXX"
argument_list|,
name|tp
argument_list|,
name|SLASH
argument_list|,
literal|'0'
operator|+
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mktemp
argument_list|(
name|p
argument_list|)
operator|||
operator|!
operator|*
name|p
condition|)
name|faterror
argument_list|(
literal|"can't make temporary file name `%s%cT%cXXXXXX'"
argument_list|,
name|tp
argument_list|,
name|SLASH
argument_list|,
literal|'0'
operator|+
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
name|char
name|tfnamebuf
index|[
name|TEMPNAMES
index|]
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|p
operator|=
name|tfnamebuf
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmpnam
argument_list|(
name|p
argument_list|)
operator|||
operator|!
operator|*
name|p
condition|)
ifdef|#
directive|ifdef
name|P_tmpdir
name|faterror
argument_list|(
literal|"can't make temporary file name `%s...'"
argument_list|,
name|P_tmpdir
argument_list|)
expr_stmt|;
else|#
directive|else
name|faterror
argument_list|(
literal|"can't make temporary file name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|tfnames
index|[
name|n
index|]
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|tempunlink
parameter_list|()
comment|/* Clean up maketemp() files.  May be invoked by signal handler.  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TEMPNAMES
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|tfnames
index|[
name|i
index|]
operator|)
condition|)
block|{
name|VOID
name|unlink
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* 		 * We would tfree(p) here, 		 * but this might dump core if we're handing a signal. 		 * We're about to exit anyway, so we won't bother. 		 */
name|tfnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|bindex
parameter_list|(
name|sp
parameter_list|,
name|ch
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* Function: Finds the last occurrence of character c in string sp  * and returns a pointer to the character just beyond it. If the  * character doesn't occur in the string, sp is returned.  */
block|{
specifier|register
name|char
specifier|const
name|c
init|=
name|ch
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|suffix_matches
parameter_list|(
name|suffix
parameter_list|,
name|pattern
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|suffix
decl_stmt|,
decl|*
name|pattern
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|true
return|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|suffix
operator|++
operator|-
operator|(
name|c
operator|=
operator|*
name|pattern
operator|++
operator|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|true
return|;
break|break;
case|case
literal|'A'
operator|-
literal|'a'
case|:
if|if
condition|(
name|ctab
index|[
name|c
index|]
operator|==
name|Letter
condition|)
break|break;
comment|/* fall into */
default|default:
return|return
name|false
return|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|InitAdmin
parameter_list|()
comment|/* function: initializes an admin node */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|Suffix
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Head
operator|=
name|nil
expr_stmt|;
name|Dbranch
operator|=
name|nil
expr_stmt|;
name|AccessList
operator|=
name|nil
expr_stmt|;
name|Symbols
operator|=
name|nil
expr_stmt|;
name|Locks
operator|=
name|nil
expr_stmt|;
name|StrictLocks
operator|=
name|STRICT_LOCKING
expr_stmt|;
comment|/* guess the comment leader from the suffix*/
name|Suffix
operator|=
name|bindex
argument_list|(
name|workfilename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Suffix
operator|==
name|workfilename
condition|)
name|Suffix
operator|=
literal|""
expr_stmt|;
comment|/* empty suffix; will get default*/
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|suffix_matches
argument_list|(
name|Suffix
argument_list|,
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|Comment
operator|.
name|string
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
name|Comment
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
argument_list|)
expr_stmt|;
name|Lexinit
argument_list|()
expr_stmt|;
comment|/* note: if !finptr, reads nothing; only initializes */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_NO_TRUNC
argument_list|)
end_if

begin_define
define|#
directive|define
name|LONG_NAMES_MAY_BE_SILENTLY_TRUNCATED
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LONG_NAMES_MAY_BE_SILENTLY_TRUNCATED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LONG_NAMES_MAY_BE_SILENTLY_TRUNCATED
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|NAME_MAX
end_ifdef

begin_define
define|#
directive|define
name|filenametoolong
parameter_list|(
name|path
parameter_list|)
value|(NAME_MAX< strlen(basename(path)))
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|filenametoolong
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Yield true if the last file name in PATH is too long. */
block|{
specifier|static
name|unsigned
name|long
name|dot_namemax
decl_stmt|;
specifier|register
name|size_t
name|namelen
decl_stmt|;
specifier|register
name|char
modifier|*
name|base
decl_stmt|;
specifier|register
name|unsigned
name|long
name|namemax
decl_stmt|;
name|base
operator|=
name|path
operator|+
name|dirlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
name|_POSIX_NAME_MAX
condition|)
comment|/* fast check for shorties */
return|return
name|false
return|;
if|if
condition|(
name|base
operator|!=
name|path
condition|)
block|{
operator|*
operator|--
name|base
operator|=
literal|0
expr_stmt|;
name|namemax
operator|=
name|pathconf
argument_list|(
name|path
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
operator|*
name|base
operator|=
name|SLASH
expr_stmt|;
block|}
else|else
block|{
comment|/* Cache the results for the working directory, for speed. */
if|if
condition|(
operator|!
name|dot_namemax
condition|)
name|dot_namemax
operator|=
name|pathconf
argument_list|(
literal|"."
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
name|namemax
operator|=
name|dot_namemax
expr_stmt|;
block|}
comment|/* If pathconf() yielded -1, namemax is now ULONG_MAX.  */
return|return
name|namemax
operator|<
name|namelen
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|bufalloc
parameter_list|(
name|b
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* Ensure *B is a name buffer of at least SIZE bytes.  * *B's old contents can be freed; *B's new contents are undefined.  */
block|{
if|if
condition|(
name|b
operator|->
name|size
operator|<
name|size
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|size
condition|)
name|tfree
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|malloc_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|size
operator|<
name|size
condition|)
name|b
operator|->
name|size
operator|<<=
literal|1
expr_stmt|;
name|b
operator|->
name|string
operator|=
name|tnalloc
argument_list|(
name|char
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bufrealloc
parameter_list|(
name|b
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* like bufalloc, except *B's old contents, if any, are preserved */
block|{
if|if
condition|(
name|b
operator|->
name|size
operator|<
name|size
condition|)
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|size
condition|)
name|bufalloc
argument_list|(
name|b
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|b
operator|->
name|size
operator|<<=
literal|1
operator|)
operator|<
name|size
condition|)
empty_stmt|;
name|b
operator|->
name|string
operator|=
name|trealloc
argument_list|(
name|char
argument_list|,
name|b
operator|->
name|string
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|bufautoend
parameter_list|(
name|b
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
comment|/* Free an auto buffer at block exit. */
block|{
if|if
condition|(
name|b
operator|->
name|size
condition|)
name|tfree
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cbuf
name|bufremember
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|s
decl_stmt|;
comment|/*  * Free the buffer B with used size S.  * Yield a cbuf with identical contents.  * The cbuf will be reclaimed when this input file is finished.  */
block|{
name|struct
name|cbuf
name|cb
decl_stmt|;
if|if
condition|(
operator|(
name|cb
operator|.
name|size
operator|=
name|s
operator|)
condition|)
name|cb
operator|.
name|string
operator|=
name|fremember
argument_list|(
name|trealloc
argument_list|(
name|char
argument_list|,
name|b
operator|->
name|string
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bufautoend
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* not really auto */
name|cb
operator|.
name|string
operator|=
literal|""
expr_stmt|;
block|}
return|return
name|cb
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bufenlarge
parameter_list|(
name|b
parameter_list|,
name|alim
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|alim
decl_stmt|;
comment|/* Make *B larger.  Set *ALIM to its new limit, and yield the relocated value  * of its old limit.  */
block|{
name|size_t
name|s
init|=
name|b
operator|->
name|size
decl_stmt|;
name|bufrealloc
argument_list|(
name|b
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|alim
operator|=
name|b
operator|->
name|string
operator|+
name|b
operator|->
name|size
expr_stmt|;
return|return
name|b
operator|->
name|string
operator|+
name|s
return|;
block|}
end_function

begin_function
name|void
name|bufscat
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Concatenate S to B's end. */
block|{
name|size_t
name|blen
init|=
name|b
operator|->
name|string
condition|?
name|strlen
argument_list|(
name|b
operator|->
name|string
argument_list|)
else|:
literal|0
decl_stmt|;
name|bufrealloc
argument_list|(
name|b
argument_list|,
name|blen
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|b
operator|->
name|string
operator|+
name|blen
argument_list|,
name|s
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|bufscpy
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Copy S into B. */
block|{
name|bufalloc
argument_list|(
name|b
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|b
operator|->
name|string
argument_list|,
name|s
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|basename
parameter_list|(
name|p
parameter_list|)
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
comment|/* Yield the address of the base filename of the pathname P.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|b
init|=
name|p
decl_stmt|,
modifier|*
name|q
init|=
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|q
operator|++
condition|)
block|{
case|case
name|SLASHes
case|:
name|b
operator|=
name|q
expr_stmt|;
break|break;
case|case
literal|0
case|:
return|return
name|b
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|dirlen
parameter_list|(
name|p
parameter_list|)
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
comment|/* Yield the length of P's directory, including its trailing SLASH.  */
block|{
return|return
name|basename
argument_list|(
name|p
argument_list|)
operator|-
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|suffixlen
parameter_list|(
name|x
parameter_list|)
name|char
specifier|const
modifier|*
name|x
decl_stmt|;
comment|/* Yield the length of X, an RCS filename suffix.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|0
case|:
case|case
name|SLASHes
case|:
return|return
name|p
operator|-
name|x
return|;
default|default:
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|rcssuffix
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
comment|/* Yield the suffix of NAME if it is an RCS filename, 0 otherwise.  */
block|{
name|char
specifier|const
modifier|*
name|x
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|nz
decl_stmt|;
name|size_t
name|dl
decl_stmt|,
name|nl
decl_stmt|,
name|xl
decl_stmt|;
name|nl
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nz
operator|=
name|name
operator|+
name|nl
expr_stmt|;
name|x
operator|=
name|suffixes
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|xl
operator|=
name|suffixlen
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|xl
operator|<=
name|nl
operator|&&
name|memcmp
argument_list|(
name|p
operator|=
name|nz
operator|-
name|xl
argument_list|,
name|x
argument_list|,
name|xl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
block|}
else|else
block|{
name|dl
operator|=
name|dirlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsdirlen
operator|<
name|dl
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
operator|=
name|name
operator|+
operator|(
name|dl
operator|-=
name|rcsdirlen
operator|+
literal|1
operator|)
argument_list|,
name|rcsdir
argument_list|,
name|rcsdirlen
argument_list|)
operator|&&
operator|(
operator|!
name|dl
operator|||
name|isSLASH
argument_list|(
operator|*
operator|--
name|p
argument_list|)
operator|)
condition|)
return|return
name|nz
return|;
block|}
name|x
operator|+=
name|xl
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|x
operator|++
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|RILE
modifier|*
name|rcsreadopen
parameter_list|(
name|RCSname
parameter_list|,
name|status
parameter_list|,
name|mustread
parameter_list|)
name|struct
name|buf
modifier|*
name|RCSname
decl_stmt|;
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
name|int
name|mustread
decl_stmt|;
comment|/* Open RCSNAME for reading and yield its FILE* descriptor.  * If successful, set *STATUS to its status.  * Pass this routine to pairfilenames() for read-only access to the file.  */
block|{
return|return
name|Iopen
argument_list|(
name|RCSname
operator|->
name|string
argument_list|,
name|FOPEN_R
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|finopen
parameter_list|(
name|rcsopen
parameter_list|,
name|mustread
parameter_list|)
comment|/* jlf RILE *(*rcsopen)P((struct buf*,struct stat*,int)); */
function|RILE *
parameter_list|(
function|*rcsopen
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mustread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Use RCSOPEN to open an RCS file; MUSTREAD is set if the file must be read.  * Set finptr to the result and yield true if successful.  * RCSb holds the file's name.  * Set RCSbuf to the best RCS name found so far, and RCSerrno to its errno.  * Yield true if successful or if an unusual failure.  */
end_comment

begin_block
block|{
name|int
name|interesting
decl_stmt|,
name|preferold
decl_stmt|;
comment|/* 	 * We prefer an old name to that of a nonexisting new RCS file, 	 * unless we tried locking the old name and failed. 	 */
name|preferold
operator|=
name|RCSbuf
operator|.
name|string
index|[
literal|0
index|]
operator|&&
operator|(
name|mustread
operator|||
name|frewrite
operator|)
expr_stmt|;
name|finptr
operator|=
call|(
modifier|*
name|rcsopen
call|)
argument_list|(
operator|&
name|RCSb
argument_list|,
operator|&
name|RCSstat
argument_list|,
name|mustread
argument_list|)
expr_stmt|;
name|interesting
operator|=
name|finptr
operator|||
name|errno
operator|!=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|interesting
operator|||
operator|!
name|preferold
condition|)
block|{
comment|/* Use the new name.  */
name|RCSerrno
operator|=
name|errno
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|RCSbuf
argument_list|,
name|RCSb
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|interesting
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|fin2open
parameter_list|(
name|d
parameter_list|,
name|dlen
parameter_list|,
name|base
parameter_list|,
name|baselen
parameter_list|,
name|x
parameter_list|,
name|xlen
parameter_list|,
name|rcsopen
parameter_list|,
name|mustread
parameter_list|)
name|char
specifier|const
modifier|*
name|d
decl_stmt|,
decl|*
name|base
decl_stmt|,
modifier|*
name|x
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|dlen
decl_stmt|,
name|baselen
decl_stmt|,
name|xlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* jlf RILE *(*rcsopen)P((struct buf*,struct stat*,int)); */
end_comment

begin_function_decl
name|RILE
modifier|*
function_decl|(
modifier|*
name|rcsopen
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|mustread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * D is a directory name with length DLEN (including trailing slash).  * BASE is a filename with length BASELEN.  * X is an RCS filename suffix with length XLEN.  * Use RCSOPEN to open an RCS file; MUSTREAD is set if the file must be read.  * Yield true if successful.  * Try dRCS/basex first; if that fails and x is nonempty, try dbasex.  * Put these potential names in RCSb.  * Set RCSbuf to the best RCS name found so far, and RCSerrno to its errno.  * Yield true if successful or if an unusual failure.  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bufalloc
argument_list|(
operator|&
name|RCSb
argument_list|,
name|dlen
operator|+
name|rcsdirlen
operator|+
literal|1
operator|+
name|baselen
operator|+
name|xlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Try dRCS/basex.  */
name|VOID
name|memcpy
parameter_list|(
name|p
init|=
name|RCSb
operator|.
name|string
parameter_list|,
name|d
parameter_list|,
name|dlen
parameter_list|)
function_decl|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|dlen
argument_list|,
name|rcsdir
argument_list|,
name|rcsdirlen
argument_list|)
decl_stmt|;
name|p
operator|+=
name|rcsdirlen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SLASH
expr_stmt|;
name|VOID
name|memcpy
parameter_list|(
name|p
parameter_list|,
name|base
parameter_list|,
name|baselen
parameter_list|)
function_decl|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
argument_list|)
decl_stmt|;
name|p
index|[
name|xlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xlen
condition|)
block|{
if|if
condition|(
name|finopen
argument_list|(
name|rcsopen
argument_list|,
name|mustread
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Try dbasex.  */
comment|/* Start from scratch, because finopen() may have changed RCSb.  */
name|VOID
name|memcpy
parameter_list|(
name|p
init|=
name|RCSb
operator|.
name|string
parameter_list|,
name|d
parameter_list|,
name|dlen
parameter_list|)
function_decl|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|dlen
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
decl_stmt|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
argument_list|)
decl_stmt|;
name|p
index|[
name|xlen
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|finopen
argument_list|(
name|rcsopen
argument_list|,
name|mustread
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|pairfilenames
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|rcsopen
parameter_list|,
name|mustread
parameter_list|,
name|quiet
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* jlf RILE *(*rcsopen)P((struct buf*,struct stat*,int)); */
function|RILE *
parameter_list|(
function|*rcsopen
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mustread
decl_stmt|,
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Pairs the filenames pointed to by argv; argc indicates  * how many there are.  * Places a pointer to the RCS filename into RCSfilename,  * and a pointer to the name of the working file into workfilename.  * If both the workfilename and the RCS filename are given, and workstdout  * is set, a warning is printed.  *  * If the RCS file exists, places its status into RCSstat.  *  * If the RCS file exists, it is RCSOPENed for reading, the file pointer  * is placed into finptr, and the admin-node is read in; returns 1.  * If the RCS file does not exist and MUSTREAD,  * print an error unless QUIET and return 0.  * Otherwise, initialize the admin node and return -1.  *  * 0 is returned on all errors, e.g. files that are not regular files.  */
end_comment

begin_block
block|{
specifier|static
name|struct
name|buf
name|tempbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|RCS1
decl_stmt|;
name|char
specifier|const
modifier|*
name|purefname
decl_stmt|,
modifier|*
name|pureRCSname
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|int
name|paired
decl_stmt|;
name|size_t
name|arglen
decl_stmt|,
name|dlen
decl_stmt|,
name|baselen
decl_stmt|,
name|xlen
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
operator|*
name|argv
operator|)
condition|)
return|return
literal|0
return|;
comment|/* already paired filename */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
name|error
argument_list|(
literal|"%s option is ignored after file names"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|purefname
operator|=
name|basename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Allocate buffer temporary to hold the default paired file name. */
name|p
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
comment|/* Beware characters that cause havoc with ci -k. */
case|case
name|KDELIM
case|:
name|error
argument_list|(
literal|"RCS file name `%s' contains %c"
argument_list|,
name|arg
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
name|error
argument_list|(
literal|"RCS file name `%s' contains white space"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
continue|continue;
case|case
literal|0
case|:
break|break;
block|}
break|break;
block|}
name|paired
operator|=
name|false
expr_stmt|;
comment|/* first check suffix to see whether it is an RCS file or not */
if|if
condition|(
operator|(
name|x
operator|=
name|rcssuffix
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
comment|/* RCS file name given*/
name|RCS1
operator|=
name|arg
expr_stmt|;
name|pureRCSname
operator|=
name|purefname
expr_stmt|;
name|baselen
operator|=
name|x
operator|-
name|purefname
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
operator|&&
operator|!
name|rcssuffix
argument_list|(
name|workfilename
operator|=
name|p
operator|=
name|argv
index|[
literal|1
index|]
argument_list|)
operator|&&
name|baselen
operator|<=
operator|(
name|arglen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|p
operator|+=
name|arglen
operator|-
name|baselen
operator|)
operator|==
name|workfilename
operator|||
name|isSLASH
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|purefname
argument_list|,
name|p
argument_list|,
name|baselen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|paired
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|bufscpy
argument_list|(
operator|&
name|tempbuf
argument_list|,
name|purefname
argument_list|)
expr_stmt|;
name|workfilename
operator|=
name|p
operator|=
name|tempbuf
operator|.
name|string
expr_stmt|;
name|p
index|[
name|baselen
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* working file given; now try to find RCS file */
name|workfilename
operator|=
name|arg
expr_stmt|;
name|baselen
operator|=
name|p
operator|-
name|purefname
operator|-
literal|1
expr_stmt|;
comment|/* derive RCS file name*/
if|if
condition|(
literal|1
operator|<
name|argc
operator|&&
operator|(
name|x
operator|=
name|rcssuffix
argument_list|(
name|RCS1
operator|=
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|baselen
operator|<=
name|x
operator|-
name|RCS1
operator|&&
operator|(
operator|(
name|pureRCSname
operator|=
name|x
operator|-
name|baselen
operator|)
operator|==
name|RCS1
operator|||
name|isSLASH
argument_list|(
name|pureRCSname
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|purefname
argument_list|,
name|pureRCSname
argument_list|,
name|baselen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|paired
operator|=
name|true
expr_stmt|;
block|}
else|else
name|pureRCSname
operator|=
name|RCS1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now we have a (tentative) RCS filename in RCS1 and workfilename  */
comment|/* Second, try to find the right RCS file */
if|if
condition|(
name|pureRCSname
operator|!=
name|RCS1
condition|)
block|{
comment|/* a path for RCSfile is given; single RCS file to look for */
name|bufscpy
argument_list|(
operator|&
name|RCSbuf
argument_list|,
name|RCS1
argument_list|)
expr_stmt|;
name|finptr
operator|=
call|(
modifier|*
name|rcsopen
call|)
argument_list|(
operator|&
name|RCSbuf
argument_list|,
operator|&
name|RCSstat
argument_list|,
name|mustread
argument_list|)
expr_stmt|;
name|RCSerrno
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
name|bufscpy
argument_list|(
operator|&
name|RCSbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|RCS1
condition|)
comment|/* RCS file name was given without path.  */
name|VOID
name|fin2open
argument_list|(
name|arg
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|pureRCSname
argument_list|,
name|baselen
argument_list|,
name|x
argument_list|,
name|strlen
argument_list|(
name|x
argument_list|)
argument_list|,
name|rcsopen
argument_list|,
name|mustread
argument_list|)
decl_stmt|;
else|else
block|{
comment|/* No RCS file name was given.  */
comment|/* Try each suffix in turn.  */
name|dlen
operator|=
name|purefname
operator|-
name|arg
expr_stmt|;
name|x
operator|=
name|suffixes
expr_stmt|;
while|while
condition|(
operator|!
name|fin2open
argument_list|(
name|arg
argument_list|,
name|dlen
argument_list|,
name|purefname
argument_list|,
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
operator|=
name|suffixlen
argument_list|(
name|x
argument_list|)
argument_list|,
name|rcsopen
argument_list|,
name|mustread
argument_list|)
condition|)
block|{
name|x
operator|+=
name|xlen
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|x
operator|++
condition|)
break|break;
block|}
block|}
block|}
name|RCSfilename
operator|=
name|p
operator|=
name|RCSbuf
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|finptr
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s isn't a regular file -- ignored"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RCSerrno
operator|!=
name|ENOENT
operator|||
name|mustread
operator|||
operator|!
name|frewrite
condition|)
block|{
if|if
condition|(
name|RCSerrno
operator|==
name|EEXIST
condition|)
name|error
argument_list|(
literal|"RCS file %s is in use"
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|quiet
operator|||
name|RCSerrno
operator|!=
name|ENOENT
condition|)
name|enerror
argument_list|(
name|RCSerrno
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|InitAdmin
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
if|#
directive|if
name|LONG_NAMES_MAY_BE_SILENTLY_TRUNCATED
if|if
condition|(
name|filenametoolong
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"RCS file name %s is too long"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifndef|#
directive|ifndef
name|NAME_MAX
comment|/* 		 * Check workfilename too, even though it cannot be longer, 		 * because it may reside on a different filesystem. 		 */
if|if
condition|(
name|filenametoolong
argument_list|(
name|workfilename
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"working file name %s is too long"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|paired
operator|&&
name|workstdout
condition|)
name|warn
argument_list|(
literal|"Option -p is set; ignoring output file %s"
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
name|prevkeys
operator|=
name|false
expr_stmt|;
return|return
name|finptr
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|char
specifier|const
modifier|*
name|getfullRCSname
parameter_list|()
comment|/* Function: returns a pointer to the full path name of the RCS file.  * Gets the working directory's name at most once.  * Removes leading "../" and "./".  */
block|{
specifier|static
name|char
specifier|const
modifier|*
name|wdptr
decl_stmt|;
specifier|static
name|struct
name|buf
name|rcsbuf
decl_stmt|,
name|wdbuf
decl_stmt|;
specifier|static
name|size_t
name|pathlength
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|realname
decl_stmt|;
specifier|register
name|size_t
name|parentdirlength
decl_stmt|;
specifier|register
name|unsigned
name|dotdotcounter
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|wd
decl_stmt|;
if|if
condition|(
name|ROOTPATH
argument_list|(
name|RCSfilename
argument_list|)
condition|)
block|{
return|return
operator|(
name|RCSfilename
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|wd
operator|=
name|wdptr
operator|)
condition|)
block|{
comment|/* Get working directory for the first time.  */
if|if
condition|(
operator|!
operator|(
name|d
operator|=
name|cgetenv
argument_list|(
literal|"PWD"
argument_list|)
operator|)
condition|)
block|{
name|bufalloc
argument_list|(
operator|&
name|wdbuf
argument_list|,
name|SIZEABLE_PATH
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|has_getcwd
operator|&&
name|has_getwd
name|d
operator|=
name|getwd
argument_list|(
name|wdbuf
operator|.
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|!
operator|(
name|d
operator|=
name|getcwd
argument_list|(
name|wdbuf
operator|.
name|string
argument_list|,
name|wdbuf
operator|.
name|size
argument_list|)
operator|)
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
name|bufalloc
argument_list|(
operator|&
name|wdbuf
argument_list|,
name|wdbuf
operator|.
name|size
operator|<<
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
condition|)
name|efaterror
argument_list|(
literal|"working directory"
argument_list|)
expr_stmt|;
block|}
name|parentdirlength
operator|=
name|strlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
name|parentdirlength
operator|&&
name|isSLASH
argument_list|(
name|d
index|[
name|parentdirlength
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|d
index|[
operator|--
name|parentdirlength
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Check needed because some getwd implementations */
comment|/* generate "/" for the root.                      */
block|}
name|wdptr
operator|=
name|wd
operator|=
name|d
expr_stmt|;
name|pathlength
operator|=
name|parentdirlength
expr_stmt|;
block|}
comment|/*the following must be redone since RCSfilename may change*/
comment|/* Find how many `../'s to remove from RCSfilename.  */
name|dotdotcounter
operator|=
literal|0
expr_stmt|;
name|realname
operator|=
name|RCSfilename
expr_stmt|;
while|while
condition|(
name|realname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|isSLASH
argument_list|(
name|realname
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* drop leading ./ */
name|realname
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|realname
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|isSLASH
argument_list|(
name|realname
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* drop leading ../ and remember */
name|dotdotcounter
operator|++
expr_stmt|;
name|realname
operator|+=
literal|3
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Now remove dotdotcounter trailing directories from wd. */
name|parentdirlength
operator|=
name|pathlength
expr_stmt|;
while|while
condition|(
name|dotdotcounter
operator|&&
name|parentdirlength
condition|)
block|{
comment|/* move pointer backwards over trailing directory */
if|if
condition|(
name|isSLASH
argument_list|(
name|wd
index|[
operator|--
name|parentdirlength
index|]
argument_list|)
condition|)
block|{
name|dotdotcounter
operator|--
expr_stmt|;
block|}
block|}
comment|/* build full path name */
name|bufalloc
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|parentdirlength
operator|+
name|strlen
argument_list|(
name|realname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d
operator|=
name|rcsbuf
operator|.
name|string
expr_stmt|;
name|VOID
name|memcpy
argument_list|(
name|d
argument_list|,
name|wd
argument_list|,
name|parentdirlength
argument_list|)
decl_stmt|;
name|d
operator|+=
name|parentdirlength
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|SLASH
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|d
argument_list|,
name|realname
argument_list|)
decl_stmt|;
return|return
name|rcsbuf
operator|.
name|string
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|isSLASH
end_ifndef

begin_function
name|int
name|isSLASH
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SLASHes
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_getcwd
operator|&&
operator|!
name|has_getwd
end_if

begin_function
name|char
modifier|*
name|getcwd
parameter_list|(
name|path
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|static
name|char
specifier|const
name|usrbinpwd
index|[]
init|=
literal|"/usr/bin/pwd"
decl_stmt|;
define|#
directive|define
name|binpwd
value|(usrbinpwd+4)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|int
name|closeerrno
decl_stmt|,
name|closeerror
decl_stmt|,
name|e
decl_stmt|,
name|fd
index|[
literal|2
index|]
decl_stmt|,
name|readerror
decl_stmt|,
name|toolong
decl_stmt|,
name|wstatus
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
if|#
directive|if
operator|!
name|has_waitpid
name|pid_t
name|w
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|vfork
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|fd
index|[
literal|1
index|]
operator|==
name|STDOUT_FILENO
operator|||
ifdef|#
directive|ifdef
name|F_DUPFD
operator|(
name|VOID
name|close
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|,
name|fcntl
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|F_DUPFD
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|)
else|#
directive|else
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
endif|#
directive|endif
operator|==
name|STDOUT_FILENO
operator|&&
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|VOID
name|close
argument_list|(
name|STDERR_FILENO
argument_list|)
decl_stmt|;
name|VOID
name|execl
argument_list|(
name|binpwd
argument_list|,
name|binpwd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|VOID
name|execl
argument_list|(
name|usrbinpwd
argument_list|,
name|usrbinpwd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
block|}
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|errno
expr_stmt|;
name|closeerror
operator|=
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|closeerrno
operator|=
name|errno
expr_stmt|;
name|fp
operator|=
literal|0
expr_stmt|;
name|readerror
operator|=
name|toolong
operator|=
name|wstatus
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|child
condition|)
block|{
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|lim
operator|=
name|p
operator|+
name|size
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
condition|;
operator|*
name|p
operator|++
operator|=
name|c
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|readerror
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|lim
condition|)
block|{
name|toolong
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|#
directive|if
name|has_waitpid
if|if
condition|(
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|wstatus
operator|=
literal|1
expr_stmt|;
else|#
directive|else
do|do
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|wstatus
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|w
operator|!=
name|child
condition|)
do|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|VOID
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|readerror
condition|)
block|{
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|closeerror
condition|)
block|{
name|errno
operator|=
name|closeerrno
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|toolong
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|wstatus
operator|||
name|p
operator|==
name|path
operator|||
operator|*
operator|--
name|p
operator|!=
literal|'\n'
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PAIRTEST
end_ifdef

begin_comment
comment|/* test program for pairfilenames() and getfullRCSname() */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|"pair"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|initflag
decl_stmt|;
name|quietflag
operator|=
name|initflag
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|workstdout
operator|=
name|stdout
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unknown option: %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|do
block|{
name|RCSfilename
operator|=
name|workfilename
operator|=
name|nil
expr_stmt|;
name|result
operator|=
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
operator|!
name|initflag
argument_list|,
name|quietflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|diagnose
argument_list|(
literal|"RCS file: %s; working file: %s\nFull RCS file name: %s\n"
argument_list|,
name|RCSfilename
argument_list|,
name|workfilename
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* already paired file */
case|case
literal|1
case|:
if|if
condition|(
name|initflag
condition|)
block|{
name|error
argument_list|(
literal|"RCS file %s exists already"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"RCS file %s exists\n"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
block|}
name|Ifclose
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|diagnose
argument_list|(
literal|"RCS file doesn't exist\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
block|}
end_function

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

