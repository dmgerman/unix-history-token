begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* status.c: functions for printing fancy status messages in rc */
end_comment

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"sigmsgs.h"
end_include

begin_comment
comment|/* status == the wait() value of the last command in the pipeline, or the last command */
end_comment

begin_decl_stmt
specifier|static
name|int
name|statuses
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipelength
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Test to see if rc's status is true. According to td, status is true    if and only if every pipe-member has an exit status of zero. */
end_comment

begin_function
specifier|extern
name|int
name|istrue
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pipelength
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|statuses
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*    Return the status as an integer. A status which has low-bits set is    a signal number, whereas a status with high bits set is a value set    from exit(). The presence of a signal just sets status to 1. Also,    a pipeline with nonzero exit statuses in it just sets status to 1. */
end_comment

begin_function
specifier|extern
name|int
name|getstatus
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|pipelength
operator|>
literal|1
condition|)
return|return
operator|!
name|istrue
argument_list|()
return|;
name|s
operator|=
name|statuses
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|s
operator|&
literal|0xff
operator|)
condition|?
literal|1
else|:
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|set
parameter_list|(
name|bool
name|code
parameter_list|)
block|{
name|setstatus
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
operator|!
name|code
operator|)
operator|<<
literal|8
argument_list|)
expr_stmt|;
comment|/* exit status 1 == 0x100 */
block|}
end_function

begin_comment
comment|/* take a pipeline and store the exit statuses. Check to see whether any of the children dumped core */
end_comment

begin_function
specifier|extern
name|void
name|setpipestatus
parameter_list|(
name|int
name|stats
index|[]
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|pipelength
operator|=
name|num
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|statprint
argument_list|(
operator|-
literal|1
argument_list|,
name|stats
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|statuses
index|[
name|i
index|]
operator|=
name|stats
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* set a simple status, as opposed to a pipeline */
end_comment

begin_function
specifier|extern
name|void
name|setstatus
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|pipelength
operator|=
literal|1
expr_stmt|;
name|statuses
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|statprint
argument_list|(
name|pid
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print a message if termination was with a signal, and if the child dumped core. exit on error if -e is set */
end_comment

begin_function
specifier|extern
name|void
name|statprint
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|&
literal|0xff
condition|)
block|{
name|char
modifier|*
name|msg
init|=
operator|(
operator|(
name|i
operator|&
literal|0x7f
operator|)
operator|<
name|NUMOFSIGNALS
condition|?
name|signals
index|[
name|i
operator|&
literal|0x7f
index|]
operator|.
name|msg
else|:
literal|""
operator|)
decl_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%d: "
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
operator|*
name|msg
operator|==
literal|'\0'
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"core dumped\n"
argument_list|)
expr_stmt|;
else|else
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%s--core dumped\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|msg
operator|!=
literal|'\0'
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
name|dashee
operator|&&
operator|!
name|cond
condition|)
name|rc_exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* prepare a list to be passed back. Used whenever $status is dereferenced */
end_comment

begin_function
specifier|extern
name|List
modifier|*
name|sgetstatus
parameter_list|()
block|{
name|List
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|r
operator|=
name|NULL
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pipelength
condition|;
name|i
operator|++
control|)
block|{
name|List
modifier|*
name|q
init|=
name|nnew
argument_list|(
name|List
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|statuses
index|[
name|i
index|]
decl_stmt|;
name|int
name|t
decl_stmt|;
name|q
operator|->
name|n
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|s
operator|&
literal|0x7f
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|core
init|=
operator|(
name|s
operator|&
literal|0x80
operator|)
condition|?
literal|"+core"
else|:
literal|""
decl_stmt|;
if|if
condition|(
name|t
operator|<
name|NUMOFSIGNALS
operator|&&
operator|*
name|signals
index|[
name|t
index|]
operator|.
name|name
operator|!=
literal|'\0'
condition|)
name|r
operator|->
name|w
operator|=
name|nprint
argument_list|(
literal|"%s%s"
argument_list|,
name|signals
index|[
name|t
index|]
operator|.
name|name
argument_list|,
name|core
argument_list|)
expr_stmt|;
else|else
name|r
operator|->
name|w
operator|=
name|nprint
argument_list|(
literal|"-%d%s"
argument_list|,
name|t
argument_list|,
name|core
argument_list|)
expr_stmt|;
comment|/* unknown signals are negated */
block|}
else|else
name|r
operator|->
name|w
operator|=
name|nprint
argument_list|(
literal|"%d"
argument_list|,
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|ssetstatus
parameter_list|(
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|bool
name|found
decl_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|av
index|[
name|l
index|]
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
empty_stmt|;
comment|/* count up array length */
operator|--
name|l
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|av
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|a2u
argument_list|(
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|statuses
index|[
name|l
operator|-
name|i
index|]
operator|=
name|j
operator|<<
literal|8
expr_stmt|;
continue|continue;
block|}
name|found
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUMOFSIGNALS
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|signals
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|statuses
index|[
name|l
operator|-
name|i
index|]
operator|=
name|k
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|signals
index|[
name|k
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|signals
index|[
name|k
index|]
operator|.
name|name
argument_list|,
name|av
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|streq
argument_list|(
name|av
index|[
name|i
index|]
operator|+
name|len
argument_list|,
literal|"+core"
argument_list|)
condition|)
block|{
name|statuses
index|[
name|l
operator|-
name|i
index|]
operator|=
name|k
operator|+
literal|0x80
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"bad status\n"
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|pipelength
operator|=
name|i
expr_stmt|;
block|}
end_function

end_unit

