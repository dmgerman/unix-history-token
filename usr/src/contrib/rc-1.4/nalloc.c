begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nalloc.c: a simple single-arena allocator for command-line-lifetime allocation */
end_comment

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_struct
specifier|static
struct|struct
name|Block
block|{
name|size_t
name|used
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|;
name|Block
modifier|*
name|n
decl_stmt|;
block|}
modifier|*
name|fl
struct|,
modifier|*
name|ul
struct|;
end_struct

begin_comment
comment|/* alignto() works only with power of 2 blocks and assumes 2's complement arithmetic */
end_comment

begin_define
define|#
directive|define
name|alignto
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
value|((m + n - 1)& ~(n - 1))
end_define

begin_define
define|#
directive|define
name|BLOCKSIZE
value|((size_t) 4096)
end_define

begin_comment
comment|/* Allocate a block from the free list or malloc one if none in the fl fit */
end_comment

begin_function
specifier|static
name|void
name|getblock
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|Block
modifier|*
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|r
operator|=
name|fl
operator|,
name|p
operator|=
name|NULL
init|;
name|r
operator|!=
name|NULL
condition|;
name|p
operator|=
name|r
operator|,
name|r
operator|=
name|r
operator|->
name|n
control|)
if|if
condition|(
name|n
operator|<=
name|r
operator|->
name|size
condition|)
break|break;
comment|/* look for a block which fits the request */
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
comment|/* if one is found, take it off the free list */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|n
operator|=
name|r
operator|->
name|n
expr_stmt|;
else|else
name|fl
operator|=
name|r
operator|->
name|n
expr_stmt|;
block|}
else|else
block|{
comment|/* else allocate a new block */
name|r
operator|=
name|enew
argument_list|(
name|Block
argument_list|)
expr_stmt|;
name|r
operator|->
name|mem
operator|=
name|ealloc
argument_list|(
name|r
operator|->
name|size
operator|=
name|alignto
argument_list|(
name|n
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|n
operator|=
name|ul
expr_stmt|;
name|ul
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    A fast single-arena allocator. Looks at the current block, and if    there is not enough room, it goes to getblock() for more. "ul"    stands for "used list", and the head of the list is the current    block. "ulp" is a register cache for "ul"; this routine is hacked    for speed. (sigh, optimizing RISC compilers still can't cache the    address of a global in a register) */
end_comment

begin_function
specifier|extern
name|void
modifier|*
name|nalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|size_t
name|base
decl_stmt|;
name|Block
modifier|*
name|ulp
decl_stmt|;
name|n
operator|=
name|alignto
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|ALIGN_T
argument_list|)
argument_list|)
expr_stmt|;
name|ulp
operator|=
name|ul
expr_stmt|;
if|if
condition|(
name|ulp
operator|!=
name|NULL
operator|&&
name|n
operator|+
operator|(
name|base
operator|=
name|ulp
operator|->
name|used
operator|)
operator|<
name|ulp
operator|->
name|size
condition|)
block|{
name|ulp
operator|->
name|used
operator|=
name|base
operator|+
name|n
expr_stmt|;
return|return
operator|&
name|ulp
operator|->
name|mem
index|[
name|base
index|]
return|;
block|}
else|else
block|{
name|getblock
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* assert(ul->used) == 0 */
operator|(
name|ulp
operator|=
name|ul
operator|)
operator|->
name|used
operator|=
name|n
expr_stmt|;
return|return
operator|&
name|ulp
operator|->
name|mem
index|[
literal|0
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/*    Frees memory from nalloc space by putting it on the free list.    Returns free blocks to the system, retaining at least MAXMEM bytes    worth of blocks for nalloc. */
end_comment

begin_define
define|#
directive|define
name|MAXMEM
value|500000
end_define

begin_function
specifier|extern
name|void
name|nfree
parameter_list|()
block|{
name|size_t
name|count
decl_stmt|;
name|Block
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|ul
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|r
operator|=
name|ul
init|;
name|r
operator|->
name|n
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|n
control|)
empty_stmt|;
comment|/* get to end of used list */
name|r
operator|->
name|n
operator|=
name|fl
expr_stmt|;
comment|/* tack free list onto it */
name|fl
operator|=
name|ul
expr_stmt|;
comment|/* and make it the free list */
name|ul
operator|=
name|NULL
expr_stmt|;
comment|/* finally, zero out the used list */
for|for
control|(
name|r
operator|=
name|fl
operator|,
name|count
operator|=
name|r
operator|->
name|size
init|;
name|r
operator|->
name|n
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|n
operator|,
name|count
operator|+=
name|r
operator|->
name|size
control|)
block|{
if|if
condition|(
name|count
operator|>=
name|MAXMEM
condition|)
block|{
name|Block
modifier|*
name|tmp
init|=
name|r
decl_stmt|;
name|r
operator|=
name|r
operator|->
name|n
expr_stmt|;
name|tmp
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
comment|/* terminate the free list */
while|while
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
comment|/* free memory off the tail of the free list */
name|tmp
operator|=
name|r
operator|->
name|n
expr_stmt|;
name|efree
argument_list|(
name|r
operator|->
name|mem
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|tmp
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*    "Allocates" a new arena by zeroing out the old one. Up to the    calling routine to keep the old value of the block around. */
end_comment

begin_function
specifier|extern
name|Block
modifier|*
name|newblock
parameter_list|()
block|{
name|Block
modifier|*
name|old
init|=
name|ul
decl_stmt|;
name|ul
operator|=
name|NULL
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* "Restores" an arena to its saved value. */
end_comment

begin_function
specifier|extern
name|void
name|restoreblock
parameter_list|(
name|Block
modifier|*
name|old
parameter_list|)
block|{
name|nfree
argument_list|()
expr_stmt|;
name|ul
operator|=
name|old
expr_stmt|;
block|}
end_function

begin_comment
comment|/* generic memory allocation functions */
end_comment

begin_function
specifier|extern
name|void
modifier|*
name|ealloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
specifier|extern
name|void
modifier|*
name|malloc
argument_list|(
name|size_t
argument_list|)
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|uerror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|rc_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|extern
name|void
modifier|*
name|erealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
specifier|extern
name|void
modifier|*
name|realloc
argument_list|(
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|uerror
argument_list|(
literal|"realloc"
argument_list|)
expr_stmt|;
name|rc_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|efree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|extern
name|void
name|free
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

