begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 	history.c -- primitive history mechanism  	Paul Haahr& Byron Rakitzis, July 1991.  	This program mimics the att v8 = and == history programs. 	The edit() algorithm was adapted from a similar program 	that Boyd Roberts wrote, but otherwise all the code has 	been written from scratch.  	edit() was subsequently redone by Hugh Redelmeier in order 	to correctly deal with tab characters in the source line.  	BUGS: 	There is an implicit assumption that commands are no 	more than 1k characters long.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|id
init|=
literal|"@(#) history.c  8/91"
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|FALSE
end_undef

begin_undef
undef|#
directive|undef
name|TRUE
end_undef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FALSE
block|,
name|TRUE
block|}
name|bool
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHUNKSIZE
value|65536
end_define

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
block|}
modifier|*
name|replace
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|search
decl_stmt|,
modifier|*
name|progname
decl_stmt|,
modifier|*
name|history
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|me
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* typically ':' or '-' */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|editit
init|=
name|FALSE
decl_stmt|,
name|printit
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nreplace
init|=
literal|0
decl_stmt|,
name|nsearch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|ealloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|erealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"realloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|newstr
parameter_list|()
block|{
return|return
name|ealloc
argument_list|(
operator|(
name|size_t
operator|)
literal|1024
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|basename
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
init|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
return|return
operator|(
name|t
operator|==
name|NULL
operator|)
condition|?
name|s
else|:
name|t
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* stupid O(n^2) substring matching routine */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|isin
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|)
block|{
name|size_t
name|plen
init|=
name|strlen
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|size_t
name|tlen
init|=
name|strlen
argument_list|(
name|target
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|tlen
operator|>=
name|plen
condition|;
name|target
operator|++
operator|,
operator|--
name|tlen
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|target
argument_list|,
name|pattern
argument_list|,
name|plen
argument_list|)
operator|==
literal|0
condition|)
return|return
name|target
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* replace the first match in the string with "new" */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sub
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|old
parameter_list|,
name|char
modifier|*
name|new
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|u
decl_stmt|;
name|t
operator|=
name|isin
argument_list|(
name|s
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|u
operator|=
name|newstr
argument_list|()
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|old
operator|!=
literal|'\0'
condition|)
name|old
operator|++
operator|,
name|t
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|u
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|u
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|u
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|edit
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|final
decl_stmt|,
modifier|*
name|f
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|col
decl_stmt|;
name|bool
name|ins
decl_stmt|;
name|start
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|f
operator|=
name|final
operator|=
name|newstr
argument_list|()
expr_stmt|;
name|end
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
name|ins
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
name|col
operator|++
control|)
block|{
name|int
name|c
init|=
name|getchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|me
operator|&&
name|col
operator|==
literal|0
condition|)
block|{
name|int
name|peekc
init|=
name|getchar
argument_list|()
decl_stmt|;
if|if
condition|(
name|peekc
operator|==
literal|'\n'
condition|)
return|return
name|NULL
return|;
name|ungetc
argument_list|(
name|peekc
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|col
operator|==
literal|0
condition|)
return|return
name|s
return|;
while|while
condition|(
name|s
operator|<
name|end
condition|)
comment|/* copy remainder of string */
operator|*
name|f
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|final
expr_stmt|;
goto|goto
name|start
goto|;
block|}
elseif|else
if|if
condition|(
name|ins
operator|||
name|s
operator|>=
name|end
condition|)
block|{
comment|/* col need not be accurate -- tabs need not be interpreted */
operator|*
name|f
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
while|while
condition|(
name|s
operator|<
name|end
condition|)
operator|*
name|f
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|c
operator|=
literal|' '
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
operator|*
name|f
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|EOF
case|:
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|' '
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|int
name|oldcol
init|=
name|col
decl_stmt|;
for|for
control|(
init|;
condition|;
name|col
operator|++
control|)
block|{
name|int
name|peekc
decl_stmt|;
if|if
condition|(
operator|(
name|col
operator|&
literal|07
operator|)
operator|==
literal|07
condition|)
block|{
operator|*
name|f
operator|++
operator|=
literal|'\t'
expr_stmt|;
comment|/* we spaced past a tab */
break|break;
block|}
name|peekc
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|peekc
operator|!=
literal|' '
condition|)
block|{
name|ungetc
argument_list|(
name|peekc
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|peekc
operator|!=
literal|'\n'
condition|)
block|{
comment|/* we spaced partially into a tab */
do|do
block|{
operator|*
name|f
operator|++
operator|=
literal|' '
expr_stmt|;
name|oldcol
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|oldcol
operator|<=
name|col
condition|)
do|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
operator|*
name|f
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
break|break;
case|case
literal|'$'
case|:
name|end
operator|=
name|s
expr_stmt|;
comment|/* truncate s */
continue|continue;
comment|/* skip incrementing s */
case|case
literal|'^'
case|:
name|ins
operator|=
name|TRUE
expr_stmt|;
continue|continue;
comment|/* skip incrementing s */
case|case
literal|'\t'
case|:
for|for
control|(
init|;
condition|;
name|col
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|f
operator|++
operator|=
name|s
operator|<
name|end
condition|?
operator|*
name|s
operator|++
else|:
literal|'\t'
operator|)
operator|==
literal|'\t'
condition|)
block|{
name|col
operator|=
name|col
operator||
literal|07
expr_stmt|;
comment|/* advance to before next tabstop */
block|}
if|if
condition|(
operator|(
name|col
operator|&
literal|07
operator|)
operator|==
literal|07
condition|)
comment|/* stop before tabstop */
break|break;
block|}
continue|continue;
comment|/* skip incrementing s */
block|}
if|if
condition|(
name|s
operator|<
name|end
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'\t'
operator|||
operator|(
name|col
operator|&
literal|07
operator|)
operator|==
literal|07
operator|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|readhistoryfile
parameter_list|(
name|char
modifier|*
modifier|*
name|last
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|size
decl_stmt|;
name|long
name|nread
decl_stmt|;
if|if
condition|(
operator|(
name|history
operator|=
name|getenv
argument_list|(
literal|"history"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"$history not set\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|history
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|history
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|ealloc
argument_list|(
name|size
operator|=
name|CHUNKSIZE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nread
operator|=
name|fread
argument_list|(
name|buf
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|size
operator|-
name|count
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|count
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|size
operator|-
name|count
operator|==
literal|0
condition|)
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
name|size
operator|*=
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nread
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|history
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|last
operator|=
name|buf
operator|+
name|count
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getcommand
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|static
name|char
modifier|*
name|hist
init|=
name|NULL
decl_stmt|,
modifier|*
name|last
decl_stmt|;
if|if
condition|(
name|hist
operator|==
name|NULL
condition|)
block|{
name|hist
operator|=
name|readhistoryfile
argument_list|(
operator|&
name|last
argument_list|)
expr_stmt|;
operator|*
operator|--
name|last
operator|=
literal|'\0'
expr_stmt|;
comment|/* trim final newline */
block|}
name|again
label|:
name|s
operator|=
name|last
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|hist
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|*
operator|--
name|s
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|s
operator|<=
name|hist
condition|)
block|{
name|last
operator|=
name|hist
operator|-
literal|1
expr_stmt|;
return|return
name|hist
return|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|last
operator|=
name|s
operator|++
expr_stmt|;
comment|/* 	 * if the command contains the "me" character at the start of the line 	 * or after any of [`{|()] then try again 	 */
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
operator|!=
literal|'\0'
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
name|me
condition|)
block|{
name|char
modifier|*
name|u
init|=
name|t
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|u
operator|>=
name|s
operator|&&
operator|(
operator|*
name|u
operator|==
literal|' '
operator|||
operator|*
name|u
operator|==
literal|'\t'
operator|)
condition|)
operator|--
name|u
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|s
operator|||
operator|*
name|u
operator|==
literal|'`'
operator|||
operator|*
name|u
operator|==
literal|'{'
operator|||
operator|*
name|u
operator|==
literal|'|'
operator|||
operator|*
name|u
operator|==
literal|'('
operator|||
operator|*
name|u
operator|==
literal|')'
condition|)
goto|goto
name|again
goto|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|me
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|me
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|editit
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'p'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|printit
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Nahh... 	if (*s != '\0') { 		fprintf(stderr, "\"%s\": bad name for history program\n", progname); 		exit(1); 	} */
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|replace
operator|=
name|ealloc
argument_list|(
operator|(
name|argc
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|replace
argument_list|)
expr_stmt|;
name|search
operator|=
name|ealloc
argument_list|(
operator|(
name|argc
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|search
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|search
index|[
name|nsearch
operator|++
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
operator|*
operator|(
name|char
operator|*
operator|)
name|s
operator|=
literal|'\0'
expr_stmt|;
comment|/* do we confuse ps too much? */
name|replace
index|[
name|nreplace
index|]
operator|.
name|old
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|replace
index|[
name|nreplace
index|]
operator|.
name|new
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|nreplace
operator|++
expr_stmt|;
block|}
name|next
label|:
name|s
operator|=
name|getcommand
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"command not matched\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsearch
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isin
argument_list|(
name|s
argument_list|,
name|search
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|next
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreplace
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isin
argument_list|(
name|s
argument_list|,
name|replace
index|[
name|i
index|]
operator|.
name|old
argument_list|)
condition|)
goto|goto
name|next
goto|;
else|else
name|s
operator|=
name|sub
argument_list|(
name|s
argument_list|,
name|replace
index|[
name|i
index|]
operator|.
name|old
argument_list|,
name|replace
index|[
name|i
index|]
operator|.
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|editit
condition|)
block|{
name|s
operator|=
name|edit
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
block|}
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 2 == end of file. i.e., append command to $history */
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|printit
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|shell
init|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|editit
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
name|execl
argument_list|(
name|shell
argument_list|,
name|basename
argument_list|(
name|shell
argument_list|)
argument_list|,
literal|"-c"
argument_list|,
name|s
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|shell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

