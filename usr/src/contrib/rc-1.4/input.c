begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* input.c: i/o routines for files and pseudo-files (strings) */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"jbwrap.h"
end_include

begin_comment
comment|/*    NB: character unget is supported for up to two characters, but NOT    in the case of EOF. Since EOF does not fit in a char, it is easiest    to support only one unget of EOF. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Input
block|{
name|inputtype
name|t
decl_stmt|;
name|char
modifier|*
name|ibuf
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|index
decl_stmt|,
name|read
decl_stmt|,
name|lineno
decl_stmt|,
name|last
decl_stmt|;
name|bool
name|saved
decl_stmt|,
name|eofread
decl_stmt|;
block|}
name|Input
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BUFSIZE
value|((size_t) 256)
end_define

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|,
modifier|*
name|prompt2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|rcrc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|dead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdgchar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stringgchar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|history
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ugdead
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pushcommon
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|inbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|istacksize
decl_stmt|,
name|chars_out
decl_stmt|,
name|chars_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|eofread
init|=
name|FALSE
decl_stmt|,
name|save_lineno
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Input
modifier|*
name|istack
decl_stmt|,
modifier|*
name|itop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|histstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|histfd
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|realgchar
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|realugchar
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_function
specifier|extern
name|int
name|gchar
parameter_list|()
block|{
if|if
condition|(
name|eofread
condition|)
block|{
name|eofread
operator|=
name|FALSE
expr_stmt|;
return|return
name|last
operator|=
name|EOF
return|;
block|}
return|return
call|(
modifier|*
name|realgchar
call|)
argument_list|()
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|ugchar
parameter_list|(
name|int
name|c
parameter_list|)
block|{
call|(
modifier|*
name|realugchar
call|)
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dead
parameter_list|()
block|{
return|return
name|last
operator|=
name|EOF
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ugdead
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ugalive
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|eofread
operator|=
name|TRUE
expr_stmt|;
else|else
name|inbuf
index|[
operator|--
name|chars_out
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get the next character from a string. */
end_comment

begin_function
specifier|static
name|int
name|stringgchar
parameter_list|()
block|{
return|return
name|last
operator|=
operator|(
name|inbuf
index|[
name|chars_out
index|]
operator|==
literal|'\0'
condition|?
name|EOF
else|:
name|inbuf
index|[
name|chars_out
operator|++
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* signal-safe readline wrapper */
end_comment

begin_comment
comment|/*    read a character from a file-descriptor. If GNU readline is defined, add a newline and doctor    the buffer to look like a regular fdgchar buffer. */
end_comment

begin_function
specifier|static
name|int
name|fdgchar
parameter_list|()
block|{
if|if
condition|(
name|chars_out
operator|>=
name|chars_in
operator|+
literal|2
condition|)
block|{
comment|/* has the buffer been exhausted? if so, replenish it */
while|while
condition|(
literal|1
condition|)
block|{
name|long
comment|/*ssize_t*/
name|r
init|=
name|rc_read
argument_list|(
name|istack
operator|->
name|fd
argument_list|,
name|inbuf
operator|+
literal|2
argument_list|,
name|BUFSIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
comment|/* Suppose it was interrupted by a signal */
name|uerror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
name|rc_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|chars_in
operator|=
operator|(
name|size_t
operator|)
name|r
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chars_in
operator|==
literal|0
condition|)
return|return
name|last
operator|=
name|EOF
return|;
name|chars_out
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|dashvee
condition|)
name|writeall
argument_list|(
literal|2
argument_list|,
name|inbuf
operator|+
literal|2
argument_list|,
name|chars_in
argument_list|)
expr_stmt|;
name|history
argument_list|()
expr_stmt|;
block|}
return|return
name|last
operator|=
name|inbuf
index|[
name|chars_out
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* set up the input stack, and put a "dead" input at the bottom, so that yyparse will always read eof */
end_comment

begin_function
specifier|extern
name|void
name|initinput
parameter_list|()
block|{
name|istack
operator|=
name|itop
operator|=
name|ealloc
argument_list|(
name|istacksize
operator|=
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|Input
argument_list|)
argument_list|)
expr_stmt|;
name|istack
operator|->
name|t
operator|=
name|iFd
expr_stmt|;
name|istack
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|realugchar
operator|=
name|ugalive
expr_stmt|;
block|}
end_function

begin_comment
comment|/* push an input source onto the stack. set up a new input buffer, and set gchar() */
end_comment

begin_function
specifier|static
name|void
name|pushcommon
parameter_list|()
block|{
name|size_t
name|idiff
decl_stmt|;
name|istack
operator|->
name|index
operator|=
name|chars_out
expr_stmt|;
name|istack
operator|->
name|read
operator|=
name|chars_in
expr_stmt|;
name|istack
operator|->
name|ibuf
operator|=
name|inbuf
expr_stmt|;
name|istack
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|istack
operator|->
name|saved
operator|=
name|save_lineno
expr_stmt|;
name|istack
operator|->
name|last
operator|=
name|last
expr_stmt|;
name|istack
operator|->
name|eofread
operator|=
name|eofread
expr_stmt|;
name|istack
operator|++
expr_stmt|;
name|idiff
operator|=
name|istack
operator|-
name|itop
expr_stmt|;
if|if
condition|(
name|idiff
operator|>=
name|istacksize
operator|/
sizeof|sizeof
argument_list|(
name|Input
argument_list|)
condition|)
block|{
name|itop
operator|=
name|erealloc
argument_list|(
name|itop
argument_list|,
name|istacksize
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|istack
operator|=
name|itop
operator|+
name|idiff
expr_stmt|;
block|}
name|realugchar
operator|=
name|ugalive
expr_stmt|;
name|chars_out
operator|=
literal|2
expr_stmt|;
name|chars_in
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|pushfd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|pushcommon
argument_list|()
expr_stmt|;
name|istack
operator|->
name|t
operator|=
name|iFd
expr_stmt|;
name|save_lineno
operator|=
name|TRUE
expr_stmt|;
name|istack
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|realgchar
operator|=
name|fdgchar
expr_stmt|;
name|inbuf
operator|=
name|ealloc
argument_list|(
name|BUFSIZE
operator|+
literal|2
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|pushstring
parameter_list|(
name|char
modifier|*
modifier|*
name|a
parameter_list|,
name|bool
name|save
parameter_list|)
block|{
name|pushcommon
argument_list|()
expr_stmt|;
name|istack
operator|->
name|t
operator|=
name|iString
expr_stmt|;
name|save_lineno
operator|=
name|save
expr_stmt|;
name|inbuf
operator|=
name|mprint
argument_list|(
literal|"..%A"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|realgchar
operator|=
name|stringgchar
expr_stmt|;
if|if
condition|(
name|save_lineno
condition|)
name|lineno
operator|=
literal|1
expr_stmt|;
else|else
operator|--
name|lineno
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove an input source from the stack. restore the right kind of getchar (string,fd) etc. */
end_comment

begin_function
specifier|extern
name|void
name|popinput
parameter_list|()
block|{
if|if
condition|(
name|istack
operator|->
name|t
operator|==
name|iFd
condition|)
name|close
argument_list|(
name|istack
operator|->
name|fd
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
operator|--
name|istack
expr_stmt|;
name|realgchar
operator|=
operator|(
name|istack
operator|->
name|t
operator|==
name|iString
condition|?
name|stringgchar
else|:
name|fdgchar
operator|)
expr_stmt|;
if|if
condition|(
name|istack
operator|->
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* top of input stack */
name|realgchar
operator|=
name|dead
expr_stmt|;
name|realugchar
operator|=
name|ugdead
expr_stmt|;
block|}
name|last
operator|=
name|istack
operator|->
name|last
expr_stmt|;
name|eofread
operator|=
name|istack
operator|->
name|eofread
expr_stmt|;
name|inbuf
operator|=
name|istack
operator|->
name|ibuf
expr_stmt|;
name|chars_out
operator|=
name|istack
operator|->
name|index
expr_stmt|;
name|chars_in
operator|=
name|istack
operator|->
name|read
expr_stmt|;
if|if
condition|(
name|save_lineno
condition|)
name|lineno
operator|=
name|istack
operator|->
name|lineno
expr_stmt|;
else|else
name|lineno
operator|++
expr_stmt|;
name|save_lineno
operator|=
name|istack
operator|->
name|saved
expr_stmt|;
block|}
end_function

begin_comment
comment|/* flush input characters upto newline. Used by scanerror() */
end_comment

begin_function
specifier|extern
name|void
name|flushu
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|last
operator|==
literal|'\n'
operator|||
name|last
operator|==
name|EOF
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
name|gchar
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
comment|/* skip to newline */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|ugchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* the wrapper loop in rc: prompt for commands until EOF, calling yyparse and walk() */
end_comment

begin_function
specifier|extern
name|Node
modifier|*
name|doit
parameter_list|(
name|bool
name|execit
parameter_list|)
block|{
name|bool
name|eof
decl_stmt|;
name|Jbwrap
name|j
decl_stmt|;
name|Estack
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|Edata
name|jerror
decl_stmt|;
if|if
condition|(
name|dashen
condition|)
name|execit
operator|=
name|FALSE
expr_stmt|;
name|setjmp
argument_list|(
name|j
operator|.
name|j
argument_list|)
expr_stmt|;
name|jerror
operator|.
name|jb
operator|=
operator|&
name|j
expr_stmt|;
name|except
argument_list|(
name|eError
argument_list|,
name|jerror
argument_list|,
operator|&
name|e1
argument_list|)
expr_stmt|;
for|for
control|(
name|eof
operator|=
name|FALSE
init|;
operator|!
name|eof
condition|;
control|)
block|{
name|Edata
name|block
decl_stmt|;
name|block
operator|.
name|b
operator|=
name|newblock
argument_list|()
expr_stmt|;
name|except
argument_list|(
name|eArena
argument_list|,
name|block
argument_list|,
operator|&
name|e2
argument_list|)
expr_stmt|;
name|SIGCHK
expr_stmt|;
if|if
condition|(
name|dashell
condition|)
block|{
name|char
modifier|*
name|fname
index|[
literal|3
index|]
decl_stmt|;
name|fname
index|[
literal|1
index|]
operator|=
name|concat
argument_list|(
name|varlookup
argument_list|(
literal|"home"
argument_list|)
argument_list|,
name|word
argument_list|(
literal|"/.rcrc"
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|->
name|w
expr_stmt|;
name|fname
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|rcrc
operator|=
name|TRUE
expr_stmt|;
name|dashell
operator|=
name|FALSE
expr_stmt|;
name|b_dot
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interactive
condition|)
block|{
name|List
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|dashen
operator|&&
name|fnlookup
argument_list|(
literal|"prompt"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
modifier|*
name|arglist
index|[]
init|=
block|{
literal|"prompt"
block|,
name|NULL
block|}
decl_stmt|;
name|funcall
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|varlookup
argument_list|(
literal|"prompt"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|s
operator|->
name|w
argument_list|)
expr_stmt|;
name|prompt2
operator|=
operator|(
name|s
operator|->
name|n
operator|==
name|NULL
condition|?
literal|""
else|:
name|s
operator|->
name|n
operator|->
name|w
operator|)
expr_stmt|;
block|}
block|}
name|inityy
argument_list|()
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
operator|==
literal|1
operator|&&
name|execit
condition|)
name|rc_raise
argument_list|(
name|eError
argument_list|)
expr_stmt|;
name|eof
operator|=
operator|(
name|last
operator|==
name|EOF
operator|)
expr_stmt|;
comment|/* "last" can be clobbered during a walk() */
if|if
condition|(
name|parsetree
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|execit
condition|)
name|walk
argument_list|(
name|parsetree
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dashex
operator|&&
name|dashen
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%T\n"
argument_list|,
name|parsetree
argument_list|)
expr_stmt|;
block|}
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eArena */
block|}
name|popinput
argument_list|()
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eError */
return|return
name|parsetree
return|;
block|}
end_function

begin_comment
comment|/* parse a function imported from the environment */
end_comment

begin_function
specifier|extern
name|Node
modifier|*
name|parseline
parameter_list|(
name|char
modifier|*
name|extdef
parameter_list|)
block|{
name|int
name|i
init|=
name|interactive
decl_stmt|;
name|char
modifier|*
name|in
index|[
literal|2
index|]
decl_stmt|;
name|Node
modifier|*
name|fun
decl_stmt|;
name|in
index|[
literal|0
index|]
operator|=
name|extdef
expr_stmt|;
name|in
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|interactive
operator|=
name|FALSE
expr_stmt|;
name|pushstring
argument_list|(
name|in
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|fun
operator|=
name|doit
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|interactive
operator|=
name|i
expr_stmt|;
return|return
name|fun
return|;
block|}
end_function

begin_comment
comment|/* write last command out to a file. Check to see if $history has changed, also */
end_comment

begin_function
specifier|static
name|void
name|history
parameter_list|()
block|{
name|List
modifier|*
name|histlist
decl_stmt|;
name|size_t
name|a
decl_stmt|;
if|if
condition|(
operator|!
name|interactive
condition|)
return|return;
if|if
condition|(
operator|(
name|histlist
operator|=
name|varlookup
argument_list|(
literal|"history"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|histstr
operator|!=
name|NULL
condition|)
block|{
name|efree
argument_list|(
name|histstr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|histfd
argument_list|)
expr_stmt|;
name|histstr
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|histstr
operator|==
name|NULL
operator|||
operator|!
name|streq
argument_list|(
name|histstr
argument_list|,
name|histlist
operator|->
name|w
argument_list|)
condition|)
block|{
comment|/* open new file */
if|if
condition|(
name|histstr
operator|!=
name|NULL
condition|)
block|{
name|efree
argument_list|(
name|histstr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|histfd
argument_list|)
expr_stmt|;
block|}
name|histstr
operator|=
name|ecpy
argument_list|(
name|histlist
operator|->
name|w
argument_list|)
expr_stmt|;
name|histfd
operator|=
name|rc_open
argument_list|(
name|histstr
argument_list|,
name|rAppend
argument_list|)
expr_stmt|;
if|if
condition|(
name|histfd
operator|<
literal|0
condition|)
block|{
name|uerror
argument_list|(
name|histstr
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|histstr
argument_list|)
expr_stmt|;
name|histstr
operator|=
name|NULL
expr_stmt|;
name|varrm
argument_list|(
literal|"history"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	   Small unix hack: since read() reads only up to a newline 	   from a terminal, then presumably this write() will write at 	   most only one input line at a time. 	*/
for|for
control|(
name|a
operator|=
literal|2
init|;
name|a
operator|<
name|chars_in
operator|+
literal|2
condition|;
name|a
operator|++
control|)
block|{
comment|/* skip empty lines and comments in history. */
if|if
condition|(
name|inbuf
index|[
name|a
index|]
operator|==
literal|'#'
operator|||
name|inbuf
index|[
name|a
index|]
operator|==
literal|'\n'
condition|)
return|return;
if|if
condition|(
name|inbuf
index|[
name|a
index|]
operator|!=
literal|' '
operator|&&
name|inbuf
index|[
name|a
index|]
operator|!=
literal|'\t'
condition|)
break|break;
block|}
name|writeall
argument_list|(
name|histfd
argument_list|,
name|inbuf
operator|+
literal|2
argument_list|,
name|chars_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* close file descriptors after a fork() */
end_comment

begin_function
specifier|extern
name|void
name|closefds
parameter_list|()
block|{
name|Input
modifier|*
name|i
decl_stmt|;
if|if
condition|(
name|histstr
operator|!=
name|NULL
condition|)
block|{
comment|/* Close an open history file */
name|close
argument_list|(
name|histfd
argument_list|)
expr_stmt|;
name|histstr
operator|=
name|NULL
expr_stmt|;
comment|/* But prevent re-closing of the same file-descriptor */
block|}
for|for
control|(
name|i
operator|=
name|istack
init|;
name|i
operator|!=
name|itop
condition|;
operator|--
name|i
control|)
comment|/* close open scripts */
if|if
condition|(
name|i
operator|->
name|t
operator|==
name|iFd
operator|&&
name|i
operator|->
name|fd
operator|>
literal|2
condition|)
block|{
name|close
argument_list|(
name|i
operator|->
name|fd
argument_list|)
expr_stmt|;
name|i
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

end_unit

