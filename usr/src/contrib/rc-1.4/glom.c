begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* glom.c: builds an argument list out of words, variables, etc. */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_function_decl
specifier|static
name|List
modifier|*
name|backq
parameter_list|(
name|Node
modifier|*
parameter_list|,
name|Node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|List
modifier|*
name|bqinput
parameter_list|(
name|List
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|List
modifier|*
name|count
parameter_list|(
name|List
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|List
modifier|*
name|mkcmdarg
parameter_list|(
name|Node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|Rq
modifier|*
name|redirq
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|extern
name|List
modifier|*
name|word
parameter_list|(
name|char
modifier|*
name|w
parameter_list|,
name|char
modifier|*
name|m
parameter_list|)
block|{
name|List
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|w
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|s
operator|->
name|w
operator|=
name|w
expr_stmt|;
name|s
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|s
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*    Append list s2 to list s1 by copying s1 and making the new copy    point at s2. */
end_comment

begin_function
specifier|extern
name|List
modifier|*
name|append
parameter_list|(
name|List
modifier|*
name|s1
parameter_list|,
name|List
modifier|*
name|s2
parameter_list|)
block|{
name|List
modifier|*
name|r
decl_stmt|,
modifier|*
name|top
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
return|return
name|s2
return|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
return|return
name|s1
return|;
for|for
control|(
name|r
operator|=
name|top
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
init|;
literal|1
condition|;
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
control|)
block|{
name|r
operator|->
name|w
operator|=
name|s1
operator|->
name|w
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|s1
operator|->
name|m
expr_stmt|;
if|if
condition|(
operator|(
name|s1
operator|=
name|s1
operator|->
name|n
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
name|r
operator|->
name|n
operator|=
name|s2
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|extern
name|List
modifier|*
name|concat
parameter_list|(
name|List
modifier|*
name|s1
parameter_list|,
name|List
modifier|*
name|s2
parameter_list|)
block|{
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|List
modifier|*
name|r
decl_stmt|,
modifier|*
name|top
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
return|return
name|s2
return|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
return|return
name|s1
return|;
if|if
condition|(
operator|(
name|n1
operator|=
name|listnel
argument_list|(
name|s1
argument_list|)
operator|)
operator|!=
operator|(
name|n2
operator|=
name|listnel
argument_list|(
name|s2
argument_list|)
operator|)
operator|&&
name|n1
operator|!=
literal|1
operator|&&
name|n2
operator|!=
literal|1
condition|)
name|rc_error
argument_list|(
literal|"bad concatenation"
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|top
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
init|;
literal|1
condition|;
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
control|)
block|{
name|size_t
name|x
init|=
name|strlen
argument_list|(
name|s1
operator|->
name|w
argument_list|)
decl_stmt|;
name|size_t
name|y
init|=
name|strlen
argument_list|(
name|s2
operator|->
name|w
argument_list|)
decl_stmt|;
name|size_t
name|z
init|=
name|x
operator|+
name|y
operator|+
literal|1
decl_stmt|;
name|r
operator|->
name|w
operator|=
name|nalloc
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|r
operator|->
name|w
argument_list|,
name|s1
operator|->
name|w
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|r
operator|->
name|w
argument_list|,
name|s2
operator|->
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|->
name|m
operator|==
name|NULL
operator|&&
name|s2
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|r
operator|->
name|m
operator|=
name|nalloc
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|->
name|m
operator|==
name|NULL
condition|)
name|clear
argument_list|(
name|r
operator|->
name|m
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|r
operator|->
name|m
argument_list|,
name|s1
operator|->
name|m
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|m
operator|==
name|NULL
condition|)
name|clear
argument_list|(
operator|&
name|r
operator|->
name|m
index|[
name|x
index|]
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|r
operator|->
name|m
index|[
name|x
index|]
argument_list|,
name|s2
operator|->
name|m
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|r
operator|->
name|m
index|[
name|z
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n1
operator|>
literal|1
condition|)
name|s1
operator|=
name|s1
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|n2
operator|>
literal|1
condition|)
name|s2
operator|=
name|s2
operator|->
name|n
expr_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s2
operator|==
name|NULL
operator|||
operator|(
name|n1
operator|==
literal|1
operator|&&
name|n2
operator|==
literal|1
operator|)
condition|)
break|break;
block|}
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|extern
name|List
modifier|*
name|varsub
parameter_list|(
name|List
modifier|*
name|var
parameter_list|,
name|List
modifier|*
name|subs
parameter_list|)
block|{
name|List
modifier|*
name|r
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|int
name|n
init|=
name|listnel
argument_list|(
name|var
argument_list|)
decl_stmt|;
for|for
control|(
name|top
operator|=
name|r
operator|=
name|NULL
init|;
name|subs
operator|!=
name|NULL
condition|;
name|subs
operator|=
name|subs
operator|->
name|n
control|)
block|{
name|int
name|i
init|=
name|a2u
argument_list|(
name|subs
operator|->
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
name|rc_error
argument_list|(
literal|"bad subscript"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|n
condition|)
block|{
name|List
modifier|*
name|sub
init|=
name|var
decl_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
name|sub
operator|=
name|sub
operator|->
name|n
expr_stmt|;
comment|/* loop until sub == var(i) */
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
name|top
operator|=
name|r
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|sub
operator|->
name|w
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|sub
operator|->
name|m
expr_stmt|;
block|}
block|}
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|extern
name|List
modifier|*
name|flatten
parameter_list|(
name|List
modifier|*
name|s
parameter_list|)
block|{
name|List
modifier|*
name|r
decl_stmt|;
name|size_t
name|step
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|n
operator|==
name|NULL
condition|)
return|return
name|s
return|;
name|r
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|f
operator|=
name|r
operator|->
name|w
operator|=
name|nalloc
argument_list|(
name|listlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* flattened lists come from variables, so no meta */
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|f
argument_list|,
name|s
operator|->
name|w
argument_list|)
expr_stmt|;
name|f
operator|+=
name|strlen
argument_list|(
name|s
operator|->
name|w
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|f
operator|++
operator|=
literal|' '
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|n
expr_stmt|;
name|step
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|w
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|f
argument_list|,
name|s
operator|->
name|w
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|f
operator|+=
name|step
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|->
name|n
operator|!=
name|NULL
condition|)
do|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|List
modifier|*
name|count
parameter_list|(
name|List
modifier|*
name|l
parameter_list|)
block|{
name|List
modifier|*
name|s
init|=
name|nnew
argument_list|(
name|List
argument_list|)
decl_stmt|;
name|s
operator|->
name|w
operator|=
name|nprint
argument_list|(
literal|"%d"
argument_list|,
name|listnel
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|assign
parameter_list|(
name|List
modifier|*
name|s1
parameter_list|,
name|List
modifier|*
name|s2
parameter_list|,
name|bool
name|stack
parameter_list|)
block|{
name|List
modifier|*
name|val
init|=
name|s2
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"null variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s1
operator|->
name|n
operator|!=
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"multi-word variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|->
name|w
operator|==
literal|'\0'
condition|)
name|rc_error
argument_list|(
literal|"zero-length variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|a2u
argument_list|(
name|s1
operator|->
name|w
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|rc_error
argument_list|(
literal|"numeric variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|s1
operator|->
name|w
argument_list|,
literal|'='
argument_list|)
operator|!=
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"'=' in variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|->
name|w
operator|==
literal|'*'
operator|&&
name|s1
operator|->
name|w
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|val
operator|=
name|append
argument_list|(
name|varlookup
argument_list|(
literal|"0"
argument_list|)
argument_list|,
name|s2
argument_list|)
expr_stmt|;
comment|/* preserve $0 when * is assigned explicitly */
if|if
condition|(
name|s2
operator|!=
name|NULL
operator|||
name|stack
condition|)
block|{
if|if
condition|(
name|dashex
condition|)
name|prettyprint_var
argument_list|(
literal|2
argument_list|,
name|s1
operator|->
name|w
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|varassign
argument_list|(
name|s1
operator|->
name|w
argument_list|,
name|val
argument_list|,
name|stack
argument_list|)
expr_stmt|;
name|alias
argument_list|(
name|s1
operator|->
name|w
argument_list|,
name|varlookup
argument_list|(
name|s1
operator|->
name|w
argument_list|)
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dashex
condition|)
name|prettyprint_var
argument_list|(
literal|2
argument_list|,
name|s1
operator|->
name|w
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|varrm
argument_list|(
name|s1
operator|->
name|w
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    The following two functions are by the courtesy of Paul Haahr,    who could not stand the incompetence of my own backquote implementation. */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|((size_t) 1000)
end_define

begin_function
specifier|static
name|List
modifier|*
name|bqinput
parameter_list|(
name|List
modifier|*
name|ifs
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|bufend
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|List
modifier|*
name|r
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|size_t
name|remain
decl_stmt|,
name|bufsize
decl_stmt|;
name|char
name|isifs
index|[
literal|256
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|state
decl_stmt|;
comment|/* a simple FSA is used to read in data */
name|clear
argument_list|(
name|isifs
argument_list|,
sizeof|sizeof
name|isifs
argument_list|)
expr_stmt|;
for|for
control|(
name|isifs
index|[
literal|'\0'
index|]
operator|=
name|TRUE
init|;
name|ifs
operator|!=
name|NULL
condition|;
name|ifs
operator|=
name|ifs
operator|->
name|n
control|)
for|for
control|(
name|s
operator|=
name|ifs
operator|->
name|w
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
name|isifs
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
index|]
operator|=
name|TRUE
expr_stmt|;
name|remain
operator|=
name|bufsize
operator|=
name|BUFSIZE
expr_stmt|;
name|top
operator|=
name|r
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|end
operator|=
name|nalloc
argument_list|(
name|bufsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|remain
operator|==
literal|0
condition|)
block|{
comment|/* is the string bigger than the buffer? */
name|size_t
name|m
init|=
name|end
operator|-
name|r
operator|->
name|w
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
while|while
condition|(
name|bufsize
operator|<
name|m
operator|+
name|BUFSIZE
condition|)
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|nalloc
argument_list|(
name|bufsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|r
operator|->
name|w
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|buf
expr_stmt|;
name|end
operator|=
operator|&
name|buf
index|[
name|m
index|]
expr_stmt|;
name|remain
operator|=
name|bufsize
operator|-
name|m
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|rc_read
argument_list|(
name|fd
argument_list|,
name|end
argument_list|,
name|remain
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
comment|/* break */
break|break;
name|uerror
argument_list|(
literal|"backquote read"
argument_list|)
expr_stmt|;
name|rc_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|remain
operator|-=
name|n
expr_stmt|;
for|for
control|(
name|bufend
operator|=
operator|&
name|end
index|[
name|n
index|]
init|;
name|end
operator|<
name|bufend
condition|;
name|end
operator|++
control|)
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isifs
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|end
index|]
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|end
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isifs
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
name|end
index|]
condition|)
block|{
name|state
operator|=
literal|0
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|prev
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|state
operator|==
literal|1
condition|)
block|{
comment|/* terminate last string */
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
comment|/* no input at all? */
name|top
operator|=
name|NULL
expr_stmt|;
else|else
name|prev
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
comment|/* else terminate list */
block|}
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|static
name|List
modifier|*
name|backq
parameter_list|(
name|Node
modifier|*
name|ifs
parameter_list|,
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|,
name|pid
decl_stmt|,
name|sp
decl_stmt|;
name|List
modifier|*
name|bq
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|rc_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|rc_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mvfd
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|redirq
operator|=
name|NULL
expr_stmt|;
name|walk
argument_list|(
name|n
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bq
operator|=
name|bqinput
argument_list|(
name|glom
argument_list|(
name|ifs
argument_list|)
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|rc_wait4
argument_list|(
name|pid
argument_list|,
operator|&
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|statprint
argument_list|(
operator|-
literal|1
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|SIGCHK
expr_stmt|;
return|return
name|bq
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|qredir
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|Rq
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|redirq
operator|==
name|NULL
condition|)
block|{
name|next
operator|=
name|redirq
operator|=
name|nnew
argument_list|(
name|Rq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|next
operator|=
name|redirq
init|;
name|next
operator|->
name|n
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next
operator|->
name|n
control|)
empty_stmt|;
name|next
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|Rq
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|n
expr_stmt|;
block|}
name|next
operator|->
name|r
operator|=
name|n
expr_stmt|;
name|next
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|List
modifier|*
name|mkcmdarg
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|List
modifier|*
name|ret
init|=
name|nnew
argument_list|(
name|List
argument_list|)
decl_stmt|;
name|Estack
modifier|*
name|e
init|=
name|nnew
argument_list|(
name|Estack
argument_list|)
decl_stmt|;
name|Edata
name|efd
decl_stmt|;
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|rc_fork
argument_list|()
operator|==
literal|0
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvfd
argument_list|(
name|p
index|[
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
operator|==
name|rFrom
index|]
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
operator|==
name|rFrom
argument_list|)
operator|<
literal|0
condition|)
comment|/* stupid hack */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
operator|!=
name|rFrom
index|]
argument_list|)
expr_stmt|;
name|redirq
operator|=
name|NULL
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|nprint
argument_list|(
literal|"/dev/fd/%d"
argument_list|,
name|p
index|[
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
operator|!=
name|rFrom
index|]
argument_list|)
expr_stmt|;
name|efd
operator|.
name|fd
operator|=
name|p
index|[
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
operator|!=
name|rFrom
index|]
expr_stmt|;
name|except
argument_list|(
name|eFd
argument_list|,
name|efd
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
operator|==
name|rFrom
index|]
argument_list|)
expr_stmt|;
name|ret
operator|->
name|w
operator|=
name|name
expr_stmt|;
name|ret
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|extern
name|List
modifier|*
name|glom
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|List
modifier|*
name|v
decl_stmt|,
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|Node
modifier|*
name|words
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|nArgs
case|:
case|case
name|nLappend
case|:
name|words
operator|=
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|tail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|words
operator|!=
name|NULL
operator|&&
operator|(
name|words
operator|->
name|type
operator|==
name|nArgs
operator|||
name|words
operator|->
name|type
operator|==
name|nLappend
operator|)
condition|)
block|{
if|if
condition|(
name|words
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|!=
name|NULL
operator|&&
name|words
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|->
name|type
operator|!=
name|nWord
operator|&&
name|words
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|->
name|type
operator|!=
name|nQword
condition|)
break|break;
name|head
operator|=
name|glom
argument_list|(
name|words
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|head
operator|->
name|n
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|head
expr_stmt|;
block|}
name|words
operator|=
name|words
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
block|}
name|v
operator|=
name|append
argument_list|(
name|glom
argument_list|(
name|words
argument_list|)
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* force left to right evaluation */
return|return
name|append
argument_list|(
name|v
argument_list|,
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
argument_list|)
return|;
case|case
name|nBackq
case|:
return|return
name|backq
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
return|;
case|case
name|nConcat
case|:
name|head
operator|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
comment|/* force left-to-right evaluation */
return|return
name|concat
argument_list|(
name|head
argument_list|,
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
argument_list|)
return|;
case|case
name|nDup
case|:
case|case
name|nRedir
case|:
name|qredir
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
case|case
name|nWord
case|:
case|case
name|nQword
case|:
return|return
name|word
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|s
argument_list|)
return|;
case|case
name|nNmpipe
case|:
return|return
name|mkcmdarg
argument_list|(
name|n
argument_list|)
return|;
default|default:
comment|/* 		   The next four operations depend on the left-child of glom 		   to be a variable name. Therefore the variable is looked up 		   here. 		*/
if|if
condition|(
operator|(
name|v
operator|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"null variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|n
operator|!=
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"multi-word variable name"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|v
operator|->
name|w
operator|==
literal|'\0'
condition|)
name|rc_error
argument_list|(
literal|"zero-length variable name"
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
operator|*
name|v
operator|->
name|w
operator|==
literal|'*'
operator|&&
name|v
operator|->
name|w
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|varlookup
argument_list|(
name|v
operator|->
name|w
argument_list|)
operator|->
name|n
else|:
name|varlookup
argument_list|(
name|v
operator|->
name|w
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"unexpected node in glom"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|nCount
case|:
return|return
name|count
argument_list|(
name|v
argument_list|)
return|;
case|case
name|nFlat
case|:
return|return
name|flatten
argument_list|(
name|v
argument_list|)
return|;
case|case
name|nVar
case|:
return|return
name|v
return|;
case|case
name|nVarsub
case|:
return|return
name|varsub
argument_list|(
name|v
argument_list|,
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
end_function

end_unit

