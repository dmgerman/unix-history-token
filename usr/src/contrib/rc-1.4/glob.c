begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* glob.c: rc's (ugly) globber. This code is not elegant, but it works */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_function_decl
specifier|static
name|List
modifier|*
name|dmatch
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|List
modifier|*
name|doglob
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|List
modifier|*
name|lglob
parameter_list|(
name|List
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|List
modifier|*
name|sort
parameter_list|(
name|List
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*    Matches a list of words s against a list of patterns p. Returns true iff    a pattern in p matches a word in s. () matches (), but otherwise null    patterns match nothing. */
end_comment

begin_function
specifier|extern
name|bool
name|lmatch
parameter_list|(
name|List
modifier|*
name|s
parameter_list|,
name|List
modifier|*
name|p
parameter_list|)
block|{
name|List
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|okay
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* null matches null */
return|return
name|TRUE
return|;
for|for
control|(
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|n
control|)
block|{
comment|/* one or more stars match null */
if|if
condition|(
operator|*
name|p
operator|->
name|w
operator|!=
literal|'\0'
condition|)
block|{
comment|/* the null string is a special case; it does *not* match () */
name|okay
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|p
operator|->
name|w
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|w
index|[
name|i
index|]
operator|!=
literal|'*'
operator|||
name|p
operator|->
name|m
index|[
name|i
index|]
operator|!=
literal|1
condition|)
block|{
name|okay
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|okay
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
for|for
control|(
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|n
control|)
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|n
control|)
if|if
condition|(
name|match
argument_list|(
name|q
operator|->
name|w
argument_list|,
name|q
operator|->
name|m
argument_list|,
name|s
operator|->
name|w
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/*    Globs a list; checks to see if each element in the list has a metacharacter. If it    does, it is globbed, and the output is sorted. */
end_comment

begin_function
specifier|extern
name|List
modifier|*
name|glob
parameter_list|(
name|List
modifier|*
name|s
parameter_list|)
block|{
name|List
modifier|*
name|top
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|bool
name|meta
decl_stmt|;
for|for
control|(
name|r
operator|=
name|s
operator|,
name|meta
operator|=
name|FALSE
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|n
control|)
if|if
condition|(
name|r
operator|->
name|m
operator|!=
name|NULL
condition|)
name|meta
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|meta
condition|)
return|return
name|s
return|;
comment|/* don't copy lists with no metacharacters in them */
for|for
control|(
name|top
operator|=
name|r
operator|=
name|NULL
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|n
control|)
block|{
if|if
condition|(
name|s
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* no metacharacters; just tack on to the return list */
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
name|top
operator|=
name|r
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|s
operator|->
name|w
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
name|top
operator|=
name|r
operator|=
name|sort
argument_list|(
name|doglob
argument_list|(
name|s
operator|->
name|w
argument_list|,
name|s
operator|->
name|m
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|r
operator|->
name|n
operator|=
name|sort
argument_list|(
name|doglob
argument_list|(
name|s
operator|->
name|w
argument_list|,
name|s
operator|->
name|m
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|n
operator|!=
name|NULL
condition|)
name|r
operator|=
name|r
operator|->
name|n
expr_stmt|;
block|}
block|}
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* Matches a pattern p against the contents of directory d */
end_comment

begin_function
specifier|static
name|List
modifier|*
name|dmatch
parameter_list|(
name|char
modifier|*
name|d
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|m
parameter_list|)
block|{
name|bool
name|matched
init|=
name|FALSE
decl_stmt|;
name|List
modifier|*
name|top
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|static
name|DIR
modifier|*
name|dirp
decl_stmt|;
specifier|static
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|static
name|struct
name|stat
name|s
decl_stmt|;
comment|/* prototypes for XXXdir functions. comment out if necessary */
specifier|extern
name|DIR
modifier|*
name|opendir
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|extern
name|struct
name|dirent
modifier|*
name|readdir
argument_list|(
name|DIR
operator|*
argument_list|)
decl_stmt|;
comment|/*extern int closedir(DIR *);*/
name|top
operator|=
name|r
operator|=
name|NULL
expr_stmt|;
comment|/* opendir succeeds on regular files on some systems, so the stat() call is necessary (sigh) */
if|if
condition|(
name|stat
argument_list|(
name|d
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
operator|||
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|d
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
operator|*
name|dp
operator|->
name|d_name
operator|!=
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
operator|&&
name|match
argument_list|(
name|p
argument_list|,
name|m
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
comment|/* match ^. explicitly */
name|matched
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
name|top
operator|=
name|r
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|r
operator|->
name|w
operator|=
name|ncpy
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matched
condition|)
return|return
name|NULL
return|;
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/*    lglob() globs a pattern agains a list of directory roots. e.g., (/tmp /usr /bin) "*"    will return a list with all the files in /tmp, /usr, and /bin. NULL on no match.    slashcount indicates the number of slashes to stick between the directory and the    matched name. e.g., for matching ////tmp/////foo* */
end_comment

begin_function
specifier|static
name|List
modifier|*
name|lglob
parameter_list|(
name|List
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|m
parameter_list|,
name|size_t
name|slashcount
parameter_list|)
block|{
name|List
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|top
decl_stmt|,
name|foo
decl_stmt|;
specifier|static
name|List
name|slash
decl_stmt|;
specifier|static
name|size_t
name|slashsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|slashcount
operator|+
literal|1
operator|>
name|slashsize
condition|)
block|{
name|slash
operator|.
name|w
operator|=
name|ealloc
argument_list|(
name|slashcount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|slashsize
operator|=
name|slashcount
expr_stmt|;
block|}
name|slash
operator|.
name|w
index|[
name|slashcount
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|slashcount
operator|>
literal|0
condition|)
name|slash
operator|.
name|w
index|[
operator|--
name|slashcount
index|]
operator|=
literal|'/'
expr_stmt|;
for|for
control|(
name|top
operator|=
name|r
operator|=
name|NULL
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|n
control|)
block|{
name|q
operator|=
name|dmatch
argument_list|(
name|s
operator|->
name|w
argument_list|,
name|p
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|foo
operator|.
name|w
operator|=
name|s
operator|->
name|w
expr_stmt|;
name|foo
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|foo
operator|.
name|n
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|w
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s
operator|->
name|w
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
comment|/* need to separate */
name|q
operator|=
name|concat
argument_list|(
operator|&
name|slash
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* dir/name with slash */
name|q
operator|=
name|concat
argument_list|(
operator|&
name|foo
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|top
operator|=
name|r
operator|=
name|q
expr_stmt|;
else|else
name|r
operator|->
name|n
operator|=
name|q
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|n
operator|!=
name|NULL
condition|)
name|r
operator|=
name|r
operator|->
name|n
expr_stmt|;
block|}
block|}
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/*    Doglob globs a pathname in pattern form against a unix path. Returns the original    pattern (cleaned of metacharacters) on failure, or the globbed string(s). */
end_comment

begin_function
specifier|static
name|List
modifier|*
name|doglob
parameter_list|(
name|char
modifier|*
name|w
parameter_list|,
name|char
modifier|*
name|m
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|dir
init|=
name|NULL
decl_stmt|,
modifier|*
name|pattern
init|=
name|NULL
decl_stmt|,
modifier|*
name|metadir
init|=
name|NULL
decl_stmt|,
modifier|*
name|metapattern
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|dsize
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|w
decl_stmt|;
name|List
name|firstdir
decl_stmt|;
name|List
modifier|*
name|matched
decl_stmt|;
if|if
condition|(
operator|(
name|psize
operator|=
name|strlen
argument_list|(
name|w
argument_list|)
operator|+
literal|1
operator|)
operator|>
name|dsize
operator|||
name|dir
operator|==
name|NULL
condition|)
block|{
name|efree
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|metadir
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|metapattern
argument_list|)
expr_stmt|;
name|dir
operator|=
name|ealloc
argument_list|(
name|psize
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|ealloc
argument_list|(
name|psize
argument_list|)
expr_stmt|;
name|metadir
operator|=
name|ealloc
argument_list|(
name|psize
argument_list|)
expr_stmt|;
name|metapattern
operator|=
name|ealloc
argument_list|(
name|psize
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|psize
expr_stmt|;
block|}
name|d
operator|=
name|dir
expr_stmt|;
name|p
operator|=
name|pattern
expr_stmt|;
name|md
operator|=
name|metadir
expr_stmt|;
name|mp
operator|=
name|metapattern
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
while|while
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|,
operator|*
name|md
operator|++
operator|=
operator|*
name|m
operator|++
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|,
operator|*
name|md
operator|++
operator|=
operator|*
name|m
operator|++
expr_stmt|;
comment|/* get first directory component */
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	   Special case: no slashes in the pattern, i.e., open the current directory. 	   Remember that w cannot consist of slashes alone (the other way *s could be 	   zero) since doglob gets called iff there's a metacharacter to be matched 	*/
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|matched
operator|=
name|dmatch
argument_list|(
literal|"."
argument_list|,
name|dir
argument_list|,
name|metadir
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
operator|*
name|w
operator|==
literal|'/'
condition|)
block|{
name|firstdir
operator|.
name|w
operator|=
name|dir
expr_stmt|;
name|firstdir
operator|.
name|m
operator|=
name|metadir
expr_stmt|;
name|firstdir
operator|.
name|n
operator|=
name|NULL
expr_stmt|;
name|matched
operator|=
operator|&
name|firstdir
expr_stmt|;
block|}
else|else
block|{
comment|/* 		   we must glob against current directory, 		   since the first character is not a slash. 		*/
name|matched
operator|=
name|dmatch
argument_list|(
literal|"."
argument_list|,
name|dir
argument_list|,
name|metadir
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|size_t
name|slashcount
decl_stmt|;
name|SIGCHK
expr_stmt|;
for|for
control|(
name|slashcount
operator|=
literal|0
init|;
operator|*
name|s
operator|==
literal|'/'
condition|;
name|s
operator|++
operator|,
name|m
operator|++
control|)
name|slashcount
operator|++
expr_stmt|;
comment|/* skip slashes */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
operator|,
operator|*
name|mp
operator|++
operator|=
operator|*
name|m
operator|++
expr_stmt|;
comment|/* get pattern */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|matched
operator|=
name|lglob
argument_list|(
name|matched
argument_list|,
name|pattern
argument_list|,
name|metapattern
argument_list|,
name|slashcount
argument_list|)
expr_stmt|;
name|p
operator|=
name|pattern
operator|,
name|mp
operator|=
name|metapattern
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
do|;
name|end
label|:
if|if
condition|(
name|matched
operator|==
name|NULL
condition|)
block|{
name|matched
operator|=
name|nnew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|matched
operator|->
name|w
operator|=
name|w
expr_stmt|;
name|matched
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|matched
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|matched
return|;
block|}
end_function

begin_function
specifier|static
name|List
modifier|*
name|sort
parameter_list|(
name|List
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|nel
init|=
name|listnel
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|nel
operator|>
literal|1
condition|)
block|{
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|List
modifier|*
name|t
decl_stmt|;
name|qsort
argument_list|(
name|a
operator|=
name|list2array
argument_list|(
name|s
argument_list|,
name|FALSE
argument_list|)
argument_list|,
name|nel
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|starstrcmp
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|n
control|)
name|t
operator|->
name|w
operator|=
operator|*
name|a
operator|++
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

end_unit

