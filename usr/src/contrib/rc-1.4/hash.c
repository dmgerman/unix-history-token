begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c: hash table support for functions and variables. */
end_comment

begin_comment
comment|/*    Functions and variables are cached in both internal and external    form for performance. Thus a variable which is never "dereferenced"    with a $ is passed on to rc's children untouched. This is not so    important for variables, but is a big win for functions, where a call    to yyparse() is involved. */
end_comment

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"sigmsgs.h"
end_include

begin_function_decl
specifier|static
name|bool
name|var_exportable
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|fn_exportable
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hash
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find
parameter_list|(
name|char
modifier|*
parameter_list|,
name|Htab
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_fn
parameter_list|(
name|Function
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|Htab
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Htab
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fused
decl_stmt|,
name|fsize
decl_stmt|,
name|vused
decl_stmt|,
name|vsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bozosize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|envsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|env_dirty
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dead
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASHSIZE
value|64
end_define

begin_comment
comment|/* rc was debugged with HASHSIZE == 2; 64 is about right for normal use */
end_comment

begin_function
specifier|extern
name|void
name|inithash
parameter_list|()
block|{
name|Htab
modifier|*
name|fpp
decl_stmt|,
modifier|*
name|vpp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fp
operator|=
name|ealloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Htab
argument_list|)
operator|*
name|HASHSIZE
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ealloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Htab
argument_list|)
operator|*
name|HASHSIZE
argument_list|)
expr_stmt|;
name|fused
operator|=
name|vused
operator|=
literal|0
expr_stmt|;
name|fsize
operator|=
name|vsize
operator|=
name|HASHSIZE
expr_stmt|;
for|for
control|(
name|vpp
operator|=
name|vp
operator|,
name|fpp
operator|=
name|fp
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
operator|,
name|vpp
operator|++
operator|,
name|fpp
operator|++
control|)
name|vpp
operator|->
name|name
operator|=
name|fpp
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ADV
parameter_list|()
value|{if ((c = *s++) == '\0') break;}
end_define

begin_comment
comment|/* hash function courtesy of paul haahr */
end_comment

begin_function
specifier|static
name|int
name|hash
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ADV
argument_list|()
expr_stmt|;
name|n
operator|+=
operator|(
name|c
operator|<<
literal|17
operator|)
operator|^
operator|(
name|c
operator|<<
literal|11
operator|)
operator|^
operator|(
name|c
operator|<<
literal|5
operator|)
operator|^
operator|(
name|c
operator|>>
literal|1
operator|)
expr_stmt|;
name|ADV
argument_list|()
expr_stmt|;
name|n
operator|^=
operator|(
name|c
operator|<<
literal|14
operator|)
operator|+
operator|(
name|c
operator|<<
literal|7
operator|)
operator|+
operator|(
name|c
operator|<<
literal|4
operator|)
operator|+
name|c
expr_stmt|;
name|ADV
argument_list|()
expr_stmt|;
name|n
operator|^=
operator|(
operator|~
name|c
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
name|c
operator|<<
literal|3
operator|)
operator|^
operator|(
name|c
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
name|ADV
argument_list|()
expr_stmt|;
name|n
operator|-=
operator|(
name|c
operator|<<
literal|16
operator|)
operator||
operator|(
name|c
operator|<<
literal|9
operator|)
operator||
operator|(
name|c
operator|<<
literal|2
operator|)
operator||
operator|(
name|c
operator|&
literal|3
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
operator|~
name|n
expr_stmt|;
return|return
name|n
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
return|;
comment|/* need power of 2 size */
block|}
end_function

begin_function
specifier|static
name|bool
name|rehash
parameter_list|(
name|Htab
modifier|*
name|ht
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|size
decl_stmt|;
name|int
name|newsize
decl_stmt|,
name|newused
decl_stmt|;
name|Htab
modifier|*
name|newhtab
decl_stmt|;
if|if
condition|(
name|ht
operator|==
name|fp
condition|)
block|{
if|if
condition|(
name|fsize
operator|>
literal|2
operator|*
name|fused
condition|)
return|return
name|FALSE
return|;
name|size
operator|=
name|fsize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsize
operator|>
literal|2
operator|*
name|vused
condition|)
return|return
name|FALSE
return|;
name|size
operator|=
name|vsize
expr_stmt|;
block|}
name|newsize
operator|=
literal|2
operator|*
name|size
expr_stmt|;
name|newhtab
operator|=
name|ealloc
argument_list|(
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|Htab
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newsize
condition|;
name|i
operator|++
control|)
name|newhtab
index|[
name|i
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newused
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ht
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|ht
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|dead
condition|)
block|{
name|newused
operator|++
expr_stmt|;
name|j
operator|=
name|hash
argument_list|(
name|ht
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
while|while
condition|(
name|newhtab
index|[
name|j
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|j
operator|&=
operator|(
name|newsize
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|newhtab
index|[
name|j
index|]
operator|.
name|name
operator|=
name|ht
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|newhtab
index|[
name|j
index|]
operator|.
name|p
operator|=
name|ht
index|[
name|i
index|]
operator|.
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ht
operator|==
name|fp
condition|)
block|{
name|fused
operator|=
name|newused
expr_stmt|;
name|fp
operator|=
name|newhtab
expr_stmt|;
name|fsize
operator|=
name|newsize
expr_stmt|;
block|}
else|else
block|{
name|vused
operator|=
name|newused
expr_stmt|;
name|vp
operator|=
name|newhtab
expr_stmt|;
name|vsize
operator|=
name|newsize
expr_stmt|;
block|}
name|efree
argument_list|(
name|ht
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|varfind
parameter_list|(
name|s
parameter_list|)
value|find(s, vp, vsize)
end_define

begin_define
define|#
directive|define
name|fnfind
parameter_list|(
name|s
parameter_list|)
value|find(s, fp, fsize)
end_define

begin_function
specifier|static
name|int
name|find
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|Htab
modifier|*
name|ht
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|h
init|=
name|hash
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
while|while
condition|(
name|ht
index|[
name|h
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|streq
argument_list|(
name|ht
index|[
name|h
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|h
operator|++
expr_stmt|;
name|h
operator|&=
name|size
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
end_function

begin_function
specifier|extern
name|void
modifier|*
name|lookup
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|Htab
modifier|*
name|ht
parameter_list|)
block|{
name|int
name|h
init|=
name|find
argument_list|(
name|s
argument_list|,
name|ht
argument_list|,
name|ht
operator|==
name|fp
condition|?
name|fsize
else|:
name|vsize
argument_list|)
decl_stmt|;
return|return
operator|(
name|ht
index|[
name|h
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|ht
index|[
name|h
index|]
operator|.
name|p
return|;
block|}
end_function

begin_function
specifier|extern
name|Function
modifier|*
name|get_fn_place
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|h
init|=
name|fnfind
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|env_dirty
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|fp
index|[
name|h
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rehash
argument_list|(
name|fp
argument_list|)
condition|)
name|h
operator|=
name|fnfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fused
operator|++
expr_stmt|;
name|fp
index|[
name|h
index|]
operator|.
name|name
operator|=
name|ecpy
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fp
index|[
name|h
index|]
operator|.
name|p
operator|=
name|enew
argument_list|(
name|Function
argument_list|)
expr_stmt|;
block|}
else|else
name|free_fn
argument_list|(
name|fp
index|[
name|h
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
return|return
name|fp
index|[
name|h
index|]
operator|.
name|p
return|;
block|}
end_function

begin_function
specifier|extern
name|Variable
modifier|*
name|get_var_place
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|bool
name|stack
parameter_list|)
block|{
name|Variable
modifier|*
name|new
decl_stmt|;
name|int
name|h
init|=
name|varfind
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|env_dirty
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|vp
index|[
name|h
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rehash
argument_list|(
name|vp
argument_list|)
condition|)
name|h
operator|=
name|varfind
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vused
operator|++
expr_stmt|;
name|vp
index|[
name|h
index|]
operator|.
name|name
operator|=
name|ecpy
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vp
index|[
name|h
index|]
operator|.
name|p
operator|=
name|enew
argument_list|(
name|Variable
argument_list|)
expr_stmt|;
operator|(
operator|(
name|Variable
operator|*
operator|)
name|vp
index|[
name|h
index|]
operator|.
name|p
operator|)
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
return|return
name|vp
index|[
name|h
index|]
operator|.
name|p
return|;
block|}
else|else
block|{
if|if
condition|(
name|stack
condition|)
block|{
comment|/* increase the stack by 1 */
name|new
operator|=
name|enew
argument_list|(
name|Variable
argument_list|)
expr_stmt|;
name|new
operator|->
name|n
operator|=
name|vp
index|[
name|h
index|]
operator|.
name|p
expr_stmt|;
return|return
name|vp
index|[
name|h
index|]
operator|.
name|p
operator|=
name|new
return|;
block|}
else|else
block|{
comment|/* trample the top of the stack */
name|new
operator|=
name|vp
index|[
name|h
index|]
operator|.
name|p
expr_stmt|;
name|efree
argument_list|(
name|new
operator|->
name|extdef
argument_list|)
expr_stmt|;
name|listfree
argument_list|(
name|new
operator|->
name|def
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|extern
name|void
name|delete_fn
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|h
init|=
name|fnfind
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
index|[
name|h
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return;
comment|/* not found */
name|env_dirty
operator|=
name|TRUE
expr_stmt|;
name|free_fn
argument_list|(
name|fp
index|[
name|h
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|fp
index|[
name|h
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|fp
index|[
name|h
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
index|[
operator|(
name|h
operator|+
literal|1
operator|)
operator|&
operator|(
name|fsize
operator|-
literal|1
operator|)
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
operator|--
name|fused
expr_stmt|;
name|fp
index|[
name|h
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|fp
index|[
name|h
index|]
operator|.
name|name
operator|=
name|dead
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|extern
name|void
name|delete_var
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|bool
name|stack
parameter_list|)
block|{
name|int
name|h
init|=
name|varfind
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|Variable
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|vp
index|[
name|h
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return;
comment|/* not found */
name|env_dirty
operator|=
name|TRUE
expr_stmt|;
name|v
operator|=
name|vp
index|[
name|h
index|]
operator|.
name|p
expr_stmt|;
name|efree
argument_list|(
name|v
operator|->
name|extdef
argument_list|)
expr_stmt|;
name|listfree
argument_list|(
name|v
operator|->
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|n
operator|!=
name|NULL
condition|)
block|{
comment|/* This is the top of a stack */
if|if
condition|(
name|stack
condition|)
block|{
comment|/* pop */
name|vp
index|[
name|h
index|]
operator|.
name|p
operator|=
name|v
operator|->
name|n
expr_stmt|;
name|efree
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* else just empty */
name|v
operator|->
name|extdef
operator|=
name|NULL
expr_stmt|;
name|v
operator|->
name|def
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* needs to be removed from the hash table */
name|efree
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|vp
index|[
name|h
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
index|[
operator|(
name|h
operator|+
literal|1
operator|)
operator|&
operator|(
name|vsize
operator|-
literal|1
operator|)
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
operator|--
name|vused
expr_stmt|;
name|vp
index|[
name|h
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|vp
index|[
name|h
index|]
operator|.
name|name
operator|=
name|dead
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_fn
parameter_list|(
name|Function
modifier|*
name|f
parameter_list|)
block|{
name|treefree
argument_list|(
name|f
operator|->
name|def
argument_list|)
expr_stmt|;
name|efree
argument_list|(
name|f
operator|->
name|extdef
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|extern
name|void
name|initenv
parameter_list|(
name|char
modifier|*
modifier|*
name|envp
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|envp
index|[
name|n
index|]
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
empty_stmt|;
name|n
operator|++
expr_stmt|;
comment|/* one for the null terminator */
if|if
condition|(
name|n
operator|<
name|HASHSIZE
condition|)
name|n
operator|=
name|HASHSIZE
expr_stmt|;
name|env
operator|=
name|ealloc
argument_list|(
operator|(
name|envsize
operator|=
literal|2
operator|*
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|envp
operator|!=
name|NULL
condition|;
name|envp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|envp
argument_list|,
literal|"fn_"
argument_list|,
name|conststrlen
argument_list|(
literal|"fn_"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dashpee
condition|)
name|fnassign_string
argument_list|(
operator|*
name|envp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|varassign_string
argument_list|(
operator|*
name|envp
argument_list|)
condition|)
comment|/* add to bozo env */
name|env
index|[
name|bozosize
operator|++
index|]
operator|=
operator|*
name|envp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|var_exportable
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|notforexport
index|[]
init|=
block|{
literal|"apid"
block|,
literal|"pid"
block|,
literal|"apids"
block|,
literal|"*"
block|,
literal|"ifs"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arraysize
argument_list|(
name|notforexport
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|s
argument_list|,
name|notforexport
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|fn_exportable
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"sig"
argument_list|,
name|conststrlen
argument_list|(
literal|"sig"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* small speed hack */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMOFSIGNALS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|s
argument_list|,
name|signals
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|streq
argument_list|(
name|s
argument_list|,
literal|"sigexit"
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|extern
name|char
modifier|*
modifier|*
name|makeenv
parameter_list|()
block|{
name|int
name|ep
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|env_dirty
condition|)
return|return
name|env
return|;
name|env_dirty
operator|=
name|FALSE
expr_stmt|;
name|ep
operator|=
name|bozosize
expr_stmt|;
if|if
condition|(
name|vsize
operator|+
name|fsize
operator|+
literal|1
operator|+
name|bozosize
operator|>
name|envsize
condition|)
block|{
name|envsize
operator|=
literal|2
operator|*
operator|(
name|bozosize
operator|+
name|vsize
operator|+
name|fsize
operator|+
literal|1
operator|)
expr_stmt|;
name|env
operator|=
name|erealloc
argument_list|(
name|env
argument_list|,
name|envsize
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vp
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|||
name|vp
index|[
name|i
index|]
operator|.
name|name
operator|==
name|dead
operator|||
operator|!
name|var_exportable
argument_list|(
name|vp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
continue|continue;
name|v
operator|=
name|varlookup_string
argument_list|(
name|vp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
name|env
index|[
name|ep
operator|++
index|]
operator|=
name|v
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|||
name|fp
index|[
name|i
index|]
operator|.
name|name
operator|==
name|dead
operator|||
operator|!
name|fn_exportable
argument_list|(
name|fp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
continue|continue;
name|env
index|[
name|ep
operator|++
index|]
operator|=
name|fnlookup_string
argument_list|(
name|fp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|env
index|[
name|ep
index|]
operator|=
name|NULL
expr_stmt|;
name|qsort
argument_list|(
name|env
argument_list|,
operator|(
name|size_t
operator|)
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|starstrcmp
argument_list|)
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_function
specifier|extern
name|void
name|whatare_all_vars
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|List
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vp
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|=
name|varlookup
argument_list|(
name|vp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|prettyprint_var
argument_list|(
literal|1
argument_list|,
name|vp
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fsize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fp
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|fp
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|dead
condition|)
name|prettyprint_fn
argument_list|(
literal|1
argument_list|,
name|fp
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|fnlookup
argument_list|(
name|fp
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

