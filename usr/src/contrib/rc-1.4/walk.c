begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* walk.c: walks the parse tree. */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_include
include|#
directive|include
file|"jbwrap.h"
end_include

begin_comment
comment|/*    global which indicates whether rc is executing a test;    used by rc -e so that if (false) does not exit. */
end_comment

begin_decl_stmt
name|bool
name|cond
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|isallpre
parameter_list|(
name|Node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|dofork
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dopipe
parameter_list|(
name|Node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tail-recursive version of walk() */
end_comment

begin_define
define|#
directive|define
name|WALK
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|{ n = x; parent = y; goto top; }
end_define

begin_comment
comment|/* walk the parse-tree. "obvious". */
end_comment

begin_function
specifier|extern
name|bool
name|walk
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|,
name|bool
name|parent
parameter_list|)
block|{
name|top
label|:
name|SIGCHK
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|parent
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|nArgs
case|:
case|case
name|nBackq
case|:
case|case
name|nConcat
case|:
case|case
name|nCount
case|:
case|case
name|nFlat
case|:
case|case
name|nLappend
case|:
case|case
name|nRedir
case|:
case|case
name|nVar
case|:
case|case
name|nVarsub
case|:
case|case
name|nWord
case|:
case|case
name|nQword
case|:
name|exec
argument_list|(
name|glob
argument_list|(
name|glom
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|/* simple command */
break|break;
case|case
name|nBody
case|:
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|WALK
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|/* WALK doesn't fall through */
case|case
name|nNowait
case|:
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|rc_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|rc_signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Berkeleyized version: put it in a new pgroup. */
name|rc_signal
argument_list|(
name|SIGTTIN
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|rc_signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|mvfd
argument_list|(
name|rc_open
argument_list|(
literal|"/dev/null"
argument_list|,
name|rFrom
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|interactive
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|varassign
argument_list|(
literal|"apid"
argument_list|,
name|word
argument_list|(
name|nprint
argument_list|(
literal|"%d"
argument_list|,
name|pid
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|redirq
operator|=
name|NULL
expr_stmt|;
comment|/* kill pre-redir queue */
break|break;
block|}
case|case
name|nAndalso
case|:
block|{
name|bool
name|oldcond
init|=
name|cond
decl_stmt|;
name|cond
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|cond
operator|=
name|oldcond
expr_stmt|;
name|WALK
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|oldcond
expr_stmt|;
break|break;
block|}
case|case
name|nOrelse
case|:
block|{
name|bool
name|oldcond
init|=
name|cond
decl_stmt|;
name|cond
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|cond
operator|=
name|oldcond
expr_stmt|;
name|WALK
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|oldcond
expr_stmt|;
break|break;
block|}
case|case
name|nBang
case|:
name|set
argument_list|(
operator|!
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|nIf
case|:
block|{
name|bool
name|oldcond
init|=
name|cond
decl_stmt|;
name|Node
modifier|*
name|true_cmd
init|=
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
decl_stmt|,
modifier|*
name|false_cmd
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|true_cmd
operator|!=
name|NULL
operator|&&
name|true_cmd
operator|->
name|type
operator|==
name|nElse
condition|)
block|{
name|false_cmd
operator|=
name|true_cmd
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
name|true_cmd
operator|=
name|true_cmd
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
block|}
name|cond
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
condition|)
name|true_cmd
operator|=
name|false_cmd
expr_stmt|;
comment|/* run the else clause */
name|cond
operator|=
name|oldcond
expr_stmt|;
name|WALK
argument_list|(
name|true_cmd
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
case|case
name|nWhile
case|:
block|{
name|Jbwrap
name|j
decl_stmt|;
name|Edata
name|jbreak
decl_stmt|;
name|Estack
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|bool
name|testtrue
decl_stmt|,
name|oldcond
init|=
name|cond
decl_stmt|;
name|cond
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* prevent spurious breaks inside test */
name|cond
operator|=
name|oldcond
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|j
operator|.
name|j
argument_list|)
condition|)
break|break;
name|jbreak
operator|.
name|jb
operator|=
operator|&
name|j
expr_stmt|;
name|except
argument_list|(
name|eBreak
argument_list|,
name|jbreak
argument_list|,
operator|&
name|e1
argument_list|)
expr_stmt|;
do|do
block|{
name|Edata
name|block
decl_stmt|;
name|block
operator|.
name|b
operator|=
name|newblock
argument_list|()
expr_stmt|;
name|cond
operator|=
name|oldcond
expr_stmt|;
name|except
argument_list|(
name|eArena
argument_list|,
name|block
argument_list|,
operator|&
name|e2
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|testtrue
operator|=
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eArena */
name|cond
operator|=
name|TRUE
expr_stmt|;
block|}
do|while
condition|(
name|testtrue
condition|)
do|;
name|cond
operator|=
name|oldcond
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eBreak */
break|break;
block|}
case|case
name|nForin
case|:
block|{
name|List
modifier|*
name|l
decl_stmt|,
modifier|*
name|var
init|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
decl_stmt|;
name|Jbwrap
name|j
decl_stmt|;
name|Estack
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|Edata
name|jbreak
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|j
operator|.
name|j
argument_list|)
condition|)
break|break;
name|jbreak
operator|.
name|jb
operator|=
operator|&
name|j
expr_stmt|;
name|except
argument_list|(
name|eBreak
argument_list|,
name|jbreak
argument_list|,
operator|&
name|e1
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|listcpy
argument_list|(
name|glob
argument_list|(
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
argument_list|)
argument_list|,
name|nalloc
argument_list|)
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|n
control|)
block|{
name|Edata
name|block
decl_stmt|;
name|assign
argument_list|(
name|var
argument_list|,
name|word
argument_list|(
name|l
operator|->
name|w
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|block
operator|.
name|b
operator|=
name|newblock
argument_list|()
expr_stmt|;
name|except
argument_list|(
name|eArena
argument_list|,
name|block
argument_list|,
operator|&
name|e2
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eArena */
block|}
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eBreak */
break|break;
block|}
case|case
name|nSubshell
case|:
if|if
condition|(
name|dofork
argument_list|(
name|TRUE
argument_list|)
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|rc_exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|nAssign
case|:
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|==
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"null variable name"
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
argument_list|,
name|glob
argument_list|(
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|nPipe
case|:
name|dopipe
argument_list|(
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|nNewfn
case|:
block|{
name|List
modifier|*
name|l
init|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
name|rc_error
argument_list|(
literal|"null function name"
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dashex
condition|)
name|prettyprint_fn
argument_list|(
literal|2
argument_list|,
name|l
operator|->
name|w
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|fnassign
argument_list|(
name|l
operator|->
name|w
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|n
expr_stmt|;
block|}
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nRmfn
case|:
block|{
name|List
modifier|*
name|l
init|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
decl_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dashex
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"fn %S\n"
argument_list|,
name|l
operator|->
name|w
argument_list|)
expr_stmt|;
name|fnrm
argument_list|(
name|l
operator|->
name|w
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|n
expr_stmt|;
block|}
name|set
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nDup
case|:
name|redirq
operator|=
name|NULL
expr_stmt|;
break|break;
comment|/* Null command */
case|case
name|nMatch
case|:
block|{
name|List
modifier|*
name|a
init|=
name|glob
argument_list|(
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
argument_list|)
decl_stmt|,
modifier|*
name|b
init|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|dashex
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
operator|(
name|a
operator|!=
name|NULL
operator|&&
name|a
operator|->
name|n
operator|!=
name|NULL
operator|)
condition|?
literal|"~ (%L) %L\n"
else|:
literal|"~ %L %L\n"
argument_list|,
name|a
argument_list|,
literal|" "
argument_list|,
name|b
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|lmatch
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nSwitch
case|:
block|{
name|List
modifier|*
name|v
init|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
do|do
block|{
name|n
operator|=
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|istrue
argument_list|()
return|;
block|}
do|while
condition|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|==
name|NULL
operator|||
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|type
operator|!=
name|nCase
condition|)
do|;
if|if
condition|(
name|lmatch
argument_list|(
name|v
argument_list|,
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|n
operator|=
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
init|;
name|n
operator|!=
name|NULL
operator|&&
operator|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|==
name|NULL
operator|||
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|type
operator|!=
name|nCase
operator|)
condition|;
name|n
operator|=
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
control|)
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|nPre
case|:
block|{
name|List
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|type
operator|==
name|nRedir
operator|||
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|type
operator|==
name|nDup
condition|)
block|{
name|qredir
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|type
operator|==
name|nAssign
condition|)
block|{
if|if
condition|(
name|isallpre
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
condition|)
block|{
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|WALK
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Estack
name|e
decl_stmt|;
name|Edata
name|var
decl_stmt|;
name|v
operator|=
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
name|assign
argument_list|(
name|v
argument_list|,
name|glob
argument_list|(
name|glom
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|var
operator|.
name|name
operator|=
name|v
operator|->
name|w
expr_stmt|;
name|except
argument_list|(
name|eVarstack
argument_list|,
name|var
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|varrm
argument_list|(
name|v
operator|->
name|w
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|unexcept
argument_list|()
expr_stmt|;
comment|/* eVarstack */
block|}
block|}
else|else
name|panic
argument_list|(
literal|"unexpected node in preredir section of walk"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nBrace
case|:
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|==
name|NULL
condition|)
block|{
name|WALK
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dofork
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Do redirections */
name|redirq
operator|=
name|NULL
expr_stmt|;
comment|/* Reset redirection queue */
name|walk
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Do commands */
name|rc_exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
break|break;
case|case
name|nEpilog
case|:
name|qredir
argument_list|(
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|!=
name|NULL
condition|)
block|{
name|WALK
argument_list|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|parent
argument_list|)
expr_stmt|;
comment|/* Do more redirections. */
block|}
else|else
block|{
name|doredirs
argument_list|()
expr_stmt|;
comment|/* Okay, we hit the bottom. */
block|}
break|break;
case|case
name|nNmpipe
case|:
name|rc_error
argument_list|(
literal|"named pipes cannot be executed as commands"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
name|panic
argument_list|(
literal|"unknown node in walk"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
name|istrue
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* checks to see whether a subtree is all pre-command directives, i.e., assignments and redirs only */
end_comment

begin_function
specifier|static
name|bool
name|isallpre
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|type
operator|==
name|nPre
condition|)
name|n
operator|=
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
expr_stmt|;
return|return
name|n
operator|==
name|NULL
operator|||
name|n
operator|->
name|type
operator|==
name|nRedir
operator|||
name|n
operator|->
name|type
operator|==
name|nAssign
operator|||
name|n
operator|->
name|type
operator|==
name|nDup
return|;
block|}
end_function

begin_comment
comment|/*    A code-saver. Forks, child returns (for further processing in walk()), and the parent    waits for the child to finish, setting $status appropriately. */
end_comment

begin_function
specifier|static
name|bool
name|dofork
parameter_list|(
name|bool
name|parent
parameter_list|)
block|{
name|int
name|pid
decl_stmt|,
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|||
operator|(
name|pid
operator|=
name|rc_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|redirq
operator|=
name|NULL
expr_stmt|;
comment|/* clear out the pre-redirection queue in the parent */
name|rc_wait4
argument_list|(
name|pid
argument_list|,
operator|&
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|setstatus
argument_list|(
operator|-
literal|1
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|SIGCHK
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dopipe
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sp
decl_stmt|,
name|pid
decl_stmt|,
name|fd_prev
decl_stmt|,
name|fd_out
decl_stmt|,
name|pids
index|[
literal|512
index|]
decl_stmt|,
name|stats
index|[
literal|512
index|]
decl_stmt|,
name|p
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|intr
decl_stmt|;
name|Node
modifier|*
name|r
decl_stmt|;
name|fd_prev
operator|=
name|fd_out
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|r
operator|=
name|n
operator|,
name|i
operator|=
literal|0
init|;
name|r
operator|!=
name|NULL
operator|&&
name|r
operator|->
name|type
operator|==
name|nPipe
condition|;
name|r
operator|=
name|r
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|500
condition|)
comment|/* the only hard-wired limit in rc? */
name|rc_error
argument_list|(
literal|"pipe too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|uerror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|rc_error
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|rc_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|redirq
operator|=
name|NULL
expr_stmt|;
comment|/* clear preredir queue */
name|mvfd
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|r
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_prev
operator|!=
literal|1
condition|)
name|mvfd
argument_list|(
name|fd_prev
argument_list|,
name|fd_out
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|r
operator|->
name|u
index|[
literal|3
index|]
operator|.
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd_prev
operator|!=
literal|1
condition|)
name|close
argument_list|(
name|fd_prev
argument_list|)
expr_stmt|;
comment|/* parent must close all pipe fd's */
name|pids
index|[
name|i
index|]
operator|=
name|pid
expr_stmt|;
name|fd_prev
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|fd_out
operator|=
name|r
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|rc_fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|setsigdefaults
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mvfd
argument_list|(
name|fd_prev
argument_list|,
name|fd_out
argument_list|)
expr_stmt|;
name|walk
argument_list|(
name|r
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|getstatus
argument_list|()
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|redirq
operator|=
name|NULL
expr_stmt|;
comment|/* clear preredir queue */
name|close
argument_list|(
name|fd_prev
argument_list|)
expr_stmt|;
name|pids
index|[
name|i
operator|++
index|]
operator|=
name|pid
expr_stmt|;
comment|/* collect statuses */
name|intr
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|rc_wait4
argument_list|(
name|pids
index|[
name|j
index|]
argument_list|,
operator|&
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stats
index|[
name|j
index|]
operator|=
name|sp
expr_stmt|;
name|intr
operator||=
operator|(
name|sp
operator|==
name|SIGINT
operator|)
expr_stmt|;
block|}
name|setpipestatus
argument_list|(
name|stats
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SIGCHK
expr_stmt|;
block|}
end_function

end_unit

