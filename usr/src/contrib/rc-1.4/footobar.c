begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    footobar.c: a collection of functions to convert internal representations of    variables and functions to external representations, and vice versa */
end_comment

begin_include
include|#
directive|include
file|"rc.h"
end_include

begin_define
define|#
directive|define
name|FSCHAR
value|'\1'
end_define

begin_define
define|#
directive|define
name|FSSTRING
value|"\1"
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|getenvw
parameter_list|(
name|char
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|bool
name|Fconv
parameter_list|(
name|Format
modifier|*
name|f
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
comment|/* protect an exported name from brain-dead shells */
name|int
name|c
decl_stmt|;
name|unsigned
specifier|const
name|char
modifier|*
name|s
init|=
name|va_arg
argument_list|(
name|f
operator|->
name|args
argument_list|,
name|unsigned
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|dnw
index|[
name|c
index|]
operator|||
name|c
operator|==
literal|'*'
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|&&
operator|*
name|s
operator|==
literal|'_'
operator|)
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"__%02x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fmtputc
argument_list|(
name|f
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* used to turn a function in Node * form into something we can export to the environment */
end_comment

begin_function
specifier|extern
name|char
modifier|*
name|fun2str
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|Node
modifier|*
name|n
parameter_list|)
block|{
return|return
name|mprint
argument_list|(
literal|"fn_%F={%T}"
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* convert a redirection to a printable form */
end_comment

begin_function
specifier|static
name|bool
name|Dconv
parameter_list|(
name|Format
modifier|*
name|f
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"?"
decl_stmt|;
name|int
name|n
init|=
name|va_arg
argument_list|(
name|f
operator|->
name|args
argument_list|,
name|int
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|rCreate
case|:
name|name
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|rAppend
case|:
name|name
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|rFrom
case|:
name|name
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|rHeredoc
case|:
name|name
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|rHerestring
case|:
name|name
operator|=
literal|"<<<"
expr_stmt|;
break|break;
block|}
name|fmtcat
argument_list|(
name|f
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* defaultfd -- return the default fd for a given redirection operation */
end_comment

begin_function
specifier|extern
name|int
name|defaultfd
parameter_list|(
name|int
name|op
parameter_list|)
block|{
return|return
operator|(
name|op
operator|==
name|rCreate
operator|||
name|op
operator|==
name|rAppend
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* convert a function in Node * form into something rc can parse (and humans can read?) */
end_comment

begin_function
specifier|static
name|bool
name|Tconv
parameter_list|(
name|Format
modifier|*
name|f
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
name|va_arg
argument_list|(
name|f
operator|->
name|args
argument_list|,
name|Node
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
switch|switch
condition|(
name|n
operator|->
name|type
condition|)
block|{
case|case
name|nWord
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%S"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|nQword
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%#S"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|nBang
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"! %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nCase
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"case %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nNowait
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T&"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nCount
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"$#%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nFlat
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"$^%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nRmfn
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"fn %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nSubshell
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"@ %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nVar
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"$%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nAndalso
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T&&%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nAssign
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T=%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nConcat
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T^%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nElse
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"{%T}else %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nNewfn
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"fn %T {%T}"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nIf
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"if(%T)%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nOrelse
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T||%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nArgs
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nSwitch
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"switch(%T){%T}"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nMatch
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"~ %T %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nVarsub
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"$%T(%T)"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nWhile
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"while(%T)%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nLappend
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"(%T %T)"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nForin
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"for(%T in %T)%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nDup
case|:
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|i
operator|!=
operator|-
literal|1
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%D[%d=%d]"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
argument_list|,
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
else|else
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%D[%d=]"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|nBackq
case|:
block|{
name|Node
modifier|*
name|n0
init|=
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|,
modifier|*
name|n00
decl_stmt|;
if|if
condition|(
name|n0
operator|!=
name|NULL
operator|&&
name|n0
operator|->
name|type
operator|==
name|nVar
operator|&&
operator|(
name|n00
operator|=
name|n0
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
operator|)
operator|!=
name|NULL
operator|&&
name|n00
operator|->
name|type
operator|==
name|nWord
operator|&&
name|streq
argument_list|(
name|n00
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|s
argument_list|,
literal|"ifs"
argument_list|)
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"`"
argument_list|)
expr_stmt|;
else|else
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"``%T"
argument_list|,
name|n0
argument_list|)
expr_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"{%T}"
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nCbody
case|:
case|case
name|nBody
case|:
block|{
name|Node
modifier|*
name|n0
init|=
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
decl_stmt|;
if|if
condition|(
name|n0
operator|!=
name|NULL
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n0
operator|!=
name|NULL
operator|&&
name|n0
operator|->
name|type
operator|!=
name|nNowait
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|nBrace
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"{%T}"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|!=
name|NULL
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nEpilog
case|:
case|case
name|nPre
case|:
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
operator|!=
name|NULL
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|" %T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|nPipe
case|:
block|{
name|int
name|ofd
init|=
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|,
name|ifd
init|=
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
decl_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T|"
argument_list|,
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|!=
literal|0
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"[%d=%d]"
argument_list|,
name|ofd
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ofd
operator|!=
literal|1
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"[%d]"
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|3
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nRedir
case|:
block|{
name|int
name|op
init|=
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%D"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
operator|!=
name|defaultfd
argument_list|(
name|op
argument_list|)
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"[%d]"
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%T"
argument_list|,
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|nNmpipe
case|:
block|{
name|int
name|op
init|=
name|n
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|i
decl_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%D"
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
operator|!=
name|defaultfd
argument_list|(
name|op
argument_list|)
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"[%d]"
argument_list|,
name|n
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"{%T}"
argument_list|,
name|n
operator|->
name|u
index|[
literal|2
index|]
operator|.
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* convert a List to a string, separating it with ^A characters. Used for exporting variables to the environment */
end_comment

begin_function
specifier|extern
name|char
modifier|*
name|list2str
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|List
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|,
name|step
decl_stmt|;
name|List
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|w
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|name
operator|=
name|nprint
argument_list|(
literal|"%F"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|listlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|w
operator|=
name|ealloc
argument_list|(
name|size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
name|x
operator|=
name|w
expr_stmt|;
name|strcpy
argument_list|(
name|x
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|x
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|x
operator|+=
name|conststrlen
argument_list|(
literal|"="
argument_list|)
argument_list|,
name|t
operator|->
name|w
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|+=
name|strlen
argument_list|(
name|t
operator|->
name|w
argument_list|)
operator|,
name|s
operator|=
name|s
operator|->
name|n
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|n
control|)
block|{
name|memcpy
argument_list|(
name|x
argument_list|,
name|FSSTRING
argument_list|,
name|step
operator|=
name|conststrlen
argument_list|(
name|FSSTRING
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|+=
name|step
expr_stmt|;
name|memcpy
argument_list|(
name|x
argument_list|,
name|s
operator|->
name|w
argument_list|,
name|step
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|+=
name|step
expr_stmt|;
block|}
operator|*
name|x
operator|=
literal|'\0'
expr_stmt|;
return|return
name|w
return|;
block|}
end_function

begin_comment
comment|/* convert a List to an array, for execve() */
end_comment

begin_function
specifier|extern
name|char
modifier|*
modifier|*
name|list2array
parameter_list|(
name|List
modifier|*
name|s
parameter_list|,
name|bool
name|print
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 4 == 1 for the null terminator + 2 for the fake execve() + 1 for defaulting to sh */
name|av
operator|=
name|nalloc
argument_list|(
operator|(
name|listnel
argument_list|(
name|s
argument_list|)
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|av
operator|+=
literal|3
expr_stmt|;
comment|/* hide the two free spots from rc (two for #! emulation, one for defaulting to sh) */
if|if
condition|(
name|print
condition|)
name|fprint
argument_list|(
literal|2
argument_list|,
literal|"%L\n"
argument_list|,
name|s
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|av
index|[
name|i
index|]
operator|=
name|s
operator|->
name|w
expr_stmt|;
name|s
operator|=
name|s
operator|->
name|n
expr_stmt|;
block|}
name|av
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|av
return|;
block|}
end_function

begin_comment
comment|/* figure out the name of a variable given an environment string. copy this into malloc space */
end_comment

begin_function
specifier|extern
name|char
modifier|*
name|get_name
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|namebuf
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'='
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
name|r
operator|=
name|namebuf
operator|=
name|ealloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'='
case|:
operator|*
name|r
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|namebuf
return|;
case|case
literal|'_'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
specifier|static
specifier|const
name|char
name|hexchar
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
modifier|*
name|h1
init|=
name|strchr
argument_list|(
name|hexchar
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|h2
init|=
name|strchr
argument_list|(
name|hexchar
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|h1
operator|!=
name|NULL
operator|&&
name|h2
operator|!=
name|NULL
condition|)
block|{
operator|*
name|r
operator|++
operator|=
operator|(
operator|(
name|h1
operator|-
name|hexchar
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|h2
operator|-
name|hexchar
operator|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
comment|/* FALLTHROUGH */
default|default:
operator|*
name|r
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* get the next word from a variable's value as represented in the environment. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getenvw
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|bool
name|saw_alpha
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
name|FSCHAR
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|==
literal|'\0'
operator|&&
operator|!
name|saw_alpha
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|clear
argument_list|(
name|enew
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
return|;
block|}
name|r
operator|=
name|strncpy
argument_list|(
name|ealloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* take an environment entry for a variable (elements ^A separated) and turn it into a List */
end_comment

begin_function
specifier|extern
name|List
modifier|*
name|parse_var
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|extdef
parameter_list|)
block|{
name|List
modifier|*
name|r
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
name|bool
name|saw_alpha
decl_stmt|;
name|top
operator|=
name|r
operator|=
name|enew
argument_list|(
name|List
argument_list|)
expr_stmt|;
name|extdef
operator|=
name|strchr
argument_list|(
name|extdef
argument_list|,
literal|'='
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|getenvw
argument_list|(
name|extdef
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|->
name|w
operator|=
literal|""
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|r
operator|->
name|w
operator|=
name|f
expr_stmt|;
name|r
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
name|extdef
operator|+=
name|strlen
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|extdef
operator|==
name|FSCHAR
condition|)
block|{
name|extdef
operator|++
expr_stmt|;
name|saw_alpha
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|saw_alpha
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|getenvw
argument_list|(
name|extdef
argument_list|,
name|saw_alpha
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|r
operator|->
name|n
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|r
operator|=
name|r
operator|->
name|n
operator|=
name|enew
argument_list|(
name|List
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* get an environment entry for a function and have rc parse it. */
end_comment

begin_define
define|#
directive|define
name|PREFIX
value|"fn x"
end_define

begin_define
define|#
directive|define
name|PRELEN
value|conststrlen(PREFIX)
end_define

begin_function
specifier|extern
name|Node
modifier|*
name|parse_fn
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|extdef
parameter_list|)
block|{
name|Node
modifier|*
name|def
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
name|old
index|[
name|PRELEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|extdef
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|old
argument_list|,
name|s
operator|-=
operator|(
name|PRELEN
operator|-
literal|1
operator|)
argument_list|,
name|PRELEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|PREFIX
argument_list|,
name|PRELEN
argument_list|)
expr_stmt|;
name|def
operator|=
name|parseline
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
argument_list|,
name|old
argument_list|,
name|PRELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|def
operator|==
name|NULL
operator|||
name|def
operator|->
name|type
operator|!=
name|nNewfn
operator|)
condition|?
name|NULL
else|:
name|def
operator|->
name|u
index|[
literal|1
index|]
operator|.
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|Aconv
parameter_list|(
name|Format
modifier|*
name|f
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|a
init|=
name|va_arg
argument_list|(
name|f
operator|->
name|args
argument_list|,
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|a
operator|!=
name|NULL
condition|)
block|{
name|fmtcat
argument_list|(
name|f
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|a
operator|!=
name|NULL
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|" %s"
argument_list|,
operator|*
name|a
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|Lconv
parameter_list|(
name|Format
modifier|*
name|f
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|List
modifier|*
name|l
init|=
name|va_arg
argument_list|(
name|f
operator|->
name|args
argument_list|,
name|List
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sep
init|=
name|va_arg
argument_list|(
name|f
operator|->
name|args
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
operator|(
name|f
operator|->
name|flags
operator|&
name|FMT_leftside
operator|)
condition|?
literal|"%s%s"
else|:
literal|"%-S%s"
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
operator|&&
operator|(
name|f
operator|->
name|flags
operator|&
name|FMT_leftside
operator|)
operator|==
literal|0
condition|)
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
else|else
block|{
name|List
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|l
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|n
control|)
name|fmtprint
argument_list|(
name|f
argument_list|,
name|fmt
argument_list|,
name|s
operator|->
name|w
argument_list|,
name|s
operator|->
name|n
operator|==
name|NULL
condition|?
literal|""
else|:
name|sep
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ISMETA
parameter_list|(
name|c
parameter_list|)
value|(c == '*' || c == '?' || c == '[')
end_define

begin_function
specifier|static
name|bool
name|Sconv
parameter_list|(
name|Format
modifier|*
name|f
parameter_list|,
name|int
name|ignore
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|unsigned
name|char
modifier|*
name|s
init|=
name|va_arg
argument_list|(
argument|f->args
argument_list|,
argument|unsigned char *
argument_list|)
decl_stmt|,
modifier|*
name|t
init|=
name|s
decl_stmt|;
name|bool
name|quoted
init|=
operator|(
name|f
operator|->
name|flags
operator|&
name|FMT_altform
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* '#' */
name|bool
name|metaquote
init|=
operator|(
name|f
operator|->
name|flags
operator|&
name|FMT_leftside
operator|)
operator|!=
literal|0
decl_stmt|;
comment|/* '-' */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"''"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|quoted
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|t
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|nw
index|[
name|c
index|]
operator|==
literal|1
operator|||
operator|(
name|metaquote
operator|&&
name|ISMETA
argument_list|(
name|c
argument_list|)
operator|)
condition|)
goto|goto
name|quoteit
goto|;
name|fmtprint
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|quoteit
label|:
name|fmtputc
argument_list|(
name|f
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|fmtputc
argument_list|(
name|f
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|fmtputc
argument_list|(
name|f
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|fmtputc
argument_list|(
name|f
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|initprint
parameter_list|(
name|void
parameter_list|)
block|{
name|fmtinstall
argument_list|(
literal|'A'
argument_list|,
name|Aconv
argument_list|)
expr_stmt|;
name|fmtinstall
argument_list|(
literal|'L'
argument_list|,
name|Lconv
argument_list|)
expr_stmt|;
name|fmtinstall
argument_list|(
literal|'S'
argument_list|,
name|Sconv
argument_list|)
expr_stmt|;
name|fmtinstall
argument_list|(
literal|'T'
argument_list|,
name|Tconv
argument_list|)
expr_stmt|;
name|fmtinstall
argument_list|(
literal|'D'
argument_list|,
name|Dconv
argument_list|)
expr_stmt|;
name|fmtinstall
argument_list|(
literal|'F'
argument_list|,
name|Fconv
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

