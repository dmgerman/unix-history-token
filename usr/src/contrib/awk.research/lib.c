begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) AT&T 1993 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of AT&T or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AT&T OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_define
define|#
directive|define
name|getfval
parameter_list|(
name|p
parameter_list|)
value|(((p)->tval& (ARR|FLD|REC|NUM)) == NUM ? (p)->fval : r_getfval(p))
end_define

begin_define
define|#
directive|define
name|getsval
parameter_list|(
name|p
parameter_list|)
value|(((p)->tval& (ARR|FLD|REC|STR)) == STR ? (p)->sval : r_getsval(p))
end_define

begin_decl_stmt
name|FILE
modifier|*
name|infile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|file
init|=
operator|(
name|uchar
operator|*
operator|)
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|recsize
init|=
name|RECSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|recdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|record
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|fields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|fldtab
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXFLD
value|200
end_define

begin_decl_stmt
name|int
name|nfields
init|=
name|MAXFLD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* can be set from commandline in main */
end_comment

begin_decl_stmt
name|int
name|donefld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 = implies rec broken into fields */
end_comment

begin_decl_stmt
name|int
name|donerec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 = record is valid (no flds have changed) */
end_comment

begin_decl_stmt
name|int
name|maxfld
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last used field */
end_comment

begin_decl_stmt
name|int
name|argno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current input argument number */
end_comment

begin_decl_stmt
specifier|extern
name|Awkfloat
modifier|*
name|ARGC
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|recinit
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
specifier|static
name|Cell
name|dollar0
init|=
block|{
name|OCELL
block|,
name|CFLD
block|,
operator|(
name|uchar
operator|*
operator|)
literal|"$0"
block|,
comment|/*recdata*/
literal|0
block|,
literal|0.0
block|,
name|REC
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
specifier|static
name|Cell
name|dollar1
init|=
block|{
name|OCELL
block|,
name|CFLD
block|,
name|NULL
block|,
operator|(
name|uchar
operator|*
operator|)
literal|""
block|,
literal|0.0
block|,
name|FLD
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|record
operator|=
name|recdata
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|fields
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|fldtab
operator|=
operator|(
name|Cell
operator|*
operator|)
name|malloc
argument_list|(
name|nfields
operator|*
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recdata
operator|==
name|NULL
operator|||
name|fields
operator|==
name|NULL
operator|||
name|fldtab
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space for $0 and fields"
name|FATAL
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|=
name|dollar0
expr_stmt|;
name|fldtab
index|[
literal|0
index|]
operator|.
name|sval
operator|=
name|recdata
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfields
condition|;
name|i
operator|++
control|)
name|fldtab
index|[
name|i
index|]
operator|=
name|dollar1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initgetrec
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uchar
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|ARGC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isclvar
argument_list|(
name|p
operator|=
name|getargv
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|/* find 1st real filename */
name|setsval
argument_list|(
name|lookup
argument_list|(
literal|"FILENAME"
argument_list|,
name|symtab
argument_list|)
argument_list|,
name|getargv
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|setclvar
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* a commandline assignment before filename */
name|argno
operator|++
expr_stmt|;
block|}
name|infile
operator|=
name|stdin
expr_stmt|;
comment|/* no filenames, so use stdin */
block|}
end_function

begin_macro
name|getrec
argument_list|(
argument|uchar *buf
argument_list|)
end_macro

begin_comment
comment|/* get next input record from whatever source */
end_comment

begin_block
block|{
comment|/* note: tests whether buf == record */
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|firsttime
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|firsttime
condition|)
block|{
name|firsttime
operator|=
literal|0
expr_stmt|;
name|initgetrec
argument_list|()
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"RS=<%s>, FS=<%s>, ARGC=%g, FILENAME=%s\n"
operator|,
operator|*
name|RS
operator|,
operator|*
name|FS
operator|,
operator|*
name|ARGC
operator|,
operator|*
name|FILENAME
operator|)
argument_list|)
expr_stmt|;
name|donefld
operator|=
literal|0
expr_stmt|;
name|donerec
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argno
operator|<
operator|*
name|ARGC
operator|||
name|infile
operator|==
name|stdin
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"argno=%d, file=|%s|\n"
operator|,
name|argno
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
comment|/* have to open a new file */
name|file
operator|=
name|getargv
argument_list|(
name|argno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'\0'
condition|)
block|{
comment|/* it's been zapped */
name|argno
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isclvar
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|/* a var=value arg */
name|setclvar
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|argno
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|FILENAME
operator|=
name|file
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"opening file %s\n"
operator|,
name|file
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|'-'
operator|&&
operator|*
operator|(
name|file
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
name|infile
operator|=
name|stdin
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROR
literal|"can't open file %s"
operator|,
name|file
name|FATAL
expr_stmt|;
name|setfval
argument_list|(
name|fnrloc
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|readrec
argument_list|(
name|buf
argument_list|,
name|recsize
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
operator|||
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* normal record */
if|if
condition|(
name|buf
operator|==
name|record
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|recloc
operator|->
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|recloc
operator|->
name|sval
argument_list|)
expr_stmt|;
name|recloc
operator|->
name|sval
operator|=
name|record
expr_stmt|;
name|recloc
operator|->
name|tval
operator|=
name|REC
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|recloc
operator|->
name|sval
argument_list|)
condition|)
block|{
name|recloc
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|recloc
operator|->
name|sval
argument_list|)
expr_stmt|;
name|recloc
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
block|}
name|setfval
argument_list|(
name|nrloc
argument_list|,
name|nrloc
operator|->
name|fval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|fnrloc
argument_list|,
name|fnrloc
operator|->
name|fval
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* EOF arrived on this file; set up next */
if|if
condition|(
name|infile
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|infile
operator|=
name|NULL
expr_stmt|;
name|argno
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* true end of file */
block|}
end_block

begin_macro
name|readrec
argument_list|(
argument|uchar *buf
argument_list|,
argument|int bufsize
argument_list|,
argument|FILE *inf
argument_list|)
end_macro

begin_comment
comment|/* read one record into buf */
end_comment

begin_block
block|{
specifier|register
name|int
name|sep
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|rr
decl_stmt|;
specifier|register
name|int
name|nrr
decl_stmt|;
if|if
condition|(
operator|(
name|sep
operator|=
operator|*
operator|*
name|RS
operator|)
operator|==
literal|0
condition|)
block|{
name|sep
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
comment|/* skip leading \n's */
empty_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|inf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|rr
operator|=
name|buf
operator|,
name|nrr
operator|=
name|bufsize
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|sep
operator|&&
name|c
operator|!=
name|EOF
condition|;
operator|*
name|rr
operator|++
operator|=
name|c
control|)
if|if
condition|(
operator|--
name|nrr
operator|<
literal|0
condition|)
name|ERROR
literal|"input record `%.30s...' too long; try -mr n"
operator|,
name|buf
name|FATAL
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|RS
operator|==
name|sep
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
comment|/* 2 in a row */
break|break;
operator|*
name|rr
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|rr
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|rr
operator|>
name|buf
operator|+
name|bufsize
condition|)
name|ERROR
literal|"input record `%.30s...' too long; try -mr n"
operator|,
name|buf
name|FATAL
expr_stmt|;
operator|*
name|rr
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"readrec saw<%s>, returns %d\n"
operator|,
name|buf
operator|,
name|c
operator|==
name|EOF
operator|&&
name|rr
operator|==
name|buf
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|c
operator|==
name|EOF
operator|&&
name|rr
operator|==
name|buf
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_block

begin_function
name|uchar
modifier|*
name|getargv
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* get ARGV[n] */
block|{
name|Cell
modifier|*
name|x
decl_stmt|;
name|uchar
modifier|*
name|s
decl_stmt|,
name|temp
index|[
literal|10
index|]
decl_stmt|;
specifier|extern
name|Array
modifier|*
name|ARGVtab
decl_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|x
operator|=
name|setsymtab
argument_list|(
name|temp
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ARGVtab
argument_list|)
expr_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"getargv(%d) returns |%s|\n"
operator|,
name|n
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|setclvar
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|)
comment|/* set var=value from s */
block|{
name|uchar
modifier|*
name|p
decl_stmt|;
name|Cell
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'='
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|qstring
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|q
operator|=
name|setsymtab
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|q
operator|->
name|sval
argument_list|)
condition|)
block|{
name|q
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|q
operator|->
name|sval
argument_list|)
expr_stmt|;
name|q
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"command line set %s to |%s|\n"
operator|,
name|s
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fldbld
parameter_list|(
name|void
parameter_list|)
comment|/* create fields from current record */
block|{
specifier|register
name|uchar
modifier|*
name|r
decl_stmt|,
modifier|*
name|fr
decl_stmt|,
name|sep
decl_stmt|;
name|Cell
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|donefld
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|recloc
operator|->
name|tval
operator|&
name|STR
operator|)
condition|)
name|getsval
argument_list|(
name|recloc
argument_list|)
expr_stmt|;
name|r
operator|=
name|recloc
operator|->
name|sval
expr_stmt|;
name|fr
operator|=
name|fields
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* number of fields accumulated here */
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|FS
argument_list|)
operator|>
literal|1
condition|)
block|{
comment|/* it's a regular expression */
name|i
operator|=
name|refldbld
argument_list|(
name|r
argument_list|,
operator|*
name|FS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sep
operator|=
operator|*
operator|*
name|FS
operator|)
operator|==
literal|' '
condition|)
block|{
comment|/* default whitespace */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|r
operator|==
literal|' '
operator|||
operator|*
name|r
operator|==
literal|'\t'
operator|||
operator|*
name|r
operator|==
literal|'\n'
condition|)
name|r
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
literal|0
condition|)
break|break;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nfields
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|fldtab
index|[
name|i
index|]
operator|.
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|.
name|sval
operator|=
name|fr
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|.
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
do|do
operator|*
name|fr
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|r
operator|!=
literal|' '
operator|&&
operator|*
name|r
operator|!=
literal|'\t'
operator|&&
operator|*
name|r
operator|!=
literal|'\n'
operator|&&
operator|*
name|r
operator|!=
literal|'\0'
condition|)
do|;
operator|*
name|fr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|fr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* if 0, it's a null field */
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|nfields
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|fldtab
index|[
name|i
index|]
operator|.
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|.
name|sval
operator|=
name|fr
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|.
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
while|while
condition|(
operator|*
name|r
operator|!=
name|sep
operator|&&
operator|*
name|r
operator|!=
literal|'\n'
operator|&&
operator|*
name|r
operator|!=
literal|'\0'
condition|)
comment|/* \n is always a separator */
operator|*
name|fr
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
operator|*
name|fr
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|r
operator|++
operator|==
literal|0
condition|)
break|break;
block|}
operator|*
name|fr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|nfields
condition|)
name|ERROR
literal|"record `%.30s...' has too many fields; try -mf n"
operator|,
name|record
name|FATAL
expr_stmt|;
comment|/* clean out junk from previous record */
name|cleanfld
argument_list|(
name|i
argument_list|,
name|maxfld
argument_list|)
expr_stmt|;
name|maxfld
operator|=
name|i
expr_stmt|;
name|donefld
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|fldtab
operator|+
literal|1
init|;
name|p
operator|<=
name|fldtab
operator|+
name|maxfld
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isnumber
argument_list|(
name|p
operator|->
name|sval
argument_list|)
condition|)
block|{
name|p
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|p
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
block|}
name|setfval
argument_list|(
name|nfloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|maxfld
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg
condition|)
for|for
control|(
name|p
operator|=
name|fldtab
init|;
name|p
operator|<=
name|fldtab
operator|+
name|maxfld
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"field %d: |%s|\n"
argument_list|,
name|p
operator|-
name|fldtab
argument_list|,
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cleanfld
parameter_list|(
name|int
name|n1
parameter_list|,
name|int
name|n2
parameter_list|)
comment|/* clean out fields n1..n2 inclusive */
block|{
specifier|static
name|uchar
modifier|*
name|nullstat
init|=
operator|(
name|uchar
operator|*
operator|)
literal|""
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|fldtab
index|[
name|n2
index|]
operator|,
name|q
operator|=
operator|&
name|fldtab
index|[
name|n1
index|]
init|;
name|p
operator|>
name|q
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|p
operator|->
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
name|p
operator|->
name|sval
operator|=
name|nullstat
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|newfld
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* add field n (after end) */
block|{
if|if
condition|(
name|n
operator|>=
name|nfields
condition|)
name|ERROR
literal|"creating too many fields (%d); try -mf n"
operator|,
name|n
operator|,
name|record
name|FATAL
expr_stmt|;
name|cleanfld
argument_list|(
name|maxfld
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|maxfld
operator|=
name|n
expr_stmt|;
name|setfval
argument_list|(
name|nfloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|refldbld
argument_list|(
argument|uchar *rec
argument_list|,
argument|uchar *fs
argument_list|)
end_macro

begin_comment
comment|/* build fields from reg expr in FS */
end_comment

begin_block
block|{
name|uchar
modifier|*
name|fr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|tempstat
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|fr
operator|=
name|fields
expr_stmt|;
operator|*
name|fr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|rec
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"into refldbld, rec =<%s>, pat =<%s>\n"
operator|,
name|rec
operator|,
name|fs
operator|)
argument_list|)
expr_stmt|;
name|tempstat
operator|=
name|pfa
operator|->
name|initstat
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfields
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|fldtab
index|[
name|i
index|]
operator|.
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|fldtab
index|[
name|i
index|]
operator|.
name|sval
argument_list|)
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|.
name|tval
operator|=
name|FLD
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
name|fldtab
index|[
name|i
index|]
operator|.
name|sval
operator|=
name|fr
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"refldbld: i=%d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nematch
argument_list|(
name|pfa
argument_list|,
name|rec
argument_list|)
condition|)
block|{
name|pfa
operator|->
name|initstat
operator|=
literal|2
expr_stmt|;
comment|/* horrible coupling */
name|dprintf
argument_list|(
operator|(
literal|"match %s (%d chars)\n"
operator|,
name|patbeg
operator|,
name|patlen
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fr
argument_list|,
name|rec
argument_list|,
name|patbeg
operator|-
name|rec
argument_list|)
expr_stmt|;
name|fr
operator|+=
name|patbeg
operator|-
name|rec
operator|+
literal|1
expr_stmt|;
operator|*
operator|(
name|fr
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|rec
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"no match %s\n"
operator|,
name|rec
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fr
argument_list|,
name|rec
argument_list|)
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_block

begin_function
name|void
name|recbld
parameter_list|(
name|void
parameter_list|)
comment|/* create $0 from $1..$NF if necessary */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|r
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|static
name|uchar
modifier|*
name|rec
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|donerec
operator|==
literal|1
condition|)
return|return;
if|if
condition|(
name|rec
operator|==
literal|0
condition|)
block|{
name|rec
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|recsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|==
literal|0
condition|)
name|ERROR
literal|"out of space building $0, record size %d"
operator|,
name|recsize
name|FATAL
expr_stmt|;
block|}
name|r
operator|=
name|rec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|*
name|NF
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|getsval
argument_list|(
operator|&
name|fldtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|<
name|rec
operator|+
name|recsize
operator|-
literal|1
operator|&&
operator|(
operator|*
name|r
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
name|r
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|*
name|NF
condition|)
for|for
control|(
name|p
operator|=
operator|*
name|OFS
init|;
name|r
operator|<
name|rec
operator|+
name|recsize
operator|-
literal|1
operator|&&
operator|(
operator|*
name|r
operator|=
operator|*
name|p
operator|++
operator|)
condition|;
control|)
name|r
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|>
name|rec
operator|+
name|recsize
operator|-
literal|1
condition|)
name|ERROR
literal|"built giant record `%.30s...'; try -mr n"
operator|,
name|record
name|FATAL
expr_stmt|;
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"in recbld FS=%o, recloc=%o\n"
operator|,
operator|*
operator|*
name|FS
operator|,
name|recloc
operator|)
argument_list|)
expr_stmt|;
name|recloc
operator|->
name|tval
operator|=
name|REC
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
name|recloc
operator|->
name|sval
operator|=
name|record
operator|=
name|rec
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"in recbld FS=%o, recloc=%o\n"
operator|,
operator|*
operator|*
name|FS
operator|,
name|recloc
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"recbld = |%s|\n"
operator|,
name|record
operator|)
argument_list|)
expr_stmt|;
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|fieldadr
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|nfields
condition|)
name|ERROR
literal|"trying to access field %d; try -mf n"
operator|,
name|n
name|FATAL
expr_stmt|;
return|return
operator|(
operator|&
name|fldtab
index|[
name|n
index|]
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|errorflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|errbuf
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|yyerror
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|)
block|{
specifier|extern
name|uchar
modifier|*
name|cmdname
decl_stmt|,
modifier|*
name|curfname
decl_stmt|;
specifier|static
name|int
name|been_here
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|been_here
operator|++
operator|>
literal|2
condition|)
return|return;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s"
argument_list|,
name|cmdname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" at source line %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|curfname
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" in function %s"
argument_list|,
name|curfname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errorflag
operator|=
literal|2
expr_stmt|;
name|eprint
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fpecatch
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|ERROR
literal|"floating point exception %d"
operator|,
name|n
name|FATAL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|bracecnt
decl_stmt|,
name|brackcnt
decl_stmt|,
name|parencnt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bracecheck
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|beenhere
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|beenhere
operator|++
condition|)
return|return;
while|while
condition|(
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|bclass
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|bcheck2
argument_list|(
name|bracecnt
argument_list|,
literal|'{'
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
name|bcheck2
argument_list|(
name|brackcnt
argument_list|,
literal|'['
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
name|bcheck2
argument_list|(
name|parencnt
argument_list|,
literal|'('
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bcheck2
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|c2
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmissing %c\n"
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d missing %c's\n"
argument_list|,
name|n
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\textra %c\n"
argument_list|,
name|c2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%d extra %c's\n"
argument_list|,
operator|-
name|n
argument_list|,
name|c2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error
parameter_list|(
name|int
name|f
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|extern
name|Node
modifier|*
name|curnode
decl_stmt|;
specifier|extern
name|uchar
modifier|*
name|cmdname
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|compile_time
operator|!=
literal|2
operator|&&
name|NR
operator|&&
operator|*
name|NR
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" input record number %g"
argument_list|,
operator|*
name|FNR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|FILENAME
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
operator|*
name|FILENAME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compile_time
operator|!=
literal|2
operator|&&
name|curnode
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" source line number %d\n"
argument_list|,
name|curnode
operator|->
name|lineno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|compile_time
operator|!=
literal|2
operator|&&
name|lineno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" source line number %d\n"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|eprint
argument_list|()
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
if|if
condition|(
name|dbg
operator|>
literal|1
condition|)
comment|/* core dump if serious debugging on */
name|abort
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|eprint
parameter_list|(
name|void
parameter_list|)
comment|/* try to print context around error */
block|{
name|uchar
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|static
name|int
name|been_here
init|=
literal|0
decl_stmt|;
specifier|extern
name|uchar
name|ebuf
index|[]
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|compile_time
operator|==
literal|2
operator|||
name|compile_time
operator|==
literal|0
operator|||
name|been_here
operator|++
operator|>
literal|0
condition|)
return|return;
name|p
operator|=
name|ep
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|ebuf
operator|&&
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|--
expr_stmt|;
for|for
control|(
init|;
name|p
operator|>
name|ebuf
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|--
control|)
empty_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" context is\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ep
operator|-
literal|1
init|;
name|q
operator|>=
name|p
operator|&&
operator|*
name|q
operator|!=
literal|' '
operator|&&
operator|*
name|q
operator|!=
literal|'\t'
operator|&&
operator|*
name|q
operator|!=
literal|'\n'
condition|;
name|q
operator|--
control|)
empty_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|q
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">>> "
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|ep
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<<< "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|input
argument_list|()
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|bclass
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ebuf
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bclass
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'{'
case|:
name|bracecnt
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|bracecnt
operator|--
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|brackcnt
operator|++
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|brackcnt
operator|--
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|parencnt
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|parencnt
operator|--
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|double
name|errcheck
parameter_list|(
name|double
name|x
parameter_list|,
name|uchar
modifier|*
name|s
parameter_list|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|EDOM
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ERROR
literal|"%s argument out of domain"
operator|,
name|s
name|WARNING
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ERROR
literal|"%s result out of range"
operator|,
name|s
name|WARNING
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_macro
name|isclvar
argument_list|(
argument|uchar *s
argument_list|)
end_macro

begin_comment
comment|/* is s of form var=something ? */
end_comment

begin_block
block|{
name|uchar
modifier|*
name|os
init|=
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'_'
condition|)
return|return
literal|0
return|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
operator|)
condition|)
break|break;
return|return
operator|*
name|s
operator|==
literal|'='
operator|&&
name|s
operator|>
name|os
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|!=
literal|'='
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXEXPON
value|38
end_define

begin_comment
comment|/* maximum exponent for fp number. should be IEEE */
end_comment

begin_macro
name|isnumber
argument_list|(
argument|uchar *s
argument_list|)
end_macro

begin_comment
comment|/* probably should be done by a library function */
end_comment

begin_block
block|{
specifier|register
name|int
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|int
name|point
decl_stmt|;
name|uchar
modifier|*
name|es
decl_stmt|;
name|d1
operator|=
name|d2
operator|=
name|point
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* empty stuff isn't number */
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
do|do
block|{
name|d1
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|point
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|d2
operator|++
expr_stmt|;
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|!
operator|(
name|d1
operator|||
name|point
operator|&&
name|d2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
operator|||
operator|*
name|s
operator|==
literal|'E'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|es
operator|=
name|s
expr_stmt|;
do|do
block|{
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
do|;
if|if
condition|(
name|s
operator|-
name|es
operator|>
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|s
operator|-
name|es
operator|==
literal|2
operator|&&
call|(
name|int
call|)
argument_list|(
literal|10
operator|*
operator|(
operator|*
name|es
operator|-
literal|'0'
operator|)
operator|+
operator|*
operator|(
name|es
operator|+
literal|1
operator|)
operator|-
literal|'0'
argument_list|)
operator|>=
name|MAXEXPON
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

