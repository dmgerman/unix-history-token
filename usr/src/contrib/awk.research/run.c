begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) AT&T 1993 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of AT&T or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AT&T OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|tempfree
parameter_list|(
name|x
parameter_list|)
value|if (istemp(x)) tfree(x); else
end_define

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_NFILE
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|FOPEN_MAX
end_ifndef

begin_define
define|#
directive|define
name|FOPEN_MAX
value|_NFILE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FOPEN_MAX
end_ifndef

begin_define
define|#
directive|define
name|FOPEN_MAX
value|40
end_define

begin_comment
comment|/* max number of open files */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RAND_MAX
end_ifndef

begin_define
define|#
directive|define
name|RAND_MAX
value|32767
end_define

begin_comment
comment|/* all that ansi guarantees */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* an attempt to go a bit faster: */
end_comment

begin_comment
comment|/* #define	execute(p)	(isvalue(p) ? (Cell *)((p)->narg[0]) : r_execute(p)) */
end_comment

begin_define
define|#
directive|define
name|execute
parameter_list|(
name|p
parameter_list|)
value|r_execute(p)
end_define

begin_define
define|#
directive|define
name|getfval
parameter_list|(
name|p
parameter_list|)
value|(((p)->tval& (ARR|FLD|REC|NUM)) == NUM ? (p)->fval : r_getfval(p))
end_define

begin_define
define|#
directive|define
name|getsval
parameter_list|(
name|p
parameter_list|)
value|(((p)->tval& (ARR|FLD|REC|STR)) == STR ? (p)->sval : r_getsval(p))
end_define

begin_define
define|#
directive|define
name|PA2NUM
value|29
end_define

begin_comment
comment|/* max number of pat,pat patterns allowed */
end_comment

begin_decl_stmt
name|int
name|paircnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of them in use */
end_comment

begin_decl_stmt
name|int
name|pairstack
index|[
name|PA2NUM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of each pat,pat */
end_comment

begin_decl_stmt
name|Node
modifier|*
name|winner
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* root of parse tree */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|tmps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free temporary cells for execution */
end_comment

begin_decl_stmt
specifier|static
name|Cell
name|truecell
init|=
block|{
name|OBOOL
block|,
name|BTRUE
block|,
literal|0
block|,
literal|0
block|,
literal|1.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|true
init|=
operator|&
name|truecell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|falsecell
init|=
block|{
name|OBOOL
block|,
name|BFALSE
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|false
init|=
operator|&
name|falsecell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|breakcell
init|=
block|{
name|OJUMP
block|,
name|JBREAK
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jbreak
init|=
operator|&
name|breakcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|contcell
init|=
block|{
name|OJUMP
block|,
name|JCONT
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jcont
init|=
operator|&
name|contcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|nextcell
init|=
block|{
name|OJUMP
block|,
name|JNEXT
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jnext
init|=
operator|&
name|nextcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|exitcell
init|=
block|{
name|OJUMP
block|,
name|JEXIT
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jexit
init|=
operator|&
name|exitcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|retcell
init|=
block|{
name|OJUMP
block|,
name|JRET
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|jret
init|=
operator|&
name|retcell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cell
name|tempcell
init|=
block|{
name|OCELL
block|,
name|CTEMP
block|,
literal|0
block|,
literal|0
block|,
literal|0.0
block|,
name|NUM
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Node
modifier|*
name|curnode
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the node being executed, for debugging */
end_comment

begin_function
name|void
name|run
parameter_list|(
name|Node
modifier|*
name|a
parameter_list|)
comment|/* execution of parse tree starts here */
block|{
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|closeall
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|r_execute
parameter_list|(
name|Node
modifier|*
name|u
parameter_list|)
comment|/* execute a node of the parse tree */
block|{
specifier|register
name|Cell
modifier|*
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|Node
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
specifier|register
name|Node
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|u
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
for|for
control|(
name|a
operator|=
name|u
init|;
condition|;
name|a
operator|=
name|a
operator|->
name|nnext
control|)
block|{
name|curnode
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|isvalue
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|x
operator|=
operator|(
name|Cell
operator|*
operator|)
operator|(
name|a
operator|->
name|narg
index|[
literal|0
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|->
name|tval
operator|&
name|FLD
operator|)
operator|&&
operator|!
name|donefld
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|x
operator|->
name|tval
operator|&
name|REC
operator|)
operator|&&
operator|!
name|donerec
condition|)
name|recbld
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|notlegal
argument_list|(
name|a
operator|->
name|nobj
argument_list|)
condition|)
comment|/* probably a Cell* but too risky to print */
name|ERROR
literal|"illegal statement"
name|FATAL
expr_stmt|;
name|proc
operator|=
name|proctab
index|[
name|a
operator|->
name|nobj
operator|-
name|FIRSTTOKEN
index|]
expr_stmt|;
name|x
operator|=
call|(
modifier|*
name|proc
call|)
argument_list|(
name|a
operator|->
name|narg
argument_list|,
name|a
operator|->
name|nobj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|->
name|tval
operator|&
name|FLD
operator|)
operator|&&
operator|!
name|donefld
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|x
operator|->
name|tval
operator|&
name|REC
operator|)
operator|&&
operator|!
name|donerec
condition|)
name|recbld
argument_list|()
expr_stmt|;
if|if
condition|(
name|isexpr
argument_list|(
name|a
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|isjump
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|nnext
operator|==
name|NULL
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|program
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* execute an awk program */
block|{
comment|/* a[0] = BEGIN, a[1] = body, a[2] = END */
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|ex
goto|;
if|if
condition|(
name|a
index|[
literal|0
index|]
condition|)
block|{
comment|/* BEGIN */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
if|if
condition|(
name|isjump
argument_list|(
name|x
argument_list|)
condition|)
name|ERROR
literal|"illegal break, continue or next from BEGIN"
name|FATAL
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|loop
label|:
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|||
name|a
index|[
literal|2
index|]
condition|)
while|while
condition|(
name|getrec
argument_list|(
name|record
argument_list|)
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|x
argument_list|)
condition|)
break|break;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|ex
label|:
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|!=
literal|0
condition|)
comment|/* handles exit within END */
goto|goto
name|ex1
goto|;
if|if
condition|(
name|a
index|[
literal|2
index|]
condition|)
block|{
comment|/* END */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
operator|||
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|iscont
argument_list|(
name|x
argument_list|)
condition|)
name|ERROR
literal|"illegal break, next, or continue from END"
name|FATAL
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|ex1
label|:
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|Frame
block|{
comment|/* stack frame for awk function calls */
name|int
name|nargs
decl_stmt|;
comment|/* number of arguments in this call */
name|Cell
modifier|*
name|fcncell
decl_stmt|;
comment|/* pointer to Cell for function */
name|Cell
modifier|*
modifier|*
name|args
decl_stmt|;
comment|/* pointer to array of arguments after execute */
name|Cell
modifier|*
name|retval
decl_stmt|;
comment|/* return value */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NARGS
value|50
end_define

begin_comment
comment|/* max args in a call */
end_comment

begin_decl_stmt
name|struct
name|Frame
modifier|*
name|frame
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base of stack frames; dynamically allocated */
end_comment

begin_decl_stmt
name|int
name|nframe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of frames allocated */
end_comment

begin_decl_stmt
name|struct
name|Frame
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frame pointer. bottom level unused */
end_comment

begin_function
name|Cell
modifier|*
name|call
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* function call.  very kludgy and fragile */
block|{
specifier|static
name|Cell
name|newcopycell
init|=
block|{
name|OCELL
block|,
name|CCOPY
block|,
literal|0
block|,
operator|(
name|uchar
operator|*
operator|)
literal|""
block|,
literal|0.0
block|,
name|NUM
operator||
name|STR
operator||
name|DONTFREE
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ncall
decl_stmt|,
name|ndef
decl_stmt|;
name|Node
modifier|*
name|x
decl_stmt|;
name|Cell
modifier|*
name|args
index|[
name|NARGS
index|]
decl_stmt|,
modifier|*
name|oargs
index|[
name|NARGS
index|]
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|,
modifier|*
name|fcn
decl_stmt|;
name|uchar
modifier|*
name|s
decl_stmt|;
name|fcn
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* the function itself */
name|s
operator|=
name|fcn
operator|->
name|nval
expr_stmt|;
if|if
condition|(
operator|!
name|isfunc
argument_list|(
name|fcn
argument_list|)
condition|)
name|ERROR
literal|"calling undefined function %s"
operator|,
name|s
name|FATAL
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|frame
operator|=
operator|(
expr|struct
name|Frame
operator|*
operator|)
name|calloc
argument_list|(
name|nframe
operator|+=
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space for stack frames calling %s"
operator|,
name|s
name|FATAL
expr_stmt|;
block|}
for|for
control|(
name|ncall
operator|=
literal|0
operator|,
name|x
operator|=
name|a
index|[
literal|1
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|nnext
control|)
comment|/* args in call */
name|ncall
operator|++
expr_stmt|;
name|ndef
operator|=
operator|(
name|int
operator|)
name|fcn
operator|->
name|fval
expr_stmt|;
comment|/* args in defn */
name|dprintf
argument_list|(
operator|(
literal|"calling %s, %d args (%d in defn), fp=%d\n"
operator|,
name|s
operator|,
name|ncall
operator|,
name|ndef
operator|,
name|fp
operator|-
name|frame
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncall
operator|>
name|ndef
condition|)
name|ERROR
literal|"function %s called with %d args, uses only %d"
operator|,
name|s
operator|,
name|ncall
operator|,
name|ndef
name|WARNING
expr_stmt|;
if|if
condition|(
name|ncall
operator|+
name|ndef
operator|>
name|NARGS
condition|)
name|ERROR
literal|"function %s has %d arguments, limit %d"
operator|,
name|s
operator|,
name|ncall
operator|+
name|ndef
operator|,
name|NARGS
name|FATAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|x
operator|=
name|a
index|[
literal|1
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|x
operator|=
name|x
operator|->
name|nnext
control|)
block|{
comment|/* get call args */
name|dprintf
argument_list|(
operator|(
literal|"evaluate args[%d], fp=%d:\n"
operator|,
name|i
operator|,
name|fp
operator|-
name|frame
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|oargs
index|[
name|i
index|]
operator|=
name|y
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"args[%d]: %s %f<%s>, t=%o\n"
operator|,
name|i
operator|,
name|y
operator|->
name|nval
operator|,
name|y
operator|->
name|fval
operator|,
name|isarr
argument_list|(
name|y
argument_list|)
condition|?
literal|"(array)"
else|:
operator|(
name|char
operator|*
operator|)
name|y
operator|->
name|sval
operator|,
name|y
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfunc
argument_list|(
name|y
argument_list|)
condition|)
name|ERROR
literal|"can't use function %s as argument in %s"
operator|,
name|y
operator|->
name|nval
operator|,
name|s
name|FATAL
expr_stmt|;
if|if
condition|(
name|isarr
argument_list|(
name|y
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|=
name|y
expr_stmt|;
comment|/* arrays by ref */
else|else
name|args
index|[
name|i
index|]
operator|=
name|copycell
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|ndef
condition|;
name|i
operator|++
control|)
block|{
comment|/* add null args for ones not provided */
name|args
index|[
name|i
index|]
operator|=
name|gettemp
argument_list|()
expr_stmt|;
operator|*
name|args
index|[
name|i
index|]
operator|=
name|newcopycell
expr_stmt|;
block|}
name|fp
operator|++
expr_stmt|;
comment|/* now ok to up frame */
if|if
condition|(
name|fp
operator|>=
name|frame
operator|+
name|nframe
condition|)
block|{
name|int
name|dfp
init|=
name|fp
operator|-
name|frame
decl_stmt|;
comment|/* old index */
name|frame
operator|=
operator|(
expr|struct
name|Frame
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|frame
argument_list|,
operator|(
name|nframe
operator|+=
literal|100
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space for stack frames in %s"
operator|,
name|s
name|FATAL
expr_stmt|;
name|fp
operator|=
name|frame
operator|+
name|dfp
expr_stmt|;
block|}
name|fp
operator|->
name|fcncell
operator|=
name|fcn
expr_stmt|;
name|fp
operator|->
name|args
operator|=
name|args
expr_stmt|;
name|fp
operator|->
name|nargs
operator|=
name|ndef
expr_stmt|;
comment|/* number defined with (excess are locals) */
name|fp
operator|->
name|retval
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"start exec of %s, fp=%d\n"
operator|,
name|s
operator|,
name|fp
operator|-
name|frame
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
operator|(
name|Node
operator|*
operator|)
operator|(
name|fcn
operator|->
name|sval
operator|)
argument_list|)
expr_stmt|;
comment|/* execute body */
name|dprintf
argument_list|(
operator|(
literal|"finished exec of %s, fp=%d\n"
operator|,
name|s
operator|,
name|fp
operator|-
name|frame
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndef
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|t
init|=
name|fp
operator|->
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isarr
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|csub
operator|==
name|CCOPY
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ncall
condition|)
block|{
name|freesymtab
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|csub
operator|=
name|CTEMP
expr_stmt|;
block|}
else|else
block|{
name|oargs
index|[
name|i
index|]
operator|->
name|tval
operator|=
name|t
operator|->
name|tval
expr_stmt|;
name|oargs
index|[
name|i
index|]
operator|->
name|tval
operator|&=
operator|~
operator|(
name|STR
operator||
name|NUM
operator||
name|DONTFREE
operator|)
expr_stmt|;
name|oargs
index|[
name|i
index|]
operator|->
name|sval
operator|=
name|t
operator|->
name|sval
expr_stmt|;
name|tempfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|y
condition|)
block|{
comment|/* kludge to prevent freeing twice */
name|t
operator|->
name|csub
operator|=
name|CTEMP
expr_stmt|;
name|tempfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|tempfree
argument_list|(
name|fcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|isexit
argument_list|(
name|y
argument_list|)
operator|||
name|isnext
argument_list|(
name|y
argument_list|)
condition|)
return|return
name|y
return|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* this can free twice! */
name|z
operator|=
name|fp
operator|->
name|retval
expr_stmt|;
comment|/* return value */
name|dprintf
argument_list|(
operator|(
literal|"%s returns %g |%s| %o\n"
operator|,
name|s
operator|,
name|getfval
argument_list|(
name|z
argument_list|)
operator|,
name|getsval
argument_list|(
name|z
argument_list|)
operator|,
name|z
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|--
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|copycell
parameter_list|(
name|Cell
modifier|*
name|x
parameter_list|)
comment|/* make a copy of a cell in a temp */
block|{
name|Cell
modifier|*
name|y
decl_stmt|;
name|y
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|y
operator|->
name|csub
operator|=
name|CCOPY
expr_stmt|;
comment|/* prevents freeing until call is over */
name|y
operator|->
name|nval
operator|=
name|x
operator|->
name|nval
expr_stmt|;
name|y
operator|->
name|sval
operator|=
name|x
operator|->
name|sval
condition|?
name|tostring
argument_list|(
name|x
operator|->
name|sval
argument_list|)
else|:
name|NULL
expr_stmt|;
name|y
operator|->
name|fval
operator|=
name|x
operator|->
name|fval
expr_stmt|;
name|y
operator|->
name|tval
operator|=
name|x
operator|->
name|tval
operator|&
operator|~
operator|(
name|CON
operator||
name|FLD
operator||
name|REC
operator||
name|DONTFREE
operator|)
expr_stmt|;
comment|/* copy is not constant or field */
comment|/* is DONTFREE right? */
return|return
name|y
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|arg
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* nth argument of a function */
block|{
name|n
operator|=
operator|(
name|int
operator|)
name|a
index|[
literal|0
index|]
expr_stmt|;
comment|/* argument number, counting from 0 */
name|dprintf
argument_list|(
operator|(
literal|"arg(%d), fp->nargs=%d\n"
operator|,
name|n
operator|,
name|fp
operator|->
name|nargs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|+
literal|1
operator|>
name|fp
operator|->
name|nargs
condition|)
name|ERROR
literal|"argument #%d of function %s was not supplied"
operator|,
name|n
operator|+
literal|1
operator|,
name|fp
operator|->
name|fcncell
operator|->
name|nval
name|FATAL
expr_stmt|;
return|return
name|fp
operator|->
name|args
index|[
name|n
index|]
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|jump
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* break, continue, next, continue, return */
block|{
specifier|register
name|Cell
modifier|*
name|y
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|EXIT
case|:
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|errorflag
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
name|RETURN
case|:
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|y
operator|->
name|tval
operator|&
operator|(
name|STR
operator||
name|NUM
operator|)
operator|)
operator|==
operator|(
name|STR
operator||
name|NUM
operator|)
condition|)
block|{
name|setsval
argument_list|(
name|fp
operator|->
name|retval
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|retval
operator|->
name|fval
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|fp
operator|->
name|retval
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|->
name|tval
operator|&
name|STR
condition|)
name|setsval
argument_list|(
name|fp
operator|->
name|retval
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|->
name|tval
operator|&
name|NUM
condition|)
name|setfval
argument_list|(
name|fp
operator|->
name|retval
argument_list|,
name|getfval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* can't happen */
name|ERROR
literal|"bad type variable %d"
operator|,
name|y
operator|->
name|tval
name|FATAL
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|jret
operator|)
return|;
case|case
name|NEXT
case|:
return|return
operator|(
name|jnext
operator|)
return|;
case|case
name|BREAK
case|:
return|return
operator|(
name|jbreak
operator|)
return|;
case|case
name|CONTINUE
case|:
return|return
operator|(
name|jcont
operator|)
return|;
default|default:
comment|/* can't happen */
name|ERROR
literal|"illegal jump type %d"
operator|,
name|n
name|FATAL
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* not reached */
block|}
end_function

begin_function
name|Cell
modifier|*
name|getline
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* get next line from specific input */
block|{
comment|/* a[0] is variable, a[1] is operator, a[2] is filename */
specifier|register
name|Cell
modifier|*
name|r
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|uchar
name|buf
index|[
name|RECSIZE
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* in case someone is waiting for a prompt */
name|r
operator|=
name|gettemp
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* getline< file */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* filename */
if|if
condition|(
operator|(
name|int
operator|)
name|a
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
comment|/* input pipe */
name|a
index|[
literal|1
index|]
operator|=
operator|(
name|Node
operator|*
operator|)
name|LE
expr_stmt|;
comment|/* arbitrary flag */
name|fp
operator|=
name|openfile
argument_list|(
operator|(
name|int
operator|)
name|a
index|[
literal|1
index|]
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|n
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|n
operator|=
name|readrec
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* getline var<file */
name|setsval
argument_list|(
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* getline<file */
if|if
condition|(
operator|!
operator|(
name|recloc
operator|->
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|recloc
operator|->
name|sval
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|record
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|recloc
operator|->
name|sval
operator|=
name|record
expr_stmt|;
name|recloc
operator|->
name|tval
operator|=
name|REC
operator||
name|STR
operator||
name|DONTFREE
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|recloc
operator|->
name|sval
argument_list|)
condition|)
block|{
name|recloc
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|recloc
operator|->
name|sval
argument_list|)
expr_stmt|;
name|recloc
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
name|donerec
operator|=
literal|1
expr_stmt|;
name|donefld
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* bare getline; use current input */
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
comment|/* getline */
name|n
operator|=
name|getrec
argument_list|(
name|record
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* getline var */
name|n
operator|=
name|getrec
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|setsval
argument_list|(
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|setfval
argument_list|(
name|r
argument_list|,
operator|(
name|Awkfloat
operator|)
name|n
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|getnf
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* get NF */
block|{
if|if
condition|(
name|donefld
operator|==
literal|0
condition|)
name|fldbld
argument_list|()
expr_stmt|;
return|return
operator|(
name|Cell
operator|*
operator|)
name|a
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|array
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] is symtab, a[1] is list of subscripts */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s
decl_stmt|;
specifier|register
name|Node
modifier|*
name|np
decl_stmt|;
name|uchar
name|buf
index|[
name|RECSIZE
index|]
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Cell* for symbol table */
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|a
index|[
literal|1
index|]
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* subscript */
name|s
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|nnext
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|SUBSEP
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"making %s into an array\n"
operator|,
name|x
operator|->
name|nval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|x
argument_list|)
condition|)
name|xfree
argument_list|(
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator|&=
operator|~
operator|(
name|STR
operator||
name|NUM
operator||
name|DONTFREE
operator|)
expr_stmt|;
name|x
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|x
operator|->
name|sval
operator|=
operator|(
name|uchar
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|setsymtab
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|z
operator|->
name|ctype
operator|=
name|OCELL
expr_stmt|;
name|z
operator|->
name|csub
operator|=
name|CVAR
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|adelete
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] is symtab, a[1] is list of subscripts */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Node
modifier|*
name|np
decl_stmt|;
name|uchar
name|buf
index|[
name|RECSIZE
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Cell* for symbol table */
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|a
index|[
literal|1
index|]
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* subscript */
name|s
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|nnext
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|SUBSEP
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|freeelem
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|intest
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] is index (list), a[1] is symtab */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|ap
decl_stmt|,
modifier|*
name|k
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|RECSIZE
index|]
decl_stmt|;
name|uchar
modifier|*
name|s
decl_stmt|;
name|ap
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* array name */
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"making %s into an array\n"
operator|,
name|ap
operator|->
name|nval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|ap
argument_list|)
condition|)
name|xfree
argument_list|(
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|ap
operator|->
name|tval
operator|&=
operator|~
operator|(
name|STR
operator||
name|NUM
operator||
name|DONTFREE
operator|)
expr_stmt|;
name|ap
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|ap
operator|->
name|sval
operator|=
operator|(
name|uchar
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|a
index|[
literal|0
index|]
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nnext
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expr */
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nnext
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
operator|*
name|SUBSEP
argument_list|)
expr_stmt|;
block|}
name|k
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
else|else
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|matchop
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* ~ and match() */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|int
function_decl|(
modifier|*
name|mf
function_decl|)
parameter_list|(
name|fa
modifier|*
parameter_list|,
name|uchar
modifier|*
parameter_list|)
init|=
name|match
operator|,
function_decl|mode
init|=
literal|0
function_decl|;
if|if
condition|(
name|n
operator|==
name|MATCHFCN
condition|)
block|{
name|mf
operator|=
name|pmatch
expr_stmt|;
name|mode
operator|=
literal|1
expr_stmt|;
block|}
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* a[1] = target text */
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* a[1] == 0: already-compiled reg expr */
name|i
operator|=
call|(
modifier|*
name|mf
call|)
argument_list|(
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|2
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* a[2] = regular expr */
name|t
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|t
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|i
operator|=
call|(
modifier|*
name|mf
call|)
argument_list|(
name|pfa
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|MATCHFCN
condition|)
block|{
name|int
name|start
init|=
name|patbeg
operator|-
name|s
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|patlen
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
name|setfval
argument_list|(
name|rstartloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|start
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|rlengthloc
argument_list|,
operator|(
name|Awkfloat
operator|)
name|patlen
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|start
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
name|MATCH
operator|&&
name|i
operator|==
literal|1
operator|||
name|n
operator|==
name|NOTMATCH
operator|&&
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|boolop
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] || a[1], a[0]&& a[1], !a[0] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|BOR
case|:
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|AND
case|:
if|if
condition|(
operator|!
name|i
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|istrue
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|NOT
case|:
if|if
condition|(
name|i
condition|)
return|return
operator|(
name|false
operator|)
return|;
else|else
return|return
operator|(
name|true
operator|)
return|;
default|default:
comment|/* can't happen */
name|ERROR
literal|"unknown boolean operator %d"
operator|,
name|n
name|FATAL
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|Cell
modifier|*
name|relop
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0< a[1], etc. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Awkfloat
name|j
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|tval
operator|&
name|NUM
operator|&&
name|y
operator|->
name|tval
operator|&
name|NUM
condition|)
block|{
name|j
operator|=
name|x
operator|->
name|fval
operator|-
name|y
operator|->
name|fval
expr_stmt|;
name|i
operator|=
name|j
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
name|j
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strcmp
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|LT
case|:
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|LE
case|:
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|NE
case|:
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|EQ
case|:
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|GE
case|:
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
case|case
name|GT
case|:
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
else|else
return|return
operator|(
name|false
operator|)
return|;
default|default:
comment|/* can't happen */
name|ERROR
literal|"unknown relational operator %d"
operator|,
name|n
name|FATAL
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|void
name|tfree
parameter_list|(
name|Cell
modifier|*
name|a
parameter_list|)
comment|/* free a tempcell */
block|{
if|if
condition|(
name|freeable
argument_list|(
name|a
argument_list|)
condition|)
name|xfree
argument_list|(
name|a
operator|->
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|tmps
condition|)
name|ERROR
literal|"tempcell list is curdled"
name|FATAL
expr_stmt|;
name|a
operator|->
name|cnext
operator|=
name|tmps
expr_stmt|;
name|tmps
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|gettemp
parameter_list|(
name|void
parameter_list|)
comment|/* get a tempcell */
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|tmps
condition|)
block|{
name|tmps
operator|=
operator|(
name|Cell
operator|*
operator|)
name|calloc
argument_list|(
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
condition|)
name|ERROR
literal|"out of space for temporaries"
name|FATAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
name|tmps
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cnext
operator|=
operator|&
name|tmps
index|[
name|i
index|]
expr_stmt|;
name|tmps
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cnext
operator|=
literal|0
expr_stmt|;
block|}
name|x
operator|=
name|tmps
expr_stmt|;
name|tmps
operator|=
name|x
operator|->
name|cnext
expr_stmt|;
operator|*
name|x
operator|=
name|tempcell
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|indirect
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* $( a[0] ) */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
operator|&&
operator|!
name|isnumber
argument_list|(
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
comment|/* suspicion! */
name|ERROR
literal|"illegal field $(%s), name \"%s\""
operator|,
name|s
operator|,
name|x
operator|->
name|nval
name|FATAL
expr_stmt|;
comment|/* can x->nval ever be null??? */
comment|/* ERROR "illegal field $(%s)", s FATAL; */
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|fieldadr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|x
operator|->
name|ctype
operator|=
name|OCELL
expr_stmt|;
name|x
operator|->
name|csub
operator|=
name|CFLD
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|substr
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* substr(a[0], a[1], a[2]) */
block|{
specifier|register
name|int
name|k
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s
decl_stmt|;
name|int
name|temp
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|z
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|s
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|k
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|1
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|tempfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|m
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|<=
literal|0
condition|)
name|m
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|>
name|k
condition|)
name|m
operator|=
name|k
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
name|getfval
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
name|k
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
name|k
operator|-
name|m
condition|)
name|n
operator|=
name|k
operator|-
name|m
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"substr: m=%d, n=%d, s=%s\n"
operator|,
name|m
operator|,
name|n
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|temp
operator|=
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
expr_stmt|;
comment|/* with thanks to John Linderman */
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|setsval
argument_list|(
name|y
argument_list|,
name|s
operator|+
name|m
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
index|[
name|n
operator|+
name|m
operator|-
literal|1
index|]
operator|=
name|temp
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|sindex
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* index(a[0], a[1]) */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|Awkfloat
name|v
init|=
literal|0.0
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s1
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|s2
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|s1
init|;
operator|*
name|p1
operator|!=
literal|'\0'
condition|;
name|p1
operator|++
control|)
block|{
for|for
control|(
name|q
operator|=
name|p1
operator|,
name|p2
operator|=
name|s2
init|;
operator|*
name|p2
operator|!=
literal|'\0'
operator|&&
operator|*
name|q
operator|==
operator|*
name|p2
condition|;
name|q
operator|++
operator|,
name|p2
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p2
operator|==
literal|'\0'
condition|)
block|{
name|v
operator|=
call|(
name|Awkfloat
call|)
argument_list|(
name|p1
operator|-
name|s1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* origin 1 */
break|break;
block|}
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|z
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_macro
name|format
argument_list|(
argument|uchar *buf
argument_list|,
argument|int bufsize
argument_list|,
argument|uchar *s
argument_list|,
argument|Node *a
argument_list|)
end_macro

begin_comment
comment|/* printf-like conversions */
end_comment

begin_block
block|{
name|uchar
name|fmt
index|[
name|RECSIZE
index|]
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|os
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|;
name|os
operator|=
name|s
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|buf
operator|>=
name|bufsize
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'%'
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|t
operator|=
name|fmt
init|;
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|)
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'l'
operator|&&
operator|*
name|s
operator|!=
literal|'h'
operator|&&
operator|*
name|s
operator|!=
literal|'L'
condition|)
break|break;
comment|/* the ansi panoply */
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|nnext
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
operator|-
literal|1
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fmt
operator|+
name|strlen
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|t
operator|>=
name|fmt
operator|+
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
condition|)
name|ERROR
literal|"format item %.30s... too long"
operator|,
name|os
name|FATAL
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'g'
case|:
case|case
literal|'E'
case|:
case|case
literal|'G'
case|:
name|flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
name|flag
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'l'
condition|)
break|break;
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|=
literal|'l'
expr_stmt|;
operator|*
name|t
operator|=
literal|'d'
expr_stmt|;
operator|*
operator|++
name|t
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'u'
case|:
name|flag
operator|=
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'l'
condition|?
literal|2
else|:
literal|3
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flag
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flag
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|ERROR
literal|"weird printf conversion %s"
operator|,
name|fmt
name|WARNING
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
name|ERROR
literal|"not enough args in printf(%s)"
operator|,
name|os
name|FATAL
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|nnext
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0
case|:
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"%s"
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
comment|/* unknown, so dump it too */
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"%s"
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fmt
argument_list|,
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fmt
argument_list|,
operator|(
name|long
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fmt
argument_list|,
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|bufsize
condition|)
name|ERROR
literal|"huge string (%d chars) in printf %.30s..."
operator|,
name|n
operator|,
name|t
name|FATAL
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fmt
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|isnum
argument_list|(
name|x
argument_list|)
condition|?
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fmt
argument_list|,
operator|(
name|int
operator|)
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|fmt
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|nnext
control|)
comment|/* evaluate any remaining args */
name|execute
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
name|Cell
modifier|*
name|asprintf
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* sprintf(a[0]) */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
specifier|register
name|Node
modifier|*
name|y
decl_stmt|;
name|uchar
name|buf
index|[
literal|3
operator|*
name|RECSIZE
index|]
decl_stmt|;
name|y
operator|=
name|a
index|[
literal|0
index|]
operator|->
name|nnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERROR
literal|"sprintf string %.30s... too long"
operator|,
name|buf
name|FATAL
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|sval
operator|=
name|tostring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|STR
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|aprintf
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* printf */
block|{
comment|/* a[0] is list of args, starting with format string */
comment|/* a[1] is redirection operator, a[2] is redirection file */
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
specifier|register
name|Node
modifier|*
name|y
decl_stmt|;
name|uchar
name|buf
index|[
literal|3
operator|*
name|RECSIZE
index|]
decl_stmt|;
name|y
operator|=
name|a
index|[
literal|0
index|]
operator|->
name|nnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERROR
literal|"printf string %.30s... too long"
operator|,
name|buf
name|FATAL
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|ERROR
literal|"write error on stdout"
name|FATAL
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|redirect
argument_list|(
operator|(
name|int
operator|)
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|ERROR
literal|"write error on %s"
operator|,
name|filename
argument_list|(
argument|fp
argument_list|)
name|FATAL
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|arith
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] + a[1], etc.  also -a[0] */
block|{
name|Awkfloat
name|i
decl_stmt|,
name|j
decl_stmt|;
name|double
name|v
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|UMINUS
condition|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|j
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ADD
case|:
name|i
operator|+=
name|j
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|i
operator|-=
name|j
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|i
operator|*=
name|j
expr_stmt|;
break|break;
case|case
name|DIVIDE
case|:
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|ERROR
literal|"division by zero"
name|FATAL
expr_stmt|;
name|i
operator|/=
name|j
expr_stmt|;
break|break;
case|case
name|MOD
case|:
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|ERROR
literal|"division by zero in mod"
name|FATAL
expr_stmt|;
name|modf
argument_list|(
name|i
operator|/
name|j
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|i
operator|=
name|i
operator|-
name|j
operator|*
name|v
expr_stmt|;
break|break;
case|case
name|UMINUS
case|:
name|i
operator|=
operator|-
name|i
expr_stmt|;
break|break;
case|case
name|POWER
case|:
if|if
condition|(
name|j
operator|>=
literal|0
operator|&&
name|modf
argument_list|(
name|j
argument_list|,
operator|&
name|v
argument_list|)
operator|==
literal|0.0
condition|)
comment|/* pos integer exponent */
name|i
operator|=
name|ipow
argument_list|(
name|i
argument_list|,
operator|(
name|int
operator|)
name|j
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|errcheck
argument_list|(
name|pow
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|"pow"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|ERROR
literal|"illegal arithmetic operator %d"
operator|,
name|n
name|FATAL
expr_stmt|;
block|}
name|setfval
argument_list|(
name|z
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|double
name|ipow
parameter_list|(
name|double
name|x
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* x**n.  ought to be done by pow, but isn't always */
block|{
name|double
name|v
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
literal|1
return|;
name|v
operator|=
name|ipow
argument_list|(
name|x
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|%
literal|2
operator|==
literal|0
condition|)
return|return
name|v
operator|*
name|v
return|;
else|else
return|return
name|x
operator|*
name|v
operator|*
name|v
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|incrdecr
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0]++, etc. */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|z
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
name|Awkfloat
name|xf
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|xf
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|n
operator|==
name|PREINCR
operator|||
name|n
operator|==
name|POSTINCR
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|PREINCR
operator|||
name|n
operator|==
name|PREDECR
condition|)
block|{
name|setfval
argument_list|(
name|x
argument_list|,
name|xf
operator|+
name|k
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|z
argument_list|,
name|xf
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
name|xf
operator|+
name|k
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|assign
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] = a[1], a[0] += a[1], etc. */
block|{
comment|/* this is subtle; don't muck with it. */
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Awkfloat
name|xf
decl_stmt|,
name|yf
decl_stmt|;
name|double
name|v
decl_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|ASSIGN
condition|)
block|{
comment|/* ordinary assignment */
if|if
condition|(
name|x
operator|==
name|y
operator|&&
operator|!
operator|(
name|x
operator|->
name|tval
operator|&
operator|(
name|FLD
operator||
name|REC
operator|)
operator|)
condition|)
comment|/* self-assignment: */
empty_stmt|;
comment|/* leave alone unless it's a field */
elseif|else
if|if
condition|(
operator|(
name|y
operator|->
name|tval
operator|&
operator|(
name|STR
operator||
name|NUM
operator|)
operator|)
operator|==
operator|(
name|STR
operator||
name|NUM
operator|)
condition|)
block|{
name|setsval
argument_list|(
name|x
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|x
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|->
name|tval
operator|&
name|STR
condition|)
name|setsval
argument_list|(
name|x
argument_list|,
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|->
name|tval
operator|&
name|NUM
condition|)
name|setfval
argument_list|(
name|x
argument_list|,
name|getfval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|funnyvar
argument_list|(
name|y
argument_list|,
literal|"read value of"
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|xf
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|yf
operator|=
name|getfval
argument_list|(
name|y
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|ADDEQ
case|:
name|xf
operator|+=
name|yf
expr_stmt|;
break|break;
case|case
name|SUBEQ
case|:
name|xf
operator|-=
name|yf
expr_stmt|;
break|break;
case|case
name|MULTEQ
case|:
name|xf
operator|*=
name|yf
expr_stmt|;
break|break;
case|case
name|DIVEQ
case|:
if|if
condition|(
name|yf
operator|==
literal|0
condition|)
name|ERROR
literal|"division by zero in /="
name|FATAL
expr_stmt|;
name|xf
operator|/=
name|yf
expr_stmt|;
break|break;
case|case
name|MODEQ
case|:
if|if
condition|(
name|yf
operator|==
literal|0
condition|)
name|ERROR
literal|"division by zero in %%="
name|FATAL
expr_stmt|;
name|modf
argument_list|(
name|xf
operator|/
name|yf
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|xf
operator|=
name|xf
operator|-
name|yf
operator|*
name|v
expr_stmt|;
break|break;
case|case
name|POWEQ
case|:
if|if
condition|(
name|yf
operator|>=
literal|0
operator|&&
name|modf
argument_list|(
name|yf
argument_list|,
operator|&
name|v
argument_list|)
operator|==
literal|0.0
condition|)
comment|/* pos integer exponent */
name|xf
operator|=
name|ipow
argument_list|(
name|xf
argument_list|,
operator|(
name|int
operator|)
name|yf
argument_list|)
expr_stmt|;
else|else
name|xf
operator|=
name|errcheck
argument_list|(
name|pow
argument_list|(
name|xf
argument_list|,
name|yf
argument_list|)
argument_list|,
literal|"pow"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERROR
literal|"illegal assignment operator %d"
operator|,
name|n
name|FATAL
expr_stmt|;
break|break;
block|}
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
name|xf
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|cat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|q
parameter_list|)
comment|/* a[0] cat a[1] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|z
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|n1
operator|=
name|strlen
argument_list|(
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|n2
operator|=
name|strlen
argument_list|(
name|y
operator|->
name|sval
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|n1
operator|+
name|n2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space concatenating %.15s... and %.15s..."
operator|,
name|x
operator|->
name|sval
operator|,
name|y
operator|->
name|sval
name|FATAL
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|x
operator|->
name|sval
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
name|n1
argument_list|,
name|y
operator|->
name|sval
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|z
operator|->
name|sval
operator|=
name|s
expr_stmt|;
name|z
operator|->
name|tval
operator|=
name|STR
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|pastat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] { a[1] } */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|dopa2
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0], a[1] { a[2] } */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
specifier|register
name|int
name|pair
decl_stmt|;
name|pair
operator|=
operator|(
name|int
operator|)
name|a
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|pairstack
index|[
name|pair
index|]
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
name|pairstack
index|[
name|pair
index|]
operator|=
literal|1
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pairstack
index|[
name|pair
index|]
operator|==
literal|1
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
name|pairstack
index|[
name|pair
index|]
operator|=
literal|0
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|split
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* split(a[0], a[1], a[2]); a[3] is type */
block|{
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|sep
decl_stmt|;
name|uchar
modifier|*
name|t
decl_stmt|,
name|temp
decl_stmt|,
name|num
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|int
name|n
decl_stmt|,
name|tempstat
decl_stmt|;
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* source string */
name|s
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|==
literal|0
condition|)
comment|/* fs string */
name|fs
operator|=
operator|*
name|FS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|a
index|[
literal|3
index|]
operator|==
name|STRING
condition|)
block|{
comment|/* split(str,arr,"string") */
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fs
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|int
operator|)
name|a
index|[
literal|3
index|]
operator|==
name|REGEXPR
condition|)
name|fs
operator|=
operator|(
name|uchar
operator|*
operator|)
literal|"(regexpr)"
expr_stmt|;
comment|/* split(str,arr,/regexpr/) */
else|else
name|ERROR
literal|"illegal type of split()"
name|FATAL
expr_stmt|;
name|sep
operator|=
operator|*
name|fs
expr_stmt|;
name|ap
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* array name */
name|freesymtab
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"split: s=|%s|, a=%s, sep=|%s|\n"
operator|,
name|s
operator|,
name|ap
operator|->
name|nval
operator|,
name|fs
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
name|ap
operator|->
name|tval
operator||=
name|ARR
expr_stmt|;
name|ap
operator|->
name|sval
operator|=
operator|(
name|uchar
operator|*
operator|)
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
name|strlen
argument_list|(
name|fs
argument_list|)
operator|>
literal|1
operator|||
operator|(
name|int
operator|)
name|a
index|[
literal|3
index|]
operator|==
name|REGEXPR
condition|)
block|{
comment|/* reg expr */
name|fa
modifier|*
name|pfa
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|a
index|[
literal|3
index|]
operator|==
name|REGEXPR
condition|)
block|{
comment|/* it's ready already */
name|pfa
operator|=
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|pfa
operator|=
name|makedfa
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nematch
argument_list|(
name|pfa
argument_list|,
name|s
argument_list|)
condition|)
block|{
name|tempstat
operator|=
name|pfa
operator|->
name|initstat
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
name|patbeg
expr_stmt|;
operator|*
name|patbeg
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|s
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
name|atof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|patbeg
operator|=
name|temp
expr_stmt|;
name|s
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|patbeg
operator|+
name|patlen
operator|-
literal|1
operator|)
operator|==
literal|0
operator|||
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|setsymtab
argument_list|(
name|num
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
goto|goto
name|spdone
goto|;
block|}
block|}
do|while
condition|(
name|nematch
argument_list|(
name|pfa
argument_list|,
name|s
argument_list|)
condition|)
do|;
block|}
name|n
operator|++
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|s
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
name|atof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|s
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
name|spdone
label|:
name|pfa
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sep
operator|==
literal|' '
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
break|break;
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
do|do
name|s
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
do|;
name|temp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|t
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
name|atof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
name|sep
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
name|temp
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num
argument_list|,
literal|"%d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
name|t
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
name|atof
argument_list|(
operator|(
name|char
operator|*
operator|)
name|t
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|num
argument_list|,
name|t
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|tempfree
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
literal|0
operator|&&
operator|(
name|int
operator|)
name|a
index|[
literal|3
index|]
operator|==
name|STRING
condition|)
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|condexpr
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* a[0] ? a[1] : a[2] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|ifstat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* if (a[0]) a[1]; else a[2] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
block|{
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|whilestat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* while (a[0]) a[1] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|x
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|dostat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* do a[0]; while(a[1]) */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|forstat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* for (a[0]; a[1]; a[2]) a[3] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|istrue
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|else
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
comment|/* turn off break */
return|return
name|true
return|;
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|instat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* for (a[0] in a[1]) a[2] */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|arrayp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ncp
decl_stmt|;
name|Array
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vp
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arrayp
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|arrayp
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|tp
operator|=
operator|(
name|Array
operator|*
operator|)
name|arrayp
operator|->
name|sval
expr_stmt|;
name|tempfree
argument_list|(
name|arrayp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/* this routine knows too much */
for|for
control|(
name|cp
operator|=
name|tp
operator|->
name|tab
index|[
name|i
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|ncp
control|)
block|{
name|setsval
argument_list|(
name|vp
argument_list|,
name|cp
operator|->
name|nval
argument_list|)
expr_stmt|;
name|ncp
operator|=
name|cp
operator|->
name|cnext
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbreak
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|isnext
argument_list|(
name|x
argument_list|)
operator|||
name|isexit
argument_list|(
name|x
argument_list|)
operator|||
name|isret
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tempfree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* if someone ever wants to run over the arrays in sorted order, */
end_comment

begin_comment
comment|/* here it is.  but it will likely run slower, not faster. */
end_comment

begin_comment
comment|/*  *int qstrcmp(p, q)  *	uchar **p, **q;  *{  *	return strcmp(*p, *q);  *}  */
end_comment

begin_comment
comment|/*Cell *instat(Node **a, int n)	/* for (a[0] in a[1]) a[2] */
end_comment

begin_comment
comment|/*{ /*	register Cell *x, *vp, *arrayp, *cp, *ncp, *ret; /*	Array *tp; /*	int i, ne; /*#define BIGENOUGH 1000 /*	uchar *elems[BIGENOUGH], **ep; /* /*	vp = execute(a[0]); /*	arrayp = execute(a[1]); /*	if (!isarr(arrayp)) /*		ERROR "%s is not an array", arrayp->nval FATAL; /*	tp = (Array *) arrayp->sval; /*	tempfree(arrayp); /*	ep = elems; /*	ret = true; /*	if (tp->nelem>= BIGENOUGH) /*		ep = (uchar **) malloc(tp->nelem * sizeof(char *)); /* /*	for (i = ne = 0; i< tp->size; i++) /*		for (cp = tp->tab[i]; cp != NULL; cp = cp->cnext) /*			ep[ne++] = cp->nval; /*	if (ne != tp->nelem) /*		ERROR "can't happen: lost elems %d vs. %d", ne, tp->nelem FATAL; /*	qsort(ep, ne, sizeof(char *), qstrcmp); /*	for (i = 0; i< ne; i++) { /*		setsval(vp, ep[i]); /*		x = execute(a[2]); /*		if (isbreak(x)) { /*			tempfree(vp); /*			break; /*		} /*		if (isnext(x) || isexit(x) || isret(x)) { /*			tempfree(vp); /*			ret = x; /*			break; /*		} /*		tempfree(x); /*	} /*	if (ep != elems) /*		free(ep); /*	return ret; /*} */
end_comment

begin_function
name|Cell
modifier|*
name|bltin
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* builtin functions. a[0] is type, a[1] is arg list */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|Awkfloat
name|u
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|uchar
modifier|*
name|p
decl_stmt|,
name|buf
index|[
name|RECSIZE
index|]
decl_stmt|;
name|Node
modifier|*
name|nextarg
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|t
operator|=
operator|(
name|int
operator|)
name|a
index|[
literal|0
index|]
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|a
index|[
literal|1
index|]
operator|->
name|nnext
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|FLENGTH
case|:
name|u
operator|=
name|strlen
argument_list|(
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOG
case|:
name|u
operator|=
name|errcheck
argument_list|(
name|log
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|"log"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FINT
case|:
name|modf
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|FEXP
case|:
name|u
operator|=
name|errcheck
argument_list|(
name|exp
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|"exp"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSQRT
case|:
name|u
operator|=
name|errcheck
argument_list|(
name|sqrt
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
literal|"sqrt"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSIN
case|:
name|u
operator|=
name|sin
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCOS
case|:
name|u
operator|=
name|cos
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FATAN
case|:
if|if
condition|(
name|nextarg
operator|==
literal|0
condition|)
block|{
name|ERROR
literal|"atan2 requires two arguments; returning 1.0"
name|WARNING
expr_stmt|;
name|u
operator|=
literal|1.0
expr_stmt|;
block|}
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
operator|->
name|nnext
argument_list|)
expr_stmt|;
name|u
operator|=
name|atan2
argument_list|(
name|getfval
argument_list|(
name|x
argument_list|)
argument_list|,
name|getfval
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
expr_stmt|;
block|}
break|break;
case|case
name|FSYSTEM
case|:
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* in case something is buffered already */
name|u
operator|=
operator|(
name|Awkfloat
operator|)
name|system
argument_list|(
operator|(
name|char
operator|*
operator|)
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
literal|256
expr_stmt|;
comment|/* 256 is unix-dep */
break|break;
case|case
name|FRAND
case|:
comment|/* in principle, rand() returns something in 0..RAND_MAX */
name|u
operator|=
call|(
name|Awkfloat
call|)
argument_list|(
name|rand
argument_list|()
operator|%
name|RAND_MAX
argument_list|)
operator|/
name|RAND_MAX
expr_stmt|;
break|break;
case|case
name|FSRAND
case|:
if|if
condition|(
name|x
operator|->
name|tval
operator|&
name|REC
condition|)
comment|/* no argument provided */
name|u
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|getfval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|srand
argument_list|(
operator|(
name|int
operator|)
name|u
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
name|int
operator|)
name|u
expr_stmt|;
break|break;
case|case
name|FTOUPPER
case|:
case|case
name|FTOLOWER
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|FTOUPPER
condition|)
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|x
return|;
case|case
name|FFLUSH
case|:
if|if
condition|(
operator|(
name|fp
operator|=
name|openfile
argument_list|(
name|GT
argument_list|,
name|getsval
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|u
operator|=
name|EOF
expr_stmt|;
else|else
name|u
operator|=
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|ERROR
literal|"illegal function type %d"
operator|,
name|t
name|FATAL
expr_stmt|;
break|break;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|setfval
argument_list|(
name|x
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextarg
operator|!=
literal|0
condition|)
block|{
name|ERROR
literal|"warning: function has too many arguments"
name|WARNING
expr_stmt|;
for|for
control|(
init|;
name|nextarg
condition|;
name|nextarg
operator|=
name|nextarg
operator|->
name|nnext
control|)
name|execute
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|printstat
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
comment|/* print a[0] */
block|{
specifier|register
name|Node
modifier|*
name|x
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|y
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* a[1] is redirection operator, a[2] is file */
name|fp
operator|=
name|stdout
expr_stmt|;
else|else
name|fp
operator|=
name|redirect
argument_list|(
operator|(
name|int
operator|)
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|a
index|[
literal|0
index|]
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|nnext
control|)
block|{
name|y
operator|=
name|execute
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|nnext
operator|==
name|NULL
condition|)
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|ORS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|OFS
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|ERROR
literal|"write error on %s"
operator|,
name|filename
argument_list|(
argument|fp
argument_list|)
name|FATAL
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|nullproc
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|n
expr_stmt|;
name|a
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|redirect
parameter_list|(
name|int
name|a
parameter_list|,
name|Node
modifier|*
name|b
parameter_list|)
comment|/* set up all i/o redirections */
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Cell
modifier|*
name|x
decl_stmt|;
name|uchar
modifier|*
name|fname
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|fname
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fp
operator|=
name|openfile
argument_list|(
name|a
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|ERROR
literal|"can't open file %s"
operator|,
name|fname
name|FATAL
expr_stmt|;
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_struct
struct|struct
name|files
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|uchar
modifier|*
name|fname
decl_stmt|;
name|int
name|mode
decl_stmt|;
comment|/* '|', 'a', 'w' => LE/LT, GT */
block|}
name|files
index|[
name|FOPEN_MAX
index|]
init|=
block|{
block|{
name|stdin
block|,
literal|"/dev/stdin"
block|,
name|LT
block|}
block|,
comment|/* watch out: don't free this! */
block|{
name|stdout
block|,
literal|"/dev/stdout"
block|,
name|GT
block|}
block|,
block|{
name|stderr
block|,
literal|"/dev/stderr"
block|,
name|GT
block|}
block|}
struct|;
end_struct

begin_function
name|FILE
modifier|*
name|openfile
parameter_list|(
name|int
name|a
parameter_list|,
name|uchar
modifier|*
name|us
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
name|us
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
name|ERROR
literal|"null file name in print or getline"
name|FATAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOPEN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|a
operator|==
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|||
name|a
operator|==
name|APPEND
operator|&&
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|GT
condition|)
return|return
name|files
index|[
name|i
index|]
operator|.
name|fp
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOPEN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|FOPEN_MAX
condition|)
name|ERROR
literal|"%s makes too many open files"
operator|,
name|s
name|FATAL
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* force a semblance of order */
name|m
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|GT
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|APPEND
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|s
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|m
operator|=
name|GT
expr_stmt|;
comment|/* so can mix> and>> */
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|'|'
condition|)
block|{
comment|/* output pipe */
name|fp
operator|=
name|popen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|LE
condition|)
block|{
comment|/* input pipe */
name|fp
operator|=
name|popen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|LT
condition|)
block|{
comment|/* getline<file */
name|fp
operator|=
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
name|stdin
else|:
name|fopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* "-" is stdin */
block|}
else|else
comment|/* can't happen */
name|ERROR
literal|"illegal redirection %d"
operator|,
name|a
name|FATAL
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|m
expr_stmt|;
block|}
return|return
name|fp
return|;
block|}
end_function

begin_function
name|uchar
modifier|*
name|filename
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOPEN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fp
operator|==
name|files
index|[
name|i
index|]
operator|.
name|fp
condition|)
return|return
name|files
index|[
name|i
index|]
operator|.
name|fname
return|;
return|return
literal|"???"
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|closefile
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|;
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
name|n
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOPEN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|&&
name|strcmp
argument_list|(
name|x
operator|->
name|sval
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
condition|)
name|ERROR
literal|"i/o error occurred on %s"
operator|,
name|files
index|[
name|i
index|]
operator|.
name|fname
name|WARNING
expr_stmt|;
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
literal|'|'
operator|||
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|LE
condition|)
name|stat
operator|=
name|pclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
else|else
name|stat
operator|=
name|fclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|EOF
condition|)
name|ERROR
literal|"i/o error occurred closing %s"
operator|,
name|files
index|[
name|i
index|]
operator|.
name|fname
name|WARNING
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
comment|/* don't do /dev/std... */
name|xfree
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|=
name|NULL
expr_stmt|;
comment|/* watch out for ref thru this */
name|files
index|[
name|i
index|]
operator|.
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|void
name|closeall
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|stat
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FOPEN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fp
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
condition|)
name|ERROR
literal|"i/o error occurred on %s"
operator|,
name|files
index|[
name|i
index|]
operator|.
name|fname
name|WARNING
expr_stmt|;
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
literal|'|'
operator|||
name|files
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|LE
condition|)
name|stat
operator|=
name|pclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
else|else
name|stat
operator|=
name|fclose
argument_list|(
name|files
index|[
name|i
index|]
operator|.
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|EOF
condition|)
name|ERROR
literal|"i/o error occurred while closing %s"
operator|,
name|files
index|[
name|i
index|]
operator|.
name|fname
name|WARNING
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SUBSIZE
value|(20 * RECSIZE)
end_define

begin_function
name|Cell
modifier|*
name|sub
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* substitute command */
block|{
specifier|register
name|uchar
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|pb
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|uchar
name|buf
index|[
name|SUBSIZE
index|]
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* target string */
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* 0 => a[1] is already-compiled regexpr */
name|pfa
operator|=
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|1
index|]
expr_stmt|;
comment|/* regular expression */
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* replacement string */
name|result
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|pmatch
argument_list|(
name|pfa
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|pb
operator|=
name|buf
expr_stmt|;
name|sptr
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|sptr
operator|<
name|patbeg
condition|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|sptr
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|0
operator|&&
name|pb
operator|<
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|sptr
operator|+
literal|1
operator|)
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
comment|/* skip \, */
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
comment|/* add& */
block|}
elseif|else
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|patbeg
init|;
name|q
operator|<
name|patbeg
operator|+
name|patlen
condition|;
control|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pb
operator|>=
name|buf
operator|+
name|SUBSIZE
condition|)
name|ERROR
literal|"sub() result %30s too big"
operator|,
name|buf
name|FATAL
expr_stmt|;
name|sptr
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
if|if
condition|(
operator|(
name|patlen
operator|==
literal|0
operator|&&
operator|*
name|patbeg
operator|)
operator|||
operator|(
name|patlen
operator|&&
operator|*
operator|(
name|sptr
operator|-
literal|1
operator|)
operator|)
condition|)
while|while
condition|(
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
condition|)
empty_stmt|;
if|if
condition|(
name|pb
operator|>=
name|buf
operator|+
name|SUBSIZE
condition|)
name|ERROR
literal|"sub() result %.30s too big"
operator|,
name|buf
name|FATAL
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
empty_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|gsub
parameter_list|(
name|Node
modifier|*
modifier|*
name|a
parameter_list|,
name|int
name|nnn
parameter_list|)
comment|/* global substitute */
block|{
specifier|register
name|Cell
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|rptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|pb
decl_stmt|;
name|uchar
name|buf
index|[
name|SUBSIZE
index|]
decl_stmt|;
specifier|register
name|fa
modifier|*
name|pfa
decl_stmt|;
name|int
name|mflag
decl_stmt|,
name|tempstat
decl_stmt|,
name|num
decl_stmt|;
name|mflag
operator|=
literal|0
expr_stmt|;
comment|/* if mflag == 0, can replace empty string */
name|num
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|execute
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* target string */
name|t
operator|=
name|getsval
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* 0 => a[1] is already-compiled regexpr */
name|pfa
operator|=
operator|(
name|fa
operator|*
operator|)
name|a
index|[
literal|1
index|]
expr_stmt|;
comment|/* regular expression */
else|else
block|{
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pfa
operator|=
name|makedfa
argument_list|(
name|getsval
argument_list|(
name|y
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
name|y
operator|=
name|execute
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* replacement string */
if|if
condition|(
name|pmatch
argument_list|(
name|pfa
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|tempstat
operator|=
name|pfa
operator|->
name|initstat
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
literal|2
expr_stmt|;
name|pb
operator|=
name|buf
expr_stmt|;
name|rptr
operator|=
name|getsval
argument_list|(
name|y
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 			uchar *p; 			int i; 			printf("target string: %s, *patbeg = %o, patlen = %d\n", 				t, *patbeg, patlen); 			printf("	match found: "); 			p=patbeg; 			for (i=0; i<patlen; i++) 				printf("%c", *p++); 			printf("\n"); 			*/
if|if
condition|(
name|patlen
operator|==
literal|0
operator|&&
operator|*
name|patbeg
operator|!=
literal|0
condition|)
block|{
comment|/* matched empty string */
if|if
condition|(
name|mflag
operator|==
literal|0
condition|)
block|{
comment|/* can replace empty */
name|num
operator|++
expr_stmt|;
name|sptr
operator|=
name|rptr
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|0
operator|&&
name|pb
operator|<
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|sptr
operator|+
literal|1
operator|)
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|uchar
modifier|*
name|q
decl_stmt|;
name|sptr
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|patbeg
init|;
name|q
operator|<
name|patbeg
operator|+
name|patlen
condition|;
control|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|0
condition|)
comment|/* at end */
goto|goto
name|done
goto|;
operator|*
name|pb
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
if|if
condition|(
name|pb
operator|>=
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
name|ERROR
literal|"gsub() result %.30s too big"
operator|,
name|buf
name|FATAL
expr_stmt|;
name|mflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* matched nonempty string */
name|num
operator|++
expr_stmt|;
name|sptr
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|sptr
operator|<
name|patbeg
operator|&&
name|pb
operator|<
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|sptr
operator|=
name|rptr
expr_stmt|;
while|while
condition|(
operator|*
name|sptr
operator|!=
literal|0
operator|&&
name|pb
operator|<
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|sptr
operator|+
literal|1
operator|)
operator|==
literal|'&'
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sptr
operator|==
literal|'&'
condition|)
block|{
name|uchar
modifier|*
name|q
decl_stmt|;
name|sptr
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|patbeg
init|;
name|q
operator|<
name|patbeg
operator|+
name|patlen
condition|;
control|)
operator|*
name|pb
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
expr_stmt|;
name|t
operator|=
name|patbeg
operator|+
name|patlen
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|t
operator|-
literal|1
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|0
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|pb
operator|>=
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
name|ERROR
literal|"gsub() result %.30s too big"
operator|,
name|buf
name|FATAL
expr_stmt|;
name|mflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|pmatch
argument_list|(
name|pfa
argument_list|,
name|t
argument_list|)
condition|)
do|;
name|sptr
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|*
name|pb
operator|++
operator|=
operator|*
name|sptr
operator|++
condition|)
empty_stmt|;
name|done
label|:
if|if
condition|(
name|pb
operator|>=
name|buf
operator|+
name|SUBSIZE
operator|-
literal|1
condition|)
name|ERROR
literal|"gsub() result %.30s too big"
operator|,
name|buf
name|FATAL
expr_stmt|;
operator|*
name|pb
operator|=
literal|'\0'
expr_stmt|;
name|setsval
argument_list|(
name|x
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|pfa
operator|->
name|initstat
operator|=
name|tempstat
expr_stmt|;
block|}
name|tempfree
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|tempfree
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|gettemp
argument_list|()
expr_stmt|;
name|x
operator|->
name|tval
operator|=
name|NUM
expr_stmt|;
name|x
operator|->
name|fval
operator|=
name|num
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

end_unit

