begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) AT&T 1993 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of AT&T or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AT&T OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_comment
comment|/* lasciate ogni speranza, voi ch'entrate. */
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_define
define|#
directive|define
name|HAT
value|(NCHARS-1)
end_define

begin_comment
comment|/* matches ^ in regular expr */
end_comment

begin_comment
comment|/* NCHARS is 2**n */
end_comment

begin_define
define|#
directive|define
name|MAXLIN
value|512
end_define

begin_define
define|#
directive|define
name|type
parameter_list|(
name|v
parameter_list|)
value|(v)->nobj
end_define

begin_define
define|#
directive|define
name|left
parameter_list|(
name|v
parameter_list|)
value|(v)->narg[0]
end_define

begin_define
define|#
directive|define
name|right
parameter_list|(
name|v
parameter_list|)
value|(v)->narg[1]
end_define

begin_define
define|#
directive|define
name|parent
parameter_list|(
name|v
parameter_list|)
value|(v)->nnext
end_define

begin_define
define|#
directive|define
name|LEAF
value|case CCL: case NCCL: case CHAR: case DOT: case FINAL: case ALL:
end_define

begin_define
define|#
directive|define
name|UNARY
value|case STAR: case PLUS: case QUEST:
end_define

begin_comment
comment|/* encoding in tree Nodes: 	leaf (CCL, NCCL, CHAR, DOT, FINAL, ALL): 		left is index, right contains value or pointer to value 	unary (STAR, PLUS, QUEST): left is child, right is null 	binary (CAT, OR): left and right are children 	parent contains pointer to parent */
end_comment

begin_decl_stmt
name|uchar
name|chars
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|setvec
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tmpset
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Node
modifier|*
name|point
index|[
name|MAXLIN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rtok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next token in current re */
end_comment

begin_decl_stmt
name|int
name|rlxval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|rlxstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|prestr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current position in current re */
end_comment

begin_decl_stmt
name|uchar
modifier|*
name|lastre
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* origin of last re */
end_comment

begin_decl_stmt
specifier|static
name|int
name|setcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|poscnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uchar
modifier|*
name|patbeg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patlen
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NFA
value|20
end_define

begin_comment
comment|/* cache this many dynamic fa's */
end_comment

begin_decl_stmt
name|fa
modifier|*
name|fatab
index|[
name|NFA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfatab
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entries in fatab */
end_comment

begin_function
name|fa
modifier|*
name|makedfa
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|,
name|int
name|anchor
parameter_list|)
comment|/* returns dfa for reg expr s */
block|{
name|int
name|i
decl_stmt|,
name|use
decl_stmt|,
name|nuse
decl_stmt|;
name|fa
modifier|*
name|pfa
decl_stmt|;
if|if
condition|(
name|compile_time
condition|)
comment|/* a constant for sure */
return|return
name|mkdfa
argument_list|(
name|s
argument_list|,
name|anchor
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfatab
condition|;
name|i
operator|++
control|)
comment|/* is it there already? */
if|if
condition|(
name|fatab
index|[
name|i
index|]
operator|->
name|anchor
operator|==
name|anchor
operator|&&
name|strcmp
argument_list|(
name|fatab
index|[
name|i
index|]
operator|->
name|restr
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fatab
index|[
name|i
index|]
operator|->
name|use
operator|++
expr_stmt|;
return|return
name|fatab
index|[
name|i
index|]
return|;
block|}
name|pfa
operator|=
name|mkdfa
argument_list|(
name|s
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfatab
operator|<
name|NFA
condition|)
block|{
comment|/* room for another */
name|fatab
index|[
name|nfatab
index|]
operator|=
name|pfa
expr_stmt|;
name|fatab
index|[
name|nfatab
index|]
operator|->
name|use
operator|=
literal|1
expr_stmt|;
name|nfatab
operator|++
expr_stmt|;
return|return
name|pfa
return|;
block|}
name|use
operator|=
name|fatab
index|[
literal|0
index|]
operator|->
name|use
expr_stmt|;
comment|/* replace least-recently used */
name|nuse
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nfatab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fatab
index|[
name|i
index|]
operator|->
name|use
operator|<
name|use
condition|)
block|{
name|use
operator|=
name|fatab
index|[
name|i
index|]
operator|->
name|use
expr_stmt|;
name|nuse
operator|=
name|i
expr_stmt|;
block|}
name|freefa
argument_list|(
name|fatab
index|[
name|nuse
index|]
argument_list|)
expr_stmt|;
name|fatab
index|[
name|nuse
index|]
operator|=
name|pfa
expr_stmt|;
name|pfa
operator|->
name|use
operator|=
literal|1
expr_stmt|;
return|return
name|pfa
return|;
block|}
end_function

begin_function
name|fa
modifier|*
name|mkdfa
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|,
name|int
name|anchor
parameter_list|)
comment|/* does the real work of making a dfa */
comment|/* anchor = 1 for anchored matches, else 0 */
block|{
name|Node
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|fa
modifier|*
name|f
decl_stmt|;
name|p
operator|=
name|reparse
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p1
operator|=
name|op2
argument_list|(
name|CAT
argument_list|,
name|op2
argument_list|(
name|STAR
argument_list|,
name|op2
argument_list|(
name|ALL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|NIL
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* put ALL STAR in front of reg.  exp. */
name|p1
operator|=
name|op2
argument_list|(
name|CAT
argument_list|,
name|p1
argument_list|,
name|op2
argument_list|(
name|FINAL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put FINAL after reg.  exp. */
name|poscnt
operator|=
literal|0
expr_stmt|;
name|penter
argument_list|(
name|p1
argument_list|)
expr_stmt|;
comment|/* enter parent pointers and leaf indices */
if|if
condition|(
operator|(
name|f
operator|=
operator|(
name|fa
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|fa
argument_list|)
operator|+
name|poscnt
operator|*
sizeof|sizeof
argument_list|(
name|rrow
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space for fa"
argument_list|)
expr_stmt|;
name|f
operator|->
name|accept
operator|=
name|poscnt
operator|-
literal|1
expr_stmt|;
comment|/* penter has computed number of positions in re */
name|cfoll
argument_list|(
name|f
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* set up follow sets */
name|freetr
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|*
operator|(
name|f
operator|->
name|re
index|[
literal|0
index|]
operator|.
name|lfollow
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in makedfa"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in makedfa"
argument_list|)
expr_stmt|;
operator|*
name|f
operator|->
name|posns
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|initstat
operator|=
name|makeinit
argument_list|(
name|f
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|f
operator|->
name|anchor
operator|=
name|anchor
expr_stmt|;
name|f
operator|->
name|restr
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|int
name|makeinit
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
name|int
name|anchor
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|reset
operator|=
literal|0
expr_stmt|;
name|k
operator|=
operator|*
operator|(
name|f
operator|->
name|re
index|[
literal|0
index|]
operator|.
name|lfollow
operator|)
expr_stmt|;
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|k
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in makeinit"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|re
index|[
literal|0
index|]
operator|.
name|lfollow
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
literal|1
index|]
operator|==
name|f
operator|->
name|accept
condition|)
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|curstat
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
literal|2
argument_list|,
name|HAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
condition|)
block|{
operator|*
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
name|k
operator|-
literal|1
expr_stmt|;
comment|/* leave out position 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|f
operator|->
name|out
index|[
literal|0
index|]
operator|=
name|f
operator|->
name|out
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|curstat
operator|!=
literal|2
condition|)
operator|--
operator|(
operator|*
name|f
operator|->
name|posns
index|[
name|f
operator|->
name|curstat
index|]
operator|)
expr_stmt|;
block|}
return|return
name|f
operator|->
name|curstat
return|;
block|}
end_function

begin_function
name|void
name|penter
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
comment|/* set up parent pointers and leaf indices */
block|{
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|LEAF
name|left
parameter_list|(
name|p
parameter_list|)
init|=
operator|(
name|Node
operator|*
operator|)
name|poscnt
function_decl|;
if|if
condition|(
name|poscnt
operator|>=
name|MAXLIN
condition|)
name|overflo
argument_list|(
literal|"leaf index overflow in penter"
argument_list|)
expr_stmt|;
name|point
index|[
name|poscnt
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
name|UNARY
name|penter
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|parent
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|penter
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|penter
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
name|parent
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
name|p
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|ERROR
literal|"unknown type %d in penter"
operator|,
name|type
argument_list|(
argument|p
argument_list|)
name|FATAL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|freetr
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
comment|/* free parse tree */
block|{
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|LEAF
name|xfree
argument_list|(
name|p
argument_list|)
decl_stmt|;
break|break;
name|UNARY
name|freetr
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|freetr
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|freetr
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|ERROR
literal|"unknown type %d in freetr"
operator|,
name|type
argument_list|(
argument|p
argument_list|)
name|FATAL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* in the parsing of regular expressions, metacharacters like . have */
end_comment

begin_comment
comment|/* to be seen literally;  \056 is not a metacharacter. */
end_comment

begin_macro
name|hexstr
argument_list|(
argument|char **pp
argument_list|)
end_macro

begin_comment
comment|/* find and eval hex string at pp, return new p */
end_comment

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|pp
init|;
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
literal|16
operator|*
name|n
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'f'
condition|)
name|n
operator|=
literal|16
operator|*
name|n
operator|+
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'F'
condition|)
name|n
operator|=
literal|16
operator|*
name|n
operator|+
operator|*
name|p
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|n
return|;
block|}
end_block

begin_define
define|#
directive|define
name|isoctdigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '8')
end_define

begin_comment
comment|/* multiple use of arg */
end_comment

begin_macro
name|quoted
argument_list|(
argument|char **pp
argument_list|)
end_macro

begin_comment
comment|/* pick up next thing after a \\ */
end_comment

begin_comment
comment|/* and increment *pp */
end_comment

begin_block
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'t'
condition|)
name|c
operator|=
literal|'\t'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'f'
condition|)
name|c
operator|=
literal|'\f'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
name|c
operator|=
literal|'\r'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
name|c
operator|=
literal|'\b'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'x'
condition|)
block|{
comment|/* hexadecimal goo follows */
name|c
operator|=
name|hexstr
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isoctdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* \d \dd \ddd */
name|int
name|n
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|isoctdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isoctdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
name|p
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
name|c
operator|=
name|n
expr_stmt|;
block|}
comment|/* else */
comment|/* c = c; */
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_function
name|uchar
modifier|*
name|cclenter
parameter_list|(
name|uchar
modifier|*
name|p
parameter_list|)
comment|/* add a character class */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|uchar
modifier|*
name|op
decl_stmt|;
name|op
operator|=
name|p
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|quoted
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|i
operator|>
literal|0
operator|&&
name|chars
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
name|c
operator|=
name|chars
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c2
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'\\'
condition|)
name|c2
operator|=
name|quoted
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|<
name|c2
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|MAXLIN
operator|-
literal|1
condition|)
name|overflo
argument_list|(
literal|"character class too big"
argument_list|)
expr_stmt|;
name|chars
index|[
name|i
operator|++
index|]
operator|=
operator|++
name|c
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|MAXLIN
operator|-
literal|1
condition|)
name|overflo
argument_list|(
literal|"character class too big"
argument_list|)
expr_stmt|;
name|chars
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|chars
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"cclenter: in = |%s|, out = |%s|\n"
operator|,
name|op
operator|,
name|chars
operator|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|tostring
argument_list|(
name|chars
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|overflo
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|)
block|{
name|ERROR
literal|"regular expression too big: %.30s..."
operator|,
name|s
name|FATAL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfoll
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
name|Node
modifier|*
name|v
parameter_list|)
comment|/* enter follow set of each leaf of vertex v into lfollow[leaf] */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|LEAF
name|f
operator|->
name|re
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
index|]
operator|.
name|ltype
operator|=
name|type
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|f
operator|->
name|re
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
index|]
operator|.
name|lval
operator|=
operator|(
name|long
operator|)
name|right
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* assumes ptr& long fit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|accept
condition|;
name|i
operator|++
control|)
name|setvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|setcnt
operator|=
literal|0
expr_stmt|;
name|follow
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* computes setvec and setcnt */
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|setcnt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space building follow set"
argument_list|)
expr_stmt|;
name|f
operator|->
name|re
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|v
argument_list|)
index|]
operator|.
name|lfollow
operator|=
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|setcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
name|f
operator|->
name|accept
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|setvec
index|[
name|i
index|]
operator|==
literal|1
condition|)
operator|*
operator|++
name|p
operator|=
name|i
expr_stmt|;
break|break;
name|UNARY
name|cfoll
argument_list|(
name|f
argument_list|,
name|left
argument_list|(
name|v
argument_list|)
argument_list|)
decl_stmt|;
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
name|cfoll
argument_list|(
name|f
argument_list|,
name|left
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|cfoll
argument_list|(
name|f
argument_list|,
name|right
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* can't happen */
name|ERROR
literal|"unknown type %d in cfoll"
operator|,
name|type
argument_list|(
argument|v
argument_list|)
name|FATAL
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|first
argument_list|(
argument|Node *p
argument_list|)
end_macro

begin_comment
comment|/* collects initially active leaves of p into setvec */
end_comment

begin_comment
comment|/* returns 0 or 1 depending on whether p matches empty string */
end_comment

begin_block
block|{
specifier|register
name|int
name|b
decl_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|LEAF
if|if
condition|(
name|setvec
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|p
argument_list|)
index|]
operator|!=
literal|1
condition|)
block|{
name|setvec
index|[
operator|(
name|int
operator|)
name|left
argument_list|(
name|p
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|setcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
argument_list|(
name|p
argument_list|)
operator|==
name|CCL
operator|&&
operator|(
operator|*
operator|(
name|uchar
operator|*
operator|)
name|right
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* empty CCL */
else|else
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|STAR
case|:
case|case
name|QUEST
case|:
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CAT
case|:
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|OR
case|:
name|b
operator|=
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
argument_list|(
name|left
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ERROR
literal|"unknown type %d in first"
operator|,
name|type
argument_list|(
argument|p
argument_list|)
name|FATAL
expr_stmt|;
comment|/* can't happen */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|void
name|follow
parameter_list|(
name|Node
modifier|*
name|v
parameter_list|)
comment|/* collects leaves that can follow v into setvec */
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|type
argument_list|(
name|v
argument_list|)
operator|==
name|FINAL
condition|)
return|return;
name|p
operator|=
name|parent
argument_list|(
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
name|first
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|OR
case|:
case|case
name|QUEST
case|:
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|CAT
case|:
if|if
condition|(
name|v
operator|==
name|left
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* v is left child of p */
if|if
condition|(
name|first
argument_list|(
name|right
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
comment|/* v is right child */
name|follow
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_macro
name|member
argument_list|(
argument|int c
argument_list|,
argument|uchar *s
argument_list|)
end_macro

begin_comment
comment|/* is c in s? */
end_comment

begin_block
block|{
while|while
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|c
operator|==
operator|*
name|s
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|match
argument_list|(
argument|fa *f
argument_list|,
argument|uchar *p
argument_list|)
end_macro

begin_comment
comment|/* shortest match ? */
end_comment

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|s
operator|=
name|f
operator|->
name|reset
condition|?
name|makeinit
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
else|:
name|f
operator|->
name|initstat
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
do|do
block|{
if|if
condition|(
name|ns
operator|=
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
operator|*
name|p
index|]
condition|)
name|s
operator|=
name|ns
expr_stmt|;
else|else
name|s
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|pmatch
argument_list|(
argument|fa *f
argument_list|,
argument|uchar *p
argument_list|)
end_macro

begin_comment
comment|/* longest match, for sub */
end_comment

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|ns
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|s
operator|=
name|f
operator|->
name|reset
condition|?
name|makeinit
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
else|:
name|f
operator|->
name|initstat
expr_stmt|;
name|patbeg
operator|=
name|p
expr_stmt|;
name|patlen
operator|=
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|q
operator|=
name|p
expr_stmt|;
do|do
block|{
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
comment|/* final state */
name|patlen
operator|=
name|q
operator|-
name|p
expr_stmt|;
if|if
condition|(
name|ns
operator|=
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
operator|*
name|q
index|]
condition|)
name|s
operator|=
name|ns
expr_stmt|;
else|else
name|s
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|1
condition|)
comment|/* no transition */
if|if
condition|(
name|patlen
operator|>=
literal|0
condition|)
block|{
name|patbeg
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
goto|goto
name|nextin
goto|;
comment|/* no match */
block|}
do|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
name|patlen
operator|=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
comment|/* don't count $ */
if|if
condition|(
name|patlen
operator|>=
literal|0
condition|)
block|{
name|patbeg
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nextin
label|:
name|s
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|reset
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|f
operator|->
name|posns
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|k
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in pmatch"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|)
index|[
name|i
index|]
expr_stmt|;
name|f
operator|->
name|initstat
operator|=
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
name|f
operator|->
name|out
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|nematch
argument_list|(
argument|fa *f
argument_list|,
argument|uchar *p
argument_list|)
end_macro

begin_comment
comment|/* non-empty match, for sub */
end_comment

begin_block
block|{
specifier|register
name|int
name|s
decl_stmt|,
name|ns
decl_stmt|;
specifier|register
name|uchar
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|s
operator|=
name|f
operator|->
name|reset
condition|?
name|makeinit
argument_list|(
name|f
argument_list|,
literal|1
argument_list|)
else|:
name|f
operator|->
name|initstat
expr_stmt|;
name|patlen
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
do|do
block|{
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
comment|/* final state */
name|patlen
operator|=
name|q
operator|-
name|p
expr_stmt|;
if|if
condition|(
name|ns
operator|=
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
operator|*
name|q
index|]
condition|)
name|s
operator|=
name|ns
expr_stmt|;
else|else
name|s
operator|=
name|cgoto
argument_list|(
name|f
argument_list|,
name|s
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|1
condition|)
comment|/* no transition */
if|if
condition|(
name|patlen
operator|>
literal|0
condition|)
block|{
name|patbeg
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
goto|goto
name|nnextin
goto|;
comment|/* no nonempty match */
block|}
do|while
condition|(
operator|*
name|q
operator|++
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|f
operator|->
name|out
index|[
name|s
index|]
condition|)
name|patlen
operator|=
name|q
operator|-
name|p
operator|-
literal|1
expr_stmt|;
comment|/* don't count $ */
if|if
condition|(
name|patlen
operator|>
literal|0
condition|)
block|{
name|patbeg
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nnextin
label|:
name|s
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|reset
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|f
operator|->
name|posns
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|k
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of state space"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
operator|(
name|f
operator|->
name|posns
index|[
literal|2
index|]
operator|)
index|[
name|i
index|]
operator|=
operator|(
name|f
operator|->
name|posns
index|[
literal|0
index|]
operator|)
index|[
name|i
index|]
expr_stmt|;
name|f
operator|->
name|initstat
operator|=
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|out
index|[
literal|2
index|]
operator|=
name|f
operator|->
name|out
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
literal|2
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|Node
modifier|*
name|reparse
parameter_list|(
name|uchar
modifier|*
name|p
parameter_list|)
comment|/* parses regular expression pointed to by p */
block|{
comment|/* uses relex() to scan regular expression */
name|Node
modifier|*
name|np
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"reparse<%s>\n"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
name|lastre
operator|=
name|prestr
operator|=
name|p
expr_stmt|;
comment|/* prestr points to string to be parsed */
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|==
literal|'\0'
condition|)
name|ERROR
literal|"empty regular expression"
name|FATAL
expr_stmt|;
name|np
operator|=
name|regexp
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|!=
literal|'\0'
condition|)
name|ERROR
literal|"syntax error in regular expression %s at %s"
operator|,
name|lastre
operator|,
name|prestr
name|FATAL
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|regexp
parameter_list|(
name|void
parameter_list|)
comment|/* top-level parse of reg expr */
block|{
return|return
operator|(
name|alt
argument_list|(
name|concat
argument_list|(
name|primary
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|primary
parameter_list|(
name|void
parameter_list|)
block|{
name|Node
modifier|*
name|np
decl_stmt|;
switch|switch
condition|(
name|rtok
condition|)
block|{
case|case
name|CHAR
case|:
name|np
operator|=
name|op2
argument_list|(
name|CHAR
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|rlxval
argument_list|)
expr_stmt|;
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
case|case
name|ALL
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|ALL
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|DOT
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|DOT
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|CCL
case|:
name|np
operator|=
name|op2
argument_list|(
name|CCL
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|cclenter
argument_list|(
name|rlxstr
argument_list|)
argument_list|)
expr_stmt|;
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
case|case
name|NCCL
case|:
name|np
operator|=
name|op2
argument_list|(
name|NCCL
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|cclenter
argument_list|(
name|rlxstr
argument_list|)
argument_list|)
expr_stmt|;
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
case|case
literal|'^'
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|CHAR
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|HAT
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'$'
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|CHAR
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|'('
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|==
literal|')'
condition|)
block|{
comment|/* special pleading for () */
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
name|unary
argument_list|(
name|op2
argument_list|(
name|CCL
argument_list|,
name|NIL
argument_list|,
operator|(
name|Node
operator|*
operator|)
name|tostring
argument_list|(
literal|""
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
name|np
operator|=
name|regexp
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtok
operator|==
literal|')'
condition|)
block|{
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|np
argument_list|)
operator|)
return|;
block|}
else|else
name|ERROR
literal|"syntax error in regular expression %s at %s"
operator|,
name|lastre
operator|,
name|prestr
name|FATAL
expr_stmt|;
default|default:
name|ERROR
literal|"illegal primary in regular expression %s at %s"
operator|,
name|lastre
operator|,
name|prestr
name|FATAL
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|Node
modifier|*
name|concat
parameter_list|(
name|Node
modifier|*
name|np
parameter_list|)
block|{
switch|switch
condition|(
name|rtok
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|DOT
case|:
case|case
name|ALL
case|:
case|case
name|CCL
case|:
case|case
name|NCCL
case|:
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
return|return
operator|(
name|concat
argument_list|(
name|op2
argument_list|(
name|CAT
argument_list|,
name|np
argument_list|,
name|primary
argument_list|()
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|alt
parameter_list|(
name|Node
modifier|*
name|np
parameter_list|)
block|{
if|if
condition|(
name|rtok
operator|==
name|OR
condition|)
block|{
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|alt
argument_list|(
name|op2
argument_list|(
name|OR
argument_list|,
name|np
argument_list|,
name|concat
argument_list|(
name|primary
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|Node
modifier|*
name|unary
parameter_list|(
name|Node
modifier|*
name|np
parameter_list|)
block|{
switch|switch
condition|(
name|rtok
condition|)
block|{
case|case
name|STAR
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|STAR
argument_list|,
name|np
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|PLUS
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|PLUS
argument_list|,
name|np
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|QUEST
case|:
name|rtok
operator|=
name|relex
argument_list|()
expr_stmt|;
return|return
operator|(
name|unary
argument_list|(
name|op2
argument_list|(
name|QUEST
argument_list|,
name|np
argument_list|,
name|NIL
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|np
operator|)
return|;
block|}
block|}
end_function

begin_macro
name|relex
argument_list|(
argument|void
argument_list|)
end_macro

begin_comment
comment|/* lexical analyzer for reparse */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|uchar
name|cbuf
index|[
name|MAXLIN
index|]
decl_stmt|;
name|int
name|clen
decl_stmt|,
name|cflag
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
name|prestr
operator|++
condition|)
block|{
case|case
literal|'|'
case|:
return|return
name|OR
return|;
case|case
literal|'*'
case|:
return|return
name|STAR
return|;
case|case
literal|'+'
case|:
return|return
name|PLUS
return|;
case|case
literal|'?'
case|:
return|return
name|QUEST
return|;
case|case
literal|'.'
case|:
return|return
name|DOT
return|;
case|case
literal|'\0'
case|:
name|prestr
operator|--
expr_stmt|;
return|return
literal|'\0'
return|;
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
return|return
name|c
return|;
case|case
literal|'\\'
case|:
name|rlxval
operator|=
name|quoted
argument_list|(
operator|&
name|prestr
argument_list|)
expr_stmt|;
return|return
name|CHAR
return|;
default|default:
name|rlxval
operator|=
name|c
expr_stmt|;
return|return
name|CHAR
return|;
case|case
literal|'['
case|:
name|clen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|prestr
operator|==
literal|'^'
condition|)
block|{
name|cflag
operator|=
literal|1
expr_stmt|;
name|prestr
operator|++
expr_stmt|;
block|}
else|else
name|cflag
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|clen
operator|<
name|MAXLIN
operator|-
literal|1
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|prestr
operator|++
operator|)
operator|==
literal|'\\'
condition|)
block|{
name|cbuf
index|[
name|clen
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|prestr
operator|++
operator|)
operator|==
literal|'\0'
condition|)
name|ERROR
literal|"nonterminated character class %.20s..."
operator|,
name|lastre
name|FATAL
expr_stmt|;
name|cbuf
index|[
name|clen
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
block|{
name|cbuf
index|[
name|clen
index|]
operator|=
literal|0
expr_stmt|;
name|rlxstr
operator|=
name|tostring
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
return|return
name|CCL
return|;
else|else
return|return
name|NCCL
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|ERROR
literal|"newline in character class %.20s..."
operator|,
name|lastre
name|FATAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|ERROR
literal|"nonterminated character class %.20s"
operator|,
name|lastre
name|FATAL
expr_stmt|;
block|}
else|else
name|cbuf
index|[
name|clen
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|clen
operator|>=
name|MAXLIN
operator|-
literal|1
condition|)
name|ERROR
literal|"character class %.20s... too long"
operator|,
name|cbuf
name|FATAL
expr_stmt|;
block|}
comment|/* can't happen */
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|cgoto
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|c
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|accept
condition|;
name|i
operator|++
control|)
name|setvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|setcnt
operator|=
literal|0
expr_stmt|;
comment|/* compute positions of gototab[s,c] into setvec */
name|p
operator|=
name|f
operator|->
name|posns
index|[
name|s
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|*
name|p
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|ltype
operator|)
operator|!=
name|FINAL
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|CHAR
operator|&&
name|c
operator|==
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lval
operator|||
name|k
operator|==
name|DOT
operator|&&
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|HAT
operator|||
name|k
operator|==
name|ALL
operator|&&
name|c
operator|!=
literal|0
operator|||
name|k
operator|==
name|CCL
operator|&&
name|member
argument_list|(
name|c
argument_list|,
operator|(
name|uchar
operator|*
operator|)
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lval
argument_list|)
operator|||
name|k
operator|==
name|NCCL
operator|&&
operator|!
name|member
argument_list|(
name|c
argument_list|,
operator|(
name|uchar
operator|*
operator|)
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lval
argument_list|)
operator|&&
name|c
operator|!=
literal|0
operator|&&
name|c
operator|!=
name|HAT
condition|)
block|{
name|q
operator|=
name|f
operator|->
name|re
index|[
name|p
index|[
name|i
index|]
index|]
operator|.
name|lfollow
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
operator|*
name|q
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|setvec
index|[
name|q
index|[
name|j
index|]
index|]
operator|==
literal|0
condition|)
block|{
name|setcnt
operator|++
expr_stmt|;
name|setvec
index|[
name|q
index|[
name|j
index|]
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* determine if setvec is a previous state */
name|tmpset
index|[
literal|0
index|]
operator|=
name|setcnt
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|f
operator|->
name|accept
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|setvec
index|[
name|i
index|]
condition|)
block|{
name|tmpset
index|[
name|j
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* tmpset == previous state? */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|f
operator|->
name|posns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|tmpset
index|[
literal|0
index|]
operator|)
operator|!=
name|p
index|[
literal|0
index|]
condition|)
goto|goto
name|different
goto|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|tmpset
index|[
name|j
index|]
operator|!=
name|p
index|[
name|j
index|]
condition|)
goto|goto
name|different
goto|;
comment|/* setvec is state i */
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
name|c
index|]
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
name|different
label|:
empty_stmt|;
block|}
comment|/* add tmpset to current set of states */
if|if
condition|(
name|f
operator|->
name|curstat
operator|>=
name|NSTATES
operator|-
literal|1
condition|)
block|{
name|f
operator|->
name|curstat
operator|=
literal|2
expr_stmt|;
name|f
operator|->
name|reset
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|NSTATES
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
operator|++
operator|(
name|f
operator|->
name|curstat
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHARS
condition|;
name|i
operator|++
control|)
name|f
operator|->
name|gototab
index|[
name|f
operator|->
name|curstat
index|]
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|f
operator|->
name|curstat
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
operator|(
name|setcnt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|overflo
argument_list|(
literal|"out of space in cgoto"
argument_list|)
expr_stmt|;
name|f
operator|->
name|posns
index|[
name|f
operator|->
name|curstat
index|]
operator|=
name|p
expr_stmt|;
name|f
operator|->
name|gototab
index|[
name|s
index|]
index|[
name|c
index|]
operator|=
name|f
operator|->
name|curstat
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|setcnt
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|tmpset
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|setvec
index|[
name|f
operator|->
name|accept
index|]
condition|)
name|f
operator|->
name|out
index|[
name|f
operator|->
name|curstat
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|f
operator|->
name|out
index|[
name|f
operator|->
name|curstat
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|f
operator|->
name|curstat
return|;
block|}
end_function

begin_function
name|void
name|freefa
parameter_list|(
name|fa
modifier|*
name|f
parameter_list|)
comment|/* free a finite automaton */
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|curstat
condition|;
name|i
operator|++
control|)
name|xfree
argument_list|(
name|f
operator|->
name|posns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|f
operator|->
name|accept
condition|;
name|i
operator|++
control|)
block|{
name|xfree
argument_list|(
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|lfollow
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|ltype
operator|==
name|CCL
operator|||
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|ltype
operator|==
name|NCCL
condition|)
name|xfree
argument_list|(
name|f
operator|->
name|re
index|[
name|i
index|]
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|f
operator|->
name|restr
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

