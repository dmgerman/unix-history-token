begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************** Copyright (C) AT&T 1993 All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that the copyright notice and this permission notice and warranty disclaimer appear in supporting documentation, and that the name of AT&T or any of its entities not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  AT&T DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL AT&T OR ANY OF ITS ENTITIES BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. ****************************************************************/
end_comment

begin_define
define|#
directive|define
name|DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"awk.h"
end_include

begin_include
include|#
directive|include
file|"y.tab.h"
end_include

begin_define
define|#
directive|define
name|FULLTAB
value|2
end_define

begin_comment
comment|/* rehash when table gets this x full */
end_comment

begin_define
define|#
directive|define
name|GROWTAB
value|4
end_define

begin_comment
comment|/* grow table by this factor */
end_comment

begin_decl_stmt
name|Array
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* main symbol table */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|FS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial field sep */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|RS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial record sep */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|OFS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output field sep */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|ORS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output record sep */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|OFMT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output format for numbers */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|CONVFMT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* format for conversions in getsval */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|NF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of fields in current record */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|NR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of current record */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|FNR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of current record in current file */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|FILENAME
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current filename argument */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|ARGC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of arguments from command line */
end_comment

begin_decl_stmt
name|uchar
modifier|*
modifier|*
name|SUBSEP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subscript separator for a[i,j,k]; default \034 */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|RSTART
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of re matched with ~; origin 1 (!) */
end_comment

begin_decl_stmt
name|Awkfloat
modifier|*
name|RLENGTH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of same */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|recloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* location of record */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|nrloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NR */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|nfloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NF */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|fnrloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FNR */
end_comment

begin_decl_stmt
name|Array
modifier|*
name|ARGVtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol table containing ARGV[...] */
end_comment

begin_decl_stmt
name|Array
modifier|*
name|ENVtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol table containing ENVIRON[...] */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|rstartloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RSTART */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|rlengthloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RLENGTH */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|symtabloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SYMTAB */
end_comment

begin_decl_stmt
name|Cell
modifier|*
name|nullloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a guaranteed empty cell */
end_comment

begin_decl_stmt
name|Node
modifier|*
name|nullnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero&null, converted into a node for comparisons */
end_comment

begin_decl_stmt
specifier|extern
name|Cell
modifier|*
name|fldtab
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|syminit
parameter_list|(
name|void
parameter_list|)
comment|/* initialize symbol table with builtin vars */
block|{
name|setsymtab
argument_list|(
literal|"0"
argument_list|,
literal|"0"
argument_list|,
literal|0.0
argument_list|,
name|NUM
operator||
name|STR
operator||
name|CON
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
comment|/* this is used for if(x)... tests: */
name|nullloc
operator|=
name|setsymtab
argument_list|(
literal|"$zero&null"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
operator||
name|STR
operator||
name|CON
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|nullnode
operator|=
name|valtonode
argument_list|(
name|nullloc
argument_list|,
name|CCON
argument_list|)
expr_stmt|;
comment|/* recloc = setsymtab("$0", record, 0.0, REC|STR|DONTFREE, symtab); */
comment|/* has been done elsewhere */
name|recloc
operator|=
operator|&
name|fldtab
index|[
literal|0
index|]
expr_stmt|;
name|FS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"FS"
argument_list|,
literal|" "
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|RS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"RS"
argument_list|,
literal|"\n"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|OFS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"OFS"
argument_list|,
literal|" "
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|ORS
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"ORS"
argument_list|,
literal|"\n"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|OFMT
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"OFMT"
argument_list|,
literal|"%.6g"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|CONVFMT
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"CONVFMT"
argument_list|,
literal|"%.6g"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|FILENAME
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"FILENAME"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|nfloc
operator|=
name|setsymtab
argument_list|(
literal|"NF"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|NF
operator|=
operator|&
name|nfloc
operator|->
name|fval
expr_stmt|;
name|nrloc
operator|=
name|setsymtab
argument_list|(
literal|"NR"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|NR
operator|=
operator|&
name|nrloc
operator|->
name|fval
expr_stmt|;
name|fnrloc
operator|=
name|setsymtab
argument_list|(
literal|"FNR"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|FNR
operator|=
operator|&
name|fnrloc
operator|->
name|fval
expr_stmt|;
name|SUBSEP
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"SUBSEP"
argument_list|,
literal|"\034"
argument_list|,
literal|0.0
argument_list|,
name|STR
operator||
name|DONTFREE
argument_list|,
name|symtab
argument_list|)
operator|->
name|sval
expr_stmt|;
name|rstartloc
operator|=
name|setsymtab
argument_list|(
literal|"RSTART"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RSTART
operator|=
operator|&
name|rstartloc
operator|->
name|fval
expr_stmt|;
name|rlengthloc
operator|=
name|setsymtab
argument_list|(
literal|"RLENGTH"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|RLENGTH
operator|=
operator|&
name|rlengthloc
operator|->
name|fval
expr_stmt|;
name|symtabloc
operator|=
name|setsymtab
argument_list|(
literal|"SYMTAB"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|ARR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|symtabloc
operator|->
name|sval
operator|=
operator|(
name|uchar
operator|*
operator|)
name|symtab
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arginit
parameter_list|(
name|int
name|ac
parameter_list|,
name|uchar
modifier|*
name|av
index|[]
parameter_list|)
comment|/* set up ARGV and ARGC */
block|{
name|Cell
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uchar
name|temp
index|[
literal|5
index|]
decl_stmt|;
name|ARGC
operator|=
operator|&
name|setsymtab
argument_list|(
literal|"ARGC"
argument_list|,
literal|""
argument_list|,
operator|(
name|Awkfloat
operator|)
name|ac
argument_list|,
name|NUM
argument_list|,
name|symtab
argument_list|)
operator|->
name|fval
expr_stmt|;
name|cp
operator|=
name|setsymtab
argument_list|(
literal|"ARGV"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|ARR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|ARGVtab
operator|=
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
comment|/* could be (int) ARGC as well */
name|cp
operator|->
name|sval
operator|=
operator|(
name|uchar
operator|*
operator|)
name|ARGVtab
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|temp
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnumber
argument_list|(
operator|*
name|av
argument_list|)
condition|)
name|setsymtab
argument_list|(
name|temp
argument_list|,
operator|*
name|av
argument_list|,
name|atof
argument_list|(
operator|*
name|av
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|ARGVtab
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
name|temp
argument_list|,
operator|*
name|av
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ARGVtab
argument_list|)
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|envinit
parameter_list|(
name|uchar
modifier|*
modifier|*
name|envp
parameter_list|)
comment|/* set up ENVIRON variable */
block|{
name|Cell
modifier|*
name|cp
decl_stmt|;
name|uchar
modifier|*
name|p
decl_stmt|;
name|cp
operator|=
name|setsymtab
argument_list|(
literal|"ENVIRON"
argument_list|,
literal|""
argument_list|,
literal|0.0
argument_list|,
name|ARR
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
name|ENVtab
operator|=
name|makesymtab
argument_list|(
name|NSYMTAB
argument_list|)
expr_stmt|;
name|cp
operator|->
name|sval
operator|=
operator|(
name|uchar
operator|*
operator|)
name|ENVtab
expr_stmt|;
for|for
control|(
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|uchar
operator|*
operator|)
name|strchr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|envp
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* split into two strings at = */
if|if
condition|(
name|isnumber
argument_list|(
name|p
argument_list|)
condition|)
name|setsymtab
argument_list|(
operator|*
name|envp
argument_list|,
name|p
argument_list|,
name|atof
argument_list|(
name|p
argument_list|)
argument_list|,
name|STR
operator||
name|NUM
argument_list|,
name|ENVtab
argument_list|)
expr_stmt|;
else|else
name|setsymtab
argument_list|(
operator|*
name|envp
argument_list|,
name|p
argument_list|,
literal|0.0
argument_list|,
name|STR
argument_list|,
name|ENVtab
argument_list|)
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
comment|/* restore in case env is passed down to a shell */
block|}
block|}
end_function

begin_function
name|Array
modifier|*
name|makesymtab
parameter_list|(
name|int
name|n
parameter_list|)
comment|/* make a new symbol table */
block|{
name|Array
modifier|*
name|ap
decl_stmt|;
name|Cell
modifier|*
modifier|*
name|tp
decl_stmt|;
name|ap
operator|=
operator|(
name|Array
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Array
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|Cell
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|Cell
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
operator|||
name|tp
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space in makesymtab"
name|FATAL
expr_stmt|;
name|ap
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|size
operator|=
name|n
expr_stmt|;
name|ap
operator|->
name|tab
operator|=
name|tp
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|freesymtab
parameter_list|(
name|Cell
modifier|*
name|ap
parameter_list|)
comment|/* free a symbol table */
block|{
name|Cell
modifier|*
name|cp
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|Array
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|isarr
argument_list|(
name|ap
argument_list|)
condition|)
return|return;
name|tp
operator|=
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|tp
operator|->
name|tab
index|[
name|i
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|temp
control|)
block|{
name|xfree
argument_list|(
name|cp
operator|->
name|nval
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|cp
argument_list|)
condition|)
name|xfree
argument_list|(
name|cp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|temp
operator|=
name|cp
operator|->
name|cnext
expr_stmt|;
comment|/* avoids freeing then using */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|tp
operator|->
name|tab
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|freeelem
parameter_list|(
name|Cell
modifier|*
name|ap
parameter_list|,
name|uchar
modifier|*
name|s
parameter_list|)
comment|/* free elem s from ap (i.e., ap["s"] */
block|{
name|Array
modifier|*
name|tp
decl_stmt|;
name|Cell
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|h
decl_stmt|;
name|tp
operator|=
operator|(
name|Array
operator|*
operator|)
name|ap
operator|->
name|sval
expr_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|,
name|tp
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|tab
index|[
name|h
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|cnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|nval
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
comment|/* 1st one */
name|tp
operator|->
name|tab
index|[
name|h
index|]
operator|=
name|p
operator|->
name|cnext
expr_stmt|;
else|else
comment|/* middle somewhere */
name|prev
operator|->
name|cnext
operator|=
name|p
operator|->
name|cnext
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|p
argument_list|)
condition|)
name|xfree
argument_list|(
name|p
operator|->
name|sval
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|nval
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|tp
operator|->
name|nelem
operator|--
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|Cell
modifier|*
name|setsymtab
parameter_list|(
name|uchar
modifier|*
name|n
parameter_list|,
name|uchar
modifier|*
name|s
parameter_list|,
name|Awkfloat
name|f
parameter_list|,
name|unsigned
name|t
parameter_list|,
name|Array
modifier|*
name|tp
parameter_list|)
block|{
specifier|register
name|int
name|h
decl_stmt|;
specifier|register
name|Cell
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|lookup
argument_list|(
name|n
argument_list|,
name|tp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"setsymtab found %o: n=%s s=\"%s\" f=%g t=%o\n"
operator|,
name|p
operator|,
name|p
operator|->
name|nval
operator|,
name|p
operator|->
name|sval
operator|,
name|p
operator|->
name|fval
operator|,
name|p
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|p
operator|=
operator|(
name|Cell
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Cell
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space for symbol table at %s"
operator|,
name|n
name|FATAL
expr_stmt|;
name|p
operator|->
name|nval
operator|=
name|tostring
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|sval
operator|=
name|s
condition|?
name|tostring
argument_list|(
name|s
argument_list|)
else|:
name|tostring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|p
operator|->
name|fval
operator|=
name|f
expr_stmt|;
name|p
operator|->
name|tval
operator|=
name|t
expr_stmt|;
name|tp
operator|->
name|nelem
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|nelem
operator|>
name|FULLTAB
operator|*
name|tp
operator|->
name|size
condition|)
name|rehash
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|n
argument_list|,
name|tp
operator|->
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|cnext
operator|=
name|tp
operator|->
name|tab
index|[
name|h
index|]
expr_stmt|;
name|tp
operator|->
name|tab
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setsymtab set %o: n=%s s=\"%s\" f=%g t=%o\n"
operator|,
name|p
operator|,
name|p
operator|->
name|nval
operator|,
name|p
operator|->
name|sval
operator|,
name|p
operator|->
name|fval
operator|,
name|p
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|hash
argument_list|(
argument|uchar *s
argument_list|,
argument|int n
argument_list|)
end_macro

begin_comment
comment|/* form hash value for string s */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|hashval
decl_stmt|;
for|for
control|(
name|hashval
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
name|hashval
operator|=
operator|(
operator|*
name|s
operator|+
literal|31
operator|*
name|hashval
operator|)
expr_stmt|;
return|return
name|hashval
operator|%
name|n
return|;
block|}
end_block

begin_function
name|void
name|rehash
parameter_list|(
name|Array
modifier|*
name|tp
parameter_list|)
comment|/* rehash items in small table into big one */
block|{
name|int
name|i
decl_stmt|,
name|nh
decl_stmt|,
name|nsz
decl_stmt|;
name|Cell
modifier|*
name|cp
decl_stmt|,
modifier|*
name|op
decl_stmt|,
modifier|*
modifier|*
name|np
decl_stmt|;
name|nsz
operator|=
name|GROWTAB
operator|*
name|tp
operator|->
name|size
expr_stmt|;
name|np
operator|=
operator|(
name|Cell
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nsz
argument_list|,
sizeof|sizeof
argument_list|(
name|Cell
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
comment|/* can't do it, but can keep running. */
return|return;
comment|/* someone else will run out later. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|tp
operator|->
name|tab
index|[
name|i
index|]
init|;
name|cp
condition|;
name|cp
operator|=
name|op
control|)
block|{
name|op
operator|=
name|cp
operator|->
name|cnext
expr_stmt|;
name|nh
operator|=
name|hash
argument_list|(
name|cp
operator|->
name|nval
argument_list|,
name|nsz
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cnext
operator|=
name|np
index|[
name|nh
index|]
expr_stmt|;
name|np
index|[
name|nh
index|]
operator|=
name|cp
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|tp
operator|->
name|tab
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tab
operator|=
name|np
expr_stmt|;
name|tp
operator|->
name|size
operator|=
name|nsz
expr_stmt|;
block|}
end_function

begin_function
name|Cell
modifier|*
name|lookup
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|,
name|Array
modifier|*
name|tp
parameter_list|)
comment|/* look for s in tp */
block|{
specifier|register
name|Cell
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|h
decl_stmt|;
name|h
operator|=
name|hash
argument_list|(
name|s
argument_list|,
name|tp
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|tp
operator|->
name|tab
index|[
name|h
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|cnext
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|nval
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* found it */
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* not found */
block|}
end_function

begin_function
name|Awkfloat
name|setfval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|,
name|Awkfloat
name|f
parameter_list|)
comment|/* set float val of a Cell */
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"assign to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|FLD
condition|)
block|{
name|donerec
operator|=
literal|0
expr_stmt|;
comment|/* mark $0 invalid */
if|if
condition|(
name|vp
operator|-
name|fldtab
operator|>
operator|*
name|NF
condition|)
name|newfld
argument_list|(
name|vp
operator|-
name|fldtab
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setting field %d to %g\n"
operator|,
name|vp
operator|-
name|fldtab
operator|,
name|f
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|REC
condition|)
block|{
name|donefld
operator|=
literal|0
expr_stmt|;
comment|/* mark $1... invalid */
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
name|vp
operator|->
name|tval
operator|&=
operator|~
name|STR
expr_stmt|;
comment|/* mark string invalid */
name|vp
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
comment|/* mark number ok */
name|dprintf
argument_list|(
operator|(
literal|"setfval %o: %s = %g, t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|f
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
name|vp
operator|->
name|fval
operator|=
name|f
return|;
block|}
end_function

begin_function
name|void
name|funnyvar
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|rw
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|ARR
condition|)
name|ERROR
literal|"can't %s %s; it's an array name."
operator|,
name|rw
operator|,
name|vp
operator|->
name|nval
name|FATAL
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|FCN
condition|)
name|ERROR
literal|"can't %s %s; it's a function."
operator|,
name|rw
operator|,
name|vp
operator|->
name|nval
name|FATAL
expr_stmt|;
name|ERROR
literal|"funny variable %o: n=%s s=\"%s\" f=%g t=%o"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|vp
operator|->
name|sval
operator|,
name|vp
operator|->
name|fval
operator|,
name|vp
operator|->
name|tval
name|WARNING
expr_stmt|;
block|}
end_function

begin_function
name|uchar
modifier|*
name|setsval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|,
name|uchar
modifier|*
name|s
parameter_list|)
comment|/* set string val of a Cell */
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"assign to"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|FLD
condition|)
block|{
name|donerec
operator|=
literal|0
expr_stmt|;
comment|/* mark $0 invalid */
if|if
condition|(
name|vp
operator|-
name|fldtab
operator|>
operator|*
name|NF
condition|)
name|newfld
argument_list|(
name|vp
operator|-
name|fldtab
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setting field %d to %s\n"
operator|,
name|vp
operator|-
name|fldtab
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|tval
operator|&
name|REC
condition|)
block|{
name|donefld
operator|=
literal|0
expr_stmt|;
comment|/* mark $1... invalid */
name|donerec
operator|=
literal|1
expr_stmt|;
block|}
name|vp
operator|->
name|tval
operator|&=
operator|~
name|NUM
expr_stmt|;
name|vp
operator|->
name|tval
operator||=
name|STR
expr_stmt|;
if|if
condition|(
name|freeable
argument_list|(
name|vp
argument_list|)
condition|)
name|xfree
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tval
operator|&=
operator|~
name|DONTFREE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"setsval %o: %s = \"%s\", t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|s
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|sval
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|Awkfloat
name|r_getfval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|)
comment|/* get float val of a Cell */
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"read value of"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
name|FLD
operator|)
operator|&&
name|donefld
operator|==
literal|0
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
name|REC
operator|)
operator|&&
name|donerec
operator|==
literal|0
condition|)
name|recbld
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isnum
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* not a number */
name|vp
operator|->
name|fval
operator|=
name|atof
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
comment|/* best guess */
if|if
condition|(
name|isnumber
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
operator|&&
operator|!
operator|(
name|vp
operator|->
name|tval
operator|&
name|CON
operator|)
condition|)
name|vp
operator|->
name|tval
operator||=
name|NUM
expr_stmt|;
comment|/* make NUM only sparingly */
block|}
name|dprintf
argument_list|(
operator|(
literal|"getfval %o: %s = %g, t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|vp
operator|->
name|fval
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|fval
operator|)
return|;
block|}
end_function

begin_function
name|uchar
modifier|*
name|r_getsval
parameter_list|(
name|Cell
modifier|*
name|vp
parameter_list|)
comment|/* get string val of a Cell */
block|{
name|uchar
name|s
index|[
literal|100
index|]
decl_stmt|;
name|double
name|dtemp
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
operator|(
name|NUM
operator||
name|STR
operator|)
operator|)
operator|==
literal|0
condition|)
name|funnyvar
argument_list|(
name|vp
argument_list|,
literal|"read value of"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
name|FLD
operator|)
operator|&&
name|donefld
operator|==
literal|0
condition|)
name|fldbld
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
name|REC
operator|)
operator|&&
name|donerec
operator|==
literal|0
condition|)
name|recbld
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|tval
operator|&
name|STR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|tval
operator|&
name|DONTFREE
operator|)
condition|)
name|xfree
argument_list|(
name|vp
operator|->
name|sval
argument_list|)
expr_stmt|;
if|if
condition|(
name|modf
argument_list|(
name|vp
operator|->
name|fval
argument_list|,
operator|&
name|dtemp
argument_list|)
operator|==
literal|0
condition|)
comment|/* it's integral */
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
literal|"%.20g"
argument_list|,
name|vp
operator|->
name|fval
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|*
name|CONVFMT
argument_list|,
name|vp
operator|->
name|fval
argument_list|)
expr_stmt|;
name|vp
operator|->
name|sval
operator|=
name|tostring
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vp
operator|->
name|tval
operator|&=
operator|~
name|DONTFREE
expr_stmt|;
name|vp
operator|->
name|tval
operator||=
name|STR
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"getsval %o: %s = \"%s\", t=%o\n"
operator|,
name|vp
operator|,
name|vp
operator|->
name|nval
operator|,
name|vp
operator|->
name|sval
operator|,
name|vp
operator|->
name|tval
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|sval
operator|)
return|;
block|}
end_function

begin_function
name|uchar
modifier|*
name|tostring
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|)
comment|/* make a copy of string s */
block|{
specifier|register
name|uchar
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|uchar
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|ERROR
literal|"out of space in tostring on %s"
operator|,
name|s
name|FATAL
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|uchar
modifier|*
name|qstring
parameter_list|(
name|uchar
modifier|*
name|s
parameter_list|,
name|int
name|delim
parameter_list|)
comment|/* collect string up to next delim */
block|{
name|uchar
modifier|*
name|q
decl_stmt|;
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|q
operator|=
name|cbuf
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|!=
name|delim
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|>=
name|cbuf
operator|+
name|CBUFLEN
operator|-
literal|1
condition|)
name|ERROR
literal|"string %.10s... too long"
operator|,
name|cbuf
name|SYNTAX
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|ERROR
literal|"newline in string %.10s..."
operator|,
name|cbuf
name|SYNTAX
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
else|else
comment|/* \something */
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|q
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
operator|++
name|s
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|n
operator|=
literal|8
operator|*
name|n
operator|+
operator|*
operator|++
name|s
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
name|n
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cbuf
return|;
block|}
end_function

end_unit

