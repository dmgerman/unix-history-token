begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Read input file characters into tokens  */
end_comment

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_define
define|#
directive|define
name|isletter
parameter_list|(
name|ch
parameter_list|)
value|((((ch)>= 'a')&& ((ch)<= 'z')) || \ 				(((ch)>= 'A')&& ((ch)<= 'Z')))
end_define

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|ch
parameter_list|)
value|(((ch)>= '0')&& ((ch)<= '9'))
end_define

begin_define
define|#
directive|define
name|issymbol
parameter_list|(
name|ch
parameter_list|)
value|(isletter(ch) || isdigit(ch) || ((ch) == '_'))
end_define

begin_comment
comment|/*  * Current token.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|short
name|t_type
decl_stmt|;
comment|/* type of token */
name|char
modifier|*
name|t_str
decl_stmt|;
comment|/* string value or symbol name */
name|long
name|t_numindex
decl_stmt|;
comment|/* index of numeric value */
block|}
name|curtoken
struct|;
end_struct

begin_decl_stmt
specifier|static
name|BOOL
name|rescan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE to reread current token */
end_comment

begin_decl_stmt
specifier|static
name|BOOL
name|newlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE to return newlines as tokens */
end_comment

begin_decl_stmt
specifier|static
name|BOOL
name|allsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if always want a symbol token */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of constant strings */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|numbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for numeric tokens */
end_comment

begin_decl_stmt
specifier|static
name|long
name|numbufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current size of numeric buffer */
end_comment

begin_decl_stmt
name|long
name|errorcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of compilation errors */
end_comment

begin_comment
comment|/*  * Table of keywords  */
end_comment

begin_struct
struct|struct
name|keyword
block|{
name|char
modifier|*
name|k_name
decl_stmt|;
comment|/* keyword name */
name|int
name|k_token
decl_stmt|;
comment|/* token number */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|keyword
name|keywords
index|[]
init|=
block|{
literal|"if"
block|,
name|T_IF
block|,
literal|"else"
block|,
name|T_ELSE
block|,
literal|"for"
block|,
name|T_FOR
block|,
literal|"while"
block|,
name|T_WHILE
block|,
literal|"do"
block|,
name|T_DO
block|,
literal|"continue"
block|,
name|T_CONTINUE
block|,
literal|"break"
block|,
name|T_BREAK
block|,
literal|"goto"
block|,
name|T_GOTO
block|,
literal|"return"
block|,
name|T_RETURN
block|,
literal|"local"
block|,
name|T_LOCAL
block|,
literal|"global"
block|,
name|T_GLOBAL
block|,
literal|"print"
block|,
name|T_PRINT
block|,
literal|"switch"
block|,
name|T_SWITCH
block|,
literal|"case"
block|,
name|T_CASE
block|,
literal|"default"
block|,
name|T_DEFAULT
block|,
literal|"quit"
block|,
name|T_QUIT
block|,
literal|"exit"
block|,
name|T_QUIT
block|,
literal|"define"
block|,
name|T_DEFINE
block|,
literal|"read"
block|,
name|T_READ
block|,
literal|"show"
block|,
name|T_SHOW
block|,
literal|"help"
block|,
name|T_HELP
block|,
literal|"write"
block|,
name|T_WRITE
block|,
literal|"mat"
block|,
name|T_MAT
block|,
literal|"obj"
block|,
name|T_OBJ
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eatcomment
argument_list|()
decl_stmt|,
name|eatstring
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eatsymbol
argument_list|()
decl_stmt|,
name|eatnumber
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize all token information.  */
end_comment

begin_function
name|void
name|inittokens
parameter_list|()
block|{
name|initstr
argument_list|(
operator|&
name|strings
argument_list|)
expr_stmt|;
name|newlines
operator|=
name|FALSE
expr_stmt|;
name|allsyms
operator|=
name|FALSE
expr_stmt|;
name|rescan
operator|=
name|FALSE
expr_stmt|;
name|setprompt
argument_list|(
name|PROMPT1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tokenmode
parameter_list|(
name|flag
parameter_list|)
block|{
name|newlines
operator|=
name|FALSE
expr_stmt|;
name|allsyms
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|TM_NEWLINES
condition|)
name|newlines
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|TM_ALLSYMS
condition|)
name|allsyms
operator|=
name|TRUE
expr_stmt|;
name|setprompt
argument_list|(
name|newlines
condition|?
name|PROMPT1
else|:
name|PROMPT2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to read in the next token from the input stream.  * The type of token is returned as a value.  If the token is a string or  * symbol name, information is saved so that the value can be retrieved.  */
end_comment

begin_function
name|int
name|gettoken
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
comment|/* current input character */
name|int
name|type
decl_stmt|;
comment|/* token type */
if|if
condition|(
name|rescan
condition|)
block|{
comment|/* rescanning */
name|rescan
operator|=
name|FALSE
expr_stmt|;
return|return
name|curtoken
operator|.
name|t_type
return|;
block|}
name|curtoken
operator|.
name|t_str
operator|=
name|NULL
expr_stmt|;
name|curtoken
operator|.
name|t_numindex
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|T_NULL
expr_stmt|;
while|while
condition|(
name|type
operator|==
name|T_NULL
condition|)
block|{
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|allsyms
operator|&&
operator|(
operator|(
name|ch
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|';'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'"'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
operator|)
condition|)
block|{
name|reread
argument_list|()
expr_stmt|;
name|type
operator|=
name|eatsymbol
argument_list|()
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|newlines
condition|)
name|type
operator|=
name|T_NEWLINE
expr_stmt|;
break|break;
case|case
name|EOF
case|:
name|type
operator|=
name|T_EOF
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|type
operator|=
name|T_LEFTBRACE
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|type
operator|=
name|T_RIGHTBRACE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|type
operator|=
name|T_LEFTPAREN
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|type
operator|=
name|T_RIGHTPAREN
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|type
operator|=
name|T_LEFTBRACKET
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|type
operator|=
name|T_RIGHTBRACKET
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|type
operator|=
name|T_SEMICOLON
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|type
operator|=
name|T_COLON
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|type
operator|=
name|T_COMMA
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|type
operator|=
name|T_QUESTIONMARK
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|type
operator|=
name|T_STRING
expr_stmt|;
name|eatstring
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_POWEREQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_POWER
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'='
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_EQ
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_ASSIGN
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'+'
case|:
name|type
operator|=
name|T_PLUSPLUS
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|type
operator|=
name|T_PLUSEQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_PLUS
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'-'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'-'
case|:
name|type
operator|=
name|T_MINUSMINUS
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|type
operator|=
name|T_MINUSEQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_MINUS
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_MULTEQUALS
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_POWEREQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_POWER
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|type
operator|=
name|T_MULT
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'/'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_SLASHSLASHEQUALS
expr_stmt|;
break|break;
default|default:
name|reread
argument_list|()
expr_stmt|;
name|type
operator|=
name|T_SLASHSLASH
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'='
case|:
name|type
operator|=
name|T_DIVEQUALS
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|eatcomment
argument_list|()
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_DIV
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_MODEQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_MOD
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_LE
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_LSHIFTEQUALS
expr_stmt|;
break|break;
default|default:
name|reread
argument_list|()
expr_stmt|;
name|type
operator|=
name|T_LEFTSHIFT
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|type
operator|=
name|T_LT
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_GE
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_RSHIFTEQUALS
expr_stmt|;
break|break;
default|default:
name|reread
argument_list|()
expr_stmt|;
name|type
operator|=
name|T_RIGHTSHIFT
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|type
operator|=
name|T_GT
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'&'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'&'
case|:
name|type
operator|=
name|T_ANDAND
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|type
operator|=
name|T_ANDEQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_AND
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'|'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'|'
case|:
name|type
operator|=
name|T_OROR
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|type
operator|=
name|T_OREQUALS
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_OR
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'!'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'='
case|:
name|type
operator|=
name|T_NE
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|T_NOT
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|nextchar
argument_list|()
condition|)
block|{
case|case
literal|'\n'
case|:
name|setprompt
argument_list|(
name|PROMPT2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Unknown token character '%c'"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|isletter
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|reread
argument_list|()
expr_stmt|;
name|type
operator|=
name|eatsymbol
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'.'
operator|)
condition|)
block|{
name|reread
argument_list|()
expr_stmt|;
name|type
operator|=
name|eatnumber
argument_list|()
expr_stmt|;
break|break;
block|}
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Unknown token character '%c'"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
name|curtoken
operator|.
name|t_type
operator|=
operator|(
name|short
operator|)
name|type
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Continue to eat up a comment string.  * The leading slash-asterisk has just been scanned at this point.  */
end_comment

begin_function
specifier|static
name|void
name|eatcomment
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
return|return;
name|reread
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|==
name|EOF
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|newlines
operator|&&
operator|(
name|ch
operator|==
literal|'\n'
operator|)
operator|&&
name|inputisterminal
argument_list|()
operator|)
condition|)
block|{
name|reread
argument_list|()
expr_stmt|;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Unterminated comment"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read in a string and add it to the literal string pool.  * The leading single or double quote has been read in at this point.  */
end_comment

begin_function
specifier|static
name|void
name|eatstring
parameter_list|(
name|quotechar
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current character address */
name|int
name|ch
decl_stmt|;
comment|/* current character */
name|char
name|buf
index|[
name|MAXSTRING
operator|+
literal|1
index|]
decl_stmt|;
comment|/* buffer for string */
name|cp
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
name|EOF
case|:
case|case
literal|'\n'
case|:
name|reread
argument_list|()
expr_stmt|;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Unterminated string constant"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|curtoken
operator|.
name|t_str
operator|=
name|addliteral
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\\'
case|:
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|setprompt
argument_list|(
name|PROMPT2
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|EOF
case|:
name|reread
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|ch
operator|==
name|quotechar
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|curtoken
operator|.
name|t_str
operator|=
name|addliteral
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall into default case */
default|default:
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read in a symbol name which may or may not be a keyword.  * If allsyms is set, keywords are not looked up and almost all chars  * will be accepted for the symbol.  Returns the type of symbol found.  */
end_comment

begin_function
specifier|static
name|int
name|eatsymbol
parameter_list|()
block|{
specifier|register
name|struct
name|keyword
modifier|*
name|kp
decl_stmt|;
comment|/* pointer to current keyword */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current character pointer */
name|int
name|ch
decl_stmt|;
comment|/* current character */
name|int
name|cc
decl_stmt|;
comment|/* character count */
specifier|static
name|char
name|buf
index|[
name|SYMBOLSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* temporary buffer */
name|cp
operator|=
name|buf
expr_stmt|;
name|cc
operator|=
name|SYMBOLSIZE
expr_stmt|;
if|if
condition|(
name|allsyms
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
literal|' '
operator|)
operator|||
operator|(
name|ch
operator|==
literal|';'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'\n'
operator|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|--
operator|>
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
name|reread
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Symbol too long"
argument_list|)
expr_stmt|;
name|curtoken
operator|.
name|t_str
operator|=
name|buf
expr_stmt|;
return|return
name|T_SYMBOL
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|nextchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|issymbol
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|--
operator|>
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
block|}
name|reread
argument_list|()
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Symbol too long"
argument_list|)
expr_stmt|;
for|for
control|(
name|kp
operator|=
name|keywords
init|;
name|kp
operator|->
name|k_name
condition|;
name|kp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|kp
operator|->
name|k_name
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
name|kp
operator|->
name|k_token
return|;
name|curtoken
operator|.
name|t_str
operator|=
name|buf
expr_stmt|;
return|return
name|T_SYMBOL
return|;
block|}
end_function

begin_comment
comment|/*  * Read in and remember a possibly numeric constant value.  * The constant is inserted into a constant table so further uses  * of the same constant will not take more memory.  This can also  * return just a period, which is used for element accesses and for  * the old numeric value.  */
end_comment

begin_function
specifier|static
name|int
name|eatnumber
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* current character pointer */
name|long
name|len
decl_stmt|;
comment|/* parsed size of number */
name|long
name|res
decl_stmt|;
comment|/* result of parsing number */
if|if
condition|(
name|numbufsize
operator|==
literal|0
condition|)
block|{
name|numbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|128
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbuf
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate number buffer"
argument_list|)
expr_stmt|;
name|numbufsize
operator|=
literal|128
expr_stmt|;
block|}
name|cp
operator|=
name|numbuf
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|len
operator|>=
name|numbufsize
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|numbuf
argument_list|,
name|numbufsize
operator|+
literal|1001
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot reallocate number buffer"
argument_list|)
expr_stmt|;
name|numbuf
operator|=
name|cp
expr_stmt|;
name|numbufsize
operator|+=
literal|1000
expr_stmt|;
name|cp
operator|=
operator|&
name|numbuf
index|[
name|len
index|]
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|nextchar
argument_list|()
expr_stmt|;
operator|*
operator|(
operator|++
name|cp
operator|)
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|numbuf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|isletter
argument_list|(
name|numbuf
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|reread
argument_list|()
expr_stmt|;
return|return
name|T_PERIOD
return|;
block|}
name|res
operator|=
name|qparse
argument_list|(
name|numbuf
argument_list|,
name|QPF_IMAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|reread
argument_list|()
expr_stmt|;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Badly formatted number"
argument_list|)
expr_stmt|;
name|curtoken
operator|.
name|t_numindex
operator|=
name|addnumber
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
return|return
name|T_NUMBER
return|;
block|}
if|if
condition|(
name|res
operator|!=
operator|++
name|len
condition|)
break|break;
block|}
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|reread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|numbuf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|numbuf
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|curtoken
operator|.
name|t_numindex
operator|=
literal|0
expr_stmt|;
return|return
name|T_OLDVALUE
return|;
block|}
name|cp
operator|-=
literal|2
expr_stmt|;
name|res
operator|=
name|T_NUMBER
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'i'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'I'
operator|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|T_IMAGINARY
expr_stmt|;
block|}
name|curtoken
operator|.
name|t_numindex
operator|=
name|addnumber
argument_list|(
name|numbuf
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Return the string value of the current token.  */
end_comment

begin_function
name|char
modifier|*
name|tokenstring
parameter_list|()
block|{
return|return
name|curtoken
operator|.
name|t_str
return|;
block|}
end_function

begin_comment
comment|/*  * Return the constant index of a numeric token.  */
end_comment

begin_function
name|long
name|tokennumber
parameter_list|()
block|{
return|return
name|curtoken
operator|.
name|t_numindex
return|;
block|}
end_function

begin_comment
comment|/*  * Push back the token just read so that it will be seen again.  */
end_comment

begin_function
name|void
name|rescantoken
parameter_list|()
block|{
name|rescan
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Describe an error message.  * Then skip to the next specified token (or one more powerful).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST
value|skip, fmt, va_alist
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|int skip; char *fmt; va_dcl
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST
value|int skip, char *fmt, ...
end_define

begin_define
define|#
directive|define
name|VA_DCL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_ALIST
value|skip, fmt
end_define

begin_define
define|#
directive|define
name|VA_DCL
value|int skip; char *fmt;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|scanerror
parameter_list|(
name|VA_ALIST
parameter_list|)
function|VA_DCL
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of file with error */
name|char
name|buf
index|[
name|MAXERROR
operator|+
literal|1
index|]
decl_stmt|;
name|errorcount
operator|++
expr_stmt|;
name|name
operator|=
name|inputname
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %ld: "
argument_list|,
name|name
argument_list|,
name|linenumber
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|skip
condition|)
block|{
case|case
name|T_NULL
case|:
return|return;
case|case
name|T_COMMA
case|:
name|rescan
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
case|case
name|T_LEFTBRACE
case|:
case|case
name|T_RIGHTBRACE
case|:
case|case
name|T_EOF
case|:
case|case
name|T_COMMA
case|:
name|rescan
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown skip token for scanerror\n"
argument_list|)
expr_stmt|;
comment|/* fall into semicolon case */
comment|/*FALLTHRU*/
case|case
name|T_SEMICOLON
case|:
name|rescan
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
case|case
name|T_LEFTBRACE
case|:
case|case
name|T_RIGHTBRACE
case|:
case|case
name|T_EOF
case|:
name|rescan
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

