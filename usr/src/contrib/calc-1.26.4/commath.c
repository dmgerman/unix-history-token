begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Extended precision complex arithmetic primitive routines  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_decl_stmt
name|COMPLEX
name|_czero_
init|=
block|{
operator|&
name|_qzero_
block|,
operator|&
name|_qzero_
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|COMPLEX
name|_cone_
init|=
block|{
operator|&
name|_qone_
block|,
operator|&
name|_qzero_
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|COMPLEX
name|_cnegone_
init|=
block|{
operator|&
name|_qnegone_
block|,
operator|&
name|_qzero_
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|COMPLEX _conei_ =	{&_qzero_,&_qone_, 1 };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Free list for complex numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|FREELIST
name|freelist
init|=
block|{
sizeof|sizeof
argument_list|(
name|COMPLEX
argument_list|)
block|,
comment|/* size of an item */
literal|100
comment|/* number of free items to keep */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Add two complex numbers.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cadd
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|COMPLEX
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c1
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c2
argument_list|)
return|;
if|if
condition|(
name|ciszero
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c1
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c1
operator|->
name|real
argument_list|)
operator|||
operator|!
name|qiszero
argument_list|(
name|c2
operator|->
name|real
argument_list|)
condition|)
name|r
operator|->
name|real
operator|=
name|qadd
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c1
operator|->
name|imag
argument_list|)
operator|||
operator|!
name|qiszero
argument_list|(
name|c2
operator|->
name|imag
argument_list|)
condition|)
name|r
operator|->
name|imag
operator|=
name|qadd
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Subtract two complex numbers.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|csub
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|COMPLEX
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|c1
operator|->
name|real
operator|==
name|c2
operator|->
name|real
operator|)
operator|&&
operator|(
name|c1
operator|->
name|imag
operator|==
name|c2
operator|->
name|imag
operator|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
if|if
condition|(
name|ciszero
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c1
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c1
operator|->
name|real
argument_list|)
operator|||
operator|!
name|qiszero
argument_list|(
name|c2
operator|->
name|real
argument_list|)
condition|)
name|r
operator|->
name|real
operator|=
name|qsub
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c1
operator|->
name|imag
argument_list|)
operator|||
operator|!
name|qiszero
argument_list|(
name|c2
operator|->
name|imag
argument_list|)
condition|)
name|r
operator|->
name|imag
operator|=
name|qsub
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Multiply two complex numbers.  * This saves one multiplication over the obvious algorithm by  * trading it for several extra additions, as follows.  Let  *	q1 = (a + b) * (c + d)  *	q2 = a * c  *	q3 = b * d  * Then (a+bi) * (c+di) = (q2 - q3) + (q1 - q2 - q3)i.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cmul
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|COMPLEX
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|,
modifier|*
name|q3
decl_stmt|,
modifier|*
name|q4
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c1
argument_list|)
operator|||
name|ciszero
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
if|if
condition|(
name|cisone
argument_list|(
name|c1
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c2
argument_list|)
return|;
if|if
condition|(
name|cisone
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c1
argument_list|)
return|;
if|if
condition|(
name|cisreal
argument_list|(
name|c2
argument_list|)
condition|)
return|return
name|cmulq
argument_list|(
name|c1
argument_list|,
name|c2
operator|->
name|real
argument_list|)
return|;
if|if
condition|(
name|cisreal
argument_list|(
name|c1
argument_list|)
condition|)
return|return
name|cmulq
argument_list|(
name|c2
argument_list|,
name|c1
operator|->
name|real
argument_list|)
return|;
comment|/* 	 * Need to do the full calculation. 	 */
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|q2
operator|=
name|qadd
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c1
operator|->
name|imag
argument_list|)
expr_stmt|;
name|q3
operator|=
name|qadd
argument_list|(
name|c2
operator|->
name|real
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
name|q1
operator|=
name|qmul
argument_list|(
name|q2
argument_list|,
name|q3
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q3
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qmul
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
name|q3
operator|=
name|qmul
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
name|q4
operator|=
name|qadd
argument_list|(
name|q2
argument_list|,
name|q3
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qsub
argument_list|(
name|q2
argument_list|,
name|q3
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qsub
argument_list|(
name|q1
argument_list|,
name|q4
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q3
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q4
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Square a complex number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|csquare
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
if|if
condition|(
name|cisrunit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_cone_
argument_list|)
return|;
if|if
condition|(
name|cisiunit
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_cnegone_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|cisimag
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|q1
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qneg
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|q1
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qsub
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|q1
operator|=
name|qmul
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qscale
argument_list|(
name|q1
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Divide two complex numbers.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cdiv
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|COMPLEX
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|,
modifier|*
name|q3
decl_stmt|,
modifier|*
name|den
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c2
argument_list|)
condition|)
name|error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c1
operator|->
name|real
operator|==
name|c2
operator|->
name|real
operator|)
operator|&&
operator|(
name|c1
operator|->
name|imag
operator|==
name|c2
operator|->
name|imag
operator|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_cone_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c1
argument_list|)
operator|&&
name|cisreal
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qdiv
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|cisimag
argument_list|(
name|c1
argument_list|)
operator|&&
name|cisimag
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qdiv
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|cisimag
argument_list|(
name|c1
argument_list|)
operator|&&
name|cisreal
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|r
operator|->
name|imag
operator|=
name|qdiv
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|cisreal
argument_list|(
name|c1
argument_list|)
operator|&&
name|cisimag
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|q1
operator|=
name|qdiv
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qneg
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|cisreal
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qdiv
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qdiv
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|q1
operator|=
name|qsquare
argument_list|(
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qsquare
argument_list|(
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
name|den
operator|=
name|qadd
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|q1
operator|=
name|qmul
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qmul
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
name|q3
operator|=
name|qadd
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qdiv
argument_list|(
name|q3
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q3
argument_list|)
expr_stmt|;
name|q1
operator|=
name|qmul
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qmul
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
name|q3
operator|=
name|qsub
argument_list|(
name|q2
argument_list|,
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qdiv
argument_list|(
name|q3
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q3
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Invert a complex number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cinv
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|,
modifier|*
name|den
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"Inverting zero"
argument_list|)
expr_stmt|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|r
operator|->
name|real
operator|=
name|qinv
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|cisimag
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|q1
operator|=
name|qinv
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qneg
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|q1
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qsquare
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|den
operator|=
name|qadd
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qdiv
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|q1
operator|=
name|qdiv
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|den
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qneg
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Negate a complex number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cneg
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c
operator|->
name|real
argument_list|)
condition|)
name|r
operator|->
name|real
operator|=
name|qneg
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qiszero
argument_list|(
name|c
operator|->
name|imag
argument_list|)
condition|)
name|r
operator|->
name|imag
operator|=
name|qneg
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Take the integer part of a complex number.  * This means take the integer part of both components.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cint
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|cisint
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qint
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qint
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Take the fractional part of a complex number.  * This means take the fractional part of both components.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cfrac
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|cisint
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qfrac
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qfrac
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Take the conjugate of a complex number.  * This negates the complex part.  */
end_comment

begin_comment
unit|COMPLEX * cconj(c) 	COMPLEX *c; { 	COMPLEX *r;  	if (cisreal(c)) 		return clink(c); 	r = comalloc(); 	if (!qiszero(c->real)) 		r->real = qlink(c->real); 	r->imag = qneg(c->imag); 	return r; }
comment|/*  * Return the real part of a complex number.  */
end_comment

begin_comment
unit|COMPLEX * creal(c) 	COMPLEX *c; { 	COMPLEX *r;  	if (cisreal(c)) 		return clink(c); 	r = comalloc(); 	if (!qiszero(c->real)) 		r->real = qlink(c->real); 	return r; }
comment|/*  * Return the imaginary part of a complex number as a real.  */
end_comment

begin_endif
unit|COMPLEX * cimag(c) 	COMPLEX *c; { 	COMPLEX *r;  	if (cisreal(c)) 		return clink(&_czero_); 	r = comalloc(); 	r->real = qlink(c->imag); 	return r; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Add a real number to a complex number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|caddq
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qadd
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Subtract a real number from a complex number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|csubq
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qsub
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Shift the components of a complex number left by the specified  * number of bits.  Negative values shift to the right.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cshift
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qshift
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qshift
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Scale a complex number by a power of two.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cscale
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|ciszero
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qscale
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qscale
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Multiply a complex number by a real number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cmulq
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|clink
argument_list|(
operator|&
name|_czero_
argument_list|)
return|;
if|if
condition|(
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
name|qisnegone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|cneg
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qmul
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qmul
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Divide a complex number by a real number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cdivq
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|clink
argument_list|(
name|c
argument_list|)
return|;
if|if
condition|(
name|qisnegone
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|cneg
argument_list|(
name|c
argument_list|)
return|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qdiv
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qdiv
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Take the integer quotient of a complex number by a real number.  * This is defined to be the result of doing the quotient for each component.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cquoq
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qquo
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qquo
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Take the modulus of a complex number by a real number.  * This is defined to be the result of doing the modulo for each component.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|cmodq
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|error
argument_list|(
literal|"Division by zero"
argument_list|)
expr_stmt|;
name|r
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qmod
argument_list|(
name|c
operator|->
name|real
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qmod
argument_list|(
name|c
operator|->
name|imag
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Construct a complex number given the real and imaginary components.  */
end_comment

begin_endif
unit|COMPLEX * qqtoc(q1, q2) 	NUMBER *q1, *q2; { 	COMPLEX *r;  	if (qiszero(q1)&& qiszero(q2)) 		return clink(&_czero_); 	r = comalloc(); 	if (!qiszero(q1)) 		r->real = qlink(q1); 	if (!qiszero(q2)) 		r->imag = qlink(q2); 	return r; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compare two complex numbers for equality, returning FALSE if they are equal,  * and TRUE if they differ.  */
end_comment

begin_function
name|BOOL
name|ccmp
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|COMPLEX
modifier|*
name|c1
decl_stmt|,
decl|*
name|c2
decl_stmt|;
end_function

begin_block
block|{
name|BOOL
name|i
decl_stmt|;
name|i
operator|=
name|qcmp
argument_list|(
name|c1
operator|->
name|real
argument_list|,
name|c2
operator|->
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|i
operator|=
name|qcmp
argument_list|(
name|c1
operator|->
name|imag
argument_list|,
name|c2
operator|->
name|imag
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/*  * Allocate a new complex number.  */
end_comment

begin_function
name|COMPLEX
modifier|*
name|comalloc
parameter_list|()
block|{
name|COMPLEX
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|COMPLEX
operator|*
operator|)
name|allocitem
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Cannot allocate complex number"
argument_list|)
expr_stmt|;
name|r
operator|->
name|links
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|real
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|r
operator|->
name|imag
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Free a complex number.  */
end_comment

begin_function
name|void
name|comfree
parameter_list|(
name|c
parameter_list|)
name|COMPLEX
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|--
operator|(
name|c
operator|->
name|links
operator|)
operator|>
literal|0
condition|)
return|return;
name|qfree
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|c
operator|->
name|imag
argument_list|)
expr_stmt|;
name|freeitem
argument_list|(
operator|&
name|freelist
argument_list|,
operator|(
name|FREEITEM
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

