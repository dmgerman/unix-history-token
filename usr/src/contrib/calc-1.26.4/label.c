begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Label handling routines.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"label.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_decl_stmt
specifier|static
name|long
name|labelcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of user labels defined */
end_comment

begin_decl_stmt
specifier|static
name|STRINGHEAD
name|labelnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of user label names */
end_comment

begin_decl_stmt
specifier|static
name|LABEL
name|labels
index|[
name|MAXLABELS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of user labels */
end_comment

begin_comment
comment|/*  * Initialize the table of labels for a function.  */
end_comment

begin_function
name|void
name|initlabels
parameter_list|()
block|{
name|labelcount
operator|=
literal|0
expr_stmt|;
name|initstr
argument_list|(
operator|&
name|labelnames
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a user named label to have the offset of the next opcode.  */
end_comment

begin_function
name|void
name|definelabel
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* label name */
block|{
specifier|register
name|LABEL
modifier|*
name|lp
decl_stmt|;
comment|/* current label */
name|long
name|i
decl_stmt|;
comment|/* current label index */
name|i
operator|=
name|findstr
argument_list|(
operator|&
name|labelnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|lp
operator|=
operator|&
name|labels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_offset
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Label \"%s\" is multiply defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|setlabel
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|labelcount
operator|>=
name|MAXLABELS
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Too many labels in use"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lp
operator|=
operator|&
name|labels
index|[
name|labelcount
operator|++
index|]
expr_stmt|;
name|lp
operator|->
name|l_chain
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|l_offset
operator|=
name|curfunc
operator|->
name|f_opcodecount
expr_stmt|;
name|lp
operator|->
name|l_name
operator|=
name|addstr
argument_list|(
operator|&
name|labelnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|clearopt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the offset corresponding to the specified user label name to the  * opcode table for a function. If the label is not yet defined, then a  * chain of undefined offsets is built using the offset value, and it  * will be fixed up when the label is defined.  */
end_comment

begin_function
name|void
name|addlabel
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* user symbol name */
block|{
specifier|register
name|LABEL
modifier|*
name|lp
decl_stmt|;
comment|/* current label */
name|long
name|i
decl_stmt|;
comment|/* counter */
for|for
control|(
name|i
operator|=
name|labelcount
operator|,
name|lp
operator|=
name|labels
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|lp
operator|->
name|l_name
argument_list|)
condition|)
continue|continue;
name|uselabel
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|labelcount
operator|>=
name|MAXLABELS
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Too many labels in use"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lp
operator|=
operator|&
name|labels
index|[
name|labelcount
operator|++
index|]
expr_stmt|;
name|lp
operator|->
name|l_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|l_chain
operator|=
name|curfunc
operator|->
name|f_opcodecount
expr_stmt|;
name|lp
operator|->
name|l_name
operator|=
name|addstr
argument_list|(
operator|&
name|labelnames
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|addop
argument_list|(
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to make sure that all labels are defined.  */
end_comment

begin_function
name|void
name|checklabels
parameter_list|()
block|{
specifier|register
name|LABEL
modifier|*
name|lp
decl_stmt|;
comment|/* label being checked */
name|long
name|i
decl_stmt|;
comment|/* counter */
for|for
control|(
name|i
operator|=
name|labelcount
operator|,
name|lp
operator|=
name|labels
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|l_offset
operator|>
literal|0
condition|)
continue|continue;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Label \"%s\" was never defined"
argument_list|,
name|lp
operator|->
name|l_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clear an internal label for use.  */
end_comment

begin_function
name|void
name|clearlabel
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|LABEL
modifier|*
name|lp
decl_stmt|;
comment|/* label being cleared */
block|{
name|lp
operator|->
name|l_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|l_chain
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|l_name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set any label to have the value of the next opcode in the current  * function being defined.  If there were forward references to it,  * all such references are patched up.  */
end_comment

begin_function
name|void
name|setlabel
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|LABEL
modifier|*
name|lp
decl_stmt|;
comment|/* label being set */
block|{
specifier|register
name|FUNC
modifier|*
name|fp
decl_stmt|;
comment|/* current function */
name|long
name|curfix
decl_stmt|;
comment|/* offset of current location being fixed */
name|long
name|nextfix
decl_stmt|;
comment|/* offset of next location to fix up */
name|long
name|offset
decl_stmt|;
comment|/* offset of this label */
name|fp
operator|=
name|curfunc
expr_stmt|;
name|offset
operator|=
name|fp
operator|->
name|f_opcodecount
expr_stmt|;
name|nextfix
operator|=
name|lp
operator|->
name|l_chain
expr_stmt|;
while|while
condition|(
name|nextfix
operator|>
literal|0
condition|)
block|{
name|curfix
operator|=
name|nextfix
expr_stmt|;
name|nextfix
operator|=
name|fp
operator|->
name|f_opcodes
index|[
name|curfix
index|]
expr_stmt|;
name|fp
operator|->
name|f_opcodes
index|[
name|curfix
index|]
operator|=
name|offset
expr_stmt|;
block|}
name|lp
operator|->
name|l_chain
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|l_offset
operator|=
name|offset
expr_stmt|;
name|clearopt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use the specified label at the current location in the function  * being compiled.  This adds one word to the current function being  * compiled.  If the label is not yet defined, a patch chain is built  * so the reference can be fixed when the label is defined.  */
end_comment

begin_function
name|void
name|uselabel
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|LABEL
modifier|*
name|lp
decl_stmt|;
comment|/* label being used */
block|{
name|long
name|offset
decl_stmt|;
comment|/* offset being added */
name|offset
operator|=
name|curfunc
operator|->
name|f_opcodecount
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_offset
operator|>
literal|0
condition|)
block|{
name|addop
argument_list|(
name|lp
operator|->
name|l_offset
argument_list|)
expr_stmt|;
return|return;
block|}
name|addop
argument_list|(
name|lp
operator|->
name|l_chain
argument_list|)
expr_stmt|;
name|lp
operator|->
name|l_chain
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

