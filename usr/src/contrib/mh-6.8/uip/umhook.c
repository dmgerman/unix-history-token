begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* umhook.c - one attempt at a rcvmail hook for UUCP mail */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|ident
index|[]
init|=
literal|"@(#)$Id: umhook.c,v 1.3 1992/11/04 01:05:01 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_comment
comment|/* I don't comment my code heavily, so read this...      You run this program from your .login file.  The invocation is simply     "umhook".  The program "detaches" itself and runs unattended until you     logout.  Whenever you get UUCP mail (or upto a minute afterwards),     umhook will filter your UUCP mail drop to a temporary file.  The mail     drop is *NOT* touched beyond this (even the access time remains the     same).  For each message that was new in the mail drop, umhook will     fork a process to interpret your .maildelivery file.      The umhook program uses the -ljobs control facility to do two things: 	- determine when the controlling tty has gone away 	- kill a child that's run away (the child sets up a process group)  */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/mf.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|swit
name|switches
index|[]
init|=
block|{
define|#
directive|define
name|SLEEPSW
value|0
literal|"sleep seconds"
block|,
literal|0
block|,
define|#
directive|define
name|HELPSW
value|1
literal|"help"
block|,
literal|4
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|snooze
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uucp
init|=
name|NOTOK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|myhome
index|[
name|BUFSIZ
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mymail
index|[
name|BUFSIZ
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|myaddr
index|[
name|BUFSIZ
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mystat
index|[
name|BUFSIZ
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|myuser
index|[
name|BUFSIZ
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|sigser
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SYS5
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__STDC__ */
end_comment

begin_endif
endif|#
directive|endif
endif|SYS5
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|argp
decl_stmt|,
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|arguments
index|[
name|MAXARGS
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCALE
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|invo_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|m_find
argument_list|(
name|invo_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ap
operator|=
name|brkstring
argument_list|(
name|cp
operator|=
name|getcpy
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|" "
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|copyip
argument_list|(
name|ap
argument_list|,
name|arguments
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|=
name|arguments
expr_stmt|;
operator|(
name|void
operator|)
name|copyip
argument_list|(
name|argv
operator|+
literal|1
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|argp
operator|=
name|arguments
expr_stmt|;
comment|/*
comment|*/
while|while
condition|(
name|cp
operator|=
operator|*
name|argp
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
condition|)
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|switches
argument_list|)
condition|)
block|{
case|case
name|AMBIGSW
case|:
name|ambigsw
argument_list|(
name|cp
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|UNKWNSW
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"-%s unknown"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
case|case
name|HELPSW
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s [switches]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|buf
argument_list|,
name|switches
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
name|SLEEPSW
case|:
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|snooze
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"bad argument %s %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: %s [switches]"
argument_list|,
name|invo_name
argument_list|)
expr_stmt|;
block|}
comment|/*
comment|*/
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"you lose big"
argument_list|)
expr_stmt|;
operator|*
name|environ
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|m_putenv
argument_list|(
literal|"USER"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_putenv
argument_list|(
literal|"HOME"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_putenv
argument_list|(
literal|"SHELL"
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
operator|==
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0077
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD41A
operator|(
name|void
operator|)
name|inigrp
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD41A
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|initgroups
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|,
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mymail
argument_list|,
literal|"%s/%s"
argument_list|,
name|uucpldir
index|[
literal|0
index|]
condition|?
name|uucpldir
else|:
name|pw
operator|->
name|pw_dir
argument_list|,
name|uucplfil
index|[
literal|0
index|]
condition|?
name|uucplfil
else|:
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myuser
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|myaddr
argument_list|,
literal|"%s@%s"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|LocalName
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myhome
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|mystat
argument_list|,
literal|".%s_%d"
argument_list|,
name|invo_name
argument_list|,
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|slocalproc
argument_list|,
literal|1
argument_list|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|slocalproc
argument_list|,
literal|"unable to execute"
argument_list|)
expr_stmt|;
name|closefds
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|sigser
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
case|case
name|OK
case|:
name|umhook
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TIOCGPGRP
end_ifndef

begin_define
define|#
directive|define
name|pgrp_ok
parameter_list|(
name|pg
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
else|TIOCGPGRP
end_else

begin_define
define|#
directive|define
name|pgrp_ok
parameter_list|(
name|pg
parameter_list|)
value|(ioctl (2, TIOCGPGRP, (char *)&pg) != NOTOK)
end_define

begin_endif
endif|#
directive|endif
endif|TIOCGPGRP
end_endif

begin_expr_stmt
specifier|static
name|umhook
argument_list|()
block|{
name|int
name|pg
block|;     struct
name|stat
name|st1
block|,
name|st2
block|;
name|st_init
argument_list|(
operator|&
name|st1
argument_list|)
block|;
for|for
control|(
init|;
name|pgrp_ok
argument_list|(
name|pg
argument_list|)
condition|;
control|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|mymail
argument_list|,
operator|&
name|st2
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|st2
operator|.
name|st_ino
operator|=
operator|(
name|ino_t
operator|)
literal|0
expr_stmt|;
name|st2
operator|.
name|st_size
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
name|st2
operator|.
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|st1
operator|.
name|st_mtime
operator|!=
name|st2
operator|.
name|st_mtime
condition|)
if|if
condition|(
name|st1
operator|.
name|st_ino
operator|!=
name|st2
operator|.
name|st_ino
condition|)
name|process
argument_list|(
operator|(
name|off_t
operator|)
literal|0
argument_list|,
operator|&
name|st2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st1
operator|.
name|st_size
operator|<
name|st2
operator|.
name|st_size
condition|)
name|process
argument_list|(
name|st1
operator|.
name|st_size
argument_list|,
operator|&
name|st2
argument_list|)
expr_stmt|;
end_elseif

begin_expr_stmt
name|st1
operator|.
name|st_ino
operator|=
name|st2
operator|.
name|st_ino
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|st1
operator|.
name|st_size
operator|=
name|st2
operator|.
name|st_size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|st1
operator|.
name|st_mtime
operator|=
name|st2
operator|.
name|st_mtime
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sleep
argument_list|(
operator|(
name|unsigned
operator|)
name|snooze
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|} }
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|process
argument_list|(
argument|offset
argument_list|,
argument|st
argument_list|)
name|off_t
name|offset
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|td1
decl_stmt|,
name|td2
decl_stmt|;
name|time_t
name|timep
index|[
literal|2
index|]
decl_stmt|;
name|char
name|tmpfil
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|uucp
operator|=
name|lkopen
argument_list|(
name|mymail
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to lock and open %s"
argument_list|,
name|mymail
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|uucp
argument_list|,
operator|(
name|off_t
operator|)
name|offset
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|NOTOK
condition|)
name|adios
argument_list|(
name|mymail
argument_list|,
literal|"unable to position to %ld offset on"
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpfil
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td1
operator|=
name|creat
argument_list|(
name|tmpfil
argument_list|,
name|TMPMODE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to create"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|td1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td1
operator|=
name|open
argument_list|(
name|tmpfil
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|tmpfil
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td2
operator|=
name|dup
argument_list|(
name|td1
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"file descriptor"
argument_list|,
literal|"unable to dup"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uucp2mmdf
argument_list|(
name|uucp
argument_list|,
name|td1
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
case|case
name|MFPRM
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"internal error while filtering UUCP mail"
argument_list|)
expr_stmt|;
case|case
name|MFSIO
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no free file pointers"
argument_list|)
expr_stmt|;
case|case
name|MFERR
case|:
name|adios
argument_list|(
literal|"UUCP mail"
argument_list|,
literal|"i/o error while filtering"
argument_list|)
expr_stmt|;
case|case
name|MFOK
case|:
case|case
name|MFROM
case|:
case|case
name|MFHDR
case|:
case|case
name|MFTXT
case|:
name|timep
index|[
literal|0
index|]
operator|=
name|st
operator|->
name|st_atime
expr_stmt|;
name|timep
index|[
literal|1
index|]
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
name|utime
argument_list|(
name|mymail
argument_list|,
name|timep
argument_list|)
expr_stmt|;
name|st_update
argument_list|(
name|st
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|lkclose
argument_list|(
name|uucp
argument_list|,
name|mymail
argument_list|)
operator|,
name|uucp
operator|=
name|NOTOK
expr_stmt|;
comment|/*
comment|*/
operator|(
name|void
operator|)
name|close
argument_list|(
name|td1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|td2
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|td2
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no free file pointers"
argument_list|)
expr_stmt|;
while|while
condition|(
name|hook
argument_list|(
name|fp
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_function
specifier|static
name|int
name|hook
parameter_list|(
name|in
parameter_list|)
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|;
block|{
name|int
name|child_id
decl_stmt|,
name|done
decl_stmt|,
name|fd1
decl_stmt|,
name|fd2
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|mysndr
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|myfile
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* should insist on isdlm1 (buffer) here... */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|myfile
argument_list|,
name|m_tmpfil
argument_list|(
name|invo_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|creat
argument_list|(
name|myfile
argument_list|,
name|TMPMODE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|myfile
argument_list|,
literal|"unable to create"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|myfile
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|myfile
argument_list|,
literal|"unable to open"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|myfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fd1
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"file descriptor"
argument_list|,
literal|"unable to dup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|out
operator|=
name|fdopen
argument_list|(
name|fd1
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no free file pointers"
argument_list|)
expr_stmt|;
for|for
control|(
name|done
operator|=
name|TRUE
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
name|in
argument_list|)
operator|==
name|NULL
condition|)
break|break;
comment|/* should be error */
if|if
condition|(
name|done
operator|&&
name|isdlm2
argument_list|(
name|buffer
argument_list|)
condition|)
break|break;
name|done
operator|=
name|buffer
index|[
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd2
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seeksndr
argument_list|(
name|fd2
argument_list|,
name|mysndr
argument_list|)
expr_stmt|;
comment|/*
comment|*/
switch|switch
condition|(
name|child_id
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
literal|"fork"
argument_list|,
literal|"unable to"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|OK
case|:
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd2
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|freopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd2
operator|!=
literal|3
condition|)
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|fd2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|closefds
argument_list|(
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCNOTTY
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
operator|)
operator|!=
name|NOTOK
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|i
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|TIOCNOTTY
ifdef|#
directive|ifdef
name|BSD42
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
literal|0
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
name|execlp
argument_list|(
name|slocalproc
argument_list|,
name|r1bindex
argument_list|(
name|slocalproc
argument_list|,
literal|'/'
argument_list|)
argument_list|,
literal|"-file"
argument_list|,
name|myfile
argument_list|,
literal|"-mailbox"
argument_list|,
name|mymail
argument_list|,
literal|"-home"
argument_list|,
name|myhome
argument_list|,
literal|"-addr"
argument_list|,
name|myaddr
argument_list|,
literal|"-user"
argument_list|,
name|myuser
argument_list|,
literal|"-sender"
argument_list|,
name|mysndr
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
name|adios
argument_list|(
name|slocalproc
argument_list|,
literal|"unable to exec"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pidwait
argument_list|(
name|child_id
argument_list|,
name|OK
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|seeksndr
argument_list|(
argument|fd1
argument_list|,
argument|mysndr
argument_list|)
name|int
name|fd1
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|mysndr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd2
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|hp
decl_stmt|,
name|from
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|sender
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|dup
argument_list|(
name|fd1
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
literal|"file descriptor"
argument_list|,
literal|"unable to dup"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|fdopen
argument_list|(
name|fd2
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"no free file pointers"
argument_list|)
expr_stmt|;
for|for
control|(
name|from
index|[
literal|0
index|]
operator|=
name|sender
index|[
literal|0
index|]
operator|=
name|NULL
init|;
name|mfgets
argument_list|(
name|in
argument_list|,
operator|&
name|hp
argument_list|)
operator|!=
name|DONE
condition|;
control|)
if|if
condition|(
operator|(
name|bp
operator|=
name|index
argument_list|(
name|hp
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lequal
argument_list|(
name|hp
argument_list|,
literal|"From"
argument_list|)
condition|)
name|seekaddr
argument_list|(
name|from
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lequal
argument_list|(
name|hp
argument_list|,
literal|"Sender"
argument_list|)
condition|)
name|seekaddr
argument_list|(
name|sender
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mysndr
argument_list|,
name|sender
index|[
literal|0
index|]
condition|?
name|sender
else|:
name|from
index|[
literal|0
index|]
condition|?
name|from
else|:
name|myaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|seekaddr
argument_list|(
argument|addr
argument_list|,
argument|bp
argument_list|)
name|char
operator|*
name|addr
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|adrx
modifier|*
name|adrxp
decl_stmt|;
if|if
condition|(
operator|(
name|adrxp
operator|=
name|seekadrx
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|adrxp
operator|->
name|err
operator|||
operator|!
name|adrxp
operator|->
name|mbox
condition|)
return|return;
if|if
condition|(
name|adrxp
operator|->
name|host
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|addr
argument_list|,
literal|"%s@%s"
argument_list|,
name|adrxp
operator|->
name|mbox
argument_list|,
name|adrxp
operator|->
name|host
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|addr
argument_list|,
name|adrxp
operator|->
name|mbox
argument_list|)
expr_stmt|;
while|while
condition|(
name|seekadrx
argument_list|(
name|NULLCP
argument_list|)
condition|)
continue|continue;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_expr_stmt
specifier|static
name|st_init
argument_list|(
argument|st
argument_list|)
expr|struct
name|stat
operator|*
name|st
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|mystat
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NOTOK
operator|||
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|st
argument_list|,
sizeof|sizeof
expr|*
name|st
argument_list|)
operator|!=
operator|(
sizeof|sizeof
expr|*
name|st
operator|)
condition|)
block|{
name|st
operator|->
name|st_ino
operator|=
operator|(
name|ino_t
operator|)
literal|0
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
operator|(
name|off_t
operator|)
literal|0
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
name|NOTOK
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|st_update
argument_list|(
argument|st
argument_list|)
expr|struct
name|stat
operator|*
name|st
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|static
name|int
name|fd
init|=
name|NOTOK
decl_stmt|;
if|if
condition|(
name|fd
operator|==
name|NOTOK
operator|&&
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|mystat
argument_list|,
name|TMPMODE
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|mystat
argument_list|,
literal|"unable to write"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|st
argument_list|,
sizeof|sizeof
expr|*
name|st
argument_list|)
operator|!=
operator|(
sizeof|sizeof
expr|*
name|st
operator|)
condition|)
name|adios
argument_list|(
name|mystat
argument_list|,
literal|"error writing"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_endif
endif|#
directive|endif
endif|BSD42
end_endif

begin_function
specifier|static
name|int
name|sigser
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|BSD42
operator|(
name|void
operator|)
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|BSD42
name|done
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*
comment|*/
end_comment

begin_function
name|void
name|done
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|lkclose
argument_list|(
name|uucp
argument_list|,
name|mymail
argument_list|)
operator|,
name|uucp
operator|=
name|NOTOK
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

