begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* sendmail.c - */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|Id
index|[]
init|=
literal|"$Id: sendmail.c,v 1.9 1992/11/24 18:37:01 jromine Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  **  A Sendmail fake.  *  * Contributed by Scott Erickson<erickson@ics.uci.edu>  */
end_comment

begin_comment
comment|/* Include files glommed from post.c */
end_comment

begin_include
include|#
directive|include
file|"../h/mh.h"
end_include

begin_include
include|#
directive|include
file|"../h/addrsbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/aliasbr.h"
end_include

begin_include
include|#
directive|include
file|"../h/dropsbr.h"
end_include

begin_include
include|#
directive|include
file|"../zotnet/tws.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MMDFMTS
end_ifndef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_else
else|#
directive|else
else|MMDFMTS
end_else

begin_include
include|#
directive|include
file|"../mts/mmdf/util.h"
end_include

begin_include
include|#
directive|include
file|"../mts/mmdf/mmdf.h"
end_include

begin_endif
endif|#
directive|endif
endif|MMDFMTS
end_endif

begin_include
include|#
directive|include
file|"../zotnet/mts.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MHMTS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
endif|not V7
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
endif|MHMTS
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SENDMTS
end_ifdef

begin_include
include|#
directive|include
file|"../mts/sendmail/smail.h"
end_include

begin_undef
undef|#
directive|undef
name|MF
end_undef

begin_endif
endif|#
directive|endif
endif|SENDMTS
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALE
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|SMTPSRVR
init|=
literal|"smtpsrvr"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|msgfname
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of message file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|FullName
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's full name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sender's mail address */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verify
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extract
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dodist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rewritefrom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return value from procedures */
end_comment

begin_decl_stmt
specifier|static
name|int
name|childid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* id from smtp child process */
end_comment

begin_function_decl
name|TYPESIG
name|die
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|long
name|lclock
init|=
literal|0L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the time we started (more or less) */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pointer for message file */
end_comment

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|tmpfile
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|swit
name|switches
index|[]
init|=
block|{
define|#
directive|define
name|ARPASW
value|0
literal|"ba"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|DAEMONSW
value|1
literal|"bd"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|INITALSW
value|2
literal|"bi"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|DELIVSW
value|3
literal|"bm"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|QSUMSW
value|4
literal|"bp"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|SMTPSW
value|5
literal|"bs"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|ADRTSTSW
value|6
literal|"bt"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|ADRVRFSW
value|7
literal|"bv"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|CFGFRZSW
value|8
literal|"bz"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|ALTCFGSW
value|9
literal|"C"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|DBGVALSW
value|10
literal|"d"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|FULLSW
value|11
literal|"F"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|FROMSW
value|12
literal|"f"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|HOPCNTSW
value|13
literal|"h"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|MSGIDSW
value|14
literal|"M"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|NOALISW
value|15
literal|"n"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|QTIMESW
value|16
literal|"q"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|OBSFRMSW
value|17
literal|"r"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|EXTHDRSW
value|18
literal|"t"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|VERBSW
value|19
literal|"v"
block|,
operator|-
literal|1
block|,
define|#
directive|define
name|ALTALISW
value|20
literal|"oA"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|NOCONSW
value|21
literal|"oc"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|DLVMODSW
value|22
literal|"od"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|NEWALISW
value|23
literal|"oD"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|ERRMODSW
value|24
literal|"oe"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|TMPMODSW
value|25
literal|"oF"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|UFROMSW
value|26
literal|"of"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|GIDSW
value|27
literal|"og"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|HLPFILSW
value|28
literal|"oH"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|NODOTSW
value|29
literal|"oi"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|LOGLEVSW
value|30
literal|"oL"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|MEOKSW
value|31
literal|"om"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|OLDHDRSW
value|32
literal|"oo"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|QDIRSW
value|33
literal|"oQ"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|RTMOUTSW
value|34
literal|"or"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|SFILESW
value|35
literal|"oS"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|QMSGSW
value|36
literal|"os"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|MTMOUTSW
value|37
literal|"oT"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|TZSW
value|38
literal|"ot"
block|,
operator|-
literal|2
block|,
define|#
directive|define
name|UIDSW
value|39
literal|"ou"
block|,
operator|-
literal|2
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|removemsg
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|isheader
argument_list|()
decl_stmt|,
name|sendfile
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
init|=
name|argv
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCALE
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|invo_name
operator|=
name|r1bindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|mts_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|die
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|die
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|die
argument_list|)
expr_stmt|;
name|FullName
operator|=
name|getfullname
argument_list|()
expr_stmt|;
name|from
operator|=
name|adrsprintf
argument_list|(
name|NULLCP
argument_list|,
name|NULLCP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|lclock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
operator|*
name|argp
operator|)
operator|&&
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|argp
operator|++
expr_stmt|;
switch|switch
condition|(
name|smatch
argument_list|(
operator|++
name|cp
argument_list|,
name|switches
argument_list|)
condition|)
block|{
case|case
name|ARPASW
case|:
comment|/* smtp on stdin */
case|case
name|SMTPSW
case|:
comment|/* smtp on stdin */
name|smtp
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|98
argument_list|)
expr_stmt|;
comment|/* should never happen */
case|case
name|DELIVSW
case|:
comment|/* just send mail */
continue|continue;
case|case
name|ADRVRFSW
case|:
comment|/* verify mode */
name|verify
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|FROMSW
case|:
comment|/* from address */
case|case
name|OBSFRMSW
case|:
comment|/* obsolete -f flag */
if|if
condition|(
operator|*
operator|(
operator|++
name|cp
operator|)
operator|==
literal|'\0'
operator|&&
operator|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* At this point, cp points to the from name */
if|if
condition|(
name|rewritefrom
condition|)
block|{
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"More than one \"from\" person"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|from
operator|=
name|cp
expr_stmt|;
name|rewritefrom
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|EXTHDRSW
case|:
comment|/* read recipients from message */
name|extract
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|VERBSW
case|:
comment|/* give blow-by-blow description */
name|verbose
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* These switches have no args. */
case|case
name|QMSGSW
case|:
comment|/* always queue the message */
case|case
name|DAEMONSW
case|:
comment|/* run as a daemon& wait for SMTP */
case|case
name|INITALSW
case|:
comment|/* initialize the alias database */
case|case
name|QSUMSW
case|:
comment|/* print summary of mail queue */
case|case
name|ADRTSTSW
case|:
comment|/* test the addresses to debug config file */
case|case
name|CFGFRZSW
case|:
comment|/* create the configuration freeze file */
case|case
name|NOALISW
case|:
comment|/* do not do aliasing */
case|case
name|NOCONSW
case|:
comment|/* do not initiate immediate host connection */
case|case
name|NEWALISW
case|:
comment|/* run newaliases to rebuild db */
case|case
name|UFROMSW
case|:
comment|/* save UNIX-style From lines at front of msg*/
case|case
name|NODOTSW
case|:
comment|/* dots on line are not msg terminators */
case|case
name|MEOKSW
case|:
comment|/* ok to send to me if I'm in an alias */
case|case
name|OLDHDRSW
case|:
comment|/* msg may have old-style headers */
continue|continue;
comment|/* These switches have string args. */
case|case
name|ALTALISW
case|:
comment|/* use alternate alias file */
case|case
name|ALTCFGSW
case|:
comment|/* use alternate configuration file */
case|case
name|DBGVALSW
case|:
comment|/* set the debug value */
case|case
name|FULLSW
case|:
comment|/* set full name */
case|case
name|MSGIDSW
case|:
comment|/* try to deliver queued msg with msg-id */
case|case
name|QTIMESW
case|:
comment|/* interval between queue passes */
case|case
name|DLVMODSW
case|:
comment|/* set the delivery mode */
case|case
name|ERRMODSW
case|:
comment|/* set the error mode */
case|case
name|TMPMODSW
case|:
comment|/* the mode to use when creating tmp files */
case|case
name|HLPFILSW
case|:
comment|/* the SMTP help file */
case|case
name|QDIRSW
case|:
comment|/* directory into which to queue messages */
case|case
name|RTMOUTSW
case|:
comment|/* timeout on reads */
case|case
name|SFILESW
case|:
comment|/* save statistics in this file */
case|case
name|MTMOUTSW
case|:
comment|/* timeout on messages in the queue */
case|case
name|TZSW
case|:
comment|/* set the name of the timezone */
if|if
condition|(
operator|*
operator|(
operator|++
name|cp
operator|)
operator|==
literal|'\0'
operator|&&
operator|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* At this point, cp points to the argument */
continue|continue;
comment|/* Ignore */
comment|/* These switches have numeric args. */
case|case
name|HOPCNTSW
case|:
comment|/* hop count */
case|case
name|GIDSW
case|:
comment|/* gid when calling mailers */
case|case
name|LOGLEVSW
case|:
comment|/* the log level */
case|case
name|UIDSW
case|:
comment|/* uid when calling mailers */
if|if
condition|(
operator|*
operator|(
operator|++
name|cp
operator|)
operator|==
literal|'\0'
operator|&&
operator|(
operator|!
operator|(
name|cp
operator|=
operator|*
name|argp
operator|++
operator|)
operator|||
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"missing argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* At this point, cp points to the numeric arg */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"non-numeric argument to %s"
argument_list|,
name|argp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Ignore */
block|}
block|}
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
operator|&&
name|extract
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"mode not supported on header components"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|argp
operator|==
name|NULL
operator|&&
operator|!
name|extract
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"usage: /usr/lib/sendmail [flags] addr..."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|msgfname
argument_list|,
literal|"/tmp/sendmhXXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mktemp
argument_list|(
name|msgfname
argument_list|)
operator|==
name|NULL
condition|)
name|adios
argument_list|(
name|msgfname
argument_list|,
literal|"can't create msg file "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|msgfname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|adios
argument_list|(
name|msgfname
argument_list|,
literal|"error opening "
argument_list|)
expr_stmt|;
block|}
name|doheader
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|status
operator|=
name|doverify
argument_list|()
expr_stmt|;
name|removemsg
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|dobody
argument_list|()
expr_stmt|;
name|status
operator|=
name|sendfile
argument_list|()
expr_stmt|;
name|removemsg
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|removemsg
parameter_list|()
block|{
if|if
condition|(
name|unlink
argument_list|(
name|msgfname
argument_list|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"unlink"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|doheader
argument_list|(
argument|argp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|gotdate
decl_stmt|,
name|gotfrom
decl_stmt|,
name|gotsender
decl_stmt|,
name|gotto
decl_stmt|;
comment|/* if we're not extracting the headers from the message, then we      * need to check to see if we need to do a "send" or a "dist".      */
if|if
condition|(
operator|!
name|extract
condition|)
block|{
comment|/* If we're doing a verify, just create a "To:" header. */
if|if
condition|(
operator|!
name|verify
condition|)
block|{
name|gotdate
operator|=
name|gotfrom
operator|=
name|gotto
operator|=
name|gotsender
operator|=
name|dodist
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
comment|/* end of header */
break|break;
if|if
condition|(
operator|!
name|isheader
argument_list|(
name|line
argument_list|)
condition|)
break|break;
comment|/* if any of the following headers are present, then we 		 * want to do a dist. 		 */
if|if
condition|(
operator|!
name|gotdate
operator|&&
name|uprf
argument_list|(
name|line
argument_list|,
literal|"date"
argument_list|)
condition|)
name|gotdate
operator|=
name|dodist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|gotto
operator|&&
operator|(
name|uprf
argument_list|(
name|line
argument_list|,
literal|"to"
argument_list|)
operator|||
name|uprf
argument_list|(
name|line
argument_list|,
literal|"cc"
argument_list|)
operator|)
condition|)
name|gotto
operator|=
name|dodist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|uprf
argument_list|(
name|line
argument_list|,
literal|"message-id"
argument_list|)
condition|)
name|dodist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|gotsender
operator|&&
name|uprf
argument_list|(
name|line
argument_list|,
literal|"sender"
argument_list|)
condition|)
name|gotsender
operator|=
name|dodist
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|uprf
argument_list|(
name|line
argument_list|,
literal|"resent-"
argument_list|)
condition|)
block|{
name|dodist
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Prev-"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* See if we are re-writing the from line */
if|if
condition|(
name|uprf
argument_list|(
name|line
argument_list|,
literal|"from"
argument_list|)
condition|)
block|{
name|gotfrom
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rewritefrom
condition|)
name|dofrom
argument_list|()
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now, generate a "to" line.  The first line is easy. 	 * Write the rest of the lines with a newline/tab so that we 	 * don't accidentally write a line that's too long to be parsed 	 * by post. 	 */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sTo: %s"
argument_list|,
operator|(
name|dodist
condition|?
literal|"Resent-"
else|:
literal|""
operator|)
argument_list|,
operator|*
name|argp
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|argp
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|",\n\t%s"
argument_list|,
operator|*
name|argp
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* If we're doing a dist, we must have a "Date:" and "From:" field. 	 */
if|if
condition|(
name|dodist
condition|)
block|{
if|if
condition|(
operator|!
name|gotdate
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Date: %s\n"
argument_list|,
name|dtime
argument_list|(
operator|&
name|lclock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotfrom
condition|)
name|dofrom
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MMDFI
comment|/* sigh */
if|if
condition|(
operator|!
name|gotsender
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Sender: %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MMDFI
block|}
else|else
block|{
comment|/* we're verifying, so just pass everything through */
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
comment|/* end of header */
break|break;
if|if
condition|(
name|rewritefrom
operator|&&
name|uprf
argument_list|(
name|line
argument_list|,
literal|"from"
argument_list|)
condition|)
name|dofrom
argument_list|()
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point, line is either a newline (end of header) or the      * first line of the body (poorly formatted message).  If line      * contains a line of body from a poorly formatted message, then      * print a newline to separate the header correctly, then print      * the body line.      */
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
comment|/* i.e. a "body" line */
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|isheader
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* If the first character is a space, assume a continuation of a header */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If there's no ':', it's not a header */
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If there's a space between BOL and ':', it's not a header */
while|while
condition|(
name|s
operator|<
name|cp
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This procedure does the verify and returns the status */
end_comment

begin_macro
name|doverify
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|command
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|FILE
modifier|*
name|verfp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
comment|/* set up the command line for post */
if|if
condition|(
operator|(
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|postproc
argument_list|)
operator|+
name|strlen
argument_list|(
literal|" -whom -check -verbose "
argument_list|)
operator|+
name|strlen
argument_list|(
name|msgfname
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|command
argument_list|,
name|postproc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|" -whom -check "
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-verbose "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
name|msgfname
argument_list|)
expr_stmt|;
comment|/* open up the pipe */
if|if
condition|(
operator|(
name|verfp
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|verfp
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* sendmail returns: 	 *   address:  result 	 * so we need to strip the extra post headers. 	 */
if|if
condition|(
name|verbose
condition|)
block|{
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'-'
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|bp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* return the error status of post */
return|return
operator|(
name|pclose
argument_list|(
name|verfp
argument_list|)
operator|>>
literal|8
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|sendfile
parameter_list|()
block|{
name|char
modifier|*
name|command
decl_stmt|,
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|verfp
decl_stmt|,
modifier|*
name|popen
argument_list|()
decl_stmt|;
comment|/* set up the command line for post */
if|if
condition|(
operator|(
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|postproc
argument_list|)
operator|+
name|strlen
argument_list|(
literal|" -dist -verbose "
argument_list|)
operator|+
name|strlen
argument_list|(
name|msgfname
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
return|return
name|NOTOK
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|command
argument_list|,
name|postproc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-verbose "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dodist
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-dist "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|command
argument_list|,
name|msgfname
argument_list|)
expr_stmt|;
comment|/* open up the pipe */
if|if
condition|(
operator|(
name|verfp
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NOTOK
return|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|verfp
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* return the error status of post */
return|return
operator|(
name|pclose
argument_list|(
name|verfp
argument_list|)
operator|>>
literal|8
operator|)
return|;
block|}
end_function

begin_macro
name|dofrom
argument_list|()
end_macro

begin_block
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|FullName
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"From: %s<%s>\n"
argument_list|,
name|FullName
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"From: %s\n"
argument_list|,
name|from
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dobody
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
operator|&&
operator|!
name|ferror
argument_list|(
name|stdin
argument_list|)
operator|&&
operator|(
name|i
operator|=
name|fread
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|i
argument_list|,
name|fp
argument_list|)
operator|!=
name|i
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"Problem writing body"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdin
argument_list|)
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"Problem reading body"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"problem ending submission"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
name|TYPESIG
name|silentdie
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|smtp
argument_list|()
end_macro

begin_block
block|{
name|int
name|sd
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|response
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|client
argument_list|(
name|NULLCP
argument_list|,
literal|"tcp"
argument_list|,
literal|"smtp"
argument_list|,
literal|0
argument_list|,
name|response
argument_list|)
operator|)
operator|==
name|NOTOK
condition|)
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"cannot open smtp client process"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|silentdie
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|childid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
name|NOTOK
case|:
name|adios
argument_list|(
name|NULLCP
argument_list|,
literal|"unable to fork smtp process"
argument_list|)
expr_stmt|;
case|case
name|OK
case|:
comment|/* i.e. child */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* i.e. parent */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|childid
condition|)
operator|(
name|void
operator|)
name|kill
argument_list|(
name|childid
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|TYPESIG
name|die
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|fp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|msgfname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sig
operator|!=
name|SIGHUP
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sendmail: dying from signal %d\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|TYPESIG
name|silentdie
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|pidwait
argument_list|(
name|childid
argument_list|,
name|OK
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

