begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)input-scrub.c	6.4 (Berkeley) %G%"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* input_scrub.c - layer between app and the rest of the world    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"read.h"
end_include

begin_include
include|#
directive|include
file|"input-file.h"
end_include

begin_comment
comment|/*  * O/S independent module to supply buffers of sanitised source code  * to rest of assembler. We get raw input data of some length.  * Also looks after line numbers, for e.g. error messages.  * This module used to do the sanitising, but now a pre-processor program  * (app) does that job so this module is degenerate.  * Now input is pre-sanitised, so we only worry about finding the  * last partial line. A buffer of full lines is returned to caller.  * The last partial line begins the next buffer we build and return to caller.  * The buffer returned to caller is preceeded by BEFORE_STRING and followed  * by AFTER_STRING. The last character before AFTER_STRING is a newline.  */
end_comment

begin_comment
comment|/*  * We expect the following sanitation has already been done.  *  * No comments, reduce a comment to a space.  * Reduce a tab to a space unless it is 1st char of line.  * All multiple tabs and spaces collapsed into 1 char. Tab only  *   legal if 1st char of line.  * # line file statements converted to .line x;.file y; statements.  * Escaped newlines at end of line: remove them but add as many newlines  *   to end of statement as you removed in the middle, to synch line numbers.  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|BEFORE_STRING
value|("\n")
end_define

begin_define
define|#
directive|define
name|AFTER_STRING
value|("\0")
end_define

begin_comment
comment|/* bcopy of 0 chars might choke. */
end_comment

begin_define
define|#
directive|define
name|BEFORE_SIZE
value|(1)
end_define

begin_define
define|#
directive|define
name|AFTER_SIZE
value|(1)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -> 1st char of full buffer area. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|partial_where
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -> after last full line in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|partial_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>=0. Number of chars in partial line in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_source
index|[
name|AFTER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Because we need AFTER_STRING just after last */
end_comment

begin_comment
comment|/* full line, it clobbers 1st part of partial */
end_comment

begin_comment
comment|/* line. So we preserve 1st part of partial */
end_comment

begin_comment
comment|/* line here. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|buffer_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What is the largest size buffer that */
end_comment

begin_comment
comment|/* input_file_give_next_buffer() could */
end_comment

begin_comment
comment|/* return to us? */
end_comment

begin_function_decl
specifier|static
name|void
name|as_1_char
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* We never have more than one source file open at once. We may, however, read more than 1 source file in an assembly. NULL means we have no file open right now. */
end_comment

begin_comment
comment|/* We must track the physical file and line number for error messages. We also track a "logical" file and line number corresponding to (C?) compiler source line numbers. Whenever we open a file we must fill in physical_input_file. So if it is NULL we have not opened any files yet. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|physical_input_file
decl_stmt|,
modifier|*
name|logical_input_file
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|int
name|line_numberT
typedef|;
end_typedef

begin_comment
comment|/* 1-origin line number in a source file. */
end_comment

begin_comment
comment|/* A line ends in '\n' or eof. */
end_comment

begin_decl_stmt
specifier|static
name|line_numberT
name|physical_input_line
decl_stmt|,
name|logical_input_line
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|input_scrub_begin
parameter_list|()
block|{
name|know
argument_list|(
name|strlen
argument_list|(
name|BEFORE_STRING
argument_list|)
operator|==
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|strlen
argument_list|(
name|AFTER_STRING
argument_list|)
operator|==
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|input_file_begin
argument_list|()
expr_stmt|;
name|buffer_length
operator|=
name|input_file_buffer_size
argument_list|()
expr_stmt|;
name|buffer_start
operator|=
name|xmalloc
argument_list|(
call|(
name|long
call|)
argument_list|(
name|BEFORE_SIZE
operator|+
name|buffer_length
operator|+
name|buffer_length
operator|+
name|AFTER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|BEFORE_STRING
argument_list|,
name|buffer_start
argument_list|,
operator|(
name|int
operator|)
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
comment|/* Line number things. */
name|logical_input_line
operator|=
literal|0
expr_stmt|;
name|logical_input_file
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|physical_input_file
operator|=
name|NULL
expr_stmt|;
comment|/* No file read yet. */
name|do_scrub_begin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|input_scrub_end
parameter_list|()
block|{
name|input_file_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
comment|/* Return start of caller's part of buffer. */
name|input_scrub_new_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|input_file_open
argument_list|(
name|filename
argument_list|,
operator|!
name|flagseen
index|[
literal|'f'
index|]
argument_list|)
expr_stmt|;
name|physical_input_file
operator|=
name|filename
index|[
literal|0
index|]
condition|?
name|filename
else|:
literal|"{standard input}"
expr_stmt|;
name|physical_input_line
operator|=
literal|0
expr_stmt|;
name|partial_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|input_scrub_next_buffer
parameter_list|(
name|bufp
parameter_list|)
name|char
modifier|*
modifier|*
name|bufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|limit
decl_stmt|;
comment|/* -> just after last char of buffer. */
ifdef|#
directive|ifdef
name|DONTDEF
if|if
condition|(
name|preprocess
condition|)
block|{
if|if
condition|(
name|save_buffer
condition|)
block|{
operator|*
name|bufp
operator|=
name|save_buffer
expr_stmt|;
name|save_buffer
operator|=
literal|0
expr_stmt|;
block|}
name|limit
operator|=
name|input_file_give_next_buffer
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|limit
condition|)
block|{
name|partial_where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial_size
condition|)
name|as_warn
argument_list|(
literal|"Partial line at end of file ignored"
argument_list|)
expr_stmt|;
return|return
name|partial_where
return|;
block|}
if|if
condition|(
name|partial_size
condition|)
name|bcopy
argument_list|(
name|save_source
argument_list|,
name|partial_where
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|do_scrub
argument_list|(
name|partial_where
argument_list|,
name|partial_size
argument_list|,
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
name|limit
operator|-
operator|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|)
argument_list|,
operator|&
name|out_string
argument_list|,
operator|&
name|out_length
argument_list|)
expr_stmt|;
name|limit
operator|=
name|out_string
operator|+
name|out_length
expr_stmt|;
for|for
control|(
name|p
operator|=
name|limit
init|;
operator|*
operator|--
name|p
operator|!=
literal|'\n'
condition|;
control|)
empty_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|<=
name|buffer_start
operator|+
name|BEFORE_SIZE
condition|)
name|as_fatal
argument_list|(
literal|"Source line too long.  Please change file '%s' and re-make the assembler."
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
name|partial_where
operator|=
name|p
expr_stmt|;
name|partial_size
operator|=
name|limit
operator|-
name|p
expr_stmt|;
name|bcopy
argument_list|(
name|partial_where
argument_list|,
name|save_source
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|AFTER_STRING
argument_list|,
name|partial_where
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|save_buffer
operator|=
operator|*
name|bufp
expr_stmt|;
operator|*
name|bufp
operator|=
name|out_string
expr_stmt|;
return|return
name|partial_where
return|;
block|}
comment|/* We're not preprocessing.  Do the right thing */
endif|#
directive|endif
if|if
condition|(
name|partial_size
condition|)
block|{
name|bcopy
argument_list|(
name|partial_where
argument_list|,
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
operator|(
name|int
operator|)
name|partial_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|save_source
argument_list|,
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
block|}
name|limit
operator|=
name|input_file_give_next_buffer
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|+
name|partial_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find last newline. */
for|for
control|(
name|p
operator|=
name|limit
init|;
operator|*
operator|--
name|p
operator|!=
literal|'\n'
condition|;
control|)
block|{ 	}
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|<=
name|buffer_start
operator|+
name|BEFORE_SIZE
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Source line too long. Please change file %s then rebuild assembler."
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
name|partial_where
operator|=
name|p
expr_stmt|;
name|partial_size
operator|=
name|limit
operator|-
name|p
expr_stmt|;
name|bcopy
argument_list|(
name|partial_where
argument_list|,
name|save_source
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|AFTER_STRING
argument_list|,
name|partial_where
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partial_where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial_size
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Partial line at end of file ignored"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|partial_where
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The remaining part of this file deals with line numbers, error  * messages and so on.  */
end_comment

begin_function
name|int
name|seen_at_least_1_file
parameter_list|()
comment|/* TRUE if we opened any file. */
block|{
return|return
operator|(
name|physical_input_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bump_line_counters
parameter_list|()
block|{
operator|++
name|physical_input_line
expr_stmt|;
operator|++
name|logical_input_line
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			new_logical_line()  *  * Tells us what the new logical line number and file are.  * If the line_number is<0, we don't change the current logical line number.  * If the fname is NULL, we don't change the current logical file name.  */
end_comment

begin_function
name|void
name|new_logical_line
parameter_list|(
name|fname
parameter_list|,
name|line_number
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* DON'T destroy it! We point to it! */
name|int
name|line_number
decl_stmt|;
block|{
if|if
condition|(
name|fname
condition|)
block|{
name|logical_input_file
operator|=
name|fname
expr_stmt|;
block|}
if|if
condition|(
name|line_number
operator|>=
literal|0
condition|)
block|{
name|logical_input_line
operator|=
name|line_number
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			a s _ w h e r e ( )  *  * Write a line to stderr locating where we are in reading  * input source files.  * As a sop to the debugger of AS, pretty-print the offending line.  */
end_comment

begin_function
name|void
name|as_where
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|line_numberT
name|line
decl_stmt|;
if|if
condition|(
name|physical_input_file
condition|)
block|{
comment|/* we tried to read SOME source */
if|if
condition|(
name|input_file_is_open
argument_list|()
condition|)
block|{
comment|/* we can still read lines from source */
ifdef|#
directive|ifdef
name|DONTDEF
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" @ physical line %ld., file \"%s\""
argument_list|,
operator|(
name|long
operator|)
name|physical_input_line
argument_list|,
name|physical_input_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" @ logical line %ld., file \"%s\"\n"
argument_list|,
operator|(
name|long
operator|)
name|logical_input_line
argument_list|,
name|logical_input_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|as_howmuch
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|logical_input_file
condition|?
name|logical_input_file
else|:
name|physical_input_file
expr_stmt|;
name|line
operator|=
name|logical_input_line
condition|?
name|logical_input_line
else|:
name|physical_input_line
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%u:"
argument_list|,
name|p
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DONTDEF
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" After reading source.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|logical_input_file
condition|?
name|logical_input_file
else|:
name|physical_input_file
expr_stmt|;
name|line
operator|=
name|logical_input_line
condition|?
name|logical_input_line
else|:
name|physical_input_line
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:unknown:"
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DONTDEF
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" Before reading source.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Support for source file debugging.  These functions handle  * logical lines and logical files.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|saved_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|saved_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|line_numberT
name|saved_line
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|filestab
parameter_list|()
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|physical_input_file
operator|||
operator|!
name|input_file_is_open
argument_list|()
condition|)
return|return;
name|file
operator|=
name|logical_input_file
condition|?
name|logical_input_file
else|:
name|physical_input_file
expr_stmt|;
if|if
condition|(
name|saved_file
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file
argument_list|,
name|saved_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|stabs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|saved_len
condition|)
block|{
if|if
condition|(
name|saved_file
operator|==
literal|0
condition|)
name|saved_file
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|saved_file
operator|=
name|xrealloc
argument_list|(
name|saved_file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|saved_file
argument_list|,
name|file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|saved_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|saved_file
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|saved_line
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|funcstab
parameter_list|(
name|func
parameter_list|)
name|char
modifier|*
name|func
decl_stmt|;
block|{
if|if
condition|(
name|now_seg
operator|!=
name|SEG_TEXT
condition|)
return|return;
name|filestab
argument_list|()
expr_stmt|;
name|stabf
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|linestab
parameter_list|()
block|{
name|line_numberT
name|line
decl_stmt|;
if|if
condition|(
name|now_seg
operator|!=
name|SEG_TEXT
condition|)
return|return;
name|filestab
argument_list|()
expr_stmt|;
name|line
operator|=
name|logical_input_line
condition|?
name|logical_input_line
else|:
name|physical_input_line
expr_stmt|;
if|if
condition|(
name|saved_line
operator|==
literal|0
operator|||
name|line
operator|!=
name|saved_line
condition|)
block|{
name|stabd
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|saved_line
operator|=
name|line
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			a s _ h o w m u c h ( )  *  * Output to given stream how much of line we have scanned so far.  * Assumes we have scanned up to and including input_line_pointer.  * No free '\n' at end of line.  */
end_comment

begin_function
name|void
name|as_howmuch
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
comment|/* Opened for write please. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Scan input line. */
comment|/* register	char	c; JF unused */
for|for
control|(
name|p
operator|=
name|input_line_pointer
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|--
name|p
control|)
block|{     }
operator|++
name|p
expr_stmt|;
comment|/* p -> 1st char of line. */
for|for
control|(
init|;
name|p
operator|<=
name|input_line_pointer
condition|;
name|p
operator|++
control|)
block|{
comment|/* Assume ASCII. EBCDIC& other micro-computer char sets ignored. */
comment|/* c = *p& 0xFF; JF unused */
name|as_1_char
argument_list|(
operator|*
name|p
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|as_1_char
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|unsigned
name|char
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'^'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|+=
literal|'@'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end: input_scrub.c */
end_comment

end_unit

