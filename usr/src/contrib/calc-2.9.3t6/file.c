begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * File I/O routines callable by users.  */
end_comment

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_define
define|#
directive|define
name|READSIZE
value|1024
end_define

begin_comment
comment|/* buffer size for reading */
end_comment

begin_comment
comment|/*  * Definition of opened files.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|FILEID
name|id
decl_stmt|;
comment|/* id to identify this file */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* real file structure for I/O */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name */
name|BOOL
name|reading
decl_stmt|;
comment|/* TRUE if opened for reading */
name|BOOL
name|writing
decl_stmt|;
comment|/* TRUE if opened for writing */
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* open mode */
block|}
name|FILEIO
typedef|;
end_typedef

begin_comment
comment|/*  * Table of opened files.  * The first three entries always correspond to stdin, stdout, and stderr,  * and cannot be closed.  Their file ids are always 0, 1, and 2.  */
end_comment

begin_decl_stmt
specifier|static
name|FILEIO
name|files
index|[
name|MAXFILES
index|]
init|=
block|{
name|FILEID_STDIN
block|,
name|NULL
block|,
literal|"(stdin)"
block|,
name|TRUE
block|,
name|FALSE
block|,
literal|"reading"
block|,
name|FILEID_STDOUT
block|,
name|NULL
block|,
literal|"(stdout)"
block|,
name|FALSE
block|,
name|TRUE
block|,
literal|"writing"
block|,
name|FILEID_STDERR
block|,
name|NULL
block|,
literal|"(stderr)"
block|,
name|FALSE
block|,
name|TRUE
block|,
literal|"writing"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILEID
name|lastid
init|=
name|FILEID_STDERR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last allocated file id */
end_comment

begin_comment
comment|/*  * file_init - perform needed initilization work  *  * On some systems, one cannot initialize a pointer to a FILE *.  * This routine, called once at startup is a work-a-round for  * systems with such bogons.  */
end_comment

begin_function
name|void
name|file_init
parameter_list|()
block|{
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
comment|/* 1 => routine already called */
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|files
index|[
literal|0
index|]
operator|.
name|fp
operator|=
name|stdin
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|.
name|fp
operator|=
name|stdout
expr_stmt|;
name|files
index|[
literal|2
index|]
operator|.
name|fp
operator|=
name|stderr
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Open the specified file name for reading or writing as determined by  * the specified mode ("r", "w", or "a").  Returns a file id which can be  * used to do I/O to the file, or else FILEID_NONE if the open failed.  * Aborts with an error if too many files are opened or the mode is illegal.  */
end_comment

begin_function
name|FILEID
name|openid
parameter_list|(
name|name
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name */
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* open mode */
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|FILEID
name|id
decl_stmt|;
comment|/* new file id */
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|mode
operator|!=
literal|'r'
operator|)
operator|&&
operator|(
operator|*
name|mode
operator|!=
literal|'w'
operator|)
operator|&&
operator|(
operator|*
name|mode
operator|!=
literal|'a'
operator|)
operator|)
operator|||
name|mode
index|[
literal|1
index|]
condition|)
name|math_error
argument_list|(
literal|"Illegal mode for fopen"
argument_list|)
expr_stmt|;
name|count
operator|=
name|MAXFILES
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Too many open files"
argument_list|)
expr_stmt|;
name|id
operator|=
operator|++
name|lastid
expr_stmt|;
name|fiop
operator|=
operator|&
name|files
index|[
name|id
operator|%
name|MAXFILES
index|]
expr_stmt|;
block|}
do|while
condition|(
name|fiop
operator|->
name|reading
operator|||
name|fiop
operator|->
name|writing
condition|)
do|;
name|fiop
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiop
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|lastid
operator|--
expr_stmt|;
name|math_error
argument_list|(
literal|"No memory for filename"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|fiop
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|fp
operator|=
name|f_open
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiop
operator|->
name|fp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|fiop
operator|->
name|name
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|lastid
operator|--
expr_stmt|;
return|return
name|FILEID_NONE
return|;
block|}
switch|switch
condition|(
operator|*
name|mode
condition|)
block|{
case|case
literal|'r'
case|:
name|fiop
operator|->
name|mode
operator|=
literal|"reading"
expr_stmt|;
name|fiop
operator|->
name|reading
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fiop
operator|->
name|mode
operator|=
literal|"writing"
expr_stmt|;
name|fiop
operator|->
name|writing
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|fiop
operator|->
name|mode
operator|=
literal|"appending"
expr_stmt|;
name|fiop
operator|->
name|writing
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|fiop
operator|->
name|id
operator|=
name|id
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/*  * Find the file I/O structure for the specified file id, and verify that  * it is opened in the required manner ('r' for reading or 'w' for writing).  * If mode is 0, then no open checks are made at all, and NULL is then  * returned if the id represents a closed file.  */
end_comment

begin_function
specifier|static
name|FILEIO
modifier|*
name|findid
parameter_list|(
name|id
parameter_list|,
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
name|FILEID
name|id
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
specifier|static
name|char
modifier|*
name|msg
decl_stmt|;
name|BOOL
name|flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|<
literal|0
operator|)
operator|||
operator|(
name|id
operator|>
name|lastid
operator|)
condition|)
name|math_error
argument_list|(
literal|"Illegal file id"
argument_list|)
expr_stmt|;
name|fiop
operator|=
operator|&
name|files
index|[
name|id
operator|%
name|MAXFILES
index|]
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'r'
case|:
name|msg
operator|=
literal|"Reading from"
expr_stmt|;
name|flag
operator|=
name|fiop
operator|->
name|reading
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|msg
operator|=
literal|"Writing to"
expr_stmt|;
name|flag
operator|=
name|fiop
operator|->
name|writing
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|msg
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Unknown findid mode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fiop
operator|->
name|id
operator|!=
name|id
condition|)
block|{
if|if
condition|(
name|msg
condition|)
name|math_error
argument_list|(
literal|"%s closed file"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|msg
operator|&&
operator|!
name|flag
condition|)
name|math_error
argument_list|(
literal|"%s file not opened that way"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|fiop
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not a file id is valid.  This is used for if tests.  */
end_comment

begin_function
name|BOOL
name|validid
parameter_list|(
name|id
parameter_list|)
name|FILEID
name|id
decl_stmt|;
block|{
return|return
operator|(
name|findid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the file id for the entry in the file table at the specified index.  * Returns FILEID_NONE if the index is illegal or the file is closed.  */
end_comment

begin_function
name|FILEID
name|indexid
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|MAXFILES
operator|)
condition|)
return|return
name|FILEID_NONE
return|;
name|fiop
operator|=
operator|&
name|files
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|fiop
operator|->
name|reading
operator|||
name|fiop
operator|->
name|writing
condition|)
return|return
name|fiop
operator|->
name|id
return|;
return|return
name|FILEID_NONE
return|;
block|}
end_function

begin_comment
comment|/*  * Close the specified file id.  Returns TRUE if there was an error.  * Closing of stdin, stdout, or stderr is illegal, but closing of already  * closed files is allowed.  */
end_comment

begin_function
name|BOOL
name|closeid
parameter_list|(
name|id
parameter_list|)
name|FILEID
name|id
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|==
name|FILEID_STDIN
operator|)
operator|||
operator|(
name|id
operator|==
name|FILEID_STDOUT
operator|)
operator|||
operator|(
name|id
operator|==
name|FILEID_STDERR
operator|)
condition|)
name|math_error
argument_list|(
literal|"Cannot close stdin, stdout, or stderr"
argument_list|)
expr_stmt|;
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiop
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|fiop
operator|->
name|id
operator|=
name|FILEID_NONE
expr_stmt|;
if|if
condition|(
operator|!
name|fiop
operator|->
name|reading
operator|&&
operator|!
name|fiop
operator|->
name|writing
condition|)
name|math_error
argument_list|(
literal|"Closing non-opened file"
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|reading
operator|=
name|FALSE
expr_stmt|;
name|fiop
operator|->
name|writing
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|fiop
operator|->
name|name
condition|)
name|free
argument_list|(
name|fiop
operator|->
name|name
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|ferror
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
expr_stmt|;
name|err
operator||=
name|fclose
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
expr_stmt|;
name|fiop
operator|->
name|fp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not an error occurred to a file.  */
end_comment

begin_function
name|BOOL
name|errorid
parameter_list|(
name|id
parameter_list|)
name|FILEID
name|id
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiop
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Closed file for ferror"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ferror
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not end of file occurred to a file.  */
end_comment

begin_function
name|BOOL
name|eofid
parameter_list|(
name|id
parameter_list|)
name|FILEID
name|id
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiop
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Closed file for feof"
argument_list|)
expr_stmt|;
return|return
operator|(
name|feof
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush output to an opened file.  */
end_comment

begin_function
name|void
name|flushid
parameter_list|(
name|id
parameter_list|)
name|FILEID
name|id
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the next line from an opened file.  * Returns a pointer to an allocated string holding the null-terminated  * line (without any terminating newline), or else a NULL pointer on an  * end of file or error.  */
end_comment

begin_function
name|void
name|readid
parameter_list|(
name|id
parameter_list|,
name|retptr
parameter_list|)
name|FILEID
name|id
decl_stmt|;
comment|/* file to read from */
name|char
modifier|*
modifier|*
name|retptr
decl_stmt|;
comment|/* returned pointer to string */
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|char
modifier|*
name|str
decl_stmt|;
comment|/* current string */
name|int
name|len
decl_stmt|;
comment|/* current length of string */
name|int
name|totlen
decl_stmt|;
comment|/* total length of string */
name|char
name|buf
index|[
name|READSIZE
index|]
decl_stmt|;
comment|/* temporary buffer */
name|totlen
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|'r'
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|READSIZE
argument_list|,
name|fiop
operator|->
name|fp
argument_list|)
operator|&&
name|buf
index|[
literal|0
index|]
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
condition|)
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|str
argument_list|,
name|totlen
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"No memory in freadline"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|str
index|[
name|totlen
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|str
index|[
name|totlen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|retptr
operator|=
name|str
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|totlen
operator|&&
name|ferror
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|retptr
operator|=
name|str
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the next character from an opened file.  * Returns EOF if there was an error or end of file.  */
end_comment

begin_function
name|int
name|getcharid
parameter_list|(
name|id
parameter_list|)
name|FILEID
name|id
decl_stmt|;
block|{
return|return
name|fgetc
argument_list|(
name|findid
argument_list|(
name|id
argument_list|,
literal|'r'
argument_list|)
operator|->
name|fp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the name of an opened file.  * If the file has been closed, a null name is printed.  * If flags contain PRINT_UNAMBIG then extra information is printed  * identifying the output as a file and some data about it.  */
end_comment

begin_function
name|void
name|printid
parameter_list|(
name|id
parameter_list|,
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
name|FILEID
name|id
decl_stmt|;
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
comment|/* file structure */
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fiop
operator|==
name|NULL
condition|)
block|{
name|math_str
argument_list|(
operator|(
name|flags
operator|&
name|PRINT_UNAMBIG
operator|)
condition|?
literal|"FILE (closed)"
else|:
literal|"\"\""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|PRINT_UNAMBIG
operator|)
operator|==
literal|0
condition|)
block|{
name|math_chr
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
name|fiop
operator|->
name|name
argument_list|)
expr_stmt|;
name|math_chr
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
name|fiop
operator|->
name|fp
expr_stmt|;
name|math_fmt
argument_list|(
literal|"FILE \"%s\" (%s, pos %ld"
argument_list|,
name|fiop
operator|->
name|name
argument_list|,
name|fiop
operator|->
name|mode
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|math_str
argument_list|(
literal|", error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
name|math_str
argument_list|(
literal|", eof"
argument_list|)
expr_stmt|;
name|math_chr
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a formatted string similar to printf.  Various formats of output  * are possible, depending on the format string AND the actual types of the  * values.  Mismatches do not cause errors, instead something reasonable is  * printed instead.  The output goes to the file with the specified id.  */
end_comment

begin_function
name|void
name|idprintf
parameter_list|(
name|id
parameter_list|,
name|fmt
parameter_list|,
name|count
parameter_list|,
name|vals
parameter_list|)
name|int
name|count
decl_stmt|;
name|FILEID
name|id
decl_stmt|;
comment|/* file id to print to */
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* standard format string */
name|VALUE
modifier|*
modifier|*
name|vals
decl_stmt|;
comment|/* table of values to print */
block|{
name|FILEIO
modifier|*
name|fiop
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|len
decl_stmt|;
name|int
name|oldmode
decl_stmt|,
name|newmode
decl_stmt|;
name|long
name|olddigits
decl_stmt|,
name|newdigits
decl_stmt|;
name|long
name|width
decl_stmt|,
name|precision
decl_stmt|;
name|BOOL
name|didneg
decl_stmt|,
name|didprecision
decl_stmt|;
name|fiop
operator|=
name|findid
argument_list|(
name|id
argument_list|,
literal|'w'
argument_list|)
expr_stmt|;
name|math_setfp
argument_list|(
name|fiop
operator|->
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ch
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|math_setfp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|math_chr
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'%'
condition|)
block|{
name|math_chr
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Here to handle formats. 		 */
name|didneg
operator|=
name|FALSE
expr_stmt|;
name|didprecision
operator|=
name|FALSE
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
name|precision
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|didneg
operator|=
name|TRUE
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|width
operator|=
name|width
operator|*
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|didprecision
operator|=
name|TRUE
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|precision
operator|=
name|precision
operator|*
literal|10
operator|+
operator|(
name|ch
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|==
literal|'l'
condition|)
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
name|oldmode
operator|=
name|_outmode_
expr_stmt|;
name|newmode
operator|=
name|oldmode
expr_stmt|;
name|olddigits
operator|=
name|_outdigits_
expr_stmt|;
name|newdigits
operator|=
name|olddigits
expr_stmt|;
if|if
condition|(
name|didprecision
condition|)
name|newdigits
operator|=
name|precision
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'s'
case|:
case|case
literal|'c'
case|:
break|break;
case|case
literal|'f'
case|:
name|newmode
operator|=
name|MODE_REAL
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|newmode
operator|=
name|MODE_EXP
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|newmode
operator|=
name|MODE_FRAC
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|newmode
operator|=
name|MODE_OCTAL
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|newmode
operator|=
name|MODE_HEX
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|newmode
operator|=
name|MODE_BINARY
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|math_setfp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_chr
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|--
name|count
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Not enough arguments for fprintf"
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|*
name|vals
operator|++
expr_stmt|;
name|math_setdigits
argument_list|(
name|newdigits
argument_list|)
expr_stmt|;
name|math_setmode
argument_list|(
name|newmode
argument_list|)
expr_stmt|;
comment|/* 		 * If there is no width specification, or if the type of 		 * value requires multiple lines, then just output the 		 * value directly. 		 */
if|if
condition|(
operator|(
name|width
operator|==
literal|0
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_MAT
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_type
operator|==
name|V_LIST
operator|)
condition|)
block|{
name|printvalue
argument_list|(
name|vp
argument_list|,
name|PRINT_NORMAL
argument_list|)
expr_stmt|;
name|math_setmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
name|math_setdigits
argument_list|(
name|olddigits
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * There is a field width.  Collect the output in a string, 		 * print it padded appropriately with spaces, and free it. 		 * However, if the output contains a newline, then ignore 		 * the field width. 		 */
name|math_divertio
argument_list|()
expr_stmt|;
name|printvalue
argument_list|(
name|vp
argument_list|,
name|PRINT_NORMAL
argument_list|)
expr_stmt|;
name|str
operator|=
name|math_getdivertedio
argument_list|()
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|width
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|didneg
operator|&&
operator|(
name|width
operator|>
name|len
operator|)
condition|)
block|{
name|width
operator|--
expr_stmt|;
name|math_chr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|math_str
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
name|didneg
operator|&&
operator|(
name|width
operator|>
name|len
operator|)
condition|)
block|{
name|width
operator|--
expr_stmt|;
name|math_chr
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|math_setmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
name|math_setdigits
argument_list|(
name|olddigits
argument_list|)
expr_stmt|;
block|}
name|math_setfp
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

