begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Extended precision rational arithmetic non-primitive functions  */
end_comment

begin_include
include|#
directive|include
file|"qmath.h"
end_include

begin_decl_stmt
name|NUMBER
modifier|*
name|_epsilon_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default precision for real functions */
end_comment

begin_decl_stmt
name|long
name|_epsilonprec_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits of precision for epsilon */
end_comment

begin_comment
comment|/*  * Set the default precision for real calculations.  * The precision must be between zero and one.  */
end_comment

begin_function
name|void
name|setepsilon
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to be set as the new epsilon */
block|{
name|NUMBER
modifier|*
name|old
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|qreli
argument_list|(
name|q
argument_list|,
literal|1L
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|math_error
argument_list|(
literal|"Epsilon value must be between zero and one"
argument_list|)
expr_stmt|;
name|old
operator|=
name|_epsilon_
expr_stmt|;
name|_epsilonprec_
operator|=
name|qprecision
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|_epsilon_
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
name|qfree
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the inverse of one number modulo another.  * That is, find x such that:  *	Ax = 1 (mod B)  * Returns zero if the numbers are not relatively prime (temporary hack).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qminv
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for minv"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|zmodinv
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Return the residue modulo an integer (q3) of an integer (q1)   * raised to a positive integer (q2) power.    */
end_comment

begin_function
name|NUMBER
modifier|*
name|qpowermod
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|q3
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|q3
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|BOOL
name|s
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q3
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for pmod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative power for pmod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q3
argument_list|)
condition|)
return|return
name|qpowi
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
return|;
name|s
operator|=
name|q3
operator|->
name|num
operator|.
name|sign
expr_stmt|;
name|q3
operator|->
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zpowermod
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
name|q3
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|||
name|qiszero
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|r
return|;
name|q3
operator|->
name|num
operator|.
name|sign
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|qadd
argument_list|(
name|r
argument_list|,
name|q3
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_block

begin_comment
comment|/*  * Return the power function of one number with another.  * The power must be integral.  *	q3 = qpowi(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qpowi
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|BOOL
name|invert
decl_stmt|,
name|sign
decl_stmt|;
name|ZVALUE
name|num
decl_stmt|,
name|den
decl_stmt|,
name|z2
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Raising number to fractional power"
argument_list|)
expr_stmt|;
name|num
operator|=
name|q1
operator|->
name|num
expr_stmt|;
name|den
operator|=
name|q1
operator|->
name|den
expr_stmt|;
name|z2
operator|=
name|q2
operator|->
name|num
expr_stmt|;
name|sign
operator|=
operator|(
name|num
operator|.
name|sign
operator|&&
name|zisodd
argument_list|(
name|z2
argument_list|)
operator|)
expr_stmt|;
name|invert
operator|=
name|z2
operator|.
name|sign
expr_stmt|;
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z2
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	* Check for trivial cases first. 	*/
if|if
condition|(
name|ziszero
argument_list|(
name|num
argument_list|)
operator|&&
operator|!
name|ziszero
argument_list|(
name|z2
argument_list|)
condition|)
block|{
comment|/* zero raised to a power */
if|if
condition|(
name|invert
condition|)
name|math_error
argument_list|(
literal|"Zero raised to negative power"
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|num
argument_list|)
operator|&&
name|zisunit
argument_list|(
name|den
argument_list|)
condition|)
block|{
comment|/* 1 or -1 raised to a power */
name|r
operator|=
operator|(
name|sign
condition|?
name|q1
else|:
operator|&
name|_qone_
operator|)
expr_stmt|;
name|r
operator|->
name|links
operator|++
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|ziszero
argument_list|(
name|z2
argument_list|)
condition|)
comment|/* raising to zeroth power */
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
if|if
condition|(
name|zisunit
argument_list|(
name|z2
argument_list|)
condition|)
block|{
comment|/* raising to power 1 or -1 */
if|if
condition|(
name|invert
condition|)
return|return
name|qinv
argument_list|(
name|q1
argument_list|)
return|;
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
block|}
comment|/* 	 * Not a trivial case.  Do the real work. 	 */
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|num
argument_list|)
condition|)
name|zpowi
argument_list|(
name|num
argument_list|,
name|z2
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisunit
argument_list|(
name|den
argument_list|)
condition|)
name|zpowi
argument_list|(
name|den
argument_list|,
name|z2
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
block|{
name|z2
operator|=
name|r
operator|->
name|num
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|r
operator|->
name|den
expr_stmt|;
name|r
operator|->
name|den
operator|=
name|z2
expr_stmt|;
block|}
name|r
operator|->
name|num
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Given the legs of a right triangle, compute its hypothenuse within  * the specified error.  This is sqrt(a^2 + b^2).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qhypot
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|tmp3
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon value for hypot"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qabs
argument_list|(
name|q2
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qabs
argument_list|(
name|q1
argument_list|)
return|;
name|tmp1
operator|=
name|qsquare
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|qsquare
argument_list|(
name|q2
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|qadd
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|qsqrt
argument_list|(
name|tmp3
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
return|return
name|tmp1
return|;
block|}
end_block

begin_comment
comment|/*  * Given one leg of a right triangle with unit hypothenuse, calculate  * the other leg within the specified error.  This is sqrt(1 - a^2).  * If the wantneg flag is nonzero, then negative square root is returned.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qlegtoleg
parameter_list|(
name|q
parameter_list|,
name|epsilon
parameter_list|,
name|wantneg
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_decl_stmt
name|BOOL
name|wantneg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|NUMBER
modifier|*
name|res
decl_stmt|,
modifier|*
name|qtmp1
decl_stmt|,
modifier|*
name|qtmp2
decl_stmt|;
name|ZVALUE
name|num
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon value for legtoleg"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisunit
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|wantneg
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qnegone_
argument_list|)
return|;
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
block|}
name|num
operator|=
name|q
operator|->
name|num
expr_stmt|;
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zrel
argument_list|(
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|)
operator|>=
literal|0
condition|)
name|math_error
argument_list|(
literal|"Leg too large in legtoleg"
argument_list|)
expr_stmt|;
name|qtmp1
operator|=
name|qsquare
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|qtmp2
operator|=
name|qsub
argument_list|(
operator|&
name|_qone_
argument_list|,
name|qtmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qtmp1
argument_list|)
expr_stmt|;
name|res
operator|=
name|qsqrt
argument_list|(
name|qtmp2
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qtmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantneg
condition|)
block|{
name|qtmp1
operator|=
name|qneg
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|res
operator|=
name|qtmp1
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the square root of a number to within the specified error.  * If the number is an exact square, the exact result is returned.  *	q3 = qsqrt(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qsqrt
parameter_list|(
name|q1
parameter_list|,
name|epsilon
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|long
name|bits
decl_stmt|,
name|bits2
decl_stmt|;
comment|/* number of bits of precision */
name|int
name|exact
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Square root of negative number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon value for sqrt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qisunit
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|epsilon
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|zistiny
argument_list|(
name|q1
operator|->
name|num
argument_list|)
operator|&&
operator|(
operator|*
name|q1
operator|->
name|num
operator|.
name|v
operator|<=
literal|3
operator|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|bits
operator|=
name|zhighbit
argument_list|(
name|epsilon
operator|->
name|den
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|epsilon
operator|->
name|num
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|0
condition|)
name|bits
operator|=
literal|0
expr_stmt|;
name|bits2
operator|=
name|zhighbit
argument_list|(
name|q1
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q1
operator|->
name|den
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bits2
operator|>
literal|0
condition|)
name|bits
operator|+=
name|bits2
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zshift
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|bits
operator|*
literal|2
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|t2
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|exact
operator|=
name|zsqrt
argument_list|(
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exact
condition|)
block|{
name|zshift
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|bits
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zreduce
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zquo
argument_list|(
name|t2
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|zbitvalue
argument_list|(
name|bits
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zreduce
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
name|zfree
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate the integral part of the square root of a number.  * Example:  qisqrt(13) = 3.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qisqrt
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Square root of negative number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
operator|&&
name|zistiny
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|&&
operator|(
name|z1tol
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|<
literal|4
operator|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zsqrt
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zsqrt
argument_list|(
name|tmp
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not a number is an exact square.  */
end_comment

begin_function
name|BOOL
name|qissquare
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|BOOL
name|flag
decl_stmt|;
name|flag
operator|=
name|zissquare
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
operator|||
operator|!
name|flag
condition|)
return|return
name|flag
return|;
return|return
name|zissquare
argument_list|(
name|q
operator|->
name|den
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the greatest integer of the Kth root of a number.  * Example:  qiroot(85, 3) = 4.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qiroot
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Taking number to bad root value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|qisone
argument_list|(
name|q1
argument_list|)
operator|||
name|qisone
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qistwo
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qisqrt
argument_list|(
name|q1
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
condition|)
block|{
name|zroot
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|zquo
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|zroot
argument_list|(
name|tmp
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Return the greatest integer of the base 2 log of a number.  * This is the number such that  1<= x / log2(x)< 2.  * Examples:  qilog2(8) = 3, qilog2(1.3) = 1, qilog2(1/7) = -3.  */
end_comment

begin_function
name|long
name|qilog2
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to take log of */
block|{
name|long
name|n
decl_stmt|;
comment|/* power of two */
name|int
name|c
decl_stmt|;
comment|/* result of comparison */
name|ZVALUE
name|tmp
decl_stmt|;
comment|/* temporary value */
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive number for log2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
return|;
name|n
operator|=
name|zhighbit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|-
name|zhighbit
argument_list|(
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|c
operator|=
name|zrel
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|zshift
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|n
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|c
operator|=
name|zrel
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zshift
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|n
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|c
operator|=
name|zrel
argument_list|(
name|tmp
argument_list|,
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|n
operator|--
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Return the greatest integer of the base 10 log of a number.  * This is the number such that  1<= x / log10(x)< 10.  * Examples:  qilog10(100) = 2, qilog10(12.3) = 1, qilog10(.023) = -2.  */
end_comment

begin_function
name|long
name|qilog10
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to take log of */
block|{
name|long
name|n
decl_stmt|;
comment|/* log value */
name|ZVALUE
name|temp
decl_stmt|;
comment|/* temporary value */
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive number for log10"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|zlog10
argument_list|(
name|q
operator|->
name|num
argument_list|)
return|;
comment|/* 	 * The number is not an integer. 	 * Compute the result if the number is greater than one. 	 */
if|if
condition|(
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|>
name|q
operator|->
name|den
operator|.
name|len
operator|)
operator|||
operator|(
operator|(
name|q
operator|->
name|num
operator|.
name|len
operator|==
name|q
operator|->
name|den
operator|.
name|len
operator|)
operator|&&
operator|(
name|zrel
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|n
operator|=
name|zlog10
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/* 	 * Here if the number is less than one. 	 * If the number is the inverse of a power of ten, then the obvious answer 	 * will be off by one.  Subtracting one if the number is the inverse of an 	 * integer will fix it. 	 */
if|if
condition|(
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|zsub
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|_one_
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
else|else
name|zquo
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|q
operator|->
name|num
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|n
operator|=
operator|-
name|zlog10
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of digits in a number, ignoring the sign.  * For fractions, this is the number of digits of its greatest integer.  * Examples: qdigits(3456) = 4, qdigits(-23.45) = 2, qdigits(.0120) = 1.  */
end_comment

begin_function
name|long
name|qdigits
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to count digits of */
block|{
name|long
name|n
decl_stmt|;
comment|/* number of digits */
name|ZVALUE
name|temp
decl_stmt|;
comment|/* temporary value */
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|zdigits
argument_list|(
name|q
operator|->
name|num
argument_list|)
return|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|n
operator|=
name|zdigits
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Return the digit at the specified decimal place of a number represented  * in floating point.  The lowest digit of the integral part of a number  * is the zeroth decimal place.  Negative decimal places indicate digits  * to the right of the decimal point.  Examples: qdigit(1234.5678, 1) = 3,  * qdigit(1234.5678, -3) = 7.  */
end_comment

begin_function
name|FLAG
name|qdigit
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|ZVALUE
name|tenpow
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|FLAG
name|res
decl_stmt|;
comment|/* 	 * Zero number or negative decimal place of integer is trivial. 	 */
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|qisint
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
name|n
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * For non-negative decimal places, answer is easy. 	 */
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|zdigit
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|n
argument_list|)
return|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|res
operator|=
name|zdigit
argument_list|(
name|tmp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* 	 * Fractional value and want negative digit, must work harder. 	 */
name|ztenpow
argument_list|(
operator|-
name|n
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tenpow
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tmp1
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|res
operator|=
name|zmodi
argument_list|(
name|tmp2
argument_list|,
literal|10L
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not a bit is set at the specified bit position in a  * number.  The lowest bit of the integral part of a number is the zeroth  * bit position.  Negative bit positions indicate bits to the right of the  * binary decimal point.  Examples: qdigit(17.1, 0) = 1, qdigit(17.1, -1) = 0.  */
end_comment

begin_function
name|BOOL
name|qisset
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|qtmp1
decl_stmt|,
modifier|*
name|qtmp2
decl_stmt|;
name|ZVALUE
name|ztmp
decl_stmt|;
name|BOOL
name|res
decl_stmt|;
comment|/* 	 * Zero number or negative bit position place of integer is trivial. 	 */
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
operator|(
name|qisint
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
name|n
operator|<
literal|0
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * For non-negative bit positions, answer is easy. 	 */
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|zisset
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|n
argument_list|)
return|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|ztmp
argument_list|)
expr_stmt|;
name|res
operator|=
name|zisset
argument_list|(
name|ztmp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ztmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* 	 * Fractional value and want negative bit position, must work harder. 	 */
name|qtmp1
operator|=
name|qscale
argument_list|(
name|q
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
name|qtmp2
operator|=
name|qint
argument_list|(
name|qtmp1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qtmp1
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
operator|(
name|qtmp2
operator|->
name|num
operator|.
name|v
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|qfree
argument_list|(
name|qtmp2
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the factorial of an integer.  *	q2 = qfact(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qfact
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral factorial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
operator|||
name|zisone
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zfact
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the product of the primes less than or equal to a number.  *	q2 = qpfact(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qpfact
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral factorial"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zpfact
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the lcm of all the numbers less than or equal to a number.  *	q2 = qlcmfact(q1);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qlcmfact
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral lcmfact"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zlcmfact
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the permutation function  M! / (M - N)!.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qperm
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral arguments for permutation"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zperm
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the combinatorial function  M! / (N! * (M - N)!).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qcomb
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral arguments for combinatorial"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zcomb
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the Jacobi function (a / b).  * -1 => a is not quadratic residue mod b  * 1 => b is composite, or a is quad residue of b  * 0 => b is even or b< 0  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qjacobi
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral arguments for jacobi"
argument_list|)
expr_stmt|;
return|return
name|itoq
argument_list|(
operator|(
name|long
operator|)
name|zjacobi
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the Fibonacci number F(n).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qfib
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral Fibonacci number"
argument_list|)
expr_stmt|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zfib
argument_list|(
name|q
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Truncate a number to the specified number of decimal places.  * Specifying zero places makes the result identical to qint.  * Example: qtrunc(2/3, 3) = .666  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qtrunc
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|long
name|places
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|tenpow
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
operator|!
name|zistiny
argument_list|(
name|q2
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad number of places for qtrunc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|places
operator|=
name|z1tol
argument_list|(
name|q2
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, produce the result. 	 * First see if we want no places, in which case just take integer part. 	 */
if|if
condition|(
name|places
operator|==
literal|0
condition|)
block|{
name|zquo
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|ztenpow
argument_list|(
name|places
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tmp1
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|tmp2
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * Now reduce the result to the lowest common denominator. 	 */
name|zgcd
argument_list|(
name|tmp2
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|tmp1
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|tmp2
expr_stmt|;
name|r
operator|->
name|den
operator|=
name|tenpow
expr_stmt|;
return|return
name|r
return|;
block|}
name|zquo
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tenpow
argument_list|,
name|tmp1
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tenpow
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Round a number to the specified number of decimal places.  * Zero decimal places means round to the nearest integer.  * Example: qround(2/3, 3) = .667  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qround
parameter_list|(
name|q
parameter_list|,
name|places
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to be rounded */
name|long
name|places
decl_stmt|;
comment|/* number of decimal places to round to */
block|{
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|tenpow
decl_stmt|,
name|roundval
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
name|places
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Negative places for qround"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
comment|/* 	 * Calculate one half of the denominator, ignoring fractional results. 	 * This is the value we will add in order to cause rounding. 	 */
name|zshift
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|-
literal|1L
argument_list|,
operator|&
name|roundval
argument_list|)
expr_stmt|;
name|roundval
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
comment|/* 	 * Ok, now do the actual work to produce the result. 	 */
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|ztenpow
argument_list|(
name|places
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|tmp2
argument_list|,
name|roundval
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|roundval
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tmp1
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|tmp2
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * Now reduce the result to the lowest common denominator. 	 */
name|zgcd
argument_list|(
name|tmp2
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|tmp1
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|tmp2
expr_stmt|;
name|r
operator|->
name|den
operator|=
name|tenpow
expr_stmt|;
return|return
name|r
return|;
block|}
name|zquo
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tenpow
argument_list|,
name|tmp1
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tenpow
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Truncate a number to the specified number of binary places.  * Specifying zero places makes the result identical to qint.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qbtrunc
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|long
name|places
decl_stmt|,
name|twopow
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
operator|!
name|zistiny
argument_list|(
name|q2
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad number of places for qtrunc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|places
operator|=
name|z1tol
argument_list|(
name|q2
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, produce the result. 	 * First see if we want no places, in which case just take integer part. 	 */
if|if
condition|(
name|places
operator|==
literal|0
condition|)
block|{
name|zquo
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|zshift
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|places
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tmp1
argument_list|,
name|q1
operator|->
name|den
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|tmp2
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * Now reduce the result to the lowest common denominator. 	 */
if|if
condition|(
name|zisodd
argument_list|(
name|tmp2
argument_list|)
condition|)
block|{
name|r
operator|->
name|num
operator|=
name|tmp2
expr_stmt|;
name|zbitvalue
argument_list|(
name|places
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|twopow
operator|=
name|zlowbit
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|twopow
operator|>
name|places
condition|)
name|twopow
operator|=
name|places
expr_stmt|;
name|places
operator|-=
name|twopow
expr_stmt|;
name|zshift
argument_list|(
name|tmp2
argument_list|,
operator|-
name|twopow
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|zbitvalue
argument_list|(
name|places
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Round a number to the specified number of binary places.  * Zero binary places means round to the nearest integer.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qbround
parameter_list|(
name|q
parameter_list|,
name|places
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to be rounded */
name|long
name|places
decl_stmt|;
comment|/* number of binary places to round to */
block|{
name|long
name|twopow
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
name|ZVALUE
name|roundval
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
if|if
condition|(
name|places
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Negative places for qbround"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
comment|/* 	 * Calculate one half of the denominator, ignoring fractional results. 	 * This is the value we will add in order to cause rounding. 	 */
name|zshift
argument_list|(
name|q
operator|->
name|den
argument_list|,
operator|-
literal|1L
argument_list|,
operator|&
name|roundval
argument_list|)
expr_stmt|;
name|roundval
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
comment|/* 	 * Ok, produce the result. 	 */
name|zshift
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|places
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|tmp1
argument_list|,
name|roundval
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|roundval
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|tmp2
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|tmp1
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * Now reduce the result to the lowest common denominator. 	 */
if|if
condition|(
name|zisodd
argument_list|(
name|tmp1
argument_list|)
condition|)
block|{
name|r
operator|->
name|num
operator|=
name|tmp1
expr_stmt|;
name|zbitvalue
argument_list|(
name|places
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
name|twopow
operator|=
name|zlowbit
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|twopow
operator|>
name|places
condition|)
name|twopow
operator|=
name|places
expr_stmt|;
name|places
operator|-=
name|twopow
expr_stmt|;
name|zshift
argument_list|(
name|tmp1
argument_list|,
operator|-
name|twopow
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zbitvalue
argument_list|(
name|places
argument_list|,
operator|&
name|r
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Approximate a number by using binary rounding with the minimum number  * of binary places so that the resulting number is within the specified  * epsilon of the original number.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qbappr
parameter_list|(
name|q
parameter_list|,
name|e
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|long
name|bits
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|e
argument_list|)
operator|||
name|qiszero
argument_list|(
name|e
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon value for qbappr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|_epsilon_
condition|)
name|bits
operator|=
name|_epsilonprec_
operator|+
literal|1
expr_stmt|;
else|else
name|bits
operator|=
name|qprecision
argument_list|(
name|e
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|qbround
argument_list|(
name|q
argument_list|,
name|bits
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Approximate a number using continued fractions until the approximation  * error is less than the specified value.  If a NULL pointer is given  * for the error value, then the closest simpler fraction is returned.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qcfappr
parameter_list|(
name|q
parameter_list|,
name|e
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|,
decl|*
name|e
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
name|qtest
decl_stmt|,
modifier|*
name|qtmp
decl_stmt|;
name|ZVALUE
name|u1
decl_stmt|,
name|u2
decl_stmt|,
name|u3
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|qq
decl_stmt|,
name|tt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BOOL
name|haveeps
decl_stmt|;
name|haveeps
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|haveeps
operator|=
name|FALSE
expr_stmt|;
name|e
operator|=
operator|&
name|_qzero_
expr_stmt|;
block|}
if|if
condition|(
name|qisneg
argument_list|(
name|e
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative epsilon for cfappr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
operator|||
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
operator|(
name|haveeps
operator|&&
name|qiszero
argument_list|(
name|e
argument_list|)
operator|)
condition|)
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
name|u1
operator|=
name|_one_
expr_stmt|;
name|u2
operator|=
name|_zero_
expr_stmt|;
name|u3
operator|=
name|q
operator|->
name|num
expr_stmt|;
name|u3
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|v1
operator|=
name|_zero_
expr_stmt|;
name|v2
operator|=
name|_one_
expr_stmt|;
name|v3
operator|=
name|q
operator|->
name|den
expr_stmt|;
while|while
condition|(
operator|!
name|ziszero
argument_list|(
name|v3
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ziszero
argument_list|(
name|u2
argument_list|)
operator|&&
operator|!
name|ziszero
argument_list|(
name|u1
argument_list|)
condition|)
block|{
name|qtest
operator|.
name|num
operator|=
name|u2
expr_stmt|;
name|qtest
operator|.
name|den
operator|=
name|u1
expr_stmt|;
name|qtest
operator|.
name|den
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|qtest
operator|.
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
name|qtmp
operator|=
name|qsub
argument_list|(
name|q
argument_list|,
operator|&
name|qtest
argument_list|)
expr_stmt|;
name|qtest
operator|=
operator|*
name|qtmp
expr_stmt|;
name|qtest
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|qrel
argument_list|(
operator|&
name|qtest
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qtmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
block|}
name|zquo
argument_list|(
name|u3
argument_list|,
name|v3
argument_list|,
operator|&
name|qq
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|qq
argument_list|,
name|v1
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|u1
argument_list|,
name|tt
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|qq
argument_list|,
name|v2
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|u2
argument_list|,
name|tt
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|qq
argument_list|,
name|v3
argument_list|,
operator|&
name|tt
argument_list|)
expr_stmt|;
name|zsub
argument_list|(
name|u3
argument_list|,
name|tt
argument_list|,
operator|&
name|t3
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|u2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u3
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
operator|)
operator|&&
operator|(
name|u3
operator|.
name|v
operator|!=
name|q
operator|->
name|den
operator|.
name|v
operator|)
condition|)
name|zfree
argument_list|(
name|u3
argument_list|)
expr_stmt|;
name|u1
operator|=
name|v1
expr_stmt|;
name|u2
operator|=
name|v2
expr_stmt|;
name|u3
operator|=
name|v3
expr_stmt|;
name|v1
operator|=
name|t1
expr_stmt|;
name|v2
operator|=
name|t2
expr_stmt|;
name|v3
operator|=
name|t3
expr_stmt|;
block|}
if|if
condition|(
name|u3
operator|.
name|v
operator|!=
name|q
operator|->
name|den
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|u3
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|v1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|v2
argument_list|)
expr_stmt|;
name|i
operator|=
name|ziszero
argument_list|(
name|v3
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|v3
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|haveeps
condition|)
block|{
name|zfree
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|u2
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
name|q
argument_list|)
return|;
block|}
name|qtest
operator|.
name|num
operator|=
name|u2
expr_stmt|;
name|qtest
operator|.
name|den
operator|=
name|u1
expr_stmt|;
name|qtest
operator|.
name|den
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|qtest
operator|.
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
name|qtmp
operator|=
name|qcopy
argument_list|(
operator|&
name|qtest
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|u2
argument_list|)
expr_stmt|;
return|return
name|qtmp
return|;
block|}
end_block

begin_comment
comment|/*  * Return an indication on whether or not two fractions are approximately  * equal within the specified epsilon. Returns negative if the absolute value  * of the difference between the two numbers is less than epsilon, zero if  * the difference is equal to epsilon, and positive if the difference is  * greater than epsilon.  */
end_comment

begin_function
name|FLAG
name|qnear
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|epsilon
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|epsilon
decl_stmt|;
end_function

begin_block
block|{
name|int
name|res
decl_stmt|;
name|NUMBER
name|qtemp
decl_stmt|,
modifier|*
name|qq
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative epsilon for near"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
block|{
if|if
condition|(
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
return|return
name|qcmp
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
block|{
name|qtemp
operator|=
operator|*
name|q1
expr_stmt|;
name|qtemp
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
return|return
name|qrel
argument_list|(
operator|&
name|qtemp
argument_list|,
name|epsilon
argument_list|)
return|;
block|}
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
block|{
name|qtemp
operator|=
operator|*
name|q2
expr_stmt|;
name|qtemp
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
return|return
name|qrel
argument_list|(
operator|&
name|qtemp
argument_list|,
name|epsilon
argument_list|)
return|;
block|}
name|qq
operator|=
name|qsub
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qtemp
operator|=
operator|*
name|qq
expr_stmt|;
name|qtemp
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|qrel
argument_list|(
operator|&
name|qtemp
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qq
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the gcd (greatest common divisor) of two numbers.  *	q3 = qgcd(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qgcd
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|z
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qabs
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
block|{
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zgcd
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|zlcm
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qabs
argument_list|(
name|q2
argument_list|)
return|;
if|if
condition|(
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qabs
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qisunit
argument_list|(
name|q1
argument_list|)
operator|||
name|qisunit
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
name|zgcd
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|z
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
block|}
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|z
expr_stmt|;
return|return
name|q
return|;
block|}
end_block

begin_comment
comment|/*  * Compute the lcm (least common multiple) of two numbers.  *	q3 = qlcm(q1, q2);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qlcm
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|qabs
argument_list|(
name|q1
argument_list|)
return|;
if|if
condition|(
name|qisunit
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qabs
argument_list|(
name|q2
argument_list|)
return|;
if|if
condition|(
name|qisunit
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qabs
argument_list|(
name|q1
argument_list|)
return|;
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zlcm
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|zgcd
argument_list|(
name|q1
operator|->
name|den
argument_list|,
name|q2
operator|->
name|den
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_block

begin_comment
comment|/*  * Remove all occurances of the specified factor from a number.  * Returned number is always positive.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qfacrem
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|long
name|count
decl_stmt|;
name|ZVALUE
name|tmp
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for factor removal"
argument_list|)
expr_stmt|;
name|count
operator|=
name|zfacrem
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|tmp
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Divide one number by the gcd of it with another number repeatedly until  * the number is relatively prime.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qgcdrem
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|tmp
decl_stmt|;
name|NUMBER
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for gcdrem"
argument_list|)
expr_stmt|;
name|zgcdrem
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
block|}
if|if
condition|(
name|zcmp
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|tmp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
block|}
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|r
operator|->
name|num
operator|=
name|tmp
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Return the lowest prime factor of a number.  * Search is conducted for the specified number of primes.  * Returns one if no factor was found.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qlowfactor
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for lowfactor"
argument_list|)
expr_stmt|;
return|return
name|itoq
argument_list|(
name|zlowfactor
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|ztoi
argument_list|(
name|q2
operator|->
name|num
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return the number of places after the decimal point needed to exactly  * represent the specified number as a real number.  Integers return zero,  * and non-terminating decimals return minus one.  Examples:  *	qplaces(1/7)=-1, qplaces(3/10)= 1, qplaces(1/8)=3, qplaces(4)=0.  */
end_comment

begin_function
name|long
name|qplaces
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|long
name|twopow
decl_stmt|,
name|fivepow
decl_stmt|;
name|HALF
name|fiveval
index|[
literal|2
index|]
decl_stmt|;
name|ZVALUE
name|five
decl_stmt|;
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q
argument_list|)
condition|)
comment|/* no decimal places if number is integer */
return|return
literal|0
return|;
comment|/* 	 * The number of decimal places of a fraction in lowest terms is finite 	 * if an only if the denominator is of the form 2^A * 5^B, and then the 	 * number of decimal places is equal to MAX(A, B). 	 */
name|five
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|five
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|five
operator|.
name|v
operator|=
name|fiveval
expr_stmt|;
name|fiveval
index|[
literal|0
index|]
operator|=
literal|5
expr_stmt|;
name|fivepow
operator|=
name|zfacrem
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|five
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zisonebit
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|twopow
operator|=
name|zlowbit
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|twopow
operator|<
name|fivepow
condition|)
name|twopow
operator|=
name|fivepow
expr_stmt|;
return|return
name|twopow
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a probabilistic primality test (algorithm P in Knuth).  * Returns FALSE if definitely not prime, or TRUE if probably prime.  * Second arg determines how many times to check for primality.  */
end_comment

begin_function
name|BOOL
name|qprimetest
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad arguments for qprimetest"
argument_list|)
expr_stmt|;
return|return
name|zprimetest
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|qtoi
argument_list|(
name|q2
argument_list|)
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Return a trivial hash value for a number.  */
end_comment

begin_function
name|HASH
name|qhash
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|HASH
name|hash
decl_stmt|;
name|hash
operator|=
name|zhash
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|hash
operator|+=
name|zhash
argument_list|(
name|q
operator|->
name|den
argument_list|)
operator|*
literal|2000003
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

