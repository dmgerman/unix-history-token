begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Scanf and printf routines for arbitrary precision rational numbers  */
end_comment

begin_include
include|#
directive|include
file|"stdarg.h"
end_include

begin_include
include|#
directive|include
file|"qmath.h"
end_include

begin_define
define|#
directive|define
name|PUTCHAR
parameter_list|(
name|ch
parameter_list|)
value|math_chr(ch)
end_define

begin_define
define|#
directive|define
name|PUTSTR
parameter_list|(
name|str
parameter_list|)
value|math_str(str)
end_define

begin_define
define|#
directive|define
name|PRINTF1
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|)
value|math_fmt(fmt, a1)
end_define

begin_define
define|#
directive|define
name|PRINTF2
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
value|math_fmt(fmt, a1, a2)
end_define

begin_decl_stmt
name|int
name|tilde_ok
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FALSE => don't print '~' for rounded value */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static long	etoalen; static char	*etoabuf = NULL;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|scalefactor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ZVALUE
name|scalenumber
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print a formatted string containing arbitrary numbers, similar to printf.  * ALL numeric arguments to this routine are rational NUMBERs.  * Various forms of printing such numbers are supplied, in addition  * to strings and characters.  Output can actually be to any FILE  * stream or a string.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VARARGS
end_ifdef

begin_define
define|#
directive|define
name|VA_ALIST1
value|fmt, va_alist
end_define

begin_define
define|#
directive|define
name|VA_DCL1
value|char *fmt; va_dcl
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|VA_ALIST1
value|char *fmt, ...
end_define

begin_define
define|#
directive|define
name|VA_DCL1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VA_ALIST1
value|fmt
end_define

begin_define
define|#
directive|define
name|VA_DCL1
value|char *fmt;
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|void
name|qprintf
parameter_list|(
name|VA_ALIST1
parameter_list|)
function|VA_DCL1
block|{
name|va_list
name|ap
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|sign
decl_stmt|;
name|long
name|width
decl_stmt|,
name|precision
decl_stmt|;
ifdef|#
directive|ifdef
name|VARARGS
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|ch
operator|=
literal|'\v'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
block|}
name|PUTCHAR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'%'
condition|)
block|{
name|PUTCHAR
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
name|precision
operator|=
literal|8
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
name|percent
label|:
empty_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfd
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintff
argument_list|(
name|q
argument_list|,
name|width
argument_list|,
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfe
argument_list|(
name|q
argument_list|,
name|width
argument_list|,
name|precision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfr
argument_list|(
name|q
argument_list|,
name|width
argument_list|,
call|(
name|BOOL
call|)
argument_list|(
name|ch
operator|==
literal|'R'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|q
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfo
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfx
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|qprintfb
argument_list|(
name|q
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|PUTSTR
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|PUTCHAR
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'-'
case|:
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
default|default:
if|if
condition|(
operator|(
literal|'0'
operator|<=
name|ch
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
operator|||
name|ch
operator|==
literal|'.'
operator|||
name|ch
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|width
operator|=
name|sign
operator|*
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|'.'
condition|)
block|{
name|width
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|width
operator|*=
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|==
literal|'*'
condition|)
block|{
name|q
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|NUMBER
operator|*
argument_list|)
expr_stmt|;
name|precision
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|precision
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|precision
operator|=
name|precision
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
goto|goto
name|percent
goto|;
block|}
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Read a number from the specified FILE stream (NULL means stdin).  * The number can be an integer, a fraction, a real number, an  * exponential number, or a hex, octal or binary number.  Leading blanks  * are skipped.  Illegal numbers return NULL.  Unrecognized characters  * remain to be read on the line.  *	q = qreadval(fp);  */
end_comment

begin_comment
unit|NUMBER * qreadval(fp) 	FILE *fp;
comment|/* file stream to read from (or NULL) */
end_comment

begin_comment
unit|{ 	NUMBER *r;
comment|/* returned number */
end_comment

begin_comment
unit|char *cp;
comment|/* current buffer location */
end_comment

begin_comment
unit|long savecc;
comment|/* characters saved in buffer */
end_comment

begin_comment
unit|long scancc;
comment|/* characters parsed correctly */
end_comment

begin_comment
unit|int ch;
comment|/* current character */
end_comment

begin_endif
unit|if (fp == NULL) 		fp = stdin; 	if (etoabuf == NULL) { 		etoabuf = (char *)malloc(OUTBUFSIZE + 2); 		if (etoabuf == NULL) 			return NULL; 		etoalen = OUTBUFSIZE; 	} 	cp = etoabuf; 	ch = fgetc(fp); 	while ((ch == ' ') || (ch == '\t')) 		ch = fgetc(fp); 	savecc = 0; 	for (;;) { 		if (ch == EOF) 			return NULL; 		if (savecc>= etoalen) 		{ 			cp = (char *)realloc(etoabuf, etoalen + OUTBUFSIZE + 2); 			if (cp == NULL) 				return NULL; 			etoabuf = cp; 			etoalen += OUTBUFSIZE; 			cp += savecc; 		} 		*cp++ = (char)ch; 		*cp = '\0'; 		scancc = qparse(etoabuf, QPF_SLASH); 		if (scancc != ++savecc) 			break; 		ch = fgetc(fp); 	} 	ungetc(ch, fp); 	if (scancc< 0) 		return NULL; 	r = atoq(etoabuf); 	if (ziszero(r->den)) { 		qfree(r); 		r = NULL; 	} 	return r; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Print a number in the specified output mode.  * If MODE_DEFAULT is given, then the default output mode is used.  * Any approximate output is flagged with a leading tilde.  * Integers are always printed as themselves.  */
end_comment

begin_function
name|void
name|qprintnum
parameter_list|(
name|q
parameter_list|,
name|outmode
parameter_list|)
name|int
name|outmode
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
block|{
name|NUMBER
name|tmpval
decl_stmt|;
name|long
name|prec
decl_stmt|,
name|exp
decl_stmt|;
if|if
condition|(
name|outmode
operator|==
name|MODE_DEFAULT
condition|)
name|outmode
operator|=
name|_outmode_
expr_stmt|;
if|if
condition|(
operator|(
name|outmode
operator|==
name|MODE_FRAC
operator|)
operator|||
operator|(
operator|(
name|outmode
operator|==
name|MODE_REAL
operator|)
operator|&&
name|qisint
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
name|qprintfr
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|outmode
condition|)
block|{
case|case
name|MODE_INT
case|:
if|if
condition|(
name|tilde_ok
operator|&&
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|qprintfd
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_REAL
case|:
name|prec
operator|=
name|qplaces
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prec
operator|<
literal|0
operator|)
operator|||
operator|(
name|prec
operator|>
name|_outdigits_
operator|)
condition|)
block|{
name|prec
operator|=
name|_outdigits_
expr_stmt|;
if|if
condition|(
name|tilde_ok
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
block|}
block|}
name|qprintff
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|,
name|prec
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_EXP
case|:
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpval
operator|=
operator|*
name|q
expr_stmt|;
name|tmpval
operator|.
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
name|qilog10
argument_list|(
operator|&
name|tmpval
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
comment|/* in range to output as real */
name|qprintnum
argument_list|(
name|q
argument_list|,
name|MODE_REAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmpval
operator|.
name|num
operator|=
name|_one_
expr_stmt|;
name|tmpval
operator|.
name|den
operator|=
name|_one_
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
name|ztenpow
argument_list|(
name|exp
argument_list|,
operator|&
name|tmpval
operator|.
name|den
argument_list|)
expr_stmt|;
else|else
name|ztenpow
argument_list|(
operator|-
name|exp
argument_list|,
operator|&
name|tmpval
operator|.
name|num
argument_list|)
expr_stmt|;
name|q
operator|=
name|qmul
argument_list|(
name|q
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmpval
operator|.
name|num
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmpval
operator|.
name|den
argument_list|)
expr_stmt|;
name|qprintnum
argument_list|(
name|q
argument_list|,
name|MODE_REAL
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|PRINTF1
argument_list|(
literal|"e%ld"
argument_list|,
name|exp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_HEX
case|:
name|qprintfx
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_OCTAL
case|:
name|qprintfo
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_BINARY
case|:
name|qprintfb
argument_list|(
name|q
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad mode for print"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in floating point representation.  * Example:  193.784  */
end_comment

begin_function
name|void
name|qprintff
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|,
name|precision
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
name|long
name|precision
decl_stmt|;
block|{
name|ZVALUE
name|z
decl_stmt|,
name|z1
decl_stmt|;
if|if
condition|(
name|precision
operator|!=
name|scalefactor
condition|)
block|{
if|if
condition|(
name|scalenumber
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|scalenumber
argument_list|)
expr_stmt|;
name|ztenpow
argument_list|(
name|precision
argument_list|,
operator|&
name|scalenumber
argument_list|)
expr_stmt|;
name|scalefactor
operator|=
name|precision
expr_stmt|;
block|}
if|if
condition|(
name|scalenumber
operator|.
name|v
condition|)
name|zmul
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|scalenumber
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
else|else
name|z
operator|=
name|q
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zquo
argument_list|(
name|z
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|z
operator|=
name|z1
expr_stmt|;
block|}
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|&&
name|ziszero
argument_list|(
name|z
argument_list|)
condition|)
name|PUTCHAR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|z
argument_list|,
name|precision
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a number in exponential notation.  * Example: 4.1856e34  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|qprintfe
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|,
name|precision
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
name|long
name|precision
decl_stmt|;
block|{
name|long
name|exponent
decl_stmt|;
name|NUMBER
name|q2
decl_stmt|;
name|ZVALUE
name|num
decl_stmt|,
name|den
decl_stmt|,
name|tenpow
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTSTR
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|q
operator|->
name|num
expr_stmt|;
name|den
operator|=
name|q
operator|->
name|den
expr_stmt|;
name|num
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|exponent
operator|=
name|zdigits
argument_list|(
name|num
argument_list|)
operator|-
name|zdigits
argument_list|(
name|den
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|>
literal|0
condition|)
block|{
name|ztenpow
argument_list|(
name|exponent
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|den
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tenpow
argument_list|)
expr_stmt|;
name|den
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|exponent
operator|<
literal|0
condition|)
block|{
name|ztenpow
argument_list|(
operator|-
name|exponent
argument_list|,
operator|&
name|tenpow
argument_list|)
expr_stmt|;
name|zmul
argument_list|(
name|num
argument_list|,
name|tenpow
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tenpow
argument_list|)
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|zrel
argument_list|(
name|num
argument_list|,
name|den
argument_list|)
operator|<
literal|0
condition|)
block|{
name|zmuli
argument_list|(
name|num
argument_list|,
literal|10L
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|num
operator|=
name|tmp
expr_stmt|;
name|exponent
operator|--
expr_stmt|;
block|}
name|q2
operator|.
name|num
operator|=
name|num
expr_stmt|;
name|q2
operator|.
name|den
operator|=
name|den
expr_stmt|;
name|q2
operator|.
name|num
operator|.
name|sign
operator|=
name|q
operator|->
name|num
operator|.
name|sign
expr_stmt|;
name|qprintff
argument_list|(
operator|&
name|q2
argument_list|,
literal|0L
argument_list|,
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
condition|)
name|PRINTF1
argument_list|(
literal|"e%ld"
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|.
name|v
operator|!=
name|q
operator|->
name|num
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|den
operator|.
name|v
operator|!=
name|q
operator|->
name|den
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|den
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a number in rational representation.  * Example: 397/37  */
end_comment

begin_function
name|void
name|qprintfr
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|,
name|force
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
name|BOOL
name|force
decl_stmt|;
block|{
name|zprintval
argument_list|(
name|q
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|||
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number as an integer (truncating fractional part).  * Example: 958421  */
end_comment

begin_function
name|void
name|qprintfd
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|ZVALUE
name|z
decl_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
name|zprintval
argument_list|(
name|z
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
else|else
name|zprintval
argument_list|(
name|q
operator|->
name|num
argument_list|,
literal|0L
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a number in hex.  * This prints the numerator and denominator in hex.  */
end_comment

begin_function
name|void
name|qprintfx
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|zprintx
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintx
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in binary.  * This prints the numerator and denominator in binary.  */
end_comment

begin_function
name|void
name|qprintfb
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|zprintb
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprintb
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print a number in octal.  * This prints the numerator and denominator in octal.  */
end_comment

begin_function
name|void
name|qprintfo
parameter_list|(
name|q
parameter_list|,
name|width
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|long
name|width
decl_stmt|;
block|{
name|zprinto
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|PUTCHAR
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|zprinto
argument_list|(
name|q
operator|->
name|den
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert a string to a number in rational, floating point,  * exponential notation, hex, or octal.  *	q = atoq(string);  */
end_comment

begin_function
name|NUMBER
modifier|*
name|atoq
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|ZVALUE
name|div
decl_stmt|,
name|newnum
decl_stmt|,
name|newden
decl_stmt|,
name|tmp
decl_stmt|;
name|long
name|decimals
decl_stmt|,
name|exp
decl_stmt|;
name|BOOL
name|hex
decl_stmt|,
name|negexp
decl_stmt|;
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|decimals
operator|=
literal|0
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
name|negexp
operator|=
name|FALSE
expr_stmt|;
name|hex
operator|=
name|FALSE
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'-'
operator|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|t
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|t
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
name|hex
operator|=
name|TRUE
expr_stmt|;
name|t
operator|+=
literal|2
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
operator|*
name|t
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
name|hex
operator|&&
operator|(
operator|(
operator|(
operator|*
name|t
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'f'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|t
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'/'
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|atoz
argument_list|(
name|t
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'.'
condition|)
block|{
name|t
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|t
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
name|decimals
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Parse exponent if any 		 */
if|if
condition|(
operator|(
operator|*
name|t
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|t
operator|==
literal|'E'
operator|)
condition|)
block|{
name|t
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'+'
condition|)
name|t
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|t
operator|==
literal|'-'
condition|)
block|{
name|negexp
operator|=
name|TRUE
expr_stmt|;
name|t
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|t
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|t
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|exp
operator|=
operator|(
name|exp
operator|*
literal|10
operator|)
operator|+
operator|*
name|t
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|1000000
condition|)
name|math_error
argument_list|(
literal|"Exponent too large"
argument_list|)
expr_stmt|;
block|}
block|}
name|ztenpow
argument_list|(
name|decimals
argument_list|,
operator|&
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
block|}
name|atoz
argument_list|(
name|s
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
comment|/* 	 * Apply the exponential if any 	 */
if|if
condition|(
name|exp
condition|)
block|{
name|ztenpow
argument_list|(
name|exp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|negexp
condition|)
block|{
name|zmul
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|tmp
argument_list|,
operator|&
name|newden
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
name|q
operator|->
name|den
operator|=
name|newden
expr_stmt|;
block|}
else|else
block|{
name|zmul
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|tmp
argument_list|,
operator|&
name|newnum
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|newnum
expr_stmt|;
block|}
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reduce the fraction to lowest terms 	 */
if|if
condition|(
name|zisunit
argument_list|(
name|q
operator|->
name|num
argument_list|)
operator|||
name|zisunit
argument_list|(
name|q
operator|->
name|den
argument_list|)
condition|)
return|return
name|q
return|;
name|zgcd
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|q
operator|->
name|den
argument_list|,
operator|&
name|div
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|div
argument_list|)
condition|)
return|return
name|q
return|;
name|zquo
argument_list|(
name|q
operator|->
name|num
argument_list|,
name|div
argument_list|,
operator|&
name|newnum
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|zquo
argument_list|(
name|q
operator|->
name|den
argument_list|,
name|div
argument_list|,
operator|&
name|newden
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|q
operator|->
name|den
argument_list|)
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|newnum
expr_stmt|;
name|q
operator|->
name|den
operator|=
name|newden
expr_stmt|;
return|return
name|q
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a number in any of the various legal forms, and return the count  * of characters that are part of a legal number.  Numbers can be either a  * decimal integer, possibly two decimal integers separated with a slash, a  * floating point or exponential number, a hex number beginning with "0x",  * a binary number beginning with "0b", or an octal number beginning with "0".  * The flags argument modifies the end of number testing for ease in handling  * fractions or complex numbers.  Minus one is returned if the number format  * is definitely illegal.  */
end_comment

begin_function
name|long
name|qparse
parameter_list|(
name|cp
parameter_list|,
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
modifier|*
name|oldcp
decl_stmt|;
name|oldcp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
comment|/* hex */
name|cp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'f'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'F'
operator|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
operator|||
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'B'
operator|)
operator|)
condition|)
block|{
comment|/* binary */
name|cp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'1'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|)
condition|)
block|{
comment|/* octal */
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'7'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Number is decimal, but can still be a fraction or real or exponential. 	 */
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
operator|&&
name|flags
operator|&
name|QPF_SLASH
condition|)
block|{
comment|/* fraction */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
comment|/* floating point */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'e'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'E'
operator|)
condition|)
block|{
comment|/* exponential */
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'+'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'-'
operator|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|(
operator|(
operator|*
name|cp
operator|==
literal|'i'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'I'
operator|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|QPF_IMAG
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'.'
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|flags
operator|&
name|QPF_SLASH
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'z'
operator|)
operator|)
operator|||
operator|(
operator|(
operator|*
name|cp
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|<=
literal|'Z'
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|cp
operator|-
name|oldcp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

