begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Routines to do modulo arithmetic both normally and also using the REDC  * algorithm given by Peter L. Montgomery in Mathematics of Computation,  * volume 44, number 170 (April, 1985).  For multiple multiplies using  * the same large modulus, the REDC algorithm avoids the usual division  * by the modulus, instead replacing it with two multiplies or else a  * special algorithm.  When these two multiplies or the special algorithm  * are faster then the division, then the REDC algorithm is better.  */
end_comment

begin_include
include|#
directive|include
file|"zmath.h"
end_include

begin_define
define|#
directive|define
name|POWBITS
value|4
end_define

begin_comment
comment|/* bits for power chunks (must divide BASEB) */
end_comment

begin_define
define|#
directive|define
name|POWNUMS
value|(1<<POWBITS)
end_define

begin_comment
comment|/* number of powers needed in table */
end_comment

begin_decl_stmt
name|LEN
name|_pow2_
init|=
name|POW_ALG2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modulo size to use REDC for powers */
end_comment

begin_decl_stmt
name|LEN
name|_redc2_
init|=
name|REDC_ALG2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modulo size to use second REDC algorithm */
end_comment

begin_decl_stmt
specifier|static
name|REDC
modifier|*
name|powermodredc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* REDC info for raising to power */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|extern void zaddmod MATH_PROTO((ZVALUE z1, ZVALUE z2, ZVALUE z3, ZVALUE *res)); extern void znegmod MATH_PROTO((ZVALUE z1, ZVALUE z2, ZVALUE *res));
comment|/*  * Multiply two numbers together and then mod the result with a third number.  * The two numbers to be multiplied can be negative or out of modulo range.  * The result will be in the range 0 to the modulus - 1.  */
end_comment

begin_comment
unit|void zmulmod(z1, z2, z3, res) 	ZVALUE z1;
comment|/* first number to be multiplied */
end_comment

begin_comment
unit|ZVALUE z2;
comment|/* second number to be multiplied */
end_comment

begin_comment
unit|ZVALUE z3;
comment|/* number to take mod with */
end_comment

begin_comment
unit|ZVALUE *res;
comment|/* result */
end_comment

begin_comment
unit|{ 	ZVALUE tmp; 	FULL prod; 	FULL digit; 	BOOL neg;  	if (ziszero(z3) || zisneg(z3)) 		math_error("Mod of non-positive integer"); 	if (ziszero(z1) || ziszero(z2) || zisunit(z3)) { 		*res = _zero_; 		return; 	}
comment|/* 	 * If the modulus is a single digit number, then do the result 	 * cheaply.  Check especially for a small power of two. 	 */
end_comment

begin_comment
unit|if (zistiny(z3)) { 		neg = (z1.sign != z2.sign); 		digit = z3.v[0]; 		if ((digit& -digit) == digit) {
comment|/* NEEDS 2'S COMP */
end_comment

begin_comment
unit|prod = ((FULL) z1.v[0]) * ((FULL) z2.v[0]); 			prod&= (digit - 1); 		} else { 			z1.sign = 0; 			z2.sign = 0; 			prod = (FULL) zmodi(z1, (long) digit); 			prod *= (FULL) zmodi(z2, (long) digit); 			prod %= digit; 		} 		if (neg&& prod) 			prod = digit - prod; 		itoz((long) prod, res); 		return; 	}
comment|/* 	 * The modulus is more than one digit. 	 * Actually do the multiply and divide if necessary. 	 */
end_comment

begin_comment
unit|zmul(z1, z2,&tmp); 	if (zispos(tmp)&& ((tmp.len< z3.len) || ((tmp.len == z3.len)&& 		(tmp.v[tmp.len-1]< z2.v[z3.len-1])))) 	{ 		*res = tmp; 		return; 	} 	zmod(tmp, z3, res); 	zfree(tmp); }
comment|/*  * Square a number and then mod the result with a second number.  * The number to be squared can be negative or out of modulo range.  * The result will be in the range 0 to the modulus - 1.  */
end_comment

begin_comment
unit|void zsquaremod(z1, z2, res) 	ZVALUE z1;
comment|/* number to be squared */
end_comment

begin_comment
unit|ZVALUE z2;
comment|/* number to take mod with */
end_comment

begin_comment
unit|ZVALUE *res;
comment|/* result */
end_comment

begin_comment
unit|{ 	ZVALUE tmp; 	FULL prod; 	FULL digit;  	if (ziszero(z2) || zisneg(z2)) 		math_error("Mod of non-positive integer"); 	if (ziszero(z1) || zisunit(z2)) { 		*res = _zero_; 		return; 	}
comment|/* 	 * If the modulus is a single digit number, then do the result 	 * cheaply.  Check especially for a small power of two. 	 */
end_comment

begin_comment
unit|if (zistiny(z2)) { 		digit = z2.v[0]; 		if ((digit& -digit) == digit) {
comment|/* NEEDS 2'S COMP */
end_comment

begin_comment
unit|prod = (FULL) z1.v[0]; 			prod = (prod * prod)& (digit - 1); 		} else { 			z1.sign = 0; 			prod = (FULL) zmodi(z1, (long) digit); 			prod = (prod * prod) % digit; 		} 		itoz((long) prod, res); 		return; 	}
comment|/* 	 * The modulus is more than one digit. 	 * Actually do the square and divide if necessary. 	 */
end_comment

begin_comment
unit|zsquare(z1,&tmp); 	if ((tmp.len< z2.len) || 		((tmp.len == z2.len)&& (tmp.v[tmp.len-1]< z2.v[z2.len-1]))) { 			*res = tmp; 			return; 	} 	zmod(tmp, z2, res); 	zfree(tmp); }
comment|/*  * Add two numbers together and then mod the result with a third number.  * The two numbers to be added can be negative or out of modulo range.  * The result will be in the range 0 to the modulus - 1.  */
end_comment

begin_comment
unit|static void zaddmod(z1, z2, z3, res) 	ZVALUE z1;
comment|/* first number to be added */
end_comment

begin_comment
unit|ZVALUE z2;
comment|/* second number to be added */
end_comment

begin_comment
unit|ZVALUE z3;
comment|/* number to take mod with */
end_comment

begin_comment
unit|ZVALUE *res;
comment|/* result */
end_comment

begin_comment
unit|{ 	ZVALUE tmp; 	FULL sumdigit; 	FULL moddigit;  	if (ziszero(z3) || zisneg(z3)) 		math_error("Mod of non-positive integer"); 	if ((ziszero(z1)&& ziszero(z2)) || zisunit(z3)) { 		*res = _zero_; 		return; 	} 	if (zistwo(z2)) { 		if ((z1.v[0] + z2.v[0])& 0x1) 			*res = _one_; 		else 			*res = _zero_; 		return; 	} 	zadd(z1, z2,&tmp); 	if (zisneg(tmp) || (tmp.len> z3.len)) { 		zmod(tmp, z3, res); 		zfree(tmp); 		return; 	} 	sumdigit = tmp.v[tmp.len - 1]; 	moddigit = z3.v[z3.len - 1]; 	if ((tmp.len< z3.len) || (sumdigit< moddigit)) { 		*res = tmp; 		return; 	} 	if (sumdigit< 2 * moddigit) { 		zsub(tmp, z3, res); 		zfree(tmp); 		return; 	} 	zmod(tmp, z2, res); 	zfree(tmp); }
comment|/*  * Subtract two numbers together and then mod the result with a third number.  * The two numbers to be subtract can be negative or out of modulo range.  * The result will be in the range 0 to the modulus - 1.  */
end_comment

begin_comment
unit|void zsubmod(z1, z2, z3, res) 	ZVALUE z1;
comment|/* number to be subtracted from */
end_comment

begin_comment
unit|ZVALUE z2;
comment|/* number to be subtracted */
end_comment

begin_comment
unit|ZVALUE z3;
comment|/* number to take mod with */
end_comment

begin_comment
unit|ZVALUE *res;
comment|/* result */
end_comment

begin_comment
unit|{ 	if (ziszero(z3) || zisneg(z3)) 		math_error("Mod of non-positive integer"); 	if (ziszero(z2)) { 		zmod(z1, z3, res); 		return; 	} 	if (ziszero(z1)) { 		znegmod(z2, z3, res); 		return; 	} 	if ((z1.sign == z2.sign)&& (z1.len == z2.len)&& 		(z1.v[0] == z2.v[0])&& (zcmp(z1, z2) == 0)) { 			*res = _zero_; 			return; 	} 	z2.sign = !z2.sign; 	zaddmod(z1, z2, z3, res); }
comment|/*  * Calculate the negative of a number modulo another number.  * The number to be negated can be negative or out of modulo range.  * The result will be in the range 0 to the modulus - 1.  */
end_comment

begin_comment
unit|static void znegmod(z1, z2, res) 	ZVALUE z1;
comment|/* number to take negative of */
end_comment

begin_comment
unit|ZVALUE z2;
comment|/* number to take mod with */
end_comment

begin_comment
unit|ZVALUE *res;
comment|/* result */
end_comment

begin_comment
unit|{ 	int sign; 	int cv;  	if (ziszero(z2) || zisneg(z2)) 		math_error("Mod of non-positive integer"); 	if (ziszero(z1) || zisunit(z2)) { 		*res = _zero_; 		return; 	} 	if (zistwo(z2)) { 		if (z1.v[0]& 0x1) 			*res = _one_; 		else 			*res = _zero_; 		return; 	}
comment|/* 	 * If the absolute value of the number is within the modulo range, 	 * then the result is just a copy or a subtraction.  Otherwise go 	 * ahead and negate and reduce the result. 	 */
end_comment

begin_endif
unit|sign = z1.sign; 	z1.sign = 0; 	cv = zrel(z1, z2); 	if (cv == 0) { 		*res = _zero_; 		return; 	} 	if (cv< 0) { 		if (sign) 			zcopy(z1, res); 		else 			zsub(z2, z1, res); 		return; 	} 	z1.sign = !sign; 	zmod(z1, z2, res); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Calculate the number congruent to the given number whose absolute  * value is minimal.  The number to be reduced can be negative or out of  * modulo range.  The result will be within the range -int((modulus-1)/2)  * to int(modulus/2) inclusive.  For example, for modulus 7, numbers are  * reduced to the range [-3, 3], and for modulus 8, numbers are reduced to  * the range [-3, 4].  */
end_comment

begin_function
name|void
name|zminmod
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|;
comment|/* number to find minimum congruence of */
name|ZVALUE
name|z2
decl_stmt|;
comment|/* number to take mod with */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* result */
block|{
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|int
name|cv
decl_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|z2
argument_list|)
operator|||
name|zisneg
argument_list|(
name|z2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Mod of non-positive integer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
operator|||
name|zisunit
argument_list|(
name|z2
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zistwo
argument_list|(
name|z2
argument_list|)
condition|)
block|{
if|if
condition|(
name|zisodd
argument_list|(
name|z1
argument_list|)
condition|)
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
else|else
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do a quick check to see if the number is very small compared 	 * to the modulus.  If so, then the result is obvious. 	 */
if|if
condition|(
name|z1
operator|.
name|len
operator|<
name|z2
operator|.
name|len
operator|-
literal|1
condition|)
block|{
name|zcopy
argument_list|(
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now make sure the input number is within the modulo range. 	 * If not, then reduce it to be within range and make the 	 * quick check again. 	 */
name|sign
operator|=
name|z1
operator|.
name|sign
expr_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|cv
operator|=
name|zrel
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
name|tmp1
operator|=
name|z1
expr_stmt|;
if|if
condition|(
name|cv
operator|>
literal|0
condition|)
block|{
name|z1
operator|.
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
name|zmod
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|len
operator|<
name|z2
operator|.
name|len
operator|-
literal|1
condition|)
block|{
operator|*
name|res
operator|=
name|tmp1
expr_stmt|;
return|return;
block|}
name|sign
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now calculate the difference of the modulus and the absolute 	 * value of the original number.  Compare the original number with 	 * the difference, and return the one with the smallest absolute 	 * value, with the correct sign.  If the two values are equal, then 	 * return the positive result. 	 */
name|zsub
argument_list|(
name|z2
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|cv
operator|=
name|zrel
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|<
literal|0
condition|)
block|{
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|tmp1
operator|.
name|sign
operator|=
operator|(
name|BOOL
operator|)
name|sign
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|v
operator|==
name|z1
operator|.
name|v
condition|)
name|zcopy
argument_list|(
name|tmp1
argument_list|,
name|res
argument_list|)
expr_stmt|;
else|else
operator|*
name|res
operator|=
name|tmp1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cv
condition|)
name|tmp2
operator|.
name|sign
operator|=
operator|!
name|sign
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|v
operator|!=
name|z1
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|tmp2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare two numbers for equality modulo a third number.  * The two numbers to be compared can be negative or out of modulo range.  * Returns TRUE if the numbers are not congruent, and FALSE if they are  * congruent.  */
end_comment

begin_function
name|BOOL
name|zcmpmod
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|z3
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|;
comment|/* first number to be compared */
name|ZVALUE
name|z2
decl_stmt|;
comment|/* second number to be compared */
name|ZVALUE
name|z3
decl_stmt|;
comment|/* modulus */
block|{
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
name|FULL
name|digit
decl_stmt|;
name|LEN
name|len
decl_stmt|;
name|int
name|cv
decl_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z3
argument_list|)
operator|||
name|ziszero
argument_list|(
name|z3
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive modulus in zcmpmod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zistwo
argument_list|(
name|z3
argument_list|)
condition|)
return|return
operator|(
operator|(
operator|(
name|z1
operator|.
name|v
index|[
literal|0
index|]
operator|+
name|z2
operator|.
name|v
index|[
literal|0
index|]
operator|)
operator|&
literal|0x1
operator|)
operator|!=
literal|0
operator|)
return|;
comment|/* 	 * If the two numbers are equal, then their mods are equal. 	 */
if|if
condition|(
operator|(
name|z1
operator|.
name|sign
operator|==
name|z2
operator|.
name|sign
operator|)
operator|&&
operator|(
name|z1
operator|.
name|len
operator|==
name|z2
operator|.
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|z2
operator|.
name|v
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|zcmp
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * If both numbers are negative, then we can make them positive. 	 */
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
operator|&&
name|zisneg
argument_list|(
name|z2
argument_list|)
condition|)
block|{
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|z2
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * For small negative numbers, make them positive before comparing. 	 * In any case, the resulting numbers are in tmp1 and tmp2. 	 */
name|tmp1
operator|=
name|z1
expr_stmt|;
name|tmp2
operator|=
name|z2
expr_stmt|;
name|len
operator|=
name|z3
operator|.
name|len
expr_stmt|;
name|digit
operator|=
name|z3
operator|.
name|v
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
operator|&&
operator|(
operator|(
name|z1
operator|.
name|len
operator|<
name|len
operator|)
operator|||
operator|(
operator|(
name|z1
operator|.
name|len
operator|==
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
name|z1
operator|.
name|len
operator|-
literal|1
index|]
operator|<
name|digit
operator|)
operator|)
operator|)
condition|)
name|zadd
argument_list|(
name|z1
argument_list|,
name|z3
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z2
argument_list|)
operator|&&
operator|(
operator|(
name|z2
operator|.
name|len
operator|<
name|len
operator|)
operator|||
operator|(
operator|(
name|z2
operator|.
name|len
operator|==
name|len
operator|)
operator|&&
operator|(
name|z2
operator|.
name|v
index|[
name|z2
operator|.
name|len
operator|-
literal|1
index|]
operator|<
name|digit
operator|)
operator|)
operator|)
condition|)
name|zadd
argument_list|(
name|z2
argument_list|,
name|z3
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
comment|/* 	 * Now compare the two numbers for equality. 	 * If they are equal we are all done. 	 */
if|if
condition|(
name|zcmp
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp1
operator|.
name|v
operator|!=
name|z1
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
operator|.
name|v
operator|!=
name|z2
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 	 * They are not identical.  Now if both numbers are positive 	 * and less than the modulus, then they are definitely not equal. 	 */
if|if
condition|(
operator|(
name|tmp1
operator|.
name|sign
operator|==
name|tmp2
operator|.
name|sign
operator|)
operator|&&
operator|(
operator|(
name|tmp1
operator|.
name|len
operator|<
name|len
operator|)
operator|||
operator|(
name|zrel
argument_list|(
name|tmp1
argument_list|,
name|z3
argument_list|)
operator|<
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|tmp2
operator|.
name|len
operator|<
name|len
operator|)
operator|||
operator|(
name|zrel
argument_list|(
name|tmp2
argument_list|,
name|z3
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tmp1
operator|.
name|v
operator|!=
name|z1
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
operator|.
name|v
operator|!=
name|z2
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* 	 * Either one of the numbers is negative or is large. 	 * So do the standard thing and subtract the two numbers. 	 * Then they are equal if the result is 0 (mod z3). 	 */
name|zsub
argument_list|(
name|tmp1
argument_list|,
name|tmp2
argument_list|,
operator|&
name|tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|v
operator|!=
name|z1
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
operator|.
name|v
operator|!=
name|z2
operator|.
name|v
condition|)
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
comment|/* 	 * Compare the result with the modulus to see if it is equal to 	 * or less than the modulus.  If so, we know the mod result. 	 */
name|tmp3
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|cv
operator|=
name|zrel
argument_list|(
name|tmp3
argument_list|,
name|z3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv
operator|==
literal|0
condition|)
block|{
name|zfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|cv
operator|<
literal|0
condition|)
block|{
name|zfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* 	 * We are forced to actually do the division. 	 * The numbers are congruent if the result is zero. 	 */
name|zmod
argument_list|(
name|tmp3
argument_list|,
name|z3
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|tmp1
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the result of raising one number to a power modulo another number.  * That is, this computes:  a^b (modulo c).  * This calculates the result by examining the power POWBITS bits at a time,  * using a small table of POWNUMS low powers to calculate powers for those bits,  * and repeated squaring and multiplying by the partial powers to generate  * the complete power.  If the power being raised to is high enough, then  * this uses the REDC algorithm to avoid doing many divisions.  When using  * REDC, multiple calls to this routine using the same modulus will be  * slightly faster.  */
end_comment

begin_function
name|void
name|zpowermod
parameter_list|(
name|z1
parameter_list|,
name|z2
parameter_list|,
name|z3
parameter_list|,
name|res
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|,
name|z2
decl_stmt|,
name|z3
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_block
block|{
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* pointer to current word of the power */
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information to be used */
name|ZVALUE
modifier|*
name|pp
decl_stmt|;
comment|/* pointer to low power table */
name|ZVALUE
name|ans
decl_stmt|,
name|temp
decl_stmt|;
comment|/* calculation values */
name|ZVALUE
name|modpow
decl_stmt|;
comment|/* current small power */
name|ZVALUE
name|lowpowers
index|[
name|POWNUMS
index|]
decl_stmt|;
comment|/* low powers */
name|int
name|sign
decl_stmt|;
comment|/* original sign of number */
name|int
name|curshift
decl_stmt|;
comment|/* shift value for word of power */
name|HALF
name|curhalf
decl_stmt|;
comment|/* current word of power */
name|unsigned
name|int
name|curpow
decl_stmt|;
comment|/* current low power */
name|unsigned
name|int
name|curbit
decl_stmt|;
comment|/* current bit of low power */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z3
argument_list|)
operator|||
name|ziszero
argument_list|(
name|z3
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive modulus in zpowermod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative power in zpowermod"
argument_list|)
expr_stmt|;
name|sign
operator|=
name|z1
operator|.
name|sign
expr_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check easy cases first. 	 */
if|if
condition|(
operator|(
name|ziszero
argument_list|(
name|z1
argument_list|)
operator|&&
operator|!
name|ziszero
argument_list|(
name|z2
argument_list|)
operator|)
operator|||
name|zisunit
argument_list|(
name|z3
argument_list|)
condition|)
block|{
comment|/* 0^(non_zero) or x^y mod 1 always produces zero */
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ziszero
argument_list|(
name|z2
argument_list|)
condition|)
block|{
comment|/* x^0 == 1 */
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zistwo
argument_list|(
name|z3
argument_list|)
condition|)
block|{
comment|/* mod 2 */
if|if
condition|(
name|zisodd
argument_list|(
name|z1
argument_list|)
condition|)
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
else|else
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|z1
argument_list|)
operator|&&
operator|(
operator|!
name|sign
operator|||
name|ziseven
argument_list|(
name|z2
argument_list|)
operator|)
condition|)
block|{
comment|/* 1^x or (-1)^(2x) */
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
comment|/* 	 * Normalize the number being raised to be non-negative and to lie 	 * within the modulo range.  Then check for zero or one specially. 	 */
name|zmod
argument_list|(
name|z1
argument_list|,
name|z3
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|temp
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
name|z1
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|sign
condition|)
block|{
name|zsub
argument_list|(
name|z3
argument_list|,
name|z1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|z1
argument_list|)
expr_stmt|;
name|z1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|z1
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the modulus is odd, large enough, is not one less than an 	 * exact power of two, and if the power is large enough, then use 	 * the REDC algorithm.  The size where this is done is configurable. 	 */
if|if
condition|(
operator|(
name|z2
operator|.
name|len
operator|>
literal|1
operator|)
operator|&&
operator|(
name|z3
operator|.
name|len
operator|>=
name|_pow2_
operator|)
operator|&&
name|zisodd
argument_list|(
name|z3
argument_list|)
operator|&&
operator|!
name|zisallbits
argument_list|(
name|z3
argument_list|)
condition|)
block|{
if|if
condition|(
name|powermodredc
operator|&&
name|zcmp
argument_list|(
name|powermodredc
operator|->
name|mod
argument_list|,
name|z3
argument_list|)
condition|)
block|{
name|zredcfree
argument_list|(
name|powermodredc
argument_list|)
expr_stmt|;
name|powermodredc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|powermodredc
operator|==
name|NULL
condition|)
name|powermodredc
operator|=
name|zredcalloc
argument_list|(
name|z3
argument_list|)
expr_stmt|;
name|rp
operator|=
name|powermodredc
expr_stmt|;
name|zredcencode
argument_list|(
name|rp
argument_list|,
name|z1
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zredcpower
argument_list|(
name|rp
argument_list|,
name|temp
argument_list|,
name|z2
argument_list|,
operator|&
name|z1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zredcdecode
argument_list|(
name|rp
argument_list|,
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|z1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Modulus or power is small enough to perform the power raising 	 * directly.  Initialize the table of powers. 	 */
for|for
control|(
name|pp
operator|=
operator|&
name|lowpowers
index|[
literal|2
index|]
init|;
name|pp
operator|<
operator|&
name|lowpowers
index|[
name|POWNUMS
index|]
condition|;
name|pp
operator|++
control|)
name|pp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|lowpowers
index|[
literal|0
index|]
operator|=
name|_one_
expr_stmt|;
name|lowpowers
index|[
literal|1
index|]
operator|=
name|z1
expr_stmt|;
name|ans
operator|=
name|_one_
expr_stmt|;
name|hp
operator|=
operator|&
name|z2
operator|.
name|v
index|[
name|z2
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|curhalf
operator|=
operator|*
name|hp
expr_stmt|;
name|curshift
operator|=
name|BASEB
operator|-
name|POWBITS
expr_stmt|;
while|while
condition|(
name|curshift
operator|&&
operator|(
operator|(
name|curhalf
operator|>>
name|curshift
operator|)
operator|==
literal|0
operator|)
condition|)
name|curshift
operator|-=
name|POWBITS
expr_stmt|;
comment|/* 	 * Calculate the result by examining the power POWBITS bits at a time, 	 * and use the table of low powers at each iteration. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|curpow
operator|=
operator|(
name|curhalf
operator|>>
name|curshift
operator|)
operator|&
operator|(
name|POWNUMS
operator|-
literal|1
operator|)
expr_stmt|;
name|pp
operator|=
operator|&
name|lowpowers
index|[
name|curpow
index|]
expr_stmt|;
comment|/* 		 * If the small power is not yet saved in the table, then 		 * calculate it and remember it in the table for future use. 		 */
if|if
condition|(
name|pp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curpow
operator|&
literal|0x1
condition|)
name|zcopy
argument_list|(
name|z1
argument_list|,
operator|&
name|modpow
argument_list|)
expr_stmt|;
else|else
name|modpow
operator|=
name|_one_
expr_stmt|;
for|for
control|(
name|curbit
operator|=
literal|0x2
init|;
name|curbit
operator|<=
name|curpow
condition|;
name|curbit
operator|*=
literal|2
control|)
block|{
name|pp
operator|=
operator|&
name|lowpowers
index|[
name|curbit
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|zsquare
argument_list|(
name|lowpowers
index|[
name|curbit
operator|/
literal|2
index|]
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|temp
argument_list|,
name|z3
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curbit
operator|&
name|curpow
condition|)
block|{
name|zmul
argument_list|(
operator|*
name|pp
argument_list|,
name|modpow
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|modpow
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|temp
argument_list|,
name|z3
argument_list|,
operator|&
name|modpow
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|pp
operator|=
operator|&
name|lowpowers
index|[
name|curpow
index|]
expr_stmt|;
operator|*
name|pp
operator|=
name|modpow
expr_stmt|;
block|}
comment|/* 		 * If the power is nonzero, then accumulate the small power 		 * into the result. 		 */
if|if
condition|(
name|curpow
condition|)
block|{
name|zmul
argument_list|(
name|ans
argument_list|,
operator|*
name|pp
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ans
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|temp
argument_list|,
name|z3
argument_list|,
operator|&
name|ans
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Select the next POWBITS bits of the power, if there is 		 * any more to generate. 		 */
name|curshift
operator|-=
name|POWBITS
expr_stmt|;
if|if
condition|(
name|curshift
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|hp
operator|--
operator|==
name|z2
operator|.
name|v
condition|)
break|break;
name|curhalf
operator|=
operator|*
name|hp
expr_stmt|;
name|curshift
operator|=
name|BASEB
operator|-
name|POWBITS
expr_stmt|;
block|}
comment|/* 		 * Square the result POWBITS times to make room for the next 		 * chunk of bits. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POWBITS
condition|;
name|i
operator|++
control|)
block|{
name|zsquare
argument_list|(
name|ans
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ans
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|temp
argument_list|,
name|z3
argument_list|,
operator|&
name|ans
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|pp
operator|=
operator|&
name|lowpowers
index|[
literal|2
index|]
init|;
name|pp
operator|<
operator|&
name|lowpowers
index|[
name|POWNUMS
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|len
condition|)
name|freeh
argument_list|(
name|pp
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ans
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Initialize the REDC algorithm for a particular modulus,  * returning a pointer to a structure that is used for other  * REDC calls.  An error is generated if the structure cannot  * be allocated.  The modulus must be odd and positive.  */
end_comment

begin_function
name|REDC
modifier|*
name|zredcalloc
parameter_list|(
name|z1
parameter_list|)
name|ZVALUE
name|z1
decl_stmt|;
comment|/* modulus to initialize for */
block|{
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|ZVALUE
name|tmp
decl_stmt|;
name|long
name|bit
decl_stmt|;
if|if
condition|(
name|ziseven
argument_list|(
name|z1
argument_list|)
operator|||
name|zisneg
argument_list|(
name|z1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"REDC requires positive odd modulus"
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|REDC
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REDC
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate REDC structure"
argument_list|)
expr_stmt|;
comment|/* 	 * Round up the binary modulus to the next power of two 	 * which is at a word boundary.  Then the shift and modulo 	 * operations mod the binary modulus can be done very cheaply. 	 * Calculate the REDC format for the number 1 for future use. 	 */
name|bit
operator|=
name|zhighbit
argument_list|(
name|z1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bit
operator|%
name|BASEB
condition|)
name|bit
operator|+=
operator|(
name|BASEB
operator|-
operator|(
name|bit
operator|%
name|BASEB
operator|)
operator|)
expr_stmt|;
name|zcopy
argument_list|(
name|z1
argument_list|,
operator|&
name|rp
operator|->
name|mod
argument_list|)
expr_stmt|;
name|zbitvalue
argument_list|(
name|bit
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|z1
operator|.
name|sign
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|zmodinv
argument_list|(
name|z1
argument_list|,
name|tmp
argument_list|,
operator|&
name|rp
operator|->
name|inv
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|tmp
argument_list|,
name|rp
operator|->
name|mod
argument_list|,
operator|&
name|rp
operator|->
name|one
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|len
operator|=
name|bit
operator|/
name|BASEB
expr_stmt|;
return|return
name|rp
return|;
block|}
end_function

begin_comment
comment|/*  * Free any numbers associated with the specified REDC structure,  * and then the REDC structure itself.  */
end_comment

begin_function
name|void
name|zredcfree
parameter_list|(
name|rp
parameter_list|)
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information to be cleared */
block|{
name|zfree
argument_list|(
name|rp
operator|->
name|mod
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|rp
operator|->
name|inv
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|rp
operator|->
name|one
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a normal number into the specified REDC format.  * The number to be converted can be negative or out of modulo range.  * The resulting number can be used for multiplying, adding, subtracting,  * or comparing with any other such converted numbers, as if the numbers  * were being calculated modulo the number which initialized the REDC  * information.  When the final value is unconverted, the result is the  * same as if the usual operations were done with the original numbers.  */
end_comment

begin_function
name|void
name|zredcencode
parameter_list|(
name|rp
parameter_list|,
name|z1
parameter_list|,
name|res
parameter_list|)
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|ZVALUE
name|z1
decl_stmt|;
comment|/* number to be converted */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* returned converted number */
block|{
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* 	 * Handle the cases 0, 1, -1, and 2 specially since these are 	 * easy to calculate.  Zero transforms to zero, and the others 	 * can be obtained from the precomputed REDC format for 1 since 	 * addition and subtraction act normally for REDC format numbers. 	 */
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisone
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|zcopy
argument_list|(
name|rp
operator|->
name|one
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zisunit
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|zsub
argument_list|(
name|rp
operator|->
name|mod
argument_list|,
name|rp
operator|->
name|one
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zistwo
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|zadd
argument_list|(
name|rp
operator|->
name|one
argument_list|,
name|rp
operator|->
name|one
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zrel
argument_list|(
name|tmp1
argument_list|,
name|rp
operator|->
name|mod
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|tmp1
expr_stmt|;
return|return;
block|}
name|zsub
argument_list|(
name|tmp1
argument_list|,
name|rp
operator|->
name|mod
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Not a trivial number to convert, so do the full transformation. 	 * Convert negative numbers to positive numbers before converting. 	 */
name|tmp1
operator|.
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
condition|)
block|{
name|zmod
argument_list|(
name|z1
argument_list|,
name|rp
operator|->
name|mod
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|z1
operator|=
name|tmp1
expr_stmt|;
block|}
name|zshift
argument_list|(
name|z1
argument_list|,
name|rp
operator|->
name|len
operator|*
name|BASEB
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|len
condition|)
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|zmod
argument_list|(
name|tmp2
argument_list|,
name|rp
operator|->
name|mod
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The REDC algorithm used to convert numbers out of REDC format and also  * used after multiplication of two REDC numbers.  Using this routine  * avoids any divides, replacing the divide by two multiplications.  * If the numbers are very large, then these two multiplies will be  * quicker than the divide, since dividing is harder than multiplying.  */
end_comment

begin_function
name|void
name|zredcdecode
parameter_list|(
name|rp
parameter_list|,
name|z1
parameter_list|,
name|res
parameter_list|)
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|ZVALUE
name|z1
decl_stmt|;
comment|/* number to be transformed */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* returned transformed number */
block|{
name|ZVALUE
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* temporaries */
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* saved pointer to tmp2 value */
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative number for zredc"
argument_list|)
expr_stmt|;
comment|/* 	 * Check first for the special values for 0 and 1 that are easy. 	 */
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|z1
operator|.
name|len
operator|==
name|rp
operator|->
name|one
operator|.
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|rp
operator|->
name|one
operator|.
name|v
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|zcmp
argument_list|(
name|z1
argument_list|,
name|rp
operator|->
name|one
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|res
operator|=
name|_one_
expr_stmt|;
return|return;
block|}
comment|/* 	 * First calculate the following: 	 * 	tmp2 = ((z1 % 2^bitnum) * inv) % 2^bitnum. 	 * The mod operations can be done with no work since the bit 	 * number was selected as a multiple of the word size.  Just 	 * reduce the sizes of the numbers as required. 	 */
name|tmp1
operator|=
name|z1
expr_stmt|;
if|if
condition|(
name|tmp1
operator|.
name|len
operator|>
name|rp
operator|->
name|len
condition|)
name|tmp1
operator|.
name|len
operator|=
name|rp
operator|->
name|len
expr_stmt|;
name|zmul
argument_list|(
name|tmp1
argument_list|,
name|rp
operator|->
name|inv
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp2
operator|.
name|len
operator|>
name|rp
operator|->
name|len
condition|)
name|tmp2
operator|.
name|len
operator|=
name|rp
operator|->
name|len
expr_stmt|;
comment|/* 	 * Next calculate the following: 	 *	res = (z1 + tmp2 * modulus) / 2^bitnum 	 * The division by a power of 2 is always exact, and requires no 	 * work.  Just adjust the address and length of the number to do 	 * the divide, but save the original pointer for freeing later. 	 */
name|zmul
argument_list|(
name|tmp2
argument_list|,
name|rp
operator|->
name|mod
argument_list|,
operator|&
name|tmp1
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|zadd
argument_list|(
name|z1
argument_list|,
name|tmp1
argument_list|,
operator|&
name|tmp2
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp1
argument_list|)
expr_stmt|;
name|hp
operator|=
name|tmp2
operator|.
name|v
expr_stmt|;
if|if
condition|(
name|tmp2
operator|.
name|len
operator|<=
name|rp
operator|->
name|len
condition|)
block|{
name|freeh
argument_list|(
name|hp
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
name|tmp2
operator|.
name|v
operator|+=
name|rp
operator|->
name|len
expr_stmt|;
name|tmp2
operator|.
name|len
operator|-=
name|rp
operator|->
name|len
expr_stmt|;
comment|/* 	 * Finally do a final modulo by a simple subtraction if necessary. 	 * This is all that is needed because the previous calculation is 	 * guaranteed to always be less than twice the modulus. 	 */
if|if
condition|(
name|zrel
argument_list|(
name|tmp2
argument_list|,
name|rp
operator|->
name|mod
argument_list|)
operator|<
literal|0
condition|)
name|zcopy
argument_list|(
name|tmp2
argument_list|,
name|res
argument_list|)
expr_stmt|;
else|else
name|zsub
argument_list|(
name|tmp2
argument_list|,
name|rp
operator|->
name|mod
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|freeh
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Multiply two numbers in REDC format together producing a result also  * in REDC format.  If the result is converted back to a normal number,  * then the result is the same as the modulo'd multiplication of the  * original numbers before they were converted to REDC format.  This  * calculation is done in one of two ways, depending on the size of the  * modulus.  For large numbers, the REDC definition is used directly  * which involves three multiplies overall.  For small numbers, a  * complicated routine is used which does the indicated multiplication  * and the REDC algorithm at the same time to produce the result.  */
end_comment

begin_function
name|void
name|zredcmul
parameter_list|(
name|rp
parameter_list|,
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|ZVALUE
name|z1
decl_stmt|;
comment|/* first REDC number to be multiplied */
name|ZVALUE
name|z2
decl_stmt|;
comment|/* second REDC number to be multiplied */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* resulting REDC number */
block|{
name|FULL
name|mulb
decl_stmt|;
name|FULL
name|muln
decl_stmt|;
name|HALF
modifier|*
name|h1
decl_stmt|;
name|HALF
modifier|*
name|h2
decl_stmt|;
name|HALF
modifier|*
name|h3
decl_stmt|;
name|HALF
modifier|*
name|hd
decl_stmt|;
name|HALF
name|Ninv
decl_stmt|;
name|HALF
name|topdigit
init|=
literal|0
decl_stmt|;
name|LEN
name|modlen
decl_stmt|;
name|LEN
name|len
decl_stmt|;
name|LEN
name|len2
decl_stmt|;
name|SIUNION
name|sival1
decl_stmt|;
name|SIUNION
name|sival2
decl_stmt|;
name|SIUNION
name|sival3
decl_stmt|;
name|SIUNION
name|carry
decl_stmt|;
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
operator|||
operator|(
name|z1
operator|.
name|len
operator|>
name|rp
operator|->
name|mod
operator|.
name|len
operator|)
operator|||
name|zisneg
argument_list|(
name|z2
argument_list|)
operator|||
operator|(
name|z2
operator|.
name|len
operator|>
name|rp
operator|->
name|mod
operator|.
name|len
operator|)
condition|)
name|math_error
argument_list|(
literal|"Negative or too large number in zredcmul"
argument_list|)
expr_stmt|;
comment|/* 	 * Check for special values which we easily know the answer. 	 */
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
operator|||
name|ziszero
argument_list|(
name|z2
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|z1
operator|.
name|len
operator|==
name|rp
operator|->
name|one
operator|.
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|rp
operator|->
name|one
operator|.
name|v
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|zcmp
argument_list|(
name|z1
argument_list|,
name|rp
operator|->
name|one
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|zcopy
argument_list|(
name|z2
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|z2
operator|.
name|len
operator|==
name|rp
operator|->
name|one
operator|.
name|len
operator|)
operator|&&
operator|(
name|z2
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|rp
operator|->
name|one
operator|.
name|v
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|zcmp
argument_list|(
name|z2
argument_list|,
name|rp
operator|->
name|one
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|zcopy
argument_list|(
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the size of the modulus is large, then just do the multiply, 	 * followed by the two multiplies contained in the REDC routine. 	 * This will be quicker than directly doing the REDC calculation 	 * because of the O(N^1.585) speed of the multiplies.  The size 	 * of the number which this is done is configurable. 	 */
if|if
condition|(
name|rp
operator|->
name|mod
operator|.
name|len
operator|>=
name|_redc2_
condition|)
block|{
name|zmul
argument_list|(
name|z1
argument_list|,
name|z2
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|zredcdecode
argument_list|(
name|rp
argument_list|,
name|tmp
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The number is small enough to calculate by doing the O(N^2) REDC 	 * algorithm directly.  This algorithm performs the multiplication and 	 * the reduction at the same time.  Notice the obscure facts that 	 * only the lowest word of the inverse value is used, and that 	 * there is no shifting of the partial products as there is in a 	 * normal multiply. 	 */
name|modlen
operator|=
name|rp
operator|->
name|mod
operator|.
name|len
expr_stmt|;
name|Ninv
operator|=
name|rp
operator|->
name|inv
operator|.
name|v
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Allocate the result and clear it. 	 * The size of the result will be equal to or smaller than 	 * the modulus size. 	 */
name|res
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|len
operator|=
name|modlen
expr_stmt|;
name|res
operator|->
name|v
operator|=
name|alloc
argument_list|(
name|modlen
argument_list|)
expr_stmt|;
name|hd
operator|=
name|res
operator|->
name|v
expr_stmt|;
name|len
operator|=
name|modlen
expr_stmt|;
name|zclearval
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
comment|/* 	 * Do this outermost loop over all the digits of z1. 	 */
name|h1
operator|=
name|z1
operator|.
name|v
expr_stmt|;
name|len
operator|=
name|z1
operator|.
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
comment|/* 		 * Start off with the next digit of z1, the first 		 * digit of z2, and the first digit of the modulus. 		 */
name|mulb
operator|=
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
expr_stmt|;
name|h2
operator|=
name|z2
operator|.
name|v
expr_stmt|;
name|h3
operator|=
name|rp
operator|->
name|mod
operator|.
name|v
expr_stmt|;
name|hd
operator|=
name|res
operator|->
name|v
expr_stmt|;
name|sival1
operator|.
name|ivalue
operator|=
name|mulb
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|++
operator|)
expr_stmt|;
name|muln
operator|=
operator|(
call|(
name|HALF
call|)
argument_list|(
name|sival1
operator|.
name|silow
operator|*
name|Ninv
argument_list|)
operator|)
expr_stmt|;
name|sival2
operator|.
name|ivalue
operator|=
name|muln
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
expr_stmt|;
name|sival3
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival1
operator|.
name|silow
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|silow
operator|)
expr_stmt|;
name|carry
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival1
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival3
operator|.
name|sihigh
operator|)
expr_stmt|;
comment|/* 		 * Do this innermost loop for each digit of z2, except 		 * for the first digit which was just done above. 		 */
name|len2
operator|=
name|z2
operator|.
name|len
expr_stmt|;
while|while
condition|(
operator|--
name|len2
operator|>
literal|0
condition|)
block|{
name|sival1
operator|.
name|ivalue
operator|=
name|mulb
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h2
operator|++
operator|)
expr_stmt|;
name|sival2
operator|.
name|ivalue
operator|=
name|muln
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
expr_stmt|;
name|sival3
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival1
operator|.
name|silow
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|silow
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|silow
operator|)
expr_stmt|;
name|carry
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival1
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival3
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|sihigh
operator|)
expr_stmt|;
name|hd
index|[
operator|-
literal|1
index|]
operator|=
name|sival3
operator|.
name|silow
expr_stmt|;
name|hd
operator|++
expr_stmt|;
block|}
comment|/* 		 * Now continue the loop as necessary so the total number 		 * of interations is equal to the size of the modulus. 		 * This acts as if the innermost loop was repeated for 		 * high digits of z2 that are zero. 		 */
name|len2
operator|=
name|modlen
operator|-
name|z2
operator|.
name|len
expr_stmt|;
while|while
condition|(
name|len2
operator|--
condition|)
block|{
name|sival2
operator|.
name|ivalue
operator|=
name|muln
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
expr_stmt|;
name|sival3
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|silow
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|silow
operator|)
expr_stmt|;
name|carry
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival3
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|sihigh
operator|)
expr_stmt|;
name|hd
index|[
operator|-
literal|1
index|]
operator|=
name|sival3
operator|.
name|silow
expr_stmt|;
name|hd
operator|++
expr_stmt|;
block|}
name|res
operator|->
name|v
index|[
name|modlen
operator|-
literal|1
index|]
operator|=
name|carry
operator|.
name|silow
expr_stmt|;
name|topdigit
operator|=
name|carry
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Now continue the loop as necessary so the total number 	 * of interations is equal to the size of the modulus. 	 * This acts as if the outermost loop was repeated for high 	 * digits of z1 that are zero. 	 */
name|len
operator|=
name|modlen
operator|-
name|z1
operator|.
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
comment|/* 		 * Start off with the first digit of the modulus. 		 */
name|h3
operator|=
name|rp
operator|->
name|mod
operator|.
name|v
expr_stmt|;
name|hd
operator|=
name|res
operator|->
name|v
expr_stmt|;
name|muln
operator|=
operator|(
call|(
name|HALF
call|)
argument_list|(
operator|*
name|hd
operator|*
name|Ninv
argument_list|)
operator|)
expr_stmt|;
name|sival2
operator|.
name|ivalue
operator|=
name|muln
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
expr_stmt|;
name|sival3
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|silow
operator|)
expr_stmt|;
name|carry
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival3
operator|.
name|sihigh
operator|)
expr_stmt|;
comment|/* 		 * Do this innermost loop for each digit of the modulus, 		 * except for the first digit which was just done above. 		 */
name|len2
operator|=
name|modlen
expr_stmt|;
while|while
condition|(
operator|--
name|len2
operator|>
literal|0
condition|)
block|{
name|sival2
operator|.
name|ivalue
operator|=
name|muln
operator|*
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h3
operator|++
operator|)
expr_stmt|;
name|sival3
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|silow
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|silow
operator|)
expr_stmt|;
name|carry
operator|.
name|ivalue
operator|=
operator|(
operator|(
name|FULL
operator|)
name|sival2
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|sival3
operator|.
name|sihigh
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|sihigh
operator|)
expr_stmt|;
name|hd
index|[
operator|-
literal|1
index|]
operator|=
name|sival3
operator|.
name|silow
expr_stmt|;
name|hd
operator|++
expr_stmt|;
block|}
name|res
operator|->
name|v
index|[
name|modlen
operator|-
literal|1
index|]
operator|=
name|carry
operator|.
name|silow
expr_stmt|;
name|topdigit
operator|=
name|carry
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Determine the true size of the result, taking the top digit of 	 * the current result into account.  The top digit is not stored in 	 * the number because it is temporary and would become zero anyway 	 * after the final subtraction is done. 	 */
if|if
condition|(
name|topdigit
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|modlen
expr_stmt|;
name|hd
operator|=
operator|&
name|res
operator|->
name|v
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|res
operator|->
name|len
operator|=
name|len
expr_stmt|;
block|}
comment|/* 	 * Compare the result with the modulus. 	 * If it is less than the modulus, then the calculation is complete. 	 */
if|if
condition|(
operator|(
name|topdigit
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|len
operator|<
name|modlen
operator|)
operator|||
operator|(
name|res
operator|->
name|v
index|[
name|len
operator|-
literal|1
index|]
operator|<
name|rp
operator|->
name|mod
operator|.
name|v
index|[
name|len
operator|-
literal|1
index|]
operator|)
operator|||
operator|(
name|zrel
argument_list|(
operator|*
name|res
argument_list|,
name|rp
operator|->
name|mod
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
return|return;
comment|/* 	 * Do a subtraction to reduce the result to a value less than 	 * the modulus.  The REDC algorithm guarantees that a single subtract 	 * is all that is needed.  Ignore any borrowing from the possible 	 * highest word of the current result because that would affect 	 * only the top digit value that was not stored and would become 	 * zero anyway. 	 */
name|carry
operator|.
name|ivalue
operator|=
literal|0
expr_stmt|;
name|h1
operator|=
name|rp
operator|->
name|mod
operator|.
name|v
expr_stmt|;
name|hd
operator|=
name|res
operator|->
name|v
expr_stmt|;
name|len
operator|=
name|modlen
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|carry
operator|.
name|ivalue
operator|=
name|BASE1
operator|-
operator|(
operator|(
name|FULL
operator|)
operator|*
name|hd
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
operator|*
name|h1
operator|++
operator|)
operator|+
operator|(
operator|(
name|FULL
operator|)
name|carry
operator|.
name|silow
operator|)
expr_stmt|;
operator|*
name|hd
operator|++
operator|=
name|BASE1
operator|-
name|carry
operator|.
name|silow
expr_stmt|;
name|carry
operator|.
name|silow
operator|=
name|carry
operator|.
name|sihigh
expr_stmt|;
block|}
comment|/* 	 * Now finally recompute the size of the result. 	 */
name|len
operator|=
name|modlen
expr_stmt|;
name|hd
operator|=
operator|&
name|res
operator|->
name|v
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|hd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|len
operator|>
literal|1
operator|)
condition|)
block|{
name|hd
operator|--
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|res
operator|->
name|len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Square a number in REDC format producing a result also in REDC format.  */
end_comment

begin_function
name|void
name|zredcsquare
parameter_list|(
name|rp
parameter_list|,
name|z1
parameter_list|,
name|res
parameter_list|)
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|ZVALUE
name|z1
decl_stmt|;
comment|/* REDC number to be squared */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* resulting REDC number */
block|{
name|ZVALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative number in zredcsquare"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|z1
operator|.
name|len
operator|==
name|rp
operator|->
name|one
operator|.
name|len
operator|)
operator|&&
operator|(
name|z1
operator|.
name|v
index|[
literal|0
index|]
operator|==
name|rp
operator|->
name|one
operator|.
name|v
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|zcmp
argument_list|(
name|z1
argument_list|,
name|rp
operator|->
name|one
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|zcopy
argument_list|(
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the modulus is small enough, then call the multiply 	 * routine to produce the result.  Otherwise call the O(N^1.585) 	 * routines to get the answer. 	 */
if|if
condition|(
name|rp
operator|->
name|mod
operator|.
name|len
operator|<
name|_redc2_
condition|)
block|{
name|zredcmul
argument_list|(
name|rp
argument_list|,
name|z1
argument_list|,
name|z1
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
name|zsquare
argument_list|(
name|z1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|zredcdecode
argument_list|(
name|rp
argument_list|,
name|tmp
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the result of raising a REDC format number to a power.  * The result is within the range 0 to the modulus - 1.  * This calculates the result by examining the power POWBITS bits at a time,  * using a small table of POWNUMS low powers to calculate powers for those bits,  * and repeated squaring and multiplying by the partial powers to generate  * the complete power.  */
end_comment

begin_function
name|void
name|zredcpower
parameter_list|(
name|rp
parameter_list|,
name|z1
parameter_list|,
name|z2
parameter_list|,
name|res
parameter_list|)
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|ZVALUE
name|z1
decl_stmt|;
comment|/* REDC number to be raised */
name|ZVALUE
name|z2
decl_stmt|;
comment|/* normal number to raise number to */
name|ZVALUE
modifier|*
name|res
decl_stmt|;
comment|/* result */
block|{
name|HALF
modifier|*
name|hp
decl_stmt|;
comment|/* pointer to current word of the power */
name|ZVALUE
modifier|*
name|pp
decl_stmt|;
comment|/* pointer to low power table */
name|ZVALUE
name|ans
decl_stmt|,
name|temp
decl_stmt|;
comment|/* calculation values */
name|ZVALUE
name|modpow
decl_stmt|;
comment|/* current small power */
name|ZVALUE
name|lowpowers
index|[
name|POWNUMS
index|]
decl_stmt|;
comment|/* low powers */
name|int
name|curshift
decl_stmt|;
comment|/* shift value for word of power */
name|HALF
name|curhalf
decl_stmt|;
comment|/* current word of power */
name|unsigned
name|int
name|curpow
decl_stmt|;
comment|/* current low power */
name|unsigned
name|int
name|curbit
decl_stmt|;
comment|/* current bit of low power */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative number in zredcpower"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisneg
argument_list|(
name|z2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Negative power in zredcpower"
argument_list|)
expr_stmt|;
comment|/* 	 * Check for zero or the REDC format for one. 	 */
if|if
condition|(
name|ziszero
argument_list|(
name|z1
argument_list|)
operator|||
name|zisunit
argument_list|(
name|rp
operator|->
name|mod
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|_zero_
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zcmp
argument_list|(
name|z1
argument_list|,
name|rp
operator|->
name|one
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zcopy
argument_list|(
name|rp
operator|->
name|one
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * See if the number being raised is the REDC format for -1. 	 * If so, then the answer is the REDC format for one or minus one. 	 * To do this check, calculate the REDC format for -1. 	 */
if|if
condition|(
operator|(
call|(
name|HALF
call|)
argument_list|(
name|z1
operator|.
name|v
index|[
literal|0
index|]
operator|+
name|rp
operator|->
name|one
operator|.
name|v
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|rp
operator|->
name|mod
operator|.
name|v
index|[
literal|0
index|]
condition|)
block|{
name|zsub
argument_list|(
name|rp
operator|->
name|mod
argument_list|,
name|rp
operator|->
name|one
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcmp
argument_list|(
name|z1
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zisodd
argument_list|(
name|z2
argument_list|)
condition|)
block|{
operator|*
name|res
operator|=
name|temp
expr_stmt|;
return|return;
block|}
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|rp
operator|->
name|one
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
name|zfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
operator|&
name|lowpowers
index|[
literal|2
index|]
init|;
name|pp
operator|<
operator|&
name|lowpowers
index|[
name|POWNUMS
index|]
condition|;
name|pp
operator|++
control|)
name|pp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|zcopy
argument_list|(
name|rp
operator|->
name|one
argument_list|,
operator|&
name|lowpowers
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|z1
argument_list|,
operator|&
name|lowpowers
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|zcopy
argument_list|(
name|rp
operator|->
name|one
argument_list|,
operator|&
name|ans
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|&
name|z2
operator|.
name|v
index|[
name|z2
operator|.
name|len
operator|-
literal|1
index|]
expr_stmt|;
name|curhalf
operator|=
operator|*
name|hp
expr_stmt|;
name|curshift
operator|=
name|BASEB
operator|-
name|POWBITS
expr_stmt|;
while|while
condition|(
name|curshift
operator|&&
operator|(
operator|(
name|curhalf
operator|>>
name|curshift
operator|)
operator|==
literal|0
operator|)
condition|)
name|curshift
operator|-=
name|POWBITS
expr_stmt|;
comment|/* 	 * Calculate the result by examining the power POWBITS bits at a time, 	 * and use the table of low powers at each iteration. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|curpow
operator|=
operator|(
name|curhalf
operator|>>
name|curshift
operator|)
operator|&
operator|(
name|POWNUMS
operator|-
literal|1
operator|)
expr_stmt|;
name|pp
operator|=
operator|&
name|lowpowers
index|[
name|curpow
index|]
expr_stmt|;
comment|/* 		 * If the small power is not yet saved in the table, then 		 * calculate it and remember it in the table for future use. 		 */
if|if
condition|(
name|pp
operator|->
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curpow
operator|&
literal|0x1
condition|)
name|zcopy
argument_list|(
name|z1
argument_list|,
operator|&
name|modpow
argument_list|)
expr_stmt|;
else|else
name|zcopy
argument_list|(
name|rp
operator|->
name|one
argument_list|,
operator|&
name|modpow
argument_list|)
expr_stmt|;
for|for
control|(
name|curbit
operator|=
literal|0x2
init|;
name|curbit
operator|<=
name|curpow
condition|;
name|curbit
operator|*=
literal|2
control|)
block|{
name|pp
operator|=
operator|&
name|lowpowers
index|[
name|curbit
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|len
operator|==
literal|0
condition|)
name|zredcsquare
argument_list|(
name|rp
argument_list|,
name|lowpowers
index|[
name|curbit
operator|/
literal|2
index|]
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbit
operator|&
name|curpow
condition|)
block|{
name|zredcmul
argument_list|(
name|rp
argument_list|,
operator|*
name|pp
argument_list|,
name|modpow
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|modpow
argument_list|)
expr_stmt|;
name|modpow
operator|=
name|temp
expr_stmt|;
block|}
block|}
name|pp
operator|=
operator|&
name|lowpowers
index|[
name|curpow
index|]
expr_stmt|;
operator|*
name|pp
operator|=
name|modpow
expr_stmt|;
block|}
comment|/* 		 * If the power is nonzero, then accumulate the small power 		 * into the result. 		 */
if|if
condition|(
name|curpow
condition|)
block|{
name|zredcmul
argument_list|(
name|rp
argument_list|,
name|ans
argument_list|,
operator|*
name|pp
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ans
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
block|}
comment|/* 		 * Select the next POWBITS bits of the power, if there is 		 * any more to generate. 		 */
name|curshift
operator|-=
name|POWBITS
expr_stmt|;
if|if
condition|(
name|curshift
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|hp
operator|--
operator|==
name|z2
operator|.
name|v
condition|)
break|break;
name|curhalf
operator|=
operator|*
name|hp
expr_stmt|;
name|curshift
operator|=
name|BASEB
operator|-
name|POWBITS
expr_stmt|;
block|}
comment|/* 		 * Square the result POWBITS times to make room for the next 		 * chunk of bits. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|POWBITS
condition|;
name|i
operator|++
control|)
block|{
name|zredcsquare
argument_list|(
name|rp
argument_list|,
name|ans
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|ans
argument_list|)
expr_stmt|;
name|ans
operator|=
name|temp
expr_stmt|;
block|}
block|}
for|for
control|(
name|pp
operator|=
name|lowpowers
init|;
name|pp
operator|<
operator|&
name|lowpowers
index|[
name|POWNUMS
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|len
condition|)
name|freeh
argument_list|(
name|pp
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ans
expr_stmt|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

