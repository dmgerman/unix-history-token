begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Modular arithmetic routines for normal numbers, and also using  * the faster REDC algorithm.  */
end_comment

begin_include
include|#
directive|include
file|"qmath.h"
end_include

begin_comment
comment|/*  * Structure used for caching REDC information.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|NUMBER
modifier|*
name|num
decl_stmt|;
comment|/* modulus being cached */
name|REDC
modifier|*
name|redc
decl_stmt|;
comment|/* REDC information for modulus */
name|long
name|age
decl_stmt|;
comment|/* age counter for reallocation */
block|}
name|REDC_CACHE
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|long
name|redc_age
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current age counter */
end_comment

begin_decl_stmt
specifier|static
name|REDC_CACHE
name|redc_cache
index|[
name|MAXREDC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cached REDC info */
end_comment

begin_decl_stmt
specifier|static
name|REDC
modifier|*
name|qfindredc
name|MATH_PROTO
argument_list|(
operator|(
name|NUMBER
operator|*
name|q
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the remainder when one number is divided by another.  * The second argument cannot be negative.  The result is normalized  * to lie in the range 0 to q2, and works for fractional values as:  *	qmod(q1, q2) = q1 - (int(q1 / q2) * q2).  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qmod
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|ZVALUE
name|res
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive modulus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
comment|/* easy case */
name|zmod
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ziszero
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
block|}
if|if
condition|(
name|zisone
argument_list|(
name|res
argument_list|)
condition|)
block|{
name|zfree
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
return|;
block|}
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|num
operator|=
name|res
expr_stmt|;
return|return
name|q
return|;
block|}
name|q
operator|=
name|qquo
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qmul
argument_list|(
name|q
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|qsub
argument_list|(
name|q1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|qadd
argument_list|(
name|q2
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|tmp
expr_stmt|;
block|}
return|return
name|q
return|;
block|}
end_block

begin_comment
comment|/*  * Given two numbers (a and b), calculate the quotient (c) and remainder (d)  * when a is divided by b.  This is defined so 0<= d< b, and c is integral,  * and a = b * c + d.  The results are returned indirectly through pointers.  * This works for integers or fractions.  Returns whether or not there is a  * remainder.  Examples:  *	qquomod(11, 4,&x,&y) sets x to 2, y to 3, and returns TRUE.  *	qquomod(-7, 3,&x,&y) sets x to -3, y to 2, and returns TRUE.  */
end_comment

begin_function
name|BOOL
name|qquomod
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|retqdiv
parameter_list|,
name|retqmod
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_comment
comment|/* numbers to do quotient with */
end_comment

begin_decl_stmt
name|NUMBER
modifier|*
modifier|*
name|retqdiv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* returned quotient */
end_comment

begin_decl_stmt
name|NUMBER
modifier|*
modifier|*
name|retqmod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* returned modulo */
end_comment

begin_block
block|{
name|NUMBER
modifier|*
name|qq
decl_stmt|,
modifier|*
name|qm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive modulus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisint
argument_list|(
name|q1
argument_list|)
operator|&&
name|qisint
argument_list|(
name|q2
argument_list|)
condition|)
block|{
comment|/* integer case */
name|qq
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|qm
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zdiv
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|qq
operator|->
name|num
argument_list|,
operator|&
name|qm
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|qm
argument_list|)
condition|)
block|{
operator|*
name|retqdiv
operator|=
name|qq
expr_stmt|;
operator|*
name|retqmod
operator|=
name|qm
expr_stmt|;
return|return
operator|!
name|qiszero
argument_list|(
name|qm
argument_list|)
return|;
block|}
comment|/* 		 * Need to fix up negative results. 		 */
name|tmp
operator|=
name|qdec
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|qq
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qsub
argument_list|(
name|q2
argument_list|,
name|qm
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qm
argument_list|)
expr_stmt|;
name|qm
operator|=
name|tmp
expr_stmt|;
operator|*
name|retqdiv
operator|=
name|qq
expr_stmt|;
operator|*
name|retqmod
operator|=
name|qm
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* 	 * Fractional case. 	 */
name|qq
operator|=
name|qquo
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|qmul
argument_list|(
name|qq
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qm
operator|=
name|qsub
argument_list|(
name|q1
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|qm
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|qadd
argument_list|(
name|qm
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qm
argument_list|)
expr_stmt|;
name|qm
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|qdec
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qq
argument_list|)
expr_stmt|;
name|qq
operator|=
name|tmp
expr_stmt|;
block|}
operator|*
name|retqdiv
operator|=
name|qq
expr_stmt|;
operator|*
name|retqmod
operator|=
name|qm
expr_stmt|;
return|return
operator|!
name|qiszero
argument_list|(
name|qm
argument_list|)
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Return the product of two integers modulo a third integer.  * The result is in the range 0 to q3 - 1 inclusive.  *	q4 = (q1 * q2) mod q3.  */
end_comment

begin_comment
unit|NUMBER * qmulmod(q1, q2, q3) 	NUMBER *q1, *q2, *q3; { 	NUMBER *q;  	if (qisneg(q3) || qiszero(q3)) 		math_error("Non-positive modulus"); 	if (qisfrac(q1) || qisfrac(q2) || qisfrac(q3)) 		math_error("Non-integers for qmulmod"); 	if (qiszero(q1) || qiszero(q2) || qisunit(q3)) 		return qlink(&_qzero_); 	q = qalloc(); 	zmulmod(q1->num, q2->num, q3->num,&q->num); 	return q; }
comment|/*  * Return the square of an integer modulo another integer.  * The result is in the range 0 to q2 - 1 inclusive.  *	q2 = (q1^2) mod q2.  */
end_comment

begin_comment
unit|NUMBER * qsquaremod(q1, q2) 	NUMBER *q1, *q2; { 	NUMBER *q;  	if (qisneg(q2) || qiszero(q2)) 		math_error("Non-positive modulus"); 	if (qisfrac(q1) || qisfrac(q2)) 		math_error("Non-integers for qsquaremod"); 	if (qiszero(q1) || qisunit(q2)) 		return qlink(&_qzero_); 	if (qisunit(q1)) 		return qlink(&_qone_); 	q = qalloc(); 	zsquaremod(q1->num, q2->num,&q->num); 	return q; }
comment|/*  * Return the sum of two integers modulo a third integer.  * The result is in the range 0 to q3 - 1 inclusive.  *	q4 = (q1 + q2) mod q3.  */
end_comment

begin_comment
unit|NUMBER * qaddmod(q1, q2, q3) 	NUMBER *q1, *q2, *q3; { 	NUMBER *q;  	if (qisneg(q3) || qiszero(q3)) 		math_error("Non-positive modulus"); 	if (qisfrac(q1) || qisfrac(q2) || qisfrac(q3)) 		math_error("Non-integers for qaddmod"); 	q = qalloc(); 	zaddmod(q1->num, q2->num, q3->num,&q->num); 	return q; }
comment|/*  * Return the difference of two integers modulo a third integer.  * The result is in the range 0 to q3 - 1 inclusive.  *	q4 = (q1 - q2) mod q3.  */
end_comment

begin_comment
unit|NUMBER * qsubmod(q1, q2, q3) 	NUMBER *q1, *q2, *q3; { 	NUMBER *q;  	if (qisneg(q3) || qiszero(q3)) 		math_error("Non-positive modulus"); 	if (qisfrac(q1) || qisfrac(q2) || qisfrac(q3)) 		math_error("Non-integers for qsubmod"); 	if (q1 == q2) 		return qlink(&_qzero_); 	q = qalloc(); 	zsubmod(q1->num, q2->num, q3->num,&q->num); 	return q; }
comment|/*  * Return the negative of an integer modulo another integer.  * The result is in the range 0 to q2 - 1 inclusive.  *	q2 = (-q1) mod q2.  */
end_comment

begin_endif
unit|NUMBER * qnegmod(q1, q2) 	NUMBER *q1, *q2; { 	NUMBER *q;  	if (qisneg(q2) || qiszero(q2)) 		math_error("Non-positive modulus"); 	if (qisfrac(q1) || qisfrac(q2)) 		math_error("Non-integers for qnegmod"); 	if (qiszero(q1) || qisunit(q2)) 		return qlink(&_qzero_); 	q = qalloc(); 	znegmod(q1->num, q2->num,&q->num); 	return q; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the integer congruent to an integer whose absolute value is smallest.  * This is a unique integer in the range int((q2-1)/2 to int(q2/2), inclusive.  * For example, for a modulus of 7, returned values are [-3, 3], and for a  * modulus of 8, returned values are [-3, 4].  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qminmod
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive modulus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for qminmod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
operator|(
name|q1
operator|->
name|num
operator|.
name|len
operator|<
name|q2
operator|->
name|num
operator|.
name|len
operator|-
literal|1
operator|)
condition|)
return|return
name|qlink
argument_list|(
name|q1
argument_list|)
return|;
name|q
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zminmod
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|q
return|;
block|}
end_block

begin_comment
comment|/*  * Return whether or not two integers are congruent modulo a third integer.  * Returns TRUE if the numbers are not congruent, and FALSE if they are.  */
end_comment

begin_function
name|BOOL
name|qcmpmod
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|q3
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|,
modifier|*
name|q3
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|qisneg
argument_list|(
name|q3
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q3
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive modulus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q3
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integers for qcmpmod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q1
operator|==
name|q2
condition|)
return|return
name|FALSE
return|;
return|return
name|zcmpmod
argument_list|(
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
name|q3
operator|->
name|num
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  * Convert an integer into REDC format for use in faster modular arithmetic.  * The number can be negative or out of modulus range.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qredcin
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|;
comment|/* number to convert into REDC format */
name|NUMBER
modifier|*
name|q2
decl_stmt|;
comment|/* modulus */
block|{
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|NUMBER
modifier|*
name|r
decl_stmt|;
comment|/* result */
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integer for qredcin"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|qfindredc
argument_list|(
name|q2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zredcencode
argument_list|(
name|rp
argument_list|,
name|q1
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a REDC format number back into a normal integer.  * The resulting number is in the range 0 to the modulus - 1.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qredcout
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|;
comment|/* number to convert out of REDC format */
name|NUMBER
modifier|*
name|q2
decl_stmt|;
comment|/* modulus */
block|{
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|NUMBER
modifier|*
name|r
decl_stmt|;
comment|/* result */
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive integer required for qredcout"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|qfindredc
argument_list|(
name|q2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zredcdecode
argument_list|(
name|rp
argument_list|,
name|q1
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|zisunit
argument_list|(
name|r
operator|->
name|num
argument_list|)
condition|)
block|{
name|qfree
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|qlink
argument_list|(
operator|&
name|_qone_
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Multiply two REDC format numbers together producing a REDC format result.  * This multiplication is done modulo the specified modulus.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qredcmul
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|q3
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|,
decl|*
name|q2
decl_stmt|;
end_function

begin_comment
comment|/* REDC numbers to be multiplied */
end_comment

begin_decl_stmt
name|NUMBER
modifier|*
name|q3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* modulus */
end_comment

begin_block
block|{
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|NUMBER
modifier|*
name|r
decl_stmt|;
comment|/* result */
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive integers required for qredcmul"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|qfindredc
argument_list|(
name|q3
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zredcmul
argument_list|(
name|rp
argument_list|,
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/*  * Square a REDC format number to produce a REDC format result.  * This squaring is done modulo the specified modulus.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qredcsquare
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|;
comment|/* REDC number to be squared */
name|NUMBER
modifier|*
name|q2
decl_stmt|;
comment|/* modulus */
block|{
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|NUMBER
modifier|*
name|r
decl_stmt|;
comment|/* result */
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive integer required for qredcsquare"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|qfindredc
argument_list|(
name|q2
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zredcsquare
argument_list|(
name|rp
argument_list|,
name|q1
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Raise a REDC format number to the indicated power producing a REDC  * format result.  This is done modulo the specified modulus.  The  * power to be raised to is a normal number.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|qredcpower
parameter_list|(
name|q1
parameter_list|,
name|q2
parameter_list|,
name|q3
parameter_list|)
name|NUMBER
modifier|*
name|q1
decl_stmt|;
comment|/* REDC number to be raised */
name|NUMBER
modifier|*
name|q2
decl_stmt|;
comment|/* power to be raised to */
name|NUMBER
modifier|*
name|q3
decl_stmt|;
comment|/* modulus */
block|{
name|REDC
modifier|*
name|rp
decl_stmt|;
comment|/* REDC information */
name|NUMBER
modifier|*
name|r
decl_stmt|;
comment|/* result */
if|if
condition|(
name|qisfrac
argument_list|(
name|q1
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q2
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive integers required for qredcpower"
argument_list|)
expr_stmt|;
name|rp
operator|=
name|qfindredc
argument_list|(
name|q3
argument_list|)
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qisunit
argument_list|(
name|q3
argument_list|)
condition|)
return|return
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
return|;
name|r
operator|=
name|qalloc
argument_list|()
expr_stmt|;
name|zredcpower
argument_list|(
name|rp
argument_list|,
name|q1
operator|->
name|num
argument_list|,
name|q2
operator|->
name|num
argument_list|,
operator|&
name|r
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Search for and return the REDC information for the specified number.  * The information is cached into a local table so that future calls  * for this information will be quick.  If the table fills up, then  * the oldest cached entry is reused.  */
end_comment

begin_function
specifier|static
name|REDC
modifier|*
name|qfindredc
parameter_list|(
name|q
parameter_list|)
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* modulus to find REDC information of */
block|{
specifier|register
name|REDC_CACHE
modifier|*
name|rcp
decl_stmt|;
name|REDC_CACHE
modifier|*
name|bestrcp
decl_stmt|;
comment|/* 	 * First try for an exact pointer match in the table. 	 */
for|for
control|(
name|rcp
operator|=
name|redc_cache
init|;
name|rcp
operator|<
operator|&
name|redc_cache
index|[
name|MAXREDC
index|]
condition|;
name|rcp
operator|++
control|)
block|{
if|if
condition|(
name|q
operator|==
name|rcp
operator|->
name|num
condition|)
block|{
name|rcp
operator|->
name|age
operator|=
operator|++
name|redc_age
expr_stmt|;
return|return
name|rcp
operator|->
name|redc
return|;
block|}
block|}
comment|/* 	 * Search the table again looking for a value which matches. 	 */
for|for
control|(
name|rcp
operator|=
name|redc_cache
init|;
name|rcp
operator|<
operator|&
name|redc_cache
index|[
name|MAXREDC
index|]
condition|;
name|rcp
operator|++
control|)
block|{
if|if
condition|(
name|rcp
operator|->
name|age
operator|&&
operator|(
name|qcmp
argument_list|(
name|q
argument_list|,
name|rcp
operator|->
name|num
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rcp
operator|->
name|age
operator|=
operator|++
name|redc_age
expr_stmt|;
return|return
name|rcp
operator|->
name|redc
return|;
block|}
block|}
comment|/* 	 * Must invalidate an existing entry in the table. 	 * Find the oldest (or first unused) entry. 	 * But first make sure the modulus will be reasonable. 	 */
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|qiseven
argument_list|(
name|q
argument_list|)
operator|||
name|qisneg
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"REDC modulus must be positive odd integer"
argument_list|)
expr_stmt|;
name|bestrcp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|rcp
operator|=
name|redc_cache
init|;
name|rcp
operator|<
operator|&
name|redc_cache
index|[
name|MAXREDC
index|]
condition|;
name|rcp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bestrcp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|rcp
operator|->
name|age
operator|<
name|bestrcp
operator|->
name|age
operator|)
condition|)
name|bestrcp
operator|=
name|rcp
expr_stmt|;
block|}
comment|/* 	 * Found the best entry. 	 * Free the old information for the entry if necessary, 	 * then initialize it. 	 */
name|rcp
operator|=
name|bestrcp
expr_stmt|;
if|if
condition|(
name|rcp
operator|->
name|age
condition|)
block|{
name|rcp
operator|->
name|age
operator|=
literal|0
expr_stmt|;
name|qfree
argument_list|(
name|rcp
operator|->
name|num
argument_list|)
expr_stmt|;
name|zredcfree
argument_list|(
name|rcp
operator|->
name|redc
argument_list|)
expr_stmt|;
block|}
name|rcp
operator|->
name|redc
operator|=
name|zredcalloc
argument_list|(
name|q
operator|->
name|num
argument_list|)
expr_stmt|;
name|rcp
operator|->
name|num
operator|=
name|qlink
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|rcp
operator|->
name|age
operator|=
operator|++
name|redc_age
expr_stmt|;
return|return
name|rcp
operator|->
name|redc
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

