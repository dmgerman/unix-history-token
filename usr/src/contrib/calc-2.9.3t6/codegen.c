begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Module to generate opcodes from the input tokens.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_include
include|#
directive|include
file|"token.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"label.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
specifier|static
name|BOOL
name|rdonce
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE => do not reread this file */
end_comment

begin_decl_stmt
name|FUNC
modifier|*
name|curfunc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BOOL
name|getfilename
argument_list|()
decl_stmt|,
name|getid
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getshowcommand
argument_list|()
decl_stmt|,
name|getfunction
argument_list|()
decl_stmt|,
name|getbody
argument_list|()
decl_stmt|,
name|getdeclarations
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getstatement
argument_list|()
decl_stmt|,
name|getobjdeclaration
argument_list|()
decl_stmt|,
name|getobjvars
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getmatdeclaration
argument_list|()
decl_stmt|,
name|getsimplebody
argument_list|()
decl_stmt|,
name|getonedeclaration
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getcondition
argument_list|()
decl_stmt|,
name|getmatargs
argument_list|()
decl_stmt|,
name|getelement
argument_list|()
decl_stmt|,
name|usesymbol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|definesymbol
argument_list|()
decl_stmt|,
name|getcallargs
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getexprlist
argument_list|()
decl_stmt|,
name|getassignment
argument_list|()
decl_stmt|,
name|getaltcond
argument_list|()
decl_stmt|,
name|getorcond
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getandcond
argument_list|()
decl_stmt|,
name|getrelation
argument_list|()
decl_stmt|,
name|getsum
argument_list|()
decl_stmt|,
name|getproduct
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getorexpr
argument_list|()
decl_stmt|,
name|getandexpr
argument_list|()
decl_stmt|,
name|getshiftexpr
argument_list|()
decl_stmt|,
name|getterm
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|getidexpr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|getinitlist
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Read all the commands from an input file.  * These are either declarations, or else are commands to execute now.  * In general, commands are terminated by newlines or semicolons.  * Exceptions are function definitions and escaped newlines.  * Commands are read and executed until the end of file.  * The toplevel flag indicates whether we are at the top interactive level.  */
end_comment

begin_function
name|void
name|getcommands
parameter_list|(
name|toplevel
parameter_list|)
name|BOOL
name|toplevel
decl_stmt|;
block|{
name|char
name|name
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* program name */
if|if
condition|(
operator|!
name|toplevel
condition|)
name|enterfilescope
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|TM_NEWLINES
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_DEFINE
case|:
name|getfunction
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_EOF
case|:
if|if
condition|(
operator|!
name|toplevel
condition|)
name|exitfilescope
argument_list|()
expr_stmt|;
return|return;
case|case
name|T_HELP
case|:
if|if
condition|(
operator|!
name|getfilename
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|DEFAULTCALCHELP
argument_list|)
expr_stmt|;
block|}
name|givehelp
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_READ
case|:
if|if
condition|(
operator|!
name|getfilename
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
operator|&
name|rdonce
argument_list|)
condition|)
break|break;
switch|switch
condition|(
name|opensearchfile
argument_list|(
name|name
argument_list|,
name|calcpath
argument_list|,
name|CALCEXT
argument_list|,
name|rdonce
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|getcommands
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* previously read and -once was given */
break|break;
default|default:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Cannot open \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|T_WRITE
case|:
if|if
condition|(
operator|!
name|getfilename
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
if|if
condition|(
name|writeglobals
argument_list|(
name|name
argument_list|)
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Error writing \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SHOW
case|:
name|rescantoken
argument_list|()
expr_stmt|;
name|getshowcommand
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
name|initstack
argument_list|()
expr_stmt|;
if|if
condition|(
name|evaluate
argument_list|(
name|FALSE
argument_list|)
condition|)
name|updateoldvalue
argument_list|(
name|curfunc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Evaluate a line of statements.  * This is done by treating the current line as a function body,  * compiling it, and then executing it.  Returns TRUE if the line  * successfully compiled and executed.  The last expression result  * is saved in the f_savedvalue element of the current function.  * The nestflag variable should be FALSE for the outermost evaluation  * level, and TRUE for all other calls (such as the 'eval' function).  * The function name begins with an asterisk to indicate specialness.  */
end_comment

begin_function
name|BOOL
name|evaluate
parameter_list|(
name|nestflag
parameter_list|)
name|BOOL
name|nestflag
decl_stmt|;
comment|/* TRUE if this is a nested evaluation */
block|{
name|char
modifier|*
name|funcname
decl_stmt|;
name|BOOL
name|gotstatement
decl_stmt|;
name|funcname
operator|=
operator|(
name|nestflag
condition|?
literal|"**"
else|:
literal|"*"
operator|)
expr_stmt|;
name|beginfunc
argument_list|(
name|funcname
argument_list|,
name|nestflag
argument_list|)
expr_stmt|;
name|gotstatement
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_SEMICOLON
case|:
break|break;
case|case
name|T_NEWLINE
case|:
case|case
name|T_EOF
case|:
goto|goto
name|done
goto|;
case|case
name|T_GLOBAL
case|:
case|case
name|T_LOCAL
case|:
case|case
name|T_STATIC
case|:
if|if
condition|(
name|gotstatement
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Declarations must be used before code"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
name|getdeclarations
argument_list|()
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
name|getstatement
argument_list|(
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
name|gotstatement
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|done
label|:
name|addop
argument_list|(
name|OP_UNDEF
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
name|checklabels
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorcount
condition|)
return|return
name|FALSE
return|;
name|calculate
argument_list|(
name|curfunc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get a function declaration.  * func = name '(' '' | name [ ',' name] ... ')' simplebody  *	| name '(' '' | name [ ',' name] ... ')' body.  */
end_comment

begin_function
specifier|static
name|void
name|getfunction
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* parameter name */
name|int
name|type
decl_stmt|;
comment|/* type of token read */
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|TM_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Function name expected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|beginfunc
argument_list|(
name|tokenstring
argument_list|()
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|enterfuncscope
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTPAREN
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Left parenthesis expected for function"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|type
operator|=
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_RIGHTPAREN
condition|)
break|break;
if|if
condition|(
name|type
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_COMMA
argument_list|,
literal|"Bad function definition"
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|tokenstring
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|symboltype
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
name|SYM_UNDEFINED
case|:
case|case
name|SYM_GLOBAL
case|:
case|case
name|SYM_STATIC
case|:
operator|(
name|void
operator|)
name|addparam
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Parameter \"%s\" is already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_RIGHTPAREN
condition|)
break|break;
if|if
condition|(
name|type
operator|!=
name|T_COMMA
condition|)
block|{
name|scanerror
argument_list|(
name|T_COMMA
argument_list|,
literal|"Bad function definition"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_ASSIGN
case|:
name|rescantoken
argument_list|()
expr_stmt|;
name|getsimplebody
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_LEFTBRACE
case|:
name|rescantoken
argument_list|()
expr_stmt|;
name|getbody
argument_list|(
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Left brace or equals sign expected for function"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addop
argument_list|(
name|OP_UNDEF
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
name|endfunc
argument_list|()
expr_stmt|;
name|exitfuncscope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a simple assignment style body for a function declaration.  * simplebody = '=' assignment '\n'.  */
end_comment

begin_function
specifier|static
name|void
name|getsimplebody
parameter_list|()
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_ASSIGN
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing equals for simple function body"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|TM_NEWLINES
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SEMICOLON
condition|)
name|rescantoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_NEWLINE
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Illegal function definition"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the body of a function, or a subbody of a function.  * body = '{' [ declarations ] ... [ statement ] ... '}'  *	| [ declarations ] ... [statement ] ... '\n'  */
end_comment

begin_function
specifier|static
name|void
name|getbody
parameter_list|(
name|contlabel
parameter_list|,
name|breaklabel
parameter_list|,
name|nextcaselabel
parameter_list|,
name|defaultlabel
parameter_list|,
name|toplevel
parameter_list|)
name|LABEL
modifier|*
name|contlabel
decl_stmt|,
decl|*
name|breaklabel
decl_stmt|,
modifier|*
name|nextcaselabel
decl_stmt|,
modifier|*
name|defaultlabel
decl_stmt|;
end_function

begin_decl_stmt
name|BOOL
name|toplevel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BOOL
name|gotstatement
decl_stmt|;
comment|/* TRUE if seen a real statement yet */
name|int
name|oldmode
decl_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACE
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing left brace for function body"
argument_list|)
expr_stmt|;
return|return;
block|}
name|oldmode
operator|=
name|tokenmode
argument_list|(
name|TM_DEFAULT
argument_list|)
expr_stmt|;
name|gotstatement
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACE
case|:
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_GLOBAL
case|:
case|case
name|T_LOCAL
case|:
case|case
name|T_STATIC
case|:
if|if
condition|(
operator|!
name|toplevel
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Declarations must be at the top of the function"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gotstatement
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Declarations must be used before code"
argument_list|)
expr_stmt|;
return|return;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
name|getdeclarations
argument_list|()
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|nextcaselabel
argument_list|,
name|defaultlabel
argument_list|)
expr_stmt|;
name|gotstatement
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Get a line of possible local, global, or static variable declarations.  * declarations = { LOCAL | GLOBAL | STATIC } onedeclaration  *	[ ',' onedeclaration ] ... ';'.  */
end_comment

begin_function
specifier|static
name|void
name|getdeclarations
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|type
operator|=
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|T_LOCAL
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_GLOBAL
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_STATIC
operator|)
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|TRUE
condition|)
block|{
name|getonedeclaration
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_COMMA
case|:
continue|continue;
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
return|return;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Bad syntax in declaration statement"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get a single declaration of a symbol of the specified type.  * onedeclaration = name [ '=' getassignment ]  *	| 'obj' type name [ '=' objvalues ]  *	| 'mat' name '[' matargs ']' [ '=' matvalues ].  */
end_comment

begin_function
specifier|static
name|void
name|getonedeclaration
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of symbol seen */
name|int
name|symtype
decl_stmt|;
comment|/* type of symbol */
name|int
name|vartype
decl_stmt|;
comment|/* type of variable being defined */
name|LABEL
name|label
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_LOCAL
case|:
name|symtype
operator|=
name|SYM_LOCAL
expr_stmt|;
break|break;
case|case
name|T_GLOBAL
case|:
name|symtype
operator|=
name|SYM_GLOBAL
expr_stmt|;
break|break;
case|case
name|T_STATIC
case|:
name|symtype
operator|=
name|SYM_STATIC
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_INITSTATIC
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
break|break;
default|default:
name|symtype
operator|=
name|SYM_UNDEFINED
expr_stmt|;
break|break;
block|}
name|vartype
operator|=
name|gettoken
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|vartype
condition|)
block|{
case|case
name|T_SYMBOL
case|:
name|name
operator|=
name|tokenstring
argument_list|()
expr_stmt|;
name|definesymbol
argument_list|(
name|name
argument_list|,
name|symtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MAT
case|:
name|addopone
argument_list|(
name|OP_DEBUG
argument_list|,
name|linenumber
argument_list|()
argument_list|)
expr_stmt|;
name|getmatdeclaration
argument_list|(
name|symtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtype
operator|==
name|SYM_STATIC
condition|)
name|setlabel
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_OBJ
case|:
name|addopone
argument_list|(
name|OP_DEBUG
argument_list|,
name|linenumber
argument_list|()
argument_list|)
expr_stmt|;
name|getobjdeclaration
argument_list|(
name|symtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtype
operator|==
name|SYM_STATIC
condition|)
name|setlabel
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
return|return;
default|default:
name|scanerror
argument_list|(
name|T_COMMA
argument_list|,
literal|"Bad syntax for declaration"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_ASSIGN
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|symtype
operator|==
name|SYM_STATIC
condition|)
name|setlabel
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Initialize the variable with the expression.  If the variable is 	 * static, arrange for the initialization to only be done once. 	 */
name|addopone
argument_list|(
name|OP_DEBUG
argument_list|,
name|linenumber
argument_list|()
argument_list|)
expr_stmt|;
name|usesymbol
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|getassignment
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_ASSIGNPOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtype
operator|==
name|SYM_STATIC
condition|)
name|setlabel
argument_list|(
operator|&
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a statement.  * statement = IF condition statement [ELSE statement]  *	| FOR '(' [assignment] ';' [assignment] ';' [assignment] ')' statement  *	| WHILE condition statement  *	| DO statement WHILE condition ';'  *	| SWITCH condition '{' [caseclause] ... '}'  *	| CONTINUE ';'  *	| BREAK ';'  *	| RETURN assignment ';'  *	| GOTO label ';'  *	| MAT name '[' value [ ':' value ] [',' value [ ':' value ] ] ']' ';'  *	| OBJ type '{' arg [ ',' arg ] ... '}' ] ';'  *	| OBJ type name [ ',' name ] ';'  *	| PRINT assignment [, assignment ] ... ';'  *	| QUIT [ string ] ';'  *	| SHOW item ';'  *	| body  *	| assignment ';'  *	| label ':' statement  *	| ';'.  */
end_comment

begin_function
specifier|static
name|void
name|getstatement
parameter_list|(
name|contlabel
parameter_list|,
name|breaklabel
parameter_list|,
name|nextcaselabel
parameter_list|,
name|defaultlabel
parameter_list|)
name|LABEL
modifier|*
name|contlabel
decl_stmt|;
comment|/* label for continue statement */
name|LABEL
modifier|*
name|breaklabel
decl_stmt|;
comment|/* label for break statement */
name|LABEL
modifier|*
name|nextcaselabel
decl_stmt|;
comment|/* label for next case statement */
name|LABEL
modifier|*
name|defaultlabel
decl_stmt|;
comment|/* label for default case */
block|{
name|LABEL
name|label1
decl_stmt|,
name|label2
decl_stmt|,
name|label3
decl_stmt|,
name|label4
decl_stmt|;
comment|/* locations for jumps */
name|int
name|type
decl_stmt|;
name|BOOL
name|printeol
decl_stmt|;
name|addopone
argument_list|(
name|OP_DEBUG
argument_list|,
name|linenumber
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
return|return;
case|case
name|T_RIGHTBRACE
case|:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Extraneous right brace"
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_CONTINUE
case|:
if|if
condition|(
name|contlabel
operator|==
name|NULL_LABEL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"CONTINUE not within FOR, WHILE, or DO"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|contlabel
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_BREAK
case|:
if|if
condition|(
name|breaklabel
operator|==
name|NULL_LABEL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"BREAK not within FOR, WHILE, or DO"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|breaklabel
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_GOTO
case|:
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing label in goto"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addop
argument_list|(
name|OP_JUMP
argument_list|)
expr_stmt|;
name|addlabel
argument_list|(
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_RETURN
case|:
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
name|addop
argument_list|(
name|OP_UNDEF
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
return|return;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|curfunc
operator|->
name|f_name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|addop
argument_list|(
name|OP_SAVE
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_RETURN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_LEFTBRACE
case|:
name|rescantoken
argument_list|()
expr_stmt|;
name|getbody
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|nextcaselabel
argument_list|,
name|defaultlabel
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_IF
case|:
name|clearlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|label2
argument_list|)
expr_stmt|;
name|getcondition
argument_list|()
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMPEQ
argument_list|,
operator|&
name|label1
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_ELSE
condition|)
block|{
name|setlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|rescantoken
argument_list|()
expr_stmt|;
return|return;
block|}
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
operator|&
name|label2
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|label2
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_FOR
case|:
comment|/* for (a; b; c) x */
name|clearlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|label2
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|label3
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|label4
argument_list|)
expr_stmt|;
name|contlabel
operator|=
name|NULL_LABEL
expr_stmt|;
name|breaklabel
operator|=
operator|&
name|label4
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTPAREN
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Left parenthesis expected"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SEMICOLON
condition|)
block|{
comment|/* have 'a' part */
name|rescantoken
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SEMICOLON
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing semicolon"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SEMICOLON
condition|)
block|{
comment|/* have 'b' part */
name|setlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|contlabel
operator|=
operator|&
name|label1
expr_stmt|;
name|rescantoken
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMPNE
argument_list|,
operator|&
name|label3
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|breaklabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SEMICOLON
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing semicolon"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_RIGHTPAREN
condition|)
block|{
comment|/* have 'c' part */
if|if
condition|(
name|label1
operator|.
name|l_offset
operator|<=
literal|0
condition|)
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
operator|&
name|label3
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|label2
argument_list|)
expr_stmt|;
name|contlabel
operator|=
operator|&
name|label2
expr_stmt|;
name|rescantoken
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
if|if
condition|(
name|label1
operator|.
name|l_offset
operator|>
literal|0
condition|)
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
operator|&
name|label1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_RIGHTPAREN
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Right parenthesis expected"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|setlabel
argument_list|(
operator|&
name|label3
argument_list|)
expr_stmt|;
if|if
condition|(
name|contlabel
operator|==
name|NULL_LABEL
condition|)
name|contlabel
operator|=
operator|&
name|label3
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|contlabel
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_WHILE
case|:
name|contlabel
operator|=
operator|&
name|label1
expr_stmt|;
name|breaklabel
operator|=
operator|&
name|label2
expr_stmt|;
name|clearlabel
argument_list|(
name|contlabel
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|contlabel
argument_list|)
expr_stmt|;
name|getcondition
argument_list|()
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMPEQ
argument_list|,
name|breaklabel
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|contlabel
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_DO
case|:
name|contlabel
operator|=
operator|&
name|label1
expr_stmt|;
name|breaklabel
operator|=
operator|&
name|label2
expr_stmt|;
name|clearlabel
argument_list|(
name|contlabel
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|label3
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|label3
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_WHILE
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"WHILE keyword expected for DO statement"
argument_list|)
expr_stmt|;
return|return;
block|}
name|setlabel
argument_list|(
name|contlabel
argument_list|)
expr_stmt|;
name|getcondition
argument_list|()
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMPNE
argument_list|,
operator|&
name|label3
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_SWITCH
case|:
name|breaklabel
operator|=
operator|&
name|label1
expr_stmt|;
name|nextcaselabel
operator|=
operator|&
name|label2
expr_stmt|;
name|defaultlabel
operator|=
operator|&
name|label3
expr_stmt|;
name|clearlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
name|nextcaselabel
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
name|defaultlabel
argument_list|)
expr_stmt|;
name|getcondition
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACE
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing left brace for switch statement"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|nextcaselabel
argument_list|)
expr_stmt|;
name|rescantoken
argument_list|()
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|nextcaselabel
argument_list|,
name|defaultlabel
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|breaklabel
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|nextcaselabel
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultlabel
operator|->
name|l_offset
operator|>
literal|0
condition|)
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
name|defaultlabel
argument_list|)
expr_stmt|;
else|else
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|breaklabel
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_CASE
case|:
if|if
condition|(
name|nextcaselabel
operator|==
name|NULL_LABEL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"CASE not within SWITCH statement"
argument_list|)
expr_stmt|;
return|return;
block|}
name|clearlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
operator|&
name|label1
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|nextcaselabel
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
name|nextcaselabel
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_COLON
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Colon expected after CASE expression"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addoplabel
argument_list|(
name|OP_CASEJUMP
argument_list|,
name|nextcaselabel
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|nextcaselabel
argument_list|,
name|defaultlabel
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_DEFAULT
case|:
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_COLON
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Colon expected after DEFAULT keyword"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|defaultlabel
operator|==
name|NULL_LABEL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"DEFAULT not within SWITCH statement"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|defaultlabel
operator|->
name|l_offset
operator|>
literal|0
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Multiple DEFAULT clauses in SWITCH"
argument_list|)
expr_stmt|;
return|return;
block|}
name|clearlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
operator|&
name|label1
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
name|defaultlabel
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|label1
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|nextcaselabel
argument_list|,
name|defaultlabel
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_ELSE
case|:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"ELSE without preceeding IF"
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_MAT
case|:
name|getmatdeclaration
argument_list|(
name|SYM_UNDEFINED
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_OBJ
case|:
name|getobjdeclaration
argument_list|(
name|SYM_UNDEFINED
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PRINT
case|:
name|printeol
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACE
case|:
case|case
name|T_NEWLINE
case|:
name|rescantoken
argument_list|()
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|T_SEMICOLON
case|:
if|if
condition|(
name|printeol
condition|)
name|addop
argument_list|(
name|OP_PRINTEOL
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_COLON
case|:
name|printeol
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|T_COMMA
case|:
name|printeol
operator|=
name|TRUE
expr_stmt|;
name|addop
argument_list|(
name|OP_PRINTSPACE
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_STRING
case|:
name|printeol
operator|=
name|TRUE
expr_stmt|;
name|addopptr
argument_list|(
name|OP_PRINTSTRING
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printeol
operator|=
name|TRUE
expr_stmt|;
name|rescantoken
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
name|addopone
argument_list|(
name|OP_PRINT
argument_list|,
operator|(
name|long
operator|)
name|PRINT_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
case|case
name|T_QUIT
case|:
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_STRING
case|:
name|addopptr
argument_list|(
name|OP_QUIT
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|addopptr
argument_list|(
name|OP_QUIT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rescantoken
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|T_SYMBOL
case|:
if|if
condition|(
name|nextchar
argument_list|()
operator|==
literal|':'
condition|)
block|{
comment|/****HACK HACK ****/
name|definelabel
argument_list|(
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
name|getstatement
argument_list|(
name|contlabel
argument_list|,
name|breaklabel
argument_list|,
name|NULL_LABEL
argument_list|,
name|NULL_LABEL
argument_list|)
expr_stmt|;
return|return;
block|}
name|reread
argument_list|()
expr_stmt|;
comment|/* fall into default case */
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
name|type
operator|=
name|getexprlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|contlabel
operator|||
name|breaklabel
operator|||
operator|(
name|curfunc
operator|->
name|f_name
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|)
condition|)
block|{
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
break|break;
block|}
name|addop
argument_list|(
name|OP_SAVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isassign
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|curfunc
operator|->
name|f_name
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
break|break;
block|}
name|addop
argument_list|(
name|OP_PRINTRESULT
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACE
case|:
case|case
name|T_NEWLINE
case|:
case|case
name|T_EOF
case|:
name|rescantoken
argument_list|()
expr_stmt|;
break|break;
case|case
name|T_SEMICOLON
case|:
break|break;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Semicolon expected"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Read in an object declaration.  * This is of the following form:  *	OBJ type [ '{' id [ ',' id ] ... '}' ]  [ objlist ].  * The OBJ keyword has already been read.  Symtype is SYM_UNDEFINED if this  * is an OBJ statement, otherwise this is part of a declaration which will  * define new symbols with the specified type.  */
end_comment

begin_function
specifier|static
name|void
name|getobjdeclaration
parameter_list|(
name|symtype
parameter_list|)
name|int
name|symtype
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of object type */
name|int
name|count
decl_stmt|;
comment|/* number of elements */
name|int
name|index
decl_stmt|;
comment|/* current index */
name|int
name|i
decl_stmt|;
comment|/* loop counter */
name|BOOL
name|err
decl_stmt|;
comment|/* error flag */
name|int
name|indices
index|[
name|MAXINDICES
index|]
decl_stmt|;
comment|/* indices for elements */
name|err
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Object type name missing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|addliteral
argument_list|(
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACE
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
name|getobjvars
argument_list|(
name|name
argument_list|,
name|symtype
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Read in the definition of the elements of the object. 	 */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing element name in OBJ statement"
argument_list|)
expr_stmt|;
return|return;
block|}
name|index
operator|=
name|addelement
argument_list|(
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|indices
index|[
name|i
index|]
operator|==
name|index
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Duplicate element name \"%s\""
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
name|err
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|indices
index|[
name|count
operator|++
index|]
operator|=
name|index
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACE
case|:
if|if
condition|(
operator|!
name|err
condition|)
operator|(
name|void
operator|)
name|defineobject
argument_list|(
name|name
argument_list|,
name|indices
argument_list|,
name|count
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_SEMICOLON
case|:
case|case
name|T_NEWLINE
case|:
name|rescantoken
argument_list|()
expr_stmt|;
return|return;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
name|getobjvars
argument_list|(
name|name
argument_list|,
name|symtype
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_COMMA
case|:
case|case
name|T_SEMICOLON
case|:
case|case
name|T_NEWLINE
case|:
break|break;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Bad object element definition"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Routine to collect a set of variables for the specified object type  * and initialize them as being that type of object.  * Here  *	objlist = name initlist [ ',' name initlist ] ... ';'.  * If symtype is SYM_UNDEFINED, then this is an OBJ statement where the  * values can be any variable expression, and no symbols are to be defined.  * Otherwise this is part of a declaration, and the variables must be raw  * symbol names which are defined with the specified symbol type.  */
end_comment

begin_function
specifier|static
name|void
name|getobjvars
parameter_list|(
name|name
parameter_list|,
name|symtype
parameter_list|)
name|int
name|symtype
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* object name */
block|{
name|long
name|index
decl_stmt|;
comment|/* index for object */
name|char
modifier|*
name|symname
decl_stmt|;
name|index
operator|=
name|checkobject
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Object %s has not been defined yet"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|symtype
operator|==
name|SYM_UNDEFINED
condition|)
operator|(
name|void
operator|)
name|getidexpr
argument_list|(
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing object variable name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|symname
operator|=
name|tokenstring
argument_list|()
expr_stmt|;
name|definesymbol
argument_list|(
name|symname
argument_list|,
name|symtype
argument_list|)
expr_stmt|;
name|usesymbol
argument_list|(
name|symname
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|addopone
argument_list|(
name|OP_OBJCREATE
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getinitlist
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_COMMA
case|:
break|break;
case|case
name|T_SEMICOLON
case|:
case|case
name|T_NEWLINE
case|:
name|rescantoken
argument_list|()
expr_stmt|;
return|return;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Bad OBJ statement"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read a matrix definition declaration for a one or more dimensional matrix.  * The MAT keyword has already been read.  This also handles an optional  * matrix initialization list enclosed in braces.  Symtype is SYM_UNDEFINED  * if this is part of a MAT statement which handles any variable expression.  * Otherwise this is part of a declaration and only a symbol name is allowed.  */
end_comment

begin_function
specifier|static
name|void
name|getmatdeclaration
parameter_list|(
name|symtype
parameter_list|)
name|int
name|symtype
decl_stmt|;
block|{
name|long
name|dim
decl_stmt|;
name|long
name|index
decl_stmt|;
name|long
name|count
decl_stmt|;
name|long
name|patchpc
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|symtype
operator|==
name|SYM_UNDEFINED
condition|)
operator|(
name|void
operator|)
name|getidexpr
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
condition|)
block|{
name|scanerror
argument_list|(
name|T_COMMA
argument_list|,
literal|"Missing matrix variable name"
argument_list|)
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|tokenstring
argument_list|()
expr_stmt|;
name|definesymbol
argument_list|(
name|name
argument_list|,
name|symtype
argument_list|)
expr_stmt|;
name|usesymbol
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACKET
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing left bracket for MAT"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dim
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If there are no bounds given for the matrix, then they must be 	 * implicitly defined by a list of initialization values.  Put in 	 * a dummy number in the opcode stream for the bounds and remember 	 * its location.  After we know how many values are in the list, we 	 * will patch the correct value back into the opcode. 	 */
if|if
condition|(
name|gettoken
argument_list|()
operator|==
name|T_RIGHTBRACKET
condition|)
block|{
name|clearopt
argument_list|()
expr_stmt|;
name|patchpc
operator|=
name|curfunc
operator|->
name|f_opcodecount
operator|+
literal|1
expr_stmt|;
name|addopone
argument_list|(
name|OP_NUMBER
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clearopt
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_ZERO
argument_list|)
expr_stmt|;
name|addopone
argument_list|(
name|OP_MATCREATE
argument_list|,
name|dim
argument_list|)
expr_stmt|;
name|count
operator|=
name|getinitlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Initialization required for implicit matrix bounds"
argument_list|)
expr_stmt|;
return|return;
block|}
name|index
operator|=
name|addqconstant
argument_list|(
name|itoq
argument_list|(
name|count
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate constant"
argument_list|)
expr_stmt|;
name|curfunc
operator|->
name|f_opcodes
index|[
name|patchpc
index|]
operator|=
name|index
expr_stmt|;
return|return;
block|}
comment|/* 	 * This isn't implicit, so we expect expressions for the bounds. 	 */
name|rescantoken
argument_list|()
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACKET
case|:
case|case
name|T_COMMA
case|:
name|rescantoken
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_ONE
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_SUB
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_ZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_COLON
case|:
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACKET
case|:
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACKET
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
name|addopone
argument_list|(
name|OP_MATCREATE
argument_list|,
name|dim
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getinitlist
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* proceed into comma case */
comment|/*FALLTHRU*/
case|case
name|T_COMMA
case|:
if|if
condition|(
operator|++
name|dim
operator|<=
name|MAXDIM
condition|)
break|break;
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Only %ld dimensions allowed"
argument_list|,
name|MAXDIM
argument_list|)
expr_stmt|;
return|return;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Illegal matrix definition"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get an optional initialization list for a matrix or object definition.  * Returns the number of elements that are in the list, or -1 on parse error.  * This assumes that the address of a matrix or object variable is on the  * stack, and so this routine will pop it off when complete.  *	initlist = [ '=' '{' assignment [ ',' assignment ] ... '}' ].  */
end_comment

begin_function
specifier|static
name|long
name|getinitlist
parameter_list|()
block|{
name|long
name|index
decl_stmt|;
name|int
name|oldmode
decl_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_ASSIGN
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|oldmode
operator|=
name|tokenmode
argument_list|(
name|TM_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACE
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing brace for initialization list"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
condition|;
name|index
operator|++
control|)
block|{
name|getassignment
argument_list|()
expr_stmt|;
name|addopone
argument_list|(
name|OP_ELEMINIT
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_COMMA
case|:
continue|continue;
case|case
name|T_RIGHTBRACE
case|:
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
return|return
name|index
operator|+
literal|1
return|;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Bad initialization list"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|oldmode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get a condition.  * condition = '(' assignment ')'.  */
end_comment

begin_function
specifier|static
name|void
name|getcondition
parameter_list|()
block|{
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTPAREN
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing left parenthesis for condition"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|getexprlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_RIGHTPAREN
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing right parenthesis for condition"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Get an expression list consisting of one or more expressions,  * separated by commas.  The value of the list is that of the final expression.  * This is the top level routine for parsing expressions.  * Returns flags describing the type of assignment or expression found.  * exprlist = assignment [ ',' assignment ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getexprlist
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
name|type
operator|=
name|getassignment
argument_list|()
expr_stmt|;
while|while
condition|(
name|gettoken
argument_list|()
operator|==
name|T_COMMA
condition|)
block|{
name|addop
argument_list|(
name|OP_POP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Get an assignment (or possibly just an expression).  * Returns flags describing the type of assignment or expression found.  * assignment = lvalue '=' assignment  *	| lvalue '+=' assignment  *	| lvalue '-=' assignment  *	| lvalue '*=' assignment  *	| lvalue '/=' assignment  *	| lvalue '%=' assignment  *	| lvalue '//=' assignment  *	| lvalue '&=' assignment  *	| lvalue '|=' assignment  *	| lvalue '<<=' assignment  *	| lvalue '>>=' assignment  *	| lvalue '^=' assignment  *	| lvalue '**=' assignment  *	| orcond.  */
end_comment

begin_function
specifier|static
name|int
name|getassignment
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of expression */
name|long
name|op
decl_stmt|;
comment|/* opcode to generate */
name|type
operator|=
name|getaltcond
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_ASSIGN
case|:
name|op
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_PLUSEQUALS
case|:
name|op
operator|=
name|OP_ADD
expr_stmt|;
break|break;
case|case
name|T_MINUSEQUALS
case|:
name|op
operator|=
name|OP_SUB
expr_stmt|;
break|break;
case|case
name|T_MULTEQUALS
case|:
name|op
operator|=
name|OP_MUL
expr_stmt|;
break|break;
case|case
name|T_DIVEQUALS
case|:
name|op
operator|=
name|OP_DIV
expr_stmt|;
break|break;
case|case
name|T_SLASHSLASHEQUALS
case|:
name|op
operator|=
name|OP_QUO
expr_stmt|;
break|break;
case|case
name|T_MODEQUALS
case|:
name|op
operator|=
name|OP_MOD
expr_stmt|;
break|break;
case|case
name|T_ANDEQUALS
case|:
name|op
operator|=
name|OP_AND
expr_stmt|;
break|break;
case|case
name|T_OREQUALS
case|:
name|op
operator|=
name|OP_OR
expr_stmt|;
break|break;
case|case
name|T_LSHIFTEQUALS
case|:
name|op
operator|=
name|OP_LEFTSHIFT
expr_stmt|;
break|break;
case|case
name|T_RSHIFTEQUALS
case|:
name|op
operator|=
name|OP_RIGHTSHIFT
expr_stmt|;
break|break;
case|case
name|T_POWEREQUALS
case|:
name|op
operator|=
name|OP_POWER
expr_stmt|;
break|break;
case|case
name|T_NUMBER
case|:
case|case
name|T_IMAGINARY
case|:
case|case
name|T_STRING
case|:
case|case
name|T_SYMBOL
case|:
case|case
name|T_OLDVALUE
case|:
case|case
name|T_LEFTPAREN
case|:
case|case
name|T_PLUSPLUS
case|:
case|case
name|T_MINUSMINUS
case|:
case|case
name|T_NOT
case|:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Missing operator"
argument_list|)
expr_stmt|;
return|return
name|type
return|;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
if|if
condition|(
name|isrvalue
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Illegal assignment"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
return|return
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_ASSIGN
operator|)
return|;
block|}
name|writeindexop
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
condition|)
name|addop
argument_list|(
name|OP_DUPLICATE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
condition|)
block|{
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
name|addop
argument_list|(
name|OP_ASSIGN
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_ASSIGN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a possible conditional result expression (question mark).  * Flags are returned indicating the type of expression found.  * altcond = orcond [ '?' orcond ':' altcond ].  */
end_comment

begin_function
specifier|static
name|int
name|getaltcond
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of expression */
name|LABEL
name|donelab
decl_stmt|;
comment|/* label for done */
name|LABEL
name|altlab
decl_stmt|;
comment|/* label for alternate expression */
name|type
operator|=
name|getorcond
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_QUESTIONMARK
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
name|clearlabel
argument_list|(
operator|&
name|donelab
argument_list|)
expr_stmt|;
name|clearlabel
argument_list|(
operator|&
name|altlab
argument_list|)
expr_stmt|;
name|addoplabel
argument_list|(
name|OP_JUMPEQ
argument_list|,
operator|&
name|altlab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getorcond
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_COLON
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing colon for conditional expression"
argument_list|)
expr_stmt|;
return|return
name|EXPR_RVALUE
return|;
block|}
name|addoplabel
argument_list|(
name|OP_JUMP
argument_list|,
operator|&
name|donelab
argument_list|)
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|altlab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getaltcond
argument_list|()
expr_stmt|;
name|setlabel
argument_list|(
operator|&
name|donelab
argument_list|)
expr_stmt|;
return|return
name|EXPR_RVALUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get a possible conditional or expression.  * Flags are returned indicating the type of expression found.  * orcond = andcond [ '||' andcond ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getorcond
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of expression */
name|LABEL
name|donelab
decl_stmt|;
comment|/* label for done */
name|clearlabel
argument_list|(
operator|&
name|donelab
argument_list|)
expr_stmt|;
name|type
operator|=
name|getandcond
argument_list|()
expr_stmt|;
while|while
condition|(
name|gettoken
argument_list|()
operator|==
name|T_OROR
condition|)
block|{
name|addoplabel
argument_list|(
name|OP_CONDORJUMP
argument_list|,
operator|&
name|donelab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getandcond
argument_list|()
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|donelab
operator|.
name|l_chain
operator|>
literal|0
condition|)
name|setlabel
argument_list|(
operator|&
name|donelab
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Get a possible conditional and expression.  * Flags are returned indicating the type of expression found.  * andcond = relation [ '&&' relation ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getandcond
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of expression */
name|LABEL
name|donelab
decl_stmt|;
comment|/* label for done */
name|clearlabel
argument_list|(
operator|&
name|donelab
argument_list|)
expr_stmt|;
name|type
operator|=
name|getrelation
argument_list|()
expr_stmt|;
while|while
condition|(
name|gettoken
argument_list|()
operator|==
name|T_ANDAND
condition|)
block|{
name|addoplabel
argument_list|(
name|OP_CONDANDJUMP
argument_list|,
operator|&
name|donelab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getrelation
argument_list|()
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|donelab
operator|.
name|l_chain
operator|>
literal|0
condition|)
name|setlabel
argument_list|(
operator|&
name|donelab
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Get a possible relation (equality or inequality), or just an expression.  * Flags are returned indicating the type of relation found.  * relation = sum '==' sum  *	| sum '!=' sum  *	| sum '<=' sum  *	| sum '>=' sum  *	| sum '<' sum  *	| sum '>' sum  *	| sum.  */
end_comment

begin_function
specifier|static
name|int
name|getrelation
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of expression */
name|long
name|op
decl_stmt|;
comment|/* opcode to generate */
name|type
operator|=
name|getsum
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_EQ
case|:
name|op
operator|=
name|OP_EQ
expr_stmt|;
break|break;
case|case
name|T_NE
case|:
name|op
operator|=
name|OP_NE
expr_stmt|;
break|break;
case|case
name|T_LT
case|:
name|op
operator|=
name|OP_LT
expr_stmt|;
break|break;
case|case
name|T_GT
case|:
name|op
operator|=
name|OP_GT
expr_stmt|;
break|break;
case|case
name|T_LE
case|:
name|op
operator|=
name|OP_LE
expr_stmt|;
break|break;
case|case
name|T_GE
case|:
name|op
operator|=
name|OP_GE
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
operator|(
name|void
operator|)
name|getsum
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|EXPR_RVALUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get an expression made up of sums of products.  * Flags indicating the type of expression found are returned.  * sum = product [ {'+' | '-'} product ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getsum
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of expression found */
name|long
name|op
decl_stmt|;
comment|/* opcode to generate */
name|type
operator|=
name|getproduct
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_PLUS
case|:
name|op
operator|=
name|OP_ADD
expr_stmt|;
break|break;
case|case
name|T_MINUS
case|:
name|op
operator|=
name|OP_SUB
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
operator|(
name|void
operator|)
name|getproduct
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the product of arithmetic or expressions.  * Flags indicating the type of expression found are returned.  * product = orexpr [ {'*' | '/' | '//' | '%'} orexpr ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getproduct
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of value found */
name|long
name|op
decl_stmt|;
comment|/* opcode to generate */
name|type
operator|=
name|getorexpr
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_MULT
case|:
name|op
operator|=
name|OP_MUL
expr_stmt|;
break|break;
case|case
name|T_DIV
case|:
name|op
operator|=
name|OP_DIV
expr_stmt|;
break|break;
case|case
name|T_MOD
case|:
name|op
operator|=
name|OP_MOD
expr_stmt|;
break|break;
case|case
name|T_SLASHSLASH
case|:
name|op
operator|=
name|OP_QUO
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
operator|(
name|void
operator|)
name|getorexpr
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get an expression made up of arithmetic or operators.  * Flags indicating the type of expression found are returned.  * orexpr = andexpr [ '|' andexpr ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getorexpr
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of value found */
name|type
operator|=
name|getandexpr
argument_list|()
expr_stmt|;
while|while
condition|(
name|gettoken
argument_list|()
operator|==
name|T_OR
condition|)
block|{
operator|(
name|void
operator|)
name|getandexpr
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_OR
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Get an expression made up of arithmetic and operators.  * Flags indicating the type of expression found are returned.  * andexpr = shiftexpr [ '&' shiftexpr ] ...  */
end_comment

begin_function
specifier|static
name|int
name|getandexpr
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of value found */
name|type
operator|=
name|getshiftexpr
argument_list|()
expr_stmt|;
while|while
condition|(
name|gettoken
argument_list|()
operator|==
name|T_AND
condition|)
block|{
operator|(
name|void
operator|)
name|getshiftexpr
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_AND
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/*  * Get a shift or power expression.  * Flags indicating the type of expression found are returned.  * shift = term '^' shiftexpr  *	 | term '<<' shiftexpr  *	 | term '>>' shiftexpr  *	 | term.  */
end_comment

begin_function
specifier|static
name|int
name|getshiftexpr
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of value found */
name|long
name|op
decl_stmt|;
comment|/* opcode to generate */
name|type
operator|=
name|getterm
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_POWER
case|:
name|op
operator|=
name|OP_POWER
expr_stmt|;
break|break;
case|case
name|T_LEFTSHIFT
case|:
name|op
operator|=
name|OP_LEFTSHIFT
expr_stmt|;
break|break;
case|case
name|T_RIGHTSHIFT
case|:
name|op
operator|=
name|OP_RIGHTSHIFT
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
operator|(
name|void
operator|)
name|getshiftexpr
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|EXPR_RVALUE
return|;
block|}
end_function

begin_comment
comment|/*  * Get a single term.  * Flags indicating the type of value found are returned.  * term = lvalue  *	| lvalue '[' assignment ']'  *	| lvalue '++'  *	| lvalue '--'  *	| '++' lvalue  *	| '--' lvalue  *	| real_number  *	| imaginary_number  *	| '.'  *	| string  *	| '(' assignment ')'  *	| function [ '(' [assignment  [',' assignment] ] ')' ]  *	| '!' term  *	| '+' term  *	| '-' term.  */
end_comment

begin_function
specifier|static
name|int
name|getterm
parameter_list|()
block|{
name|int
name|type
decl_stmt|;
comment|/* type of term found */
name|type
operator|=
name|gettoken
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_NUMBER
case|:
name|addopone
argument_list|(
name|OP_NUMBER
argument_list|,
name|tokennumber
argument_list|()
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_CONST
operator|)
expr_stmt|;
break|break;
case|case
name|T_IMAGINARY
case|:
name|addopone
argument_list|(
name|OP_IMAGINARY
argument_list|,
name|tokennumber
argument_list|()
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_CONST
operator|)
expr_stmt|;
break|break;
case|case
name|T_OLDVALUE
case|:
name|addop
argument_list|(
name|OP_OLDVALUE
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_STRING
case|:
name|addopptr
argument_list|(
name|OP_STRING
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_CONST
operator|)
expr_stmt|;
break|break;
case|case
name|T_PLUSPLUS
case|:
if|if
condition|(
name|isrvalue
argument_list|(
name|getterm
argument_list|()
argument_list|)
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad ++ usage"
argument_list|)
expr_stmt|;
name|writeindexop
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_PREINC
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_ASSIGN
operator|)
expr_stmt|;
break|break;
case|case
name|T_MINUSMINUS
case|:
if|if
condition|(
name|isrvalue
argument_list|(
name|getterm
argument_list|()
argument_list|)
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad -- usage"
argument_list|)
expr_stmt|;
name|writeindexop
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_PREDEC
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_ASSIGN
operator|)
expr_stmt|;
break|break;
case|case
name|T_NOT
case|:
operator|(
name|void
operator|)
name|getterm
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_NOT
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
break|break;
case|case
name|T_MINUS
case|:
operator|(
name|void
operator|)
name|getterm
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_NEGATE
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
break|break;
case|case
name|T_PLUS
case|:
operator|(
name|void
operator|)
name|getterm
argument_list|()
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
break|break;
case|case
name|T_LEFTPAREN
case|:
name|type
operator|=
name|getexprlist
argument_list|()
expr_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_RIGHTPAREN
condition|)
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing right parenthesis"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SYMBOL
case|:
name|rescantoken
argument_list|()
expr_stmt|;
name|type
operator|=
name|getidexpr
argument_list|(
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_LEFTBRACKET
case|:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad index usage"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_PERIOD
case|:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad element reference"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|iskeyword
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Expression contains reserved keyword"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Missing expression"
argument_list|)
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_PLUSPLUS
case|:
if|if
condition|(
name|isrvalue
argument_list|(
name|type
argument_list|)
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad ++ usage"
argument_list|)
expr_stmt|;
name|writeindexop
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_POSTINC
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_ASSIGN
operator|)
return|;
case|case
name|T_MINUSMINUS
case|:
if|if
condition|(
name|isrvalue
argument_list|(
name|type
argument_list|)
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad -- usage"
argument_list|)
expr_stmt|;
name|writeindexop
argument_list|()
expr_stmt|;
name|addop
argument_list|(
name|OP_POSTDEC
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXPR_RVALUE
operator||
name|EXPR_ASSIGN
operator|)
return|;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read in an identifier expressions.  * This is a symbol name followed by parenthesis, or by square brackets or  * element refernces.  The symbol can be a global or a local variable name.  * Returns the type of expression found.  */
end_comment

begin_function
specifier|static
name|int
name|getidexpr
parameter_list|(
name|okmat
parameter_list|,
name|autodef
parameter_list|)
name|BOOL
name|okmat
decl_stmt|,
name|autodef
decl_stmt|;
block|{
name|int
name|type
decl_stmt|;
name|char
name|name
index|[
name|SYMBOLSIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* symbol name */
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|getid
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|type
return|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_LEFTPAREN
case|:
name|getcallargs
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|EXPR_RVALUE
expr_stmt|;
break|break;
case|case
name|T_ASSIGN
case|:
name|autodef
operator|=
name|TRUE
expr_stmt|;
comment|/* fall into default case */
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
name|usesymbol
argument_list|(
name|name
argument_list|,
name|autodef
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now collect as many element references and matrix index operations 	 * as there are following the id. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_LEFTBRACKET
case|:
name|rescantoken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|okmat
condition|)
return|return
name|type
return|;
name|getmatargs
argument_list|()
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_PERIOD
case|:
name|getelement
argument_list|()
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_LEFTPAREN
case|:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Function calls not allowed as expressions"
argument_list|)
expr_stmt|;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read in a filename for a read or write command.  * Both quoted and unquoted filenames are handled here.  * The name must be terminated by an end of line or semicolon.  * Returns TRUE if the filename was successfully parsed.  */
end_comment

begin_function
specifier|static
name|BOOL
name|getfilename
parameter_list|(
name|name
parameter_list|,
name|msg_ok
parameter_list|,
name|once
parameter_list|)
name|char
name|name
index|[
name|PATHSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|BOOL
name|msg_ok
decl_stmt|;
comment|/* TRUE => ok to print error messages */
name|BOOL
modifier|*
name|once
decl_stmt|;
comment|/* non-NULL => set to TRUE of -once read */
block|{
comment|/* look at the next token */
operator|(
name|void
operator|)
name|tokenmode
argument_list|(
name|TM_NEWLINES
operator||
name|TM_ALLSYMS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_STRING
case|:
case|case
name|T_SYMBOL
case|:
break|break;
default|default:
if|if
condition|(
name|msg_ok
condition|)
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Filename expected"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
comment|/* determine if we care about a possible -once option */
if|if
condition|(
name|once
operator|!=
name|NULL
condition|)
block|{
comment|/* we care about a possible -once option */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-once"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* -once option found */
operator|*
name|once
operator|=
name|TRUE
expr_stmt|;
comment|/* look for the filename */
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_STRING
case|:
case|case
name|T_SYMBOL
case|:
break|break;
default|default:
if|if
condition|(
name|msg_ok
condition|)
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Filename expected"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|once
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* look at the next token */
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_SEMICOLON
case|:
case|case
name|T_NEWLINE
case|:
case|case
name|T_EOF
case|:
break|break;
default|default:
if|if
condition|(
name|msg_ok
condition|)
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing semicolon after filename"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Read the show command and display useful information.  */
end_comment

begin_function
specifier|static
name|void
name|getshowcommand
parameter_list|()
block|{
name|char
name|name
index|[
name|SYMBOLSIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|gettoken
argument_list|()
operator|!=
name|T_SHOW
operator|)
operator|||
operator|(
name|gettoken
argument_list|()
operator|!=
name|T_SYMBOL
operator|)
condition|)
block|{
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Bad syntax for SHOW command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|name
argument_list|,
name|tokenstring
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_NEWLINE
case|:
case|case
name|T_SEMICOLON
case|:
break|break;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Bad syntax for SHOW command"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|stringindex
argument_list|(
literal|"builtins\0builtin\0globals\0global\0functions\0function\0objfuncs\0objfunc\0memory\0"
argument_list|,
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|showbuiltins
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|showglobals
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
name|showfunctions
argument_list|()
expr_stmt|;
break|break;
case|case
literal|7
case|:
case|case
literal|8
case|:
name|showobjfuncs
argument_list|()
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|mem_stats
argument_list|(
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Unknown SHOW parameter \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read in a set of matrix index arguments, surrounded with square brackets.  * This also handles double square brackets for 'fast indexing'.  */
end_comment

begin_function
specifier|static
name|void
name|getmatargs
parameter_list|()
block|{
name|int
name|dim
decl_stmt|;
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACKET
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Matrix indexing expected"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Parse all levels of the array reference 	 * Look for the 'fast index' first. 	 */
if|if
condition|(
name|gettoken
argument_list|()
operator|==
name|T_LEFTBRACKET
condition|)
block|{
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|gettoken
argument_list|()
operator|!=
name|T_RIGHTBRACKET
operator|)
operator|||
operator|(
name|gettoken
argument_list|()
operator|!=
name|T_RIGHTBRACKET
operator|)
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Bad fast index usage"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addop
argument_list|(
name|OP_FIADDR
argument_list|)
expr_stmt|;
return|return;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
comment|/* 	 * Normal indexing with the indexes separated by commas. 	 * Initialize the flag in the opcode to assume that the array 	 * element will only be referenced for reading.  If the parser 	 * finds that the element will be referenced for writing, then 	 * it will call writeindexop to change the flag in the opcode. 	 */
name|dim
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|getassignment
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTBRACKET
case|:
if|if
condition|(
name|gettoken
argument_list|()
operator|!=
name|T_LEFTBRACKET
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
name|addoptwo
argument_list|(
name|OP_INDEXADDR
argument_list|,
operator|(
name|long
operator|)
name|dim
argument_list|,
operator|(
name|long
operator|)
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* proceed into comma case */
comment|/*FALLTHRU*/
case|case
name|T_COMMA
case|:
if|if
condition|(
operator|++
name|dim
operator|>
name|MAXDIM
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Too many dimensions for array reference"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rescantoken
argument_list|()
expr_stmt|;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Missing right bracket in array reference"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get an element of an object reference.  * The leading period which introduces the element has already been read.  */
end_comment

begin_function
specifier|static
name|void
name|getelement
parameter_list|()
block|{
name|long
name|index
decl_stmt|;
name|char
name|name
index|[
name|SYMBOLSIZE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|getid
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|index
operator|=
name|findelement
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Element \"%s\" is undefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|addopone
argument_list|(
name|OP_ELEMADDR
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read in a single symbol name and copy its value into the given buffer.  * Returns TRUE if a valid symbol id was found.  */
end_comment

begin_function
specifier|static
name|BOOL
name|getid
parameter_list|(
name|buf
parameter_list|)
name|char
name|buf
index|[
name|SYMBOLSIZE
operator|+
literal|1
index|]
decl_stmt|;
block|{
name|int
name|type
decl_stmt|;
name|type
operator|=
name|gettoken
argument_list|()
expr_stmt|;
if|if
condition|(
name|iskeyword
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Reserved keyword used as symbol name"
argument_list|)
expr_stmt|;
name|type
operator|=
name|T_SYMBOL
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
name|T_SYMBOL
condition|)
block|{
name|rescantoken
argument_list|()
expr_stmt|;
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Symbol name expected"
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|strncpy
argument_list|(
name|buf
argument_list|,
name|tokenstring
argument_list|()
argument_list|,
name|SYMBOLSIZE
argument_list|)
expr_stmt|;
name|buf
index|[
name|SYMBOLSIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Define a symbol name to be of the specified symbol type.  This also checks  * to see if the symbol was already defined in an incompatible manner.  */
end_comment

begin_function
specifier|static
name|void
name|definesymbol
parameter_list|(
name|name
parameter_list|,
name|symtype
parameter_list|)
name|int
name|symtype
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
switch|switch
condition|(
name|symboltype
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
name|SYM_UNDEFINED
case|:
case|case
name|SYM_GLOBAL
case|:
case|case
name|SYM_STATIC
case|:
if|if
condition|(
name|symtype
operator|==
name|SYM_LOCAL
condition|)
operator|(
name|void
operator|)
name|addlocal
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|addglobal
argument_list|(
name|name
argument_list|,
operator|(
name|symtype
operator|==
name|SYM_STATIC
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_PARAM
case|:
case|case
name|SYM_LOCAL
case|:
name|scanerror
argument_list|(
name|T_COMMA
argument_list|,
literal|"Variable \"%s\" is already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Check a symbol name to see if it is known and generate code to reference it.  * The symbol can be either a parameter name, a local name, or a global name.  * If autodef is true, we automatically define the name as a global symbol  * if it is not yet known.  */
end_comment

begin_function
specifier|static
name|void
name|usesymbol
parameter_list|(
name|name
parameter_list|,
name|autodef
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* symbol name to be checked */
name|BOOL
name|autodef
decl_stmt|;
block|{
switch|switch
condition|(
name|symboltype
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
name|SYM_LOCAL
case|:
name|addopone
argument_list|(
name|OP_LOCALADDR
argument_list|,
operator|(
name|long
operator|)
name|findlocal
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SYM_PARAM
case|:
name|addopone
argument_list|(
name|OP_PARAMADDR
argument_list|,
operator|(
name|long
operator|)
name|findparam
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SYM_GLOBAL
case|:
case|case
name|SYM_STATIC
case|:
name|addopptr
argument_list|(
name|OP_GLOBALADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|findglobal
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The symbol is not yet defined. 	 * If we are at the top level and we are allowed to, then define it. 	 */
if|if
condition|(
operator|(
name|curfunc
operator|->
name|f_name
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|)
operator|||
operator|!
name|autodef
condition|)
block|{
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"\"%s\" is undefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|addglobal
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|addopptr
argument_list|(
name|OP_GLOBALADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|findglobal
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get arguments for a function call.  * The name and beginning parenthesis has already been seen.  * callargs = [ [ '&' ] assignment  [',' [ '&' ] assignment] ] ')'.  */
end_comment

begin_function
specifier|static
name|void
name|getcallargs
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of function */
block|{
name|long
name|index
decl_stmt|;
comment|/* function index */
name|long
name|op
decl_stmt|;
comment|/* opcode to add */
name|int
name|argcount
decl_stmt|;
comment|/* number of arguments */
name|int
name|type
decl_stmt|;
name|BOOL
name|addrflag
decl_stmt|;
name|op
operator|=
name|OP_CALL
expr_stmt|;
name|index
operator|=
name|getbuiltinfunc
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|op
operator|=
name|OP_USERCALL
expr_stmt|;
name|index
operator|=
name|adduserfunc
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettoken
argument_list|()
operator|==
name|T_RIGHTPAREN
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|OP_CALL
condition|)
name|builtincheck
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addopfunction
argument_list|(
name|op
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|rescantoken
argument_list|()
expr_stmt|;
name|argcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|argcount
operator|++
expr_stmt|;
name|addrflag
operator|=
operator|(
name|gettoken
argument_list|()
operator|==
name|T_AND
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|addrflag
condition|)
name|rescantoken
argument_list|()
expr_stmt|;
name|type
operator|=
name|getassignment
argument_list|()
expr_stmt|;
if|if
condition|(
name|addrflag
condition|)
block|{
if|if
condition|(
name|isrvalue
argument_list|(
name|type
argument_list|)
condition|)
name|scanerror
argument_list|(
name|T_NULL
argument_list|,
literal|"Taking address of non-variable"
argument_list|)
expr_stmt|;
name|writeindexop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addrflag
operator|&&
operator|(
name|op
operator|!=
name|OP_CALL
operator|)
condition|)
name|addop
argument_list|(
name|OP_GETVALUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettoken
argument_list|()
condition|)
block|{
case|case
name|T_RIGHTPAREN
case|:
if|if
condition|(
name|op
operator|==
name|OP_CALL
condition|)
name|builtincheck
argument_list|(
name|index
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
name|addopfunction
argument_list|(
name|op
argument_list|,
name|index
argument_list|,
name|argcount
argument_list|)
expr_stmt|;
return|return;
case|case
name|T_COMMA
case|:
break|break;
default|default:
name|scanerror
argument_list|(
name|T_SEMICOLON
argument_list|,
literal|"Missing right parenthesis in function call"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

