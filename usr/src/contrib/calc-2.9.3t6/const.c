begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Constant number storage module.  */
end_comment

begin_include
include|#
directive|include
file|"calc.h"
end_include

begin_define
define|#
directive|define
name|CONSTALLOCSIZE
value|400
end_define

begin_comment
comment|/* number of constants to allocate */
end_comment

begin_decl_stmt
specifier|static
name|long
name|constcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of constants defined */
end_comment

begin_decl_stmt
specifier|static
name|long
name|constavail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of constants available */
end_comment

begin_decl_stmt
specifier|static
name|NUMBER
modifier|*
modifier|*
name|consttable
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of constants */
end_comment

begin_comment
comment|/*  * Read in a constant number and add it to the table of constant numbers,  * creating a new entry if necessary.  The incoming number is a string  * value which must have a correct format, otherwise an undefined number  * will result.  Returns the index of the number in the constant table.  * Returns zero if the number could not be saved.  */
end_comment

begin_function
name|long
name|addnumber
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* string representation of number */
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|atoq
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|addqconstant
argument_list|(
name|q
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a particular number to the constant table.  * Returns the index of the number in the constant table, or zero  * if the number could not be saved.  The incoming number if freed  * if it is already in the table.  */
end_comment

begin_function
name|long
name|addqconstant
parameter_list|(
name|q
parameter_list|)
specifier|register
name|NUMBER
modifier|*
name|q
decl_stmt|;
comment|/* number to be added */
block|{
specifier|register
name|NUMBER
modifier|*
modifier|*
name|tp
decl_stmt|;
comment|/* pointer to current number */
specifier|register
name|NUMBER
modifier|*
name|t
decl_stmt|;
comment|/* number being tested */
name|long
name|index
decl_stmt|;
comment|/* index into constant table */
name|long
name|numlen
decl_stmt|;
comment|/* numerator length */
name|long
name|denlen
decl_stmt|;
comment|/* denominator length */
name|HALF
name|numlow
decl_stmt|;
comment|/* bottom value of numerator */
name|HALF
name|denlow
decl_stmt|;
comment|/* bottom value of denominator */
name|numlen
operator|=
name|q
operator|->
name|num
operator|.
name|len
expr_stmt|;
name|denlen
operator|=
name|q
operator|->
name|den
operator|.
name|len
expr_stmt|;
name|numlow
operator|=
name|q
operator|->
name|num
operator|.
name|v
index|[
literal|0
index|]
expr_stmt|;
name|denlow
operator|=
name|q
operator|->
name|den
operator|.
name|v
index|[
literal|0
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|consttable
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<=
name|constcount
condition|;
name|index
operator|++
control|)
block|{
name|t
operator|=
operator|*
name|tp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|numlen
operator|!=
name|t
operator|->
name|num
operator|.
name|len
operator|)
operator|||
operator|(
name|numlow
operator|!=
name|t
operator|->
name|num
operator|.
name|v
index|[
literal|0
index|]
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|denlen
operator|!=
name|t
operator|->
name|den
operator|.
name|len
operator|)
operator|||
operator|(
name|denlow
operator|!=
name|t
operator|->
name|den
operator|.
name|v
index|[
literal|0
index|]
operator|)
condition|)
continue|continue;
if|if
condition|(
name|q
operator|->
name|num
operator|.
name|sign
operator|!=
name|t
operator|->
name|num
operator|.
name|sign
condition|)
continue|continue;
if|if
condition|(
name|qcmp
argument_list|(
name|q
argument_list|,
name|t
argument_list|)
operator|==
literal|0
condition|)
block|{
name|qfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
block|}
if|if
condition|(
name|constavail
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|consttable
operator|==
name|NULL
condition|)
block|{
name|tp
operator|=
operator|(
name|NUMBER
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NUMBER
operator|*
argument_list|)
operator|*
operator|(
name|CONSTALLOCSIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|tp
operator|=
operator|(
name|NUMBER
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|consttable
argument_list|,
sizeof|sizeof
argument_list|(
name|NUMBER
operator|*
argument_list|)
operator|*
operator|(
name|constcount
operator|+
name|CONSTALLOCSIZE
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|consttable
operator|=
name|tp
expr_stmt|;
name|constavail
operator|=
name|CONSTALLOCSIZE
expr_stmt|;
block|}
name|constavail
operator|--
expr_stmt|;
name|constcount
operator|++
expr_stmt|;
name|consttable
index|[
name|constcount
index|]
operator|=
name|q
expr_stmt|;
return|return
name|constcount
return|;
block|}
end_function

begin_comment
comment|/*  * Return the value of a constant number given its index.  * Returns address of the number, or NULL if the index is illegal.  */
end_comment

begin_function
name|NUMBER
modifier|*
name|constvalue
parameter_list|(
name|index
parameter_list|)
name|long
name|index
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|index
operator|<=
literal|0
operator|)
operator|||
operator|(
name|index
operator|>
name|constcount
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|consttable
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

