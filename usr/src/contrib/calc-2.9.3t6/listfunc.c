begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * List handling routines.  * Lists can be composed of any types of values, mixed if desired.  * Lists are doubly linked so that elements can be inserted or  * deleted efficiently at any point in the list.  A pointer is  * kept to the most recently indexed element so that sequential  * accesses are fast.  */
end_comment

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_decl_stmt
specifier|static
name|LISTELEM
modifier|*
name|elemalloc
name|MATH_PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LISTELEM
modifier|*
name|listelement
name|MATH_PROTO
argument_list|(
operator|(
name|LIST
operator|*
name|lp
operator|,
name|long
name|index
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elemfree
name|MATH_PROTO
argument_list|(
operator|(
name|LISTELEM
operator|*
name|ep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|removelistelement
name|MATH_PROTO
argument_list|(
operator|(
name|LIST
operator|*
name|lp
operator|,
name|LISTELEM
operator|*
name|ep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Free lists for list headers and list elements.  */
end_comment

begin_decl_stmt
specifier|static
name|FREELIST
name|headerfreelist
init|=
block|{
sizeof|sizeof
argument_list|(
name|LIST
argument_list|)
block|,
comment|/* size of list header */
literal|20
comment|/* number of free headers to keep */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FREELIST
name|elementfreelist
init|=
block|{
sizeof|sizeof
argument_list|(
name|LISTELEM
argument_list|)
block|,
comment|/* size of list element */
literal|1000
comment|/* number of free list elements to keep */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Insert an element before the first element of a list.  */
end_comment

begin_function
name|void
name|insertlistfirst
parameter_list|(
name|lp
parameter_list|,
name|vp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to put element onto */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to be inserted */
block|{
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
comment|/* list element */
name|ep
operator|=
name|elemalloc
argument_list|()
expr_stmt|;
name|copyvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|ep
operator|->
name|e_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_count
operator|==
literal|0
condition|)
name|lp
operator|->
name|l_last
operator|=
name|ep
expr_stmt|;
else|else
block|{
name|lp
operator|->
name|l_cacheindex
operator|++
expr_stmt|;
name|lp
operator|->
name|l_first
operator|->
name|e_prev
operator|=
name|ep
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
name|lp
operator|->
name|l_first
expr_stmt|;
block|}
name|lp
operator|->
name|l_first
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert an element after the last element of a list.  */
end_comment

begin_function
name|void
name|insertlistlast
parameter_list|(
name|lp
parameter_list|,
name|vp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to put element onto */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to be inserted */
block|{
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
comment|/* list element */
name|ep
operator|=
name|elemalloc
argument_list|()
expr_stmt|;
name|copyvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|ep
operator|->
name|e_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_count
operator|==
literal|0
condition|)
name|lp
operator|->
name|l_first
operator|=
name|ep
expr_stmt|;
else|else
block|{
name|lp
operator|->
name|l_last
operator|->
name|e_next
operator|=
name|ep
expr_stmt|;
name|ep
operator|->
name|e_prev
operator|=
name|lp
operator|->
name|l_last
expr_stmt|;
block|}
name|lp
operator|->
name|l_last
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert an element into the middle of list at the given index (zero based).  * The specified index will select the new element, so existing elements  * at or beyond the index will be shifted down one position.  It is legal  * to specify an index which is right at the end of the list, in which  * case the element is appended to the list.  */
end_comment

begin_function
name|void
name|insertlistmiddle
parameter_list|(
name|lp
parameter_list|,
name|index
parameter_list|,
name|vp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to put element onto */
name|long
name|index
decl_stmt|;
comment|/* element number to insert in front of */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to be inserted */
block|{
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
comment|/* list element */
name|LISTELEM
modifier|*
name|oldep
decl_stmt|;
comment|/* old list element at desired index */
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|insertlistfirst
argument_list|(
name|lp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|==
name|lp
operator|->
name|l_count
condition|)
block|{
name|insertlistlast
argument_list|(
name|lp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
name|oldep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|lp
operator|->
name|l_count
operator|)
condition|)
name|oldep
operator|=
name|listelement
argument_list|(
name|lp
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldep
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for list insertion"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|elemalloc
argument_list|()
expr_stmt|;
name|copyvalue
argument_list|(
name|vp
argument_list|,
operator|&
name|ep
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
name|oldep
expr_stmt|;
name|ep
operator|->
name|e_prev
operator|=
name|oldep
operator|->
name|e_prev
expr_stmt|;
name|ep
operator|->
name|e_prev
operator|->
name|e_next
operator|=
name|ep
expr_stmt|;
name|oldep
operator|->
name|e_prev
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_cache
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_cacheindex
operator|=
name|index
expr_stmt|;
name|lp
operator|->
name|l_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the first element from a list, returning its value.  * Returns the null value if no more elements exist.  */
end_comment

begin_function
name|void
name|removelistfirst
parameter_list|(
name|lp
parameter_list|,
name|vp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to have element removed */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* location of the value */
block|{
if|if
condition|(
name|lp
operator|->
name|l_count
operator|==
literal|0
condition|)
block|{
name|vp
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return;
block|}
operator|*
name|vp
operator|=
name|lp
operator|->
name|l_first
operator|->
name|e_value
expr_stmt|;
name|lp
operator|->
name|l_first
operator|->
name|e_value
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|removelistelement
argument_list|(
name|lp
argument_list|,
name|lp
operator|->
name|l_first
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the last element from a list, returning its value.  * Returns the null value if no more elements exist.  */
end_comment

begin_function
name|void
name|removelistlast
parameter_list|(
name|lp
parameter_list|,
name|vp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to have element removed */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* location of the value */
block|{
if|if
condition|(
name|lp
operator|->
name|l_count
operator|==
literal|0
condition|)
block|{
name|vp
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return;
block|}
operator|*
name|vp
operator|=
name|lp
operator|->
name|l_last
operator|->
name|e_value
expr_stmt|;
name|lp
operator|->
name|l_last
operator|->
name|e_value
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|removelistelement
argument_list|(
name|lp
argument_list|,
name|lp
operator|->
name|l_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the element with the given index from a list, returning its value.  */
end_comment

begin_function
name|void
name|removelistmiddle
parameter_list|(
name|lp
parameter_list|,
name|index
parameter_list|,
name|vp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to have element removed */
name|long
name|index
decl_stmt|;
comment|/* list element to be removed */
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* location of the value */
block|{
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
comment|/* element being removed */
name|ep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|index
operator|<
name|lp
operator|->
name|l_count
operator|)
condition|)
name|ep
operator|=
name|listelement
argument_list|(
name|lp
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Index out of bounds for list deletion"
argument_list|)
expr_stmt|;
operator|*
name|vp
operator|=
name|ep
operator|->
name|e_value
expr_stmt|;
name|ep
operator|->
name|e_value
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
name|removelistelement
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an arbitrary element from a list.  * The value contained in the element is freed.  */
end_comment

begin_function
specifier|static
name|void
name|removelistelement
parameter_list|(
name|lp
parameter_list|,
name|ep
parameter_list|)
specifier|register
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list header */
specifier|register
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
comment|/* list element to remove */
block|{
if|if
condition|(
operator|(
name|ep
operator|==
name|lp
operator|->
name|l_cache
operator|)
operator|||
operator|(
operator|(
name|ep
operator|!=
name|lp
operator|->
name|l_first
operator|)
operator|&&
operator|(
name|ep
operator|!=
name|lp
operator|->
name|l_last
operator|)
operator|)
condition|)
name|lp
operator|->
name|l_cache
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_next
condition|)
name|ep
operator|->
name|e_next
operator|->
name|e_prev
operator|=
name|ep
operator|->
name|e_prev
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_prev
condition|)
name|ep
operator|->
name|e_prev
operator|->
name|e_next
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|lp
operator|->
name|l_first
condition|)
block|{
name|lp
operator|->
name|l_first
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|lp
operator|->
name|l_cacheindex
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|==
name|lp
operator|->
name|l_last
condition|)
name|lp
operator|->
name|l_last
operator|=
name|ep
operator|->
name|e_prev
expr_stmt|;
name|lp
operator|->
name|l_count
operator|--
expr_stmt|;
name|elemfree
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search a list for the specified value starting at the specified index.  * Returns the element number (zero based) of the found value, or -1 if  * the value was not found.  */
end_comment

begin_function
name|long
name|listsearch
parameter_list|(
name|lp
parameter_list|,
name|vp
parameter_list|,
name|index
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
specifier|register
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|index
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|listelement
argument_list|(
name|lp
argument_list|,
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
if|if
condition|(
operator|!
name|comparevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|,
name|vp
argument_list|)
condition|)
block|{
name|lp
operator|->
name|l_cache
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_cacheindex
operator|=
name|index
expr_stmt|;
return|return
name|index
return|;
block|}
name|ep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Search a list backwards for the specified value starting at the  * specified index.  Returns the element number (zero based) of the  * found value, or -1 if the value was not found.  */
end_comment

begin_function
name|long
name|listrsearch
parameter_list|(
name|lp
parameter_list|,
name|vp
parameter_list|,
name|index
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|long
name|index
decl_stmt|;
block|{
specifier|register
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|lp
operator|->
name|l_count
condition|)
name|index
operator|=
name|lp
operator|->
name|l_count
operator|-
literal|1
expr_stmt|;
name|ep
operator|=
name|listelement
argument_list|(
name|lp
argument_list|,
name|index
argument_list|)
expr_stmt|;
while|while
condition|(
name|ep
condition|)
block|{
if|if
condition|(
operator|!
name|comparevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|,
name|vp
argument_list|)
condition|)
block|{
name|lp
operator|->
name|l_cache
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_cacheindex
operator|=
name|index
expr_stmt|;
return|return
name|index
return|;
block|}
name|ep
operator|=
name|ep
operator|->
name|e_prev
expr_stmt|;
name|index
operator|--
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Index into a list and return the address for the value corresponding  * to that index.  Returns NULL if the element does not exist.  */
end_comment

begin_function
name|VALUE
modifier|*
name|listfindex
parameter_list|(
name|lp
parameter_list|,
name|index
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to index into */
name|long
name|index
decl_stmt|;
comment|/* index of desired element */
block|{
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|listelement
argument_list|(
name|lp
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|ep
operator|->
name|e_value
return|;
block|}
end_function

begin_comment
comment|/*  * Return the element at a specified index number of a list.  * The list is indexed starting at zero, and negative indices  * indicate to index from the end of the list.  This routine finds  * the element by chaining through the list from the closest one  * of the first, last, and cached elements.  Returns NULL if the  * element does not exist.  */
end_comment

begin_function
specifier|static
name|LISTELEM
modifier|*
name|listelement
parameter_list|(
name|lp
parameter_list|,
name|index
parameter_list|)
specifier|register
name|LIST
modifier|*
name|lp
decl_stmt|;
comment|/* list to index into */
name|long
name|index
decl_stmt|;
comment|/* index of desired element */
block|{
specifier|register
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
comment|/* current list element */
name|long
name|dist
decl_stmt|;
comment|/* distance to element */
name|long
name|temp
decl_stmt|;
comment|/* temporary distance */
name|BOOL
name|forward
decl_stmt|;
comment|/* TRUE if need to walk forwards */
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|index
operator|+=
name|lp
operator|->
name|l_count
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|<
literal|0
operator|)
operator|||
operator|(
name|index
operator|>=
name|lp
operator|->
name|l_count
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Check quick special cases first. 	 */
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
name|lp
operator|->
name|l_first
return|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
return|return
name|lp
operator|->
name|l_first
operator|->
name|e_next
return|;
if|if
condition|(
name|index
operator|==
name|lp
operator|->
name|l_count
operator|-
literal|1
condition|)
return|return
name|lp
operator|->
name|l_last
return|;
if|if
condition|(
operator|(
name|index
operator|==
name|lp
operator|->
name|l_cacheindex
operator|)
operator|&&
name|lp
operator|->
name|l_cache
condition|)
return|return
name|lp
operator|->
name|l_cache
return|;
comment|/* 	 * Calculate whether it is better to go forwards from 	 * the first element or backwards from the last element. 	 */
name|forward
operator|=
operator|(
operator|(
name|index
operator|*
literal|2
operator|)
operator|<=
name|lp
operator|->
name|l_count
operator|)
expr_stmt|;
if|if
condition|(
name|forward
condition|)
block|{
name|dist
operator|=
name|index
expr_stmt|;
name|ep
operator|=
name|lp
operator|->
name|l_first
expr_stmt|;
block|}
else|else
block|{
name|dist
operator|=
operator|(
name|lp
operator|->
name|l_count
operator|-
literal|1
operator|)
operator|-
name|index
expr_stmt|;
name|ep
operator|=
name|lp
operator|->
name|l_last
expr_stmt|;
block|}
comment|/* 	 * Now see if we have a cached element and if so, whether or 	 * not the distance from it is better than the above distance. 	 */
if|if
condition|(
name|lp
operator|->
name|l_cache
condition|)
block|{
name|temp
operator|=
name|index
operator|-
name|lp
operator|->
name|l_cacheindex
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|temp
operator|<
name|dist
operator|)
condition|)
block|{
name|dist
operator|=
name|temp
expr_stmt|;
name|ep
operator|=
name|lp
operator|->
name|l_cache
expr_stmt|;
name|forward
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|-
name|temp
operator|<
name|dist
operator|)
condition|)
block|{
name|dist
operator|=
operator|-
name|temp
expr_stmt|;
name|ep
operator|=
name|lp
operator|->
name|l_cache
expr_stmt|;
name|forward
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
comment|/* 	 * Now walk forwards or backwards from the selected element 	 * until we reach the correct element.  Cache the location of 	 * the found element for future use. 	 */
if|if
condition|(
name|forward
condition|)
block|{
while|while
condition|(
name|dist
operator|--
operator|>
literal|0
condition|)
name|ep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|dist
operator|--
operator|>
literal|0
condition|)
name|ep
operator|=
name|ep
operator|->
name|e_prev
expr_stmt|;
block|}
name|lp
operator|->
name|l_cache
operator|=
name|ep
expr_stmt|;
name|lp
operator|->
name|l_cacheindex
operator|=
name|index
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two lists to see if they are identical.  * Returns TRUE if they are different.  */
end_comment

begin_function
name|BOOL
name|listcmp
parameter_list|(
name|lp1
parameter_list|,
name|lp2
parameter_list|)
name|LIST
modifier|*
name|lp1
decl_stmt|,
decl|*
name|lp2
decl_stmt|;
end_function

begin_block
block|{
name|LISTELEM
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
name|long
name|count
decl_stmt|;
if|if
condition|(
name|lp1
operator|==
name|lp2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|lp1
operator|->
name|l_count
operator|!=
name|lp2
operator|->
name|l_count
condition|)
return|return
name|TRUE
return|;
name|e1
operator|=
name|lp1
operator|->
name|l_first
expr_stmt|;
name|e2
operator|=
name|lp2
operator|->
name|l_first
expr_stmt|;
name|count
operator|=
name|lp1
operator|->
name|l_count
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|comparevalue
argument_list|(
operator|&
name|e1
operator|->
name|e_value
argument_list|,
operator|&
name|e2
operator|->
name|e_value
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|e1
operator|=
name|e1
operator|->
name|e_next
expr_stmt|;
name|e2
operator|=
name|e2
operator|->
name|e_next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_comment
comment|/*  * Copy a list  */
end_comment

begin_function
name|LIST
modifier|*
name|listcopy
parameter_list|(
name|oldlp
parameter_list|)
name|LIST
modifier|*
name|oldlp
decl_stmt|;
block|{
name|LIST
modifier|*
name|lp
decl_stmt|;
name|LISTELEM
modifier|*
name|oldep
decl_stmt|;
name|lp
operator|=
name|listalloc
argument_list|()
expr_stmt|;
name|oldep
operator|=
name|oldlp
operator|->
name|l_first
expr_stmt|;
while|while
condition|(
name|oldep
condition|)
block|{
name|insertlistlast
argument_list|(
name|lp
argument_list|,
operator|&
name|oldep
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|oldep
operator|=
name|oldep
operator|->
name|e_next
expr_stmt|;
block|}
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an element for a list.  */
end_comment

begin_function
specifier|static
name|LISTELEM
modifier|*
name|elemalloc
parameter_list|()
block|{
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
operator|(
name|LISTELEM
operator|*
operator|)
name|allocitem
argument_list|(
operator|&
name|elementfreelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate list element"
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_next
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|e_prev
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|e_value
operator|.
name|v_type
operator|=
name|V_NULL
expr_stmt|;
return|return
name|ep
return|;
block|}
end_function

begin_comment
comment|/*  * Free a list element, along with any contained value.  */
end_comment

begin_function
specifier|static
name|void
name|elemfree
parameter_list|(
name|ep
parameter_list|)
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
block|{
if|if
condition|(
name|ep
operator|->
name|e_value
operator|.
name|v_type
operator|!=
name|V_NULL
condition|)
name|freevalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|)
expr_stmt|;
name|freeitem
argument_list|(
operator|&
name|elementfreelist
argument_list|,
operator|(
name|FREEITEM
operator|*
operator|)
name|ep
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new list header.  */
end_comment

begin_function
name|LIST
modifier|*
name|listalloc
parameter_list|()
block|{
specifier|register
name|LIST
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
operator|(
name|LIST
operator|*
operator|)
name|allocitem
argument_list|(
operator|&
name|headerfreelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot allocate list header"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|l_first
operator|=
name|NULL
expr_stmt|;
name|lp
operator|->
name|l_last
operator|=
name|NULL
expr_stmt|;
name|lp
operator|->
name|l_cache
operator|=
name|NULL
expr_stmt|;
name|lp
operator|->
name|l_cacheindex
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|l_count
operator|=
literal|0
expr_stmt|;
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/*  * Free a list header, along with all of its list elements.  */
end_comment

begin_function
name|void
name|listfree
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|LIST
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
while|while
condition|(
name|lp
operator|->
name|l_count
operator|--
operator|>
literal|0
condition|)
block|{
name|ep
operator|=
name|lp
operator|->
name|l_first
expr_stmt|;
name|lp
operator|->
name|l_first
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
name|elemfree
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
name|freeitem
argument_list|(
operator|&
name|headerfreelist
argument_list|,
operator|(
name|FREEITEM
operator|*
operator|)
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print out a list along with the specified number of its elements.  * The elements are printed out in shortened form.  */
end_comment

begin_function
name|void
name|listprint
parameter_list|(
name|lp
parameter_list|,
name|max_print
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
name|long
name|max_print
decl_stmt|;
block|{
name|long
name|count
decl_stmt|;
name|long
name|index
decl_stmt|;
name|LISTELEM
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|max_print
operator|>
name|lp
operator|->
name|l_count
condition|)
name|max_print
operator|=
name|lp
operator|->
name|l_count
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|lp
operator|->
name|l_first
expr_stmt|;
name|index
operator|=
name|lp
operator|->
name|l_count
expr_stmt|;
while|while
condition|(
name|index
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_value
operator|.
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
operator|!
name|qiszero
argument_list|(
name|ep
operator|->
name|e_value
operator|.
name|v_num
argument_list|)
operator|)
condition|)
name|count
operator|++
expr_stmt|;
name|ep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
block|}
if|if
condition|(
name|max_print
operator|>
literal|0
condition|)
name|math_str
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|math_fmt
argument_list|(
literal|"list (%ld element%s, %ld nonzero)"
argument_list|,
name|lp
operator|->
name|l_count
argument_list|,
operator|(
operator|(
name|lp
operator|->
name|l_count
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_print
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Walk through the first few list elements, printing their 	 * value in short and unambiguous format. 	 */
name|math_str
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|lp
operator|->
name|l_first
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|max_print
condition|;
name|index
operator|++
control|)
block|{
name|math_fmt
argument_list|(
literal|"  [[%ld]] = "
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|printvalue
argument_list|(
operator|&
name|ep
operator|->
name|e_value
argument_list|,
name|PRINT_SHORT
operator||
name|PRINT_UNAMBIG
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|ep
operator|->
name|e_next
expr_stmt|;
block|}
if|if
condition|(
name|max_print
operator|<
name|lp
operator|->
name|l_count
condition|)
name|math_str
argument_list|(
literal|"  ...\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a trivial hash value for a list.  */
end_comment

begin_function
name|HASH
name|listhash
parameter_list|(
name|lp
parameter_list|)
name|LIST
modifier|*
name|lp
decl_stmt|;
block|{
name|HASH
name|hash
decl_stmt|;
name|hash
operator|=
name|lp
operator|->
name|l_count
operator|*
literal|600011
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_count
operator|>
literal|0
condition|)
name|hash
operator|=
name|hash
operator|*
literal|600043
operator|+
name|hashvalue
argument_list|(
operator|&
name|lp
operator|->
name|l_first
operator|->
name|e_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_count
operator|>
literal|1
condition|)
name|hash
operator|=
name|hash
operator|*
literal|600053
operator|+
name|hashvalue
argument_list|(
operator|&
name|lp
operator|->
name|l_last
operator|->
name|e_value
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

