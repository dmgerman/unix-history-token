begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 David I. Bell  * Permission is granted to use, distribute, or modify this source,  * provided that this copyright notice remains intact.  *  * Generic value manipulation routines.  */
end_comment

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"opcodes.h"
end_include

begin_include
include|#
directive|include
file|"func.h"
end_include

begin_include
include|#
directive|include
file|"symbol.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_comment
comment|/*  * Free a value and set its type to undefined.  */
end_comment

begin_function
name|void
name|freevalue
parameter_list|(
name|vp
parameter_list|)
specifier|register
name|VALUE
modifier|*
name|vp
decl_stmt|;
comment|/* value to be freed */
block|{
name|int
name|type
decl_stmt|;
comment|/* type of value being freed */
name|type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|V_NULL
case|:
case|case
name|V_ADDR
case|:
case|case
name|V_FILE
case|:
break|break;
case|case
name|V_STR
case|:
if|if
condition|(
name|vp
operator|->
name|v_subtype
operator|==
name|V_STRALLOC
condition|)
name|free
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_NUM
case|:
name|qfree
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|comfree
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_MAT
case|:
name|matfree
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|listfree
argument_list|(
name|vp
operator|->
name|v_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|assocfree
argument_list|(
name|vp
operator|->
name|v_assoc
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
name|objfree
argument_list|(
name|vp
operator|->
name|v_obj
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Freeing unknown value type"
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_subtype
operator|=
name|V_NOSUBTYPE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy a value from one location to another.  * This overwrites the specified new value without checking it.  */
end_comment

begin_function
name|void
name|copyvalue
parameter_list|(
name|oldvp
parameter_list|,
name|newvp
parameter_list|)
specifier|register
name|VALUE
modifier|*
name|oldvp
decl_stmt|;
comment|/* value to be copied from */
specifier|register
name|VALUE
modifier|*
name|newvp
decl_stmt|;
comment|/* value to be copied into */
block|{
name|newvp
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|oldvp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NULL
case|:
break|break;
case|case
name|V_FILE
case|:
name|newvp
operator|->
name|v_file
operator|=
name|oldvp
operator|->
name|v_file
expr_stmt|;
break|break;
case|case
name|V_NUM
case|:
name|newvp
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|oldvp
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|newvp
operator|->
name|v_com
operator|=
name|clink
argument_list|(
name|oldvp
operator|->
name|v_com
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_STR
case|:
name|newvp
operator|->
name|v_str
operator|=
name|oldvp
operator|->
name|v_str
expr_stmt|;
if|if
condition|(
name|oldvp
operator|->
name|v_subtype
operator|==
name|V_STRALLOC
condition|)
block|{
name|newvp
operator|->
name|v_str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|oldvp
operator|->
name|v_str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|->
name|v_str
operator|==
name|NULL
condition|)
name|math_error
argument_list|(
literal|"Cannot get memory for string copy"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newvp
operator|->
name|v_str
argument_list|,
name|oldvp
operator|->
name|v_str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V_MAT
case|:
name|newvp
operator|->
name|v_mat
operator|=
name|matcopy
argument_list|(
name|oldvp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|newvp
operator|->
name|v_list
operator|=
name|listcopy
argument_list|(
name|oldvp
operator|->
name|v_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|newvp
operator|->
name|v_assoc
operator|=
name|assoccopy
argument_list|(
name|oldvp
operator|->
name|v_assoc
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ADDR
case|:
name|newvp
operator|->
name|v_addr
operator|=
name|oldvp
operator|->
name|v_addr
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
name|newvp
operator|->
name|v_obj
operator|=
name|objcopy
argument_list|(
name|oldvp
operator|->
name|v_obj
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Copying unknown value type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldvp
operator|->
name|v_type
operator|==
name|V_STR
condition|)
block|{
name|newvp
operator|->
name|v_subtype
operator|=
name|oldvp
operator|->
name|v_subtype
expr_stmt|;
block|}
else|else
block|{
name|newvp
operator|->
name|v_subtype
operator|=
name|V_NOSUBTYPE
expr_stmt|;
block|}
name|newvp
operator|->
name|v_type
operator|=
name|oldvp
operator|->
name|v_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Negate an arbitrary value.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|negvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qneg
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|cneg
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matneg
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_NEG
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for negation"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Add two arbitrary values together.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|addvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qadd
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|caddq
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|caddq
argument_list|(
name|v2
operator|->
name|v_com
argument_list|,
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cadd
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_MAT
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matadd
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|&&
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-compatible values for add"
argument_list|)
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_ADD
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Subtract one arbitrary value from another one.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|subvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qsub
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|csubq
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_COM
argument_list|)
case|:
name|c
operator|=
name|csubq
argument_list|(
name|v2
operator|->
name|v_com
argument_list|,
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_com
operator|=
name|cneg
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|csub
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_MAT
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matsub
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|&&
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-compatible values for subtract"
argument_list|)
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_SUB
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Multiply two arbitrary values together.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|mulvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qmul
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cmulq
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cmulq
argument_list|(
name|v2
operator|->
name|v_com
argument_list|,
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cmul
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_MAT
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matmul
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_NUM
argument_list|)
case|:
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matmulval
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_MAT
argument_list|)
case|:
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_MAT
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matmulval
argument_list|(
name|v2
operator|->
name|v_mat
argument_list|,
name|v1
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|&&
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-compatible values for multiply"
argument_list|)
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_MUL
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Square an arbitrary value.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|squarevalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qsquare
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|csquare
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matsquare
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_SQUARE
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for squaring"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Invert an arbitrary value.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|invertvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qinv
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|cinv
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matinv
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_INV
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for inverting"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Round an arbitrary value to the specified number of decimal places.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|roundvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|long
name|places
init|=
operator|-
literal|1
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
switch|switch
condition|(
name|v2
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|q
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad number of places for round"
argument_list|)
expr_stmt|;
name|places
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_INT
case|:
name|places
operator|=
name|v2
operator|->
name|v_int
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad value type for places in round"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|places
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Negative number of places in round"
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|qisint
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
condition|)
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
else|else
name|vres
operator|->
name|v_num
operator|=
name|qround
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
if|if
condition|(
name|cisint
argument_list|(
name|v1
operator|->
name|v_com
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_com
operator|=
name|clink
argument_list|(
name|v1
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
block|}
name|vres
operator|->
name|v_com
operator|=
name|cround
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matround
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_ROUND
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for round"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Round an arbitrary value to the specified number of binary places.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|broundvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|long
name|places
init|=
operator|-
literal|1
decl_stmt|;
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
switch|switch
condition|(
name|v2
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|q
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
operator|||
name|zisbig
argument_list|(
name|q
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Bad number of places for bround"
argument_list|)
expr_stmt|;
name|places
operator|=
name|qtoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_INT
case|:
name|places
operator|=
name|v2
operator|->
name|v_int
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Bad value type for places in bround"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|places
operator|<
literal|0
condition|)
name|math_error
argument_list|(
literal|"Negative number of places in bround"
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|qisint
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
condition|)
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
else|else
name|vres
operator|->
name|v_num
operator|=
name|qbround
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
if|if
condition|(
name|cisint
argument_list|(
name|v1
operator|->
name|v_com
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_com
operator|=
name|clink
argument_list|(
name|v1
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
block|}
name|vres
operator|->
name|v_com
operator|=
name|cbround
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matbround
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|places
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_BROUND
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for bround"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Take the integer part of an arbitrary value.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|intvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|qisint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
else|else
name|vres
operator|->
name|v_num
operator|=
name|qint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
if|if
condition|(
name|cisint
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_com
operator|=
name|clink
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
block|}
name|vres
operator|->
name|v_com
operator|=
name|cint
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matint
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_INT
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for int"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Take the fractional part of an arbitrary value.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|fracvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|qisint
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
condition|)
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
else|else
name|vres
operator|->
name|v_num
operator|=
name|qfrac
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
if|if
condition|(
name|cisint
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|clink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|vres
operator|->
name|v_com
operator|=
name|cfrac
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matfrac
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_FRAC
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for frac function"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Increment an arbitrary value by one.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|incvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qinc
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|caddq
argument_list|(
name|vp
operator|->
name|v_com
argument_list|,
operator|&
name|_qone_
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_INC
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for incrementing"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Decrement an arbitrary value by one.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|decvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qdec
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|caddq
argument_list|(
name|vp
operator|->
name|v_com
argument_list|,
operator|&
name|_qnegone_
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_DEC
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for decrementing"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Produce the 'conjugate' of an arbitrary value.  * Result is placed in the indicated location.  * (Example: complex conjugate.)  */
end_comment

begin_function
name|void
name|conjvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|vres
operator|->
name|v_com
operator|->
name|real
operator|=
name|qlink
argument_list|(
name|vp
operator|->
name|v_com
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_com
operator|->
name|imag
operator|=
name|qneg
argument_list|(
name|vp
operator|->
name|v_com
operator|->
name|imag
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matconj
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_CONJ
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for conjugation"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Take the square root of an arbitrary value within the specified error.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|sqrtvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon for sqrt"
argument_list|)
expr_stmt|;
name|q
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Illegal epsilon value for sqrt"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qsqrt
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
name|qneg
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|c
operator|=
name|comalloc
argument_list|()
expr_stmt|;
name|c
operator|->
name|imag
operator|=
name|qsqrt
argument_list|(
name|tmp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_com
operator|=
name|c
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|csqrt
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_SQRT
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Bad value for taking square root"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Take the Nth root of an arbitrary value within the specified error.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|rootvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|;
comment|/* value to take root of */
name|VALUE
modifier|*
name|v2
decl_stmt|;
comment|/* value specifying root to take */
name|VALUE
modifier|*
name|v3
decl_stmt|;
comment|/* value specifying error */
name|VALUE
modifier|*
name|vres
decl_stmt|;
block|{
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
name|COMPLEX
name|ctmp
decl_stmt|;
if|if
condition|(
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
operator|||
operator|(
name|v3
operator|->
name|v_type
operator|!=
name|V_NUM
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-real arguments for root"
argument_list|)
expr_stmt|;
name|q1
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
name|q2
operator|=
name|v3
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q1
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q1
argument_list|)
operator|||
name|qisfrac
argument_list|(
name|q1
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive or non-integral root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|q2
argument_list|)
operator|||
name|qiszero
argument_list|(
name|q2
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive epsilon for root"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
operator|!
name|qisneg
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
operator|||
name|zisodd
argument_list|(
name|q1
operator|->
name|num
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qroot
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|ctmp
operator|.
name|real
operator|=
name|v1
operator|->
name|v_num
expr_stmt|;
name|ctmp
operator|.
name|imag
operator|=
operator|&
name|_qzero_
expr_stmt|;
name|ctmp
operator|.
name|links
operator|=
literal|1
expr_stmt|;
name|vres
operator|->
name|v_com
operator|=
name|croot
argument_list|(
operator|&
name|ctmp
argument_list|,
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|croot
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_ROOT
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|v3
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Taking root of bad value"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take the absolute value of an arbitrary value within the specified error.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|absvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Bad epsilon type for abs"
argument_list|)
expr_stmt|;
name|epsilon
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qiszero
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qisneg
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive epsilon for abs"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
if|if
condition|(
name|qisneg
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
condition|)
name|q
operator|=
name|qneg
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|qlink
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|q
operator|=
name|qhypot
argument_list|(
name|v1
operator|->
name|v_com
operator|->
name|real
argument_list|,
name|v1
operator|->
name|v_com
operator|->
name|imag
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_ABS
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for absolute value"
argument_list|)
expr_stmt|;
block|}
name|vres
operator|->
name|v_num
operator|=
name|q
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Calculate the norm of an arbitrary value.  * Result is placed in the indicated location.  * The norm is the square of the absolute value.  */
end_comment

begin_function
name|void
name|normvalue
parameter_list|(
name|vp
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|,
decl|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|q1
decl_stmt|,
modifier|*
name|q2
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qsquare
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|q1
operator|=
name|qsquare
argument_list|(
name|vp
operator|->
name|v_com
operator|->
name|real
argument_list|)
expr_stmt|;
name|q2
operator|=
name|qsquare
argument_list|(
name|vp
operator|->
name|v_com
operator|->
name|imag
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_num
operator|=
name|qadd
argument_list|(
name|q1
argument_list|,
name|q2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|qfree
argument_list|(
name|q1
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|q2
argument_list|)
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_NORM
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for norm"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Shift a value left or right by the specified number of bits.  * Negative shift value means shift the direction opposite the selected dir.  * Right shifts are defined to lose bits off the low end of the number.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|shiftvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|rightshift
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_decl_stmt
name|BOOL
name|rightshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if shift right instead of left */
end_comment

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|long
name|n
init|=
literal|0
decl_stmt|;
name|VALUE
name|tmp
decl_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real shift value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral shift value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
condition|)
block|{
if|if
condition|(
name|zisbig
argument_list|(
name|v2
operator|->
name|v_num
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Very large shift value"
argument_list|)
expr_stmt|;
name|n
operator|=
name|qtoi
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rightshift
condition|)
name|n
operator|=
operator|-
name|n
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qshift
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|c
operator|=
name|cshift
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_com
operator|=
name|c
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
block|}
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matshift
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
if|if
condition|(
operator|!
name|rightshift
condition|)
block|{
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_SHIFT
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|.
name|v_num
operator|=
name|qneg
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|v_type
operator|=
name|V_NUM
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_SHIFT
argument_list|,
name|v1
argument_list|,
operator|&
name|tmp
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|tmp
operator|.
name|v_num
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Bad value for shifting"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Scale a value by a power of two.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|scalevalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|long
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real scaling factor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-integral scaling factor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
condition|)
block|{
if|if
condition|(
name|zisbig
argument_list|(
name|v2
operator|->
name|v_num
operator|->
name|num
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Very large scaling factor"
argument_list|)
expr_stmt|;
name|n
operator|=
name|qtoi
argument_list|(
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qscale
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|cscale
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matscale
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_SCALE
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Bad value for scaling"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Raise a value to an integral power.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|powivalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|q
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|v2
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Raising value to non-real power"
argument_list|)
expr_stmt|;
name|q
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisfrac
argument_list|(
name|q
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Raising value to non-integral power"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|vres
operator|->
name|v_num
operator|=
name|qpowi
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|V_COM
case|:
name|vres
operator|->
name|v_com
operator|=
name|cpowi
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
name|V_MAT
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matpowi
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
case|case
name|V_OBJ
case|:
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_POW
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for raising to integer power"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Raise one value to another value's power, within the specified error.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|powervalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|v3
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|v3
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|NUMBER
modifier|*
name|epsilon
decl_stmt|;
name|COMPLEX
modifier|*
name|c
decl_stmt|,
name|ctmp
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
if|if
condition|(
name|v3
operator|->
name|v_type
operator|!=
name|V_NUM
condition|)
name|math_error
argument_list|(
literal|"Non-real epsilon value for power"
argument_list|)
expr_stmt|;
name|epsilon
operator|=
name|v3
operator|->
name|v_num
expr_stmt|;
if|if
condition|(
name|qisneg
argument_list|(
name|epsilon
argument_list|)
operator|||
name|qiszero
argument_list|(
name|epsilon
argument_list|)
condition|)
name|math_error
argument_list|(
literal|"Non-positive epsilon value for power"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qpower
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_COM
argument_list|)
case|:
name|ctmp
operator|.
name|real
operator|=
name|v1
operator|->
name|v_num
expr_stmt|;
name|ctmp
operator|.
name|imag
operator|=
operator|&
name|_qzero_
expr_stmt|;
name|ctmp
operator|.
name|links
operator|=
literal|1
expr_stmt|;
name|vres
operator|->
name|v_com
operator|=
name|cpower
argument_list|(
operator|&
name|ctmp
argument_list|,
name|v2
operator|->
name|v_com
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|ctmp
operator|.
name|real
operator|=
name|v2
operator|->
name|v_num
expr_stmt|;
name|ctmp
operator|.
name|imag
operator|=
operator|&
name|_qzero_
expr_stmt|;
name|ctmp
operator|.
name|links
operator|=
literal|1
expr_stmt|;
name|vres
operator|->
name|v_com
operator|=
name|cpower
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
operator|&
name|ctmp
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cpower
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_com
argument_list|,
name|epsilon
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for raising to power"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here for any complex result. 	 */
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
operator|!
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
return|return;
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Divide one arbitrary value by another one.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|divvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|COMPLEX
name|ctmp
decl_stmt|;
name|VALUE
name|tmpval
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qdiv
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cdivq
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_COM
argument_list|)
case|:
if|if
condition|(
name|qiszero
argument_list|(
name|v1
operator|->
name|v_num
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
operator|&
name|_qzero_
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
block|}
name|ctmp
operator|.
name|real
operator|=
name|v1
operator|->
name|v_num
expr_stmt|;
name|ctmp
operator|.
name|imag
operator|=
operator|&
name|_qzero_
expr_stmt|;
name|ctmp
operator|.
name|links
operator|=
literal|1
expr_stmt|;
name|vres
operator|->
name|v_com
operator|=
name|cdiv
argument_list|(
operator|&
name|ctmp
argument_list|,
name|v2
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cdiv
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_com
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_NUM
argument_list|)
case|:
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_COM
argument_list|)
case|:
name|invertvalue
argument_list|(
name|v2
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_mat
operator|=
name|matmulval
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
operator|&
name|tmpval
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
name|freevalue
argument_list|(
operator|&
name|tmpval
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|&&
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-compatible values for divide"
argument_list|)
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_DIV
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Divide one arbitrary value by another one keeping only the integer part.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|quovalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qquo
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cquoq
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_NUM
argument_list|)
case|:
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matquoval
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|&&
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-compatible values for quotient"
argument_list|)
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_QUO
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Divide one arbitrary value by another one keeping only the remainder.  * Result is placed in the indicated location.  */
end_comment

begin_function
name|void
name|modvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|,
name|vres
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|,
modifier|*
name|vres
decl_stmt|;
end_function

begin_block
block|{
name|COMPLEX
modifier|*
name|c
decl_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NULL
expr_stmt|;
switch|switch
condition|(
name|TWOVAL
argument_list|(
name|v1
operator|->
name|v_type
argument_list|,
name|v2
operator|->
name|v_type
argument_list|)
condition|)
block|{
case|case
name|TWOVAL
argument_list|(
name|V_NUM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_num
operator|=
name|qmod
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_COM
argument_list|,
name|V_NUM
argument_list|)
case|:
name|vres
operator|->
name|v_com
operator|=
name|cmodq
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_COM
expr_stmt|;
name|c
operator|=
name|vres
operator|->
name|v_com
expr_stmt|;
if|if
condition|(
name|cisreal
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|vres
operator|->
name|v_num
operator|=
name|qlink
argument_list|(
name|c
operator|->
name|real
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_NUM
expr_stmt|;
name|comfree
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_NUM
argument_list|)
case|:
case|case
name|TWOVAL
argument_list|(
name|V_MAT
argument_list|,
name|V_COM
argument_list|)
case|:
name|vres
operator|->
name|v_mat
operator|=
name|matmodval
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
argument_list|)
expr_stmt|;
name|vres
operator|->
name|v_type
operator|=
name|V_MAT
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
operator|&&
operator|(
name|v2
operator|->
name|v_type
operator|!=
name|V_OBJ
operator|)
condition|)
name|math_error
argument_list|(
literal|"Non-compatible values for mod"
argument_list|)
expr_stmt|;
operator|*
name|vres
operator|=
name|objcall
argument_list|(
name|OBJ_MOD
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_comment
comment|/*  * Test an arbitrary value to see if it is equal to "zero".  * The definition of zero varies depending on the value type.  For example,  * the null string is "zero", and a matrix with zero values is "zero".  * Returns TRUE if value is not equal to zero.  */
end_comment

begin_function
name|BOOL
name|testvalue
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
name|VALUE
name|val
decl_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
return|return
operator|!
name|qiszero
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
return|;
case|case
name|V_COM
case|:
return|return
operator|!
name|ciszero
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
return|;
case|case
name|V_STR
case|:
return|return
operator|(
name|vp
operator|->
name|v_str
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
return|;
case|case
name|V_MAT
case|:
return|return
name|mattest
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
return|;
case|case
name|V_LIST
case|:
return|return
operator|(
name|vp
operator|->
name|v_list
operator|->
name|l_count
operator|!=
literal|0
operator|)
return|;
case|case
name|V_ASSOC
case|:
return|return
operator|(
name|vp
operator|->
name|v_assoc
operator|->
name|a_count
operator|!=
literal|0
operator|)
return|;
case|case
name|V_FILE
case|:
return|return
name|validid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|)
return|;
case|case
name|V_NULL
case|:
return|return
name|FALSE
return|;
case|case
name|V_OBJ
case|:
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_TEST
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|.
name|v_int
operator|!=
literal|0
operator|)
return|;
default|default:
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare two values for equality.  * Returns TRUE if the two values differ.  */
end_comment

begin_function
name|BOOL
name|comparevalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|r
init|=
name|FALSE
decl_stmt|;
name|VALUE
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|==
name|V_OBJ
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|==
name|V_OBJ
operator|)
condition|)
block|{
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_CMP
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|.
name|v_int
operator|!=
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|v2
operator|->
name|v_type
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|r
operator|=
name|qcmp
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|r
operator|=
name|ccmp
argument_list|(
name|v1
operator|->
name|v_com
argument_list|,
name|v2
operator|->
name|v_com
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_STR
case|:
name|r
operator|=
operator|(
operator|(
name|v1
operator|->
name|v_str
operator|!=
name|v2
operator|->
name|v_str
operator|)
operator|&&
operator|(
operator|(
name|v1
operator|->
name|v_str
index|[
literal|0
index|]
operator|-
name|v2
operator|->
name|v_str
index|[
literal|0
index|]
operator|)
operator|||
name|strcmp
argument_list|(
name|v1
operator|->
name|v_str
argument_list|,
name|v2
operator|->
name|v_str
argument_list|)
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|V_MAT
case|:
name|r
operator|=
name|matcmp
argument_list|(
name|v1
operator|->
name|v_mat
argument_list|,
name|v2
operator|->
name|v_mat
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|r
operator|=
name|listcmp
argument_list|(
name|v1
operator|->
name|v_list
argument_list|,
name|v2
operator|->
name|v_list
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|r
operator|=
name|assoccmp
argument_list|(
name|v1
operator|->
name|v_assoc
argument_list|,
name|v2
operator|->
name|v_assoc
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_NULL
case|:
break|break;
case|case
name|V_FILE
case|:
name|r
operator|=
operator|(
name|v1
operator|->
name|v_file
operator|!=
name|v2
operator|->
name|v_file
operator|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Illegal values for comparevalue"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compare two values for their relative values.  * Returns minus one if the first value is less than the second one,  * one if the first value is greater than the second one, and  * zero if they are equal.  */
end_comment

begin_function
name|FLAG
name|relvalue
parameter_list|(
name|v1
parameter_list|,
name|v2
parameter_list|)
name|VALUE
modifier|*
name|v1
decl_stmt|,
decl|*
name|v2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|VALUE
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|v1
operator|->
name|v_type
operator|==
name|V_OBJ
operator|)
operator|||
operator|(
name|v2
operator|->
name|v_type
operator|==
name|V_OBJ
operator|)
condition|)
block|{
name|val
operator|=
name|objcall
argument_list|(
name|OBJ_REL
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
return|return
name|val
operator|.
name|v_int
return|;
block|}
if|if
condition|(
name|v1
operator|==
name|v2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|v1
operator|->
name|v_type
operator|!=
name|v2
operator|->
name|v_type
condition|)
name|math_error
argument_list|(
literal|"Relative comparison of differing types"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|v1
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|r
operator|=
name|qrel
argument_list|(
name|v1
operator|->
name|v_num
argument_list|,
name|v2
operator|->
name|v_num
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_STR
case|:
name|r
operator|=
name|strcmp
argument_list|(
name|v1
operator|->
name|v_str
argument_list|,
name|v2
operator|->
name|v_str
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_NULL
case|:
break|break;
default|default:
name|math_error
argument_list|(
literal|"Illegal value for relative comparison"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|r
operator|!=
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Calculate a hash value for a value.  * The hash does not have to be a perfect one, it is only used for  * making associations faster.  */
end_comment

begin_function
name|HASH
name|hashvalue
parameter_list|(
name|vp
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_INT
case|:
return|return
operator|(
operator|(
name|long
operator|)
name|vp
operator|->
name|v_int
operator|)
return|;
case|case
name|V_NUM
case|:
return|return
name|qhash
argument_list|(
name|vp
operator|->
name|v_num
argument_list|)
return|;
case|case
name|V_COM
case|:
return|return
name|chash
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
return|;
case|case
name|V_STR
case|:
return|return
name|hashstr
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
return|;
case|case
name|V_NULL
case|:
return|return
literal|0
return|;
case|case
name|V_OBJ
case|:
return|return
name|objhash
argument_list|(
name|vp
operator|->
name|v_obj
argument_list|)
return|;
case|case
name|V_LIST
case|:
return|return
name|listhash
argument_list|(
name|vp
operator|->
name|v_list
argument_list|)
return|;
case|case
name|V_ASSOC
case|:
return|return
name|assochash
argument_list|(
name|vp
operator|->
name|v_assoc
argument_list|)
return|;
case|case
name|V_MAT
case|:
return|return
name|mathash
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|)
return|;
case|case
name|V_FILE
case|:
return|return
operator|(
operator|(
name|long
operator|)
name|vp
operator|->
name|v_file
operator|)
return|;
default|default:
name|math_error
argument_list|(
literal|"Hashing unknown value"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Print the value of a descriptor in one of several formats.  * If flags contains PRINT_SHORT, then elements of arrays and lists  * will not be printed.  If flags contains PRINT_UNAMBIG, then quotes  * are placed around strings and the null value is explicitly printed.  */
end_comment

begin_function
name|void
name|printvalue
parameter_list|(
name|vp
parameter_list|,
name|flags
parameter_list|)
name|VALUE
modifier|*
name|vp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|V_NUM
case|:
name|qprintnum
argument_list|(
name|vp
operator|->
name|v_num
argument_list|,
name|MODE_DEFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_COM
case|:
name|comprint
argument_list|(
name|vp
operator|->
name|v_com
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_STR
case|:
if|if
condition|(
name|flags
operator|&
name|PRINT_UNAMBIG
condition|)
name|math_chr
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
name|math_str
argument_list|(
name|vp
operator|->
name|v_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRINT_UNAMBIG
condition|)
name|math_chr
argument_list|(
literal|'\"'
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_NULL
case|:
if|if
condition|(
name|flags
operator|&
name|PRINT_UNAMBIG
condition|)
name|math_str
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_OBJ
case|:
operator|(
name|void
operator|)
name|objcall
argument_list|(
name|OBJ_PRINT
argument_list|,
name|vp
argument_list|,
name|NULL_VALUE
argument_list|,
name|NULL_VALUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_LIST
case|:
name|listprint
argument_list|(
name|vp
operator|->
name|v_list
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|PRINT_SHORT
operator|)
condition|?
literal|0L
else|:
name|maxprint
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_ASSOC
case|:
name|assocprint
argument_list|(
name|vp
operator|->
name|v_assoc
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|PRINT_SHORT
operator|)
condition|?
literal|0L
else|:
name|maxprint
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_MAT
case|:
name|matprint
argument_list|(
name|vp
operator|->
name|v_mat
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|PRINT_SHORT
operator|)
condition|?
literal|0L
else|:
name|maxprint
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_FILE
case|:
name|printid
argument_list|(
name|vp
operator|->
name|v_file
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|math_error
argument_list|(
literal|"Printing unknown value"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* END CODE */
end_comment

end_unit

