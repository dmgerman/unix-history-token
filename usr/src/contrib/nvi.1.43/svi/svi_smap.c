begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)svi_smap.c	9.2 (Berkeley) 11/10/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"../vi/vcmd.h"
end_include

begin_include
include|#
directive|include
file|"svi_screen.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|svi_deleteln
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_insertln
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_delete
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_down
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|MARK
operator|*
operator|,
name|recno_t
operator|,
expr|enum
name|sctype
operator|,
name|SMAP
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_erase
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_insert
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_reset
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|recno_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svi_sm_up
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|MARK
operator|*
operator|,
name|recno_t
operator|,
expr|enum
name|sctype
operator|,
name|SMAP
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * svi_change --  *	Make a change to the screen.  */
end_comment

begin_function
name|int
name|svi_change
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|op
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|enum
name|operation
name|op
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|;
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
comment|/* Appending is the same as inserting, if the line is incremented. */
if|if
condition|(
name|op
operator|==
name|LINE_APPEND
condition|)
block|{
operator|++
name|lno
expr_stmt|;
name|op
operator|=
name|LINE_INSERT
expr_stmt|;
block|}
comment|/* Ignore the change if the line is after the map. */
if|if
condition|(
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the line is before the map, and it's a decrement, decrement 	 * the map.  If it's an increment, increment the map.  Otherwise, 	 * ignore it. 	 */
if|if
condition|(
name|lno
operator|<
name|HMAP
operator|->
name|lno
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_APPEND
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|LINE_DELETE
case|:
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|--
name|sp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_SCR_NUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
operator|++
name|p
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|>=
name|lno
condition|)
operator|++
name|sp
operator|->
name|lno
expr_stmt|;
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_SCR_NUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_SCR_DIRTY
argument_list|)
expr_stmt|;
comment|/* Invalidate the cursor, if it's on this line. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
name|lno
condition|)
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* Invalidate the line size cache. */
name|SVI_SCR_CFLUSH
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|LINE_DELETE
case|:
if|if
condition|(
name|svi_sm_delete
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_SCR_NUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_INSERT
case|:
if|if
condition|(
name|svi_sm_insert
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_SCR_NUMBER
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_RESET
case|:
if|if
condition|(
name|svi_sm_reset
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_fill --  *	Fill in the screen map, placing the specified line at the  *	right position.  There isn't any way to tell if an SMAP  *	entry has been filled in, so this routine had better be  *	called with P_FILL set before anything else is done.  *  * !!!  * Unexported interface: if lno is OOBLNO, P_TOP means that the HMAP  * slot is already filled in, P_BOTTOM means that the TMAP slot is  * already filled in, and we just finish up the job.  */
end_comment

begin_function
name|int
name|svi_sm_fill
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
name|enum
name|position
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Flush all cached information from the SMAP. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
name|SMAP_FLUSH
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If the map is filled, the screen must be redrawn. 	 * 	 * XXX 	 * This is a bug.  We should try and figure out if the desired line 	 * is already in the map or close by -- scrolling the screen would 	 * be a lot better than redrawing. 	 */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SCR_REDRAW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_FILL
case|:
name|tmp
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|off
operator|=
literal|1
expr_stmt|;
comment|/* See if less than half a screen from the top. */
if|if
condition|(
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* See if less than half a screen from the bottom. */
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
name|tmp
operator|.
name|off
operator|=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|tmp
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_nlines
argument_list|(
name|sp
argument_list|,
operator|&
name|tmp
argument_list|,
name|lno
argument_list|,
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|<=
name|HALFTEXT
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|tmp
operator|.
name|lno
expr_stmt|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
name|TMAP
operator|->
name|off
operator|=
name|tmp
operator|.
name|off
expr_stmt|;
goto|goto
name|bottom
goto|;
block|}
goto|goto
name|middle
goto|;
case|case
name|P_TOP
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
name|top
label|:
name|HMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|HMAP
operator|->
name|off
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we fail, just punt. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* If we fail, guess that the file is too small. */
name|middle
label|:
name|p
operator|=
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|p
operator|->
name|lno
operator|=
name|lno
operator|,
name|p
operator|->
name|off
operator|=
literal|1
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
comment|/* If we fail, just punt. */
name|p
operator|=
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
break|break;
case|case
name|P_BOTTOM
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
block|{
name|TMAP
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
name|TMAP
operator|->
name|off
operator|=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If we fail, guess that the file is too small. */
name|bottom
label|:
for|for
control|(
name|p
operator|=
name|TMAP
init|;
name|p
operator|>
name|HMAP
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lno
operator|=
literal|1
expr_stmt|;
goto|goto
name|top
goto|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Try and put *something* on the screen.  If this fails, 	 * we have a serious hard error. 	 */
name|err
label|:
name|HMAP
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|HMAP
operator|->
name|off
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|<
name|TMAP
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the routines svi_sm_reset, svi_sm_delete and svi_sm_insert: if the  * screen only contains one line, or, if the line is the entire screen, this  * gets fairly exciting.  Skip the fun and simply return if there's only one  * line in the screen, or just call fill.  Fill may not be entirely accurate,  * i.e. we may be painting the screen with something not even close to the  * cursor, but it's not like we're into serious performance issues here, and  * the refresh routine will fix it for us.  */
end_comment

begin_define
define|#
directive|define
name|TOO_WEIRD
value|{							\ 	if (cnt_orig>= sp->t_rows) {					\ 		if (cnt_orig == 1)					\ 			return (0);					\ 		if (file_gline(sp, lno, NULL) == NULL)			\ 			if (file_lline(sp,&lno))			\ 				return (1);				\ 		F_SET(sp, S_SCR_REDRAW);				\ 		return (svi_sm_fill(sp, lno, P_TOP));			\ 	}								\ }
end_define

begin_comment
comment|/*  * svi_sm_delete --  *	Delete a line out of the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_delete
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|;
comment|/* 	 * Find the line in the map, and count the number of screen lines 	 * which display any part of the deleted line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
name|cnt_orig
operator|=
literal|1
expr_stmt|;
else|else
for|for
control|(
name|cnt_orig
operator|=
literal|1
operator|,
name|t
operator|=
name|p
operator|+
literal|1
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|TOO_WEIRD
expr_stmt|;
comment|/* Delete that many lines from the screen. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|cnt_orig
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
name|p
operator|<=
name|t
condition|;
operator|++
name|p
control|)
operator|--
name|p
operator|->
name|lno
expr_stmt|;
comment|/* Display the new lines. */
for|for
control|(
name|p
operator|=
name|TMAP
operator|-
name|cnt_orig
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|<
name|TMAP
operator|&&
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
operator|++
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|TMAP
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_insert --  *	Insert a line into the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_insert
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* 	 * Find the line in the map, find out how many screen lines 	 * needed to display the line. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
name|cnt_orig
operator|=
literal|1
expr_stmt|;
else|else
name|cnt_orig
operator|=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TOO_WEIRD
expr_stmt|;
comment|/* 	 * The lines left in the screen override the number of screen 	 * lines in the inserted line. 	 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|>
name|cnt
condition|)
name|cnt_orig
operator|=
name|cnt
expr_stmt|;
comment|/* Push down that many lines. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
name|cnt_orig
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|cnt_orig
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|cnt_orig
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Increment the line numbers for the rest of the map. */
for|for
control|(
name|t
operator|=
name|p
operator|+
name|cnt_orig
init|;
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
control|)
operator|++
name|t
operator|->
name|lno
expr_stmt|;
comment|/* Fill in the SMAP for the new lines, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt
operator|<=
name|cnt_orig
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_reset --  *	Reset a line in the SMAP.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_reset
parameter_list|(
name|sp
parameter_list|,
name|lno
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|recno_t
name|lno
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|size_t
name|cnt_orig
decl_stmt|,
name|cnt_new
decl_stmt|,
name|cnt
decl_stmt|,
name|diff
decl_stmt|;
comment|/* 	 * See if the number of on-screen rows taken up by the old display 	 * for the line is the same as the number needed for the new one. 	 * If so, repaint, otherwise do it the hard way. 	 */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|=
name|p
expr_stmt|;
name|cnt_orig
operator|=
name|cnt_new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|cnt_orig
operator|=
literal|0
operator|,
name|t
operator|=
name|p
init|;
name|t
operator|<=
name|TMAP
operator|&&
name|t
operator|->
name|lno
operator|==
name|lno
condition|;
operator|++
name|cnt_orig
operator|,
operator|++
name|t
control|)
empty_stmt|;
name|cnt_new
operator|=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|TOO_WEIRD
expr_stmt|;
if|if
condition|(
name|cnt_orig
operator|==
name|cnt_new
condition|)
block|{
do|do
block|{
name|SMAP_FLUSH
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|++
name|p
operator|<
name|t
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cnt_orig
operator|<
name|cnt_new
condition|)
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_new
operator|-
name|cnt_orig
expr_stmt|;
comment|/* 		 * The lines left in the screen override the number of screen 		 * lines in the inserted line. 		 */
name|cnt
operator|=
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|>
name|cnt
condition|)
name|diff
operator|=
name|cnt
expr_stmt|;
comment|/* Push down the extra lines. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map down. */
name|memmove
argument_list|(
name|p
operator|+
name|diff
argument_list|,
name|p
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
operator|&&
name|t
operator|<=
name|TMAP
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Get the difference. */
name|diff
operator|=
name|cnt_orig
operator|-
name|cnt_new
expr_stmt|;
comment|/* Delete that many lines from the screen. */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|p
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
name|diff
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Shift the screen map up. */
name|memmove
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|diff
argument_list|,
operator|(
operator|(
operator|(
name|TMAP
operator|-
name|p
operator|)
operator|-
name|diff
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the SMAP for the replaced line, and display. */
for|for
control|(
name|cnt
operator|=
literal|1
operator|,
name|t
operator|=
name|p
init|;
name|cnt_new
operator|--
condition|;
operator|++
name|t
operator|,
operator|++
name|cnt
control|)
block|{
name|t
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|cnt
expr_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Display the new lines at the bottom of the screen. */
for|for
control|(
name|t
operator|=
name|TMAP
operator|-
name|diff
init|;
condition|;
control|)
block|{
if|if
condition|(
name|t
operator|<
name|TMAP
operator|&&
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|t
argument_list|,
name|t
operator|+
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
operator|++
name|t
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|t
operator|==
name|TMAP
condition|)
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_scroll  *	Scroll the SMAP up/down count logical lines.  Different  *	semantics based on the vi command, *sigh*.  */
end_comment

begin_function
name|int
name|svi_sm_scroll
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|scmd
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|enum
name|sctype
name|scmd
decl_stmt|;
block|{
name|SMAP
modifier|*
name|smp
decl_stmt|;
comment|/* 	 * Invalidate the cursor.  The line is probably going to change, 	 * (although for ^E and ^Y it may not).  In any case, the scroll 	 * routines move the cursor to draw things. 	 */
name|F_SET
argument_list|(
name|SVP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|SVI_CUR_INVALID
argument_list|)
expr_stmt|;
comment|/* Find the cursor in the screen. */
if|if
condition|(
name|svi_sm_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|smp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_B
case|:
case|case
name|CNTRL_U
case|:
case|case
name|CNTRL_Y
case|:
case|case
name|Z_CARAT
case|:
if|if
condition|(
name|svi_sm_down
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
name|count
argument_list|,
name|scmd
argument_list|,
name|smp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|CNTRL_D
case|:
case|case
name|CNTRL_E
case|:
case|case
name|CNTRL_F
case|:
case|case
name|Z_PLUS
case|:
if|if
condition|(
name|svi_sm_up
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
name|count
argument_list|,
name|scmd
argument_list|,
name|smp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * If we're at the start of a line, go for the first non-blank. 	 * This makes it look like the old vi, even though we're moving 	 * around by logical lines, not physical ones. 	 * 	 * XXX 	 * In the presence of a long line, which has more than a screen 	 * width of leading spaces, this code can cause a cursor warp. 	 * Live with it. 	 */
if|if
condition|(
name|scmd
operator|!=
name|CNTRL_E
operator|&&
name|scmd
operator|!=
name|CNTRL_Y
operator|&&
name|rp
operator|->
name|cno
operator|==
literal|0
operator|&&
name|nonblank
argument_list|(
name|sp
argument_list|,
name|rp
operator|->
name|lno
argument_list|,
operator|&
name|rp
operator|->
name|cno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_up --  *	Scroll the SMAP up count logical lines.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_up
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|scmd
parameter_list|,
name|smp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|enum
name|sctype
name|scmd
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|;
block|{
name|int
name|cursor_set
decl_stmt|,
name|echanged
decl_stmt|,
name|zset
decl_stmt|;
name|SMAP
modifier|*
name|ssmp
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* 	 * Check to see if movement is possible. 	 * 	 * Get the line after the map.  If that line is a new one (and if 	 * O_LEFTRIGHT option is set, this has to be true), and the next 	 * line doesn't exist, and the cursor doesn't move, or the cursor 	 * isn't even on the screen, or the cursor is already at the last 	 * line in the map, it's an error.  If that test succeeded because 	 * the cursor wasn't at the end of the map, test to see if the map 	 * is mostly empty. 	 */
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|.
name|lno
operator|>
name|TMAP
operator|->
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|scmd
operator|==
name|CNTRL_E
operator|||
name|scmd
operator|==
name|Z_PLUS
operator|||
name|smp
operator|==
name|TMAP
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|.
name|lno
operator|>
name|smp
operator|->
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|v_eof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Small screens: see svi/svi_refresh.c:svi_refresh, section 2b. 	 * 	 * If it's a small screen, and the movement isn't larger than a 	 * screen, i.e some context will remain, open up the screen and 	 * display by scrolling.  In this case, the cursor moves down one 	 * line for each line displayed.  Otherwise, erase/compress and 	 * repaint, and move the cursor to the first line in the screen. 	 * Note, the ^F command is always in the latter case, for historical 	 * reasons. 	 */
name|cursor_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ISSMALLSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|sp
operator|->
name|t_maxrows
operator|||
name|scmd
operator|==
name|CNTRL_F
condition|)
block|{
name|s1
operator|=
name|TMAP
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|svi_sm_erase
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|count
operator|--
condition|;
name|s1
operator|=
name|s2
control|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
operator|&
name|s1
argument_list|,
operator|&
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s2
operator|.
name|lno
operator|!=
name|s1
operator|.
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|s2
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
block|}
name|TMAP
index|[
literal|0
index|]
operator|=
name|s2
expr_stmt|;
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_BOTTOM
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|svi_sm_position
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|,
name|P_TOP
argument_list|)
operator|)
return|;
block|}
name|cursor_set
operator|=
name|scmd
operator|==
name|CNTRL_E
operator|||
name|svi_sm_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|ssmp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|count
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|!=
name|s1
operator|.
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
operator|*
operator|++
name|TMAP
operator|=
name|s1
expr_stmt|;
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|cursor_set
condition|)
operator|++
name|ssmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cursor_set
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|ssmp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|ssmp
operator|->
name|c_sboff
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|echanged
operator|=
name|zset
operator|=
literal|0
init|;
name|count
condition|;
operator|--
name|count
control|)
block|{
comment|/* Decide what would show up on the screen. */
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
operator|&
name|s1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|TMAP
operator|->
name|lno
operator|!=
name|s1
operator|.
name|lno
operator|&&
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|s1
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
comment|/* Scroll the screen cursor up one logical line. */
if|if
condition|(
name|svi_sm_1up
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_E
case|:
if|if
condition|(
name|smp
operator|>
name|HMAP
condition|)
operator|--
name|smp
expr_stmt|;
else|else
name|echanged
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_PLUS
case|:
if|if
condition|(
name|zset
condition|)
block|{
if|if
condition|(
name|smp
operator|>
name|HMAP
condition|)
operator|--
name|smp
expr_stmt|;
block|}
else|else
block|{
name|smp
operator|=
name|TMAP
expr_stmt|;
name|zset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|cursor_set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_E
case|:
comment|/* 		 * On a ^E that was forced to change lines, try and keep the 		 * cursor as close as possible to the last position, but also 		 * set it up so that the next "real" movement will return the 		 * cursor to the closest position to the last real movement. 		 */
if|if
condition|(
name|echanged
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|svi_cm_private
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
name|smp
operator|->
name|off
argument_list|,
name|sp
operator|->
name|rcm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CNTRL_F
case|:
comment|/* 		 * If there are more lines, the ^F command is positioned at 		 * the first line of the screen. 		 */
if|if
condition|(
operator|!
name|count
condition|)
block|{
name|smp
operator|=
name|HMAP
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|CNTRL_D
case|:
comment|/* 		 * The ^D and ^F commands move the cursor towards EOF 		 * if there are more lines to move.  Check to be sure 		 * the lines actually exist.  (They may not if the 		 * file is smaller than the screen.) 		 */
for|for
control|(
init|;
name|count
condition|;
operator|--
name|count
operator|,
operator|++
name|smp
control|)
if|if
condition|(
name|smp
operator|==
name|TMAP
operator|||
operator|!
name|file_gline
argument_list|(
name|sp
argument_list|,
name|smp
index|[
literal|1
index|]
operator|.
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
break|break;
case|case
name|Z_PLUS
case|:
comment|/* The z+ command moves the cursor to the first new line. */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|svi_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_1up --  *	Scroll the SMAP up one.  */
end_comment

begin_function
name|int
name|svi_sm_1up
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* 	 * Delete the top line of the screen.  Shift the screen map up. 	 * Display a new line at the bottom of the screen. 	 */
name|MOVE
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_deleteln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* One-line screens can fail. */
if|if
condition|(
name|HMAP
operator|==
name|TMAP
condition|)
block|{
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|HMAP
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
operator|(
name|sp
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_next
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
literal|1
argument_list|,
name|TMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* svi_sm_next() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|TMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_deleteln --  *	Delete a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
specifier|static
name|int
name|svi_deleteln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|deleteln
argument_list|()
expr_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insertln
argument_list|()
expr_stmt|;
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_down --  *	Scroll the SMAP down count logical lines.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_down
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|count
parameter_list|,
name|scmd
parameter_list|,
name|smp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|recno_t
name|count
decl_stmt|;
name|SMAP
modifier|*
name|smp
decl_stmt|;
name|enum
name|sctype
name|scmd
decl_stmt|;
block|{
name|SMAP
modifier|*
name|ssmp
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|int
name|cursor_set
decl_stmt|,
name|ychanged
decl_stmt|,
name|zset
decl_stmt|;
comment|/* Check to see if movement is possible. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
name|HMAP
operator|->
name|off
operator|==
literal|1
operator|&&
operator|(
name|scmd
operator|==
name|CNTRL_Y
operator|||
name|scmd
operator|==
name|Z_CARAT
operator|||
name|smp
operator|==
name|HMAP
operator|)
condition|)
block|{
name|v_sof
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Small screens: see svi/svi_refresh.c:svi_refresh, section 2b. 	 * 	 * If it's a small screen, and the movement isn't larger than a 	 * screen, i.e some context will remain, open up the screen and 	 * display by scrolling.  In this case, the cursor moves up one 	 * line for each line displayed.  Otherwise, erase/compress and 	 * repaint, and move the cursor to the first line in the screen. 	 * Note, the ^B command is always in the latter case, for historical 	 * reasons. 	 */
name|cursor_set
operator|=
name|scmd
operator|==
name|CNTRL_Y
expr_stmt|;
if|if
condition|(
name|ISSMALLSCREEN
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
name|count
operator|>=
name|sp
operator|->
name|t_maxrows
operator|||
name|scmd
operator|==
name|CNTRL_B
condition|)
block|{
name|s1
operator|=
name|HMAP
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|svi_sm_erase
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|count
operator|--
condition|;
name|s1
operator|=
name|s2
control|)
block|{
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
operator|&
name|s1
argument_list|,
operator|&
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s2
operator|.
name|lno
operator|==
literal|1
operator|&&
name|s2
operator|.
name|off
operator|==
literal|1
condition|)
break|break;
block|}
name|HMAP
index|[
literal|0
index|]
operator|=
name|s2
expr_stmt|;
if|if
condition|(
name|svi_sm_fill
argument_list|(
name|sp
argument_list|,
name|OOBLNO
argument_list|,
name|P_TOP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|svi_sm_position
argument_list|(
name|sp
argument_list|,
name|rp
argument_list|,
literal|0
argument_list|,
name|P_BOTTOM
argument_list|)
operator|)
return|;
block|}
name|cursor_set
operator|=
name|scmd
operator|==
name|CNTRL_Y
operator|||
name|svi_sm_cursor
argument_list|(
name|sp
argument_list|,
operator|&
name|ssmp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|&&
name|sp
operator|->
name|t_rows
operator|!=
name|sp
operator|->
name|t_maxrows
condition|;
operator|--
name|count
operator|,
operator|++
name|sp
operator|->
name|t_rows
control|)
block|{
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
name|HMAP
operator|->
name|off
operator|==
literal|1
condition|)
break|break;
operator|++
name|TMAP
expr_stmt|;
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cursor_set
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|ssmp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|ssmp
operator|->
name|c_sboff
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|ychanged
operator|=
name|zset
operator|=
literal|0
init|;
name|count
condition|;
operator|--
name|count
control|)
block|{
comment|/* If the line doesn't exist, we're done. */
if|if
condition|(
name|HMAP
operator|->
name|lno
operator|==
literal|1
operator|&&
name|HMAP
operator|->
name|off
operator|==
literal|1
condition|)
break|break;
comment|/* Scroll the screen and cursor down one logical line. */
if|if
condition|(
name|svi_sm_1down
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_Y
case|:
if|if
condition|(
name|smp
operator|<
name|TMAP
condition|)
operator|++
name|smp
expr_stmt|;
else|else
name|ychanged
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|Z_CARAT
case|:
if|if
condition|(
name|zset
condition|)
block|{
if|if
condition|(
name|smp
operator|<
name|TMAP
condition|)
operator|++
name|smp
expr_stmt|;
block|}
else|else
block|{
name|smp
operator|=
name|HMAP
expr_stmt|;
name|zset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|scmd
operator|!=
name|CNTRL_Y
operator|&&
name|cursor_set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|scmd
condition|)
block|{
case|case
name|CNTRL_B
case|:
comment|/* 		 * If there are more lines, the ^B command is positioned at 		 * the last line of the screen.  However, the line may not 		 * exist. 		 */
if|if
condition|(
operator|!
name|count
condition|)
block|{
for|for
control|(
name|smp
operator|=
name|TMAP
init|;
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|CNTRL_U
case|:
comment|/* 		 * The ^B and ^U commands move the cursor towards SOF 		 * if there are more lines to move. 		 */
if|if
condition|(
name|count
operator|<
name|smp
operator|-
name|HMAP
condition|)
name|smp
operator|-=
name|count
expr_stmt|;
else|else
name|smp
operator|=
name|HMAP
expr_stmt|;
break|break;
case|case
name|CNTRL_Y
case|:
comment|/* 		 * On a ^Y that was forced to change lines, try and keep the 		 * cursor as close as possible to the last position, but also 		 * set it up so that the next "real" movement will return the 		 * cursor to the closest position to the last real movement. 		 */
if|if
condition|(
name|ychanged
condition|)
block|{
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|svi_cm_private
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
name|smp
operator|->
name|off
argument_list|,
name|sp
operator|->
name|rcm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_CARAT
case|:
comment|/* The z^ command moves the cursor to the first new line. */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|svi_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_erase --  *	Erase the small screen area for the scrolling functions.  */
end_comment

begin_function
specifier|static
name|int
name|svi_sm_erase
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|sp
operator|->
name|t_rows
operator|>
name|sp
operator|->
name|t_minrows
condition|;
operator|--
name|sp
operator|->
name|t_rows
operator|,
operator|--
name|TMAP
control|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|-
name|HMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_1down --  *	Scroll the SMAP down one.  */
end_comment

begin_function
name|int
name|svi_sm_1down
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* 	 * Clear the bottom line of the screen, insert a line at the top 	 * of the screen.  Shift the screen map down, display a new line 	 * at the top of the screen. 	 */
name|MOVE
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|t_rows
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|MOVE
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_insertln
argument_list|(
name|sp
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|memmove
argument_list|(
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|,
operator|(
name|sp
operator|->
name|rows
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|SMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svi_sm_prev
argument_list|(
name|sp
argument_list|,
name|HMAP
operator|+
literal|1
argument_list|,
name|HMAP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* svi_sm_prev() flushed the cache. */
if|if
condition|(
name|svi_line
argument_list|(
name|sp
argument_list|,
name|HMAP
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_insertln --  *	Insert a line a la curses, make sure to put the information  *	line and other screens back.  */
end_comment

begin_function
specifier|static
name|int
name|svi_insertln
parameter_list|(
name|sp
parameter_list|,
name|cnt
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|size_t
name|oldy
decl_stmt|,
name|oldx
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
name|MOVE
argument_list|(
name|sp
argument_list|,
name|INFOLINE
argument_list|(
name|sp
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deleteln
argument_list|()
expr_stmt|;
name|MOVEA
argument_list|(
name|sp
argument_list|,
name|oldy
argument_list|,
name|oldx
argument_list|)
expr_stmt|;
name|insertln
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_next --  *	Fill in the next entry in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_next
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|size_t
name|lcnt
decl_stmt|;
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
expr_stmt|;
block|}
else|else
block|{
name|lcnt
operator|=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcnt
operator|==
name|p
operator|->
name|off
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|+
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * svi_sm_prev --  *	Fill in the previous entry in the SMAP.  */
end_comment

begin_function
name|int
name|svi_sm_prev
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
name|p
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|SMAP_FLUSH
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|off
operator|!=
literal|1
condition|)
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|p
operator|->
name|off
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|lno
operator|=
name|p
operator|->
name|lno
operator|-
literal|1
expr_stmt|;
name|t
operator|->
name|off
operator|=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|t
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|->
name|lno
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * svi_sm_cursor --  *	Return the SMAP entry referenced by the cursor.  */
end_comment

begin_function
name|int
name|svi_sm_cursor
parameter_list|(
name|sp
parameter_list|,
name|smpp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
modifier|*
name|smpp
decl_stmt|;
block|{
name|SMAP
modifier|*
name|p
decl_stmt|;
comment|/* See if the cursor is not in the map. */
if|if
condition|(
name|sp
operator|->
name|lno
operator|<
name|HMAP
operator|->
name|lno
operator|||
name|sp
operator|->
name|lno
operator|>
name|TMAP
operator|->
name|lno
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Find the first occurence of the line. */
for|for
control|(
name|p
operator|=
name|HMAP
init|;
name|p
operator|->
name|lno
operator|!=
name|sp
operator|->
name|lno
condition|;
operator|++
name|p
control|)
empty_stmt|;
comment|/* Fill in the map information until we find the right line. */
for|for
control|(
init|;
name|p
operator|<=
name|TMAP
condition|;
operator|++
name|p
control|)
block|{
comment|/* Short lines are common and easy to detect. */
if|if
condition|(
name|p
operator|!=
name|TMAP
operator|&&
operator|(
name|p
operator|+
literal|1
operator|)
operator|->
name|lno
operator|!=
name|p
operator|->
name|lno
condition|)
block|{
operator|*
name|smpp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|p
argument_list|)
operator|&&
name|svi_line
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|c_eboff
operator|>=
name|sp
operator|->
name|cno
condition|)
block|{
operator|*
name|smpp
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* It was past the end of the map after all. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_position --  *	Return the line/column of the top, middle or last line on the screen.  *	(The vi H, M and L commands.)  Here because only the screen routines  *	know what's really out there.  */
end_comment

begin_function
name|int
name|svi_sm_position
parameter_list|(
name|sp
parameter_list|,
name|rp
parameter_list|,
name|cnt
parameter_list|,
name|pos
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|rp
decl_stmt|;
name|u_long
name|cnt
decl_stmt|;
name|enum
name|position
name|pos
decl_stmt|;
block|{
name|SMAP
modifier|*
name|smp
decl_stmt|;
name|recno_t
name|last
decl_stmt|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|P_TOP
case|:
comment|/* 		 * !!! 		 * Historically, an invalid count to the H command failed. 		 * We do nothing special here, just making sure that H in 		 * an empty screen works. 		 */
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|-
name|HMAP
condition|)
goto|goto
name|sof
goto|;
name|smp
operator|=
name|HMAP
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|&&
name|file_gline
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sof
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"219|Movement past the end-of-screen"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|P_MIDDLE
case|:
comment|/* 		 * !!! 		 * Historically, a count to the M command was ignored. 		 * If the screen isn't filled, find the middle of what's 		 * real and move there. 		 */
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|TMAP
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|smp
operator|=
name|TMAP
init|;
name|smp
operator|->
name|lno
operator|>
name|last
operator|&&
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
empty_stmt|;
if|if
condition|(
name|smp
operator|>
name|HMAP
condition|)
name|smp
operator|-=
operator|(
name|smp
operator|-
name|HMAP
operator|)
operator|/
literal|2
expr_stmt|;
block|}
else|else
name|smp
operator|=
operator|(
name|HMAP
operator|+
operator|(
name|TMAP
operator|-
name|HMAP
operator|)
operator|/
literal|2
operator|)
operator|+
name|cnt
expr_stmt|;
break|break;
case|case
name|P_BOTTOM
case|:
comment|/* 		 * !!! 		 * Historically, an invalid count to the L command failed. 		 * If the screen isn't filled, find the bottom of what's 		 * real and try to offset from there. 		 */
if|if
condition|(
name|cnt
operator|>
name|TMAP
operator|-
name|HMAP
condition|)
goto|goto
name|eof
goto|;
name|smp
operator|=
name|TMAP
operator|-
name|cnt
expr_stmt|;
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|smp
operator|->
name|lno
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
operator|&
name|last
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
init|;
name|smp
operator|->
name|lno
operator|>
name|last
operator|&&
name|smp
operator|>
name|HMAP
condition|;
operator|--
name|smp
control|)
empty_stmt|;
if|if
condition|(
name|cnt
operator|>
name|smp
operator|-
name|HMAP
condition|)
block|{
name|eof
label|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_BERR
argument_list|,
literal|"220|Movement past the beginning-of-screen"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|smp
operator|-=
name|cnt
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Make sure that the cached information is valid. */
if|if
condition|(
operator|!
name|SMAP_CACHE
argument_list|(
name|smp
argument_list|)
operator|&&
name|svi_line
argument_list|(
name|sp
argument_list|,
name|smp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|rp
operator|->
name|lno
operator|=
name|smp
operator|->
name|lno
expr_stmt|;
name|rp
operator|->
name|cno
operator|=
name|smp
operator|->
name|c_sboff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * svi_sm_nlines --  *	Return the number of screen lines from an SMAP entry to the  *	start of some file line, less than a maximum value.  */
end_comment

begin_function
name|recno_t
name|svi_sm_nlines
parameter_list|(
name|sp
parameter_list|,
name|from_sp
parameter_list|,
name|to_lno
parameter_list|,
name|max
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|SMAP
modifier|*
name|from_sp
decl_stmt|;
name|recno_t
name|to_lno
decl_stmt|;
name|size_t
name|max
decl_stmt|;
block|{
name|recno_t
name|lno
decl_stmt|,
name|lcnt
decl_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LEFTRIGHT
argument_list|)
condition|)
return|return
operator|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|?
name|from_sp
operator|->
name|lno
operator|-
name|to_lno
else|:
name|to_lno
operator|-
name|from_sp
operator|->
name|lno
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|==
name|to_lno
condition|)
return|return
operator|(
name|from_sp
operator|->
name|off
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|from_sp
operator|->
name|lno
operator|>
name|to_lno
condition|)
block|{
name|lcnt
operator|=
name|from_sp
operator|->
name|off
operator|-
literal|1
expr_stmt|;
comment|/* Correct for off-by-one. */
for|for
control|(
name|lno
operator|=
name|from_sp
operator|->
name|lno
init|;
operator|--
name|lno
operator|>=
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lno
operator|=
name|from_sp
operator|->
name|lno
expr_stmt|;
name|lcnt
operator|=
operator|(
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
operator|-
name|from_sp
operator|->
name|off
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
operator|++
name|lno
operator|<
name|to_lno
operator|&&
name|lcnt
operator|<=
name|max
condition|;
control|)
name|lcnt
operator|+=
name|svi_opt_screens
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lcnt
operator|)
return|;
block|}
end_function

end_unit

