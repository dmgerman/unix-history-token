begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ex_subst.c	9.4 (Berkeley) 11/13/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_define
define|#
directive|define
name|SUB_FIRST
value|0x01
end_define

begin_comment
comment|/* The 'r' flag isn't reasonable. */
end_comment

begin_define
define|#
directive|define
name|SUB_MUSTSETR
value|0x02
end_define

begin_comment
comment|/* The 'r' flag is required. */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|int
name|regsub
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|size_t
operator|*
operator|,
name|regmatch_t
index|[
literal|10
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|s
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|EXCMDARG
operator|*
operator|,
name|char
operator|*
operator|,
name|regex_t
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ex_s --  *	[line [,line]] s[ubstitute] [[/;]pat[/;]/repl[/;] [cgr] [count] [#lp]]  *  *	Substitute on lines matching a pattern.  */
end_comment

begin_function
name|int
name|ex_s
parameter_list|(
name|sp
parameter_list|,
name|cmdp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
block|{
name|regex_t
modifier|*
name|re
decl_stmt|,
name|lre
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|len
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|delim
decl_stmt|,
name|eval
decl_stmt|,
name|reflags
decl_stmt|,
name|replaced
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ptrn
decl_stmt|,
modifier|*
name|rep
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* 	 * Skip leading white space. 	 * 	 * !!! 	 * Historic vi allowed any non-alphanumeric to serve as the 	 * substitution command delimiter. 	 * 	 * !!! 	 * If the arguments are empty, it's the same as&, i.e. we 	 * repeat the last substitution. 	 */
if|if
condition|(
name|cmdp
operator|->
name|argc
operator|==
literal|0
condition|)
goto|goto
name|subagain
goto|;
for|for
control|(
name|p
operator|=
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
operator|,
name|len
operator|=
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|len
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
operator|,
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|subagain
label|:
return|return
operator|(
name|ex_subagain
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|)
operator|)
return|;
name|delim
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isalnum
argument_list|(
name|delim
argument_list|)
condition|)
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|p
argument_list|,
operator|&
name|sp
operator|->
name|subre
argument_list|,
name|SUB_MUSTSETR
argument_list|)
operator|)
return|;
comment|/* 	 * !!! 	 * The full-blown substitute command reset the remembered 	 * state of the 'c' and 'g' suffices. 	 */
name|sp
operator|->
name|c_suffix
operator|=
name|sp
operator|->
name|g_suffix
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the pattern string, toss escaped characters. 	 * 	 * !!! 	 * Historic vi accepted any of the following forms: 	 * 	 *	:s/abc/def/		change "abc" to "def" 	 *	:s/abc/def		change "abc" to "def" 	 *	:s/abc/			delete "abc" 	 *	:s/abc			delete "abc" 	 * 	 * QUOTING NOTE: 	 * 	 * Only toss an escape character if it escapes a delimiter. 	 * This means that "s/A/\\\\f" replaces "A" with "\\f".  It 	 * would be nice to be more regular, i.e. for each layer of 	 * escaping a single escape character is removed, but that's 	 * not how the historic vi worked. 	 */
for|for
control|(
name|ptrn
operator|=
name|t
operator|=
name|p
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
comment|/* 			 * !!! 			 * Nul terminate the pattern string -- it's passed 			 * to regcomp which doesn't understand anything else. 			 */
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* 	 * If the pattern string is empty, use the last RE (not just the 	 * last substitution RE). 	 */
if|if
condition|(
operator|*
name|ptrn
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SRE_SET
argument_list|)
condition|)
block|{
name|ex_message
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|re
operator|=
operator|&
name|sp
operator|->
name|sre
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Set RE flags. */
name|reflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_EXTENDED
argument_list|)
condition|)
name|reflags
operator||=
name|REG_EXTENDED
expr_stmt|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_IGNORECASE
argument_list|)
condition|)
name|reflags
operator||=
name|REG_ICASE
expr_stmt|;
comment|/* Convert vi-style RE's to POSIX 1003.2 RE's. */
if|if
condition|(
name|re_conv
argument_list|(
name|sp
argument_list|,
operator|&
name|ptrn
argument_list|,
operator|&
name|replaced
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Compile the RE. */
name|eval
operator|=
name|regcomp
argument_list|(
operator|&
name|lre
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptrn
argument_list|,
name|reflags
argument_list|)
expr_stmt|;
comment|/* Free up any allocated memory. */
if|if
condition|(
name|replaced
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|ptrn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
condition|)
block|{
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
operator|&
name|lre
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Set saved RE. 		 * 		 * !!! 		 * Historic practice is that substitutes set the search 		 * direction as well as both substitute and search RE's. 		 */
name|sp
operator|->
name|searchdir
operator|=
name|FORWARD
expr_stmt|;
name|sp
operator|->
name|sre
operator|=
name|lre
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SRE_SET
argument_list|)
expr_stmt|;
name|sp
operator|->
name|subre
operator|=
name|lre
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SUBRE_SET
argument_list|)
expr_stmt|;
name|re
operator|=
operator|&
name|lre
expr_stmt|;
name|flags
operator|=
name|SUB_FIRST
expr_stmt|;
block|}
comment|/* 	 * Get the replacement string. 	 * 	 * The special character& (\& if O_MAGIC not set) matches the 	 * entire RE.  No handling of& is required here, it's done by 	 * regsub(). 	 * 	 * The special character ~ (\~ if O_MAGIC not set) inserts the 	 * previous replacement string into this replacement string. 	 * Count ~'s to figure out how much space we need.  We could 	 * special case nonexistent last patterns or whether or not 	 * O_MAGIC is set, but it's probably not worth the effort. 	 * 	 * QUOTING NOTE: 	 * 	 * Only toss an escape character if it escapes a delimiter or 	 * if O_MAGIC is set and it escapes a tilde. 	 * 	 * !!! 	 * If the entire replacement pattern is "%", then use the last 	 * replacement pattern.  This semantic was added to vi in System 	 * V and then percolated elsewhere, presumably around the time 	 * that it was added to their version of ed(1). 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|repl
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|sp
operator|->
name|repl
argument_list|,
name|sp
operator|->
name|repl_len
argument_list|)
expr_stmt|;
name|sp
operator|->
name|repl
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|repl_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|1
index|]
operator|==
name|delim
operator|)
condition|)
name|p
operator|+=
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|?
literal|2
else|:
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|rep
operator|=
name|p
operator|,
name|len
operator|=
literal|0
init|;
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
name|delim
condition|;
operator|++
name|p
operator|,
operator|++
name|len
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|len
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
name|GET_SPACE_RET
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|bp
operator|,
name|len
operator|=
literal|0
operator|,
name|p
operator|=
name|rep
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
name|delim
condition|)
operator|++
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
goto|goto
name|tilde
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'~'
operator|&&
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|tilde
label|:
operator|++
name|p
expr_stmt|;
name|memmove
argument_list|(
name|t
argument_list|,
name|sp
operator|->
name|repl
argument_list|,
name|sp
operator|->
name|repl_len
argument_list|)
expr_stmt|;
name|t
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
name|len
operator|+=
name|sp
operator|->
name|repl_len
expr_stmt|;
continue|continue;
block|}
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|repl_len
operator|=
name|len
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|repl
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sp
operator|->
name|repl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|repl
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|memmove
argument_list|(
name|sp
operator|->
name|repl
argument_list|,
name|bp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|p
argument_list|,
name|re
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_subagain --  *	[line [,line]]& [cgr] [count] [#lp]]  *  *	Substitute using the last substitute RE and replacement pattern.  */
end_comment

begin_function
name|int
name|ex_subagain
parameter_list|(
name|sp
parameter_list|,
name|cmdp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SUBRE_SET
argument_list|)
condition|)
block|{
name|ex_message
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|cmdp
operator|->
name|argc
condition|?
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
else|:
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|subre
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ex_subtilde --  *	[line [,line]] ~ [cgr] [count] [#lp]]  *  *	Substitute using the last RE and last substitute replacement pattern.  */
end_comment

begin_function
name|int
name|ex_subtilde
parameter_list|(
name|sp
parameter_list|,
name|cmdp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SRE_SET
argument_list|)
condition|)
block|{
name|ex_message
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|s
argument_list|(
name|sp
argument_list|,
name|cmdp
argument_list|,
name|cmdp
operator|->
name|argc
condition|?
name|cmdp
operator|->
name|argv
index|[
literal|0
index|]
operator|->
name|bp
else|:
name|NULL
argument_list|,
operator|&
name|sp
operator|->
name|sre
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The nasty part of the substitution is what happens when the replacement  * string contains newlines.  It's a bit tricky -- consider the information  * that has to be retained for "s/f\(o\)o/^M\1^M\1/".  The solution here is  * to build a set of newline offsets which we use to break the line up later,  * when the replacement is done.  Don't change it unless you're pretty damned  * confident.  */
end_comment

begin_define
define|#
directive|define
name|NEEDNEWLINE
parameter_list|(
name|sp
parameter_list|)
value|{						\ 	if (sp->newl_len == sp->newl_cnt) {				\ 		sp->newl_len += 25;					\ 		REALLOC(sp, sp->newl, size_t *,				\ 		    sp->newl_len * sizeof(size_t));			\ 		if (sp->newl == NULL) {					\ 			sp->newl_len = 0;				\ 			return (1);					\ 		}							\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|BUILD
parameter_list|(
name|sp
parameter_list|,
name|l
parameter_list|,
name|len
parameter_list|)
value|{						\ 	if (lbclen + (len)> lblen) {					\ 		lblen += MAX(lbclen + (len), 256);			\ 		REALLOC(sp, lb, char *, lblen);				\ 		if (lb == NULL) {					\ 			lbclen = 0;					\ 			return (1);					\ 		}							\ 	}								\ 	memmove(lb + lbclen, l, len);					\ 	lbclen += len;							\ }
end_define

begin_define
define|#
directive|define
name|NEEDSP
parameter_list|(
name|sp
parameter_list|,
name|len
parameter_list|,
name|pnt
parameter_list|)
value|{						\ 	if (lbclen + (len)> lblen) {					\ 		lblen += MAX(lbclen + (len), 256);			\ 		REALLOC(sp, lb, char *, lblen);				\ 		if (lb == NULL) {					\ 			lbclen = 0;					\ 			return (1);					\ 		}							\ 		pnt = lb + lbclen;					\ 	}								\ }
end_define

begin_comment
comment|/*  * substitute --  *	Do the substitution.  This stuff is *really* tricky.  There are  *	lots of special cases, and general nastiness.  Don't mess with it  * 	unless you're pretty confident.  */
end_comment

begin_function
specifier|static
name|int
name|s
parameter_list|(
name|sp
parameter_list|,
name|cmdp
parameter_list|,
name|s
parameter_list|,
name|re
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXCMDARG
modifier|*
name|cmdp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|regex_t
modifier|*
name|re
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|recno_t
name|elno
decl_stmt|,
name|lno
decl_stmt|;
name|regmatch_t
name|match
index|[
literal|10
index|]
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|cnt
decl_stmt|,
name|last
decl_stmt|,
name|lbclen
decl_stmt|,
name|lblen
decl_stmt|,
name|len
decl_stmt|,
name|llen
decl_stmt|,
name|offset
decl_stmt|,
name|saved_offset
decl_stmt|;
name|int
name|cflag
decl_stmt|,
name|lflag
decl_stmt|,
name|nflag
decl_stmt|,
name|pflag
decl_stmt|,
name|rflag
decl_stmt|;
name|int
name|didsub
decl_stmt|,
name|do_eol_match
decl_stmt|,
name|eflags
decl_stmt|,
name|empty_ok
decl_stmt|,
name|eval
decl_stmt|;
name|int
name|linechanged
decl_stmt|,
name|matched
decl_stmt|,
name|quit
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lb
decl_stmt|;
name|NEEDFILE
argument_list|(
name|sp
argument_list|,
name|cmdp
operator|->
name|cmd
argument_list|)
expr_stmt|;
comment|/* 	 * !!! 	 * Historically, the 'g' and 'c' suffices were always toggled as flags, 	 * so ":s/A/B/" was the same as ":s/A/B/ccgg".  If O_EDCOMPATIBLE was 	 * not set, they were initialized to 0 for all substitute commands.  If 	 * O_EDCOMPATIBLE was set, they were initialized to 0 only if the user 	 * specified substitute/replacement patterns (see ex_s()). 	 */
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_EDCOMPATIBLE
argument_list|)
condition|)
name|sp
operator|->
name|c_suffix
operator|=
name|sp
operator|->
name|g_suffix
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Historic vi permitted the '#', 'l' and 'p' options in vi mode, but 	 * it only displayed the last change.  I'd disallow them, but they are 	 * useful in combination with the [v]global commands.  In the current 	 * model the problem is combining them with the 'c' flag -- the screen 	 * would have to flip back and forth between the confirm screen and the 	 * ex print screen, which would be pretty awful.  We do display all 	 * changes, though, for what that's worth. 	 * 	 * !!! 	 * Historic vi was fairly strict about the order of "options", the 	 * count, and "flags".  I'm somewhat fuzzy on the difference between 	 * options and flags, anyway, so this is a simpler approach, and we 	 * just take it them in whatever order the user gives them.  (The ex 	 * usage statement doesn't reflect this.) 	 */
name|cflag
operator|=
name|lflag
operator|=
name|nflag
operator|=
name|pflag
operator|=
name|rflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
goto|goto
name|noargs
goto|;
for|for
control|(
name|lno
operator|=
name|OOBLNO
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
continue|continue;
case|case
literal|'+'
case|:
operator|++
name|cmdp
operator|->
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|--
name|cmdp
operator|->
name|flagoff
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|lno
operator|!=
name|OOBLNO
condition|)
goto|goto
name|usage
goto|;
name|errno
operator|=
literal|0
expr_stmt|;
name|lno
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
comment|/* Loop increment correction. */
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
block|{
if|if
condition|(
name|lno
operator|==
name|LONG_MAX
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"156|Count overflow"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lno
operator|==
name|LONG_MIN
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"157|Count underflow"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * In historic vi, the count was inclusive from the 			 * second address. 			 */
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|=
name|cmdp
operator|->
name|addr2
operator|.
name|lno
expr_stmt|;
name|cmdp
operator|->
name|addr2
operator|.
name|lno
operator|+=
name|lno
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|nflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|sp
operator|->
name|c_suffix
operator|=
operator|!
name|sp
operator|->
name|c_suffix
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|sp
operator|->
name|g_suffix
operator|=
operator|!
name|sp
operator|->
name|g_suffix
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|LF_ISSET
argument_list|(
name|SUB_FIRST
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"158|Regular expression specified; r flag meaningless"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_SRE_SET
argument_list|)
condition|)
block|{
name|ex_message
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_NOPREVRE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|rflag
operator|=
literal|1
expr_stmt|;
name|re
operator|=
operator|&
name|sp
operator|->
name|sre
expr_stmt|;
break|break;
default|default:
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|||
operator|!
name|rflag
operator|&&
name|LF_ISSET
argument_list|(
name|SUB_MUSTSETR
argument_list|)
condition|)
block|{
name|usage
label|:
name|ex_message
argument_list|(
name|sp
argument_list|,
name|cmdp
operator|->
name|cmd
argument_list|,
name|EXM_USAGE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|noargs
label|:
if|if
condition|(
name|IN_VI_MODE
argument_list|(
name|sp
argument_list|)
operator|&&
name|sp
operator|->
name|c_suffix
operator|&&
operator|(
name|lflag
operator|||
name|nflag
operator|||
name|pflag
operator|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"159|The #, l and p flags may not be combined with the c flag in vi mode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * bp:		if interactive, line cache 	 * blen:	if interactive, line cache length 	 * lb:		build buffer pointer. 	 * lbclen:	current length of built buffer. 	 * lblen;	length of build buffer. 	 */
name|bp
operator|=
name|lb
operator|=
name|NULL
expr_stmt|;
name|blen
operator|=
name|lbclen
operator|=
name|lblen
operator|=
literal|0
expr_stmt|;
comment|/* For each line... */
for|for
control|(
name|matched
operator|=
name|quit
operator|=
literal|0
operator|,
name|lno
operator|=
name|cmdp
operator|->
name|addr1
operator|.
name|lno
operator|,
name|elno
operator|=
name|cmdp
operator|->
name|addr2
operator|.
name|lno
init|;
operator|!
name|quit
operator|&&
name|lno
operator|<=
name|elno
condition|;
operator|++
name|lno
control|)
block|{
comment|/* Someone's unhappy, time to stop. */
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
name|ex_message
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|EXM_INTERRUPTED
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Get the line. */
if|if
condition|(
operator|(
name|s
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
comment|/* 		 * Make a local copy if doing confirmation -- when calling 		 * the confirm routine we're likely to lose the cached copy. 		 */
if|if
condition|(
name|sp
operator|->
name|c_suffix
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|GET_SPACE_RET
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|llen
argument_list|)
expr_stmt|;
block|}
else|else
name|ADD_SPACE_RET
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|s
operator|=
name|bp
expr_stmt|;
block|}
comment|/* Start searching from the beginning. */
name|offset
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|llen
expr_stmt|;
comment|/* Reset the build buffer offset. */
name|lbclen
operator|=
literal|0
expr_stmt|;
comment|/* Reset empty match flag. */
name|empty_ok
operator|=
literal|1
expr_stmt|;
comment|/* 		 * We don't want to have to do a setline if the line didn't 		 * change -- keep track of whether or not this line changed. 		 * If doing confirmations, don't want to keep setting the 		 * line if change is refused -- keep track of substitutions. 		 */
name|didsub
operator|=
name|linechanged
operator|=
literal|0
expr_stmt|;
comment|/* New line, do an EOL match. */
name|do_eol_match
operator|=
literal|1
expr_stmt|;
comment|/* It's not nul terminated, but we pretend it is. */
name|eflags
operator|=
name|REG_STARTEND
expr_stmt|;
comment|/* 		 * The search area is from s + offset to the EOL. 		 * 		 * Generally, match[0].rm_so is the offset of the start 		 * of the match from the start of the search, and offset 		 * is the offset of the start of the last search. 		 */
name|nextmatch
label|:
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
comment|/* Get the next match. */
name|eval
operator|=
name|regexec
argument_list|(
name|re
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s
operator|+
name|offset
argument_list|,
literal|10
argument_list|,
name|match
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
comment|/* 		 * There wasn't a match or if there was an error, deal with 		 * it.  If there was a previous match in this line, resolve 		 * the changes into the database.  Otherwise, just move on. 		 */
if|if
condition|(
name|eval
operator|==
name|REG_NOMATCH
condition|)
goto|goto
name|endmatch
goto|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
name|re_error
argument_list|(
name|sp
argument_list|,
name|eval
argument_list|,
name|re
argument_list|)
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* Only the first search can match an anchored expression. */
name|eflags
operator||=
name|REG_NOTBOL
expr_stmt|;
comment|/* 		 * !!! 		 * It's possible to match 0-length strings -- for example, the 		 * command s;a*;X;, when matched against the string "aabb" will 		 * result in "XbXbX", i.e. the matches are "aa", the space 		 * between the b's and the space between the b's and the end of 		 * the string.  There is a similar space between the beginning 		 * of the string and the a's.  The rule that we use (because vi 		 * historically used it) is that any 0-length match, occurring 		 * immediately after a match, is ignored.  Otherwise, the above 		 * example would have resulted in "XXbXbX".  Another example is 		 * incorrectly using " *" to replace groups of spaces with one 		 * space. 		 * 		 * The way we do this is that if we just had a successful match, 		 * the starting offset does not skip characters, and the match 		 * is empty, ignore the match and move forward.  If there's no 		 * more characters in the string, we were attempting to match 		 * after the last character, so quit. 		 */
if|if
condition|(
operator|!
name|empty_ok
operator|&&
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|==
literal|0
condition|)
block|{
name|empty_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|endmatch
goto|;
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
literal|1
argument_list|)
operator|++
name|offset
expr_stmt|;
operator|--
name|len
expr_stmt|;
goto|goto
name|nextmatch
goto|;
block|}
comment|/* Confirm change. */
if|if
condition|(
name|sp
operator|->
name|c_suffix
condition|)
block|{
comment|/* 			 * Set the cursor position for confirmation.  Note, 			 * if we matched on a '$', the cursor may be past 			 * the end of line. 			 * 			 * XXX 			 * We may want to "fix" this in the confirm routine, 			 * if the confirm routine should be able to display 			 * a cursor past EOL. 			 */
name|from
operator|.
name|lno
operator|=
name|to
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|from
operator|.
name|cno
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
operator|+
name|offset
expr_stmt|;
name|to
operator|.
name|cno
operator|=
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|llen
operator|==
literal|0
condition|)
name|from
operator|.
name|cno
operator|=
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|to
operator|.
name|cno
operator|>=
name|llen
condition|)
name|to
operator|.
name|cno
operator|=
name|llen
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|cno
operator|>=
name|llen
condition|)
name|from
operator|.
name|cno
operator|=
name|llen
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|sp
operator|->
name|s_confirm
argument_list|(
name|sp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|)
condition|)
block|{
case|case
name|CONF_YES
case|:
break|break;
case|case
name|CONF_NO
case|:
name|didsub
operator|=
literal|0
expr_stmt|;
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
case|case
name|CONF_QUIT
case|:
comment|/* Set the quit/interrupted flags. */
name|quit
operator|=
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_INTERRUPTED
argument_list|)
expr_stmt|;
comment|/* 				 * Resolve any changes, then return to (and 				 * exit from) the main loop. 				 */
goto|goto
name|endmatch
goto|;
block|}
block|}
comment|/* Copy the bytes before the match into the build buffer. */
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
name|match
index|[
literal|0
index|]
operator|.
name|rm_so
argument_list|)
expr_stmt|;
comment|/* Substitute the matching bytes. */
name|didsub
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|regsub
argument_list|(
name|sp
argument_list|,
name|s
operator|+
name|offset
argument_list|,
operator|&
name|lb
argument_list|,
operator|&
name|lbclen
argument_list|,
operator|&
name|lblen
argument_list|,
name|match
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
comment|/* Set the change flag so we know this line was modified. */
name|linechanged
operator|=
literal|1
expr_stmt|;
comment|/* Move past the matched bytes. */
name|skip
label|:
name|offset
operator|+=
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
name|len
operator|-=
name|match
index|[
literal|0
index|]
operator|.
name|rm_eo
expr_stmt|;
comment|/* A match cannot be followed by an empty pattern. */
name|empty_ok
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If doing a global change with confirmation, we have to 		 * update the screen.  The basic idea is to store the line 		 * so the screen update routines can find it, and restart. 		 */
if|if
condition|(
name|didsub
operator|&&
name|sp
operator|->
name|c_suffix
operator|&&
name|sp
operator|->
name|g_suffix
condition|)
block|{
comment|/* 			 * The new search offset will be the end of the 			 * modified line. 			 */
name|saved_offset
operator|=
name|lbclen
expr_stmt|;
comment|/* Copy the rest of the line. */
if|if
condition|(
name|len
condition|)
name|BUILD
argument_list|(
argument|sp
argument_list|,
argument|s + offset
argument_list|,
argument|len
argument_list|)
comment|/* Set the new offset. */
name|offset
operator|=
name|saved_offset
expr_stmt|;
comment|/* Store inserted lines, adjusting the build buffer. */
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|newl_cnt
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|sp
operator|->
name|newl_cnt
condition|;
operator|++
name|cnt
operator|,
operator|++
name|lno
operator|,
operator|++
name|elno
control|)
block|{
if|if
condition|(
name|file_iline
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|-
name|last
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
name|last
operator|=
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|+
literal|1
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
block|}
name|lbclen
operator|-=
name|last
expr_stmt|;
name|offset
operator|-=
name|last
expr_stmt|;
name|sp
operator|->
name|newl_cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store and retrieve the line. */
if|if
condition|(
name|file_sline
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|lbclen
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
if|if
condition|(
operator|(
name|s
operator|=
name|file_gline
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
operator|&
name|llen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GETLINE_ERR
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|)
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
name|ADD_SPACE_RET
argument_list|(
argument|sp
argument_list|,
argument|bp
argument_list|,
argument|blen
argument_list|,
argument|llen
argument_list|)
name|memmove
argument_list|(
name|bp
argument_list|,
name|s
argument_list|,
name|llen
argument_list|)
expr_stmt|;
name|s
operator|=
name|bp
expr_stmt|;
name|len
operator|=
name|llen
operator|-
name|offset
expr_stmt|;
comment|/* Restart the build. */
name|lbclen
operator|=
literal|0
expr_stmt|;
name|BUILD
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* 			 * If we haven't already done the after-the-string 			 * match, do one.  Set REG_NOTEOL so the '$' pattern 			 * only matches once. 			 */
if|if
condition|(
operator|!
name|do_eol_match
condition|)
goto|goto
name|endmatch
goto|;
if|if
condition|(
name|offset
operator|==
name|len
condition|)
block|{
name|do_eol_match
operator|=
literal|0
expr_stmt|;
name|eflags
operator||=
name|REG_NOTEOL
expr_stmt|;
block|}
goto|goto
name|nextmatch
goto|;
block|}
comment|/* 		 * If it's a global: 		 * 		 * If at the end of the string, do a test for the after 		 * the string match.  Set REG_NOTEOL so the '$' pattern 		 * only matches once. 		 */
if|if
condition|(
name|sp
operator|->
name|g_suffix
operator|&&
name|do_eol_match
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|do_eol_match
operator|=
literal|0
expr_stmt|;
name|eflags
operator||=
name|REG_NOTEOL
expr_stmt|;
block|}
goto|goto
name|nextmatch
goto|;
block|}
name|endmatch
label|:
if|if
condition|(
operator|!
name|linechanged
condition|)
continue|continue;
comment|/* Copy any remaining bytes into the build buffer. */
if|if
condition|(
name|len
condition|)
name|BUILD
argument_list|(
argument|sp
argument_list|,
argument|s + offset
argument_list|,
argument|len
argument_list|)
comment|/* Store inserted lines, adjusting the build buffer. */
name|last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|newl_cnt
condition|)
block|{
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|sp
operator|->
name|newl_cnt
condition|;
operator|++
name|cnt
operator|,
operator|++
name|lno
operator|,
operator|++
name|elno
control|)
block|{
if|if
condition|(
name|file_iline
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|-
name|last
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
name|last
operator|=
name|sp
operator|->
name|newl
index|[
name|cnt
index|]
operator|+
literal|1
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_ADDED
index|]
expr_stmt|;
block|}
name|lbclen
operator|-=
name|last
expr_stmt|;
name|sp
operator|->
name|newl_cnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Store the changed line. */
if|if
condition|(
name|file_sline
argument_list|(
name|sp
argument_list|,
name|lno
argument_list|,
name|lb
operator|+
name|last
argument_list|,
name|lbclen
argument_list|)
condition|)
goto|goto
name|ret1
goto|;
comment|/* Update changed line counter. */
if|if
condition|(
name|sp
operator|->
name|rptlchange
operator|!=
name|lno
condition|)
block|{
name|sp
operator|->
name|rptlchange
operator|=
name|lno
expr_stmt|;
operator|++
name|sp
operator|->
name|rptlines
index|[
name|L_CHANGED
index|]
expr_stmt|;
block|}
comment|/* 		 * !!! 		 * Display as necessary.  Historic practice is to only 		 * display the last line of a line split into multiple 		 * lines. 		 */
if|if
condition|(
name|lflag
operator|||
name|nflag
operator|||
name|pflag
condition|)
block|{
name|from
operator|.
name|lno
operator|=
name|to
operator|.
name|lno
operator|=
name|lno
expr_stmt|;
name|from
operator|.
name|cno
operator|=
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
name|ex_print
argument_list|(
name|sp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_F_LIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|ex_print
argument_list|(
name|sp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_F_HASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
name|ex_print
argument_list|(
name|sp
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|to
argument_list|,
name|E_F_PRINT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sp
operator|->
name|c_suffix
condition|)
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
comment|/* 		 * !!! 		 * Move the cursor to the last line changed. 		 */
if|if
condition|(
operator|!
name|sp
operator|->
name|c_suffix
condition|)
name|sp
operator|->
name|lno
operator|=
name|lno
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Move the cursor to the first non-blank of the last line change. 	 * 	 * XXX 	 * This is NOT backward compatible with historic vi, which always 	 * moved to the last line actually changed. 	 */
if|if
condition|(
operator|!
name|sp
operator|->
name|c_suffix
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If not in a global command, and nothing matched, say so. 	 * Else, if none of the lines displayed, put something up. 	 */
if|if
condition|(
operator|!
name|matched
condition|)
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_GLOBAL
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"160|No match found"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|lflag
operator|&&
operator|!
name|nflag
operator|&&
operator|!
name|pflag
condition|)
name|F_SET
argument_list|(
name|EXP
argument_list|(
name|sp
argument_list|)
argument_list|,
name|EX_AUTOPRINT
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|ret1
label|:
name|rval
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * regsub --  * 	Do the substitution for a regular expression.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|regsub
parameter_list|(
name|sp
parameter_list|,
name|ip
parameter_list|,
name|lbp
parameter_list|,
name|lbclenp
parameter_list|,
name|lblenp
parameter_list|,
name|match
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|ip
decl_stmt|;
comment|/* Input line. */
name|char
modifier|*
modifier|*
name|lbp
decl_stmt|;
name|size_t
modifier|*
name|lbclenp
decl_stmt|,
decl|*
name|lblenp
decl_stmt|;
end_function

begin_decl_stmt
name|regmatch_t
name|match
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
enum|enum
block|{
name|C_NOTSET
block|,
name|C_LOWER
block|,
name|C_ONELOWER
block|,
name|C_ONEUPPER
block|,
name|C_UPPER
block|}
name|conv
enum|;
name|size_t
name|lbclen
decl_stmt|,
name|lblen
decl_stmt|;
comment|/* Local copies. */
name|size_t
name|mlen
decl_stmt|;
comment|/* Match length. */
name|size_t
name|rpl
decl_stmt|;
comment|/* Remaining replacement length. */
name|char
modifier|*
name|rp
decl_stmt|;
comment|/* Replacement pointer. */
name|int
name|ch
decl_stmt|;
name|int
name|no
decl_stmt|;
comment|/* Match replacement offset. */
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Buffer pointers. */
name|char
modifier|*
name|lb
decl_stmt|;
comment|/* Local copies. */
name|lb
operator|=
operator|*
name|lbp
expr_stmt|;
comment|/* Get local copies. */
name|lbclen
operator|=
operator|*
name|lbclenp
expr_stmt|;
name|lblen
operator|=
operator|*
name|lblenp
expr_stmt|;
comment|/* 	 * QUOTING NOTE: 	 * 	 * There are some special sequences that vi provides in the 	 * replacement patterns. 	 *& string the RE matched (\& if nomagic set) 	 *	\# n-th regular subexpression 	 *	\E end \U, \L conversion 	 *	\e end \U, \L conversion 	 *	\l convert the next character to lower-case 	 *	\L convert to lower-case, until \E, \e, or end of replacement 	 *	\u convert the next character to upper-case 	 *	\U convert to upper-case, until \E, \e, or end of replacement 	 * 	 * Otherwise, since this is the lowest level of replacement, discard 	 * all escape characters.  This (hopefully) follows historic practice. 	 */
define|#
directive|define
name|ADDCH
parameter_list|(
name|ch
parameter_list|)
value|{							\ 	CHAR_T __ch = (ch);						\ 	u_int __value = KEY_VAL(sp, __ch);				\ 	if (__value == K_CR || __value == K_NL) {			\ 		NEEDNEWLINE(sp);					\ 		sp->newl[sp->newl_cnt++] = lbclen;			\ 	} else if (conv != C_NOTSET) {					\ 		switch (conv) {						\ 		case C_ONELOWER:					\ 			conv = C_NOTSET;				\
comment|/* FALLTHROUGH */
value|\ 		case C_LOWER:						\ 			if (isupper(__ch))				\ 				__ch = tolower(__ch);			\ 			break;						\ 		case C_ONEUPPER:					\ 			conv = C_NOTSET;				\
comment|/* FALLTHROUGH */
value|\ 		case C_UPPER:						\ 			if (islower(__ch))				\ 				__ch = toupper(__ch);			\ 			break;						\ 		default:						\ 			abort();					\ 		}							\ 	}								\ 	NEEDSP(sp, 1, p);						\ 	*p++ = __ch;							\ 	++lbclen;							\ }
name|conv
operator|=
name|C_NOTSET
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|sp
operator|->
name|repl
operator|,
name|rpl
operator|=
name|sp
operator|->
name|repl_len
operator|,
name|p
operator|=
name|lb
operator|+
name|lbclen
init|;
name|rpl
operator|--
condition|;
control|)
block|{
switch|switch
condition|(
name|ch
operator|=
operator|*
name|rp
operator|++
condition|)
block|{
case|case
literal|'&'
case|:
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|no
operator|=
literal|0
expr_stmt|;
goto|goto
name|subzero
goto|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|rpl
operator|==
literal|0
condition|)
break|break;
operator|--
name|rpl
expr_stmt|;
switch|switch
condition|(
name|ch
operator|=
operator|*
name|rp
condition|)
block|{
case|case
literal|'&'
case|:
operator|++
name|rp
expr_stmt|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_MAGIC
argument_list|)
condition|)
block|{
name|no
operator|=
literal|0
expr_stmt|;
goto|goto
name|subzero
goto|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|no
operator|=
operator|*
name|rp
operator|++
operator|-
literal|'0'
expr_stmt|;
name|subzero
label|:
if|if
condition|(
name|match
index|[
name|no
index|]
operator|.
name|rm_so
operator|==
operator|-
literal|1
operator|||
name|match
index|[
name|no
index|]
operator|.
name|rm_eo
operator|==
operator|-
literal|1
condition|)
break|break;
name|mlen
operator|=
name|match
index|[
name|no
index|]
operator|.
name|rm_eo
operator|-
name|match
index|[
name|no
index|]
operator|.
name|rm_so
expr_stmt|;
for|for
control|(
name|t
operator|=
name|ip
operator|+
name|match
index|[
name|no
index|]
operator|.
name|rm_so
init|;
name|mlen
operator|--
condition|;
operator|++
name|t
control|)
name|ADDCH
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_NOTSET
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_ONELOWER
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_LOWER
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_ONEUPPER
expr_stmt|;
continue|continue;
case|case
literal|'U'
case|:
operator|++
name|rp
expr_stmt|;
name|conv
operator|=
name|C_UPPER
expr_stmt|;
continue|continue;
default|default:
operator|++
name|rp
expr_stmt|;
break|break;
block|}
block|}
name|ADDCH
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
operator|*
name|lbp
operator|=
name|lb
expr_stmt|;
comment|/* Update caller's information. */
operator|*
name|lbclenp
operator|=
name|lbclen
expr_stmt|;
operator|*
name|lblenp
operator|=
name|lblen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

