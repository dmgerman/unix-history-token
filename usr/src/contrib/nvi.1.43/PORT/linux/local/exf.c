begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)exf.c	9.14 (Berkeley) 12/2/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/*  * We include<sys/file.h>, because the flock(2) and open(2) #defines  * were found there on historical systems.  We also include<fcntl.h>  * because the open(2) #defines are found there on newer systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<pathnames.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"excmd.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|file_backup
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * file_add --  *	Insert a file name into the FREF list, if it doesn't already  *	appear in it.  *  * !!!  * The "if it doesn't already appear" changes vi's semantics slightly.  If  * you do a "vi foo bar", and then execute "next bar baz", the edit of bar  * will reflect the line/column of the previous edit session.  Historic nvi  * did not do this.  The change is a logical extension of the change where  * vi now remembers the last location in any file that it has ever edited,  * not just the previously edited file.  */
end_comment

begin_function
name|FREF
modifier|*
name|file_add
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CHAR_T
modifier|*
name|name
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
comment|/* 	 * Return it if it already exists.  Note that we test against the 	 * user's name, whatever that happens to be, including if it's a 	 * temporary file. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
for|for
control|(
name|frp
operator|=
name|sp
operator|->
name|frefq
operator|.
name|cqh_first
init|;
name|frp
operator|!=
operator|(
name|FREF
operator|*
operator|)
operator|&
name|sp
operator|->
name|frefq
condition|;
name|frp
operator|=
name|frp
operator|->
name|q
operator|.
name|cqe_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|frp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|frp
operator|)
return|;
comment|/* Allocate and initialize the FREF structure. */
name|CALLOC
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|FREF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If no file name specified, or if the file name is a request 	 * for something temporary, file_init() will allocate the file 	 * name.  Temporary files are always ignored. 	 */
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|TEMPORARY_FILE_STRING
argument_list|)
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|frp
argument_list|,
sizeof|sizeof
argument_list|(
name|FREF
argument_list|)
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Append into the chain of file names. */
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|sp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|frp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_init --  *	Start editing a file, based on the FREF structure.  If successsful,  *	let go of any previous file.  Don't release the previous file until  *	absolutely sure we have the new one.  */
end_comment

begin_function
name|int
name|file_init
parameter_list|(
name|sp
parameter_list|,
name|frp
parameter_list|,
name|rcv_name
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|char
modifier|*
name|rcv_name
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|EXF
modifier|*
name|ep
decl_stmt|;
name|RECNOINFO
name|oinfo
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|nf
decl_stmt|,
name|open_err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|oname
decl_stmt|,
name|tname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|open_err
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the file is a recovery file, let the recovery code handle it. 	 * Clear the FR_RECOVER flag first -- the recovery code does set up, 	 * and then calls us!  If the recovery call fails, it's probably 	 * because the named file doesn't exist.  So, move boldly forward, 	 * presuming that there's an error message the user will get to see. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_RECOVER
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_RECOVER
argument_list|)
expr_stmt|;
return|return
operator|(
name|rcv_read
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Required FRP initialization; the only flag we keep is the 	 * cursor information. 	 */
name|F_CLR
argument_list|(
name|frp
argument_list|,
operator|~
operator|(
name|FR_CURSORSET
operator||
name|FR_FNONBLANK
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Required EXF initialization: 	 *	Flush the line caches. 	 *	Default recover mail file fd to -1. 	 *	Set initial EXF flag bits. 	 */
name|CALLOC_RET
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|EXF
operator|*
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|c_lno
operator|=
name|ep
operator|->
name|c_nlines
operator|=
name|OOBLNO
expr_stmt|;
name|ep
operator|->
name|rcv_fd
operator|=
name|ep
operator|->
name|fcntl_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_FIRSTMODIFY
argument_list|)
expr_stmt|;
comment|/* 	 * If no name or backing file, for whatever reason, create a backing 	 * temporary file, saving the temp file name so we can later unlink 	 * it.  If the user never named this file, copy the temporary file name 	 * to the real name (we display that until the user renames it). 	 */
name|oname
operator|=
name|frp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_OPENERR
argument_list|)
operator|||
name|oname
operator|==
name|NULL
operator|||
name|stat
argument_list|(
name|oname
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tname
argument_list|,
sizeof|sizeof
argument_list|(
name|tname
argument_list|)
argument_list|,
literal|"%s/vi.XXXXXX"
argument_list|,
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_DIRECTORY
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"002|Unable to create temporary file"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|->
name|name
operator|==
name|NULL
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frp
operator|->
name|tname
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|frp
operator|->
name|name
operator|==
name|NULL
operator|&&
operator|(
name|frp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|tname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oname
operator|=
name|frp
operator|->
name|tname
expr_stmt|;
name|psize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_OPENERR
argument_list|)
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Try to keep it at 10 pages or less per file.  This 		 * isn't friendly on a loaded machine, btw. 		 */
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
literal|40
operator|*
literal|1024
condition|)
name|psize
operator|=
literal|4
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
literal|320
operator|*
literal|1024
condition|)
name|psize
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
else|else
name|psize
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|ep
operator|->
name|mdev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|ep
operator|->
name|minode
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
name|ep
operator|->
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|oname
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"003|Warning: %s is not a regular file"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set up recovery. */
name|memset
argument_list|(
operator|&
name|oinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|RECNOINFO
argument_list|)
argument_list|)
expr_stmt|;
name|oinfo
operator|.
name|bval
operator|=
literal|'\n'
expr_stmt|;
comment|/* Always set. */
name|oinfo
operator|.
name|psize
operator|=
name|psize
expr_stmt|;
name|oinfo
operator|.
name|flags
operator|=
name|F_ISSET
argument_list|(
name|sp
operator|->
name|gp
argument_list|,
name|G_SNAPSHOT
argument_list|)
condition|?
name|R_SNAPSHOT
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rcv_tmp
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
name|frp
operator|->
name|name
argument_list|)
condition|)
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|rcv_path
operator|=
name|strdup
argument_list|(
name|rcv_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|oinfo
operator|.
name|bfname
operator|=
name|ep
operator|->
name|rcv_path
expr_stmt|;
name|F_SET
argument_list|(
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
block|}
comment|/* Open a db structure. */
if|if
condition|(
operator|(
name|ep
operator|->
name|db
operator|=
name|dbopen
argument_list|(
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|NULL
argument_list|,
name|O_NONBLOCK
operator||
name|O_RDONLY
argument_list|,
name|DEFFILEMODE
argument_list|,
name|DB_RECNO
argument_list|,
operator|&
name|oinfo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|rcv_name
operator|==
name|NULL
condition|?
name|oname
else|:
name|rcv_name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * !!! 		 * Historically, vi permitted users to edit files that couldn't 		 * be read.  This isn't useful for single files from a command 		 * line, but it's quite useful for "vi *.c", since you can skip 		 * past files that you can't read. 		 */
name|open_err
operator|=
literal|1
expr_stmt|;
goto|goto
name|oerr
goto|;
block|}
comment|/* 	 * Do the remaining things that can cause failure of the new file, 	 * mark and logging initialization. 	 */
if|if
condition|(
name|mark_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
operator|||
name|log_init
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Set the alternate file name to be the file we're discarding. 	 * 	 * !!! 	 * Temporary files can't become alternate files, so there's no file 	 * name.  This matches historical practice, although it could only 	 * happen in historical vi as the result of the initial command, i.e. 	 * if vi was executed without a file name. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_SETALT
argument_list|)
condition|)
name|set_alt_name
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|frp
operator|==
name|NULL
operator|||
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|?
name|NULL
else|:
name|sp
operator|->
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Close the previous file; if that fails, close the new one and run 	 * for the border. 	 * 	 * !!! 	 * There's a nasty special case.  If the user edits a temporary file, 	 * and then does an ":e! %", we need to re-initialize the backing 	 * file, but we can't change the name.  (It's worse -- we're dealing 	 * with *names* here, we can't even detect that it happened.)  Set a 	 * flag so that the file_end routine ignores the backing information 	 * of the old file if it happens to be the same as the new one. 	 * 	 * !!! 	 * Side-effect: after the call to file_end(), sp->frp may be NULL. 	 */
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ep
operator|!=
name|NULL
operator|&&
name|file_end
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|file_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the file; if it's a recovery file, it should already be 	 * locked.  Note, we acquire the lock after the previous file 	 * has been ended, so that we don't get an "already locked" error 	 * for ":edit!". 	 * 	 * XXX 	 * While the user can't interrupt us between the open and here, 	 * there's a race between the dbopen() and the lock.  Not much 	 * we can do about it. 	 * 	 * XXX 	 * We don't make a big deal of not being able to lock the file.  As 	 * locking rarely works over NFS, and often fails if the file was 	 * mmap(2)'d, it's far too common to do anything like print an error 	 * message, let alone make the file readonly.  At some future time, 	 * when locking is a little more reliable, this should change to be 	 * an error. 	 */
if|if
condition|(
name|rcv_name
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|file_lock
argument_list|(
name|sp
argument_list|,
name|oname
argument_list|,
operator|&
name|ep
operator|->
name|fcntl_fd
argument_list|,
name|ep
operator|->
name|db
operator|->
name|fd
argument_list|(
name|ep
operator|->
name|db
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|LOCK_FAILED
case|:
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_UNLOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_UNAVAIL
case|:
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|oname
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"004|%s already locked, session is read-only"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCK_SUCCESS
case|:
break|break;
block|}
comment|/* 	 * The -R flag, or doing a "set readonly" during a session causes 	 * all files edited during the session (using an edit command, or 	 * even using tags) to be marked read-only.  Changing the file name 	 * (see ex/ex_file.c), clears this flag. 	 * 	 * Otherwise, try and figure out if a file is readonly.  This is a 	 * dangerous thing to do.  The kernel is the only arbiter of whether 	 * or not a file is writeable, and the best that a user program can 	 * do is guess.  Obvious loopholes are files that are on a file system 	 * mounted readonly (access catches this one on a few systems), or 	 * alternate protection mechanisms, ACL's for example, that we can't 	 * portably check.  Lots of fun, and only here because users whined. 	 * 	 * !!! 	 * Historic vi displayed the readonly message if none of the file 	 * write bits were set, or if an an access(2) call on the path 	 * failed.  This seems reasonable.  If the file is mode 444, root 	 * users may want to know that the owner of the file did not expect 	 * it to be written. 	 * 	 * Historic vi set the readonly bit if no write bits were set for 	 * a file, even if the access call would have succeeded.  This makes 	 * the superuser force the write even when vi expects that it will 	 * succeed.  I'm less supportive of this semantic, but it's historic 	 * practice and the conservative approach to vi'ing files as root. 	 * 	 * It would be nice if there was some way to update this when the user 	 * does a "^Z; chmod ...".  The problem is that we'd first have to 	 * distinguish between readonly bits set because of file permissions 	 * and those set for other reasons.  That's not too hard, but deciding 	 * when to reevaluate the permissions is trickier.  An alternative 	 * might be to turn off the readonly bit if the user forces a write 	 * and it succeeds. 	 * 	 * XXX 	 * Access(2) doesn't consider the effective uid/gid values.  This 	 * probably isn't a problem for vi when it's running standalone. 	 */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_READONLY
argument_list|)
operator|||
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NEWFILE
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|||
name|access
argument_list|(
name|frp
operator|->
name|name
argument_list|,
name|W_OK
argument_list|)
operator|)
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
expr_stmt|;
comment|/* 	 * Switch... 	 * 	 * !!! 	 * Note, because the EXF structure is examined at interrupt time, 	 * the underlying DB structures have to be consistent as soon as 	 * it's assigned to an SCR structure. 	 */
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
name|sp
operator|->
name|ep
operator|=
name|ep
expr_stmt|;
name|sp
operator|->
name|frp
operator|=
name|frp
expr_stmt|;
comment|/* Set the initial cursor position. */
name|file_cinit
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Redraw the screen from scratch. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SCR_REFORMAT
argument_list|)
expr_stmt|;
comment|/* Display file statistics. */
return|return
operator|(
name|msg_status
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|err
label|:
if|if
condition|(
name|frp
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|frp
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
name|oerr
label|:
if|if
condition|(
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_ON
argument_list|)
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
name|ep
operator|->
name|rcv_path
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|db
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|open_err
condition|?
name|file_init
argument_list|(
name|sp
argument_list|,
name|frp
argument_list|,
name|rcv_name
argument_list|,
name|flags
operator||
name|FS_OPENERR
argument_list|)
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_cinit --  *	Set up the initial cursor position.  */
end_comment

begin_function
name|void
name|file_cinit
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|MARK
name|m
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|nb
decl_stmt|;
comment|/* 	 * If in ex mode, move to the last line, first nonblank character. 	 * Otherwise, if the file has previously been edited, move to the 	 * last position, and check it for validity.  Otherwise, move to 	 * the first line, first nonblank.  This gets called by some the 	 * file init code, because we may be in a file of ex commands and 	 * we want to execute them from the right location in the file.  A 	 * few other places that want special case behavior also call here. 	 */
name|nb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IN_EX_MODE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* XXX:  If this fails, we're toast. */
operator|(
name|void
operator|)
name|file_lline
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|lno
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|lno
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|nb
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
name|sp
operator|->
name|frp
operator|->
name|lno
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_FNONBLANK
argument_list|)
condition|)
name|nb
operator|=
literal|1
expr_stmt|;
else|else
name|sp
operator|->
name|cno
operator|=
name|sp
operator|->
name|frp
operator|->
name|cno
expr_stmt|;
comment|/* If returning to a file in vi, center the line. */
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SCR_CENTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|nb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|file_gline
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|len
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|lno
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|nb
operator|&&
name|sp
operator|->
name|cno
operator|>
name|len
condition|)
name|nb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nb
condition|)
block|{
name|sp
operator|->
name|cno
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nonblank
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|lno
argument_list|,
operator|&
name|sp
operator|->
name|cno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * Historically, vi initialized the absolute mark, but ex did not. 	 * Which meant, that if the first command in ex mode was "visual", 	 * or if an ex command was executed first (e.g. vi +10 file) vi was 	 * entered without the mark being initialized.  For consistency, if 	 * the file isn't empty, we initialize it for everyone, believing 	 * that it can't hurt, and is generally useful.  Not initializing it 	 * if the file is empty is historic practice, although it has always 	 * been possible to set (and use) marks in empty vi files. 	 */
name|m
operator|.
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|m
operator|.
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
operator|(
name|void
operator|)
name|mark_set
argument_list|(
name|sp
argument_list|,
name|ABSMARK1
argument_list|,
operator|&
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * file_end --  *	Stop editing a file.  */
end_comment

begin_function
name|int
name|file_end
parameter_list|(
name|sp
parameter_list|,
name|ep
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|FREF
modifier|*
name|frp
decl_stmt|;
name|int
name|nf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * !!! 	 * ep MAY NOT BE THE SAME AS sp->ep, DON'T USE THE LATTER. 	 * (If argument ep is NULL, use sp->ep.) 	 */
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
comment|/* 	 * 	 * Clean up the FREF structure. 	 * 	 * Save the cursor location. 	 * 	 * XXX 	 * It would be cleaner to do this somewhere else, but by the time 	 * ex or vi knows that we're changing files it's already happened. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
name|frp
operator|->
name|lno
operator|=
name|sp
operator|->
name|lno
expr_stmt|;
name|frp
operator|->
name|cno
operator|=
name|sp
operator|->
name|cno
expr_stmt|;
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_CURSORSET
argument_list|)
expr_stmt|;
comment|/* 	 * We may no longer need the temporary backing file, so clean it 	 * up.  We don't need the FREF structure either, if the file was 	 * never named, so lose it. 	 * 	 * !!! 	 * Re: FR_DONTDELETE, see the comment above in file_init(). 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_DONTDELETE
argument_list|)
operator|&&
name|frp
operator|->
name|tname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|frp
operator|->
name|tname
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"005|%s: remove"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|frp
operator|->
name|tname
argument_list|)
expr_stmt|;
name|frp
operator|->
name|tname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|sp
operator|->
name|frefq
argument_list|,
name|frp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frp
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|frp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Clean up the EXF structure. 	 * 	 * If multiply referenced, just decrement the count and return. 	 */
if|if
condition|(
operator|--
name|ep
operator|->
name|refcnt
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Close the db structure. */
if|if
condition|(
name|ep
operator|->
name|db
operator|->
name|close
operator|!=
name|NULL
operator|&&
name|ep
operator|->
name|db
operator|->
name|close
argument_list|(
name|ep
operator|->
name|db
argument_list|)
operator|&&
operator|!
name|force
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|frp
operator|->
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"006|%s: close"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|ep
operator|->
name|refcnt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* COMMITTED TO THE CLOSE.  THERE'S NO GOING BACK... */
comment|/* Stop logging. */
operator|(
name|void
operator|)
name|log_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* Free up any marks. */
operator|(
name|void
operator|)
name|mark_end
argument_list|(
name|sp
argument_list|,
name|ep
argument_list|)
expr_stmt|;
comment|/* 	 * Delete recovery files, close the open descriptor, free recovery 	 * memory.  See recover.c for a description of the protocol. 	 * 	 * XXX 	 * Unlink backup file first, we can detect that the recovery file 	 * doesn't reference anything when the user tries to recover it. 	 * There's a race, here, obviously, but it's fairly small. 	 */
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|ep
argument_list|,
name|F_RCV_NORM
argument_list|)
condition|)
block|{
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|ep
operator|->
name|rcv_path
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"007|%s: remove"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
operator|&&
name|unlink
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|ep
operator|->
name|rcv_mpath
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"008|%s: remove"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ep
operator|->
name|fcntl_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|fcntl_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|ep
operator|->
name|rcv_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|rcv_mpath
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ep
operator|->
name|rcv_mpath
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|EXF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_write --  *	Write the file to disk.  Historic vi had fairly convoluted  *	semantics for whether or not writes would happen.  That's  *	why all the flags.  */
end_comment

begin_function
name|int
name|file_write
parameter_list|(
name|sp
parameter_list|,
name|fm
parameter_list|,
name|tm
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|MARK
modifier|*
name|fm
decl_stmt|,
decl|*
name|tm
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
enum|enum
block|{
name|NEWFILE
block|,
name|NONE
block|,
name|EXISTING
block|}
name|mtype
enum|;
name|struct
name|stat
name|sb
decl_stmt|;
name|EXF
modifier|*
name|ep
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|FREF
modifier|*
name|frp
decl_stmt|;
name|MARK
name|from
decl_stmt|,
name|to
decl_stmt|;
name|u_long
name|nlno
decl_stmt|,
name|nch
decl_stmt|;
name|int
name|btear
decl_stmt|,
name|fd
decl_stmt|,
name|nf
decl_stmt|,
name|noname
decl_stmt|,
name|oflags
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Writing '%', or naming the current file explicitly, has the 	 * same semantics as writing without a name. 	 */
name|frp
operator|=
name|sp
operator|->
name|frp
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|frp
operator|->
name|name
argument_list|)
condition|)
block|{
name|noname
operator|=
literal|1
expr_stmt|;
name|name
operator|=
name|frp
operator|->
name|name
expr_stmt|;
block|}
else|else
name|noname
operator|=
literal|0
expr_stmt|;
comment|/* Can't write files marked read-only, unless forced. */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
operator|&&
name|noname
operator|&&
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"009|Read-only file, not written; use ! to override"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"010|Read-only file, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If not forced, not appending, and "writeany" not set ... */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
operator|&&
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_WRITEANY
argument_list|)
condition|)
block|{
comment|/* Don't overwrite anything but the original file. */
if|if
condition|(
operator|(
operator|!
name|noname
operator|||
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
operator|)
operator|&&
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"011|%s exists, not written; use ! to override"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"012|%s exists, not written"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't write part of any existing file.  Only test for the 		 * original file, the previous test catches anything else. 		 */
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
operator|&&
name|noname
operator|&&
operator|!
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"013|Use ! to write a partial file"
argument_list|)
expr_stmt|;
else|else
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"014|Partial file, not written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Figure out if the file already exists -- if it doesn't, we display 	 * the "new file" message.  The stat might not be necessary, but we 	 * just repeat it because it's easier than hacking the previous tests. 	 * The information is only used for the user message and modification 	 * time test, so we can ignore the obvious race condition. 	 * 	 * If the user is overwriting a file other than the original file, and 	 * O_WRITEANY was what got us here (neither force nor append was set), 	 * display the "existing file" messsage.  Since the FR_NAMECHANGE flag 	 * is cleared on a successful write, the message only appears once when 	 * the user changes a file name.  This is historic practice. 	 * 	 * One final test.  If we're not forcing or appending, and we have a 	 * saved modification time, object if the file was changed since we 	 * last edited or wrote it, and make them force it. 	 */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|mtype
operator|=
name|NEWFILE
expr_stmt|;
else|else
block|{
name|mtype
operator|=
name|NONE
expr_stmt|;
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
operator||
name|FS_APPEND
argument_list|)
condition|)
block|{
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|mtime
operator|!=
literal|0
operator|&&
operator|(
name|sb
operator|.
name|st_dev
operator|!=
name|sp
operator|->
name|ep
operator|->
name|mdev
operator|||
name|sb
operator|.
name|st_ino
operator|!=
name|ep
operator|->
name|minode
operator|||
name|sb
operator|.
name|st_mtime
operator|!=
name|ep
operator|->
name|mtime
operator|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"016|%s: file modified more recently than this copy; use ! to override"
else|:
literal|"017|%s: file modified more recently than this copy"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|noname
operator|||
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
condition|)
name|mtype
operator|=
name|EXISTING
expr_stmt|;
block|}
block|}
comment|/* Set flags to either append or truncate. */
name|oflags
operator|=
name|O_CREAT
operator||
name|O_WRONLY
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
name|oflags
operator||=
name|O_APPEND
expr_stmt|;
else|else
name|oflags
operator||=
name|O_TRUNC
expr_stmt|;
comment|/* Backup the file if requested. */
name|p
operator|=
name|O_STR
argument_list|(
name|sp
argument_list|,
name|O_BACKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|file_backup
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
operator|&&
operator|!
name|LF_ISSET
argument_list|(
name|FS_FORCE
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Open the file. */
name|SIGBLOCK
argument_list|(
name|sp
operator|->
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|oflags
argument_list|,
name|DEFFILEMODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|SIGUNBLOCK
argument_list|(
name|sp
operator|->
name|gp
argument_list|)
expr_stmt|;
comment|/* Try and get a lock. */
if|if
condition|(
operator|!
name|noname
operator|&&
name|file_lock
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|==
name|LOCK_UNAVAIL
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"265|%s: write lock was unavailable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|__linux__
comment|/* 	 * In libc 4.5.x, fdopen(fd, "w") clears the O_APPEND flag (if set). 	 * This bug is fixed in libc 4.6.x. 	 * 	 * This code works around this problem for libc 4.5.x users. 	 * Note that this code is harmless if you're using libc 4.6.x. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
operator|&&
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Use stdio for buffering. */
if|if
condition|(
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Build fake addresses, if necessary. */
if|if
condition|(
name|fm
operator|==
name|NULL
condition|)
block|{
name|from
operator|.
name|lno
operator|=
literal|1
expr_stmt|;
name|from
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|fm
operator|=
operator|&
name|from
expr_stmt|;
if|if
condition|(
name|file_lline
argument_list|(
name|sp
argument_list|,
operator|&
name|to
operator|.
name|lno
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|to
operator|.
name|cno
operator|=
literal|0
expr_stmt|;
name|tm
operator|=
operator|&
name|to
expr_stmt|;
block|}
comment|/* Turn on the busy message. */
name|btear
operator|=
name|F_ISSET
argument_list|(
name|sp
argument_list|,
name|S_EXSILENT
argument_list|)
condition|?
literal|0
else|:
operator|!
name|busy_on
argument_list|(
name|sp
argument_list|,
literal|"Writing..."
argument_list|)
expr_stmt|;
name|rval
operator|=
name|ex_writefp
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|fp
argument_list|,
name|fm
argument_list|,
name|tm
argument_list|,
operator|&
name|nlno
argument_list|,
operator|&
name|nch
argument_list|)
expr_stmt|;
if|if
condition|(
name|btear
condition|)
name|busy_off
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * Save the new last modification time -- even if the write fails 	 * we re-init the time.  That way the user can clean up the disk 	 * and rewrite without having to force it. 	 */
if|if
condition|(
name|noname
condition|)
block|{
name|ep
operator|=
name|sp
operator|->
name|ep
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|ep
operator|->
name|mtime
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|mdev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|ep
operator|->
name|minode
operator|=
name|sb
operator|.
name|st_ino
expr_stmt|;
name|ep
operator|->
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
block|}
comment|/* If the write failed, complain loudly. */
if|if
condition|(
name|rval
condition|)
block|{
if|if
condition|(
operator|!
name|LF_ISSET
argument_list|(
name|FS_APPEND
argument_list|)
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"019|%s: WARNING: FILE TRUNCATED"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Once we've actually written the file, it doesn't matter that the 	 * file name was changed -- if it was, we've already whacked it. 	 */
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_NAMECHANGE
argument_list|)
expr_stmt|;
comment|/* 	 * If wrote the entire file clear the modified bit.  If the file was 	 * written back to the original file name and the file is a temporary, 	 * set the "no exit" bit.  This permits the user to write the file and 	 * use it in the context of the file system, but still keeps them from 	 * losing their changes by exiting. 	 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|FS_ALL
argument_list|)
condition|)
block|{
name|F_CLR
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|frp
argument_list|,
name|FR_TMPFILE
argument_list|)
condition|)
if|if
condition|(
name|noname
condition|)
name|F_SET
argument_list|(
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
expr_stmt|;
else|else
name|F_CLR
argument_list|(
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|EXISTING
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"015|Interrupted write: %s: existing file: %lu lines, %lu characters"
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWFILE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"018|Interrupted write: %s: new file: %lu lines, %lu characters"
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
case|case
name|NONE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"020|Interrupted write: %s: %lu lines, %lu characters"
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|EXISTING
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"025|%s: existing file: %lu lines, %lu characters"
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWFILE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"092|%s: new file: %lu lines, %lu characters"
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
case|case
name|NONE
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"093|%s: %lu lines, %lu characters"
argument_list|,
name|p
argument_list|,
name|nlno
argument_list|,
name|nch
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file_backup --  *	Backup the about-to-be-written file.  *  * XXX  * We do the backup by copying the entire file.  It would be nice to do  * a rename instead, but: (1) both files may not fit and we want to fail  * before doing the rename; (2) the backup file may not be on the same  * disk partition as the file being written; (3) there may be optional  * file information (MACs, DACs, whatever) that we won't get right if we  * recreate the file.  So, let's not risk it.  */
end_comment

begin_function
specifier|static
name|int
name|file_backup
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|bname
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|bname
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|ARGS
modifier|*
name|ap
index|[
literal|2
index|]
decl_stmt|,
name|a
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|EXCMDARG
name|cmd
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|size_t
name|blen
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|maxnum
decl_stmt|,
name|nf
decl_stmt|,
name|nr
decl_stmt|,
name|num
decl_stmt|,
name|nw
decl_stmt|,
name|rfd
decl_stmt|,
name|wfd
decl_stmt|,
name|version
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|estr
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|pct
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|wfname
decl_stmt|,
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|rfd
operator|=
name|wfd
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|estr
operator|=
name|wfname
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Open the current file for reading.  Do this first, so that 	 * we don't exec a shell before the most likely failure point. 	 * If it doesn't exist, it's okay, there's just nothing to back 	 * up. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|estr
operator|=
name|name
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * If the name starts with an 'N' character, add a version number 	 * to the name.  Strip the leading N from the string passed to the 	 * expansion routines, for no particular reason.  It would be nice 	 * to permit users to put the version number anywhere in the backup 	 * name, but there isn't a special character that we can use in the 	 * name, and giving a new character a special meaning leads to ugly 	 * hacks both here and in the supporting ex routines. 	 * 	 * Shell and file name expand the option's value. 	 */
name|argv_init
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|ex_cbuild
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ap
argument_list|,
operator|&
name|a
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bname
index|[
literal|0
index|]
operator|==
literal|'N'
condition|)
block|{
name|version
operator|=
literal|1
expr_stmt|;
operator|++
name|bname
expr_stmt|;
block|}
else|else
name|version
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv_exp2
argument_list|(
name|sp
argument_list|,
operator|&
name|cmd
argument_list|,
name|bname
argument_list|,
name|strlen
argument_list|(
name|bname
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 *  0 args: impossible. 	 *  1 args: use it. 	 *>1 args: object, too many args. 	 */
if|if
condition|(
name|cmd
operator|.
name|argc
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|bname
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"256|%s expanded into too many file names"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If appending a version number, read through the directory, looking 	 * for file names that match the name followed by a number.  Make all 	 * of the other % characters in name literal, so the user doesn't get 	 * surprised and sscanf doesn't drop core indirecting through pointers 	 * that don't exist.  If any such files are found, increment its number 	 * by one. 	 */
if|if
condition|(
name|version
condition|)
block|{
name|GET_SPACE_GOTO
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|,
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|len
operator|*
literal|2
operator|+
literal|50
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|bp
operator|,
name|slash
operator|=
name|NULL
operator|,
name|p
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
init|;
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|;
operator|*
name|t
operator|++
operator|=
operator|*
name|p
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|'%'
condition|)
operator|*
name|t
operator|++
operator|=
literal|'%'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|slash
operator|=
name|t
expr_stmt|;
name|pct
operator|=
name|t
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'d'
expr_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
block|{
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|p
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
name|p
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|estr
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|maxnum
operator|=
literal|0
init|;
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
name|sscanf
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|p
argument_list|,
operator|&
name|num
argument_list|)
operator|==
literal|1
operator|&&
name|num
operator|>
name|maxnum
condition|)
name|maxnum
operator|=
name|num
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* Format the backup file name. */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pct
argument_list|,
name|blen
operator|-
operator|(
name|pct
operator|-
name|bp
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|maxnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wfname
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|wfname
operator|=
name|cmd
operator|.
name|argv
index|[
literal|0
index|]
operator|->
name|bp
expr_stmt|;
block|}
comment|/* Open the backup file, avoiding lurkers. */
if|if
condition|(
name|stat
argument_list|(
name|wfname
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|t
operator|=
literal|"257|%s: not a regular file"
expr_stmt|;
goto|goto
name|perm
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_uid
operator|!=
name|getuid
argument_list|()
condition|)
block|{
name|t
operator|=
literal|"258|%s: not owned by you"
expr_stmt|;
goto|goto
name|perm
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
operator|)
condition|)
block|{
name|t
operator|=
literal|"259|%s: accessible by a user other than the owner"
expr_stmt|;
name|perm
label|:
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|bname
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|flags
operator|=
name|O_TRUNC
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|O_CREAT
operator||
name|O_EXCL
expr_stmt|;
if|if
condition|(
operator|(
name|wfd
operator|=
name|open
argument_list|(
name|wfname
argument_list|,
name|flags
operator||
name|O_WRONLY
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|estr
operator|=
name|bname
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Copy the file's current contents to its backup value. */
while|while
condition|(
operator|(
name|nr
operator|=
name|read
argument_list|(
name|rfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|off
operator|=
literal|0
init|;
name|nr
operator|!=
literal|0
condition|;
name|nr
operator|-=
name|nw
operator|,
name|off
operator|+=
name|nw
control|)
if|if
condition|(
operator|(
name|nw
operator|=
name|write
argument_list|(
name|wfd
argument_list|,
name|buf
operator|+
name|off
argument_list|,
name|nr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|estr
operator|=
name|wfname
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
block|{
name|estr
operator|=
name|name
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|close
argument_list|(
name|rfd
argument_list|)
condition|)
block|{
name|estr
operator|=
name|name
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|close
argument_list|(
name|wfd
argument_list|)
condition|)
block|{
name|estr
operator|=
name|wfname
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|binc_err
label|:
name|err
label|:
if|if
condition|(
name|rfd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|rfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|wfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|wfd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|estr
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|estr
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|bp
argument_list|,
name|blen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * file_m1 --  * 	First modification check routine.  The :next, :prev, :rewind, :tag,  *	:tagpush, :tagpop, ^^ modifications check.  */
end_comment

begin_function
name|int
name|file_m1
parameter_list|(
name|sp
parameter_list|,
name|force
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|force
decl_stmt|,
name|flags
decl_stmt|;
block|{
comment|/* If no file loaded, return no modifications. */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the file has been modified, we'll want to write it back or 	 * fail.  If autowrite is set, we'll write it back automatically, 	 * unless force is also set.  Otherwise, we fail unless forced or 	 * there's another open screen on this file. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOWRITE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|file_aw
argument_list|(
name|sp
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
name|LF_ISSET
argument_list|(
name|FS_POSSIBLE
argument_list|)
condition|?
literal|"021|File modified since last complete write; write or use ! to override"
else|:
literal|"022|File modified since last complete write; write or use :edit! to override"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_m3
argument_list|(
name|sp
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_m2 --  * 	Second modification check routine.  The :edit, :quit, :recover  *	modifications check.  */
end_comment

begin_function
name|int
name|file_m2
parameter_list|(
name|sp
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
comment|/* If no file loaded, return no modifications. */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the file has been modified, we'll want to fail, unless forced 	 * or there's another open screen on this file. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
operator|&&
name|sp
operator|->
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"023|File modified since last complete write; write or use ! to override"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|file_m3
argument_list|(
name|sp
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_m3 --  * 	Third modification check routine.  */
end_comment

begin_function
name|int
name|file_m3
parameter_list|(
name|sp
parameter_list|,
name|force
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
comment|/* If no file loaded, return no modifications. */
if|if
condition|(
name|sp
operator|->
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Don't exit while in a temporary files if the file was ever modified. 	 * The problem is that if the user does a ":wq", we write and quit, 	 * unlinking the temporary file.  Not what the user had in mind at all. 	 * We permit writing to temporary files, so that user maps using file 	 * system names work with temporary files. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_TMPEXIT
argument_list|)
operator|&&
name|sp
operator|->
name|ep
operator|->
name|refcnt
operator|<=
literal|1
operator|&&
operator|!
name|force
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"024|File is a temporary; exit will discard modifications"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_aw --  *	Autowrite routine.  If modified, autowrite is set and the readonly bit  *	is not set, write the file.  A routine so there's a place to put the  *	comment.  */
end_comment

begin_function
name|int
name|file_aw
parameter_list|(
name|sp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|sp
operator|->
name|ep
argument_list|,
name|F_MODIFIED
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_AUTOWRITE
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * !!! 	 * Historic 4BSD vi attempted to write the file if autowrite was set, 	 * regardless of the writeability of the file (as defined by the file 	 * readonly flag).  System V changed this as some point, not attempting 	 * autowrite if the file was readonly.  This feels like a bug fix to 	 * me (e.g. the principle of least surprise is violated if readonly is 	 * set and vi writes the file), so I'm compatible with System V. 	 */
if|if
condition|(
name|F_ISSET
argument_list|(
name|sp
operator|->
name|frp
argument_list|,
name|FR_RDONLY
argument_list|)
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_INFO
argument_list|,
literal|"268|File readonly, modifications not auto-written"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|file_write
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file_lock --  *	Get an exclusive lock on a file.  *  * XXX  * The default locking is flock(2) style, not fcntl(2).  The latter is  * known to fail badly on some systems, and its only advantage is that  * it occasionally works over NFS.  *  * Furthermore, the semantics of fcntl(2) are wrong.  The problems are  * two-fold: you can't close any file descriptor associated with the file  * without losing all of the locks, and you can't get an exclusive lock  * unless you have the file open for writing.  Someone ought to be shot,  * but it's probably too late, they may already have reproduced.  To get  * around these problems, nvi opens the files for writing when it can and  * acquires a second file descriptor when it can't.  The recovery files  * are examples of the former, they're always opened for writing.  The DB  * files can't be opened for writing because the semantics of DB are that  * files opened for writing are flushed back to disk when the DB session  * is ended. So, in that case we have to acquire an extra file descriptor.  */
end_comment

begin_function
name|enum
name|lockt
name|file_lock
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|fdp
parameter_list|,
name|fd
parameter_list|,
name|iswrite
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|fd
decl_stmt|,
decl|*
name|fdp
decl_stmt|,
name|iswrite
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_LOCK
argument_list|)
condition|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|USE_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|LOCK_EX
argument_list|)
comment|/* Hurrah!  We've got flock(2). */
comment|/* 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Flock is documented 	 * as returning EWOULDBLOCK; add EAGAIN for good measure, and assume 	 * they are the former.  There's no portable way to do this. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|?
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|?
name|LOCK_UNAVAIL
else|:
name|LOCK_FAILED
else|:
name|LOCK_SUCCESS
operator|)
return|;
else|#
directive|else
comment|/* Gag me.  We've got fcntl(2). */
block|{
name|struct
name|flock
name|arg
decl_stmt|;
name|int
name|didopen
decl_stmt|,
name|sverrno
decl_stmt|;
name|arg
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
name|arg
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
comment|/* SEEK_SET */
name|arg
operator|.
name|l_start
operator|=
name|arg
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|arg
operator|.
name|l_pid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the file descriptor isn't opened for writing, it must fail. 	 * If we fail because we can't get a read/write file descriptor, 	 * we return LOCK_SUCCESS, believing that the file is readonly 	 * and that will be sufficient to warn the user. 	 */
if|if
condition|(
operator|!
name|iswrite
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|fdp
operator|==
name|NULL
condition|)
return|return
operator|(
name|LOCK_FAILED
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
operator|*
name|fdp
operator|=
name|fd
expr_stmt|;
name|didopen
operator|=
literal|1
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
return|return
operator|(
name|LOCK_SUCCESS
operator|)
return|;
if|if
condition|(
name|didopen
condition|)
block|{
name|sverrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|sverrno
expr_stmt|;
block|}
comment|/* 	 * !!! 	 * We need to distinguish a lock not being available for the file 	 * from the file system not supporting locking.  Fcntl is documented 	 * as returning EACCESS and EAGAIN; add EWOULDBLOCK for good measure, 	 * and assume they are the former.  There's no portable way to do this. 	 */
return|return
operator|(
name|errno
operator|==
name|EACCES
operator|||
name|errno
operator|==
name|EAGAIN
operator|||
name|errno
operator|==
name|EWOULDBLOCK
condition|?
name|LOCK_UNAVAIL
else|:
name|LOCK_FAILED
operator|)
return|;
block|}
endif|#
directive|endif
block|}
end_block

end_unit

