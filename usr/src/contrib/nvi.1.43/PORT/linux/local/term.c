begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)term.c	9.6 (Berkeley) 12/2/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<bitstring.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"compat.h"
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/*  * If we're reading less than 20 characters, up the size of the tty buffer.  * This shouldn't ever happen, other than the first time through, but it's  * possible if a map is large enough.  */
end_comment

begin_define
define|#
directive|define
name|term_read_grow
parameter_list|(
name|sp
parameter_list|)
define|\
value|(sp)->gp->i_nelem - ((sp)->gp->i_cnt + (sp)->gp->i_next)>= 20 ?\ 	0 : __term_read_grow(sp, 64)
end_define

begin_decl_stmt
specifier|static
name|int
name|keycmp
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|term_key_set
name|__P
argument_list|(
operator|(
name|GS
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|__term_read_grow
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * !!!  * Historic vi always used:  *  *	^D: autoindent deletion  *	^H: last character deletion  *	^W: last word deletion  *	^Q: quote the next character (if not used in flow control).  *	^V: quote the next character  *  * regardless of the user's choices for these characters.  The user's erase  * and kill characters worked in addition to these characters.  Nvi wires  * down the above characters, but in addition permits the VEOF, VERASE, VKILL  * and VWERASE characters described by the user's termios structure.  *  * Ex was not consistent with this scheme, as it historically ran in tty  * cooked mode.  This meant that the scroll command and autoindent erase  * characters were mapped to the user's EOF character, and the character  * and word deletion characters were the user's tty character and word  * deletion characters.  This implementation makes it all consistent, as  * described above for vi.  *  * XXX  * THIS REQUIRES THAT ALL SCREENS SHARE A SPECIAL KEY SET.  */
end_comment

begin_decl_stmt
name|KEYLIST
name|keylist
index|[]
init|=
block|{
block|{
name|K_BACKSLASH
block|,
literal|'\\'
block|}
block|,
comment|/*  \ */
block|{
name|K_CARAT
block|,
literal|'^'
block|}
block|,
comment|/*  ^ */
block|{
name|K_CNTRLD
block|,
literal|'\004'
block|}
block|,
comment|/* ^D */
block|{
name|K_CNTRLR
block|,
literal|'\022'
block|}
block|,
comment|/* ^R */
block|{
name|K_CNTRLT
block|,
literal|'\024'
block|}
block|,
comment|/* ^T */
block|{
name|K_CNTRLZ
block|,
literal|'\032'
block|}
block|,
comment|/* ^Z */
block|{
name|K_COLON
block|,
literal|':'
block|}
block|,
comment|/*  : */
block|{
name|K_CR
block|,
literal|'\r'
block|}
block|,
comment|/* \r */
block|{
name|K_ESCAPE
block|,
literal|'\033'
block|}
block|,
comment|/* ^[ */
block|{
name|K_FORMFEED
block|,
literal|'\f'
block|}
block|,
comment|/* \f */
block|{
name|K_HEXCHAR
block|,
literal|'\030'
block|}
block|,
comment|/* ^X */
block|{
name|K_NL
block|,
literal|'\n'
block|}
block|,
comment|/* \n */
block|{
name|K_RIGHTBRACE
block|,
literal|'}'
block|}
block|,
comment|/*  } */
block|{
name|K_RIGHTPAREN
block|,
literal|')'
block|}
block|,
comment|/*  ) */
block|{
name|K_TAB
block|,
literal|'\t'
block|}
block|,
comment|/* \t */
block|{
name|K_VERASE
block|,
literal|'\b'
block|}
block|,
comment|/* \b */
block|{
name|K_VKILL
block|,
literal|'\025'
block|}
block|,
comment|/* ^U */
block|{
name|K_VLNEXT
block|,
literal|'\021'
block|}
block|,
comment|/* ^Q */
block|{
name|K_VLNEXT
block|,
literal|'\026'
block|}
block|,
comment|/* ^V */
block|{
name|K_VWERASE
block|,
literal|'\027'
block|}
block|,
comment|/* ^W */
block|{
name|K_ZERO
block|,
literal|'0'
block|}
block|,
comment|/*  0 */
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
comment|/* VEOF, VERASE, VKILL, VWERASE */
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|,
block|{
name|K_NOTUSED
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nkeylist
init|=
operator|(
sizeof|sizeof
argument_list|(
name|keylist
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
operator|)
operator|-
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * term_init --  *	Initialize the special key lookup table.  */
end_comment

begin_function
name|int
name|term_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|KEYLIST
modifier|*
name|kp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* 	 * XXX 	 * 8-bit only, for now.  Recompilation should get you any 	 * 8-bit character set, as long as nul isn't a character. 	 */
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * In libc 4.5.26, setlocale(LC_ALL, ""), doesn't setup 	 * table for ctype(3c) correctly. 	 * This bug is fixed in libc 4.6.x. 	 * 	 * This code works around this problem for libc 4.5.x users. 	 * Note that this code is harmless if you're using libc 4.6.x. 	 */
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|key_init
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
ifdef|#
directive|ifdef
name|VEOF
name|term_key_set
argument_list|(
name|gp
argument_list|,
name|VEOF
argument_list|,
name|K_CNTRLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VERASE
name|term_key_set
argument_list|(
name|gp
argument_list|,
name|VERASE
argument_list|,
name|K_VERASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VKILL
name|term_key_set
argument_list|(
name|gp
argument_list|,
name|VKILL
argument_list|,
name|K_VKILL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VWERASE
name|term_key_set
argument_list|(
name|gp
argument_list|,
name|VWERASE
argument_list|,
name|K_VWERASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sort the special key list. */
name|qsort
argument_list|(
name|keylist
argument_list|,
name|nkeylist
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|keycmp
argument_list|)
expr_stmt|;
comment|/* Initialize the fast lookup table. */
for|for
control|(
name|gp
operator|->
name|max_special
operator|=
literal|0
operator|,
name|kp
operator|=
name|keylist
operator|,
name|cnt
operator|=
name|nkeylist
init|;
name|cnt
operator|--
condition|;
operator|++
name|kp
control|)
block|{
if|if
condition|(
name|gp
operator|->
name|max_special
operator|<
name|kp
operator|->
name|value
condition|)
name|gp
operator|->
name|max_special
operator|=
name|kp
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|kp
operator|->
name|ch
operator|<=
name|MAX_FAST_KEY
condition|)
name|gp
operator|->
name|special_key
index|[
name|kp
operator|->
name|ch
index|]
operator|=
name|kp
operator|->
name|value
expr_stmt|;
block|}
comment|/* Find a non-printable character to use as a message separator. */
for|for
control|(
name|ch
operator|=
literal|1
init|;
name|ch
operator|<=
name|MAX_CHAR_T
condition|;
operator|++
name|ch
control|)
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|gp
operator|->
name|noprint
operator|=
name|ch
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|!=
name|gp
operator|->
name|noprint
condition|)
block|{
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"090|No non-printable character found"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term_key_set --  *	Set keys found in the termios structure.  *  * VEOF, VERASE and VKILL are required by POSIX 1003.1-1990, VWERASE is  * a 4.4BSD extension.  We've left four open slots in the keylist table,  * if these values exist, put them into place.  Note, they may reset (or  * duplicate) values already in the table, so we check for that first.  */
end_comment

begin_function
specifier|static
name|void
name|term_key_set
parameter_list|(
name|gp
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
name|GS
modifier|*
name|gp
decl_stmt|;
name|int
name|name
decl_stmt|,
name|val
decl_stmt|;
block|{
name|KEYLIST
modifier|*
name|kp
decl_stmt|;
name|cc_t
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|F_ISSET
argument_list|(
name|gp
argument_list|,
name|G_TERMIOS_SET
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ch
operator|=
name|gp
operator|->
name|original_termios
operator|.
name|c_cc
index|[
name|name
index|]
operator|)
operator|==
name|_POSIX_VDISABLE
condition|)
return|return;
comment|/* Check for duplication. */
for|for
control|(
name|kp
operator|=
name|keylist
init|;
name|kp
operator|->
name|value
operator|!=
name|K_NOTUSED
condition|;
operator|++
name|kp
control|)
if|if
condition|(
name|kp
operator|->
name|ch
operator|==
name|ch
condition|)
block|{
name|kp
operator|->
name|value
operator|=
name|val
expr_stmt|;
return|return;
block|}
comment|/* Add a new entry. */
if|if
condition|(
name|kp
operator|->
name|value
operator|==
name|K_NOTUSED
condition|)
block|{
name|keylist
index|[
name|nkeylist
index|]
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|keylist
index|[
name|nkeylist
index|]
operator|.
name|value
operator|=
name|val
expr_stmt|;
operator|++
name|nkeylist
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * key_init --  *	Build the fast-lookup key display array.  */
end_comment

begin_function
name|void
name|key_init
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|CHAR_T
name|ch
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
for|for
control|(
name|gp
operator|=
name|sp
operator|->
name|gp
operator|,
name|ch
operator|=
literal|0
init|;
name|ch
operator|<=
name|MAX_FAST_KEY
condition|;
operator|++
name|ch
control|)
for|for
control|(
name|p
operator|=
name|gp
operator|->
name|cname
index|[
name|ch
index|]
operator|.
name|name
operator|,
name|t
operator|=
name|__key_name
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
operator|,
name|len
operator|=
name|gp
operator|->
name|cname
index|[
name|ch
index|]
operator|.
name|len
operator|=
name|sp
operator|->
name|clen
init|;
name|len
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * __key_len --  *	Return the length of the string that will display the key.  *	This routine is the backup for the KEY_LEN() macro.  */
end_comment

begin_function
name|size_t
name|__key_len
parameter_list|(
name|sp
parameter_list|,
name|ch
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|ch
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|__key_name
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|clen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * __key_name --  *	Return the string that will display the key.  This routine  *	is the backup for the KEY_NAME() macro.  */
end_comment

begin_function
name|CHAR_T
modifier|*
name|__key_name
parameter_list|(
name|sp
parameter_list|,
name|ach
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|ach
decl_stmt|;
block|{
specifier|static
specifier|const
name|CHAR_T
name|hexdigit
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
specifier|static
specifier|const
name|CHAR_T
name|octdigit
index|[]
init|=
literal|"01234567"
decl_stmt|;
name|CHAR_T
name|ch
decl_stmt|,
modifier|*
name|chp
decl_stmt|,
name|mask
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|shift
decl_stmt|;
comment|/* 	 * Historical (ARPA standard) mappings.  Printable characters are left 	 * alone.  Control characters less than '\177' are represented as '^' 	 * followed by the character offset from the '@' character in the ASCII 	 * map.  '\177' is represented as '^' followed by '?'. 	 * 	 * XXX 	 * The following code depends on the current locale being identical to 	 * the ASCII map from '\100' to '\076' (\076 since that's the largest 	 * character for which we can offset from '@' and get something that's 	 * a printable character in ASCII.  I'm told that this is a reasonable 	 * assumption... 	 * 	 * XXX 	 * This code will only work with CHAR_T's that are multiples of 8-bit 	 * bytes. 	 * 	 * XXX 	 * NB: There's an assumption here that all printable characters take 	 * up a single column on the screen.  This is not always correct. 	 */
name|ch
operator|=
name|ach
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<=
literal|'\076'
operator|&&
name|iscntrl
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|1
index|]
operator|=
name|ch
operator|==
literal|'\177'
condition|?
literal|'?'
else|:
literal|'@'
operator|+
name|ch
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_OCTAL
argument_list|)
condition|)
block|{
define|#
directive|define
name|BITS
value|(sizeof(CHAR_T) * 8)
define|#
directive|define
name|SHIFT
value|(BITS - BITS % 3)
define|#
directive|define
name|TOPMASK
value|(BITS % 3 == 2 ? 3 : 1)<< (BITS - BITS % 3)
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|1
index|]
operator|=
name|octdigit
index|[
operator|(
name|ch
operator|&
name|TOPMASK
operator|)
operator|>>
name|SHIFT
index|]
expr_stmt|;
name|shift
operator|=
name|SHIFT
operator|-
literal|3
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|2
operator|,
name|mask
operator|=
literal|7
operator|<<
operator|(
name|SHIFT
operator|-
literal|3
operator|)
operator|,
name|cnt
operator|=
name|BITS
operator|/
literal|3
init|;
name|cnt
operator|--
operator|>
literal|0
condition|;
name|mask
operator|>>=
literal|3
operator|,
name|shift
operator|-=
literal|3
control|)
name|sp
operator|->
name|cname
index|[
name|len
operator|++
index|]
operator|=
name|octdigit
index|[
operator|(
name|ch
operator|&
name|mask
operator|)
operator|>>
name|shift
index|]
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|cname
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|sp
operator|->
name|cname
index|[
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|2
operator|,
name|chp
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|ch
operator|,
name|cnt
operator|=
sizeof|sizeof
argument_list|(
name|CHAR_T
argument_list|)
init|;
name|cnt
operator|--
operator|>
literal|0
condition|;
operator|++
name|chp
control|)
block|{
name|sp
operator|->
name|cname
index|[
name|len
operator|++
index|]
operator|=
name|hexdigit
index|[
operator|(
operator|*
name|chp
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|sp
operator|->
name|cname
index|[
name|len
operator|++
index|]
operator|=
name|hexdigit
index|[
operator|*
name|chp
operator|&
literal|0x0f
index|]
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|cname
index|[
name|sp
operator|->
name|clen
operator|=
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|cname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term_push --  *	Push keys onto the front of a buffer.  *  * There is a single input buffer in ex/vi.  Characters are read onto the  * end of the buffer by the terminal input routines, and pushed onto the  * front of the buffer by various other functions in ex/vi.  Each key has  * an associated flag value, which indicates if it has already been quoted,  * if it is the result of a mapping or an abbreviation, as well as a count  * of the number of times it has been mapped.  */
end_comment

begin_function
name|int
name|term_push
parameter_list|(
name|sp
parameter_list|,
name|s
parameter_list|,
name|nchars
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CHAR_T
modifier|*
name|s
decl_stmt|;
comment|/* Characters. */
name|size_t
name|nchars
decl_stmt|;
comment|/* Number of chars. */
name|u_int
name|flags
decl_stmt|;
comment|/* CH_* flags. */
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|total
decl_stmt|;
comment|/* If we have room, stuff the keys into the buffer. */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
name|nchars
operator|<=
name|gp
operator|->
name|i_next
operator|||
operator|(
name|gp
operator|->
name|i_ch
operator|!=
name|NULL
operator|&&
name|gp
operator|->
name|i_cnt
operator|==
literal|0
operator|&&
name|nchars
operator|<=
name|gp
operator|->
name|i_nelem
operator|)
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|i_cnt
operator|!=
literal|0
condition|)
name|gp
operator|->
name|i_next
operator|-=
name|nchars
expr_stmt|;
name|gp
operator|->
name|i_cnt
operator|+=
name|nchars
expr_stmt|;
name|MEMMOVE
argument_list|(
name|gp
operator|->
name|i_ch
operator|+
name|gp
operator|->
name|i_next
argument_list|,
name|s
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|MEMSET
argument_list|(
name|gp
operator|->
name|i_chf
operator|+
name|gp
operator|->
name|i_next
argument_list|,
name|flags
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If there are currently characters in the queue, shift them up, 	 * leaving some extra room.  Get enough space plus a little extra. 	 */
define|#
directive|define
name|TERM_PUSH_SHIFT
value|30
name|total
operator|=
name|gp
operator|->
name|i_cnt
operator|+
name|gp
operator|->
name|i_next
operator|+
name|nchars
operator|+
name|TERM_PUSH_SHIFT
expr_stmt|;
if|if
condition|(
name|total
operator|>=
name|gp
operator|->
name|i_nelem
operator|&&
name|__term_read_grow
argument_list|(
name|sp
argument_list|,
name|MAX
argument_list|(
name|total
argument_list|,
literal|64
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|gp
operator|->
name|i_cnt
condition|)
block|{
name|MEMMOVE
argument_list|(
name|gp
operator|->
name|i_ch
operator|+
name|TERM_PUSH_SHIFT
operator|+
name|nchars
argument_list|,
name|gp
operator|->
name|i_ch
operator|+
name|gp
operator|->
name|i_next
argument_list|,
name|gp
operator|->
name|i_cnt
argument_list|)
expr_stmt|;
name|MEMMOVE
argument_list|(
name|gp
operator|->
name|i_chf
operator|+
name|TERM_PUSH_SHIFT
operator|+
name|nchars
argument_list|,
name|gp
operator|->
name|i_chf
operator|+
name|gp
operator|->
name|i_next
argument_list|,
name|gp
operator|->
name|i_cnt
argument_list|)
expr_stmt|;
block|}
comment|/* Put the new characters into the queue. */
name|gp
operator|->
name|i_next
operator|=
name|TERM_PUSH_SHIFT
expr_stmt|;
name|gp
operator|->
name|i_cnt
operator|+=
name|nchars
expr_stmt|;
name|MEMMOVE
argument_list|(
name|gp
operator|->
name|i_ch
operator|+
name|TERM_PUSH_SHIFT
argument_list|,
name|s
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
name|MEMSET
argument_list|(
name|gp
operator|->
name|i_chf
operator|+
name|TERM_PUSH_SHIFT
argument_list|,
name|flags
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove characters from the queue, simultaneously clearing the flag  * and map counts.  */
end_comment

begin_define
define|#
directive|define
name|QREM_HEAD
parameter_list|(
name|len
parameter_list|)
value|{						\ 	size_t __off = gp->i_next;					\ 	if (len == 1)							\ 		gp->i_chf[__off] = 0;					\ 	else								\ 		MEMSET(gp->i_chf + __off, 0, len);			\ 	if ((gp->i_cnt -= len) == 0)					\ 		gp->i_next = 0;						\ 	else								\ 		gp->i_next += len;					\ }
end_define

begin_define
define|#
directive|define
name|QREM_TAIL
parameter_list|(
name|len
parameter_list|)
value|{						\ 	size_t __off = gp->i_next + gp->i_cnt - 1;			\ 	if (len == 1)							\ 		gp->i_chf[__off] = 0;					\ 	else								\ 		MEMSET(gp->i_chf + __off, 0, len);			\ 	if ((gp->i_cnt -= len) == 0)					\ 		gp->i_next = 0;						\ }
end_define

begin_comment
comment|/*  * term_key --  *	Get the next key.  *  * !!!  * The flag TXT_MAPNODIGIT probably needs some explanation.  First, the idea  * of mapping keys is that one or more keystrokes act like a function key.  * What's going on is that vi is reading a number, and the character following  * the number may or may not be mapped (TXT_MAPCOMMAND).  For example, if the  * user is entering the z command, a valid command is "z40+", and we don't want  * to map the '+', i.e. if '+' is mapped to "xxx", we don't want to change it  * into "z40xxx".  However, if the user enters "35x", we want to put all of the  * characters through the mapping code.  *  * Historical practice is a bit muddled here.  (Surprise!)  It always permitted  * mapping digits as long as they weren't the first character of the map, e.g.  * ":map ^A1 xxx" was okay.  It also permitted the mapping of the digits 1-9  * (the digit 0 was a special case as it doesn't indicate the start of a count)  * as the first character of the map, but then ignored those mappings.  While  * it's probably stupid to map digits, vi isn't your mother.  *  * The way this works is that the TXT_MAPNODIGIT causes term_key to return the  * end-of-digit without "looking" at the next character, i.e. leaving it as the  * user entered it.  Presumably, the next term_key call will tell us how the  * user wants it handled.  *  * There is one more complication.  Users might map keys to digits, and, as  * it's described above, the commands:  *  *	:map g 1G  *	d2g  *  * would return the keys "d2<end-of-digits>1G", when the user probably wanted  * "d21<end-of-digits>G".  So, if a map starts off with a digit we continue as  * before, otherwise, we pretend we haven't mapped the character, and return  *<end-of-digits>.  *  * Now that that's out of the way, let's talk about Energizer Bunny macros.  * It's easy to create macros that expand to a loop, e.g. map x 3x.  It's  * fairly easy to detect this example, because it's all internal to term_key.  * If we're expanding a macro and it gets big enough, at some point we can  * assume it's looping and kill it.  The examples that are tough are the ones  * where the parser is involved, e.g. map x "ayyx"byy.  We do an expansion  * on 'x', and get "ayyx"byy.  We then return the first 4 characters, and then  * find the looping macro again.  There is no way that we can detect this  * without doing a full parse of the command, because the character that might  * cause the loop (in this case 'x') may be a literal character, e.g. the map  * map x "ayy"xyy"byy is perfectly legal and won't cause a loop.  *  * Historic vi tried to detect looping macros by disallowing obvious cases in  * the map command, maps that that ended with the same letter as they started  * (which wrongly disallowed "map x 'x"), and detecting macros that expanded  * too many times before keys were returned to the command parser.  It didn't  * get many (most?) of the tricky cases right, however, and it was certainly  * possible to create macros that ran forever.  And, even if it did figure out  * what was going on, the user was usually tossed into ex mode.  Finally, any  * changes made before vi realized that the macro was recursing were left in  * place.  We recover gracefully, but the only recourse the user has in an  * infinite macro loop is to interrupt.  *  * !!!  * It is historic practice that mapping characters to themselves as the first  * part of the mapped string was legal, and did not cause infinite loops, i.e.  * ":map! { {^M^T" and ":map n nz." were known to work.  The initial, matching  * characters were returned instead of being remapped.  *  * XXX  * The final issue is recovery.  It would be possible to undo all of the work  * that was done by the macro if we entered a record into the log so that we  * knew when the macro started, and, in fact, this might be worth doing at some  * point.  Given that this might make the log grow unacceptably (consider that  * cursor keys are done with maps), for now we leave any changes made in place.  */
end_comment

begin_function
name|enum
name|input
name|term_key
parameter_list|(
name|sp
parameter_list|,
name|chp
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CH
modifier|*
name|chp
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|enum
name|input
name|rval
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|CHAR_T
name|ch
decl_stmt|;
name|GS
modifier|*
name|gp
decl_stmt|;
name|SEQ
modifier|*
name|qp
decl_stmt|;
name|int
name|init_nomap
decl_stmt|,
name|ispartial
decl_stmt|,
name|nr
decl_stmt|;
comment|/* If we've been interrupted, return an error. */
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|INP_INTR
operator|)
return|;
comment|/* 	 * If the queue is empty, read more keys in.  Since no timeout is 	 * requested, s_key_read will either return an error or will read 	 * some number of characters. 	 */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|gp
operator|->
name|i_cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|term_read_grow
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
if|if
condition|(
operator|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|INP_OK
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"read: {%.*s}\n"
argument_list|,
name|gp
operator|->
name|i_cnt
argument_list|,
operator|&
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If there's something on the mode line that we wanted 		 * the user to see, presume they've seen it as they just 		 * entered a character. 		 */
name|F_CLR
argument_list|(
name|sp
argument_list|,
name|S_SCR_UMODE
argument_list|)
expr_stmt|;
block|}
comment|/* If the key is mappable and should be mapped, look it up. */
if|if
condition|(
operator|!
operator|(
name|gp
operator|->
name|i_chf
index|[
name|gp
operator|->
name|i_next
index|]
operator|&
name|CH_NOMAP
operator|)
operator|&&
name|LF_ISSET
argument_list|(
name|TXT_MAPCOMMAND
operator||
name|TXT_MAPINPUT
argument_list|)
condition|)
block|{
comment|/* Get the next key. */
name|newmap
label|:
name|ch
operator|=
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|<
name|MAX_BIT_SEQ
operator|&&
operator|!
name|bit_test
argument_list|(
name|gp
operator|->
name|seqb
argument_list|,
name|ch
argument_list|)
condition|)
goto|goto
name|nomap
goto|;
comment|/* Search the map. */
name|remap
label|:
name|qp
operator|=
name|seq_find
argument_list|(
name|sp
argument_list|,
name|NULL
argument_list|,
operator|&
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
index|]
argument_list|,
name|gp
operator|->
name|i_cnt
argument_list|,
name|LF_ISSET
argument_list|(
name|TXT_MAPCOMMAND
argument_list|)
condition|?
name|SEQ_COMMAND
else|:
name|SEQ_INPUT
argument_list|,
operator|&
name|ispartial
argument_list|)
expr_stmt|;
comment|/* If we've been interrupted, return an error. */
if|if
condition|(
name|INTERRUPTED
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|INP_INTR
operator|)
return|;
comment|/* 		 * If get a partial match, read more characters and retry 		 * the map.  If no characters read, return the characters 		 * unmapped. 		 * 		 * !!! 		 *<escape> characters are a problem.  Input mode ends with 		 * an<escape>, and cursor keys start with one, so there's 		 * an ugly pause at the end of an input session.  If it's an 		 *<escape>, check for followon characters, but timeout after 		 * a 20th of a second.  This will lose if users create maps 		 * that use<escape> as the first character, and that aren't 		 * entered as a single keystroke. 		 */
if|if
condition|(
name|ispartial
condition|)
block|{
if|if
condition|(
name|term_read_grow
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_TIMEOUT
argument_list|)
condition|)
block|{
name|tp
operator|=
operator|&
name|t
expr_stmt|;
if|if
condition|(
name|KEY_VAL
argument_list|(
name|sp
argument_list|,
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
index|]
argument_list|)
operator|==
name|K_ESCAPE
condition|)
block|{
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|50000L
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|tv_sec
operator|=
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_KEYTIME
argument_list|)
operator|/
literal|10
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
operator|(
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_KEYTIME
argument_list|)
operator|%
literal|10
operator|)
operator|*
literal|100000L
expr_stmt|;
block|}
block|}
else|else
name|tp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
name|tp
argument_list|)
operator|)
operator|!=
name|INP_OK
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|nr
condition|)
goto|goto
name|remap
goto|;
goto|goto
name|nomap
goto|;
block|}
comment|/* If no map, return the character. */
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
goto|goto
name|nomap
goto|;
comment|/* 		 * If looking for the end of a digit string, and the first 		 * character of the map is it, pretend we haven't seen the 		 * character. 		 */
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_MAPNODIGIT
argument_list|)
operator|&&
name|qp
operator|->
name|output
operator|!=
name|NULL
operator|&&
operator|!
name|isdigit
argument_list|(
name|qp
operator|->
name|output
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|not_digit_ch
goto|;
comment|/* Find out if the initial segments are identical. */
name|init_nomap
operator|=
operator|!
name|memcmp
argument_list|(
operator|&
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
index|]
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|ilen
argument_list|)
expr_stmt|;
comment|/* Delete the mapped characters from the queue. */
name|QREM_HEAD
argument_list|(
name|qp
operator|->
name|ilen
argument_list|)
expr_stmt|;
comment|/* If keys mapped to nothing, go get more. */
if|if
condition|(
name|qp
operator|->
name|output
operator|==
name|NULL
condition|)
goto|goto
name|loop
goto|;
comment|/* If remapping characters, push the character on the queue. */
if|if
condition|(
name|O_ISSET
argument_list|(
name|sp
argument_list|,
name|O_REMAP
argument_list|)
condition|)
block|{
if|if
condition|(
name|init_nomap
condition|)
block|{
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
operator|+
name|qp
operator|->
name|ilen
argument_list|,
name|qp
operator|->
name|olen
operator|-
name|qp
operator|->
name|ilen
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|ilen
argument_list|,
name|CH_NOMAP
operator||
name|CH_MAPPED
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
goto|goto
name|nomap
goto|;
block|}
elseif|else
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
name|CH_MAPPED
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
goto|goto
name|newmap
goto|;
block|}
comment|/* Else, push the characters on the queue and return one. */
if|if
condition|(
name|term_push
argument_list|(
name|sp
argument_list|,
name|qp
operator|->
name|output
argument_list|,
name|qp
operator|->
name|olen
argument_list|,
name|CH_MAPPED
operator||
name|CH_NOMAP
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
block|}
name|nomap
label|:
name|ch
operator|=
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
index|]
expr_stmt|;
if|if
condition|(
name|LF_ISSET
argument_list|(
name|TXT_MAPNODIGIT
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|not_digit_ch
label|:
name|chp
operator|->
name|ch
operator|=
name|CH_NOT_DIGIT
expr_stmt|;
name|chp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|chp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|INP_OK
operator|)
return|;
block|}
comment|/* Fill in the return information. */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
literal|0
name|TRACE
argument_list|(
name|sp
argument_list|,
literal|"rtrn: {%s}\n"
argument_list|,
name|KEY_NAME
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chp
operator|->
name|ch
operator|=
name|ch
expr_stmt|;
name|chp
operator|->
name|flags
operator|=
name|gp
operator|->
name|i_chf
index|[
name|gp
operator|->
name|i_next
index|]
expr_stmt|;
name|chp
operator|->
name|value
operator|=
name|KEY_VAL
argument_list|(
name|sp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* Delete the character from the queue. */
name|QREM_HEAD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|INP_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term_flush --  *	Flush any flagged keys.  */
end_comment

begin_function
name|void
name|term_flush
parameter_list|(
name|sp
parameter_list|,
name|msg
parameter_list|,
name|flags
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
if|if
condition|(
operator|!
name|gp
operator|->
name|i_cnt
operator|||
operator|!
operator|(
name|gp
operator|->
name|i_chf
index|[
name|gp
operator|->
name|i_next
index|]
operator|&
name|flags
operator|)
condition|)
return|return;
do|do
block|{
name|QREM_HEAD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gp
operator|->
name|i_cnt
operator|&&
name|gp
operator|->
name|i_chf
index|[
name|gp
operator|->
name|i_next
index|]
operator|&
name|flags
condition|)
do|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"091|%s: keys flushed"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAKE_THE_USER_ENTER_A_KEY
end_ifdef

begin_expr_stmt
name|Earlier
name|versions
name|of
name|nvi
name|required
name|that
name|a
name|user
name|enter
name|a
name|key
name|when
name|waiting
end_expr_stmt

begin_for
for|for something to happen
operator|,
name|e
operator|.
name|g
operator|.
name|when
name|getting
name|a
name|key
name|to
name|acknowledge
name|that
name|the
name|user
name|has
name|seen
name|one
name|or
name|more
name|error
name|messages
operator|.
name|Historic
name|vi
name|just
name|used
name|the
name|next
name|character
name|regardless
decl_stmt|,
name|and
name|users
name|complained
operator|.
name|This
name|routine
name|is
name|left
name|in
name|place
name|in
name|case we ever need it again.  static enum input term_key_queue __P((SCR *))
decl_stmt|;
end_for

begin_decl_stmt
specifier|static
name|enum
name|input
name|term_user_key
name|__P
argument_list|(
operator|(
name|SCR
operator|*
operator|,
name|CH
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * term_user_key --  *	Get the next key, but require the user enter one.  */
end_comment

begin_function
name|enum
name|input
name|term_user_key
parameter_list|(
name|sp
parameter_list|,
name|chp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|CH
modifier|*
name|chp
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|enum
name|input
name|rval
decl_stmt|;
name|int
name|nr
decl_stmt|;
comment|/* 	 * Read any keys the user has waiting.  Make the race 	 * condition as short as possible. 	 */
if|if
condition|(
operator|(
name|rval
operator|=
name|term_key_queue
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
name|INP_OK
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* Wait and read another key. */
if|if
condition|(
operator|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|INP_OK
condition|)
return|return
operator|(
name|rval
operator|)
return|;
comment|/* Fill in the return information. */
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|chp
operator|->
name|ch
operator|=
name|gp
operator|->
name|i_ch
index|[
name|gp
operator|->
name|i_next
operator|+
operator|(
name|gp
operator|->
name|i_cnt
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|chp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chp
operator|->
name|value
operator|=
name|KEY_VAL
argument_list|(
name|sp
argument_list|,
name|chp
operator|->
name|ch
argument_list|)
expr_stmt|;
name|QREM_TAIL
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|INP_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * term_key_queue --  *	Read the keys off of the terminal queue until it's empty.  */
end_comment

begin_function
specifier|static
name|enum
name|input
name|term_key_queue
parameter_list|(
name|sp
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|enum
name|input
name|rval
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|t
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|gp
operator|=
name|sp
operator|->
name|gp
init|;
condition|;
control|)
block|{
if|if
condition|(
name|term_read_grow
argument_list|(
name|sp
argument_list|)
condition|)
return|return
operator|(
name|INP_ERR
operator|)
return|;
if|if
condition|(
operator|(
name|rval
operator|=
name|sp
operator|->
name|s_key_read
argument_list|(
name|sp
argument_list|,
operator|&
name|nr
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|!=
name|INP_OK
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|nr
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|INP_OK
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * __key_val --  *	Fill in the value for a key.  This routine is the backup  *	for the KEY_VAL() macro.  */
end_comment

begin_function
name|int
name|__key_val
parameter_list|(
name|sp
parameter_list|,
name|ch
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|ARG_CHAR_T
name|ch
decl_stmt|;
block|{
name|KEYLIST
name|k
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|k
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|kp
operator|=
name|bsearch
argument_list|(
operator|&
name|k
argument_list|,
name|keylist
argument_list|,
name|nkeylist
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|keycmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kp
operator|==
name|NULL
condition|?
name|K_NOTUSED
else|:
name|kp
operator|->
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * __term_read_grow --  *	Grow the terminal queue.  This routine is the backup for  *	the term_read_grow() macro.  */
end_comment

begin_function
specifier|static
name|int
name|__term_read_grow
parameter_list|(
name|sp
parameter_list|,
name|add
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|add
decl_stmt|;
block|{
name|GS
modifier|*
name|gp
decl_stmt|;
name|size_t
name|new_nelem
decl_stmt|,
name|olen
decl_stmt|;
name|gp
operator|=
name|sp
operator|->
name|gp
expr_stmt|;
name|new_nelem
operator|=
name|gp
operator|->
name|i_nelem
operator|+
name|add
expr_stmt|;
name|olen
operator|=
name|gp
operator|->
name|i_nelem
operator|*
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_ch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|gp
operator|->
name|i_ch
argument_list|,
name|olen
argument_list|,
name|new_nelem
operator|*
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_ch
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|olen
operator|=
name|gp
operator|->
name|i_nelem
operator|*
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_chf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|BINC_RET
argument_list|(
name|sp
argument_list|,
name|gp
operator|->
name|i_chf
argument_list|,
name|olen
argument_list|,
name|new_nelem
operator|*
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_chf
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gp
operator|->
name|i_nelem
operator|=
name|olen
operator|/
sizeof|sizeof
argument_list|(
name|gp
operator|->
name|i_chf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keycmp
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
specifier|const
name|void
modifier|*
name|ap
decl_stmt|,
decl|*
name|bp
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
operator|(
operator|(
name|KEYLIST
operator|*
operator|)
name|ap
operator|)
operator|->
name|ch
operator|-
operator|(
operator|(
name|KEYLIST
operator|*
operator|)
name|bp
operator|)
operator|->
name|ch
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * term_window --  *	Set the window size.  */
end_comment

begin_function
name|int
name|term_window
parameter_list|(
name|sp
parameter_list|,
name|sigwinch
parameter_list|)
name|SCR
modifier|*
name|sp
decl_stmt|;
name|int
name|sigwinch
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|win
decl_stmt|;
endif|#
directive|endif
name|size_t
name|col
decl_stmt|,
name|row
decl_stmt|;
name|int
name|nf
decl_stmt|,
name|rval
decl_stmt|;
name|ARGS
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|,
name|buf
index|[
literal|2048
index|]
decl_stmt|;
comment|/* 	 * Get the screen rows and columns.  If the values are wrong, it's 	 * not a big deal -- as soon as the user sets them explicitly the 	 * environment will be set and the screen package will use the new 	 * values. 	 * 	 * Try TIOCGWINSZ. 	 */
name|row
operator|=
name|col
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|ioctl
argument_list|(
name|STDERR_FILENO
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|win
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|row
operator|=
name|win
operator|.
name|ws_row
expr_stmt|;
name|col
operator|=
name|win
operator|.
name|ws_col
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If here because of suspend or a signal, only trust TIOCGWINSZ. */
if|if
condition|(
name|sigwinch
condition|)
block|{
comment|/* 		 * Somebody didn't get TIOCGWINSZ right, or has suspend 		 * without window resizing support.  The user just lost, 		 * but there's nothing we can do. 		 */
if|if
condition|(
name|row
operator|==
literal|0
operator|||
name|col
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * SunOS systems deliver SIGWINCH when windows are uncovered 		 * as well as when they change size.  In addition, we call 		 * here when continuing after being suspended since the window 		 * may have changed size.  Since we don't want to background 		 * all of the screens just because the window was uncovered, 		 * ignore the signal if there's no change. 		 */
if|if
condition|(
name|row
operator|==
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_LINES
argument_list|)
operator|&&
name|col
operator|==
name|O_VAL
argument_list|(
name|sp
argument_list|,
name|O_COLUMNS
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
goto|goto
name|sigw
goto|;
block|}
comment|/* 	 * !!! 	 * If TIOCGWINSZ failed, or had entries of 0, try termcap.  This 	 * routine is called before any termcap or terminal information 	 * has been set up.  If there's no TERM environmental variable set, 	 * let it go, at least ex can run. 	 */
if|if
condition|(
name|row
operator|==
literal|0
operator|||
name|col
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|noterm
goto|;
ifdef|#
directive|ifdef
name|SYSV_CURSES
if|if
condition|(
name|row
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|rval
operator|=
name|tigetnum
argument_list|(
literal|"lines"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"tigetnum: lines"
argument_list|)
expr_stmt|;
else|else
name|row
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|rval
operator|=
name|tigetnum
argument_list|(
literal|"cols"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"tigetnum: cols"
argument_list|)
expr_stmt|;
else|else
name|col
operator|=
name|rval
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|tgetent
argument_list|(
name|buf
argument_list|,
name|s
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_SYSERR
argument_list|,
literal|"tgetent: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|0
case|:
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"096|%s: unknown terminal type"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|row
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|rval
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"097|no \"li\" terminal capability for %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|row
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|rval
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|msg_print
argument_list|(
name|sp
argument_list|,
name|s
argument_list|,
operator|&
name|nf
argument_list|)
expr_stmt|;
name|msgq
argument_list|(
name|sp
argument_list|,
name|M_ERR
argument_list|,
literal|"098|no \"co\" terminal capability for %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nf
condition|)
name|FREE_SPACE
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|col
operator|=
name|rval
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If nothing else, well, it's probably a VT100. */
name|noterm
label|:
if|if
condition|(
name|row
operator|==
literal|0
condition|)
name|row
operator|=
literal|24
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|col
operator|=
literal|80
expr_stmt|;
comment|/* POSIX 1003.2 requires the environment to override. */
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|row
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|col
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sigw
label|:
name|a
operator|.
name|bp
operator|=
name|buf
expr_stmt|;
name|b
operator|.
name|bp
operator|=
name|NULL
expr_stmt|;
name|b
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
operator|&
name|a
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
operator|&
name|b
expr_stmt|;
empty_stmt|;
comment|/* Use the options code to accomplish the change. */
name|a
operator|.
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"lines=%u"
argument_list|,
name|row
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts_set
argument_list|(
name|sp
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|a
operator|.
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"columns=%u"
argument_list|,
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts_set
argument_list|(
name|sp
argument_list|,
name|argv
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|F_SET
argument_list|(
name|sp
argument_list|,
name|S_SCR_RESIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

