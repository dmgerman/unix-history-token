begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|yysccsid
index|[]
init|=
literal|"@(#)yaccpar	1.9 (Berkeley) 02/21/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYBYACC
value|1
end_define

begin_define
define|#
directive|define
name|YYMAJOR
value|1
end_define

begin_define
define|#
directive|define
name|YYMINOR
value|9
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar=(-1))
end_define

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrflag=0)
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
value|(yyerrflag!=0)
end_define

begin_define
define|#
directive|define
name|YYPREFIX
value|"yy"
end_define

begin_line
line|#
directive|line
number|10
file|"./parse.y"
end_line

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *   * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/* $Header: /home/daffy/u0/vern/flex/RCS/parse.y,v 2.28 95/04/21 11:51:51 vern Exp $ */
end_comment

begin_comment
comment|/* Some versions of bison are broken in that they use alloca() but don't  * declare it properly.  The following is the patented (just kidding!)  * #ifdef chud to fix the problem, courtesy of Francois Pinard.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYBISON
end_ifdef

begin_comment
comment|/* AIX requires this to be the first thing in the file.  What a piece.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* The remainder of the alloca() cruft has to come after including flexdef.h,  * so HAVE_ALLOCA_H is (possibly) defined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYBISON
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_ALLOCA_H
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_function_decl
name|void
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Bletch, ^^^^ that was ugly! */
end_comment

begin_decl_stmt
name|int
name|pat
decl_stmt|,
name|scnum
decl_stmt|,
name|eps
decl_stmt|,
name|headcnt
decl_stmt|,
name|trailcnt
decl_stmt|,
name|anyccl
decl_stmt|,
name|lastchar
decl_stmt|,
name|i
decl_stmt|,
name|rulelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trlcontxt
decl_stmt|,
name|xcluflg
decl_stmt|,
name|currccl
decl_stmt|,
name|cclsorted
decl_stmt|,
name|varlength
decl_stmt|,
name|variable_trail_rule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|scon_stk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scon_stk_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|madeany
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether we've made the '.' character class */
end_comment

begin_decl_stmt
name|int
name|previous_continued_action
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether the previous rule's action was '|' */
end_comment

begin_comment
comment|/* Expand a POSIX character class expression. */
end_comment

begin_define
define|#
directive|define
name|CCL_EXPR
parameter_list|(
name|func
parameter_list|)
define|\
value|{ \ 	int c; \ 	for ( c = 0; c< csize; ++c ) \ 		if ( isascii(c)&& func(c) ) \ 			ccladd( currccl, c ); \ 	}
end_define

begin_comment
comment|/* While POSIX defines isblank(), it's not ANSI C. */
end_comment

begin_define
define|#
directive|define
name|IS_BLANK
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_comment
comment|/* On some over-ambitious machines, such as DEC Alpha's, the default  * token type is "long" instead of "int"; this leads to problems with  * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen  * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the  * following should ensure that the default token type is "int".  */
end_comment

begin_define
define|#
directive|define
name|YYSTYPE
value|int
end_define

begin_line
line|#
directive|line
number|112
file|"y.tab.c"
end_line

begin_define
define|#
directive|define
name|CHAR
value|257
end_define

begin_define
define|#
directive|define
name|NUMBER
value|258
end_define

begin_define
define|#
directive|define
name|SECTEND
value|259
end_define

begin_define
define|#
directive|define
name|SCDECL
value|260
end_define

begin_define
define|#
directive|define
name|XSCDECL
value|261
end_define

begin_define
define|#
directive|define
name|NAME
value|262
end_define

begin_define
define|#
directive|define
name|PREVCCL
value|263
end_define

begin_define
define|#
directive|define
name|EOF_OP
value|264
end_define

begin_define
define|#
directive|define
name|OPTION_OP
value|265
end_define

begin_define
define|#
directive|define
name|OPT_OUTFILE
value|266
end_define

begin_define
define|#
directive|define
name|OPT_PREFIX
value|267
end_define

begin_define
define|#
directive|define
name|OPT_YYCLASS
value|268
end_define

begin_define
define|#
directive|define
name|CCE_ALNUM
value|269
end_define

begin_define
define|#
directive|define
name|CCE_ALPHA
value|270
end_define

begin_define
define|#
directive|define
name|CCE_BLANK
value|271
end_define

begin_define
define|#
directive|define
name|CCE_CNTRL
value|272
end_define

begin_define
define|#
directive|define
name|CCE_DIGIT
value|273
end_define

begin_define
define|#
directive|define
name|CCE_GRAPH
value|274
end_define

begin_define
define|#
directive|define
name|CCE_LOWER
value|275
end_define

begin_define
define|#
directive|define
name|CCE_PRINT
value|276
end_define

begin_define
define|#
directive|define
name|CCE_PUNCT
value|277
end_define

begin_define
define|#
directive|define
name|CCE_SPACE
value|278
end_define

begin_define
define|#
directive|define
name|CCE_UPPER
value|279
end_define

begin_define
define|#
directive|define
name|CCE_XDIGIT
value|280
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_decl_stmt
name|short
name|yylhs
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|14
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|16
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|18
block|,
literal|18
block|,
literal|17
block|,
literal|19
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|21
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|22
block|,
literal|22
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yylen
index|[]
init|=
block|{
literal|2
block|,
literal|5
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yydefred
index|[]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|15
block|,
literal|21
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
literal|0
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|29
block|,
literal|33
block|,
literal|34
block|,
literal|0
block|,
literal|32
block|,
literal|0
block|,
literal|26
block|,
literal|55
block|,
literal|52
block|,
literal|25
block|,
literal|0
block|,
literal|50
block|,
literal|75
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|24
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|51
block|,
literal|28
block|,
literal|0
block|,
literal|20
block|,
literal|23
block|,
literal|0
block|,
literal|0
block|,
literal|61
block|,
literal|0
block|,
literal|19
block|,
literal|0
block|,
literal|37
block|,
literal|0
block|,
literal|41
block|,
literal|0
block|,
literal|0
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|31
block|,
literal|74
block|,
literal|53
block|,
literal|54
block|,
literal|0
block|,
literal|0
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|56
block|,
literal|60
block|,
literal|36
block|,
literal|0
block|,
literal|0
block|,
literal|57
block|,
literal|0
block|,
literal|49
block|,
literal|0
block|,
literal|58
block|,
literal|0
block|,
literal|48
block|,
literal|47
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yydgoto
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|9
block|,
literal|13
block|,
literal|22
block|,
literal|10
block|,
literal|16
block|,
literal|11
block|,
literal|12
block|,
literal|20
block|,
literal|23
block|,
literal|50
block|,
literal|51
block|,
literal|29
block|,
literal|38
block|,
literal|39
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|61
block|,
literal|64
block|,
literal|94
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yysindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|235
block|,
literal|0
block|,
operator|-
literal|191
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|207
block|,
literal|0
block|,
operator|-
literal|215
block|,
operator|-
literal|18
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|202
block|,
literal|4
block|,
literal|26
block|,
literal|32
block|,
literal|0
block|,
literal|41
block|,
literal|0
block|,
operator|-
literal|35
block|,
literal|0
block|,
operator|-
literal|168
block|,
operator|-
literal|166
block|,
operator|-
literal|165
block|,
literal|38
block|,
operator|-
literal|180
block|,
literal|0
block|,
operator|-
literal|30
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|16
block|,
literal|0
block|,
operator|-
literal|40
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|2
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|2
block|,
literal|8
block|,
literal|93
block|,
literal|0
block|,
operator|-
literal|2
block|,
operator|-
literal|25
block|,
operator|-
literal|2
block|,
literal|15
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|153
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|27
block|,
operator|-
literal|26
block|,
literal|0
block|,
operator|-
literal|88
block|,
literal|0
block|,
operator|-
literal|23
block|,
literal|0
block|,
operator|-
literal|2
block|,
literal|0
block|,
literal|15
block|,
operator|-
literal|150
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|3
block|,
literal|65
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|2
block|,
operator|-
literal|21
block|,
literal|0
block|,
operator|-
literal|145
block|,
literal|0
block|,
operator|-
literal|116
block|,
literal|0
block|,
operator|-
literal|12
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yyrindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|188
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|154
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|140
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|176
block|,
literal|0
block|,
operator|-
literal|28
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|22
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|106
block|,
literal|7
block|,
operator|-
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|108
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|7
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yygindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|92
block|,
literal|100
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|81
block|,
literal|0
block|,
literal|0
block|,
literal|69
block|,
literal|0
block|,
literal|27
block|,
literal|60
block|,
operator|-
literal|29
block|,
literal|0
block|,
literal|0
block|,
literal|66
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYTABLESIZE
value|326
end_define

begin_decl_stmt
name|short
name|yytable
index|[]
init|=
block|{
literal|43
block|,
literal|22
block|,
literal|30
block|,
literal|42
block|,
literal|47
block|,
literal|93
block|,
literal|22
block|,
literal|77
block|,
literal|30
block|,
literal|104
block|,
literal|48
block|,
literal|67
block|,
literal|22
block|,
literal|95
block|,
literal|30
block|,
literal|78
block|,
literal|46
block|,
literal|40
block|,
literal|22
block|,
literal|39
block|,
literal|21
block|,
literal|3
block|,
literal|69
block|,
literal|101
block|,
literal|43
block|,
literal|70
block|,
literal|43
block|,
literal|42
block|,
literal|58
block|,
literal|42
block|,
literal|43
block|,
literal|43
block|,
literal|47
block|,
literal|42
block|,
literal|42
block|,
literal|30
block|,
literal|43
block|,
literal|43
block|,
literal|48
block|,
literal|42
block|,
literal|42
block|,
literal|30
block|,
literal|21
block|,
literal|40
block|,
literal|46
block|,
literal|39
block|,
literal|57
block|,
literal|30
block|,
literal|40
block|,
literal|14
block|,
literal|39
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|40
block|,
literal|15
block|,
literal|39
block|,
literal|72
block|,
literal|73
block|,
literal|30
block|,
literal|24
block|,
literal|49
block|,
literal|30
block|,
literal|22
block|,
literal|45
block|,
literal|25
block|,
literal|22
block|,
literal|70
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|8
block|,
literal|62
block|,
literal|36
block|,
literal|5
block|,
literal|74
block|,
literal|66
block|,
literal|27
block|,
literal|43
block|,
literal|37
block|,
literal|28
block|,
literal|42
block|,
literal|59
block|,
literal|27
block|,
literal|26
block|,
literal|30
block|,
literal|49
block|,
literal|98
block|,
literal|30
block|,
literal|30
block|,
literal|27
block|,
literal|32
block|,
literal|30
block|,
literal|33
block|,
literal|34
block|,
literal|68
block|,
literal|68
block|,
literal|35
block|,
literal|68
block|,
literal|63
block|,
literal|65
block|,
literal|100
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|97
block|,
literal|37
block|,
literal|99
block|,
literal|13
block|,
literal|102
block|,
literal|105
block|,
literal|43
block|,
literal|61
block|,
literal|38
block|,
literal|42
block|,
literal|35
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|40
block|,
literal|31
block|,
literal|30
block|,
literal|3
block|,
literal|60
block|,
literal|75
block|,
literal|96
block|,
literal|79
block|,
literal|0
block|,
literal|40
block|,
literal|0
block|,
literal|39
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|71
block|,
literal|59
block|,
literal|0
block|,
literal|0
block|,
literal|103
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|30
block|,
literal|41
block|,
literal|42
block|,
literal|22
block|,
literal|22
block|,
literal|76
block|,
literal|30
block|,
literal|30
block|,
literal|43
block|,
literal|44
block|,
literal|22
block|,
literal|22
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|43
block|,
literal|0
block|,
literal|0
block|,
literal|42
block|,
literal|0
block|,
literal|0
block|,
literal|43
block|,
literal|80
block|,
literal|42
block|,
literal|42
block|,
literal|30
block|,
literal|30
block|,
literal|0
block|,
literal|0
block|,
literal|43
block|,
literal|0
block|,
literal|0
block|,
literal|30
block|,
literal|30
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|0
block|,
literal|61
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|61
block|,
literal|59
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|,
literal|59
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yycheck
index|[]
init|=
block|{
literal|10
block|,
literal|0
block|,
literal|34
block|,
literal|10
block|,
literal|34
block|,
literal|93
block|,
literal|34
block|,
literal|34
block|,
literal|40
block|,
literal|125
block|,
literal|40
block|,
literal|36
block|,
literal|40
block|,
literal|36
block|,
literal|46
block|,
literal|41
block|,
literal|46
block|,
literal|10
block|,
literal|46
block|,
literal|10
block|,
literal|60
block|,
literal|256
block|,
literal|47
block|,
literal|44
block|,
literal|34
block|,
literal|54
block|,
literal|36
block|,
literal|34
block|,
literal|44
block|,
literal|36
block|,
literal|40
block|,
literal|41
block|,
literal|34
block|,
literal|40
block|,
literal|41
block|,
literal|34
block|,
literal|46
block|,
literal|47
block|,
literal|40
block|,
literal|46
block|,
literal|47
block|,
literal|40
block|,
literal|60
block|,
literal|36
block|,
literal|46
block|,
literal|36
block|,
literal|62
block|,
literal|46
block|,
literal|41
block|,
literal|256
block|,
literal|41
block|,
literal|266
block|,
literal|267
block|,
literal|268
block|,
literal|47
block|,
literal|262
block|,
literal|47
block|,
literal|42
block|,
literal|43
block|,
literal|91
block|,
literal|262
block|,
literal|91
block|,
literal|94
block|,
literal|91
block|,
literal|94
block|,
literal|61
block|,
literal|94
block|,
literal|96
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|265
block|,
literal|48
block|,
literal|256
block|,
literal|265
block|,
literal|63
block|,
literal|52
block|,
literal|256
block|,
literal|91
block|,
literal|262
block|,
literal|42
block|,
literal|91
block|,
literal|125
block|,
literal|262
block|,
literal|61
block|,
literal|123
block|,
literal|91
block|,
literal|93
block|,
literal|123
block|,
literal|91
block|,
literal|61
block|,
literal|262
block|,
literal|94
block|,
literal|262
block|,
literal|262
block|,
literal|124
block|,
literal|124
block|,
literal|62
block|,
literal|124
block|,
literal|94
block|,
literal|10
block|,
literal|125
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|258
block|,
literal|262
block|,
literal|45
block|,
literal|265
block|,
literal|257
block|,
literal|125
block|,
literal|124
block|,
literal|93
block|,
literal|10
block|,
literal|124
block|,
literal|10
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|30
block|,
literal|23
block|,
literal|123
block|,
literal|265
block|,
literal|45
block|,
literal|58
block|,
literal|68
block|,
literal|63
block|,
operator|-
literal|1
block|,
literal|124
block|,
operator|-
literal|1
block|,
literal|124
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|123
block|,
literal|93
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|258
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|269
block|,
literal|270
block|,
literal|271
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|256
block|,
literal|257
block|,
literal|256
block|,
literal|257
block|,
literal|256
block|,
literal|257
block|,
literal|257
block|,
literal|263
block|,
literal|264
block|,
literal|263
block|,
literal|264
block|,
literal|263
block|,
literal|264
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
literal|257
block|,
literal|257
block|,
literal|263
block|,
literal|256
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
literal|264
block|,
literal|269
block|,
literal|270
block|,
literal|271
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|269
block|,
literal|270
block|,
literal|271
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|269
block|,
literal|270
block|,
literal|271
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYFINAL
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYMAXTOKEN
value|280
end_define

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_decl_stmt
name|char
modifier|*
name|yyname
index|[]
init|=
block|{
literal|"end-of-file"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'\\n'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'\"'"
block|,
literal|0
block|,
literal|"'$'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'('"
block|,
literal|"')'"
block|,
literal|"'*'"
block|,
literal|"'+'"
block|,
literal|"','"
block|,
literal|"'-'"
block|,
literal|"'.'"
block|,
literal|"'/'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'<'"
block|,
literal|"'='"
block|,
literal|"'>'"
block|,
literal|"'?'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'['"
block|,
literal|0
block|,
literal|"']'"
block|,
literal|"'^'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'{'"
block|,
literal|"'|'"
block|,
literal|"'}'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"CHAR"
block|,
literal|"NUMBER"
block|,
literal|"SECTEND"
block|,
literal|"SCDECL"
block|,
literal|"XSCDECL"
block|,
literal|"NAME"
block|,
literal|"PREVCCL"
block|,
literal|"EOF_OP"
block|,
literal|"OPTION_OP"
block|,
literal|"OPT_OUTFILE"
block|,
literal|"OPT_PREFIX"
block|,
literal|"OPT_YYCLASS"
block|,
literal|"CCE_ALNUM"
block|,
literal|"CCE_ALPHA"
block|,
literal|"CCE_BLANK"
block|,
literal|"CCE_CNTRL"
block|,
literal|"CCE_DIGIT"
block|,
literal|"CCE_GRAPH"
block|,
literal|"CCE_LOWER"
block|,
literal|"CCE_PRINT"
block|,
literal|"CCE_PUNCT"
block|,
literal|"CCE_SPACE"
block|,
literal|"CCE_UPPER"
block|,
literal|"CCE_XDIGIT"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yyrule
index|[]
init|=
block|{
literal|"$accept : goal"
block|,
literal|"goal : initlex sect1 sect1end sect2 initforrule"
block|,
literal|"initlex :"
block|,
literal|"sect1 : sect1 startconddecl namelist1"
block|,
literal|"sect1 : sect1 options"
block|,
literal|"sect1 :"
block|,
literal|"sect1 : error"
block|,
literal|"sect1end : SECTEND"
block|,
literal|"startconddecl : SCDECL"
block|,
literal|"startconddecl : XSCDECL"
block|,
literal|"namelist1 : namelist1 NAME"
block|,
literal|"namelist1 : NAME"
block|,
literal|"namelist1 : error"
block|,
literal|"options : OPTION_OP optionlist"
block|,
literal|"optionlist : optionlist option"
block|,
literal|"optionlist :"
block|,
literal|"option : OPT_OUTFILE '=' NAME"
block|,
literal|"option : OPT_PREFIX '=' NAME"
block|,
literal|"option : OPT_YYCLASS '=' NAME"
block|,
literal|"sect2 : sect2 scon initforrule flexrule '\\n'"
block|,
literal|"sect2 : sect2 scon '{' sect2 '}'"
block|,
literal|"sect2 :"
block|,
literal|"initforrule :"
block|,
literal|"flexrule : '^' rule"
block|,
literal|"flexrule : rule"
block|,
literal|"flexrule : EOF_OP"
block|,
literal|"flexrule : error"
block|,
literal|"scon_stk_ptr :"
block|,
literal|"scon : '<' scon_stk_ptr namelist2 '>'"
block|,
literal|"scon : '<' '*' '>'"
block|,
literal|"scon :"
block|,
literal|"namelist2 : namelist2 ',' sconname"
block|,
literal|"namelist2 : sconname"
block|,
literal|"namelist2 : error"
block|,
literal|"sconname : NAME"
block|,
literal|"rule : re2 re"
block|,
literal|"rule : re2 re '$'"
block|,
literal|"rule : re '$'"
block|,
literal|"rule : re"
block|,
literal|"re : re '|' series"
block|,
literal|"re : series"
block|,
literal|"re2 : re '/'"
block|,
literal|"series : series singleton"
block|,
literal|"series : singleton"
block|,
literal|"singleton : singleton '*'"
block|,
literal|"singleton : singleton '+'"
block|,
literal|"singleton : singleton '?'"
block|,
literal|"singleton : singleton '{' NUMBER ',' NUMBER '}'"
block|,
literal|"singleton : singleton '{' NUMBER ',' '}'"
block|,
literal|"singleton : singleton '{' NUMBER '}'"
block|,
literal|"singleton : '.'"
block|,
literal|"singleton : fullccl"
block|,
literal|"singleton : PREVCCL"
block|,
literal|"singleton : '\"' string '\"'"
block|,
literal|"singleton : '(' re ')'"
block|,
literal|"singleton : CHAR"
block|,
literal|"fullccl : '[' ccl ']'"
block|,
literal|"fullccl : '[' '^' ccl ']'"
block|,
literal|"ccl : ccl CHAR '-' CHAR"
block|,
literal|"ccl : ccl CHAR"
block|,
literal|"ccl : ccl ccl_expr"
block|,
literal|"ccl :"
block|,
literal|"ccl_expr : CCE_ALNUM"
block|,
literal|"ccl_expr : CCE_ALPHA"
block|,
literal|"ccl_expr : CCE_BLANK"
block|,
literal|"ccl_expr : CCE_CNTRL"
block|,
literal|"ccl_expr : CCE_DIGIT"
block|,
literal|"ccl_expr : CCE_GRAPH"
block|,
literal|"ccl_expr : CCE_LOWER"
block|,
literal|"ccl_expr : CCE_PRINT"
block|,
literal|"ccl_expr : CCE_PUNCT"
block|,
literal|"ccl_expr : CCE_SPACE"
block|,
literal|"ccl_expr : CCE_UPPER"
block|,
literal|"ccl_expr : CCE_XDIGIT"
block|,
literal|"string : string CHAR"
block|,
literal|"string :"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTYPE
end_ifndef

begin_typedef
typedef|typedef
name|int
name|YYSTYPE
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACKSIZE
end_ifdef

begin_undef
undef|#
directive|undef
name|YYMAXDEPTH
end_undef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|YYSTACKSIZE
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|YYMAXDEPTH
end_ifdef

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|YYMAXDEPTH
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|500
end_define

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yynerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
modifier|*
name|yyssp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
modifier|*
name|yyvsp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yyval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|yyss
index|[
name|YYSTACKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yyvs
index|[
name|YYSTACKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|yystacksize
value|YYSTACKSIZE
end_define

begin_line
line|#
directive|line
number|776
file|"./parse.y"
end_line

begin_comment
comment|/* build_eof_action - build the "<<EOF>>" action for the active start  *                    conditions  */
end_comment

begin_function
name|void
name|build_eof_action
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|action_text
index|[
name|MAXLINE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sceof
index|[
name|scon_stk
index|[
name|i
index|]
index|]
condition|)
name|format_pinpoint_message
argument_list|(
literal|"multiple<<EOF>> rules for start condition %s"
argument_list|,
name|scname
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|sceof
index|[
name|scon_stk
index|[
name|i
index|]
index|]
operator|=
name|true
expr_stmt|;
name|sprintf
argument_list|(
name|action_text
argument_list|,
literal|"case YY_STATE_EOF(%s):\n"
argument_list|,
name|scname
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
name|action_text
argument_list|)
expr_stmt|;
block|}
block|}
name|line_directive_out
argument_list|(
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This isn't a normal rule after all - don't count it as 	 * such, so we don't have any holes in the rule numbering 	 * (which make generating "rule can never match" warnings 	 * more difficult. 	 */
operator|--
name|num_rules
expr_stmt|;
operator|++
name|num_eof_rules
expr_stmt|;
block|}
end_function

begin_comment
comment|/* format_synerr - write out formatted syntax error */
end_comment

begin_decl_stmt
name|void
name|format_synerr
argument_list|(
name|msg
argument_list|,
name|arg
argument_list|)
name|char
name|msg
index|[]
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|errmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errmsg
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|synerr
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* synerr - report a syntax error */
end_comment

begin_function
name|void
name|synerr
parameter_list|(
name|str
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
name|syntaxerror
operator|=
name|true
expr_stmt|;
name|pinpoint_message
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* format_warn - write out formatted warning */
end_comment

begin_decl_stmt
name|void
name|format_warn
argument_list|(
name|msg
argument_list|,
name|arg
argument_list|)
name|char
name|msg
index|[]
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|warn_msg
index|[
name|MAXLINE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|warn_msg
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|warn_msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* warn - report a warning, unless -w was given */
end_comment

begin_function
name|void
name|warn
parameter_list|(
name|str
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
name|line_warning
argument_list|(
name|str
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* format_pinpoint_message - write out a message formatted with one string,  *			     pinpointing its location  */
end_comment

begin_decl_stmt
name|void
name|format_pinpoint_message
argument_list|(
name|msg
argument_list|,
name|arg
argument_list|)
name|char
name|msg
index|[]
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|errmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errmsg
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pinpoint_message
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* pinpoint_message - write out a message, pinpointing its location */
end_comment

begin_function
name|void
name|pinpoint_message
parameter_list|(
name|str
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
name|line_pinpoint
argument_list|(
name|str
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* line_warning - report a warning at a given line, unless -w was given */
end_comment

begin_function
name|void
name|line_warning
parameter_list|(
name|str
parameter_list|,
name|line
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
name|warning
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|nowarn
condition|)
block|{
name|sprintf
argument_list|(
name|warning
argument_list|,
literal|"warning, %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|line_pinpoint
argument_list|(
name|warning
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* line_pinpoint - write out a message, pinpointing it at the given line */
end_comment

begin_function
name|void
name|line_pinpoint
parameter_list|(
name|str
parameter_list|,
name|line
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\", line %d: %s\n"
argument_list|,
name|infilename
argument_list|,
name|line
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* yyerror - eat up an error message from the parser;  *	     currently, messages are ignore  */
end_comment

begin_function
name|void
name|yyerror
parameter_list|(
name|msg
parameter_list|)
name|char
name|msg
index|[]
decl_stmt|;
block|{ 	}
end_function

begin_line
line|#
directive|line
number|541
file|"y.tab.c"
end_line

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYREJECT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyaccept
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_function
name|int
name|yyparse
parameter_list|()
block|{
specifier|register
name|int
name|yym
decl_stmt|,
name|yyn
decl_stmt|,
name|yystate
decl_stmt|;
if|#
directive|if
name|YYDEBUG
specifier|register
name|char
modifier|*
name|yys
decl_stmt|;
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
if|if
condition|(
name|yys
operator|=
name|getenv
argument_list|(
literal|"YYDEBUG"
argument_list|)
condition|)
block|{
name|yyn
operator|=
operator|*
name|yys
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|'0'
operator|&&
name|yyn
operator|<=
literal|'9'
condition|)
name|yydebug
operator|=
name|yyn
operator|-
literal|'0'
expr_stmt|;
block|}
endif|#
directive|endif
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
name|yyssp
operator|=
name|yyss
expr_stmt|;
name|yyvsp
operator|=
name|yyvs
expr_stmt|;
operator|*
name|yyssp
operator|=
name|yystate
operator|=
literal|0
expr_stmt|;
name|yyloop
label|:
if|if
condition|(
name|yyn
operator|=
name|yydefred
index|[
name|yystate
index|]
condition|)
goto|goto
name|yyreduce
goto|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|yys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<=
name|YYMAXTOKEN
condition|)
name|yys
operator|=
name|yyname
index|[
name|yychar
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|yys
condition|)
name|yys
operator|=
literal|"illegal-symbol"
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, reading %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
name|yystate
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|yychar
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, shifting to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
block|{
goto|goto
name|yyoverflow
goto|;
block|}
operator|*
operator|++
name|yyssp
operator|=
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
name|yychar
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yyrindex
index|[
name|yystate
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|yychar
condition|)
block|{
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
if|if
condition|(
name|yyerrflag
condition|)
goto|goto
name|yyinrecovery
goto|;
ifdef|#
directive|ifdef
name|lint
goto|goto
name|yynewerror
goto|;
endif|#
directive|endif
name|yynewerror
label|:
name|yyerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
goto|goto
name|yyerrlab
goto|;
endif|#
directive|endif
name|yyerrlab
label|:
operator|++
name|yynerrs
expr_stmt|;
name|yyinrecovery
label|:
if|if
condition|(
name|yyerrflag
operator|<
literal|3
condition|)
block|{
name|yyerrflag
operator|=
literal|3
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
operator|*
name|yyssp
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|YYERRCODE
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|YYERRCODE
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, error recovery shifting\  to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yyssp
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
block|{
goto|goto
name|yyoverflow
goto|;
block|}
operator|*
operator|++
name|yyssp
operator|=
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yylval
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
else|else
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: error recovery discarding state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yyssp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyssp
operator|<=
name|yyss
condition|)
goto|goto
name|yyabort
goto|;
operator|--
name|yyssp
expr_stmt|;
operator|--
name|yyvsp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyabort
goto|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|yys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<=
name|YYMAXTOKEN
condition|)
name|yys
operator|=
name|yyname
index|[
name|yychar
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|yys
condition|)
name|yys
operator|=
literal|"illegal-symbol"
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, error recovery discards token %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yychar
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
name|yyreduce
label|:
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, reducing by rule %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yyn
argument_list|,
name|yyrule
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yym
operator|=
name|yylen
index|[
name|yyn
index|]
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
literal|1
operator|-
name|yym
index|]
expr_stmt|;
switch|switch
condition|(
name|yyn
condition|)
block|{
case|case
literal|1
case|:
line|#
directive|line
number|113
file|"./parse.y"
block|{
comment|/* add default rule */
name|int
name|def_rule
decl_stmt|;
name|pat
operator|=
name|cclinit
argument_list|()
expr_stmt|;
name|cclnegate
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|def_rule
operator|=
name|mkstate
argument_list|(
operator|-
name|pat
argument_list|)
expr_stmt|;
comment|/* Remember the number of the default rule so we 			 * don't generate "can't match" warnings for it. 			 */
name|default_rule
operator|=
name|num_rules
expr_stmt|;
name|finish_rule
argument_list|(
name|def_rule
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
name|scset
index|[
name|i
index|]
operator|=
name|mkbranch
argument_list|(
name|scset
index|[
name|i
index|]
argument_list|,
name|def_rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
condition|)
name|add_action
argument_list|(
literal|"YY_FATAL_ERROR( \"flex scanner jammed\" )"
argument_list|)
expr_stmt|;
else|else
name|add_action
argument_list|(
literal|"ECHO"
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
literal|";\n\tYY_BREAK\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
line|#
directive|line
number|142
file|"./parse.y"
block|{
comment|/* initialize for processing rules */
comment|/* Create default DFA start condition. */
name|scinstal
argument_list|(
literal|"INITIAL"
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
line|#
directive|line
number|153
file|"./parse.y"
block|{
name|synerr
argument_list|(
literal|"unknown error processing section 1"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
line|#
directive|line
number|157
file|"./parse.y"
block|{
name|check_options
argument_list|()
expr_stmt|;
name|scon_stk
operator|=
name|allocate_integer_array
argument_list|(
name|lastsc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scon_stk_ptr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
line|#
directive|line
number|165
file|"./parse.y"
block|{
name|xcluflg
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
line|#
directive|line
number|168
file|"./parse.y"
block|{
name|xcluflg
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
line|#
directive|line
number|172
file|"./parse.y"
block|{
name|scinstal
argument_list|(
name|nmstr
argument_list|,
name|xcluflg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|175
file|"./parse.y"
block|{
name|scinstal
argument_list|(
name|nmstr
argument_list|,
name|xcluflg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
line|#
directive|line
number|178
file|"./parse.y"
block|{
name|synerr
argument_list|(
literal|"bad start condition list"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|189
file|"./parse.y"
block|{
name|outfilename
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
name|did_outfilename
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
line|#
directive|line
number|194
file|"./parse.y"
block|{
name|prefix
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|18
case|:
line|#
directive|line
number|196
file|"./parse.y"
block|{
name|yyclass
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|19
case|:
line|#
directive|line
number|200
file|"./parse.y"
block|{
name|scon_stk_ptr
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
line|#
directive|line
number|202
file|"./parse.y"
block|{
name|scon_stk_ptr
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|22
case|:
line|#
directive|line
number|207
file|"./parse.y"
block|{
comment|/* Initialize for a parse of one rule. */
name|trlcontxt
operator|=
name|variable_trail_rule
operator|=
name|varlength
operator|=
name|false
expr_stmt|;
name|trailcnt
operator|=
name|headcnt
operator|=
name|rulelen
operator|=
literal|0
expr_stmt|;
name|current_state_type
operator|=
name|STATE_NORMAL
expr_stmt|;
name|previous_continued_action
operator|=
name|continued_action
expr_stmt|;
name|in_rule
operator|=
name|true
expr_stmt|;
name|new_rule
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|23
case|:
line|#
directive|line
number|220
file|"./parse.y"
block|{
name|pat
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
name|finish_rule
argument_list|(
name|pat
argument_list|,
name|variable_trail_rule
argument_list|,
name|headcnt
argument_list|,
name|trailcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scon_stk_ptr
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
name|scbol
index|[
name|scon_stk
index|[
name|i
index|]
index|]
operator|=
name|mkbranch
argument_list|(
name|scbol
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add to all non-exclusive start conditions, 				 * including the default (0) start condition. 				 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|scxclu
index|[
name|i
index|]
condition|)
name|scbol
index|[
name|i
index|]
operator|=
name|mkbranch
argument_list|(
name|scbol
index|[
name|i
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bol_needed
condition|)
block|{
name|bol_needed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|1
condition|)
name|pinpoint_message
argument_list|(
literal|"'^' operator results in sub-optimal performance"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|24
case|:
line|#
directive|line
number|256
file|"./parse.y"
block|{
name|pat
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
name|finish_rule
argument_list|(
name|pat
argument_list|,
name|variable_trail_rule
argument_list|,
name|headcnt
argument_list|,
name|trailcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|scon_stk_ptr
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
name|scset
index|[
name|scon_stk
index|[
name|i
index|]
index|]
operator|=
name|mkbranch
argument_list|(
name|scset
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|scxclu
index|[
name|i
index|]
condition|)
name|scset
index|[
name|i
index|]
operator|=
name|mkbranch
argument_list|(
name|scset
index|[
name|i
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|25
case|:
line|#
directive|line
number|280
file|"./parse.y"
block|{
if|if
condition|(
name|scon_stk_ptr
operator|>
literal|0
condition|)
name|build_eof_action
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* This EOF applies to all start conditions 				 * which don't already have EOF actions. 				 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sceof
index|[
name|i
index|]
condition|)
name|scon_stk
index|[
operator|++
name|scon_stk_ptr
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|scon_stk_ptr
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"all start conditions already have<<EOF>> rules"
argument_list|)
expr_stmt|;
else|else
name|build_eof_action
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|26
case|:
line|#
directive|line
number|303
file|"./parse.y"
block|{
name|synerr
argument_list|(
literal|"unrecognized rule"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|27
case|:
line|#
directive|line
number|307
file|"./parse.y"
block|{
name|yyval
operator|=
name|scon_stk_ptr
expr_stmt|;
block|}
break|break;
case|case
literal|28
case|:
line|#
directive|line
number|311
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|29
case|:
line|#
directive|line
number|314
file|"./parse.y"
block|{
name|yyval
operator|=
name|scon_stk_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|scon_stk
index|[
name|j
index|]
operator|==
name|i
condition|)
break|break;
if|if
condition|(
name|j
operator|>
name|scon_stk_ptr
condition|)
name|scon_stk
index|[
operator|++
name|scon_stk_ptr
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|30
case|:
line|#
directive|line
number|331
file|"./parse.y"
block|{
name|yyval
operator|=
name|scon_stk_ptr
expr_stmt|;
block|}
break|break;
case|case
literal|33
case|:
line|#
directive|line
number|339
file|"./parse.y"
block|{
name|synerr
argument_list|(
literal|"bad start condition list"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|34
case|:
line|#
directive|line
number|343
file|"./parse.y"
block|{
if|if
condition|(
operator|(
name|scnum
operator|=
name|sclookup
argument_list|(
name|nmstr
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|format_pinpoint_message
argument_list|(
literal|"undeclared start condition %s"
argument_list|,
name|nmstr
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|scon_stk
index|[
name|i
index|]
operator|==
name|scnum
condition|)
block|{
name|format_warn
argument_list|(
literal|"<%s> specified twice"
argument_list|,
name|scname
index|[
name|scnum
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|scon_stk_ptr
condition|)
name|scon_stk
index|[
operator|++
name|scon_stk_ptr
index|]
operator|=
name|scnum
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|35
case|:
line|#
directive|line
number|366
file|"./parse.y"
block|{
if|if
condition|(
name|transchar
index|[
name|lastst
index|[
name|yyvsp
index|[
literal|0
index|]
index|]
index|]
operator|!=
name|SYM_EPSILON
condition|)
comment|/* Provide final transition \now/ so it 				 * will be marked as a trailing context 				 * state. 				 */
name|yyvsp
index|[
literal|0
index|]
operator|=
name|link_machines
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|,
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
argument_list|)
expr_stmt|;
name|mark_beginning_as_normal
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|current_state_type
operator|=
name|STATE_NORMAL
expr_stmt|;
if|if
condition|(
name|previous_continued_action
condition|)
block|{
comment|/* We need to treat this as variable trailing 				 * context so that the backup does not happen 				 * in the action but before the action switch 				 * statement.  If the backup happens in the 				 * action, then the rules "falling into" this 				 * one's action will *also* do the backup, 				 * erroneously. 				 */
if|if
condition|(
operator|!
name|varlength
operator|||
name|headcnt
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"trailing context made variable due to preceding '|' action"
argument_list|)
expr_stmt|;
comment|/* Mark as variable. */
name|varlength
operator|=
name|true
expr_stmt|;
name|headcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lex_compat
operator|||
operator|(
name|varlength
operator|&&
name|headcnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* variable trailing context rule */
comment|/* Mark the first part of the rule as the 				 * accepting "head" part of a trailing 				 * context rule. 				 * 				 * By the way, we didn't do this at the 				 * beginning of this production because back 				 * then current_state_type was set up for a 				 * trail rule, and add_accept() can create 				 * a new state ... 				 */
name|add_accept
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|num_rules
operator||
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
name|variable_trail_rule
operator|=
name|true
expr_stmt|;
block|}
else|else
name|trailcnt
operator|=
name|rulelen
expr_stmt|;
name|yyval
operator|=
name|link_machines
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|36
case|:
line|#
directive|line
number|421
file|"./parse.y"
block|{
name|synerr
argument_list|(
literal|"trailing context used twice"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|37
case|:
line|#
directive|line
number|424
file|"./parse.y"
block|{
name|headcnt
operator|=
literal|0
expr_stmt|;
name|trailcnt
operator|=
literal|1
expr_stmt|;
name|rulelen
operator|=
literal|1
expr_stmt|;
name|varlength
operator|=
name|false
expr_stmt|;
name|current_state_type
operator|=
name|STATE_TRAILING_CONTEXT
expr_stmt|;
if|if
condition|(
name|trlcontxt
condition|)
block|{
name|synerr
argument_list|(
literal|"trailing context used twice"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|previous_continued_action
condition|)
block|{
comment|/* See the comment in the rule for "re2 re" 				 * above. 				 */
name|warn
argument_list|(
literal|"trailing context made variable due to preceding '|' action"
argument_list|)
expr_stmt|;
name|varlength
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|lex_compat
operator|||
name|varlength
condition|)
block|{
comment|/* Again, see the comment in the rule for 				 * "re2 re" above. 				 */
name|add_accept
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|num_rules
operator||
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
name|variable_trail_rule
operator|=
name|true
expr_stmt|;
block|}
name|trlcontxt
operator|=
name|true
expr_stmt|;
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|link_machines
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|link_machines
argument_list|(
name|eps
argument_list|,
name|mkstate
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|38
case|:
line|#
directive|line
number|467
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|trlcontxt
condition|)
block|{
if|if
condition|(
name|lex_compat
operator|||
operator|(
name|varlength
operator|&&
name|headcnt
operator|==
literal|0
operator|)
condition|)
comment|/* Both head and trail are 					 * variable-length. 					 */
name|variable_trail_rule
operator|=
name|true
expr_stmt|;
else|else
name|trailcnt
operator|=
name|rulelen
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|39
case|:
line|#
directive|line
number|485
file|"./parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkor
argument_list|(
name|yyvsp
index|[
operator|-
literal|2
index|]
argument_list|,
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|40
case|:
line|#
directive|line
number|491
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|41
case|:
line|#
directive|line
number|496
file|"./parse.y"
block|{
comment|/* This rule is written separately so the 			 * reduction will occur before the trailing 			 * series is parsed. 			 */
if|if
condition|(
name|trlcontxt
condition|)
name|synerr
argument_list|(
literal|"trailing context used twice"
argument_list|)
expr_stmt|;
else|else
name|trlcontxt
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|varlength
condition|)
comment|/* We hope the trailing context is 				 * fixed-length. 				 */
name|varlength
operator|=
name|false
expr_stmt|;
else|else
name|headcnt
operator|=
name|rulelen
expr_stmt|;
name|rulelen
operator|=
literal|0
expr_stmt|;
name|current_state_type
operator|=
name|STATE_TRAILING_CONTEXT
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|42
case|:
line|#
directive|line
number|523
file|"./parse.y"
block|{
comment|/* This is where concatenation of adjacent patterns 			 * gets done. 			 */
name|yyval
operator|=
name|link_machines
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|43
case|:
line|#
directive|line
number|531
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|44
case|:
line|#
directive|line
number|535
file|"./parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkclos
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|45
case|:
line|#
directive|line
number|542
file|"./parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkposcl
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|46
case|:
line|#
directive|line
number|548
file|"./parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkopt
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|47
case|:
line|#
directive|line
number|554
file|"./parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|>
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|||
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|<
literal|0
condition|)
block|{
name|synerr
argument_list|(
literal|"bad iteration values"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|3
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
literal|"bad iteration values"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|5
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkopt
argument_list|(
name|mkrep
argument_list|(
name|yyvsp
index|[
operator|-
literal|5
index|]
argument_list|,
literal|1
argument_list|,
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkrep
argument_list|(
name|yyvsp
index|[
operator|-
literal|5
index|]
argument_list|,
name|yyvsp
index|[
operator|-
literal|3
index|]
argument_list|,
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|48
case|:
line|#
directive|line
number|582
file|"./parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
literal|"iteration value must be positive"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|4
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkrep
argument_list|(
name|yyvsp
index|[
operator|-
literal|4
index|]
argument_list|,
name|yyvsp
index|[
operator|-
literal|2
index|]
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|49
case|:
line|#
directive|line
number|596
file|"./parse.y"
block|{
comment|/* The singleton could be something like "(foo)", 			 * in which case we have no idea what its length 			 * is, so we punt here. 			 */
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
literal|"iteration value must be positive"
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|link_machines
argument_list|(
name|yyvsp
index|[
operator|-
literal|3
index|]
argument_list|,
name|copysingl
argument_list|(
name|yyvsp
index|[
operator|-
literal|3
index|]
argument_list|,
name|yyvsp
index|[
operator|-
literal|1
index|]
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|50
case|:
line|#
directive|line
number|615
file|"./parse.y"
block|{
if|if
condition|(
operator|!
name|madeany
condition|)
block|{
comment|/* Create the '.' character class. */
name|anyccl
operator|=
name|cclinit
argument_list|()
expr_stmt|;
name|ccladd
argument_list|(
name|anyccl
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|cclnegate
argument_list|(
name|anyccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|mkeccl
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|anyccl
index|]
argument_list|,
name|ccllen
index|[
name|anyccl
index|]
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|madeany
operator|=
name|true
expr_stmt|;
block|}
operator|++
name|rulelen
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|anyccl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|51
case|:
line|#
directive|line
number|637
file|"./parse.y"
block|{
if|if
condition|(
operator|!
name|cclsorted
condition|)
comment|/* Sort characters for fast searching.  We 				 * use a shell sort since this list could 				 * be large. 				 */
name|cshell
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|yyvsp
index|[
literal|0
index|]
index|]
argument_list|,
name|ccllen
index|[
name|yyvsp
index|[
literal|0
index|]
index|]
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|mkeccl
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|yyvsp
index|[
literal|0
index|]
index|]
argument_list|,
name|ccllen
index|[
name|yyvsp
index|[
literal|0
index|]
index|]
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
operator|++
name|rulelen
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|52
case|:
line|#
directive|line
number|655
file|"./parse.y"
block|{
operator|++
name|rulelen
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|53
case|:
line|#
directive|line
number|662
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|54
case|:
line|#
directive|line
number|665
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|55
case|:
line|#
directive|line
number|668
file|"./parse.y"
block|{
operator|++
name|rulelen
expr_stmt|;
if|if
condition|(
name|caseins
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|yyvsp
index|[
literal|0
index|]
operator|=
name|clower
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|56
case|:
line|#
directive|line
number|679
file|"./parse.y"
block|{
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|57
case|:
line|#
directive|line
number|682
file|"./parse.y"
block|{
name|cclnegate
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|58
case|:
line|#
directive|line
number|689
file|"./parse.y"
block|{
if|if
condition|(
name|caseins
condition|)
block|{
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|>=
literal|'A'
operator|&&
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|<=
literal|'Z'
condition|)
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|=
name|clower
argument_list|(
name|yyvsp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyvsp
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|yyvsp
index|[
literal|0
index|]
operator|=
name|clower
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|>
name|yyvsp
index|[
literal|0
index|]
condition|)
name|synerr
argument_list|(
literal|"negative range in character class"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|yyvsp
index|[
operator|-
literal|2
index|]
init|;
name|i
operator|<=
name|yyvsp
index|[
literal|0
index|]
condition|;
operator|++
name|i
control|)
name|ccladd
argument_list|(
name|yyvsp
index|[
operator|-
literal|3
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Keep track if this ccl is staying in 				 * alphabetical order. 				 */
name|cclsorted
operator|=
name|cclsorted
operator|&&
operator|(
name|yyvsp
index|[
operator|-
literal|2
index|]
operator|>
name|lastchar
operator|)
expr_stmt|;
name|lastchar
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
block|}
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|59
case|:
line|#
directive|line
number|717
file|"./parse.y"
block|{
if|if
condition|(
name|caseins
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|yyvsp
index|[
literal|0
index|]
operator|=
name|clower
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ccladd
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cclsorted
operator|=
name|cclsorted
operator|&&
operator|(
name|yyvsp
index|[
literal|0
index|]
operator|>
name|lastchar
operator|)
expr_stmt|;
name|lastchar
operator|=
name|yyvsp
index|[
literal|0
index|]
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|60
case|:
line|#
directive|line
number|728
file|"./parse.y"
block|{
comment|/* Too hard to properly maintain cclsorted. */
name|cclsorted
operator|=
name|false
expr_stmt|;
name|yyval
operator|=
name|yyvsp
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|61
case|:
line|#
directive|line
number|735
file|"./parse.y"
block|{
name|cclsorted
operator|=
name|true
expr_stmt|;
name|lastchar
operator|=
literal|0
expr_stmt|;
name|currccl
operator|=
name|yyval
operator|=
name|cclinit
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|62
case|:
line|#
directive|line
number|742
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isalnum
argument_list|)
block|}
break|break;
case|case
literal|63
case|:
line|#
directive|line
number|743
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isalpha
argument_list|)
block|}
break|break;
case|case
literal|64
case|:
line|#
directive|line
number|744
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|IS_BLANK
argument_list|)
block|}
break|break;
case|case
literal|65
case|:
line|#
directive|line
number|745
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|iscntrl
argument_list|)
block|}
break|break;
case|case
literal|66
case|:
line|#
directive|line
number|746
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isdigit
argument_list|)
block|}
break|break;
case|case
literal|67
case|:
line|#
directive|line
number|747
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isgraph
argument_list|)
block|}
break|break;
case|case
literal|68
case|:
line|#
directive|line
number|748
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|islower
argument_list|)
block|}
break|break;
case|case
literal|69
case|:
line|#
directive|line
number|749
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isprint
argument_list|)
block|}
break|break;
case|case
literal|70
case|:
line|#
directive|line
number|750
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|ispunct
argument_list|)
block|}
break|break;
case|case
literal|71
case|:
line|#
directive|line
number|751
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isspace
argument_list|)
block|}
break|break;
case|case
literal|72
case|:
line|#
directive|line
number|752
file|"./parse.y"
block|{
if|if
condition|(
name|caseins
condition|)
name|CCL_EXPR
argument_list|(
argument|islower
argument_list|)
else|else
name|CCL_EXPR
argument_list|(
argument|isupper
argument_list|)
block|}
break|break;
case|case
literal|73
case|:
line|#
directive|line
number|758
file|"./parse.y"
block|{
name|CCL_EXPR
argument_list|(
argument|isxdigit
argument_list|)
block|}
break|break;
case|case
literal|74
case|:
line|#
directive|line
number|762
file|"./parse.y"
block|{
if|if
condition|(
name|caseins
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|yyvsp
index|[
literal|0
index|]
operator|<=
literal|'Z'
condition|)
name|yyvsp
index|[
literal|0
index|]
operator|=
name|clower
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|++
name|rulelen
expr_stmt|;
name|yyval
operator|=
name|link_machines
argument_list|(
name|yyvsp
index|[
operator|-
literal|1
index|]
argument_list|,
name|mkstate
argument_list|(
name|yyvsp
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|75
case|:
line|#
directive|line
number|772
file|"./parse.y"
block|{
name|yyval
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
block|}
break|break;
line|#
directive|line
number|1397
file|"y.tab.c"
block|}
name|yyssp
operator|-=
name|yym
expr_stmt|;
name|yystate
operator|=
operator|*
name|yyssp
expr_stmt|;
name|yyvsp
operator|-=
name|yym
expr_stmt|;
name|yym
operator|=
name|yylhs
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yystate
operator|==
literal|0
operator|&&
name|yym
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: after reduction, shifting from state 0 to\  state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|YYFINAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yyssp
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yyval
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|yychar
operator|=
name|yylex
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|yys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<=
name|YYMAXTOKEN
condition|)
name|yys
operator|=
name|yyname
index|[
name|yychar
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|yys
condition|)
name|yys
operator|=
literal|"illegal-symbol"
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, reading %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|YYFINAL
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyaccept
goto|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yygindex
index|[
name|yym
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yystate
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|yystate
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydgoto
index|[
name|yym
index|]
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: after reduction, shifting from state %d \ to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yyssp
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yyssp
operator|>=
name|yyss
operator|+
name|yystacksize
operator|-
literal|1
condition|)
block|{
goto|goto
name|yyoverflow
goto|;
block|}
operator|*
operator|++
name|yyssp
operator|=
name|yystate
expr_stmt|;
operator|*
operator|++
name|yyvsp
operator|=
name|yyval
expr_stmt|;
goto|goto
name|yyloop
goto|;
name|yyoverflow
label|:
name|yyerror
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
name|yyabort
label|:
return|return
operator|(
literal|1
operator|)
return|;
name|yyaccept
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

