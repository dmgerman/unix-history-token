begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: ng.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"artsrch.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"art.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"ngstuff.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"respond.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"backpage.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_include
include|#
directive|include
file|"rt-wumpus.h"
end_include

begin_include
include|#
directive|include
file|"decode.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"artstate.h"
end_include

begin_comment
comment|/* somebody has to do it */
end_comment

begin_comment
comment|/* art_switch() return values */
end_comment

begin_define
define|#
directive|define
name|AS_NORM
value|0
end_define

begin_define
define|#
directive|define
name|AS_INP
value|1
end_define

begin_define
define|#
directive|define
name|AS_ASK
value|2
end_define

begin_define
define|#
directive|define
name|AS_CLEAN
value|3
end_define

begin_decl_stmt
name|int
name|exit_code
init|=
name|NG_NORM
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ng_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|KILLFILES
name|open_kfile
argument_list|(
name|KF_GLOBAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CUSTOMLINES
name|init_compex
argument_list|(
operator|&
name|hide_compex
argument_list|)
expr_stmt|;
name|init_compex
argument_list|(
operator|&
name|page_compex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* do newsgroup on line ng with name ngname */
end_comment

begin_comment
comment|/* assumes that we are chdir'ed to NEWSSPOOL, and assures that that is  * still true upon return, but chdirs to NEWSSPOOL/ngname in between  *  * If you can understand this routine, you understand most of the program.  * The basic structure is:  *	for each desired article  *		for each desired page  *			for each line on page  *				if we need another line from file  *					get it  *					if it's a header line  *						do special things  *				for each column on page  *					put out a character  *				end loop  *			end loop  *		end loop  *	end loop  *  *	(Actually, the pager is in another routine.)  *  * The chief problem is deciding what is meant by "desired".  Most of  * the messiness of this routine is due to the fact that people want  * to do unstructured things all the time.  I have used a few judicious  * goto's where I thought it improved readability.  The rest of the messiness  * arises from trying to be both space and time efficient.  Have fun.  */
end_comment

begin_function
name|int
name|do_newsgroup
parameter_list|(
name|start_command
parameter_list|)
name|char
modifier|*
name|start_command
decl_stmt|;
comment|/* command to fake up first */
block|{
name|char
name|oldmode
init|=
name|mode
decl_stmt|;
name|char
modifier|*
name|whatnext
init|=
literal|"%sWhat next? [%s]"
decl_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
operator|(
name|scanon
operator|&&
operator|!
name|ThreadedGroup
comment|/* did they say -S? */
operator|&&
operator|(
operator|(
name|ART_NUM
operator|)
name|toread
index|[
name|ng
index|]
operator|)
operator|>=
name|scanon
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
name|exit_code
operator|=
name|NG_NORM
expr_stmt|;
name|save_ids
operator|=
name|FALSE
expr_stmt|;
name|killfirst
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|extractdest
condition|)
block|{
name|free
argument_list|(
name|extractdest
argument_list|)
expr_stmt|;
name|extractdest
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|extractprog
condition|)
block|{
name|free
argument_list|(
name|extractprog
argument_list|)
expr_stmt|;
name|extractprog
operator|=
name|Nullch
expr_stmt|;
block|}
comment|/* initialize the newsgroup data structures */
if|if
condition|(
operator|!
name|access_ng
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|/* FROM HERE ON, RETURN THRU CLEANUP OR WE ARE SCREWED */
name|in_ng
operator|=
name|TRUE
expr_stmt|;
comment|/* tell the world we are here */
name|forcelast
operator|=
name|TRUE
expr_stmt|;
comment|/* if 0 unread, do not bomb out */
name|recent_artp
operator|=
name|curr_artp
operator|=
name|Nullart
expr_stmt|;
name|recent_art
operator|=
name|curr_art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|prompt
operator|=
name|whatnext
expr_stmt|;
comment|/* remember what newsgroup we were in for sake of posterity */
name|writelast
argument_list|()
expr_stmt|;
comment|/* see if there are any special searches to do */
name|has_normal_kills
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|KILLFILES
name|open_kfile
argument_list|(
name|KF_LOCAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|kill_unwanted
argument_list|(
name|firstart
argument_list|,
literal|"Processing memorized commands...\n\n"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|kill_unwanted
argument_list|(
name|firstart
argument_list|,
literal|"Auto-processing...\n\n"
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|selected_count
condition|)
name|selected_only
operator|=
name|FALSE
expr_stmt|;
name|top_article
argument_list|()
expr_stmt|;
comment|/* do they want a special top line? */
name|firstline
operator|=
name|getval
argument_list|(
literal|"FIRSTLINE"
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
comment|/* custom line suppression, custom page ending */
ifdef|#
directive|ifdef
name|CUSTOMLINES
if|if
condition|(
name|hideline
operator|=
name|getval
argument_list|(
literal|"HIDELINE"
argument_list|,
name|Nullch
argument_list|)
condition|)
name|compile
argument_list|(
operator|&
name|hide_compex
argument_list|,
name|hideline
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagestop
operator|=
name|getval
argument_list|(
literal|"PAGESTOP"
argument_list|,
name|Nullch
argument_list|)
condition|)
name|compile
argument_list|(
operator|&
name|page_compex
argument_list|,
name|pagestop
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* now read each unread article */
name|rc_changed
operator|=
name|doing_ng
operator|=
name|TRUE
expr_stmt|;
comment|/* enter the twilight zone */
name|checkcount
operator|=
literal|0
expr_stmt|;
comment|/* do not checkpoint for a while */
name|do_fseek
operator|=
name|FALSE
expr_stmt|;
comment|/* start 1st article at top */
for|for
control|(
init|;
name|art
operator|<=
name|lastart
operator|+
literal|1
condition|;
control|)
block|{
comment|/* for each article */
name|mode
operator|=
literal|'a'
expr_stmt|;
comment|/* do we need to "grow" the newsgroup? */
if|if
condition|(
name|art
operator|>
name|lastart
operator|||
name|forcegrow
condition|)
block|{
name|ART_NUM
name|oldlast
init|=
name|lastart
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_NNTP
name|ART_NUM
name|newlast
init|=
name|lastart
decl_stmt|;
while|while
condition|(
name|nntp_stat
argument_list|(
name|newlast
operator|+
literal|1
argument_list|)
condition|)
name|newlast
operator|++
expr_stmt|;
if|if
condition|(
name|newlast
operator|>
name|oldlast
condition|)
block|{
name|ngmax
index|[
name|ng
index|]
operator|=
name|newlast
expr_stmt|;
name|grow_ng
argument_list|(
name|newlast
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|grow_ng
argument_list|(
name|getngsize
argument_list|(
name|ng
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|forcelast
operator|&&
name|art
operator|>
name|oldlast
condition|)
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
block|}
name|find_article
argument_list|(
name|art
argument_list|)
expr_stmt|;
comment|/* sets artp */
if|if
condition|(
name|start_command
condition|)
block|{
comment|/* do we have an initial command? */
name|pushstring
argument_list|(
name|start_command
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|start_command
argument_list|)
expr_stmt|;
name|start_command
operator|=
name|Nullch
expr_stmt|;
name|art
operator|=
name|curr_art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|artp
operator|=
name|curr_artp
operator|=
name|Nullart
expr_stmt|;
if|if
condition|(
name|input_pending
argument_list|()
condition|)
goto|goto
name|reinp_article
goto|;
block|}
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
block|{
comment|/* are we off the end still? */
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|ART_NUM
name|i
decl_stmt|;
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
comment|/* keep pointer references sane */
if|if
condition|(
operator|!
name|forcelast
operator|&&
name|toread
index|[
name|ng
index|]
operator|&&
name|selected_only
operator|&&
operator|!
name|selected_count
condition|)
block|{
name|art
operator|=
name|curr_art
expr_stmt|;
name|artp
operator|=
name|curr_artp
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
goto|goto
name|article_level
goto|;
block|}
name|count_subjects
argument_list|(
name|CS_NORM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|last_cached
operator|+
literal|1
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
condition|)
name|article_count
operator|++
expr_stmt|;
name|toread
index|[
name|ng
index|]
operator|=
operator|(
name|ART_UNREAD
operator|)
name|article_count
expr_stmt|;
if|if
condition|(
name|artp
operator|!=
name|curr_artp
condition|)
block|{
name|recent_art
operator|=
name|curr_art
expr_stmt|;
comment|/* remember last article # (for '-') */
name|curr_art
operator|=
name|art
expr_stmt|;
comment|/* set current article # */
name|recent_artp
operator|=
name|curr_artp
expr_stmt|;
name|curr_artp
operator|=
name|artp
expr_stmt|;
block|}
if|if
condition|(
name|erase_screen
condition|)
name|clear
argument_list|()
expr_stmt|;
comment|/* clear the screen */
else|else
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"End of newsgroup %s."
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
comment|/* print pseudo-article */
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"End of %s"
argument_list|,
name|ngname
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|article_count
condition|)
block|{
if|if
condition|(
name|selected_only
condition|)
name|printf
argument_list|(
literal|"  (%ld + %ld articles still unread)"
argument_list|,
operator|(
name|long
operator|)
name|selected_count
argument_list|,
operator|(
name|long
operator|)
name|article_count
operator|-
name|selected_count
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  (%ld article%s still unread)"
argument_list|,
operator|(
name|long
operator|)
name|article_count
argument_list|,
name|article_count
operator|==
literal|1
condition|?
name|nullstr
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|forcelast
condition|)
goto|goto
name|cleanup
goto|;
comment|/* actually exit newsgroup */
name|mode
operator|=
literal|'e'
expr_stmt|;
name|prompt
operator|=
name|whatnext
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
comment|/* no more subject search mode */
endif|#
directive|endif
name|fputs
argument_list|(
literal|"\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|reread
operator|&&
operator|(
name|was_read
argument_list|(
name|art
argument_list|)
operator|||
operator|(
name|artp
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
operator|||
operator|(
name|selected_only
operator|&&
operator|!
operator|(
name|artp
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* has this article been read? */
name|inc_art
argument_list|(
name|selected_only
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* then skip it */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|reread
operator|&&
operator|!
name|parseheader
argument_list|(
name|art
argument_list|)
condition|)
block|{
name|oneless
argument_list|(
name|artp
argument_list|)
expr_stmt|;
comment|/* mark deleted as read */
name|ng_skip
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* we have a real live article */
if|if
condition|(
name|artp
operator|!=
name|curr_artp
condition|)
block|{
name|recent_art
operator|=
name|curr_art
expr_stmt|;
comment|/* remember last article # (for '-') */
name|curr_art
operator|=
name|art
expr_stmt|;
comment|/* set current article # */
name|recent_artp
operator|=
name|curr_artp
expr_stmt|;
name|curr_artp
operator|=
name|artp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_fseek
condition|)
block|{
comment|/* starting at top of article? */
name|artline
operator|=
literal|0
expr_stmt|;
comment|/* start at the beginning */
name|topline
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and remember top line of screen */
comment|/*  (line # within article file) */
block|}
name|clear
argument_list|()
expr_stmt|;
comment|/* clear screen */
if|if
condition|(
operator|!
name|artopen
argument_list|(
name|art
argument_list|)
condition|)
block|{
comment|/* make sure article is found& open */
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
comment|/* see if we have tree data for this article anyway */
name|init_tree
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s: article is not available."
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
if|if
condition|(
name|artp
operator|&&
operator|!
operator|(
name|artp
operator|->
name|flags
operator|&
name|AF_CACHED
operator|)
condition|)
block|{
if|if
condition|(
name|absfirst
operator|<
name|first_cached
operator|||
name|last_cached
operator|<
name|lastart
operator|||
operator|!
name|cached_all_in_range
condition|)
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s: article may show up in a moment."
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
block|}
name|tree_puts
argument_list|(
name|tmpbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vwtary
argument_list|(
operator|(
name|ART_LINE
operator|)
literal|0
argument_list|,
operator|(
name|ART_POS
operator|)
literal|0
argument_list|)
expr_stmt|;
name|finish_tree
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|prompt
operator|=
name|whatnext
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* found it, so print it */
switch|switch
condition|(
name|do_article
argument_list|()
condition|)
block|{
case|case
name|DA_CLEAN
case|:
comment|/* quit newsgroup */
goto|goto
name|cleanup
goto|;
case|case
name|DA_TOEND
case|:
comment|/* do not mark as read */
goto|goto
name|reask_article
goto|;
case|case
name|DA_RAISE
case|:
comment|/* reparse command at end of art */
goto|goto
name|article_level
goto|;
case|case
name|DA_NORM
case|:
comment|/* normal end of article */
break|break;
block|}
block|}
if|if
condition|(
name|art
operator|>=
name|absfirst
condition|)
comment|/* don't mark non-existant articles */
name|mark_as_read
argument_list|()
expr_stmt|;
comment|/* mark current article as read */
name|do_hiding
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ROTATION
name|rotate
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if these gotos bother you, think of this as a little state machine */
name|reask_article
label|:
ifdef|#
directive|ifdef
name|MAILCALL
name|setmail
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setdfltcmd
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAREOL
if|if
condition|(
name|erase_screen
operator|&&
name|can_home_clear
condition|)
name|clear_rest
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CLEAREOL */
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
name|standout
argument_list|()
expr_stmt|;
comment|/* enter standout mode */
name|printf
argument_list|(
name|prompt
argument_list|,
name|mailcall
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
comment|/* print prompt, whatever it is */
name|un_standout
argument_list|()
expr_stmt|;
comment|/* leave standout mode */
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reinp_article
label|:
name|reread
operator|=
name|FALSE
expr_stmt|;
name|forcelast
operator|=
name|FALSE
expr_stmt|;
name|eat_typeahead
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PENDING
name|look_ahead
argument_list|()
expr_stmt|;
comment|/* see what we can do in advance */
name|cache_until_key
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|art
operator|=
name|curr_art
expr_stmt|;
name|artp
operator|=
name|curr_artp
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
if|if
condition|(
name|LINES
operator|<
literal|100
operator|&&
operator|!
name|int_count
condition|)
operator|*
name|buf
operator|=
literal|'\f'
expr_stmt|;
comment|/* on CONT fake up refresh */
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* but only on a crt */
goto|goto
name|reask_article
goto|;
block|}
block|}
name|article_level
label|:
name|output_chase_phrase
operator|=
name|TRUE
expr_stmt|;
comment|/* parse and process article level command */
switch|switch
condition|(
name|art_switch
argument_list|()
condition|)
block|{
case|case
name|AS_INP
case|:
comment|/* multichar command rubbed out */
goto|goto
name|reinp_article
goto|;
case|case
name|AS_ASK
case|:
comment|/* reprompt "End of article..." */
goto|goto
name|reask_article
goto|;
case|case
name|AS_CLEAN
case|:
comment|/* exit newsgroup */
goto|goto
name|cleanup
goto|;
case|case
name|AS_NORM
case|:
comment|/* display article art */
break|break;
block|}
block|}
comment|/* end of article selection loop */
comment|/* shut down newsgroup */
name|cleanup
label|:
name|decode_end
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|KILLFILES
name|kill_unwanted
argument_list|(
name|firstart
argument_list|,
literal|"\nCleaning up...\n\n"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* do cleanup from KILL file, if any */
endif|#
directive|endif
name|in_ng
operator|=
name|FALSE
expr_stmt|;
comment|/* leave newsgroup state */
if|if
condition|(
name|artfp
operator|!=
name|Nullfp
condition|)
block|{
comment|/* article still open? */
name|fclose
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
comment|/* close it */
name|artfp
operator|=
name|Nullfp
expr_stmt|;
comment|/* and tell the world */
name|openart
operator|=
literal|0
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|deselect_all
argument_list|()
expr_stmt|;
name|yankback
argument_list|()
expr_stmt|;
comment|/* do a Y command */
name|bits_to_rc
argument_list|()
expr_stmt|;
comment|/* reconstitute .newsrc line */
name|doing_ng
operator|=
name|FALSE
expr_stmt|;
comment|/* tell sig_catcher to cool it */
name|write_rc
argument_list|()
expr_stmt|;
comment|/* and update .newsrc */
name|rc_changed
operator|=
name|FALSE
expr_stmt|;
comment|/* tell sig_catcher it is ok */
if|if
condition|(
name|chdir
argument_list|(
name|spool
argument_list|)
condition|)
block|{
name|printf
argument_list|(
argument|nocd
argument_list|,
argument|spool
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KILLFILES
if|if
condition|(
name|localkfp
condition|)
block|{
name|fclose
argument_list|(
name|localkfp
argument_list|)
expr_stmt|;
name|localkfp
operator|=
name|Nullfp
expr_stmt|;
block|}
endif|#
directive|endif
name|mode
operator|=
name|oldmode
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

begin_comment
comment|/* Whew! */
end_comment

begin_comment
comment|/* decide what to do at the end of an article */
end_comment

begin_function
name|int
name|art_switch
parameter_list|()
block|{
specifier|register
name|ART_NUM
name|i
decl_stmt|;
name|setdef
argument_list|(
name|buf
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'<'
case|:
comment|/* goto previous subject/thread */
name|prev_subject
argument_list|()
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
literal|'>'
case|:
comment|/* goto next subject/thread */
name|next_subject
argument_list|()
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
literal|'U'
case|:
block|{
comment|/* unread some articles */
name|char
modifier|*
name|u_prompt
decl_stmt|,
modifier|*
name|u_help_thread
decl_stmt|;
name|dfltcmd
operator|=
literal|"+"
expr_stmt|;
if|if
condition|(
operator|!
name|artp
condition|)
block|{
name|u_help_thread
operator|=
name|nullstr
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|u_prompt
operator|=
literal|"\nSet unread: +select or all? [+an] "
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|u_prompt
init|=
literal|"\nSet unread? [+an] "
decl_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
block|{
name|u_prompt
operator|=
literal|"\n\ Set unread: +select, thread, subthread, or all? [+tsan] "
expr_stmt|;
name|u_help_thread
operator|=
literal|"\ Type t or SP to mark this thread's articles as unread.\n\ Type s to mark the current article and its descendants as unread.\n"
expr_stmt|;
block|}
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
block|{
name|u_prompt
operator|=
literal|"\nSet unread? [+tsan] "
expr_stmt|;
name|u_help_thread
operator|=
literal|"\ t or SP to mark thread unread.\n\ s to mark subthread unread.\n"
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|reask_unread
label|:
name|in_char
argument_list|(
name|u_prompt
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
name|setdef
argument_list|(
name|buf
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'h'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
block|{
name|fputs
argument_list|(
literal|"\ Type + to enter select thread mode using all the unread articles.\n\ (The selected threads will be marked as unread and displayed as usual.)\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|fputs
argument_list|(
name|u_help_thread
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ Type a to mark all articles in this group as unread.\n\ Type n to change nothing.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
block|}
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
block|{
name|fputs
argument_list|(
literal|"\ + to select threads from the unread.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|fputs
argument_list|(
name|u_help_thread
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ a to mark all articles unread.\n\ n to change nothing.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|reask_unread
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'n'
operator|||
operator|*
name|buf
operator|==
literal|'q'
condition|)
return|return
name|AS_ASK
return|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'t'
operator|&&
name|u_help_thread
operator|!=
name|nullstr
condition|)
block|{
name|unkill_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|artp
operator|=
name|first_art
argument_list|(
name|artp
operator|->
name|subj
argument_list|)
operator|)
operator|!=
name|Nullart
condition|)
name|art
operator|=
name|article_num
argument_list|(
name|artp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'s'
operator|&&
name|u_help_thread
operator|!=
name|nullstr
condition|)
name|unkill_subthread
argument_list|(
name|artp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'a'
condition|)
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|check_first
argument_list|(
name|absfirst
argument_list|)
expr_stmt|;
name|ap
operator|=
name|article_ptr
argument_list|(
name|absfirst
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|absfirst
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_READ
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_READ
condition|)
block|{
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_READ
expr_stmt|;
comment|/* mark as unread */
name|toread
index|[
name|ng
index|]
operator|++
expr_stmt|;
block|}
name|count_subjects
argument_list|(
name|CS_NORM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'+'
condition|)
block|{
operator|*
name|buf
operator|=
literal|'U'
expr_stmt|;
goto|goto
name|run_the_selector
goto|;
block|}
else|else
block|{
name|fputs
argument_list|(
argument|hforhelp
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_unread
goto|;
block|}
return|return
name|AS_NORM
return|;
block|}
case|case
literal|'['
case|:
comment|/* goto parent article */
case|case
literal|'{'
case|:
comment|/* goto thread's root article */
if|if
condition|(
name|artp
condition|)
block|{
if|if
condition|(
operator|!
name|find_parent
argument_list|(
operator|*
name|buf
operator|==
literal|'{'
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|(
operator|*
name|buf
operator|==
literal|'['
condition|?
literal|"parent"
else|:
literal|"root"
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nThere is no %s article prior to this one.\n"
argument_list|,
argument|cp
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nNo prior %s.\n"
argument_list|,
name|cp
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
block|}
name|reread
operator|=
name|TRUE
expr_stmt|;
return|return
name|AS_NORM
return|;
block|}
name|not_threaded
label|:
if|if
condition|(
name|ThreadedGroup
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nThis article is not threaded.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nUnthreaded article.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nThis group is not threaded.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nUnthreaded group.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
case|case
literal|']'
case|:
comment|/* goto child article */
case|case
literal|'}'
case|:
comment|/* goto thread's leaf article */
if|if
condition|(
name|artp
condition|)
block|{
if|if
condition|(
operator|!
name|find_leaf
argument_list|(
operator|*
name|buf
operator|==
literal|'}'
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\ This is the last leaf in this tree.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nLast leaf.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
block|}
name|reread
operator|=
name|TRUE
expr_stmt|;
return|return
name|AS_NORM
return|;
block|}
goto|goto
name|not_threaded
goto|;
case|case
literal|'('
case|:
comment|/* goto previous sibling */
case|case
literal|')'
case|:
comment|/* goto next sibling */
if|if
condition|(
name|artp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|buf
operator|==
literal|'('
condition|?
name|find_prev_sib
argument_list|()
else|:
name|find_next_sib
argument_list|()
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
operator|(
operator|*
name|buf
operator|==
literal|'('
condition|?
literal|"previous"
else|:
literal|"next"
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nThis article has no %s sibling.\n"
argument_list|,
argument|cp
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nNo %s sibling.\n"
argument_list|,
name|cp
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
block|}
name|reread
operator|=
name|TRUE
expr_stmt|;
return|return
name|AS_NORM
return|;
block|}
goto|goto
name|not_threaded
goto|;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|ThreadedGroup
condition|)
goto|goto
name|not_threaded
goto|;
comment|/* FALL THROUGH */
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|artp
condition|)
block|{
name|printf
argument_list|(
literal|"You're not at an article.\n"
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
switch|switch
condition|(
name|ask_memorize
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
block|{
case|case
literal|','
case|:
case|case
literal|'j'
case|:
return|return
name|AS_NORM
return|;
block|}
return|return
name|AS_ASK
return|;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|artp
condition|)
block|{
name|printf
argument_list|(
literal|"You're not at an article.\n"
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
comment|/* first, write kill-subject command */
operator|(
name|void
operator|)
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|art
operator|=
name|curr_art
expr_stmt|;
name|artp
operator|=
name|curr_artp
expr_stmt|;
name|kill_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|,
name|KF_ALL
argument_list|)
expr_stmt|;
comment|/* take care of any prior subjects */
return|return
name|AS_NORM
return|;
case|case
literal|','
case|:
comment|/* kill this node and all descendants */
if|if
condition|(
name|ThreadedGroup
condition|)
name|kill_subthread
argument_list|(
name|artp
argument_list|,
name|KF_ALL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|art
operator|>=
name|absfirst
operator|&&
name|art
operator|<=
name|lastart
condition|)
name|mark_as_read
argument_list|()
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
literal|'J'
case|:
comment|/* Junk all nodes in this thread */
if|if
condition|(
name|ThreadedGroup
condition|)
block|{
name|kill_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|,
name|KF_ALL
argument_list|)
expr_stmt|;
return|return
name|AS_NORM
return|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'k'
case|:
comment|/* kill current subject */
name|kill_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|,
name|KF_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_cached
operator|<
name|lastart
condition|)
block|{
operator|*
name|buf
operator|=
literal|'k'
expr_stmt|;
goto|goto
name|normal_search
goto|;
block|}
return|return
name|AS_NORM
return|;
case|case
literal|'t'
case|:
name|carriage_return
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|CLEAREOL
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
else|#
directive|else
if|if
condition|(
name|erase_screen
operator|&&
name|can_home_clear
condition|)
name|clear_rest
argument_list|()
expr_stmt|;
else|else
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
endif|#
directive|endif
comment|/* CLEAREOL */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|page_line
operator|=
literal|1
expr_stmt|;
name|entire_tree
argument_list|(
name|curr_artp
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|':'
case|:
comment|/* execute command on selected articles */
name|page_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|use_selected
argument_list|()
condition|)
return|return
name|AS_INP
return|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|art
operator|=
name|curr_art
expr_stmt|;
name|artp
operator|=
name|curr_artp
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'p'
case|:
comment|/* find previous unread article */
do|do
block|{
name|dec_art
argument_list|(
name|selected_only
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|art
operator|>=
name|firstart
operator|&&
operator|(
name|was_read
argument_list|(
name|art
argument_list|)
operator|||
operator|!
name|parseheader
argument_list|(
name|art
argument_list|)
operator|)
condition|)
do|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|art
operator|>=
name|firstart
condition|)
return|return
name|AS_NORM
return|;
name|art
operator|=
name|absfirst
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'P'
case|:
comment|/* goto previous article */
name|dec_art
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|check_dec_art
label|:
if|if
condition|(
name|art
operator|<
name|absfirst
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nThere are no%s%s articles prior to this one.\n"
argument_list|,
argument|*buf==
literal|'P'
argument|?nullstr:
literal|" unread"
argument_list|,
argument|selected_only?
literal|" selected"
argument|:nullstr
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nNo previous%s%s articles\n"
argument_list|,
operator|*
name|buf
operator|==
literal|'P'
condition|?
name|nullstr
else|:
literal|" unread"
argument_list|,
name|selected_only
condition|?
literal|" selected"
else|:
name|nullstr
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|art
operator|=
name|curr_art
expr_stmt|;
name|artp
operator|=
name|curr_artp
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'-'
case|:
if|if
condition|(
name|recent_art
operator|>=
literal|0
condition|)
block|{
name|art
operator|=
name|recent_art
expr_stmt|;
name|artp
operator|=
name|recent_artp
expr_stmt|;
name|reread
operator|=
name|TRUE
expr_stmt|;
name|forcelast
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
operator|-
operator|(
name|srchahead
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
block|}
else|else
block|{
name|exit_code
operator|=
name|NG_MINUS
expr_stmt|;
return|return
name|AS_CLEAN
return|;
block|}
case|case
literal|'n'
case|:
comment|/* find next unread article? */
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
block|{
if|if
condition|(
operator|!
name|toread
index|[
name|ng
index|]
condition|)
return|return
name|AS_CLEAN
return|;
name|top_article
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARTSEARCH
elseif|else
if|if
condition|(
name|scanon
operator|&&
operator|!
name|ThreadedGroup
operator|&&
name|srchahead
condition|)
block|{
operator|*
name|buf
operator|=
name|Ctl
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_art_with_subj
argument_list|()
condition|)
goto|goto
name|normal_search
goto|;
return|return
name|AS_NORM
return|;
block|}
endif|#
directive|endif
else|else
name|inc_art
argument_list|(
name|selected_only
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'N'
case|:
comment|/* goto next article */
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
if|if
condition|(
operator|!
name|first_subject
condition|)
block|{
name|art
operator|=
name|absfirst
expr_stmt|;
name|artp
operator|=
name|article_ptr
argument_list|(
name|art
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|artp
operator|=
name|first_subject
operator|->
name|articles
expr_stmt|;
if|if
condition|(
name|artp
operator|->
name|flags
operator|&
name|AF_MISSING
condition|)
name|inc_art
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|art
operator|=
name|article_num
argument_list|(
name|artp
argument_list|)
expr_stmt|;
block|}
else|else
name|inc_art
argument_list|(
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'$'
case|:
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|artp
operator|=
name|Nullart
expr_stmt|;
name|forcelast
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
comment|/* goto specified article */
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
comment|/* or do something with a range */
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
name|forcelast
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|numnum
argument_list|()
condition|)
block|{
case|case
name|NN_INP
case|:
return|return
name|AS_INP
return|;
case|case
name|NN_ASK
case|:
return|return
name|AS_ASK
return|;
case|case
name|NN_REREAD
case|:
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
if|if
condition|(
name|srchahead
condition|)
name|srchahead
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NN_NORM
case|:
if|if
condition|(
name|was_read
argument_list|(
name|art
argument_list|)
condition|)
block|{
name|top_article
argument_list|()
expr_stmt|;
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
break|break;
block|}
return|return
name|AS_NORM
return|;
case|case
name|Ctl
argument_list|(
literal|'k'
argument_list|)
case|:
name|edit_kfile
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
name|Ctl
argument_list|(
literal|'n'
argument_list|)
case|:
comment|/* search for next article with same subject */
case|case
name|Ctl
argument_list|(
literal|'p'
argument_list|)
case|:
comment|/* search for previous article with same subject */
if|if
condition|(
operator|*
name|buf
operator|==
name|Ctl
argument_list|(
literal|'n'
argument_list|)
condition|?
name|next_art_with_subj
argument_list|()
else|:
name|prev_art_with_subj
argument_list|()
condition|)
return|return
name|AS_NORM
return|;
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
name|normal_search
label|:
ifdef|#
directive|ifdef
name|ARTSEARCH
block|{
comment|/* search for article by pattern */
name|char
name|cmd
init|=
operator|*
name|buf
decl_stmt|;
name|reread
operator|=
name|TRUE
expr_stmt|;
comment|/* assume this */
name|page_line
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|SRCH_ERROR
case|:
name|art
operator|=
name|curr_art
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
name|SRCH_ABORT
case|:
name|art
operator|=
name|curr_art
expr_stmt|;
return|return
name|AS_INP
return|;
case|case
name|SRCH_INTR
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n(Interrupted at article %ld)\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n(Intr at %ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|art
operator|=
name|curr_art
expr_stmt|;
comment|/* restore to current article */
return|return
name|AS_ASK
return|;
case|case
name|SRCH_DONE
case|:
name|fputs
argument_list|(
literal|"done\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
comment|/* 1/3 second */
if|if
condition|(
operator|!
name|srchahead
condition|)
block|{
name|art
operator|=
name|curr_art
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
name|top_article
argument_list|()
expr_stmt|;
name|reread
operator|=
name|FALSE
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
name|SRCH_SUBJDONE
case|:
ifdef|#
directive|ifdef
name|UNDEF
name|fputs
argument_list|(
literal|"\n\n\n\nSubject not found.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
comment|/* 1/3 second */
endif|#
directive|endif
name|top_article
argument_list|()
expr_stmt|;
name|reread
operator|=
name|FALSE
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
name|SRCH_NOTFOUND
case|:
name|fputs
argument_list|(
literal|"\n\n\n\nNot found.\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|art
operator|=
name|curr_art
expr_stmt|;
comment|/* restore to current article */
return|return
name|AS_ASK
return|;
case|case
name|SRCH_FOUND
case|:
if|if
condition|(
name|cmd
operator|==
name|Ctl
argument_list|(
literal|'n'
argument_list|)
operator|||
name|cmd
operator|==
name|Ctl
argument_list|(
literal|'p'
argument_list|)
condition|)
block|{
name|oldsubject
operator|=
name|TRUE
expr_stmt|;
name|reread
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
block|}
return|return
name|AS_NORM
return|;
block|}
else|#
directive|else
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|notincl
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'u'
case|:
comment|/* unsubscribe from this newsgroup? */
name|rcchar
index|[
name|ng
index|]
operator|=
name|NEGCHAR
expr_stmt|;
return|return
name|AS_CLEAN
return|;
case|case
literal|'M'
case|:
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|delay_unmark
argument_list|(
name|artp
argument_list|)
expr_stmt|;
name|oneless
argument_list|(
name|artp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nArticle %ld will return.\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
block|}
return|return
name|AS_ASK
return|;
case|case
literal|'m'
case|:
if|if
condition|(
name|art
operator|>=
name|absfirst
operator|&&
name|art
operator|<=
name|lastart
condition|)
block|{
name|unmark_as_read
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\nArticle %ld marked as still unread.\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
block|}
return|return
name|AS_ASK
return|;
case|case
literal|'c'
case|:
comment|/* catch up */
switch|switch
condition|(
name|ask_catchup
argument_list|()
condition|)
block|{
case|case
literal|'n'
case|:
return|return
name|AS_ASK
return|;
case|case
literal|'u'
case|:
return|return
name|AS_CLEAN
return|;
block|}
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|artp
operator|=
name|Nullart
expr_stmt|;
name|forcelast
operator|=
name|FALSE
expr_stmt|;
return|return
name|AS_NORM
return|;
case|case
literal|'Q'
case|:
name|exit_code
operator|=
name|NG_ASK
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
comment|/* go back up to newsgroup level? */
return|return
name|AS_CLEAN
return|;
case|case
literal|'j'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
if|if
condition|(
name|art
operator|>=
name|absfirst
operator|&&
name|art
operator|<=
name|lastart
condition|)
name|mark_as_read
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'h'
case|:
block|{
comment|/* help? */
name|int
name|cmd
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|=
name|help_art
argument_list|()
operator|)
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'&'
case|:
if|if
condition|(
name|switcheroo
argument_list|()
condition|)
comment|/* get rest of command */
return|return
name|AS_INP
return|;
comment|/* if rubbed out, try something else */
return|return
name|AS_ASK
return|;
case|case
literal|'#'
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nThe last article is %ld.\n"
argument_list|,
argument|(long)lastart
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|lastart
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
return|return
name|AS_ASK
return|;
case|case
literal|'+'
case|:
comment|/* enter selection mode */
name|run_the_selector
label|:
operator|*
name|buf
operator|=
name|do_selector
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'+'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'Q'
case|:
name|exit_code
operator|=
name|NG_ASK
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
break|break;
case|case
literal|'N'
case|:
name|exit_code
operator|=
name|NG_SELNEXT
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|exit_code
operator|=
name|NG_SELPRIOR
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|toread
index|[
name|ng
index|]
condition|)
return|return
name|AS_NORM
return|;
break|break;
block|}
return|return
name|AS_CLEAN
return|;
case|case
literal|'='
case|:
block|{
comment|/* list subjects */
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|ART_NUM
name|oldart
init|=
name|art
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|subjline
init|=
name|getval
argument_list|(
literal|"SUBJLINE"
argument_list|,
name|Nullch
argument_list|)
decl_stmt|;
name|ARTICLE
modifier|*
name|ap
init|=
name|article_ptr
argument_list|(
name|firstart
argument_list|)
decl_stmt|;
name|page_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|firstart
init|;
name|i
operator|<=
name|lastart
operator|&&
operator|!
name|int_count
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|&&
operator|(
name|s
operator|=
name|fetchsubj
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%5ld "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|subjline
condition|)
block|{
name|art
operator|=
name|i
expr_stmt|;
name|interp
argument_list|(
name|tmpbuf
operator|+
literal|6
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
literal|6
argument_list|,
name|subjline
argument_list|)
expr_stmt|;
block|}
else|else
name|safecpy
argument_list|(
name|tmpbuf
operator|+
literal|6
argument_list|,
name|s
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
operator|-
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|=
name|print_lines
argument_list|(
name|tmpbuf
argument_list|,
name|NOMARKING
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|int_count
operator|=
literal|0
expr_stmt|;
name|art
operator|=
name|oldart
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'^'
case|:
name|top_article
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|printf
argument_list|(
literal|"\nFirst article: %ld\n"
argument_list|,
argument|(long)firstart
argument_list|)
name|FLUSH
expr_stmt|;
block|{
name|ARTICLE
modifier|*
name|ap
init|=
name|article_ptr
argument_list|(
name|firstart
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|firstart
init|;
name|i
operator|<=
name|lastart
operator|&&
operator|!
name|int_count
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|subj
condition|)
name|printf
argument_list|(
literal|"%5ld %c %s\n"
argument_list|,
argument|i
argument_list|,
argument|(was_read(i)?
literal|'y'
argument|:
literal|'n'
argument|)
argument_list|,
argument|ap->subj->str
argument_list|)
name|FLUSH
expr_stmt|;
block|}
block|}
name|int_count
operator|=
literal|0
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'v'
case|:
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|reread
operator|=
name|TRUE
expr_stmt|;
name|do_hiding
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|AS_NORM
return|;
ifdef|#
directive|ifdef
name|ROTATION
case|case
name|Ctl
argument_list|(
literal|'x'
argument_list|)
case|:
endif|#
directive|endif
case|case
name|Ctl
argument_list|(
literal|'r'
argument_list|)
case|:
ifdef|#
directive|ifdef
name|ROTATION
name|rotate
operator|=
operator|(
operator|*
name|buf
operator|==
name|Ctl
argument_list|(
literal|'x'
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
name|reread
operator|=
name|TRUE
expr_stmt|;
else|else
name|forcelast
operator|=
name|TRUE
expr_stmt|;
return|return
name|AS_NORM
return|;
ifdef|#
directive|ifdef
name|ROTATION
case|case
literal|'X'
case|:
name|rotate
operator|=
operator|!
name|rotate
expr_stmt|;
comment|/* FALL THROUGH */
else|#
directive|else
case|case
name|Ctl
argument_list|(
literal|'x'
argument_list|)
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|notincl
argument_list|(
literal|"x"
argument_list|)
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'l'
case|:
case|case
name|Ctl
argument_list|(
literal|'l'
argument_list|)
case|:
comment|/* refresh screen */
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|reread
operator|=
name|TRUE
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
name|artline
operator|=
name|topline
expr_stmt|;
if|if
condition|(
name|artline
operator|<
literal|0
condition|)
name|artline
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|AS_NORM
return|;
case|case
name|Ctl
argument_list|(
literal|'f'
argument_list|)
case|:
name|carriage_return
argument_list|()
expr_stmt|;
name|erase_eol
argument_list|()
expr_stmt|;
comment|/* erase the prompt */
ifdef|#
directive|ifdef
name|MAILCALL
name|setmail
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* force a mail check */
endif|#
directive|endif
return|return
name|AS_ASK
return|;
case|case
literal|'b'
case|:
case|case
name|Ctl
argument_list|(
literal|'b'
argument_list|)
case|:
comment|/* back up a page */
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
block|{
name|ART_LINE
name|target
decl_stmt|;
name|reread
operator|=
name|TRUE
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|do_fseek
operator|=
name|TRUE
expr_stmt|;
name|target
operator|=
name|topline
operator|-
operator|(
name|LINES
operator|-
literal|2
operator|)
expr_stmt|;
name|artline
operator|=
name|topline
expr_stmt|;
if|if
condition|(
name|artline
operator|>=
literal|0
condition|)
do|do
block|{
name|artline
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|artline
operator|>=
literal|0
operator|&&
name|artline
operator|>
name|target
operator|&&
name|vrdary
argument_list|(
name|artline
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
do|;
name|topline
operator|=
name|artline
expr_stmt|;
if|if
condition|(
name|artline
operator|<
literal|0
condition|)
name|artline
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|AS_NORM
return|;
case|case
literal|'!'
case|:
comment|/* shell escape */
if|if
condition|(
name|escapade
argument_list|()
condition|)
return|return
name|AS_INP
return|;
return|return
name|AS_ASK
return|;
case|case
literal|'C'
case|:
block|{
name|cancel_article
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'Z'
case|:
case|case
literal|'z'
case|:
block|{
name|supersede_article
argument_list|()
expr_stmt|;
comment|/* supersedes */
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
block|{
comment|/* reply? */
name|reply
argument_list|()
expr_stmt|;
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'F'
case|:
case|case
literal|'f'
case|:
block|{
comment|/* followup command */
name|followup
argument_list|()
expr_stmt|;
name|forcegrow
operator|=
name|TRUE
expr_stmt|;
comment|/* recalculate lastart */
return|return
name|AS_ASK
return|;
block|}
case|case
literal|'|'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
comment|/* save command */
case|case
literal|'e'
case|:
comment|/* extract command */
if|if
condition|(
name|save_article
argument_list|()
operator|==
name|SAVE_ABORT
condition|)
return|return
name|AS_INP
return|;
name|int_count
operator|=
literal|0
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'E'
case|:
if|if
condition|(
name|decode_fp
condition|)
name|decode_end
argument_list|()
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|AS_ASK
return|;
case|case
literal|'Y'
case|:
comment|/* yank back M articles */
name|yankback
argument_list|()
expr_stmt|;
name|top_article
argument_list|()
expr_stmt|;
comment|/* from the beginning */
return|return
name|AS_NORM
return|;
comment|/* pretend nothing happened */
ifdef|#
directive|ifdef
name|STRICTCR
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
argument|badcr
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|AS_ASK
return|;
endif|#
directive|endif
case|case
literal|'_'
case|:
if|if
condition|(
operator|!
name|finish_dblchar
argument_list|()
condition|)
return|return
name|AS_INP
return|;
switch|switch
condition|(
name|buf
index|[
literal|1
index|]
operator|&
literal|0177
condition|)
block|{
case|case
literal|'P'
case|:
name|art
operator|--
expr_stmt|;
goto|goto
name|check_dec_art
goto|;
case|case
literal|'N'
case|:
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
name|art
operator|=
name|absfirst
expr_stmt|;
else|else
name|art
operator|++
expr_stmt|;
if|if
condition|(
name|art
operator|<=
name|lastart
condition|)
name|reread
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|AS_NORM
return|;
case|case
literal|'+'
case|:
if|if
condition|(
name|ThreadedGroup
condition|)
block|{
name|select_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSelected all articles in this thread.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|select_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSelected all articles in this subject.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|AS_ASK
return|;
case|case
literal|'-'
case|:
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
name|deselect_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nDeselected all articles in this thread.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|deselect_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nDeselected all articles in this subject.\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|AS_ASK
return|;
case|case
literal|'a'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
operator|*
name|buf
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|run_the_selector
goto|;
block|}
comment|/* FALL THROUGH */
default|default:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
argument|hforhelp
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|AS_ASK
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAILCALL
end_ifdef

begin_comment
comment|/* see if there is any mail */
end_comment

begin_function
name|void
name|setmail
parameter_list|(
name|force
parameter_list|)
name|bool_int
name|force
decl_stmt|;
block|{
if|if
condition|(
name|force
condition|)
name|mailcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mailcount
operator|++
operator|)
condition|)
block|{
name|char
modifier|*
name|mailfile
init|=
name|filexp
argument_list|(
name|getval
argument_list|(
literal|"MAILFILE"
argument_list|,
name|MAILFILE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|mailfile
argument_list|,
operator|&
name|filestat
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|filestat
operator|.
name|st_size
operator|||
name|filestat
operator|.
name|st_atime
operator|>
name|filestat
operator|.
name|st_mtime
condition|)
name|mailcall
operator|=
name|nullstr
expr_stmt|;
else|else
name|mailcall
operator|=
name|getval
argument_list|(
literal|"MAILCALL"
argument_list|,
literal|"(Mail) "
argument_list|)
expr_stmt|;
block|}
name|mailcount
operator|%=
literal|10
expr_stmt|;
comment|/* check every 10 articles */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|setdfltcmd
parameter_list|()
block|{
if|if
condition|(
operator|!
name|toread
index|[
name|ng
index|]
condition|)
block|{
if|if
condition|(
name|art
operator|>
name|lastart
condition|)
name|dfltcmd
operator|=
literal|"qnp"
expr_stmt|;
else|else
name|dfltcmd
operator|=
literal|"npq"
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ARTSEARCH
if|if
condition|(
name|srchahead
condition|)
name|dfltcmd
operator|=
literal|"^Nnpq"
expr_stmt|;
else|else
endif|#
directive|endif
name|dfltcmd
operator|=
literal|"npq"
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ask the user about catching-up the current group.  Returns 'y' if yes, ** 'n' or 'N' if no ('N' means we used one line when in the selector), ** or 'u' for yes with unsubscribe.  Actually performs the catchup and ** unsubscription as needed. */
end_comment

begin_function
name|char
name|ask_catchup
parameter_list|()
block|{
name|char
name|ch
decl_stmt|;
name|bool
name|use_one_line
init|=
operator|(
name|mode
operator|==
literal|'t'
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|use_one_line
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|reask_catchup
label|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|in_char
argument_list|(
literal|"Do you really want to mark everything as read? [yn] "
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|in_char
argument_list|(
literal|"Really? [ynh] "
argument_list|,
literal|'C'
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setdef
argument_list|(
name|buf
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|buf
operator|)
operator|==
literal|'h'
condition|)
block|{
name|use_one_line
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\ Type y or SP to mark all articles as read.\n\ Type n to leave articles marked as they are.\n\ Type u to mark everything read and unsubscribe.\n\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n\ y or SP to mark all read.\n\ n to forget it.\n\ u to mark all and unsubscribe.\n\n\ "
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_catchup
goto|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'n'
operator|||
name|ch
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
name|use_one_line
condition|)
return|return
literal|'N'
return|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
return|return
literal|'n'
return|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'y'
operator|&&
name|ch
operator|!=
literal|'u'
condition|)
block|{
name|use_one_line
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|hforhelp
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_catchup
goto|;
block|}
if|if
condition|(
name|mode
operator|==
literal|'n'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|catch_up
argument_list|(
name|ng
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|i
operator|=
name|firstart
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|<=
name|lastart
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|ap
operator|->
name|flags
operator|=
operator|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|~
name|sel_mask
operator|)
operator||
name|AF_READ
operator|)
expr_stmt|;
name|selected_count
operator|=
name|selected_subj_cnt
operator|=
name|selected_only
operator|=
literal|0
expr_stmt|;
name|toread
index|[
name|ng
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dmcount
condition|)
name|yankback
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'u'
condition|)
name|rcchar
index|[
name|ng
index|]
operator|=
name|NEGCHAR
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
name|char
name|ask_memorize
parameter_list|(
name|ch
parameter_list|)
name|char_int
name|ch
decl_stmt|;
block|{
name|bool
name|thread_cmd
init|=
operator|(
name|ch
operator|==
literal|'T'
operator|)
decl_stmt|;
name|bool
name|use_one_line
init|=
operator|(
name|mode
operator|==
literal|'t'
operator|)
decl_stmt|;
name|char
modifier|*
name|mode_string
init|=
operator|(
name|thread_cmd
condition|?
literal|"thread"
else|:
literal|"subject"
operator|)
decl_stmt|;
name|char
modifier|*
name|mode_phrase
init|=
operator|(
name|thread_cmd
condition|?
literal|"replies to this article"
else|:
literal|"this subject and all replies"
operator|)
decl_stmt|;
name|ART_NUM
name|art_hold
init|=
name|art
decl_stmt|;
name|ARTICLE
modifier|*
name|artp_hold
init|=
name|artp
decl_stmt|;
if|if
condition|(
operator|!
name|use_one_line
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"Memorize %s command: [+.j,cC]"
argument_list|,
name|mode_string
argument_list|)
expr_stmt|;
name|reask_memorize
label|:
name|in_char
argument_list|(
name|cmd_buf
argument_list|,
literal|'m'
argument_list|)
expr_stmt|;
name|setdef
argument_list|(
name|buf
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ch
operator|=
operator|*
name|buf
operator|)
operator|==
literal|'h'
condition|)
block|{
name|use_one_line
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n\ Type + or SP to auto-select this %s (i.e. includes future articles).\n\ Type . to auto-select %s.\n\ Type j to auto-kill (junk) this %s.\n\ Type , to auto-kill %s.\n\ Type c to clear all selection/killing on this %s.\n\ Type C to clear all selection/killing on %s.\n\ Type q to abort the operation.\n\n\ "
argument_list|,
argument|mode_string
argument_list|,
argument|mode_phrase
argument_list|,
argument|mode_string
argument_list|,
argument|mode_phrase
argument_list|,
argument|mode_string
argument_list|,
argument|mode_phrase
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n\ + or SP auto-selects this %s.\n\ . auto-selects %s.\n\ j auto-kills this %s.\n\ , auto-kills %s.\n\ c clears auto-commands for this %s.\n\ C clears auto-commands for %s.\n\ q aborts.\n\n\ "
argument_list|,
name|mode_string
argument_list|,
name|mode_phrase
argument_list|,
name|mode_string
argument_list|,
name|mode_phrase
argument_list|,
name|mode_string
argument_list|,
name|mode_phrase
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_memorize
goto|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'q'
condition|)
block|{
if|if
condition|(
name|use_one_line
condition|)
return|return
literal|'Q'
return|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|'q'
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|thread_cmd
condition|)
block|{
operator|(
name|void
operator|)
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|art
operator|=
name|art_hold
expr_stmt|;
name|artp
operator|=
name|artp_hold
expr_stmt|;
name|ch
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
name|ch
operator|=
operator|(
name|use_one_line
condition|?
literal|'+'
else|:
literal|'.'
operator|)
expr_stmt|;
if|if
condition|(
name|thread_cmd
condition|)
name|select_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|,
name|AF_AUTOSELECTALL
argument_list|)
expr_stmt|;
else|else
name|select_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|'t'
condition|)
name|printf
argument_list|(
literal|"\nSelection memorized.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|thread_cmd
condition|)
block|{
operator|(
name|void
operator|)
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|art
operator|=
name|art_hold
expr_stmt|;
name|artp
operator|=
name|artp_hold
expr_stmt|;
block|}
else|else
name|ch
operator|=
operator|(
name|use_one_line
condition|?
literal|'+'
else|:
literal|'.'
operator|)
expr_stmt|;
name|select_subthread
argument_list|(
name|artp
argument_list|,
name|thread_cmd
condition|?
name|AF_AUTOSELECT
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|'t'
condition|)
name|printf
argument_list|(
literal|"\nSelection memorized.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'j'
condition|)
block|{
if|if
condition|(
operator|!
name|thread_cmd
condition|)
block|{
operator|*
name|buf
operator|=
literal|'K'
expr_stmt|;
operator|(
name|void
operator|)
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|art
operator|=
name|art_hold
expr_stmt|;
name|artp
operator|=
name|artp_hold
expr_stmt|;
block|}
if|if
condition|(
name|thread_cmd
condition|)
name|kill_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|,
name|KF_ALL
operator||
name|KF_KILLFILE
argument_list|)
expr_stmt|;
else|else
name|kill_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|,
name|KF_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|'t'
condition|)
name|printf
argument_list|(
literal|"\nKill memorized.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|!
name|thread_cmd
condition|)
block|{
operator|(
name|void
operator|)
name|art_search
argument_list|(
name|buf
argument_list|,
operator|(
sizeof|sizeof
name|buf
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|art
operator|=
name|art_hold
expr_stmt|;
name|artp
operator|=
name|artp_hold
expr_stmt|;
block|}
name|kill_subthread
argument_list|(
name|artp
argument_list|,
name|KF_ALL
operator||
operator|(
name|thread_cmd
condition|?
name|KF_KILLFILE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
literal|'t'
condition|)
name|printf
argument_list|(
literal|"\nKill memorized.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|thread_cmd
condition|)
name|clear_thread
argument_list|(
name|artp
operator|->
name|subj
operator|->
name|thread
argument_list|)
expr_stmt|;
else|else
name|clear_subject
argument_list|(
name|artp
operator|->
name|subj
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'C'
condition|)
block|{
name|clear_subthread
argument_list|(
name|artp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|use_one_line
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n"
argument_list|,
argument|hforhelp
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_memorize
goto|;
block|}
if|if
condition|(
operator|!
name|use_one_line
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

end_unit

