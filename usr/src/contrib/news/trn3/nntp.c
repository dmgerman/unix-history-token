begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: nntp.c,v 3.0 1991/11/22 04:12:21 davison Trn $ */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NNTP
end_ifdef

begin_comment
comment|/* try to access the specified group */
end_comment

begin_function
name|bool
name|nntp_group
parameter_list|(
name|group
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"GROUP %s"
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntp_check
argument_list|(
name|FALSE
argument_list|)
operator|!=
name|NNTP_CLASS_OK
condition|)
block|{
name|int
name|ser_int
init|=
name|atoi
argument_list|(
name|ser_line
argument_list|)
decl_stmt|;
if|if
condition|(
name|ser_int
operator|!=
name|NNTP_NOSUCHGROUP_VAL
operator|&&
name|ser_int
operator|!=
name|NNTP_SYNTAX_VAL
condition|)
block|{
if|if
condition|(
name|ser_int
operator|!=
name|NNTP_AUTH_NEEDED_VAL
operator|&&
name|ser_int
operator|!=
name|NNTP_ACCESS_VAL
operator|&&
name|ser_int
operator|!=
name|NNTP_AUTH_REJECT_VAL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nServer's response to GROUP %s:\n%s\n"
argument_list|,
name|group
argument_list|,
name|ser_line
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* check on an article's existence */
end_comment

begin_function
name|bool
name|nntp_stat
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"STAT %ld"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
comment|/* ask the server for the header */
return|return
operator|(
name|nntp_check
argument_list|(
name|TRUE
argument_list|)
operator|==
name|NNTP_CLASS_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* prepare to get the header */
end_comment

begin_function
name|bool
name|nntp_header
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"HEAD %ld"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
comment|/* ask the server for the header */
return|return
operator|(
name|nntp_check
argument_list|(
name|TRUE
argument_list|)
operator|==
name|NNTP_CLASS_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* copy the body of an article to a temporary file */
end_comment

begin_function
name|FILE
modifier|*
name|nntp_body
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
name|char
modifier|*
name|artname
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|parseheader
argument_list|(
name|artnum
argument_list|)
condition|)
return|return
name|Nullfp
return|;
name|artname
operator|=
name|nntp_artname
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|artname
argument_list|,
literal|"w+"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUnable to write temporary file: '%s'.\n"
argument_list|,
name|artname
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"BODY %ld"
argument_list|,
operator|(
name|long
operator|)
name|artnum
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
comment|/* ask the server for the article */
if|if
condition|(
name|nntp_check
argument_list|(
name|TRUE
argument_list|)
operator|!=
name|NNTP_CLASS_OK
condition|)
block|{
comment|/* and get it's reaction */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
comment|/* Simulate file-not-found */
return|return
name|Nullfp
return|;
block|}
name|fwrite
argument_list|(
name|headbuf
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|headbuf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nntp_gets
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|ser_line
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|fputs
argument_list|(
operator|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|?
name|ser_line
operator|+
literal|1
else|:
name|ser_line
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|fp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* This is a 1-relative list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxdays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|time_t
name|nntp_time
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|,
name|hh
decl_stmt|,
name|mm
decl_stmt|,
name|ss
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|tm
modifier|*
name|ts
decl_stmt|;
name|char
name|ch
decl_stmt|;
endif|#
directive|endif
name|nntp_command
argument_list|(
literal|"DATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntp_check
argument_list|(
name|FALSE
argument_list|)
operator|!=
name|NNTP_CLASS_INF
condition|)
return|return
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
return|;
name|s
operator|=
name|ser_line
operator|+
name|strlen
argument_list|(
name|ser_line
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ss
operator|=
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
name|mm
operator|=
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
name|hh
operator|=
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
name|day
operator|=
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
name|month
operator|=
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
operator|--
name|s
operator|-
literal|'0'
operator|)
operator|*
literal|10
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ch
operator|=
operator|*
name|s
expr_stmt|;
endif|#
directive|endif
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|year
operator|=
name|atoi
argument_list|(
name|s
operator|-
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|*
name|s
operator|=
name|ch
expr_stmt|;
endif|#
directive|endif
comment|/* This simple algorithm will be valid until the year 2400 */
if|if
condition|(
name|year
operator|%
literal|4
condition|)
name|maxdays
index|[
literal|2
index|]
operator|=
literal|28
expr_stmt|;
else|else
name|maxdays
index|[
literal|2
index|]
operator|=
literal|29
expr_stmt|;
if|if
condition|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
operator|||
name|day
operator|>
name|maxdays
index|[
name|month
index|]
operator|||
name|hh
operator|<
literal|0
operator|||
name|hh
operator|>
literal|23
operator|||
name|mm
operator|<
literal|0
operator|||
name|mm
operator|>
literal|59
operator|||
name|ss
operator|<
literal|0
operator|||
name|ss
operator|>
literal|59
condition|)
return|return
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
return|;
for|for
control|(
name|month
operator|--
init|;
name|month
condition|;
name|month
operator|--
control|)
name|day
operator|+=
name|maxdays
index|[
name|month
index|]
expr_stmt|;
name|ss
operator|=
operator|(
operator|(
operator|(
operator|(
name|year
operator|-
literal|1970
operator|)
operator|*
literal|365
operator|+
operator|(
name|year
operator|-
literal|1968
operator|)
operator|/
literal|4
operator|+
name|day
operator|-
literal|1
operator|)
operator|*
literal|24L
operator|+
name|hh
operator|)
operator|*
literal|60
operator|+
name|mm
operator|)
operator|*
literal|60
operator|+
name|ss
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ts
operator|=
name|gmtime
argument_list|(
operator|&
name|ss
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
argument|buf
argument_list|,
literal|"19%02d%02d%02d%02d%02d%02d"
argument_list|,
argument|ts->tm_year %
literal|100
argument_list|,
argument|ts->tm_mon+
literal|1
argument_list|,
argument|ts->tm_mday
argument_list|,
argument|ts->tm_hour
argument_list|,
argument|ts->tm_min
argument_list|,
argument|ts->tm_sec
argument_list|)
name|FLUSH
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|ser_line
operator|+
literal|4
argument_list|,
name|buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"\n** Tell Wayne:  %s != %s **\n"
argument_list|,
name|ser_line
operator|+
literal|4
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ss
return|;
block|}
end_function

begin_function
name|bool
name|nntp_newgroups
parameter_list|(
name|t
parameter_list|)
name|time_t
name|t
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|ts
decl_stmt|;
name|ts
operator|=
name|gmtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"NEWGROUPS %02d%02d%02d %02d%02d%02d GMT"
argument_list|,
name|ts
operator|->
name|tm_year
operator|%
literal|100
argument_list|,
name|ts
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ts
operator|->
name|tm_mday
argument_list|,
name|ts
operator|->
name|tm_hour
argument_list|,
name|ts
operator|->
name|tm_min
argument_list|,
name|ts
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|nntp_check
argument_list|(
name|TRUE
argument_list|)
operator|==
name|NNTP_CLASS_OK
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nntp_listgroup
parameter_list|()
block|{
specifier|static
name|bool
name|listgroup_works
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|listgroup_works
condition|)
return|return
name|FALSE
return|;
name|nntp_command
argument_list|(
literal|"LISTGROUP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntp_check
argument_list|(
name|FALSE
argument_list|)
operator|!=
name|NNTP_CLASS_OK
condition|)
block|{
name|listgroup_works
operator|=
name|FALSE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* similar to nntp_gets, but will make the buffer bigger if necessary */
end_comment

begin_function
name|char
modifier|*
name|nntp_get_a_line
parameter_list|(
name|original_buffer
parameter_list|,
name|buffer_length
parameter_list|)
name|char
modifier|*
name|original_buffer
decl_stmt|;
specifier|register
name|int
name|buffer_length
decl_stmt|;
block|{
specifier|register
name|int
name|bufix
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|nextch
decl_stmt|;
specifier|register
name|char
modifier|*
name|some_buffer_or_other
init|=
name|original_buffer
decl_stmt|;
do|do
block|{
if|if
condition|(
name|bufix
operator|>=
name|buffer_length
condition|)
block|{
name|buffer_length
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|some_buffer_or_other
operator|==
name|original_buffer
condition|)
block|{
comment|/* currently static? */
name|some_buffer_or_other
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|buffer_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|some_buffer_or_other
argument_list|,
name|original_buffer
argument_list|,
name|buffer_length
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* so we must copy it */
block|}
else|else
block|{
comment|/* just grow in place, if possible */
name|some_buffer_or_other
operator|=
name|saferealloc
argument_list|(
name|some_buffer_or_other
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|buffer_length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|nextch
operator|=
name|getc
argument_list|(
name|ser_rd_fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return
name|Nullch
return|;
name|some_buffer_or_other
index|[
name|bufix
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|nextch
expr_stmt|;
block|}
do|while
condition|(
name|nextch
operator|&&
name|nextch
operator|!=
literal|'\n'
condition|)
do|;
name|some_buffer_or_other
index|[
name|bufix
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len_last_line_got
operator|=
name|bufix
expr_stmt|;
name|buflen_last_line_got
operator|=
name|buffer_length
expr_stmt|;
return|return
name|some_buffer_or_other
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|nntp_artname
parameter_list|()
block|{
specifier|static
name|char
name|artname
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|artname
argument_list|,
literal|"rrn.%ld"
argument_list|,
name|our_pid
argument_list|)
expr_stmt|;
return|return
name|artname
return|;
block|}
end_function

begin_comment
comment|/* cleanup the odds and ends associated with NNTP usage */
end_comment

begin_function
name|void
name|nntp_cleanup
parameter_list|()
block|{
name|UNLINK
argument_list|(
name|nntp_artname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|active_name
condition|)
name|UNLINK
argument_list|(
name|active_name
argument_list|)
expr_stmt|;
name|nntp_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_XTHREAD
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|rawbytes
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bytes remaining to be transfered */
end_comment

begin_comment
comment|/* nntp_readcheck -- get a line of text from the server, interpreting ** it as a status message for a binary command.  Call this once ** before calling nntp_read() for the actual data transfer. */
end_comment

begin_function
name|long
name|nntp_readcheck
parameter_list|()
block|{
comment|/* try to get the status line and the status code */
if|if
condition|(
name|nntp_check
argument_list|(
name|FALSE
argument_list|)
operator|!=
name|NNTP_CLASS_OK
condition|)
return|return
name|rawbytes
operator|=
operator|-
literal|1
return|;
comment|/* try to get the number of bytes being transfered */
if|if
condition|(
name|sscanf
argument_list|(
name|ser_line
argument_list|,
literal|"%*d%ld"
argument_list|,
operator|&
name|rawbytes
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|rawbytes
operator|=
operator|-
literal|1
return|;
return|return
name|rawbytes
return|;
block|}
end_function

begin_comment
comment|/* nntp_read -- read data from the server in binary format.  This call must ** be preceeded by an appropriate binary command and an nntp_readcheck call. */
end_comment

begin_function
name|long
name|nntp_read
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
comment|/* if no bytes to read, then just return EOF */
if|if
condition|(
name|rawbytes
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAS_SIGHOLD
name|sighold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* try to read some data from the server */
if|if
condition|(
name|rawbytes
condition|)
block|{
name|n
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|n
operator|>
name|rawbytes
condition|?
name|rawbytes
else|:
name|n
argument_list|,
name|ser_rd_fp
argument_list|)
expr_stmt|;
name|rawbytes
operator|-=
name|n
expr_stmt|;
block|}
else|else
name|n
operator|=
literal|0
expr_stmt|;
comment|/* if no more left, then fetch the end-of-command signature */
if|if
condition|(
operator|!
name|rawbytes
condition|)
block|{
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* "\r\n.\r\n" */
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
name|ser_rd_fp
argument_list|)
expr_stmt|;
name|rawbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAS_SIGHOLD
name|sigrelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_XTHREAD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_NNTP */
end_comment

end_unit

