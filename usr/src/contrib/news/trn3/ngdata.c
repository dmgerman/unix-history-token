begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: ngdata.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_comment
comment|/* open the active file */
end_comment

begin_function
name|void
name|ngdata_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USE_NNTP
name|char
modifier|*
name|cp
decl_stmt|;
name|nntp_command
argument_list|(
literal|"LIST"
argument_list|)
expr_stmt|;
comment|/* tell server we want the active file */
if|if
condition|(
name|nntp_check
argument_list|(
name|TRUE
argument_list|)
operator|!=
name|NNTP_CLASS_OK
condition|)
block|{
comment|/* and then see if that's ok */
name|printf
argument_list|(
literal|"Can't get active file from server: \n%s\n"
argument_list|,
name|ser_line
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|time
argument_list|(
operator|&
name|lastactfetch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|filexp
argument_list|(
literal|"%P/rrnact.%$"
argument_list|)
expr_stmt|;
comment|/* make a temporary name */
name|strcpy
argument_list|(
name|active_name
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|actfp
operator|=
name|fopen
argument_list|(
name|active_name
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
comment|/* and get ready */
if|if
condition|(
name|actfp
operator|==
name|Nullfp
condition|)
block|{
name|printf
argument_list|(
argument|cantopen
argument_list|,
argument|active_name
argument_list|)
name|FLUSH
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|activeitems
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|nntp_gets
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
comment|/* while there's another line */
break|break;
comment|/* get it and write it to */
name|activeitems
operator|++
expr_stmt|;
name|fputs
argument_list|(
name|ser_line
argument_list|,
name|actfp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|actfp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|actfp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error writing to active file %s.\n"
argument_list|,
argument|active_name
argument_list|)
name|FLUSH
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !USE_NNTP */
name|ngdatansrv_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fseek
argument_list|(
name|actfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* just get to the beginning */
name|printf
argument_list|(
literal|"Error seeking in active file.\n"
argument_list|)
name|FLUSH
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|bool
name|access_ng
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USE_NNTP
name|long
name|unread
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
if|if
condition|(
operator|!
name|nntp_group
argument_list|(
name|ngname
argument_list|)
condition|)
block|{
name|toread
index|[
name|ng
index|]
operator|=
name|TR_BOGUS
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|lastart
operator|=
name|getngsize
argument_list|(
name|ng
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* this cannot happen (laugh here) */
return|return
name|FALSE
return|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|ser_line
argument_list|,
literal|"%*d%ld%ld%ld"
argument_list|,
operator|&
name|unread
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
comment|/* NNTP mangles the high/low values when no articles are present. */
if|if
condition|(
operator|!
name|unread
condition|)
name|absfirst
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
else|else
block|{
name|absfirst
operator|=
operator|(
name|ART_NUM
operator|)
name|first
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|lastart
condition|)
name|lastart
operator|=
operator|(
name|ART_NUM
operator|)
name|last
expr_stmt|;
block|}
name|ngmax
index|[
name|ng
index|]
operator|=
name|lastart
expr_stmt|;
comment|/* ensure getngsize() knows the new maximum */
name|first
operator|=
name|abs1st
index|[
name|ng
index|]
expr_stmt|;
name|abs1st
index|[
name|ng
index|]
operator|=
name|absfirst
expr_stmt|;
if|if
condition|(
name|absfirst
operator|>
name|first
condition|)
name|checkexpired
argument_list|(
name|ng
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !USE_NNTP */
if|if
condition|(
name|eaccess
argument_list|(
name|ngdir
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* directory read protected? */
if|if
condition|(
name|eaccess
argument_list|(
name|ngdir
argument_list|,
literal|0
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nNewsgroup %s does not have a spool directory!\n"
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\nNo spool for %s!\n"
argument_list|,
name|ngname
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CATCHUP
name|catch_up
argument_list|(
name|ng
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nNewsgroup %s is not currently accessible.\n"
argument_list|,
argument|ngname
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n%s not readable.\n"
argument_list|,
name|ngname
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
block|}
name|toread
index|[
name|ng
index|]
operator|=
name|TR_NONE
expr_stmt|;
comment|/* make this newsgroup temporarily invisible */
return|return
name|FALSE
return|;
block|}
comment|/* chdir to newsgroup subdirectory */
if|if
condition|(
name|chdir
argument_list|(
name|ngdir
argument_list|)
condition|)
block|{
name|printf
argument_list|(
argument|nocd
argument_list|,
argument|ngdir
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|lastart
operator|=
name|getngsize
argument_list|(
name|ng
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* this cannot happen (laugh here) */
return|return
name|FALSE
return|;
name|absfirst
operator|=
name|abs1st
index|[
name|ng
index|]
expr_stmt|;
name|setfoundbits
argument_list|()
expr_stmt|;
comment|/* might reset absfirst */
endif|#
directive|endif
comment|/* !USE_NNTP */
name|dmcount
operator|=
literal|0
expr_stmt|;
name|build_cache
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|grow_ng
parameter_list|(
name|newlast
parameter_list|)
name|ART_NUM
name|newlast
decl_stmt|;
block|{
name|ART_NUM
name|tmpfirst
decl_stmt|;
name|forcegrow
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|newlast
operator|>
name|lastart
condition|)
block|{
name|ART_NUM
name|tmpart
init|=
name|art
decl_stmt|;
name|toread
index|[
name|ng
index|]
operator|+=
call|(
name|ART_UNREAD
call|)
argument_list|(
name|newlast
operator|-
name|lastart
argument_list|)
expr_stmt|;
name|grow_cache
argument_list|(
name|newlast
argument_list|)
expr_stmt|;
name|tmpfirst
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|lastart
operator|=
name|newlast
expr_stmt|;
name|thread_grow
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|KILLFILES
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld more article%s arrived -- processing memorized commands...\n\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lastart
operator|-
name|tmpfirst
operator|+
literal|1
argument_list|)
argument_list|,
operator|(
name|lastart
operator|>
name|tmpfirst
condition|?
literal|"s have"
else|:
literal|" has"
operator|)
argument_list|)
expr_stmt|;
name|ELSE
comment|/* my, my, how clever we are */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"More news -- auto-processing...\n\n"
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|has_normal_kills
condition|)
name|kill_unwanted
argument_list|(
name|tmpfirst
argument_list|,
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|art
operator|=
name|tmpart
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ng_skip
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|USE_NNTP
comment|/* never read it& cannot find it? */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
comment|/* has it not been deleted? */
name|clear
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n(Article %ld exists but is unreadable.)\n"
argument_list|,
argument|(long)art
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n(%ld unreadable.)\n"
argument_list|,
operator|(
name|long
operator|)
name|art
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|novice_delays
condition|)
block|{
name|pad
argument_list|(
name|just_a_sec
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|inc_art
argument_list|(
name|selected_only
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* try next article */
else|#
directive|else
comment|/* USE_NNTP */
name|ART_NUM
name|artnum
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"Skipping unavailable article\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
comment|/* VERBOSE */
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"Skipping\n"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* TERSE */
if|if
condition|(
name|novice_delays
condition|)
block|{
name|pad
argument_list|(
name|just_a_sec
operator|/
literal|3
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|art
operator|++
expr_stmt|;
name|artp
operator|++
expr_stmt|;
do|do
block|{
comment|/* tries to grab PREFETCH_SIZE XHDRS, flagging missing articles */
operator|(
name|void
operator|)
name|fetchsubj
argument_list|(
name|art
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|artnum
operator|=
name|art
operator|+
name|PREFETCH_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|artnum
operator|>
name|lastart
condition|)
name|artnum
operator|=
name|lastart
expr_stmt|;
while|while
condition|(
name|art
operator|<=
name|artnum
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|artp
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
return|return;
name|art
operator|++
expr_stmt|;
name|artp
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|art
operator|<=
name|lastart
condition|)
do|;
endif|#
directive|endif
comment|/* USE_NNTP */
block|}
end_function

begin_comment
comment|/* find the maximum article number of a newsgroup */
end_comment

begin_function
name|ART_NUM
name|getngsize
parameter_list|(
name|num
parameter_list|)
specifier|register
name|NG_NUM
name|num
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|nam
decl_stmt|;
name|char
name|tmpbuf
index|[
name|LBUFLEN
index|]
decl_stmt|;
name|ART_POS
name|oldsoft
decl_stmt|;
name|long
name|last
decl_stmt|,
name|first
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|nam
operator|=
name|rcline
index|[
name|num
index|]
expr_stmt|;
name|len
operator|=
name|rcnums
index|[
name|num
index|]
operator|-
literal|1
expr_stmt|;
name|softtries
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_SOFT_POINTERS
condition|)
name|printf
argument_list|(
literal|"Softptr = %ld\n"
argument_list|,
argument|(long)softptr[num]
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|oldsoft
operator|=
name|softptr
index|[
name|num
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_NNTP
name|fseek
argument_list|(
name|actfp
argument_list|,
literal|100000L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* hopefully this forces a reread */
endif|#
directive|endif
if|if
condition|(
operator|(
name|softptr
index|[
name|num
index|]
operator|=
name|findact
argument_list|(
name|tmpbuf
argument_list|,
name|nam
argument_list|,
name|len
argument_list|,
operator|(
name|long
operator|)
name|oldsoft
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|softptr
index|[
name|num
index|]
operator|!=
name|oldsoft
condition|)
block|{
name|softmisses
operator|++
expr_stmt|;
name|writesoft
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|softptr
index|[
name|num
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|RCCHAR
argument_list|(
name|rcchar
index|[
name|num
index|]
argument_list|)
operator|==
literal|':'
condition|)
name|rcchar
index|[
name|num
index|]
operator|=
name|NEGCHAR
expr_stmt|;
return|return
name|TR_BOGUS
return|;
comment|/* well, not so quietly, actually */
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_SOFT_POINTERS
condition|)
block|{
name|printf
argument_list|(
literal|"Should be %ld\n"
argument_list|,
argument|(long)softptr[num]
argument_list|)
name|FLUSH
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ANCIENT_NEWS
name|sscanf
argument_list|(
name|tmpbuf
operator|+
name|len
operator|+
literal|1
argument_list|,
literal|"%ld %ld %c"
argument_list|,
operator|&
name|last
argument_list|,
operator|&
name|first
argument_list|,
operator|&
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|sscanf
argument_list|(
name|tmpbuf
operator|+
name|len
operator|+
literal|1
argument_list|,
literal|"%ld %c"
argument_list|,
operator|&
name|last
argument_list|,
operator|&
name|ch
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|abs1st
index|[
name|num
index|]
condition|)
name|abs1st
index|[
name|num
index|]
operator|=
operator|(
name|ART_NUM
operator|)
name|first
expr_stmt|;
if|if
condition|(
operator|!
name|in_ng
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|moderated
operator|=
name|getval
argument_list|(
literal|"NOPOSTRING"
argument_list|,
literal|" (no posting)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|moderated
operator|=
name|getval
argument_list|(
literal|"MODSTRING"
argument_list|,
literal|" (moderated)"
argument_list|)
expr_stmt|;
break|break;
comment|/* This shouldn't even occur.  What are we doing in a non-existent 	   group?  Disallow it. */
case|case
literal|'x'
case|:
return|return
name|TR_BOGUS
return|;
comment|/* what should be done about refiled groups?  rn shouldn't even 	   be in them (ie, if sci.aquaria is refiled to rec.aquaria, then 	   get the news there) */
case|case
literal|'='
case|:
return|return
name|TR_BOGUS
return|;
default|default:
name|moderated
operator|=
name|nullstr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last
operator|<
name|ngmax
index|[
name|num
index|]
condition|)
return|return
name|ngmax
index|[
name|num
index|]
return|;
return|return
name|ngmax
index|[
name|num
index|]
operator|=
operator|(
name|ART_NUM
operator|)
name|last
return|;
block|}
end_function

end_unit

