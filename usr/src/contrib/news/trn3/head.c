begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: head.c,v 3.0 1992/02/23 21:25:39 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-process.h"
end_include

begin_include
include|#
directive|include
file|"rt-util.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_decl_stmt
name|bool
name|first_one
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is this the 1st occurance of this header line? */
end_comment

begin_decl_stmt
specifier|static
name|char
name|htypeix
index|[
literal|26
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|head_init
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HEAD_FIRST
operator|+
literal|1
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
name|htypeix
index|[
operator|*
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
operator|-
literal|'a'
index|]
operator|=
name|i
expr_stmt|;
name|headbuf_size
operator|=
name|LBUFLEN
operator|*
literal|8
expr_stmt|;
name|headbuf
operator|=
name|safemalloc
argument_list|(
name|headbuf_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|dumpheader
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"header: %d %s"
argument_list|,
name|parsed_art
argument_list|,
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%15s %4d %4d %03o\n"
argument_list|,
argument|htype[i].ht_name
argument_list|,
argument|htype[i].ht_minpos
argument_list|,
argument|htype[i].ht_maxpos
argument_list|,
argument|htype[i].ht_flags
argument_list|)
name|FLUSH
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|set_line_type
parameter_list|(
name|bufptr
parameter_list|,
name|colon
parameter_list|)
name|char
modifier|*
name|bufptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|colon
decl_stmt|;
block|{
name|char
name|lc
index|[
name|LONGKEY
operator|+
literal|3
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|colon
operator|-
name|bufptr
operator|>
name|LONGKEY
operator|+
literal|2
condition|)
return|return
name|SOME_LINE
return|;
for|for
control|(
name|t
operator|=
name|lc
operator|,
name|f
operator|=
name|bufptr
init|;
name|f
operator|<
name|colon
condition|;
name|f
operator|++
operator|,
name|t
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|f
argument_list|)
condition|)
comment|/* guard against space before : */
break|break;
operator|*
name|t
operator|=
name|isupper
argument_list|(
operator|*
name|f
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|f
argument_list|)
else|:
operator|*
name|f
expr_stmt|;
block|}
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|lc
expr_stmt|;
comment|/* get lc into register */
name|len
operator|=
name|t
operator|-
name|f
expr_stmt|;
comment|/* now scan the headtype table, backwards so we don't have to supply an      * extra terminating value, using first letter as index, and length as      * optimization to avoid calling subroutine strEQ unnecessarily.  Hauls.      */
if|if
condition|(
name|islower
argument_list|(
operator|*
name|f
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|htypeix
index|[
operator|*
name|f
operator|-
literal|'a'
index|]
init|;
operator|*
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
operator|==
operator|*
name|f
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|len
operator|==
name|htype
index|[
name|i
index|]
operator|.
name|ht_length
operator|&&
name|strEQ
argument_list|(
name|f
argument_list|,
name|htype
index|[
name|i
index|]
operator|.
name|ht_name
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
block|}
return|return
name|SOME_LINE
return|;
block|}
end_function

begin_function
name|void
name|start_header
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_HEADER
condition|)
name|dumpheader
argument_list|(
literal|"start_header\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HEAD_LAST
condition|;
name|i
operator|++
control|)
block|{
name|htype
index|[
name|i
index|]
operator|.
name|ht_minpos
operator|=
operator|-
literal|1
expr_stmt|;
name|htype
index|[
name|i
index|]
operator|.
name|ht_maxpos
operator|=
literal|0
expr_stmt|;
block|}
name|in_header
operator|=
name|SOME_LINE
expr_stmt|;
name|first_one
operator|=
name|FALSE
expr_stmt|;
name|parsed_art
operator|=
name|artnum
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_header_line
parameter_list|()
block|{
if|if
condition|(
name|first_one
condition|)
block|{
comment|/* did we just pass 1st occurance? */
name|first_one
operator|=
name|FALSE
expr_stmt|;
comment|/* remember where line left off */
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_maxpos
operator|=
name|artpos
expr_stmt|;
if|if
condition|(
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_flags
operator|&
name|HT_CACHED
condition|)
block|{
name|ARTICLE
modifier|*
name|ap
init|=
name|article_ptr
argument_list|(
name|parsed_art
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|get_cached_line
argument_list|(
name|ap
argument_list|,
name|in_header
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|int
name|start
init|=
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_minpos
operator|+
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_length
operator|+
literal|1
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
while|while
condition|(
name|headbuf
index|[
name|start
index|]
operator|==
literal|' '
operator|||
name|headbuf
index|[
name|start
index|]
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
name|size
operator|=
name|artpos
operator|-
name|start
operator|+
literal|1
operator|-
literal|1
expr_stmt|;
comment|/* pre-strip newline */
if|if
condition|(
name|in_header
operator|==
name|SUBJ_LINE
condition|)
name|set_subj_line
argument_list|(
name|ap
argument_list|,
name|headbuf
operator|+
name|start
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|=
name|safemalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|safecat
argument_list|(
name|s
argument_list|,
name|headbuf
operator|+
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|set_cached_line
argument_list|(
name|ap
argument_list|,
name|in_header
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|bool
name|parseline
parameter_list|(
name|art_buf
parameter_list|,
name|newhide
parameter_list|,
name|oldhide
parameter_list|)
name|char
modifier|*
name|art_buf
decl_stmt|;
name|int
name|newhide
decl_stmt|,
name|oldhide
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|art_buf
operator|==
literal|' '
operator|||
operator|*
name|art_buf
operator|==
literal|'\t'
condition|)
block|{
comment|/* header continuation line? */
return|return
name|oldhide
return|;
block|}
else|else
block|{
comment|/* maybe another header line */
name|char
modifier|*
name|s
decl_stmt|;
name|end_header_line
argument_list|()
expr_stmt|;
name|s
operator|=
name|index
argument_list|(
name|art_buf
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|Nullch
condition|)
comment|/* is it the end of the header? */
name|in_header
operator|=
name|PAST_HEADER
expr_stmt|;
else|else
block|{
comment|/* it is a new header line */
name|in_header
operator|=
name|set_line_type
argument_list|(
name|art_buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|first_one
operator|=
operator|(
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_minpos
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|first_one
condition|)
block|{
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_minpos
operator|=
name|artpos
expr_stmt|;
if|if
condition|(
name|in_header
operator|==
name|DATE_LINE
condition|)
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|article_ptr
argument_list|(
name|parsed_art
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|date
condition|)
name|ap
operator|->
name|date
operator|=
name|parsedate
argument_list|(
name|art_buf
operator|+
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_HEADER
condition|)
name|dumpheader
argument_list|(
name|art_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|htype
index|[
name|in_header
index|]
operator|.
name|ht_flags
operator|&
name|HT_HIDE
condition|)
return|return
name|newhide
return|;
block|}
block|}
return|return
name|FALSE
return|;
comment|/* don't hide this line */
block|}
end_function

begin_function
name|void
name|end_header
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|article_ptr
argument_list|(
name|parsed_art
argument_list|)
decl_stmt|;
name|end_header_line
argument_list|()
expr_stmt|;
name|in_header
operator|=
name|PAST_HEADER
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
operator|!
name|ap
operator|->
name|subj
condition|)
block|{
name|uncache_article
argument_list|(
name|ap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|DBM_XREFS
if|if
condition|(
name|htype
index|[
name|XREF_LINE
index|]
operator|.
name|ht_minpos
operator|<
literal|0
condition|)
name|article_ptr
argument_list|(
name|parsed_art
argument_list|)
operator|->
name|xrefs
operator|=
name|nullstr
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_NNTP
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
operator|=
name|artpos
expr_stmt|;
comment|/* remember where body starts */
else|#
directive|else
name|htype
index|[
name|PAST_HEADER
index|]
operator|.
name|ht_minpos
operator|=
name|ftell
argument_list|(
name|artfp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ThreadedGroup
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_THREADED
operator|)
condition|)
block|{
if|if
condition|(
name|valid_article
argument_list|(
name|ap
argument_list|)
condition|)
block|{
name|ARTICLE
modifier|*
name|artp_hold
init|=
name|artp
decl_stmt|;
name|references
operator|=
name|fetchlines
argument_list|(
name|parsed_art
argument_list|,
name|REFS_LINE
argument_list|)
expr_stmt|;
name|thread_article
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|references
argument_list|)
expr_stmt|;
name|artp
operator|=
name|artp_hold
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_CACHED
operator|)
condition|)
name|cache_article
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|check_poster
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read the header into memory and parse it if we haven't already */
end_comment

begin_function
name|bool
name|parseheader
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
name|parsed_art
operator|==
name|artnum
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|artnum
operator|>
name|lastart
condition|)
return|return
name|FALSE
return|;
name|spin
argument_list|(
literal|20
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_NNTP
if|if
condition|(
operator|!
name|nntp_header
argument_list|(
name|artnum
argument_list|)
condition|)
block|{
name|uncache_article
argument_list|(
name|article_ptr
argument_list|(
name|artnum
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|artopen
argument_list|(
name|artnum
argument_list|)
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
name|start_header
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
name|artpos
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|headbuf
expr_stmt|;
while|while
condition|(
name|in_header
condition|)
block|{
if|if
condition|(
name|headbuf_size
operator|<
name|artpos
operator|+
name|LBUFLEN
condition|)
block|{
name|headbuf_size
operator|+=
name|LBUFLEN
operator|*
literal|4
expr_stmt|;
name|headbuf
operator|=
name|saferealloc
argument_list|(
name|headbuf
argument_list|,
name|headbuf_size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_NNTP
name|nntp_gets
argument_list|(
name|bp
argument_list|,
name|LBUFLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|bp
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* tag the end with an empty line */
name|artpos
operator|++
expr_stmt|;
break|break;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|fgets
argument_list|(
name|bp
argument_list|,
name|LBUFLEN
argument_list|,
name|artfp
argument_list|)
operator|==
name|Nullch
condition|)
break|break;
name|len
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parseline
argument_list|(
name|bp
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|artpos
operator|+=
name|len
expr_stmt|;
name|bp
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
comment|/* this probably isn't needed */
name|end_header
argument_list|()
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* get a header line from an article */
end_comment

begin_function
name|char
modifier|*
name|fetchlines
parameter_list|(
name|artnum
parameter_list|,
name|which_line
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
comment|/* article to get line from */
name|int
name|which_line
decl_stmt|;
comment|/* type of line desired */
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|ART_POS
name|firstpos
decl_stmt|;
specifier|register
name|ART_POS
name|lastpos
decl_stmt|;
name|int
name|size
decl_stmt|;
name|s
operator|=
name|fetchcache
argument_list|(
name|artnum
argument_list|,
name|which_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|savestr
argument_list|(
name|s
argument_list|)
return|;
if|if
condition|(
operator|(
name|firstpos
operator|=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_minpos
operator|)
operator|<
literal|0
condition|)
return|return
name|savestr
argument_list|(
name|nullstr
argument_list|)
return|;
name|firstpos
operator|+=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_length
operator|+
literal|1
expr_stmt|;
name|lastpos
operator|=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_maxpos
expr_stmt|;
name|size
operator|=
name|lastpos
operator|-
name|firstpos
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|size
operator|<
literal|1
operator|||
name|size
operator|>
literal|1000
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Firstpos = %ld, lastpos = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|firstpos
argument_list|,
operator|(
name|long
operator|)
name|lastpos
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|cmd_buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|s
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|size
argument_list|)
expr_stmt|;
name|t
operator|=
name|headbuf
operator|+
name|firstpos
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
condition|)
name|t
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|safecat
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* prefetch a header line from one or more articles */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NNTP
end_ifdef

begin_function
name|char
modifier|*
name|prefetchlines
parameter_list|(
name|artnum
parameter_list|,
name|which_line
parameter_list|,
name|copy
parameter_list|)
comment|/* NNTP version */
name|ART_NUM
name|artnum
decl_stmt|;
comment|/* article to get line from */
name|int
name|which_line
decl_stmt|;
comment|/* type of line desired */
name|bool_int
name|copy
decl_stmt|;
comment|/* do you want it savestr()ed? */
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|size
decl_stmt|;
specifier|register
name|ART_NUM
name|num
decl_stmt|,
name|priornum
decl_stmt|,
name|lastnum
decl_stmt|;
name|bool
name|cached
init|=
operator|(
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_flags
operator|&
name|HT_CACHED
operator|)
decl_stmt|;
comment|/* find_article() returns a Nullart if the artnum value is invalid */
if|if
condition|(
operator|!
operator|(
name|ap
operator|=
name|find_article
argument_list|(
name|artnum
argument_list|)
operator|)
operator|||
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
name|s
operator|=
name|nullstr
expr_stmt|;
elseif|else
if|if
condition|(
name|cached
condition|)
name|s
operator|=
name|get_cached_line
argument_list|(
name|ap
argument_list|,
name|which_line
argument_list|,
name|untrim_cache
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|copy
condition|)
name|s
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
name|spin
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
name|s
operator|=
name|safemalloc
argument_list|(
call|(
name|MEM_SIZE
call|)
argument_list|(
name|size
operator|=
name|LBUFLEN
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|s
operator|=
name|cmd_buf
expr_stmt|;
name|size
operator|=
sizeof|sizeof
name|cmd_buf
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|priornum
operator|=
name|artnum
operator|-
literal|1
expr_stmt|;
name|lastnum
operator|=
name|artnum
operator|+
name|PREFETCH_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lastnum
operator|>
name|lastart
condition|)
name|lastnum
operator|=
name|lastart
expr_stmt|;
if|if
condition|(
name|cached
condition|)
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"XHDR %s %ld-%ld"
argument_list|,
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_name
argument_list|,
name|artnum
argument_list|,
name|lastnum
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"XHDR %s %ld"
argument_list|,
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_name
argument_list|,
name|artnum
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntp_check
argument_list|(
name|TRUE
argument_list|)
operator|==
name|NNTP_CLASS_OK
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|nntp_gets
argument_list|(
name|ser_line
argument_list|,
sizeof|sizeof
name|ser_line
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DEB_NNTP
condition|)
name|printf
argument_list|(
literal|"<%s\n"
argument_list|,
argument|ser_line
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ser_line
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
break|break;
if|if
condition|(
operator|(
name|t
operator|=
name|index
argument_list|(
name|ser_line
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|index
argument_list|(
name|ser_line
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
continue|continue;
name|t
operator|++
expr_stmt|;
name|num
operator|=
name|atol
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
name|artnum
operator|||
name|num
operator|>
name|lastnum
condition|)
continue|continue;
while|while
condition|(
operator|++
name|priornum
operator|<
name|num
condition|)
name|uncache_article
argument_list|(
name|ap
operator|++
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_line
operator|==
name|SUBJ_LINE
condition|)
name|set_subj_line
argument_list|(
name|ap
operator|++
argument_list|,
name|t
argument_list|,
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cached
condition|)
name|set_cached_line
argument_list|(
name|ap
operator|++
argument_list|,
name|which_line
argument_list|,
name|savestr
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|==
name|artnum
condition|)
name|safecat
argument_list|(
name|s
argument_list|,
name|t
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUnexpected close of server socket.\n"
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|priornum
operator|++
operator|<
name|lastnum
condition|)
name|uncache_article
argument_list|(
name|ap
operator|++
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
condition|)
name|s
operator|=
name|saferealloc
argument_list|(
name|s
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USE_NNTP */
end_comment

begin_function
name|char
modifier|*
name|prefetchlines
parameter_list|(
name|artnum
parameter_list|,
name|which_line
parameter_list|,
name|copy
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
comment|/* article to get line from */
name|int
name|which_line
decl_stmt|;
comment|/* type of line desired */
name|bool_int
name|copy
decl_stmt|;
comment|/* do you want it savestr()ed? */
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|ART_POS
name|firstpos
decl_stmt|;
specifier|register
name|ART_POS
name|lastpos
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|copy
condition|)
return|return
name|fetchlines
argument_list|(
name|artnum
argument_list|,
name|which_line
argument_list|)
return|;
name|s
operator|=
name|fetchcache
argument_list|(
name|artnum
argument_list|,
name|which_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|(
name|firstpos
operator|=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_minpos
operator|)
operator|<
literal|0
condition|)
return|return
name|nullstr
return|;
name|firstpos
operator|+=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_length
operator|+
literal|1
expr_stmt|;
name|lastpos
operator|=
name|htype
index|[
name|which_line
index|]
operator|.
name|ht_maxpos
expr_stmt|;
name|size
operator|=
name|lastpos
operator|-
name|firstpos
expr_stmt|;
name|t
operator|=
name|headbuf
operator|+
name|firstpos
expr_stmt|;
while|while
condition|(
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
condition|)
name|t
operator|++
expr_stmt|;
operator|*
name|cmd_buf
operator|=
literal|'\0'
expr_stmt|;
name|safecat
argument_list|(
name|cmd_buf
argument_list|,
name|t
argument_list|,
name|CBUFLEN
argument_list|)
expr_stmt|;
comment|/* hope this is okay--we're */
return|return
name|cmd_buf
return|;
comment|/* really scraping for space here */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_NNTP */
end_comment

end_unit

