begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: rt-process.c,v 3.0 1992/12/14 00:14:13 davison Trn $ */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_decl_stmt
specifier|extern
name|HASHTABLE
modifier|*
name|msgid_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|valid_message_id
name|_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_threads
name|_
argument_list|(
operator|(
name|SUBJECT
operator|*
operator|,
name|SUBJECT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|link_child
name|_
argument_list|(
operator|(
name|ARTICLE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unlink_child
name|_
argument_list|(
operator|(
name|ARTICLE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This depends on art being set to the current article number. */
end_comment

begin_function
name|ARTICLE
modifier|*
name|allocate_article
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|article
decl_stmt|;
comment|/* create an new article */
if|if
condition|(
name|artnum
operator|>=
name|absfirst
condition|)
block|{
if|if
condition|(
name|artnum
operator|>
name|lastart
condition|)
name|grow_cache
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
name|article
operator|=
name|article_ptr
argument_list|(
name|artnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|article
operator|=
operator|(
name|ARTICLE
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ARTICLE
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|article
argument_list|,
sizeof|sizeof
argument_list|(
name|ARTICLE
argument_list|)
argument_list|)
expr_stmt|;
name|article
operator|->
name|flags
operator||=
name|AF_READ
operator||
name|AF_MISSING
operator||
name|AF_FAKE
operator||
name|AF_TMPMEM
expr_stmt|;
block|}
return|return
name|article
return|;
block|}
end_function

begin_function
name|void
name|fix_msgid
parameter_list|(
name|msgid
parameter_list|)
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|msgid
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|cp
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
comment|/* lower-case domain portion */
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|msgid_cmp
parameter_list|(
name|key
parameter_list|,
name|keylen
parameter_list|,
name|data
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|HASHDATUM
name|data
decl_stmt|;
block|{
name|ARTICLE
modifier|*
name|article
init|=
operator|(
name|data
operator|.
name|dat_ptr
condition|?
operator|(
name|ARTICLE
operator|*
operator|)
name|data
operator|.
name|dat_ptr
else|:
name|article_ptr
argument_list|(
name|data
operator|.
name|dat_len
argument_list|)
operator|)
decl_stmt|;
comment|/* We already know that the lengths are equal, just compare the strings */
return|return
name|bcmp
argument_list|(
name|key
argument_list|,
name|article
operator|->
name|msgid
argument_list|,
name|keylen
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|SUBJECT
modifier|*
name|fake_had_subj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the fake-turned-real article had this subject */
end_comment

begin_function
name|bool
name|valid_article
parameter_list|(
name|article
parameter_list|)
name|ARTICLE
modifier|*
name|article
decl_stmt|;
block|{
name|ARTICLE
modifier|*
name|ap
decl_stmt|,
modifier|*
name|fake_ap
decl_stmt|;
name|char
modifier|*
name|msgid
init|=
name|article
operator|->
name|msgid
decl_stmt|;
name|HASHDATUM
name|data
decl_stmt|;
if|if
condition|(
name|msgid
condition|)
block|{
name|fix_msgid
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|data
operator|=
name|hashfetch
argument_list|(
name|msgid_hash
argument_list|,
name|msgid
argument_list|,
name|strlen
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fake_ap
operator|=
operator|(
name|ARTICLE
operator|*
operator|)
name|data
operator|.
name|dat_ptr
operator|)
operator|==
name|Nullart
condition|)
block|{
if|if
condition|(
operator|!
name|data
operator|.
name|dat_len
condition|)
block|{
name|data
operator|.
name|dat_len
operator|=
name|article_num
argument_list|(
name|article
argument_list|)
expr_stmt|;
name|hashstorelast
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|fake_had_subj
operator|=
name|Nullsubj
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|data
operator|.
name|dat_len
operator|==
name|article_num
argument_list|(
name|article
argument_list|)
condition|)
block|{
name|fake_had_subj
operator|=
name|Nullsubj
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Whenever we replace a fake art with a real one, it's a lot of work 	** cleaning up the references.  Fortunately, this is not often. */
if|if
condition|(
name|fake_ap
condition|)
block|{
name|article
operator|->
name|parent
operator|=
name|fake_ap
operator|->
name|parent
expr_stmt|;
name|article
operator|->
name|child1
operator|=
name|fake_ap
operator|->
name|child1
expr_stmt|;
name|article
operator|->
name|sibling
operator|=
name|fake_ap
operator|->
name|sibling
expr_stmt|;
name|fake_had_subj
operator|=
name|fake_ap
operator|->
name|subj
expr_stmt|;
if|if
condition|(
name|fake_ap
operator|->
name|flags
operator|&
name|AF_AUTOFLAGS
condition|)
block|{
name|article
operator|->
name|flags
operator||=
name|fake_ap
operator|->
name|flags
operator|&
name|AF_AUTOFLAGS
expr_stmt|;
name|save_ids
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|curr_artp
operator|==
name|fake_ap
condition|)
block|{
name|curr_artp
operator|=
name|article
expr_stmt|;
name|curr_art
operator|=
name|article_num
argument_list|(
name|article
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recent_artp
operator|==
name|fake_ap
condition|)
block|{
name|recent_artp
operator|=
name|article
expr_stmt|;
name|recent_art
operator|=
name|article_num
argument_list|(
name|article
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ap
operator|=
name|article
operator|->
name|parent
operator|)
operator|!=
name|Nullart
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|child1
operator|==
name|fake_ap
condition|)
name|ap
operator|->
name|child1
operator|=
name|article
expr_stmt|;
else|else
block|{
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
goto|goto
name|sibling_search
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|fake_had_subj
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
init|=
name|fake_had_subj
decl_stmt|;
if|if
condition|(
operator|(
name|ap
operator|=
name|sp
operator|->
name|thread
operator|)
operator|==
name|fake_ap
condition|)
block|{
do|do
block|{
name|sp
operator|->
name|thread
operator|=
name|article
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|fake_had_subj
condition|)
do|;
block|}
else|else
block|{
name|sibling_search
label|:
while|while
condition|(
name|ap
operator|->
name|sibling
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|sibling
operator|==
name|fake_ap
condition|)
block|{
name|ap
operator|->
name|sibling
operator|=
name|article
expr_stmt|;
break|break;
block|}
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|1
for|for
control|(
name|ap
operator|=
name|fake_had_subj
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
name|assert
argument_list|(
name|ap
operator|!=
name|fake_ap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
for|for
control|(
name|ap
operator|=
name|article
operator|->
name|child1
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|sibling
control|)
name|ap
operator|->
name|parent
operator|=
name|article
expr_stmt|;
name|clear_article
argument_list|(
name|fake_ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fake_ap
argument_list|)
expr_stmt|;
name|data
operator|.
name|dat_ptr
operator|=
name|Nullch
expr_stmt|;
name|data
operator|.
name|dat_len
operator|=
name|article_num
argument_list|(
name|article
argument_list|)
expr_stmt|;
name|hashstorelast
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Forget about the duplicate message-id or bogus article. */
name|uncache_article
argument_list|(
name|article
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Take a message-id and see if we already know about it.  If so, return ** the article, otherwise create a fake one. */
end_comment

begin_function
name|ARTICLE
modifier|*
name|get_article
parameter_list|(
name|msgid
parameter_list|)
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|article
decl_stmt|;
name|HASHDATUM
name|data
decl_stmt|;
name|fix_msgid
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|data
operator|=
name|hashfetch
argument_list|(
name|msgid_hash
argument_list|,
name|msgid
argument_list|,
name|strlen
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|article
operator|=
operator|(
name|ARTICLE
operator|*
operator|)
name|data
operator|.
name|dat_ptr
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|.
name|dat_len
condition|)
name|article
operator|=
name|article_ptr
argument_list|(
name|data
operator|.
name|dat_len
argument_list|)
expr_stmt|;
else|else
block|{
name|article
operator|=
name|allocate_article
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|data
operator|.
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|article
expr_stmt|;
name|article
operator|->
name|msgid
operator|=
name|savestr
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
name|hashstorelast
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|article
return|;
block|}
end_function

begin_comment
comment|/* Take all the data we've accumulated about the article and shove it into ** the article tree at the best place we can deduce. */
end_comment

begin_function
name|void
name|thread_article
parameter_list|(
name|article
parameter_list|)
name|ARTICLE
modifier|*
name|article
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ARTICLE
modifier|*
name|kill_ap
init|=
operator|(
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_AUTOKILL
operator|)
condition|?
name|article
else|:
name|Nullart
operator|)
decl_stmt|;
name|int
name|select_this_art
init|=
operator|(
name|article
operator|->
name|subj
operator|->
name|flags
operator|&
name|SF_AUTOSELECT
operator|)
operator|||
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_AUTOSELECTALL
operator|)
condition|?
name|AF_AUTOSELECTALL
else|:
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_AUTOSELECT
operator|)
decl_stmt|;
comment|/* We're definitely not a fake anymore */
name|article
operator|->
name|flags
operator|=
operator|(
name|article
operator|->
name|flags
operator|&
operator|~
name|AF_FAKE
operator|)
operator||
name|AF_THREADED
expr_stmt|;
comment|/* If the article was already part of an existing thread, unlink it     ** to try to put it in the best possible spot.     */
if|if
condition|(
name|fake_had_subj
condition|)
block|{
if|if
condition|(
name|fake_had_subj
operator|->
name|thread
operator|!=
name|article
operator|->
name|subj
operator|->
name|thread
condition|)
block|{
name|fake_had_subj
operator|->
name|flags
operator|&=
operator|~
name|SF_THREAD
expr_stmt|;
name|merge_threads
argument_list|(
name|fake_had_subj
argument_list|,
name|article
operator|->
name|subj
argument_list|)
expr_stmt|;
block|}
comment|/* Check for a real or shared-fake parent */
name|ap
operator|=
name|article
operator|->
name|parent
expr_stmt|;
while|while
condition|(
name|ap
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_FAKE
operator|)
operator|==
name|AF_FAKE
operator|&&
operator|!
name|ap
operator|->
name|child1
operator|->
name|sibling
condition|)
name|ap
operator|=
name|ap
operator|->
name|parent
expr_stmt|;
name|unlink_child
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
condition|)
block|{
comment|/* do we have decent parents? */
comment|/* Yes: assume that our references are ok, and just reorder us 	    ** with our siblings by date. 	    */
name|link_child
argument_list|(
name|article
argument_list|)
expr_stmt|;
comment|/* Freshen the date& subject in any faked parent articles. */
for|for
control|(
name|ap
operator|=
name|article
operator|->
name|parent
init|;
name|ap
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_FAKE
operator|)
operator|==
name|AF_FAKE
operator|&&
name|article
operator|->
name|date
operator|<
name|ap
operator|->
name|date
condition|;
name|ap
operator|=
name|ap
operator|->
name|parent
control|)
block|{
name|ap
operator|->
name|date
operator|=
name|article
operator|->
name|date
expr_stmt|;
name|ap
operator|->
name|subj
operator|=
name|article
operator|->
name|subj
expr_stmt|;
name|unlink_child
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|link_child
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit
goto|;
block|}
comment|/* We'll assume that this article has as good or better references 	** than the child that faked us initially.  Free the fake reference- 	** chain and process our references as usual. 	*/
for|for
control|(
name|ap
operator|=
name|article
operator|->
name|parent
init|;
name|ap
condition|;
name|ap
operator|=
name|last
control|)
block|{
name|unlink_child
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|last
operator|=
name|ap
operator|->
name|parent
expr_stmt|;
name|ap
operator|->
name|date
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|subj
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|parent
operator|=
literal|0
expr_stmt|;
comment|/* don't free it until group exit since we probably re-use it */
block|}
name|article
operator|->
name|parent
operator|=
name|Nullart
expr_stmt|;
comment|/* neaten up */
name|article
operator|->
name|sibling
operator|=
name|Nullart
expr_stmt|;
block|}
comment|/* If we have references, process them from the right end one at a time     ** until we either run into somebody, or we run out of references.     */
if|if
condition|(
operator|*
name|references
condition|)
block|{
name|last
operator|=
name|article
expr_stmt|;
name|ap
operator|=
name|Nullart
expr_stmt|;
name|end
operator|=
name|references
operator|+
name|strlen
argument_list|(
name|references
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|references
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
name|Nullch
condition|)
block|{
while|while
condition|(
name|end
operator|>=
name|cp
operator|&&
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
operator|<=
literal|' '
operator|||
operator|*
name|end
operator|==
literal|','
operator|)
condition|)
block|{
name|end
operator|--
expr_stmt|;
block|}
name|end
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Quit parsing references if this one is garbage. */
if|if
condition|(
operator|!
operator|(
name|end
operator|=
name|valid_message_id
argument_list|(
name|cp
argument_list|,
name|end
argument_list|)
operator|)
condition|)
break|break;
comment|/* Dump all domains that end in '.', such as "..."& "1@DEL." */
if|if
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
break|break;
name|ap
operator|=
name|get_article
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|select_this_art
operator||=
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_AUTOSELECT
operator||
name|AF_AUTOSELECTALL
operator|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_AUTOKILL
condition|)
name|kill_ap
operator|=
name|ap
expr_stmt|;
comment|/* Check for duplicates on the reference line.  Brand-new data has 	    ** no date.  Data we just allocated earlier on this line has a 	    ** date but no subj.  Special-case the article itself, since it 	    ** does have a subj. 	    */
if|if
condition|(
operator|(
name|ap
operator|->
name|date
operator|&&
operator|!
name|ap
operator|->
name|subj
operator|)
operator|||
name|ap
operator|==
name|article
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|last
operator|)
operator|==
name|article
condition|)
name|ap
operator|=
name|Nullart
expr_stmt|;
continue|continue;
block|}
name|last
operator|->
name|parent
operator|=
name|ap
expr_stmt|;
name|link_child
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|subj
condition|)
break|break;
name|ap
operator|->
name|date
operator|=
name|article
operator|->
name|date
expr_stmt|;
name|last
operator|=
name|ap
expr_stmt|;
name|end
operator|=
name|cp
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ap
condition|)
goto|goto
name|no_references
goto|;
comment|/* Check if we ran into anybody that was already linked.  If so, we 	** just use their thread. 	*/
if|if
condition|(
name|ap
operator|->
name|subj
condition|)
block|{
comment|/* See if this article spans the gap between what we thought 	    ** were two different threads. 	    */
if|if
condition|(
name|article
operator|->
name|subj
operator|->
name|thread
operator|!=
name|ap
operator|->
name|subj
operator|->
name|thread
condition|)
name|merge_threads
argument_list|(
name|ap
operator|->
name|subj
argument_list|,
name|article
operator|->
name|subj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We didn't find anybody we knew, so either create a new thread 	    ** or use the article's thread if it was previously faked. 	    */
name|ap
operator|->
name|subj
operator|=
name|article
operator|->
name|subj
expr_stmt|;
name|link_child
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
comment|/* Set the subj of faked articles we created as references. */
for|for
control|(
name|ap
operator|=
name|article
operator|->
name|parent
init|;
name|ap
operator|&&
operator|!
name|ap
operator|->
name|subj
condition|;
name|ap
operator|=
name|ap
operator|->
name|parent
control|)
name|ap
operator|->
name|subj
operator|=
name|article
operator|->
name|subj
expr_stmt|;
comment|/* Make sure we didn't circularly link to a child article(!), by 	** ensuring that we run off the top before we run into ourself. 	*/
while|while
condition|(
name|ap
operator|&&
name|ap
operator|->
name|parent
operator|!=
name|article
condition|)
name|ap
operator|=
name|ap
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|ap
condition|)
block|{
comment|/* Ugh.  Someone's tweaked reference line with an incorrect 	    ** article-order arrived first, and one of our children is 	    ** really one of our ancestors. Cut off the bogus child branch 	    ** right where we are and link it to the thread. 	    */
name|unlink_child
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|parent
operator|=
name|Nullart
expr_stmt|;
name|link_child
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|no_references
label|:
comment|/* The article has no references.  Either turn it into a new thread 	** or re-attach the fleshed-out article to its old thread. 	*/
name|link_child
argument_list|(
name|article
argument_list|)
expr_stmt|;
block|}
name|exit
label|:
if|if
condition|(
operator|!
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_CACHED
operator|)
condition|)
name|cache_article
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|if
condition|(
name|select_this_art
operator|&
name|AF_AUTOSELECTALL
condition|)
block|{
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
name|select_thread
argument_list|(
name|article
operator|->
name|subj
operator|->
name|thread
argument_list|,
name|AF_AUTOSELECTALL
argument_list|)
expr_stmt|;
else|else
name|select_subject
argument_list|(
name|article
operator|->
name|subj
argument_list|,
name|AF_AUTOSELECTALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|select_this_art
condition|)
name|select_subthread
argument_list|(
name|article
argument_list|,
name|AF_AUTOSELECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill_ap
condition|)
name|kill_subthread
argument_list|(
name|kill_ap
argument_list|,
name|KF_ALL
operator||
name|KF_KILLFILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if the string we've found looks like a valid message-id reference. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|valid_message_id
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
specifier|register
name|char
modifier|*
name|start
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|mid
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'>'
condition|)
block|{
comment|/* Compensate for space cadets who include the header in their 	** subsitution of all '>'s into another citation character. 	*/
if|if
condition|(
operator|*
name|end
operator|==
literal|'<'
operator|||
operator|*
name|end
operator|==
literal|'-'
operator|||
operator|*
name|end
operator|==
literal|'!'
operator|||
operator|*
name|end
operator|==
literal|'%'
operator|||
operator|*
name|end
operator|==
literal|')'
operator|||
operator|*
name|end
operator|==
literal|'|'
operator|||
operator|*
name|end
operator|==
literal|':'
operator|||
operator|*
name|end
operator|==
literal|'}'
operator|||
operator|*
name|end
operator|==
literal|'*'
operator|||
operator|*
name|end
operator|==
literal|'+'
operator|||
operator|*
name|end
operator|==
literal|'#'
operator|||
operator|*
name|end
operator|==
literal|']'
operator|||
operator|*
name|end
operator|==
literal|'@'
operator|||
operator|*
name|end
operator|==
literal|'$'
condition|)
block|{
operator|*
name|end
operator|=
literal|'>'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
block|{
operator|*
operator|(
name|end
operator|--
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Id must be "<...@...>" */
if|if
condition|(
operator|*
name|start
operator|!=
literal|'<'
operator|||
operator|*
name|end
operator|!=
literal|'>'
operator|||
operator|(
name|mid
operator|=
name|index
argument_list|(
name|start
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
name|Nullch
operator|||
name|mid
operator|==
name|start
operator|+
literal|1
operator|||
name|mid
operator|+
literal|1
operator|==
name|end
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|end
return|;
block|}
end_block

begin_comment
comment|/* Remove an article from its parent/siblings.  Leave parent pointer intact. */
end_comment

begin_function
specifier|static
name|void
name|unlink_child
parameter_list|(
name|child
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|child
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|last
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|last
operator|=
name|child
operator|->
name|parent
operator|)
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
init|=
name|child
operator|->
name|subj
decl_stmt|;
if|if
condition|(
operator|(
name|last
operator|=
name|sp
operator|->
name|thread
operator|)
operator|==
name|child
condition|)
block|{
do|do
block|{
name|sp
operator|->
name|thread
operator|=
name|child
operator|->
name|sibling
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|child
operator|->
name|subj
condition|)
do|;
block|}
else|else
goto|goto
name|sibling_search
goto|;
block|}
else|else
block|{
if|if
condition|(
name|last
operator|->
name|child1
operator|==
name|child
condition|)
name|last
operator|->
name|child1
operator|=
name|child
operator|->
name|sibling
expr_stmt|;
else|else
block|{
name|last
operator|=
name|last
operator|->
name|child1
expr_stmt|;
name|sibling_search
label|:
while|while
condition|(
name|last
operator|->
name|sibling
operator|!=
name|child
condition|)
name|last
operator|=
name|last
operator|->
name|sibling
expr_stmt|;
name|last
operator|->
name|sibling
operator|=
name|child
operator|->
name|sibling
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Link an article to its parent article.  If its parent pointer is zero, ** link it to its thread.  Sorts siblings by date. */
end_comment

begin_function
specifier|static
name|void
name|link_child
parameter_list|(
name|child
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|child
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ap
operator|=
name|child
operator|->
name|parent
operator|)
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
init|=
name|child
operator|->
name|subj
decl_stmt|;
name|ap
operator|=
name|sp
operator|->
name|thread
expr_stmt|;
if|if
condition|(
operator|!
name|ap
operator|||
name|child
operator|->
name|date
operator|<
name|ap
operator|->
name|date
condition|)
block|{
do|do
block|{
name|sp
operator|->
name|thread
operator|=
name|child
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|child
operator|->
name|subj
condition|)
do|;
name|child
operator|->
name|sibling
operator|=
name|ap
expr_stmt|;
block|}
else|else
goto|goto
name|sibling_search
goto|;
block|}
else|else
block|{
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
if|if
condition|(
operator|!
name|ap
operator|||
name|child
operator|->
name|date
operator|<
name|ap
operator|->
name|date
condition|)
block|{
name|child
operator|->
name|sibling
operator|=
name|ap
expr_stmt|;
name|child
operator|->
name|parent
operator|->
name|child1
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
name|sibling_search
label|:
while|while
condition|(
name|ap
operator|->
name|sibling
operator|&&
name|ap
operator|->
name|sibling
operator|->
name|date
operator|<=
name|child
operator|->
name|date
condition|)
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
name|child
operator|->
name|sibling
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
name|ap
operator|->
name|sibling
operator|=
name|child
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge all of s2's thread into s1's thread. */
end_comment

begin_function
specifier|static
name|void
name|merge_threads
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|SUBJECT
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|int
name|visit_flag
decl_stmt|;
name|t1
operator|=
name|s1
operator|->
name|thread
expr_stmt|;
name|t2
operator|=
name|s2
operator|->
name|thread
expr_stmt|;
name|t1
operator|->
name|subj
operator|->
name|flags
operator|&=
operator|~
name|SF_THREAD
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
name|visit_flag
operator|=
operator|(
name|t1
operator|->
name|subj
operator|->
name|flags
operator||
operator|(
name|t2
condition|?
name|t2
operator|->
name|subj
operator|->
name|flags
else|:
literal|0
operator|)
operator|)
operator|&
name|SF_VISIT
expr_stmt|;
else|else
name|visit_flag
operator|=
literal|0
expr_stmt|;
comment|/* Change all of t2's thread pointers to a common lead article */
name|sp
operator|=
name|s2
expr_stmt|;
do|do
block|{
name|sp
operator|->
name|thread
operator|=
name|t1
expr_stmt|;
name|sp
operator|->
name|flags
operator|&=
operator|~
name|SF_THREAD
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|s2
condition|)
do|;
comment|/* Join the two circular lists together */
name|sp
operator|=
name|s2
operator|->
name|thread_link
expr_stmt|;
name|s2
operator|->
name|thread_link
operator|=
name|s1
operator|->
name|thread_link
expr_stmt|;
name|s1
operator|->
name|thread_link
operator|=
name|sp
expr_stmt|;
comment|/* Link each article that was attached to t2 to t1. */
for|for
control|(
name|t1
operator|=
name|t2
init|;
name|t1
condition|;
name|t1
operator|=
name|t2
control|)
block|{
name|t2
operator|=
name|t2
operator|->
name|sibling
expr_stmt|;
name|link_child
argument_list|(
name|t1
argument_list|)
expr_stmt|;
comment|/* parent is null, thread is newly set */
block|}
name|s1
operator|->
name|thread
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_THREAD
operator||
name|visit_flag
expr_stmt|;
block|}
end_block

end_unit

