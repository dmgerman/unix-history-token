begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: nntpinit.c,v 3.0 1991/11/22 04:12:21 davison Trn $ */
end_comment

begin_comment
comment|/* This software is Copyright 1992 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction or this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_undef
undef|#
directive|undef
name|DECNET
end_undef

begin_comment
comment|/* If you want decnet support */
end_comment

begin_undef
undef|#
directive|undef
name|EXCELAN
end_undef

begin_comment
comment|/* Excelan EXOS 205 support */
end_comment

begin_undef
undef|#
directive|undef
name|NONETDB
end_undef

begin_comment
comment|/* Define if you're missing netdb.h */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"nntpclient.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_NNTP
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NONETDB
end_ifdef

begin_define
define|#
directive|define
name|IPPORT_NNTP
value|((unsigned short) 119)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !EXCELAN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCELAN
end_ifdef

begin_decl_stmt
name|int
name|connect
name|_
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|sockaddr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|htons
name|_
argument_list|(
operator|(
name|unsigned
name|short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|rhost
name|_
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rresvport
name|p
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|socket
name|_
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|sockproto
operator|*
operator|,
expr|struct
name|sockaddr_in
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCELAN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DECNET
end_ifdef

begin_include
include|#
directive|include
file|<netdnet/dn.h>
end_include

begin_include
include|#
directive|include
file|<netdnet/dnetdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECNET */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|inet_addr
name|_
argument_list|(
operator|(
name|char
operator|*
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_tcp_socket
name|_
argument_list|(
operator|(
name|char
operator|*
name|machine
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|server_init
parameter_list|(
name|server
parameter_list|)
name|char
modifier|*
name|server
decl_stmt|;
block|{
name|char
name|line2
index|[
name|NNTP_STRLEN
index|]
decl_stmt|;
name|int
name|sockt_rd
decl_stmt|,
name|sockt_wr
decl_stmt|;
ifdef|#
directive|ifdef
name|DECNET
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|server
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|sockt_rd
operator|=
name|get_dnet_socket
argument_list|(
name|server
argument_list|)
expr_stmt|;
block|}
else|else
name|sockt_rd
operator|=
name|get_tcp_socket
argument_list|(
name|server
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !DECNET */
name|sockt_rd
operator|=
name|get_tcp_socket
argument_list|(
name|server
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sockt_rd
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|sockt_wr
operator|=
name|dup
argument_list|(
name|sockt_rd
argument_list|)
expr_stmt|;
comment|/* Now we'll make file pointers (i.e., buffered I/O) out of     ** the socket file descriptor.  Note that we can't just     ** open a fp for reading and writing -- we have to open     ** up two separate fp's, one for reading, one for writing. */
if|if
condition|(
operator|(
name|ser_rd_fp
operator|=
name|fdopen
argument_list|(
name|sockt_rd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"server_init: fdopen #1"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ser_wr_fp
operator|=
name|fdopen
argument_list|(
name|sockt_wr
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"server_init: fdopen #2"
argument_list|)
expr_stmt|;
name|ser_rd_fp
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Now get the server's signon message */
name|nntp_check
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Send a MODE READER command in case we're talking to innd.     ** If understood, use that reply. */
name|nntp_command
argument_list|(
literal|"MODE READER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntp_gets
argument_list|(
name|line2
argument_list|,
sizeof|sizeof
name|line2
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|atoi
argument_list|(
name|line2
argument_list|)
operator|!=
name|NNTP_BAD_COMMAND_VAL
condition|)
name|strcpy
argument_list|(
name|ser_line
argument_list|,
name|line2
argument_list|)
expr_stmt|;
return|return
name|atoi
argument_list|(
name|ser_line
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|get_tcp_socket
parameter_list|(
name|server
parameter_list|)
name|char
modifier|*
name|server
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
ifdef|#
directive|ifdef
name|NONETDB
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
else|#
directive|else
name|struct
name|servent
modifier|*
name|getservbyname
argument_list|()
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|gethostbyname
argument_list|()
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
ifdef|#
directive|ifdef
name|h_addr
name|int
name|x
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
modifier|*
name|alist
index|[
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* h_addr */
specifier|static
name|struct
name|hostent
name|def
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|defaddr
decl_stmt|;
specifier|static
name|char
name|namebuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"nntp"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nntp/tcp: Unknown service.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* If not a raw ip address, try nameserver */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|server
argument_list|)
operator|||
call|(
name|long
call|)
argument_list|(
name|defaddr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|server
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|hp
operator|=
name|gethostbyname
argument_list|(
name|server
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Raw ip address, fake  */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|namebuf
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|def
operator|.
name|h_name
operator|=
name|namebuf
expr_stmt|;
ifdef|#
directive|ifdef
name|h_addr
name|def
operator|.
name|h_addr_list
operator|=
name|alist
expr_stmt|;
endif|#
directive|endif
name|def
operator|.
name|h_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|defaddr
expr_stmt|;
name|def
operator|.
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|def
operator|.
name|h_addrtype
operator|=
name|AF_INET
expr_stmt|;
name|def
operator|.
name|h_aliases
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
operator|&
name|def
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown host.\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
endif|#
directive|endif
comment|/* !NONETDB */
comment|/* The following is kinda gross.  The name server under 4.3     ** returns a list of addresses, each of which should be tried     ** in turn if the previous one fails.  However, 4.2 hostent     ** structure doesn't have this list of addresses.     ** Under 4.3, h_addr is a #define to h_addr_list[0].     ** We use this to figure out whether to include the NS specific     ** code... */
ifdef|#
directive|ifdef
name|h_addr
comment|/* get a socket and initiate connection -- use multiple addresses */
for|for
control|(
name|cp
operator|=
name|hp
operator|->
name|h_addr_list
init|;
name|cp
operator|&&
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|s
operator|=
name|socket
argument_list|(
name|hp
operator|->
name|h_addrtype
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bcopy
argument_list|(
operator|*
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"connection to %s: "
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"giving up...\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
comment|/* no name server */
ifdef|#
directive|ifdef
name|EXCELAN
name|s
operator|=
name|socket
argument_list|(
name|SOCK_STREAM
argument_list|,
operator|(
expr|struct
name|sockproto
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|sin
argument_list|,
name|SO_KEEPALIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
comment|/* Get the socket */
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|IPPORT_NNTP
argument_list|)
expr_stmt|;
comment|/* set up addr for the connect */
if|if
condition|(
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|rhost
argument_list|(
operator|&
name|server
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown host.\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* And then connect */
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
comment|/* not EXCELAN */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* And then connect */
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* !EXCELAN */
endif|#
directive|endif
comment|/* !h_addr */
return|return
name|s
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DECNET
end_ifdef

begin_function
name|int
name|get_dnet_socket
parameter_list|(
name|server
parameter_list|)
name|char
modifier|*
name|server
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|area
decl_stmt|,
name|node
decl_stmt|;
name|struct
name|sockaddr_dn
name|sdn
decl_stmt|;
name|struct
name|nodeent
modifier|*
name|getnodebyname
argument_list|()
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sdn
argument_list|,
sizeof|sizeof
argument_list|(
name|sdn
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|=
name|sscanf
argument_list|(
name|server
argument_list|,
literal|"%d%*[.]%d"
argument_list|,
operator|&
name|area
argument_list|,
operator|&
name|node
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|node
operator|=
name|area
expr_stmt|;
name|area
operator|=
literal|0
expr_stmt|;
case|case
literal|2
case|:
name|node
operator|+=
name|area
operator|*
literal|1024
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_len
operator|=
literal|2
expr_stmt|;
name|sdn
operator|.
name|sdn_family
operator|=
name|AF_DECnet
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_addr
index|[
literal|0
index|]
operator|=
name|node
operator|%
literal|256
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_addr
index|[
literal|1
index|]
operator|=
name|node
operator|/
literal|256
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|np
operator|=
name|getnodebyname
argument_list|(
name|server
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unknown host.\n"
argument_list|,
name|server
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|np
operator|->
name|n_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sdn
operator|.
name|sdn_add
operator|.
name|a_addr
argument_list|,
name|np
operator|->
name|n_length
argument_list|)
expr_stmt|;
name|sdn
operator|.
name|sdn_add
operator|.
name|a_len
operator|=
name|np
operator|->
name|n_length
expr_stmt|;
name|sdn
operator|.
name|sdn_family
operator|=
name|np
operator|->
name|n_addrtype
expr_stmt|;
block|}
break|break;
block|}
name|sdn
operator|.
name|sdn_objnum
operator|=
literal|0
expr_stmt|;
name|sdn
operator|.
name|sdn_flags
operator|=
literal|0
expr_stmt|;
name|sdn
operator|.
name|sdn_objnamel
operator|=
name|strlen
argument_list|(
literal|"NNTP"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"NNTP"
argument_list|,
operator|&
name|sdn
operator|.
name|sdn_objname
index|[
literal|0
index|]
argument_list|,
name|sdn
operator|.
name|sdn_objnamel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_DECnet
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|nerror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* And then connect */
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdn
argument_list|,
sizeof|sizeof
argument_list|(
name|sdn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nerror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DECNET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXCELAN
end_ifdef

begin_comment
comment|/*  * inet_addr for EXCELAN (which does not have it!)  *  */
end_comment

begin_function
name|unsigned
name|long
name|inet_addr
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|unsigned
name|long
name|val
decl_stmt|,
name|base
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|unsigned
name|long
name|octet
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|octetptr
init|=
name|octet
decl_stmt|;
ifndef|#
directive|ifndef
name|htonl
specifier|extern
name|unsigned
name|long
name|htonl
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* htonl */
name|again
label|:
comment|/* 	 * Collect number up to ``.''. 	 * Values are specified as for C: 	 * 0x=hex, 0=octal, other=decimal. 	 */
name|val
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'0'
condition|)
name|base
operator|=
literal|8
operator|,
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'x'
operator|||
operator|*
name|cp
operator|==
literal|'X'
condition|)
name|base
operator|=
literal|16
operator|,
name|cp
operator|++
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|*
name|base
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|isxdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
operator|(
name|c
operator|+
literal|10
operator|-
operator|(
name|islower
argument_list|(
name|c
argument_list|)
condition|?
literal|'a'
else|:
literal|'A'
operator|)
operator|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * Internet format: 		 *      a.b.c.d 		 *      a.b.c   (with c treated as 16-bits) 		 *      a.b     (with b treated as 24 bits) 		 */
if|if
condition|(
name|octetptr
operator|>=
name|octet
operator|+
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|octetptr
operator|++
operator|=
name|val
operator|,
name|cp
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Check for trailing characters. 	 */
if|if
condition|(
operator|*
name|cp
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|octetptr
operator|++
operator|=
name|val
expr_stmt|;
comment|/* 	 * Concoct the address according to 	 * the number of octet specified. 	 */
name|n
operator|=
name|octetptr
operator|-
name|octet
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
comment|/* a -- 32 bits */
name|val
operator|=
name|octet
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* a.b -- 8.24 bits */
name|val
operator|=
operator|(
name|octet
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|octet
index|[
literal|1
index|]
operator|&
literal|0xffffff
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* a.b.c -- 8.8.16 bits */
name|val
operator|=
operator|(
name|octet
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|octet
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|octet
index|[
literal|2
index|]
operator|&
literal|0xffff
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* a.b.c.d -- 8.8.8.8 bits */
name|val
operator|=
operator|(
name|octet
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|octet
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|octet
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|octet
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|val
operator|=
name|htonl
argument_list|(
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXCELAN */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_NNTP */
end_comment

end_unit

