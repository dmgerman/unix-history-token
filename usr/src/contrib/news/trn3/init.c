begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: init.c,v 3.0 1992/02/01 03:09:32 davison Trn $  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"only.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"addng.h"
end_include

begin_include
include|#
directive|include
file|"sw.h"
end_include

begin_include
include|#
directive|include
file|"art.h"
end_include

begin_include
include|#
directive|include
file|"artsrch.h"
end_include

begin_include
include|#
directive|include
file|"artio.h"
end_include

begin_include
include|#
directive|include
file|"backpage.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"ngsrch.h"
end_include

begin_include
include|#
directive|include
file|"ngstuff.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"respond.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"decode.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_function
name|bool
name|initialize
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|tcbuf
decl_stmt|;
specifier|register
name|bool
name|foundany
init|=
name|FALSE
decl_stmt|;
name|long
name|time
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|NOLINEBUF
specifier|static
name|char
name|std_out_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* must be static or malloced */
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|std_out_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tcbuf
operator|=
name|safemalloc
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
comment|/* make temp buffer for termcap and */
comment|/* other initialization stuff */
name|our_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* init terminal */
name|term_init
argument_list|()
expr_stmt|;
comment|/* must precede sw_init() so that */
comment|/* ospeed is set for baud-rate */
comment|/* switches.  Actually terminal */
comment|/* mode setting is in term_set() */
comment|/* we have to know rnlib to look up global switches in %X/INIT */
name|lib
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|NEWSLIB
argument_list|)
argument_list|)
expr_stmt|;
name|rnlib
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|PRIVLIB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* decode switches */
name|sw_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* must not do % interps! */
comment|/* (but may mung environment) */
comment|/* init signals, status flags */
name|final_init
argument_list|()
expr_stmt|;
comment|/* start up file expansion and the % interpreter */
name|intrp_init
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* now make sure we have a current working directory */
if|if
condition|(
operator|!
name|checkflag
condition|)
name|cwd_check
argument_list|()
expr_stmt|;
comment|/* now that we know where to save things, cd to news directory */
if|if
condition|(
name|chdir
argument_list|(
name|spool
argument_list|)
condition|)
block|{
name|printf
argument_list|(
argument|nocd
argument_list|,
argument|spool
argument_list|)
name|FLUSH
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if we aren't just checking, turn off echo */
if|if
condition|(
operator|!
name|checkflag
condition|)
name|term_set
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* get info on last rn run, if any */
if|if
condition|(
operator|!
name|checkflag
condition|)
name|last_init
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
comment|/* recover 1024 bytes */
comment|/* make sure we are the sole possessors of .newsrc */
if|if
condition|(
operator|!
name|checkflag
condition|)
name|lock_check
argument_list|()
expr_stmt|;
comment|/* check for news news */
if|if
condition|(
operator|!
name|checkflag
condition|)
name|newsnews_check
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_NNTP
comment|/* open connection to server if appropriate */
name|nntp_connect
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* open active file, etc. */
name|ngdata_init
argument_list|()
expr_stmt|;
comment|/* now read in the .newsrc file */
name|foundany
operator|=
name|rcstuff_init
argument_list|()
expr_stmt|;
comment|/* it looks like we will actually read something, so init everything */
name|addng_init
argument_list|()
expr_stmt|;
name|art_init
argument_list|()
expr_stmt|;
name|artio_init
argument_list|()
expr_stmt|;
name|artsrch_init
argument_list|()
expr_stmt|;
name|backpage_init
argument_list|()
expr_stmt|;
name|bits_init
argument_list|()
expr_stmt|;
name|cache_init
argument_list|()
expr_stmt|;
name|head_init
argument_list|()
expr_stmt|;
name|help_init
argument_list|()
expr_stmt|;
name|kfile_init
argument_list|()
expr_stmt|;
name|ng_init
argument_list|()
expr_stmt|;
name|ngsrch_init
argument_list|()
expr_stmt|;
name|ngstuff_init
argument_list|()
expr_stmt|;
name|only_init
argument_list|()
expr_stmt|;
name|rcln_init
argument_list|()
expr_stmt|;
name|respond_init
argument_list|()
expr_stmt|;
name|rn_init
argument_list|()
expr_stmt|;
name|search_init
argument_list|()
expr_stmt|;
name|decode_init
argument_list|()
expr_stmt|;
name|thread_init
argument_list|()
expr_stmt|;
name|util_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FINDNEWNG
comment|/* 	 * Skip this check if the -q flag was given. 	 */
if|if
condition|(
operator|!
name|quickstart
condition|)
block|{
if|if
condition|(
name|find_new_groups
argument_list|()
condition|)
block|{
comment|/* did we add any new groups? */
name|foundany
operator|=
name|TRUE
expr_stmt|;
comment|/* let main() know */
name|starthere
operator|=
literal|0
expr_stmt|;
comment|/* start ng scan from the top */
block|}
block|}
endif|#
directive|endif
name|time
argument_list|(
operator|&
name|lasttime
argument_list|)
expr_stmt|;
comment|/* remember when we inited-- */
comment|/* ends up back in .rnlast */
name|writelast
argument_list|()
expr_stmt|;
comment|/* in fact, put it there now */
ifdef|#
directive|ifdef
name|FINDNEWNG
ifdef|#
directive|ifdef
name|ONLY
if|if
condition|(
name|maxngtodo
condition|)
comment|/* patterns on command line? */
name|foundany
operator||=
name|scanactive
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|foundany
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SIGEMT
end_ifndef

begin_define
define|#
directive|define
name|SIGEMT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* make sure there is no rn out there already */
end_comment

begin_function
name|void
name|lock_check
parameter_list|()
block|{
name|lockname
operator|=
name|savestr
argument_list|(
name|filexp
argument_list|(
name|LOCKNAME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkflag
condition|)
block|{
name|tmpfp
operator|=
name|fopen
argument_list|(
name|lockname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfp
operator|!=
name|Nullfp
condition|)
block|{
name|int
name|processnum
decl_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
name|LBUFLEN
argument_list|,
name|tmpfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
name|processnum
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"You seem to have left a trn running, process %d.\n"
argument_list|,
argument|processnum
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"Trn left running, #%d.\n"
argument_list|,
name|processnum
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|kill
argument_list|(
name|processnum
argument_list|,
name|SIGEMT
argument_list|)
condition|)
block|{
comment|/* does process not exist? */
comment|/* (rn ignores SIGEMT) */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\ That process does not seem to exist anymore.  The count of read articles\n\ may be incorrect in the last newsgroup accessed by that other (defunct)\n\ process.\n\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nProcess crashed.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|lastngname
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"(The last newsgroup accessed was %s.)\n\n"
argument_list|,
argument|lastngname
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"(In %s.)\n\n"
argument_list|,
name|lastngname
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
block|}
name|get_anything
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\ You may not have two copies of [t]rn running simultaneously.  Goodbye.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nCan't start another.\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bizarre
condition|)
name|resetty
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|tmpfp
operator|=
name|fopen
argument_list|(
name|lockname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfp
operator|==
name|Nullfp
condition|)
block|{
name|printf
argument_list|(
argument|cantcreate
argument_list|,
argument|lockname
argument_list|)
name|FLUSH
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|tmpfp
argument_list|,
literal|"%ld\n"
argument_list|,
name|our_pid
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|newsnews_check
parameter_list|()
block|{
name|char
modifier|*
name|newsnewsname
init|=
name|filexp
argument_list|(
name|NEWSNEWSNAME
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tmpfp
operator|=
name|fopen
argument_list|(
name|newsnewsname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|Nullfp
condition|)
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|tmpfp
argument_list|)
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_mtime
operator|>
name|lasttime
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|tmpfp
argument_list|)
operator|!=
name|Nullch
condition|)
name|fputs
argument_list|(
argument|buf
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|get_anything
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
block|}
name|fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

