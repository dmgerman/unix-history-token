begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  trn -- threaded readnews program based on rn 4.4  *  *  Author/Maintainer of trn: davison@borland.com (Wayne Davison)  *  Organization: Borland International  *  Author/Maintainer of rn: sob@bcm.tmc.edu (Stan Barber)  *  Organization: Baylor College of Medicine, Houston,Tx  *  Original Author: lwall@sdcrdcf.UUCP (Larry Wall)  *  Organization: System Development Corporation, Santa Monica  *  *  History:  *	01/14/83 - rn begun  *	04/08/83 - rn 1.0  *	09/01/83 - rn 2.0  *	05/01/85 - rn 4.3  *	11/01/89 - rn/rrn integration  *	11/25/89 - trn begun  *	07/21/90 - trn 1.0  *	07/04/91 - rn 4.4  *	11/25/91 - trn 2.0  *	03/01/93 - trn 3.0 (or so... :-) )  */
end_comment

begin_comment
comment|/* This software is Copyright 1991 by Stan Barber.   *  * Permission is hereby granted to copy, reproduce, redistribute or otherwise  * use this software as long as: there is no monetary profit gained  * specifically from the use or reproduction of this software, it is not  * sold, rented, traded or otherwise marketed, and this copyright notice is  * included prominently in any copy made.   *  * The author make no claims as to the fitness or correctness of this software  * for any use whatsoever, and it is provided as is. Any use of this software  * is at the user's own risk.   */
end_comment

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|rnid
index|[]
init|=
literal|"@(#)$Id: trn.c,v 3.0 1991/11/22 00:14:59 davison Trn $"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|patchlevel
index|[]
init|=
name|PATCHLEVEL
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_include
include|#
directive|include
file|"final.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"ngstuff.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"only.h"
end_include

begin_include
include|#
directive|include
file|"ngsrch.h"
end_include

begin_include
include|#
directive|include
file|"help.h"
end_include

begin_include
include|#
directive|include
file|"last.h"
end_include

begin_include
include|#
directive|include
file|"init.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"sw.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"addng.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_function
name|void
name|rn_init
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|bool
name|foundany
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|bool
name|oh_for_the_good_old_days
init|=
name|FALSE
decl_stmt|;
name|int
name|direction
init|=
literal|1
decl_stmt|;
if|#
directive|if
operator|!
name|THREAD_INIT
comment|/* Default to threaded operation if our name starts with a 't' */
if|if
condition|(
operator|(
name|s
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
name|s
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'t'
condition|)
name|use_threads
operator|=
name|TRUE
expr_stmt|;
else|else
name|select_on
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|foundany
operator|=
name|initialize
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxngtodo
condition|)
name|starthere
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|foundany
condition|)
block|{
comment|/* nothing to do? */
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|verbose
condition|)
name|fputs
argument_list|(
literal|"\ No unread news in subscribed-to newsgroups.  To subscribe to a new\n\ newsgroup use the g<newsgroup> command.\n\ "
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
endif|#
directive|endif
name|starthere
operator|=
name|nextrcline
expr_stmt|;
block|}
comment|/* loop through all unread news */
block|{
name|bool
name|special
init|=
name|FALSE
decl_stmt|;
comment|/* temporarily allow newsgroup */
comment|/*   with no unread news? */
name|bool
name|retry
decl_stmt|;
comment|/* cycle back to top of list? */
name|NG_NUM
name|recent_ng
init|=
literal|0
decl_stmt|;
name|current_ng
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|retry
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|findlast
condition|)
block|{
name|findlast
operator|=
name|FALSE
expr_stmt|;
name|starthere
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|lastngname
condition|)
block|{
if|if
condition|(
operator|(
name|ng
operator|=
name|find_ng
argument_list|(
name|lastngname
argument_list|)
operator|)
operator|==
name|nextrcline
condition|)
name|ng
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|set_ngname
argument_list|(
name|lastngname
argument_list|)
expr_stmt|;
name|set_toread
argument_list|(
name|ng
argument_list|)
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|<=
name|TR_NONE
condition|)
name|ng
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ng
operator|=
name|starthere
expr_stmt|;
name|starthere
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|ng
operator|<=
name|nextrcline
condition|)
block|{
comment|/* for each newsgroup */
if|if
condition|(
name|ng
operator|==
name|nextrcline
condition|)
block|{
comment|/* after the last newsgroup? */
name|mode
operator|=
literal|'f'
expr_stmt|;
ifdef|#
directive|ifdef
name|ONLY
if|if
condition|(
name|maxngtodo
condition|)
block|{
if|if
condition|(
name|retry
condition|)
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\nRestriction %s%s still in effect.\n"
argument_list|,
argument|ngtodo[
literal|0
argument|]
argument_list|,
argument|maxngtodo>
literal|1
argument|?
literal|", etc."
argument|: nullstr
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n(\"Only\" mode.)\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
else|else
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\nNo articles under restriction."
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\nNo \"only\" articles."
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|end_only
argument_list|()
expr_stmt|;
comment|/* release the restriction */
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|bool
name|shoe_fits
decl_stmt|;
comment|/* newsgroup matches restriction? */
name|mode
operator|=
literal|'n'
expr_stmt|;
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|>=
name|TR_NONE
condition|)
block|{
comment|/* recalc toread? */
name|set_ngname
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
name|shoe_fits
operator|=
name|inlist
argument_list|(
name|ngname
argument_list|)
expr_stmt|;
if|if
condition|(
name|shoe_fits
condition|)
name|set_toread
argument_list|(
name|ng
argument_list|)
expr_stmt|;
if|if
condition|(
name|paranoid
condition|)
block|{
name|recent_ng
operator|=
name|current_ng
expr_stmt|;
name|current_ng
operator|=
name|ng
expr_stmt|;
name|cleanup_rc
argument_list|()
expr_stmt|;
comment|/* this may move newsgroups around */
name|ng
operator|=
name|current_ng
expr_stmt|;
name|set_ngname
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|<
operator|(
name|maxngtodo
operator|||
name|special
condition|?
name|TR_NONE
else|:
name|TR_ONE
operator|)
operator|||
operator|!
name|shoe_fits
condition|)
block|{
comment|/* unwanted newsgroup? */
name|ng
operator|+=
name|direction
expr_stmt|;
comment|/* then skip it */
if|if
condition|(
name|ng
operator|<
literal|0
condition|)
block|{
name|ng
operator|=
literal|1
expr_stmt|;
name|direction
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
block|}
name|special
operator|=
name|FALSE
expr_stmt|;
comment|/* go back to normal mode */
if|if
condition|(
name|ng
operator|!=
name|current_ng
condition|)
block|{
name|recent_ng
operator|=
name|current_ng
expr_stmt|;
comment|/* remember previous newsgroup */
name|current_ng
operator|=
name|ng
expr_stmt|;
comment|/* remember current newsgroup */
block|}
name|reask_newsgroup
label|:
name|unflush_output
argument_list|()
expr_stmt|;
comment|/* disable any ^O in effect */
if|if
condition|(
name|ng
operator|>=
name|nextrcline
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_NNTP
if|if
condition|(
name|time
argument_list|(
name|Null
argument_list|(
name|time_t
operator|*
argument_list|)
argument_list|)
operator|-
name|lastactfetch
operator|>
name|MINFETCHTIME
condition|)
block|{
name|fclose
argument_list|(
name|actfp
argument_list|)
expr_stmt|;
name|ngdata_init
argument_list|()
expr_stmt|;
comment|/* re-grab the active file */
block|}
endif|#
directive|endif
name|dfltcmd
operator|=
operator|(
name|retry
condition|?
literal|"npq"
else|:
literal|"qnp"
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n****** End of newsgroups -- what next? [%s] "
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n**** End -- next? [%s] "
argument_list|,
name|dfltcmd
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|ThreadedGroup
operator|=
operator|(
name|use_threads
operator|&&
name|rcchar
index|[
name|ng
index|]
operator|!=
literal|'0'
operator|)
expr_stmt|;
name|dfltcmd
operator|=
operator|(
name|select_on
operator|&&
operator|(
name|ART_NUM
operator|)
name|toread
index|[
name|ng
index|]
operator|>=
name|select_on
condition|?
literal|"+ynq"
else|:
literal|"ynq"
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|printf
argument_list|(
literal|"\n%s %3ld unread article%s in %s -- read now? [%s] "
argument_list|,
name|ThreadedGroup
condition|?
literal|"======"
else|:
literal|"******"
argument_list|,
operator|(
name|long
operator|)
name|toread
index|[
name|ng
index|]
argument_list|,
operator|(
name|toread
index|[
name|ng
index|]
operator|==
name|TR_ONE
condition|?
name|nullstr
else|:
literal|"s"
operator|)
argument_list|,
name|ngname
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|printf
argument_list|(
literal|"\n%s %3ld in %s -- read? [%s] "
argument_list|,
name|ThreadedGroup
condition|?
literal|"===="
else|:
literal|"****"
argument_list|,
operator|(
name|long
operator|)
name|toread
index|[
name|ng
index|]
argument_list|,
name|ngname
argument_list|,
name|dfltcmd
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reinp_newsgroup
label|:
name|eat_typeahead
argument_list|()
expr_stmt|;
name|getcmd
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|*
name|buf
operator|==
literal|'\f'
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
comment|/* if return from stop signal */
goto|goto
name|reask_newsgroup
goto|;
comment|/* give them a prompt again */
block|}
name|setdef
argument_list|(
name|buf
argument_list|,
name|dfltcmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|do_command
label|:
name|direction
operator|=
literal|1
expr_stmt|;
comment|/* default to forward motion */
name|addnewbydefault
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* goto previous newsgroup */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
comment|/* FALL THROUGH */
case|case
literal|'p'
case|:
comment|/* find previous unread newsgroup */
if|if
condition|(
name|ng
operator|>
literal|0
condition|)
name|ng
operator|--
expr_stmt|;
name|direction
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* go backward in the newsrc */
break|break;
case|case
literal|'-'
case|:
name|ng
operator|=
name|recent_ng
expr_stmt|;
comment|/* recall previous newsgroup */
if|if
condition|(
name|ng
operator|<
name|nextrcline
condition|)
if|if
condition|(
operator|!
name|get_ng
argument_list|(
name|rcline
index|[
name|ng
index|]
argument_list|,
literal|0
argument_list|)
condition|)
name|ng
operator|=
name|current_ng
expr_stmt|;
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'x'
case|:
comment|/* quit? */
name|oh_for_the_good_old_days
operator|=
operator|(
operator|*
name|buf
operator|==
literal|'x'
operator|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|ng
operator|=
name|nextrcline
operator|+
literal|1
expr_stmt|;
comment|/* satisfy */
name|retry
operator|=
name|FALSE
expr_stmt|;
comment|/*   loop conditions */
break|break;
case|case
literal|'^'
case|:
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|ng
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* find next unread newsgroup */
if|if
condition|(
name|ng
operator|==
name|nextrcline
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toread
index|[
name|ng
index|]
operator|>
name|TR_NONE
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
name|ng
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* goto next newsgroup */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* and don't skip it if toread==0 */
name|ng
operator|++
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* goto 1st newsgroup */
name|ng
operator|=
literal|0
expr_stmt|;
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* and don't skip it if toread==0 */
break|break;
case|case
literal|'$'
case|:
name|ng
operator|=
name|nextrcline
expr_stmt|;
comment|/* goto last newsgroup */
name|retry
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|list_newsgroups
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
literal|'/'
case|:
case|case
literal|'?'
case|:
comment|/* scan for newsgroup pattern */
ifdef|#
directive|ifdef
name|NGSEARCH
switch|switch
condition|(
name|ng_search
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
case|case
name|NGS_ERROR
case|:
goto|goto
name|reask_newsgroup
goto|;
case|case
name|NGS_ABORT
case|:
goto|goto
name|reinp_newsgroup
goto|;
case|case
name|NGS_INTR
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n(Interrupted)\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n(Intr)\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|ng
operator|=
name|current_ng
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
name|NGS_FOUND
case|:
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
name|NGS_NOTFOUND
case|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\n\nNot found -- use a or g to add newsgroups\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"\n\nNot found\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
goto|goto
name|reask_newsgroup
goto|;
block|}
else|#
directive|else
name|notincl
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'m'
case|:
ifndef|#
directive|ifndef
name|RELOCATE
name|notincl
argument_list|(
literal|"m"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'g'
case|:
comment|/* goto named newsgroup */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|FALSE
argument_list|)
condition|)
comment|/* if they didn't finish command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* go try something else */
for|for
control|(
name|s
operator|=
name|buf
operator|+
literal|1
init|;
operator|*
name|s
operator|==
literal|' '
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* skip leading spaces */
ifdef|#
directive|ifdef
name|RELOCATE
if|if
condition|(
operator|!
operator|*
name|s
operator|&&
operator|*
name|buf
operator|==
literal|'m'
operator|&&
name|ngname
operator|&&
name|ng
operator|<
name|nextrcline
condition|)
name|strcpy
argument_list|(
name|s
argument_list|,
name|ngname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|char
modifier|*
name|_s
decl_stmt|;
for|for
control|(
name|_s
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|*
name|_s
argument_list|)
condition|;
name|_s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|_s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|_s
argument_list|)
condition|)
comment|/* found non-digit before hitting end */
name|set_ngname
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|rcnum
decl_stmt|;
name|rcnum
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcnum
operator|<
name|nextrcline
condition|)
name|set_ngname
argument_list|(
name|rcline
index|[
name|rcnum
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\nOnly %d groups. Try again.\n"
argument_list|,
argument|nextrcline
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nPlease specify a newsgroup.\n"
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
comment|/* try to find newsgroup */
ifdef|#
directive|ifdef
name|RELOCATE
if|if
condition|(
operator|!
name|get_ng
argument_list|(
name|ngname
argument_list|,
operator|(
operator|*
name|buf
operator|==
literal|'m'
condition|?
name|GNG_RELOC
else|:
literal|0
operator|)
operator||
name|GNG_FUZZY
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|get_ng
argument_list|(
name|ngname
argument_list|,
name|GNG_FUZZY
argument_list|)
condition|)
endif|#
directive|endif
name|ng
operator|=
name|current_ng
expr_stmt|;
comment|/* if not found, go nowhere */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|printf
argument_list|(
literal|"\nTries: %d Hits: %d\n"
argument_list|,
argument|softtries
argument_list|,
argument|softtries-softmisses
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
endif|#
directive|endif
case|case
literal|'!'
case|:
comment|/* shell escape */
if|if
condition|(
name|escapade
argument_list|()
condition|)
comment|/* do command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, re input */
goto|goto
name|reask_newsgroup
goto|;
case|case
name|Ctl
argument_list|(
literal|'k'
argument_list|)
case|:
comment|/* edit global KILL file */
name|edit_kfile
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
case|case
literal|'c'
case|:
comment|/* catch up */
ifdef|#
directive|ifdef
name|CATCHUP
if|if
condition|(
name|ng
operator|<
name|nextrcline
condition|)
name|ask_catchup
argument_list|()
expr_stmt|;
name|ng
operator|++
expr_stmt|;
else|#
directive|else
name|notincl
argument_list|(
literal|"c"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|use_threads
condition|)
name|printf
argument_list|(
literal|"\n\nNot running in thread mode.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ng
operator|<
name|nextrcline
operator|&&
name|toread
index|[
name|ng
index|]
operator|>=
name|TR_NONE
condition|)
block|{
name|bool
name|read_unthreaded
init|=
operator|(
name|rcchar
index|[
name|ng
index|]
operator|==
literal|':'
operator|)
decl_stmt|;
name|rcchar
index|[
name|ng
index|]
operator|=
operator|(
name|read_unthreaded
condition|?
literal|'0'
else|:
literal|':'
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n%s will be read %sthreaded.\n"
argument_list|,
argument|rcline[ng]
argument_list|,
argument|read_unthreaded?
literal|"un"
argument|:
literal|""
argument_list|)
name|FLUSH
expr_stmt|;
name|set_toread
argument_list|(
name|ng
argument_list|)
expr_stmt|;
block|}
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
literal|'u'
case|:
comment|/* unsubscribe */
if|if
condition|(
name|ng
operator|<
name|nextrcline
operator|&&
name|toread
index|[
name|ng
index|]
operator|>=
name|TR_NONE
condition|)
block|{
comment|/* unsubscribable? */
name|printf
argument_list|(
argument|unsubto
argument_list|,
argument|rcline[ng]
argument_list|)
name|FLUSH
expr_stmt|;
name|rcchar
index|[
name|ng
index|]
operator|=
name|NEGCHAR
expr_stmt|;
comment|/* unsubscribe to (from?) it */
name|toread
index|[
name|ng
index|]
operator|=
name|TR_UNSUB
expr_stmt|;
comment|/* and make line invisible */
name|ng
operator|++
expr_stmt|;
comment|/* do an automatic 'n' */
block|}
break|break;
case|case
literal|'h'
case|:
block|{
comment|/* help */
name|int
name|cmd
decl_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|=
name|help_ng
argument_list|()
operator|)
operator|>
literal|0
condition|)
name|pushchar
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
case|case
literal|'A'
case|:
if|if
condition|(
name|ng
operator|>=
name|nextrcline
condition|)
break|break;
name|reask_abandon
label|:
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|in_char
argument_list|(
literal|"\nAbandon changes to current newsgroup? [yn] "
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|in_char
argument_list|(
literal|"\nAbandon? [ynh] "
argument_list|,
literal|'B'
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|setdef
argument_list|(
name|buf
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERIFY
name|printcmd
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'h'
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"Type y or SP to abandon the changes to this group since you started trn.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Type n to leave the group as it is.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"y or SP to abandon changes to this group.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n to forget it.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|reask_abandon
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'y'
operator|&&
operator|*
name|buf
operator|!=
literal|'n'
operator|&&
operator|*
name|buf
operator|!=
literal|'q'
condition|)
block|{
name|printf
argument_list|(
name|hforhelp
argument_list|)
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_abandon
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'y'
condition|)
name|abandon_ng
argument_list|(
name|ng
argument_list|)
expr_stmt|;
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
case|case
literal|'a'
case|:
ifndef|#
directive|ifndef
name|FINDNEWNG
name|notincl
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
else|#
directive|else
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
literal|'o'
case|:
ifdef|#
directive|ifdef
name|ONLY
block|{
ifdef|#
directive|ifdef
name|FINDNEWNG
name|bool
name|doscan
init|=
operator|(
operator|*
name|buf
operator|==
literal|'a'
operator|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|TRUE
argument_list|)
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, try something else */
name|end_only
argument_list|()
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|1
index|]
condition|)
block|{
name|bool
name|minusd
init|=
name|instr
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"-d"
argument_list|,
name|TRUE
argument_list|)
operator|!=
name|Nullch
decl_stmt|;
name|sw_list
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|minusd
condition|)
name|cwd_check
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
name|FLUSH
expr_stmt|;
ifdef|#
directive|ifdef
name|FINDNEWNG
if|if
condition|(
name|doscan
operator|&&
name|maxngtodo
condition|)
name|scanactive
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|ng
operator|=
literal|0
expr_stmt|;
comment|/* simulate ^ */
name|retry
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|notincl
argument_list|(
literal|"o"
argument_list|)
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
endif|#
directive|endif
case|case
literal|'&'
case|:
if|if
condition|(
name|switcheroo
argument_list|()
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, try something else */
goto|goto
name|reask_newsgroup
goto|;
case|case
literal|'l'
case|:
block|{
comment|/* list other newsgroups */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|TRUE
argument_list|)
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
comment|/* if rubbed out, try something else */
for|for
control|(
name|s
operator|=
name|buf
operator|+
literal|1
init|;
operator|*
name|s
operator|==
literal|' '
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* skip leading spaces */
name|sprintf
argument_list|(
name|cmd_buf
argument_list|,
literal|"%s '%s'"
argument_list|,
name|filexp
argument_list|(
name|NEWSGROUPS
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
if|if
condition|(
name|doshell
argument_list|(
name|sh
argument_list|,
name|cmd_buf
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|VERBOSE
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"    (Error from newsgroups program)\n"
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
name|ELSE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERSE
name|fputs
argument_list|(
literal|"(Error)\n"
argument_list|,
name|stdout
argument_list|)
name|FLUSH
decl_stmt|;
endif|#
directive|endif
name|noecho
argument_list|()
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
case|case
literal|'U'
case|:
case|case
literal|'+'
case|:
case|case
literal|'.'
case|:
case|case
literal|'='
case|:
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'\t'
case|:
comment|/* do normal thing */
if|if
condition|(
name|ng
operator|>=
name|nextrcline
condition|)
block|{
name|fputs
argument_list|(
literal|"\nNot on a newsgroup."
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|buf
operator|==
literal|'.'
condition|)
block|{
comment|/* start command? */
if|if
condition|(
operator|!
name|finish_command
argument_list|(
name|FALSE
argument_list|)
condition|)
comment|/* get rest of command */
goto|goto
name|reinp_newsgroup
goto|;
name|s
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* do_newsgroup will free it */
block|}
else|else
block|{
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'+'
operator|||
operator|*
name|buf
operator|==
literal|'U'
operator|||
operator|*
name|buf
operator|==
literal|'='
condition|)
operator|*
name|s
operator|++
operator|=
name|lastchar
expr_stmt|;
comment|/* restore 0200 if from a macro */
name|save_typeahead
argument_list|(
name|s
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
condition|)
name|s
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|toread
index|[
name|ng
index|]
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|do_newsgroup
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|NG_ERROR
case|:
case|case
name|NG_NORM
case|:
name|ng
operator|++
expr_stmt|;
break|break;
case|case
name|NG_ASK
case|:
goto|goto
name|reask_newsgroup
goto|;
case|case
name|NG_SELPRIOR
case|:
operator|*
name|buf
operator|=
literal|'p'
expr_stmt|;
goto|goto
name|do_command
goto|;
case|case
name|NG_SELNEXT
case|:
operator|*
name|buf
operator|=
literal|'n'
expr_stmt|;
goto|goto
name|do_command
goto|;
case|case
name|NG_MINUS
case|:
name|ng
operator|=
name|recent_ng
expr_stmt|;
comment|/* recall previous newsgroup */
name|special
operator|=
name|TRUE
expr_stmt|;
comment|/* don't skip it if toread==0 */
break|break;
block|}
break|break;
ifdef|#
directive|ifdef
name|STRICTCR
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
argument|badcr
argument_list|,
argument|stdout
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|rnid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
name|patchlevel
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSend bugs to davison@borland.com\n"
argument_list|)
name|FLUSH
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
default|default:
name|printf
argument_list|(
literal|"\n%s"
argument_list|,
argument|hforhelp
argument_list|)
name|FLUSH
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|reask_newsgroup
goto|;
block|}
block|}
block|}
do|while
condition|(
name|retry
condition|)
do|;
block|}
comment|/* now write .newsrc back out */
name|write_rc
argument_list|()
expr_stmt|;
if|if
condition|(
name|oh_for_the_good_old_days
condition|)
name|get_old_rc
argument_list|()
expr_stmt|;
name|finalize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* and exit */
block|}
end_function

begin_comment
comment|/* set current newsgroup */
end_comment

begin_function
name|void
name|set_ngname
parameter_list|(
name|what
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|what
argument_list|)
operator|+
literal|1
decl_stmt|;
name|growstr
argument_list|(
operator|&
name|ngname
argument_list|,
operator|&
name|ngnlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ngname
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|growstr
argument_list|(
operator|&
name|ngdir
argument_list|,
operator|&
name|ngdlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ngdir
argument_list|,
name|getngdir
argument_list|(
name|ngname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|myngdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ngdirlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|getngdir
parameter_list|(
name|ngnam
parameter_list|)
name|char
modifier|*
name|ngnam
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|growstr
argument_list|(
operator|&
name|myngdir
argument_list|,
operator|&
name|ngdirlen
argument_list|,
name|strlen
argument_list|(
name|ngnam
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|myngdir
argument_list|,
name|ngnam
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|myngdir
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
operator|*
name|s
operator|=
literal|'/'
expr_stmt|;
return|return
name|myngdir
return|;
block|}
end_function

end_unit

