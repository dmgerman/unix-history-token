begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: rthread.c,v 3.0 1992/12/14 00:14:13 davison Trn $ */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"artstate.h"
end_include

begin_include
include|#
directive|include
file|"rcstuff.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"kfile.h"
end_include

begin_include
include|#
directive|include
file|"head.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"rt-mt.h"
end_include

begin_include
include|#
directive|include
file|"rt-ov.h"
end_include

begin_include
include|#
directive|include
file|"rt-page.h"
end_include

begin_include
include|#
directive|include
file|"rt-process.h"
end_include

begin_include
include|#
directive|include
file|"rt-select.h"
end_include

begin_include
include|#
directive|include
file|"rt-wumpus.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_decl_stmt
name|HASHTABLE
modifier|*
name|msgid_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|try_ov
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|try_mt
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|thread_init
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USE_OV
name|try_ov
operator|=
name|ov_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_MT
name|try_mt
operator|=
name|mt_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate the thread data we need for this group.  We must call ** thread_close() before calling this again. */
end_comment

begin_function
name|void
name|thread_open
parameter_list|()
block|{
if|if
condition|(
operator|!
name|msgid_hash
condition|)
name|msgid_hash
operator|=
name|hashcreate
argument_list|(
literal|201
argument_list|,
name|msgid_cmp
argument_list|)
expr_stmt|;
comment|/*TODO: pick a better size */
if|if
condition|(
name|ThreadedGroup
condition|)
block|{
comment|/* Parse input and use msgid_hash for quick article lookups. */
comment|/* If cached but not threaded articles exist, set up to thread them. */
if|if
condition|(
name|first_subject
condition|)
block|{
name|first_cached
operator|=
name|firstart
expr_stmt|;
name|last_cached
operator|=
name|firstart
operator|-
literal|1
expr_stmt|;
name|parsed_art
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sel_mode
operator|==
name|SM_ARTICLE
condition|)
name|set_selector
argument_list|(
name|sel_mode
argument_list|,
name|sel_artsort
argument_list|)
expr_stmt|;
else|else
name|set_selector
argument_list|(
name|sel_threadmode
argument_list|,
name|sel_threadsort
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MT
if|if
condition|(
name|try_mt
operator|&&
operator|!
name|first_subject
condition|)
if|if
condition|(
operator|!
name|mt_data
argument_list|()
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_OV
if|if
condition|(
name|try_ov
operator|&&
name|first_cached
operator|>
name|last_cached
condition|)
if|if
condition|(
name|thread_always
condition|)
operator|(
name|void
operator|)
name|ov_data
argument_list|(
name|absfirst
argument_list|,
name|lastart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|firstart
operator|>
name|lastart
condition|)
block|{
comment|/* If no unread articles, see if ov. exists as quick as possible */
operator|(
name|void
operator|)
name|ov_data
argument_list|(
name|absfirst
argument_list|,
name|absfirst
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|first_cached
operator|=
name|last_cached
operator|+
literal|1
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|ov_data
argument_list|(
name|firstart
argument_list|,
name|lastart
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_NNTP
if|if
condition|(
operator|!
name|ov_opened
condition|)
name|setmissingbits
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|last_cached
operator|>
name|lastart
condition|)
block|{
name|toread
index|[
name|ng
index|]
operator|+=
call|(
name|ART_UNREAD
call|)
argument_list|(
name|last_cached
operator|-
name|lastart
argument_list|)
expr_stmt|;
comment|/* ensure getngsize() knows the new maximum */
name|ngmax
index|[
name|ng
index|]
operator|=
name|lastart
operator|=
name|last_cached
expr_stmt|;
block|}
name|thread_grow
argument_list|()
expr_stmt|;
comment|/* thread any new articles not yet in the database */
name|added_articles
operator|=
literal|0
expr_stmt|;
name|sel_page_sp
operator|=
literal|0
expr_stmt|;
name|sel_page_app
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the group's thread info. */
end_comment

begin_function
name|void
name|thread_grow
parameter_list|()
block|{
name|added_articles
operator|=
name|lastart
operator|-
name|last_cached
expr_stmt|;
if|if
condition|(
name|added_articles
operator|>
literal|0
operator|&&
name|thread_always
condition|)
name|cache_range
argument_list|(
name|last_cached
operator|+
literal|1
argument_list|,
name|lastart
argument_list|)
expr_stmt|;
name|count_subjects
argument_list|(
name|CS_NORM
argument_list|)
expr_stmt|;
if|if
condition|(
name|artptr_list
condition|)
name|sort_articles
argument_list|()
expr_stmt|;
else|else
name|sort_subjects
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kill_tmp_arts
parameter_list|(
name|data
parameter_list|,
name|extra
parameter_list|)
name|HASHDATUM
modifier|*
name|data
decl_stmt|;
name|int
name|extra
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
operator|(
name|ARTICLE
operator|*
operator|)
name|data
operator|->
name|dat_ptr
decl_stmt|;
if|if
condition|(
name|ap
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|thread_close
parameter_list|()
block|{
name|curr_artp
operator|=
name|artp
operator|=
name|Nullart
expr_stmt|;
name|init_tree
argument_list|()
expr_stmt|;
comment|/* free any tree lines */
if|if
condition|(
name|msgid_hash
condition|)
block|{
name|hashwalk
argument_list|(
name|msgid_hash
argument_list|,
name|kill_tmp_arts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|msgid_hash
argument_list|)
expr_stmt|;
name|msgid_hash
operator|=
literal|0
expr_stmt|;
block|}
name|sel_page_sp
operator|=
literal|0
expr_stmt|;
name|sel_page_app
operator|=
literal|0
expr_stmt|;
name|sel_last_ap
operator|=
literal|0
expr_stmt|;
name|sel_last_sp
operator|=
literal|0
expr_stmt|;
name|selected_only
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_OV
name|ov_close
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ARTICLE
modifier|*
name|find_article
parameter_list|(
name|artnum
parameter_list|)
name|ART_NUM
name|artnum
decl_stmt|;
block|{
if|if
condition|(
name|artp
operator|&&
operator|(
name|artp
operator|->
name|flags
operator|&
name|AF_TMPMEM
operator|)
operator|==
name|AF_TMPMEM
operator|&&
operator|!
name|artnum
condition|)
return|return
name|artp
return|;
if|if
condition|(
name|artnum
operator|<
name|absfirst
operator|||
name|artnum
operator|>
name|lastart
condition|)
return|return
operator|(
name|artp
operator|=
name|Nullart
operator|)
return|;
return|return
operator|(
name|artp
operator|=
name|article_ptr
argument_list|(
name|artnum
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|top_article
parameter_list|()
block|{
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|artp
operator|=
name|Nullart
expr_stmt|;
name|inc_art
argument_list|(
name|selected_only
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ARTICLE
modifier|*
name|first_art
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
operator|(
name|ThreadedGroup
condition|?
name|sp
operator|->
name|thread
else|:
name|sp
operator|->
name|articles
operator|)
decl_stmt|;
if|if
condition|(
name|ap
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
name|ap
operator|=
name|next_art
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ap
return|;
block|}
end_function

begin_function
name|ARTICLE
modifier|*
name|last_art
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|ThreadedGroup
condition|)
block|{
name|ap
operator|=
name|sp
operator|->
name|articles
expr_stmt|;
while|while
condition|(
name|ap
operator|->
name|subj_next
condition|)
name|ap
operator|=
name|ap
operator|->
name|subj_next
expr_stmt|;
return|return
name|ap
return|;
block|}
name|ap
operator|=
name|sp
operator|->
name|thread
expr_stmt|;
if|if
condition|(
name|ap
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|sibling
condition|)
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|child1
condition|)
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
condition|)
name|ap
operator|=
name|prev_art
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/* Bump art/artp to the next article, wrapping from thread to thread. ** If sel_flag is TRUE, only stops at selected articles. ** If rereading is FALSE, only stops at unread articles. */
end_comment

begin_function
name|void
name|inc_art
parameter_list|(
name|sel_flag
parameter_list|,
name|rereading
parameter_list|)
name|bool_int
name|sel_flag
decl_stmt|,
name|rereading
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|artp
decl_stmt|;
name|int
name|subj_mask
init|=
operator|(
name|sel_mode
operator|==
name|SM_THREAD
condition|?
operator|(
name|SF_THREAD
operator||
name|SF_VISIT
operator|)
else|:
name|SF_VISIT
operator|)
decl_stmt|;
comment|/* Use the explicit article-order if it exists */
if|if
condition|(
name|artptr_list
condition|)
block|{
name|ARTICLE
modifier|*
modifier|*
name|limit
init|=
name|artptr_list
operator|+
name|article_count
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
name|artptr
operator|=
name|artptr_list
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|artptr
operator|||
operator|*
name|artptr
operator|!=
name|ap
condition|)
block|{
for|for
control|(
name|artptr
operator|=
name|artptr_list
init|;
name|artptr
operator|<
name|limit
condition|;
name|artptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|artptr
operator|==
name|ap
condition|)
break|break;
block|}
block|}
do|do
block|{
if|if
condition|(
operator|++
name|artptr
operator|>=
name|limit
condition|)
break|break;
name|ap
operator|=
operator|*
name|artptr
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|rereading
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|)
operator|||
operator|(
name|sel_flag
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|artptr
operator|<
name|limit
condition|)
block|{
name|artp
operator|=
operator|*
name|artptr
expr_stmt|;
name|art
operator|=
name|article_num
argument_list|(
name|artp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|artp
operator|=
name|Nullart
expr_stmt|;
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|artptr
operator|=
name|artptr_list
expr_stmt|;
block|}
return|return;
block|}
comment|/* Use subject- or thread-order when possible */
if|if
condition|(
name|ThreadedGroup
operator|||
name|srchahead
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|bool
name|try_this_group_again
init|=
operator|!
name|rereading
decl_stmt|;
if|if
condition|(
name|ap
condition|)
name|sp
operator|=
name|ap
operator|->
name|subj
expr_stmt|;
else|else
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|subj_mask
operator|)
operator|!=
name|subj_mask
condition|;
control|)
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
goto|goto
name|num_inc
goto|;
do|do
block|{
if|if
condition|(
name|ap
condition|)
name|ap
operator|=
name|next_art
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
name|ap
operator|=
name|first_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ap
condition|)
block|{
if|if
condition|(
name|try_this_group_again
condition|)
name|try_this_group_again
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|sp
operator|=
name|sp
operator|->
name|next
operator|)
operator|!=
name|Nullsubj
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|subj_mask
operator|)
operator|!=
name|subj_mask
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
break|break;
block|}
name|ap
operator|=
name|first_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ap
operator|&&
operator|(
operator|(
operator|!
name|rereading
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|)
operator|||
operator|(
name|sel_flag
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|artp
operator|=
name|ap
operator|)
operator|!=
name|Nullart
condition|)
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, just increment through the art numbers */
name|num_inc
label|:
if|if
condition|(
operator|!
name|ap
condition|)
block|{
name|art
operator|=
name|firstart
operator|-
literal|1
expr_stmt|;
name|ap
operator|=
name|article_ptr
argument_list|(
name|art
argument_list|)
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
operator|++
name|art
operator|>
name|lastart
condition|)
block|{
name|ap
operator|=
name|Nullart
expr_stmt|;
break|break;
block|}
name|ap
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|rereading
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|)
operator|||
operator|(
name|sel_flag
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
operator|||
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
do|;
name|artp
operator|=
name|ap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bump art/artp to the previous article, wrapping from thread to thread. ** If sel_flag is TRUE, only stops at selected articles. ** If rereading is FALSE, only stops at unread articles. */
end_comment

begin_function
name|void
name|dec_art
parameter_list|(
name|sel_flag
parameter_list|,
name|rereading
parameter_list|)
name|bool_int
name|sel_flag
decl_stmt|,
name|rereading
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|artp
decl_stmt|;
name|int
name|subj_mask
init|=
operator|(
name|sel_mode
operator|==
name|SM_THREAD
condition|?
operator|(
name|SF_THREAD
operator||
name|SF_VISIT
operator|)
else|:
name|SF_VISIT
operator|)
decl_stmt|;
comment|/* Use the explicit article-order if it exists */
if|if
condition|(
name|artptr_list
condition|)
block|{
name|ARTICLE
modifier|*
modifier|*
name|limit
init|=
name|artptr_list
operator|+
name|article_count
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
name|artptr
operator|=
name|limit
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|artptr
operator|||
operator|*
name|artptr
operator|!=
name|ap
condition|)
block|{
for|for
control|(
name|artptr
operator|=
name|artptr_list
init|;
name|artptr
operator|<
name|limit
condition|;
name|artptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|artptr
operator|==
name|ap
condition|)
break|break;
block|}
block|}
do|do
block|{
if|if
condition|(
name|artptr
operator|==
name|artptr_list
condition|)
break|break;
name|ap
operator|=
operator|*
operator|--
name|artptr
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|rereading
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|)
operator|||
operator|(
name|sel_flag
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
condition|)
do|;
name|artp
operator|=
operator|*
name|artptr
expr_stmt|;
name|art
operator|=
name|article_num
argument_list|(
name|artp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Use subject- or thread-order when possible */
if|if
condition|(
name|ThreadedGroup
operator|||
name|srchahead
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|ap
condition|)
name|sp
operator|=
name|ap
operator|->
name|subj
expr_stmt|;
else|else
for|for
control|(
name|sp
operator|=
name|last_subject
init|;
name|sp
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|subj_mask
operator|)
operator|!=
name|subj_mask
condition|;
control|)
name|sp
operator|=
name|sp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
goto|goto
name|num_dec
goto|;
do|do
block|{
if|if
condition|(
name|ap
condition|)
name|ap
operator|=
name|prev_art
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
name|ap
operator|=
name|last_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ap
condition|)
block|{
while|while
condition|(
operator|(
name|sp
operator|=
name|sp
operator|->
name|prev
operator|)
operator|!=
name|Nullsubj
operator|&&
operator|(
name|sp
operator|->
name|flags
operator|&
name|subj_mask
operator|)
operator|!=
name|subj_mask
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|sp
condition|)
break|break;
name|ap
operator|=
name|last_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ap
operator|&&
operator|(
operator|(
operator|!
name|rereading
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|)
operator|||
operator|(
name|sel_flag
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|artp
operator|=
name|ap
operator|)
operator|!=
name|Nullart
condition|)
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
name|art
operator|=
name|absfirst
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, just decrement through the art numbers */
name|num_dec
label|:
name|ap
operator|=
name|article_ptr
argument_list|(
name|art
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|--
name|art
operator|<
name|absfirst
condition|)
block|{
name|ap
operator|=
name|Nullart
expr_stmt|;
break|break;
block|}
name|ap
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|!
name|rereading
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
operator|)
operator|)
operator|||
operator|(
name|sel_flag
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
operator|||
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
do|;
name|artp
operator|=
name|ap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bump the param to the next article in depth-first order. */
end_comment

begin_function
name|ARTICLE
modifier|*
name|bump_art
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|ap
operator|->
name|child1
condition|)
return|return
name|ap
operator|->
name|child1
return|;
while|while
condition|(
operator|!
name|ap
operator|->
name|sibling
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|=
name|ap
operator|->
name|parent
operator|)
condition|)
return|return
name|Nullart
return|;
block|}
return|return
name|ap
operator|->
name|sibling
return|;
block|}
end_function

begin_comment
comment|/* Bump the param to the next REAL article.  Uses subject order in a ** non-threaded group; honors the breadth_first flag in a threaded one. */
end_comment

begin_function
name|ARTICLE
modifier|*
name|next_art
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
name|try_again
label|:
if|if
condition|(
operator|!
name|ThreadedGroup
condition|)
block|{
name|ap
operator|=
name|ap
operator|->
name|subj_next
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|breadth_first
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|sibling
condition|)
block|{
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ap
operator|->
name|parent
condition|)
name|ap
operator|=
name|ap
operator|->
name|parent
operator|->
name|child1
expr_stmt|;
else|else
name|ap
operator|=
name|ap
operator|->
name|subj
operator|->
name|thread
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|ap
operator|->
name|child1
condition|)
block|{
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
operator|!
name|ap
operator|->
name|sibling
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|=
name|ap
operator|->
name|parent
operator|)
condition|)
return|return
name|Nullart
return|;
block|}
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
block|}
do|while
condition|(
name|breadth_first
condition|)
do|;
name|done
label|:
if|if
condition|(
name|ap
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
goto|goto
name|try_again
goto|;
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/* Bump the param to the previous REAL article.  Uses subject order in a ** non-threaded group. */
end_comment

begin_function
name|ARTICLE
modifier|*
name|prev_art
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|initial_ap
decl_stmt|;
name|try_again
label|:
name|initial_ap
operator|=
name|ap
expr_stmt|;
if|if
condition|(
operator|!
name|ThreadedGroup
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|ap
operator|->
name|subj
operator|->
name|articles
operator|)
operator|==
name|initial_ap
condition|)
name|ap
operator|=
name|Nullart
expr_stmt|;
else|else
while|while
condition|(
name|ap
operator|->
name|subj_next
operator|!=
name|initial_ap
condition|)
name|ap
operator|=
name|ap
operator|->
name|subj_next
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ap
operator|=
operator|(
name|ap
operator|->
name|parent
condition|?
name|ap
operator|->
name|parent
operator|->
name|child1
else|:
name|ap
operator|->
name|subj
operator|->
name|thread
operator|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|initial_ap
condition|)
block|{
name|ap
operator|=
name|ap
operator|->
name|parent
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|ap
operator|->
name|sibling
operator|!=
name|initial_ap
condition|)
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
while|while
condition|(
name|ap
operator|->
name|child1
condition|)
block|{
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
while|while
condition|(
name|ap
operator|->
name|sibling
condition|)
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|ap
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
goto|goto
name|try_again
goto|;
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/* Find the next art/artp with the same subject as this one.  Returns ** FALSE if no such article exists. */
end_comment

begin_function
name|bool
name|next_art_with_subj
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|artp
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|bool
name|try_this_subj_again
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return
name|FALSE
return|;
name|sp
operator|=
name|ap
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|ap
operator|=
name|ap
operator|->
name|subj_next
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
block|{
if|if
condition|(
name|try_this_subj_again
condition|)
block|{
name|ap
operator|=
name|sp
operator|->
name|articles
expr_stmt|;
name|try_this_subj_again
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|art
condition|)
name|art
operator|=
name|firstart
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_READ
operator||
name|AF_MISSING
operator|)
operator|)
operator|||
operator|(
name|selected_only
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
condition|)
do|;
name|artp
operator|=
name|ap
expr_stmt|;
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARTSEARCH
name|srchahead
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find the previous art/artp with the same subject as this one.  Returns ** FALSE if no such article exists. */
end_comment

begin_function
name|bool
name|prev_art_with_subj
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|artp
decl_stmt|,
modifier|*
name|ap2
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|bool
name|try_this_subj_again
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return
name|FALSE
return|;
name|sp
operator|=
name|ap
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|ap2
operator|=
name|ap
operator|->
name|subj
operator|->
name|articles
expr_stmt|;
if|if
condition|(
name|ap2
operator|==
name|ap
condition|)
name|ap
operator|=
name|Nullart
expr_stmt|;
else|else
block|{
while|while
condition|(
name|ap2
operator|&&
name|ap2
operator|->
name|subj_next
operator|!=
name|ap
condition|)
name|ap2
operator|=
name|ap2
operator|->
name|subj_next
expr_stmt|;
name|ap
operator|=
name|ap2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ap
condition|)
block|{
if|if
condition|(
name|try_this_subj_again
condition|)
block|{
name|ap
operator|=
name|sp
operator|->
name|articles
expr_stmt|;
while|while
condition|(
name|ap
operator|->
name|subj_next
condition|)
name|ap
operator|=
name|ap
operator|->
name|subj_next
expr_stmt|;
name|try_this_subj_again
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|art
condition|)
name|art
operator|=
name|lastart
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_READ
operator||
name|AF_MISSING
operator|)
operator|)
operator|||
operator|(
name|selected_only
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
operator|)
condition|)
do|;
name|artp
operator|=
name|ap
expr_stmt|;
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Select a single article. */
end_comment

begin_function
name|void
name|select_article
parameter_list|(
name|ap
parameter_list|,
name|sel_flags
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|sel_flags
decl_stmt|;
block|{
name|int
name|desired_flags
init|=
operator|(
name|sel_rereading
condition|?
name|AF_READ
else|:
literal|0
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|bool
name|echo
decl_stmt|;
if|if
condition|(
name|sel_flags
operator|&
name|AF_ECHO
condition|)
block|{
name|echo
operator|=
name|TRUE
expr_stmt|;
name|sel_flags
operator|&=
operator|~
name|AF_ECHO
expr_stmt|;
block|}
else|else
name|echo
operator|=
name|FALSE
expr_stmt|;
else|#
directive|else
name|sel_flags
operator|&=
operator|~
name|AF_ECHO
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sel_flags
operator|&
operator|(
name|AF_AUTOSELECT
operator||
name|AF_AUTOSELECTALL
operator|)
condition|)
name|save_ids
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_MISSING
operator||
name|AF_READ
operator|)
operator|)
operator|==
name|desired_flags
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|sel_mask
operator|)
condition|)
block|{
name|selected_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|echo
condition|)
block|{
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\tSelected"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|ap
operator|->
name|flags
operator|=
operator|(
name|ap
operator|->
name|flags
operator|&
operator|~
name|AF_DEL
operator|)
operator||
name|sel_mask
operator||
name|sel_flags
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|flags
operator||=
name|sel_flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|subj
operator|->
name|flags
operator|&
name|sel_mask
operator|)
condition|)
name|selected_subj_cnt
operator|++
expr_stmt|;
name|ap
operator|->
name|subj
operator|->
name|flags
operator|=
operator|(
name|ap
operator|->
name|subj
operator|->
name|flags
operator|&
operator|~
name|SF_DEL
operator|)
operator||
name|sel_mask
operator||
name|sel_flags
operator||
name|SF_VISIT
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|ap
operator|->
name|subj
operator|->
name|thread
operator|)
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
name|selected_only
operator|=
operator|(
name|selected_only
operator|||
name|selected_count
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select all the articles in a subject. */
end_comment

begin_function
name|void
name|select_subject
parameter_list|(
name|subj
parameter_list|,
name|sel_flags
parameter_list|)
name|SUBJECT
modifier|*
name|subj
decl_stmt|;
name|int
name|sel_flags
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|desired_flags
init|=
operator|(
name|sel_rereading
condition|?
name|AF_READ
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|old_count
init|=
name|selected_count
decl_stmt|;
if|if
condition|(
name|sel_flags
operator|&
operator|(
name|AF_AUTOSELECT
operator||
name|AF_AUTOSELECTALL
operator|)
condition|)
block|{
name|save_ids
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sel_flags
operator|&
name|AF_AUTOSELECTALL
condition|)
name|subj
operator|->
name|flags
operator||=
name|SF_AUTOSELECT
expr_stmt|;
block|}
for|for
control|(
name|ap
operator|=
name|subj
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_MISSING
operator||
name|AF_READ
operator||
name|sel_mask
operator|)
operator|)
operator|==
name|desired_flags
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|sel_mask
operator||
name|sel_flags
expr_stmt|;
name|selected_count
operator|++
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|flags
operator||=
name|sel_flags
expr_stmt|;
block|}
if|if
condition|(
name|selected_count
operator|>
name|old_count
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|subj
operator|->
name|flags
operator|&
name|sel_mask
operator|)
condition|)
name|selected_subj_cnt
operator|++
expr_stmt|;
name|subj
operator|->
name|flags
operator|=
operator|(
name|subj
operator|->
name|flags
operator|&
operator|~
name|SF_DEL
operator|)
operator||
name|sel_mask
operator||
name|SF_VISIT
operator||
name|SF_WASSELECTED
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|subj
operator|->
name|thread
operator|)
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
name|selected_only
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|subj
operator|->
name|flags
operator||=
name|SF_WASSELECTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select all the articles in a thread. */
end_comment

begin_function
name|void
name|select_thread
parameter_list|(
name|thread
parameter_list|,
name|sel_flags
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
name|int
name|sel_flags
decl_stmt|;
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|select_subject
argument_list|(
name|sp
argument_list|,
name|sel_flags
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Select the subthread attached to this article. */
end_comment

begin_function
name|void
name|select_subthread
parameter_list|(
name|ap
parameter_list|,
name|sel_flags
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|sel_flags
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|limit
decl_stmt|;
name|SUBJECT
modifier|*
name|subj
decl_stmt|;
name|int
name|desired_flags
init|=
operator|(
name|sel_rereading
condition|?
name|AF_READ
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|old_count
init|=
name|selected_count
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return;
name|subj
operator|=
name|ap
operator|->
name|subj
expr_stmt|;
for|for
control|(
name|limit
operator|=
name|ap
init|;
name|limit
condition|;
name|limit
operator|=
name|limit
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|limit
operator|->
name|sibling
condition|)
block|{
name|limit
operator|=
name|limit
operator|->
name|sibling
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sel_flags
operator|&
operator|(
name|AF_AUTOSELECT
operator||
name|AF_AUTOSELECTALL
operator|)
condition|)
name|save_ids
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
name|ap
operator|!=
name|limit
condition|;
name|ap
operator|=
name|bump_art
argument_list|(
name|ap
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_MISSING
operator||
name|AF_READ
operator||
name|sel_mask
operator|)
operator|)
operator|==
name|desired_flags
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|sel_mask
operator||
name|sel_flags
expr_stmt|;
name|selected_count
operator|++
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|flags
operator||=
name|sel_flags
expr_stmt|;
block|}
if|if
condition|(
name|selected_count
operator|>
name|old_count
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|subj
operator|->
name|flags
operator|&
name|sel_mask
operator|)
condition|)
name|selected_subj_cnt
operator|++
expr_stmt|;
name|subj
operator|->
name|flags
operator|=
operator|(
name|subj
operator|->
name|flags
operator|&
operator|~
name|SF_DEL
operator|)
operator||
name|sel_mask
operator||
name|SF_VISIT
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|subj
operator|->
name|thread
operator|)
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
name|selected_only
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Deselect a single article. */
end_comment

begin_function
name|void
name|deselect_article
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|ap
operator|->
name|flags
operator|&=
operator|~
name|sel_mask
expr_stmt|;
if|if
condition|(
operator|!
name|selected_count
operator|--
condition|)
name|selected_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
if|if
condition|(
name|mode
operator|!=
literal|'t'
condition|)
block|{
name|IF
argument_list|(
argument|verbose
argument_list|)
name|fputs
argument_list|(
literal|"\tDeselected"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|sel_rereading
operator|&&
name|sel_mode
operator|==
name|SM_ARTICLE
condition|)
name|ap
operator|->
name|flags
operator||=
name|AF_DEL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deselect all the articles in a subject. */
end_comment

begin_function
name|void
name|deselect_subject
parameter_list|(
name|subj
parameter_list|)
name|SUBJECT
modifier|*
name|subj
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|subj
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|ap
operator|->
name|flags
operator|&=
operator|~
name|sel_mask
expr_stmt|;
if|if
condition|(
operator|!
name|selected_count
operator|--
condition|)
name|selected_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subj
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|subj
operator|->
name|flags
operator|&=
operator|~
name|sel_mask
expr_stmt|;
name|selected_subj_cnt
operator|--
expr_stmt|;
block|}
name|subj
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SF_VISIT
operator||
name|SF_WASSELECTED
operator|)
expr_stmt|;
if|if
condition|(
name|sel_rereading
condition|)
name|subj
operator|->
name|flags
operator||=
name|SF_DEL
expr_stmt|;
else|else
name|subj
operator|->
name|flags
operator|&=
operator|~
name|SF_DEL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Deselect all the articles in a thread. */
end_comment

begin_function
name|void
name|deselect_thread
parameter_list|(
name|thread
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|deselect_subject
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Deselect everything. */
end_comment

begin_function
name|void
name|deselect_all
parameter_list|()
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|deselect_subject
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|selected_count
operator|=
name|selected_subj_cnt
operator|=
literal|0
expr_stmt|;
name|sel_page_sp
operator|=
literal|0
expr_stmt|;
name|sel_page_app
operator|=
literal|0
expr_stmt|;
name|sel_last_ap
operator|=
literal|0
expr_stmt|;
name|sel_last_sp
operator|=
literal|0
expr_stmt|;
name|selected_only
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill all unread articles attached to the given subject. */
end_comment

begin_function
name|void
name|kill_subject
parameter_list|(
name|subj
parameter_list|,
name|kill_flags
parameter_list|)
name|SUBJECT
modifier|*
name|subj
decl_stmt|;
name|int
name|kill_flags
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|killmask
init|=
operator|(
operator|(
name|kill_flags
operator|&
name|KF_ALL
operator|)
condition|?
name|AF_READ
else|:
operator|(
name|AF_READ
operator||
name|sel_mask
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|kill_flags
operator|&
name|KF_KILLFILE
condition|)
block|{
name|save_ids
operator|=
name|TRUE
expr_stmt|;
name|kill_flags
operator|=
name|AF_AUTOKILLALL
expr_stmt|;
block|}
else|else
name|kill_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|subj
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|killmask
operator|)
condition|)
name|set_read
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|flags
operator||=
name|kill_flags
expr_stmt|;
block|}
name|subj
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SF_VISIT
operator||
name|SF_WASSELECTED
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill all unread articles attached to the given thread. */
end_comment

begin_function
name|void
name|kill_thread
parameter_list|(
name|thread
parameter_list|,
name|kill_flags
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
name|int
name|kill_flags
decl_stmt|;
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|kill_subject
argument_list|(
name|sp
argument_list|,
name|kill_flags
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Kill the subthread attached to this article. */
end_comment

begin_function
name|void
name|kill_subthread
parameter_list|(
name|ap
parameter_list|,
name|kill_flags
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|kill_flags
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return;
for|for
control|(
name|limit
operator|=
name|ap
init|;
name|limit
condition|;
name|limit
operator|=
name|limit
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|limit
operator|->
name|sibling
condition|)
block|{
name|limit
operator|=
name|limit
operator|->
name|sibling
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|kill_flags
operator|&
name|KF_KILLFILE
condition|)
block|{
name|save_ids
operator|=
name|TRUE
expr_stmt|;
name|kill_flags
operator|=
name|AF_AUTOKILL
expr_stmt|;
block|}
else|else
name|kill_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|ap
operator|!=
name|limit
condition|;
name|ap
operator|=
name|bump_art
argument_list|(
name|ap
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_READ
operator||
name|AF_MISSING
operator|)
operator|)
condition|)
name|set_read
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|flags
operator||=
name|kill_flags
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Unkill all the articles attached to the given subject. */
end_comment

begin_function
name|void
name|unkill_subject
parameter_list|(
name|subj
parameter_list|)
name|SUBJECT
modifier|*
name|subj
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|subj
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
if|if
condition|(
name|sel_rereading
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_DELSEL
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_DELSEL
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|AF_READ
condition|)
name|toread
index|[
name|ng
index|]
operator|++
expr_stmt|;
name|ap
operator|->
name|flags
operator|=
operator|(
name|ap
operator|->
name|flags
operator|&
operator|~
operator|(
name|AF_DELSEL
operator||
name|AF_READ
operator|)
operator|)
operator||
name|AF_SEL
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|flags
operator|&=
operator|~
operator|(
name|AF_DEL
operator||
name|AF_DELSEL
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_READ
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_READ
condition|)
name|onemore
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected_only
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_SEL
operator||
name|AF_READ
operator|)
operator|)
condition|)
block|{
name|ap
operator|->
name|flags
operator|=
operator|(
name|ap
operator|->
name|flags
operator|&
operator|~
name|AF_DEL
operator|)
operator||
name|AF_SEL
expr_stmt|;
name|selected_count
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|sel_rereading
operator|&&
name|selected_only
operator|&&
operator|!
operator|(
name|subj
operator|->
name|flags
operator|&
name|SF_SEL
operator|)
condition|)
block|{
name|subj
operator|->
name|flags
operator||=
name|SF_SEL
operator||
name|SF_VISIT
operator||
name|SF_WASSELECTED
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|subj
operator|->
name|thread
operator|)
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
name|selected_subj_cnt
operator|++
expr_stmt|;
block|}
name|subj
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SF_DEL
operator||
name|SF_DELSEL
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unkill all the articles attached to the given thread. */
end_comment

begin_function
name|void
name|unkill_thread
parameter_list|(
name|thread
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|unkill_subject
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Unkill the subthread attached to this article. */
end_comment

begin_function
name|void
name|unkill_subthread
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|limit
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return;
for|for
control|(
name|limit
operator|=
name|ap
init|;
name|limit
condition|;
name|limit
operator|=
name|limit
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|limit
operator|->
name|sibling
condition|)
block|{
name|limit
operator|=
name|limit
operator|->
name|sibling
expr_stmt|;
break|break;
block|}
block|}
name|sp
operator|=
name|ap
operator|->
name|subj
expr_stmt|;
for|for
control|(
init|;
name|ap
operator|!=
name|limit
condition|;
name|ap
operator|=
name|bump_art
argument_list|(
name|ap
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_READ
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_READ
condition|)
name|onemore
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected_only
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
condition|)
block|{
name|ap
operator|->
name|flags
operator||=
name|AF_SEL
expr_stmt|;
name|selected_count
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|flags
operator|&
name|sel_mask
operator|)
condition|)
name|selected_subj_cnt
operator|++
expr_stmt|;
name|sp
operator|->
name|flags
operator|=
operator|(
name|sp
operator|->
name|flags
operator|&
operator|~
name|SF_DEL
operator|)
operator||
name|SF_SEL
operator||
name|SF_VISIT
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|sp
operator|->
name|thread
operator|)
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
name|selected_only
operator|=
operator|(
name|selected_only
operator|||
name|selected_count
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill all unread articles attached to the given subject. */
end_comment

begin_function
name|void
name|clear_subject
parameter_list|(
name|subj
parameter_list|)
name|SUBJECT
modifier|*
name|subj
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|subj
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_AUTOFLAGS
expr_stmt|;
block|}
name|subj
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SF_WASSELECTED
operator||
name|SF_AUTOSELECT
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill all unread articles attached to the given thread. */
end_comment

begin_function
name|void
name|clear_thread
parameter_list|(
name|thread
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|thread
decl_stmt|;
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|thread
operator|->
name|subj
expr_stmt|;
do|do
block|{
name|clear_subject
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
name|thread
operator|->
name|subj
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Kill the subthread attached to this article. */
end_comment

begin_function
name|void
name|clear_subthread
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return;
for|for
control|(
name|limit
operator|=
name|ap
init|;
name|limit
condition|;
name|limit
operator|=
name|limit
operator|->
name|parent
control|)
block|{
if|if
condition|(
name|limit
operator|->
name|sibling
condition|)
block|{
name|limit
operator|=
name|limit
operator|->
name|sibling
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
init|;
name|ap
operator|!=
name|limit
condition|;
name|ap
operator|=
name|bump_art
argument_list|(
name|ap
argument_list|)
control|)
block|{
name|ap
operator|->
name|flags
operator|&=
operator|~
name|AF_AUTOFLAGS
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ARTICLE
modifier|*
name|subj_art
parameter_list|(
name|sp
parameter_list|)
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|Nullart
decl_stmt|;
name|int
name|art_mask
init|=
operator|(
name|selected_only
condition|?
name|AF_SEL
else|:
literal|0
operator|)
decl_stmt|;
name|bool
name|TG_save
init|=
name|ThreadedGroup
decl_stmt|;
name|ThreadedGroup
operator|=
operator|(
name|sel_mode
operator|==
name|SM_THREAD
operator|)
expr_stmt|;
name|ap
operator|=
name|first_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ap
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|art_mask
operator||
name|AF_READ
operator|)
operator|)
operator|!=
name|art_mask
condition|)
name|ap
operator|=
name|next_art
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
block|{
name|reread
operator|=
name|TRUE
expr_stmt|;
name|ap
operator|=
name|first_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|art_mask
condition|)
block|{
while|while
condition|(
name|ap
operator|&&
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_SEL
operator|)
condition|)
name|ap
operator|=
name|next_art
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
name|ap
operator|=
name|first_art
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|ThreadedGroup
operator|=
name|TG_save
expr_stmt|;
return|return
name|ap
return|;
block|}
end_function

begin_comment
comment|/* Find the next thread (first if art> lastart).  If articles are selected, ** only choose from threads with selected articles. */
end_comment

begin_function
name|void
name|next_subject
parameter_list|()
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|sp
operator|=
operator|(
operator|(
name|ap
operator|=
name|artp
operator|)
condition|?
name|ap
operator|->
name|subj
operator|->
name|next
else|:
name|first_subject
operator|)
expr_stmt|;
for|for
control|(
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|SF_VISIT
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|subj_art
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
name|Nullart
condition|)
block|{
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|artp
operator|=
name|ap
expr_stmt|;
return|return;
block|}
name|reread
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|artp
operator|=
name|Nullart
expr_stmt|;
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|forcelast
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find previous thread (or last if artp == NULL).  If articles are selected, ** only choose from threads with selected articles. */
end_comment

begin_function
name|void
name|prev_subject
parameter_list|()
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|sp
operator|=
operator|(
operator|(
name|ap
operator|=
name|artp
operator|)
condition|?
name|ap
operator|->
name|subj
operator|->
name|prev
else|:
name|last_subject
operator|)
expr_stmt|;
for|for
control|(
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|SF_VISIT
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|subj_art
argument_list|(
name|sp
argument_list|)
operator|)
operator|!=
name|Nullart
condition|)
block|{
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|artp
operator|=
name|ap
expr_stmt|;
return|return;
block|}
name|reread
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|artp
operator|=
name|Nullart
expr_stmt|;
name|art
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
name|forcelast
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find artp's parent or oldest ancestor.  Returns FALSE if no such ** article.  Sets art and artp otherwise. */
end_comment

begin_function
name|bool
name|find_parent
parameter_list|(
name|keep_going
parameter_list|)
name|bool_int
name|keep_going
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|artp
decl_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|parent
condition|)
return|return
name|FALSE
return|;
do|do
block|{
name|ap
operator|=
name|ap
operator|->
name|parent
expr_stmt|;
block|}
do|while
condition|(
name|keep_going
operator|&&
name|ap
operator|->
name|parent
condition|)
do|;
if|if
condition|(
operator|(
operator|(
name|artp
operator|=
name|ap
operator|)
operator|->
name|flags
operator|&
name|AF_TMPMEM
operator|)
operator|==
name|AF_TMPMEM
condition|)
name|art
operator|=
literal|0
expr_stmt|;
else|else
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Find artp's first child or youngest decendent.  Returns FALSE if no ** such article.  Sets art and artp otherwise. */
end_comment

begin_function
name|bool
name|find_leaf
parameter_list|(
name|keep_going
parameter_list|)
name|bool_int
name|keep_going
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|ap
init|=
name|artp
decl_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|child1
condition|)
return|return
name|FALSE
return|;
do|do
block|{
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
block|}
do|while
condition|(
name|keep_going
operator|&&
name|ap
operator|->
name|child1
condition|)
do|;
if|if
condition|(
operator|(
operator|(
name|artp
operator|=
name|ap
operator|)
operator|->
name|flags
operator|&
name|AF_TMPMEM
operator|)
operator|==
name|AF_TMPMEM
condition|)
name|art
operator|=
literal|0
expr_stmt|;
else|else
name|art
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|ARTICLE
modifier|*
name|first_sib
argument_list|()
decl_stmt|,
modifier|*
name|last_sib
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the next "sibling" of artp, including cousins that are the ** same distance down the thread as we are.  Returns FALSE if no such ** article.  Sets art and artp otherwise. */
end_comment

begin_function
name|bool
name|find_next_sib
parameter_list|()
block|{
name|ARTICLE
modifier|*
name|ta
decl_stmt|,
modifier|*
name|tb
decl_stmt|;
name|int
name|ascent
decl_stmt|;
name|ascent
operator|=
literal|0
expr_stmt|;
name|ta
operator|=
name|artp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|ta
operator|->
name|sibling
condition|)
block|{
name|ta
operator|=
name|ta
operator|->
name|sibling
expr_stmt|;
if|if
condition|(
name|tb
operator|=
name|first_sib
argument_list|(
name|ta
argument_list|,
name|ascent
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|artp
operator|=
name|tb
operator|)
operator|->
name|flags
operator|&
name|AF_TMPMEM
operator|)
operator|==
name|AF_TMPMEM
condition|)
name|art
operator|=
literal|0
expr_stmt|;
else|else
name|art
operator|=
name|article_num
argument_list|(
name|tb
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ta
operator|=
name|ta
operator|->
name|parent
operator|)
condition|)
break|break;
name|ascent
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* A recursive routine to find the first node at the proper depth.  This ** article is at depth 0. */
end_comment

begin_function
specifier|static
name|ARTICLE
modifier|*
name|first_sib
parameter_list|(
name|ta
parameter_list|,
name|depth
parameter_list|)
name|ARTICLE
modifier|*
name|ta
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|ARTICLE
modifier|*
name|tb
decl_stmt|;
if|if
condition|(
operator|!
name|depth
condition|)
return|return
name|ta
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ta
operator|->
name|child1
operator|&&
operator|(
name|tb
operator|=
name|first_sib
argument_list|(
name|ta
operator|->
name|child1
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
operator|)
condition|)
return|return
name|tb
return|;
if|if
condition|(
operator|!
name|ta
operator|->
name|sibling
condition|)
return|return
name|Nullart
return|;
name|ta
operator|=
name|ta
operator|->
name|sibling
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the previous "sibling" of artp, including cousins that are ** the same distance down the thread as we are.  Returns FALSE if no ** such article.  Sets art and artp otherwise. */
end_comment

begin_function
name|bool
name|find_prev_sib
parameter_list|()
block|{
name|ARTICLE
modifier|*
name|ta
decl_stmt|,
modifier|*
name|tb
decl_stmt|;
name|int
name|ascent
decl_stmt|;
name|ascent
operator|=
literal|0
expr_stmt|;
name|ta
operator|=
name|artp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tb
operator|=
name|ta
expr_stmt|;
if|if
condition|(
name|ta
operator|->
name|parent
condition|)
name|ta
operator|=
name|ta
operator|->
name|parent
operator|->
name|child1
expr_stmt|;
else|else
name|ta
operator|=
name|ta
operator|->
name|subj
operator|->
name|thread
expr_stmt|;
if|if
condition|(
name|tb
operator|=
name|last_sib
argument_list|(
name|ta
argument_list|,
name|ascent
argument_list|,
name|tb
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|artp
operator|=
name|tb
operator|)
operator|->
name|flags
operator|&
name|AF_TMPMEM
operator|)
operator|==
name|AF_TMPMEM
condition|)
name|art
operator|=
literal|0
expr_stmt|;
else|else
name|art
operator|=
name|article_num
argument_list|(
name|tb
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|ta
operator|=
name|ta
operator|->
name|parent
operator|)
condition|)
break|break;
name|ascent
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* A recursive routine to find the last node at the proper depth.  This ** article is at depth 0. */
end_comment

begin_function
specifier|static
name|ARTICLE
modifier|*
name|last_sib
parameter_list|(
name|ta
parameter_list|,
name|depth
parameter_list|,
name|limit
parameter_list|)
name|ARTICLE
modifier|*
name|ta
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|ARTICLE
modifier|*
name|limit
decl_stmt|;
block|{
name|ARTICLE
modifier|*
name|tb
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
if|if
condition|(
name|ta
operator|==
name|limit
condition|)
return|return
name|Nullart
return|;
if|if
condition|(
name|ta
operator|->
name|sibling
condition|)
block|{
name|tc
operator|=
name|ta
operator|->
name|sibling
expr_stmt|;
if|if
condition|(
name|tc
operator|!=
name|limit
operator|&&
operator|(
name|tb
operator|=
name|last_sib
argument_list|(
name|tc
argument_list|,
name|depth
argument_list|,
name|limit
argument_list|)
operator|)
condition|)
return|return
name|tb
return|;
block|}
if|if
condition|(
operator|!
name|depth
condition|)
return|return
name|ta
return|;
if|if
condition|(
name|ta
operator|->
name|child1
condition|)
return|return
name|last_sib
argument_list|(
name|ta
operator|->
name|child1
argument_list|,
name|depth
operator|-
literal|1
argument_list|,
name|limit
argument_list|)
return|;
return|return
name|Nullart
return|;
block|}
end_function

begin_comment
comment|/* Get each subject's article count; count total articles and selected ** articles (use sel_rereading to determine whether to count read or ** unread articles); deselect any subjects we find that are empty if ** CS_UNSELECT or CS_UNSEL_STORE is specified.  If mode is CS_RESELECT ** is specified, the selections from the last CS_UNSEL_STORE are ** reselected. */
end_comment

begin_function
name|void
name|count_subjects
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|int
name|count
decl_stmt|,
name|sel_count
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
name|int
name|desired_flags
init|=
operator|(
name|sel_rereading
condition|?
name|AF_READ
else|:
literal|0
operator|)
decl_stmt|;
name|time_t
name|subjdate
decl_stmt|;
name|article_count
operator|=
name|selected_count
operator|=
name|selected_subj_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_cached
operator|>=
name|lastart
condition|)
name|firstart
operator|=
name|lastart
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|sp
operator|->
name|flags
operator|&=
operator|~
name|SF_VISIT
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|subjdate
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|sel_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|sp
operator|->
name|articles
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|subj_next
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_MISSING
operator||
name|AF_READ
operator|)
operator|)
operator|==
name|desired_flags
condition|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|sel_mask
condition|)
name|sel_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|subjdate
condition|)
name|subjdate
operator|=
name|ap
operator|->
name|date
expr_stmt|;
if|if
condition|(
name|article_num
argument_list|(
name|ap
argument_list|)
operator|<
name|firstart
condition|)
name|firstart
operator|=
name|article_num
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|CS_UNSEL_STORE
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|SF_SEL
condition|)
name|sp
operator|->
name|flags
operator||=
name|SF_OLDSEL
expr_stmt|;
else|else
name|sp
operator|->
name|flags
operator|&=
operator|~
name|SF_OLDSEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|CS_RESELECT
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|SF_OLDSEL
condition|)
name|sp
operator|->
name|flags
operator||=
name|SF_SEL
expr_stmt|;
else|else
name|sp
operator|->
name|flags
operator|&=
operator|~
name|SF_SEL
expr_stmt|;
block|}
name|sp
operator|->
name|misc
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|subjdate
condition|)
name|sp
operator|->
name|date
operator|=
name|subjdate
expr_stmt|;
name|article_count
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|sel_count
condition|)
block|{
name|sp
operator|->
name|flags
operator|=
operator|(
name|sp
operator|->
name|flags
operator|&
operator|~
operator|(
name|SF_SEL
operator||
name|SF_DEL
operator|)
operator|)
operator||
name|sel_mask
expr_stmt|;
name|selected_count
operator|+=
name|sel_count
expr_stmt|;
name|selected_subj_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|>=
name|CS_UNSELECT
condition|)
name|sp
operator|->
name|flags
operator|&=
operator|~
name|sel_mask
expr_stmt|;
elseif|else
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|sel_mask
condition|)
block|{
name|sp
operator|->
name|flags
operator|&=
operator|~
name|SF_DEL
expr_stmt|;
name|selected_subj_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&&
operator|(
operator|!
name|selected_only
operator|||
operator|(
name|sp
operator|->
name|flags
operator|&
name|sel_mask
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|=
name|sp
operator|->
name|thread
operator|)
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mode
operator|&&
operator|!
name|article_count
operator|&&
operator|!
name|selected_only
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|sp
operator|->
name|flags
operator||=
name|SF_VISIT
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|subjorder_subject
parameter_list|(
name|spp1
parameter_list|,
name|spp2
parameter_list|)
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|spp1
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|spp2
decl_stmt|;
block|{
return|return
name|strCASEcmp
argument_list|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|str
operator|+
literal|4
argument_list|,
operator|(
operator|*
name|spp2
operator|)
operator|->
name|str
operator|+
literal|4
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|subjorder_date
parameter_list|(
name|spp1
parameter_list|,
name|spp2
parameter_list|)
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|spp1
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|spp2
decl_stmt|;
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|spp2
operator|)
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|subjorder_count
parameter_list|(
name|spp1
parameter_list|,
name|spp2
parameter_list|)
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|spp1
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|spp2
decl_stmt|;
block|{
name|int
name|eq
decl_stmt|;
if|if
condition|(
operator|(
name|eq
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|misc
operator|-
operator|(
operator|*
name|spp2
operator|)
operator|->
name|misc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|eq
operator|*
name|sel_direction
return|;
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|spp2
operator|)
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|threadorder_subject
parameter_list|(
name|spp1
parameter_list|,
name|spp2
parameter_list|)
name|SUBJECT
modifier|*
modifier|*
name|spp1
decl_stmt|;
name|SUBJECT
modifier|*
modifier|*
name|spp2
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|t1
init|=
operator|(
operator|*
name|spp1
operator|)
operator|->
name|thread
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|t2
init|=
operator|(
operator|*
name|spp2
operator|)
operator|->
name|thread
decl_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
operator|&&
name|t1
operator|&&
name|t2
condition|)
return|return
name|strCASEcmp
argument_list|(
name|t1
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|,
name|t2
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|)
operator|*
name|sel_direction
return|;
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|spp2
operator|)
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|threadorder_date
parameter_list|(
name|spp1
parameter_list|,
name|spp2
parameter_list|)
name|SUBJECT
modifier|*
modifier|*
name|spp1
decl_stmt|;
name|SUBJECT
modifier|*
modifier|*
name|spp2
decl_stmt|;
block|{
specifier|register
name|ARTICLE
modifier|*
name|t1
init|=
operator|(
operator|*
name|spp1
operator|)
operator|->
name|thread
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|t2
init|=
operator|(
operator|*
name|spp2
operator|)
operator|->
name|thread
decl_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
operator|&&
name|t1
operator|&&
name|t2
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|sp2
decl_stmt|;
name|int
name|eq
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp1
operator|=
name|t1
operator|->
name|subj
operator|)
operator|->
name|misc
condition|)
for|for
control|(
name|sp1
operator|=
name|sp1
operator|->
name|thread_link
init|;
name|sp1
operator|!=
name|t1
operator|->
name|subj
condition|;
name|sp1
operator|=
name|sp1
operator|->
name|thread_link
control|)
if|if
condition|(
name|sp1
operator|->
name|misc
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|sp2
operator|=
name|t2
operator|->
name|subj
operator|)
operator|->
name|misc
condition|)
for|for
control|(
name|sp2
operator|=
name|sp2
operator|->
name|thread_link
init|;
name|sp2
operator|!=
name|t2
operator|->
name|subj
condition|;
name|sp2
operator|=
name|sp2
operator|->
name|thread_link
control|)
if|if
condition|(
name|sp2
operator|->
name|misc
condition|)
break|break;
if|if
condition|(
operator|(
name|eq
operator|=
call|(
name|int
call|)
argument_list|(
name|sp1
operator|->
name|date
operator|-
name|sp2
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
operator|)
operator|!=
literal|0
condition|)
return|return
name|eq
return|;
return|return
name|strCASEcmp
argument_list|(
name|sp1
operator|->
name|str
operator|+
literal|4
argument_list|,
name|sp2
operator|->
name|str
operator|+
literal|4
argument_list|)
operator|*
name|sel_direction
return|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|spp2
operator|)
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|threadorder_count
parameter_list|(
name|spp1
parameter_list|,
name|spp2
parameter_list|)
name|SUBJECT
modifier|*
modifier|*
name|spp1
decl_stmt|;
name|SUBJECT
modifier|*
modifier|*
name|spp2
decl_stmt|;
block|{
specifier|register
name|int
name|size1
init|=
operator|(
operator|*
name|spp1
operator|)
operator|->
name|misc
decl_stmt|;
specifier|register
name|int
name|size2
init|=
operator|(
operator|*
name|spp2
operator|)
operator|->
name|misc
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|spp1
operator|)
operator|->
name|thread
operator|!=
operator|(
operator|*
name|spp2
operator|)
operator|->
name|thread
condition|)
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
operator|(
operator|*
name|spp1
operator|)
operator|->
name|thread_link
init|;
name|sp
operator|!=
operator|*
name|spp1
condition|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
control|)
name|size1
operator|+=
name|sp
operator|->
name|misc
expr_stmt|;
for|for
control|(
name|sp
operator|=
operator|(
operator|*
name|spp2
operator|)
operator|->
name|thread_link
init|;
name|sp
operator|!=
operator|*
name|spp2
condition|;
name|sp
operator|=
name|sp
operator|->
name|thread_link
control|)
name|size2
operator|+=
name|sp
operator|->
name|misc
expr_stmt|;
block|}
if|if
condition|(
name|size1
operator|!=
name|size2
condition|)
return|return
operator|(
name|size1
operator|-
name|size2
operator|)
operator|*
name|sel_direction
return|;
return|return
name|threadorder_date
argument_list|(
name|spp1
argument_list|,
name|spp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the subjects according to the chosen order. */
end_comment

begin_function
name|void
name|sort_subjects
parameter_list|()
block|{
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|SUBJECT
modifier|*
modifier|*
name|lp
decl_stmt|,
modifier|*
modifier|*
name|subj_list
decl_stmt|;
name|int
function_decl|(
modifier|*
name|sort_procedure
function_decl|)
parameter_list|()
function_decl|;
comment|/* If we don't have at least two subjects, we're done! */
if|if
condition|(
operator|!
name|first_subject
operator|||
operator|!
name|first_subject
operator|->
name|next
condition|)
return|return;
switch|switch
condition|(
name|sel_sort
condition|)
block|{
case|case
name|SS_DATE
case|:
case|case
name|SS_AUTHOR
case|:
case|case
name|SS_GROUPS
case|:
name|sort_procedure
operator|=
operator|(
name|sel_mode
operator|==
name|SM_THREAD
condition|?
name|threadorder_date
else|:
name|subjorder_date
operator|)
expr_stmt|;
break|break;
case|case
name|SS_SUBJECT
case|:
name|sort_procedure
operator|=
operator|(
name|sel_mode
operator|==
name|SM_THREAD
condition|?
name|threadorder_subject
else|:
name|subjorder_subject
operator|)
expr_stmt|;
break|break;
case|case
name|SS_COUNT
case|:
name|sort_procedure
operator|=
operator|(
name|sel_mode
operator|==
name|SM_THREAD
condition|?
name|threadorder_count
else|:
name|subjorder_count
operator|)
expr_stmt|;
break|break;
block|}
name|subj_list
operator|=
operator|(
name|SUBJECT
operator|*
operator|*
operator|)
name|safemalloc
argument_list|(
name|subject_count
operator|*
sizeof|sizeof
argument_list|(
name|SUBJECT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|subj_list
operator|,
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
operator|*
name|lp
operator|++
operator|=
name|sp
expr_stmt|;
name|assert
argument_list|(
name|lp
operator|-
name|subj_list
operator|==
name|subject_count
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|subj_list
argument_list|,
name|subject_count
argument_list|,
sizeof|sizeof
argument_list|(
name|SUBJECT
operator|*
argument_list|)
argument_list|,
name|sort_procedure
argument_list|)
expr_stmt|;
name|first_subject
operator|=
name|sp
operator|=
name|subj_list
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|prev
operator|=
name|Nullsubj
expr_stmt|;
for|for
control|(
name|i
operator|=
name|subject_count
operator|,
name|lp
operator|=
name|subj_list
init|;
operator|--
name|i
condition|;
name|lp
operator|++
control|)
block|{
name|lp
index|[
literal|0
index|]
operator|->
name|next
operator|=
name|lp
index|[
literal|1
index|]
expr_stmt|;
name|lp
index|[
literal|1
index|]
operator|->
name|prev
operator|=
name|lp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
block|{
if|if
condition|(
name|lp
index|[
literal|0
index|]
operator|->
name|thread
operator|==
name|lp
index|[
literal|1
index|]
operator|->
name|thread
condition|)
name|lp
index|[
literal|0
index|]
operator|->
name|thread_link
operator|=
name|lp
index|[
literal|1
index|]
expr_stmt|;
else|else
block|{
name|lp
index|[
literal|0
index|]
operator|->
name|thread_link
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|lp
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
block|}
name|last_subject
operator|=
name|lp
index|[
literal|0
index|]
expr_stmt|;
name|last_subject
operator|->
name|next
operator|=
name|Nullsubj
expr_stmt|;
if|if
condition|(
name|sel_mode
operator|==
name|SM_THREAD
condition|)
name|last_subject
operator|->
name|thread_link
operator|=
name|sp
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subj_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|artorder_date
parameter_list|(
name|art1
parameter_list|,
name|art2
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art1
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art2
decl_stmt|;
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|art2
operator|)
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|artorder_subject
parameter_list|(
name|art1
parameter_list|,
name|art2
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art1
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art2
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|subj
operator|==
operator|(
operator|*
name|art2
operator|)
operator|->
name|subj
condition|)
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|art2
operator|)
operator|->
name|date
argument_list|)
return|;
return|return
name|strCASEcmp
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|,
operator|(
operator|*
name|art2
operator|)
operator|->
name|subj
operator|->
name|str
operator|+
literal|4
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_function
name|int
name|artorder_author
parameter_list|(
name|art1
parameter_list|,
name|art2
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art1
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art2
decl_stmt|;
block|{
name|int
name|eq
decl_stmt|;
if|if
condition|(
operator|(
name|eq
operator|=
name|strCASEcmp
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|from
argument_list|,
operator|(
operator|*
name|art2
operator|)
operator|->
name|from
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|eq
operator|*
name|sel_direction
return|;
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|art2
operator|)
operator|->
name|date
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|artorder_groups
parameter_list|(
name|art1
parameter_list|,
name|art2
parameter_list|)
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art1
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
modifier|*
name|art2
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|subj
operator|==
operator|(
operator|*
name|art2
operator|)
operator|->
name|subj
condition|)
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|date
operator|-
operator|(
operator|*
name|art2
operator|)
operator|->
name|date
argument_list|)
return|;
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|*
name|art1
operator|)
operator|->
name|subj
operator|->
name|date
operator|-
operator|(
operator|*
name|art2
operator|)
operator|->
name|subj
operator|->
name|date
argument_list|)
operator|*
name|sel_direction
return|;
block|}
end_function

begin_comment
comment|/* Sort the articles according to the chosen order. */
end_comment

begin_function
name|void
name|sort_articles
parameter_list|()
block|{
name|int
function_decl|(
modifier|*
name|sort_procedure
function_decl|)
parameter_list|()
function_decl|;
name|build_artptrs
argument_list|()
expr_stmt|;
comment|/* If we don't have at least two articles, we're done! */
if|if
condition|(
name|article_count
operator|<
literal|2
condition|)
return|return;
switch|switch
condition|(
name|sel_sort
condition|)
block|{
case|case
name|SS_DATE
case|:
case|case
name|SS_COUNT
case|:
name|sort_procedure
operator|=
name|artorder_date
expr_stmt|;
break|break;
case|case
name|SS_SUBJECT
case|:
name|sort_procedure
operator|=
name|artorder_subject
expr_stmt|;
break|break;
case|case
name|SS_AUTHOR
case|:
name|sort_procedure
operator|=
name|artorder_author
expr_stmt|;
break|break;
case|case
name|SS_GROUPS
case|:
name|sort_procedure
operator|=
name|artorder_groups
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sel_page_app
condition|)
name|sel_last_ap
operator|=
operator|*
name|sel_page_app
expr_stmt|;
name|sel_page_app
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
name|artptr_list
argument_list|,
name|article_count
argument_list|,
sizeof|sizeof
argument_list|(
name|ARTICLE
operator|*
argument_list|)
argument_list|,
name|sort_procedure
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|long
name|artptr_list_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|build_artptrs
parameter_list|()
block|{
name|ARTICLE
modifier|*
modifier|*
name|app
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|long
name|count
init|=
name|article_count
decl_stmt|;
name|int
name|desired_flags
init|=
operator|(
name|sel_rereading
condition|?
name|AF_READ
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|artptr_list
operator|||
name|artptr_list_size
operator|!=
name|count
condition|)
block|{
name|artptr_list
operator|=
operator|(
name|ARTICLE
operator|*
operator|*
operator|)
name|saferealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|artptr_list
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ARTICLE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|artptr_list_size
operator|=
name|count
expr_stmt|;
block|}
for|for
control|(
name|app
operator|=
name|artptr_list
operator|,
name|ap
operator|=
name|article_list
init|;
name|count
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_MISSING
operator||
name|AF_READ
operator|)
operator|)
operator|==
name|desired_flags
condition|)
block|{
operator|*
name|app
operator|++
operator|=
name|ap
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

