begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id: rt-mt.c,v 3.0 1992/12/14 00:14:13 davison Trn $ */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"trn.h"
end_include

begin_include
include|#
directive|include
file|"cache.h"
end_include

begin_include
include|#
directive|include
file|"bits.h"
end_include

begin_include
include|#
directive|include
file|"ng.h"
end_include

begin_include
include|#
directive|include
file|"ngdata.h"
end_include

begin_include
include|#
directive|include
file|"rcln.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"rthread.h"
end_include

begin_include
include|#
directive|include
file|"rt-process.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MT
end_ifdef

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"rt-mt.h"
end_include

begin_decl_stmt
specifier|extern
name|HASHTABLE
modifier|*
name|msgid_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|bool
name|try_mt
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USE_XTHREAD
end_ifndef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool
name|word_same
decl_stmt|,
name|long_same
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BMAP
name|my_bmap
decl_stmt|,
name|mt_bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strings
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WORD
modifier|*
name|author_cnts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|WORD
modifier|*
name|ids
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ARTICLE
modifier|*
modifier|*
name|article_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SUBJECT
modifier|*
modifier|*
name|subject_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|author_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|TOTAL
name|total
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PACKED_ROOT
name|p_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PACKED_ARTICLE
name|p_article
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize our thread code by determining the byte-order of the thread ** files and our own current byte-order.  If they differ, set flags to let ** the read code know what we'll need to translate. */
end_comment

begin_function
name|bool
name|mt_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_XTHREAD
name|long
name|size
decl_stmt|;
endif|#
directive|endif
name|bool
name|success
init|=
name|TRUE
decl_stmt|;
comment|/* I'm an optimist */
name|word_same
operator|=
name|long_same
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_XTHREAD
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"XTHREAD DBINIT"
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
name|size
operator|=
name|nntp_readcheck
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|size
operator|=
name|nntp_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mt_bmap
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|BMAP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|BMAP
argument_list|)
operator|-
literal|1
condition|)
block|{
else|#
directive|else
comment|/* !USE_XTHREAD */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|DBINIT
argument_list|)
argument_list|,
name|FOPEN_RB
argument_list|)
operator|)
operator|!=
name|Nullfp
operator|&&
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mt_bmap
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BMAP
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|BMAP
argument_list|)
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|mt_bmap
operator|.
name|version
operator|!=
name|DB_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"\nMthreads database is the wrong version -- ignoring it.\n"
argument_list|)
name|FLUSH
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|mybytemap
argument_list|(
operator|&
name|my_bmap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|)
block|{
if|if
condition|(
name|my_bmap
operator|.
name|w
index|[
name|i
index|]
operator|!=
name|mt_bmap
operator|.
name|w
index|[
name|i
index|]
condition|)
block|{
name|word_same
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|my_bmap
operator|.
name|l
index|[
name|i
index|]
operator|!=
name|mt_bmap
operator|.
name|l
index|[
name|i
index|]
condition|)
block|{
name|long_same
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
else|else
name|success
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_XTHREAD
while|while
condition|(
name|nntp_read
argument_list|(
name|ser_line
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
name|ser_line
argument_list|)
condition|)
empty_stmt|;
comment|/* trash any extraneous bytes */
else|#
directive|else
if|if
condition|(
name|fp
operator|!=
name|Nullfp
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|success
return|;
block|}
comment|/* Open and process the data in the group's thread file.  Returns TRUE unless ** we discovered a bogus thread file, destroyed the cache, and re-built it. */
name|bool
name|mt_data
parameter_list|()
block|{
name|bool
name|success
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_XTHREAD
comment|/* use remote thread file? */
name|long
name|size
decl_stmt|;
name|sprintf
argument_list|(
name|ser_line
argument_list|,
literal|"XTHREAD THREAD"
argument_list|)
expr_stmt|;
name|nntp_command
argument_list|(
name|ser_line
argument_list|)
expr_stmt|;
name|size
operator|=
name|nntp_readcheck
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
name|TRUE
return|;
name|printf
argument_list|(
literal|"\nGetting thread file."
argument_list|)
operator|,
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nntp_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|total
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|TOTAL
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|TOTAL
argument_list|)
condition|)
goto|goto
name|exit
goto|;
else|#
directive|else
comment|/* !USE_XTHREAD */
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|mt_name
argument_list|(
name|ngname
argument_list|)
argument_list|,
name|FOPEN_RB
argument_list|)
operator|)
operator|==
name|Nullfp
condition|)
return|return
name|TRUE
return|;
name|printf
argument_list|(
literal|"\nReading thread file."
argument_list|)
operator|,
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|total
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|TOTAL
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|TOTAL
argument_list|)
condition|)
goto|goto
name|exit
goto|;
endif|#
directive|endif
comment|/* !USE_XTHREAD */
name|lp_bmap
argument_list|(
operator|&
name|total
operator|.
name|first
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wp_bmap
argument_list|(
operator|&
name|total
operator|.
name|root
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|total
operator|.
name|root
condition|)
block|{
name|tweak_data
argument_list|()
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|total
operator|.
name|last
operator|>
name|lastart
condition|)
name|grow_cache
argument_list|(
name|total
operator|.
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_authors
argument_list|()
operator|&&
name|read_subjects
argument_list|()
operator|&&
name|read_roots
argument_list|()
operator|&&
name|read_articles
argument_list|()
operator|&&
name|read_ids
argument_list|()
condition|)
block|{
name|tweak_data
argument_list|()
expr_stmt|;
name|first_cached
operator|=
name|absfirst
expr_stmt|;
name|last_cached
operator|=
operator|(
name|total
operator|.
name|last
operator|<
name|absfirst
condition|?
name|absfirst
operator|-
literal|1
else|:
name|total
operator|.
name|last
operator|)
expr_stmt|;
name|cached_all_in_range
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* Something failed.  Safefree takes care of checking if some items     ** were already freed.  Any partially-allocated structures were freed     ** before we got here.  All other structures are cleaned up now.     */
name|close_cache
argument_list|()
expr_stmt|;
name|safefree
argument_list|(
operator|&
name|strings
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|article_array
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|subject_array
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|author_array
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ids
argument_list|)
expr_stmt|;
name|try_mt
operator|=
name|FALSE
expr_stmt|;
name|build_cache
argument_list|()
expr_stmt|;
name|try_mt
operator|=
name|TRUE
expr_stmt|;
name|success
operator|=
name|FALSE
expr_stmt|;
name|exit
label|:
ifdef|#
directive|ifdef
name|USE_XTHREAD
while|while
condition|(
name|nntp_read
argument_list|(
name|ser_line
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
name|ser_line
argument_list|)
condition|)
empty_stmt|;
comment|/* trash any extraneous bytes */
else|#
directive|else
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|success
return|;
block|}
ifndef|#
directive|ifndef
name|USE_XTHREAD
comment|/* Change a newsgroup name into the name of the thread data file.  We ** subsitute any '.'s in the group name into '/'s (unless LONG_THREAD_NAMES ** is defined), prepend the path, and append the '/.thread' or '.th' on to ** the end. */
specifier|static
name|char
modifier|*
name|mt_name
parameter_list|(
name|group
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|LONG_THREAD_NAMES
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|threaddir
argument_list|,
name|group
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|strcpy
argument_list|(
name|buf
argument_list|,
name|threaddir
argument_list|)
operator|+
name|strlen
argument_list|(
name|threaddir
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|group
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|threaddir
operator|==
name|spool
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/.thread"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|".th"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
endif|#
directive|endif
specifier|static
name|char
modifier|*
name|subject_strings
decl_stmt|,
modifier|*
name|string_end
decl_stmt|;
comment|/* The author information is an array of use-counts, followed by all the ** null-terminated strings crammed together.  The subject strings are read ** in at the same time, since they are appended to the end of the author ** strings. */
specifier|static
name|int
name|read_authors
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|string_ptr
decl_stmt|,
modifier|*
modifier|*
name|author_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|read_item
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|author_cnts
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|total
operator|.
name|author
operator|*
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|author_cnts
argument_list|)
expr_stmt|;
comment|/* we don't need these */
if|if
condition|(
operator|!
name|read_item
argument_list|(
operator|&
name|strings
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|total
operator|.
name|string1
argument_list|)
condition|)
return|return
literal|0
return|;
name|string_ptr
operator|=
name|strings
expr_stmt|;
name|string_end
operator|=
name|string_ptr
operator|+
name|total
operator|.
name|string1
expr_stmt|;
if|if
condition|(
name|string_end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/*error("first string table is invalid.\n");*/
return|return
literal|0
return|;
block|}
comment|/* We'll use this array to point each article at its proper author     ** (the packed values were saved as indexes).     */
name|author_array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|safemalloc
argument_list|(
name|total
operator|.
name|author
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|author_ptr
operator|=
name|author_array
expr_stmt|;
for|for
control|(
name|count
operator|=
name|total
operator|.
name|author
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|string_ptr
operator|>=
name|string_end
condition|)
break|break;
operator|*
name|author_ptr
operator|++
operator|=
name|string_ptr
expr_stmt|;
name|string_ptr
operator|+=
name|strlen
argument_list|(
name|string_ptr
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|subject_strings
operator|=
name|string_ptr
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
comment|/*error("author unpacking failed.\n");*/
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* The subject values consist of the crammed-together null-terminated strings ** (already read in above) and the use-count array.  They were saved in the ** order that the roots require while being unpacked. */
specifier|static
name|int
name|read_subjects
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|string_ptr
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|subj_ptr
decl_stmt|;
name|WORD
modifier|*
name|subject_cnts
decl_stmt|;
if|if
condition|(
operator|!
name|read_item
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|subject_cnts
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|total
operator|.
name|subject
operator|*
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
argument_list|)
condition|)
block|{
comment|/* (Error already logged.) */
return|return
literal|0
return|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subject_cnts
argument_list|)
expr_stmt|;
comment|/* we don't need these */
comment|/* Use this array when unpacking the article's subject offset. */
name|subject_array
operator|=
operator|(
name|SUBJECT
operator|*
operator|*
operator|)
name|safemalloc
argument_list|(
name|total
operator|.
name|subject
operator|*
sizeof|sizeof
argument_list|(
name|SUBJECT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subj_ptr
operator|=
name|subject_array
expr_stmt|;
name|string_ptr
operator|=
name|subject_strings
expr_stmt|;
comment|/* string_end is already set */
for|for
control|(
name|count
operator|=
name|total
operator|.
name|subject
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
name|int
name|len
decl_stmt|;
name|ARTICLE
name|arty
decl_stmt|;
if|if
condition|(
name|string_ptr
operator|>=
name|string_end
condition|)
break|break;
name|len
operator|=
name|strlen
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
name|arty
operator|.
name|subj
operator|=
literal|0
expr_stmt|;
name|set_subj_line
argument_list|(
operator|&
name|arty
argument_list|,
name|string_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|72
condition|)
name|arty
operator|.
name|subj
operator|->
name|flags
operator||=
name|SF_SUBJTRUNCED
expr_stmt|;
name|string_ptr
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
operator|*
name|subj_ptr
operator|++
operator|=
name|arty
operator|.
name|subj
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|||
name|string_ptr
operator|!=
name|string_end
condition|)
block|{
comment|/*error("subject data is invalid.\n");*/
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/* Read in the packed root structures to set each subject's thread article ** offset.  This gets turned into a real pointer later. */
specifier|static
name|int
name|read_roots
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
modifier|*
name|subj_ptr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|subj_ptr
operator|=
name|subject_array
expr_stmt|;
for|for
control|(
name|count
operator|=
name|total
operator|.
name|root
init|;
name|count
operator|--
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|USE_XTHREAD
name|ret
operator|=
name|nntp_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p_root
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|PACKED_ROOT
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p_root
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PACKED_ROOT
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|!=
sizeof|sizeof
argument_list|(
name|PACKED_ROOT
argument_list|)
condition|)
block|{
comment|/*error("failed root read -- %d bytes instead of %d.\n", 		ret, sizeof (PACKED_ROOT));*/
return|return
literal|0
return|;
block|}
name|wp_bmap
argument_list|(
operator|&
name|p_root
operator|.
name|articles
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* converts subject_cnt too */
if|if
condition|(
name|p_root
operator|.
name|articles
operator|<
literal|0
operator|||
name|p_root
operator|.
name|articles
operator|>=
name|total
operator|.
name|article
condition|)
block|{
comment|/*error("root has invalid values.\n");*/
return|return
literal|0
return|;
block|}
name|i
operator|=
name|p_root
operator|.
name|subject_cnt
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
operator|(
name|subj_ptr
operator|-
name|subject_array
operator|)
operator|+
name|i
operator|>
name|total
operator|.
name|subject
condition|)
block|{
comment|/*error("root has invalid values.\n");*/
return|return
literal|0
return|;
block|}
name|subj_ptr
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|thread_link
operator|=
name|subj_ptr
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
union|union
block|{
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
name|uni
union|;
if|if
condition|(
name|i
condition|)
name|subj_ptr
index|[
literal|0
index|]
operator|->
name|thread_link
operator|=
name|subj_ptr
index|[
literal|1
index|]
expr_stmt|;
name|subj_ptr
index|[
literal|0
index|]
operator|->
name|flags
operator|&=
operator|~
name|SF_THREAD
expr_stmt|;
name|uni
operator|.
name|num
operator|=
name|p_root
operator|.
name|articles
expr_stmt|;
operator|(
operator|*
name|subj_ptr
operator|++
operator|)
operator|->
name|thread
operator|=
name|uni
operator|.
name|ap
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
specifier|static
name|bool
name|invalid_data
decl_stmt|;
comment|/* A simple routine that checks the validity of the article's subject value. ** A -1 means that it is NULL, otherwise it should be an offset into the ** subject array we just unpacked. */
specifier|static
name|SUBJECT
modifier|*
name|the_subject
parameter_list|(
name|num
parameter_list|)
name|WORD
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|==
operator|-
literal|1
condition|)
return|return
name|Nullsubj
return|;
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>=
name|total
operator|.
name|subject
condition|)
block|{
comment|/*printf("Invalid subject in thread file: %d [%ld]\n", num, art_num);*/
name|invalid_data
operator|=
name|TRUE
expr_stmt|;
return|return
name|Nullsubj
return|;
block|}
return|return
name|subject_array
index|[
name|num
index|]
return|;
block|}
comment|/* Ditto for author checking. */
specifier|static
name|char
modifier|*
name|the_author
parameter_list|(
name|num
parameter_list|)
name|WORD
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|==
operator|-
literal|1
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>=
name|total
operator|.
name|author
condition|)
block|{
comment|/*error("invalid author in thread file: %d [%ld]\n", num, art_num);*/
name|invalid_data
operator|=
name|TRUE
expr_stmt|;
return|return
name|Nullch
return|;
block|}
return|return
name|savestr
argument_list|(
name|author_array
index|[
name|num
index|]
argument_list|)
return|;
block|}
comment|/* Our parent/sibling information is a relative offset in the article array. ** zero for none.  Child values are always found in the very next array ** element if child_cnt is non-zero. */
specifier|static
name|ARTICLE
modifier|*
name|the_article
parameter_list|(
name|relative_offset
parameter_list|,
name|num
parameter_list|)
name|WORD
name|relative_offset
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
union|union
block|{
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
name|uni
union|;
if|if
condition|(
operator|!
name|relative_offset
condition|)
return|return
name|Nullart
return|;
name|num
operator|+=
name|relative_offset
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>=
name|total
operator|.
name|article
condition|)
block|{
comment|/*error("invalid article offset in thread file.\n");*/
name|invalid_data
operator|=
name|TRUE
expr_stmt|;
return|return
name|Nullart
return|;
block|}
name|uni
operator|.
name|num
operator|=
name|num
operator|+
literal|1
expr_stmt|;
return|return
name|uni
operator|.
name|ap
return|;
comment|/* slip them an offset in disguise */
block|}
comment|/* Read the articles into their trees.  Point everything everywhere. */
specifier|static
name|int
name|read_articles
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|article
decl_stmt|,
modifier|*
modifier|*
name|art_ptr
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Build an array to interpret interlinkages of articles. */
name|article_array
operator|=
operator|(
name|ARTICLE
operator|*
operator|*
operator|)
name|safemalloc
argument_list|(
name|total
operator|.
name|article
operator|*
sizeof|sizeof
argument_list|(
name|ARTICLE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|art_ptr
operator|=
name|article_array
expr_stmt|;
name|invalid_data
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|total
operator|.
name|article
condition|;
name|count
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|USE_XTHREAD
name|ret
operator|=
name|nntp_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p_article
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|PACKED_ARTICLE
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p_article
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|PACKED_ARTICLE
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|!=
sizeof|sizeof
argument_list|(
name|PACKED_ARTICLE
argument_list|)
condition|)
block|{
comment|/*error("failed article read -- %d bytes instead of %d.\n", 		ret, sizeof (PACKED_ARTICLE));*/
return|return
literal|0
return|;
block|}
name|lp_bmap
argument_list|(
operator|&
name|p_article
operator|.
name|num
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wp_bmap
argument_list|(
operator|&
name|p_article
operator|.
name|subject
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|article
operator|=
operator|*
name|art_ptr
operator|++
operator|=
name|allocate_article
argument_list|(
name|p_article
operator|.
name|num
argument_list|)
expr_stmt|;
name|article
operator|->
name|date
operator|=
name|p_article
operator|.
name|date
expr_stmt|;
ifndef|#
directive|ifndef
name|DBM_XREFS
if|if
condition|(
name|olden_days
operator|<
literal|2
operator|&&
operator|!
operator|(
name|p_article
operator|.
name|flags
operator|&
name|HAS_XREFS
operator|)
condition|)
name|article
operator|->
name|xrefs
operator|=
name|nullstr
expr_stmt|;
endif|#
directive|endif
name|article
operator|->
name|from
operator|=
name|the_author
argument_list|(
name|p_article
operator|.
name|author
argument_list|)
expr_stmt|;
name|article
operator|->
name|parent
operator|=
name|the_article
argument_list|(
name|p_article
operator|.
name|parent
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|article
operator|->
name|child1
operator|=
name|the_article
argument_list|(
name|p_article
operator|.
name|child_cnt
condition|?
literal|1
else|:
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|article
operator|->
name|sibling
operator|=
name|the_article
argument_list|(
name|p_article
operator|.
name|sibling
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|article
operator|->
name|subj
operator|=
name|the_subject
argument_list|(
name|p_article
operator|.
name|subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalid_data
condition|)
block|{
comment|/* (Error already logged.) */
return|return
literal|0
return|;
block|}
comment|/* This is ok because parent articles precede their children */
if|if
condition|(
name|article
operator|->
name|parent
condition|)
block|{
union|union
block|{
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
name|uni
union|;
name|uni
operator|.
name|ap
operator|=
name|article
operator|->
name|parent
expr_stmt|;
name|article
operator|->
name|parent
operator|=
name|article_array
index|[
name|uni
operator|.
name|num
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|article
operator|->
name|subj
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
block|{
name|article
operator|->
name|flags
operator||=
name|AF_FROMTRUNCED
operator||
name|AF_THREADED
operator||
operator|(
operator|(
name|p_article
operator|.
name|flags
operator|&
name|ROOT_ARTICLE
operator|)
condition|?
literal|0
else|:
name|AF_HAS_RE
operator|)
expr_stmt|;
block|}
comment|/* Give this subject to any faked parent articles */
while|while
condition|(
name|article
operator|->
name|parent
operator|&&
operator|!
name|article
operator|->
name|parent
operator|->
name|subj
condition|)
block|{
name|article
operator|->
name|parent
operator|->
name|subj
operator|=
name|article
operator|->
name|subj
expr_stmt|;
name|article
operator|=
name|article
operator|->
name|parent
expr_stmt|;
block|}
block|}
else|else
name|article
operator|->
name|flags
operator||=
name|AF_FAKE
expr_stmt|;
block|}
comment|/* We're done with most of the pointer arrays at this point. */
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|subject_array
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|author_array
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|&
name|strings
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Read the message-id strings and attach them to each article.  The data ** format consists of the mushed-together null-terminated strings (a domain ** name followed by all its unique-id prefixes) and then the article offsets ** to which they belong.  The first domain name was omitted, as it is a null ** domain for those truly weird message-id's without '@'s. */
specifier|static
name|int
name|read_ids
parameter_list|()
block|{
specifier|register
name|ARTICLE
modifier|*
name|article
decl_stmt|;
specifier|register
name|char
modifier|*
name|string_ptr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|len
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
operator|!
name|read_item
argument_list|(
operator|&
name|strings
argument_list|,
operator|(
name|MEM_SIZE
operator|)
name|total
operator|.
name|string2
argument_list|)
operator|||
operator|!
name|read_item
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ids
argument_list|,
call|(
name|MEM_SIZE
call|)
argument_list|(
name|total
operator|.
name|article
operator|+
name|total
operator|.
name|domain
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|wp_bmap
argument_list|(
name|ids
argument_list|,
name|total
operator|.
name|article
operator|+
name|total
operator|.
name|domain
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string_ptr
operator|=
name|strings
expr_stmt|;
name|string_end
operator|=
name|string_ptr
operator|+
name|total
operator|.
name|string2
expr_stmt|;
if|if
condition|(
name|string_end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/*error("second string table is invalid.\n");*/
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
name|total
operator|.
name|domain
operator|+
literal|1
init|;
name|count
operator|--
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|string_ptr
operator|>=
name|string_end
condition|)
block|{
comment|/*error("error unpacking domain strings.\n");*/
return|return
literal|0
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"@%s"
argument_list|,
name|string_ptr
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string_ptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|string_ptr
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ids
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ids
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|ids
index|[
name|i
index|]
operator|>=
name|total
operator|.
name|article
condition|)
block|{
comment|/*error("error in id array.\n");*/
return|return
literal|0
return|;
block|}
name|article
operator|=
name|article_array
index|[
name|ids
index|[
name|i
index|]
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|string_ptr
operator|>=
name|string_end
condition|)
block|{
comment|/*error("error unpacking domain strings.\n");*/
return|return
literal|0
return|;
block|}
name|len2
operator|=
name|strlen
argument_list|(
name|string_ptr
argument_list|)
expr_stmt|;
name|article
operator|->
name|msgid
operator|=
name|safemalloc
argument_list|(
name|len2
operator|+
name|len
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|article
operator|->
name|msgid
argument_list|,
literal|"<%s%s>"
argument_list|,
name|string_ptr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|string_ptr
operator|+=
name|len2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|msgid_hash
condition|)
block|{
name|HASHDATUM
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|article
operator|->
name|flags
operator|&
name|AF_TMPMEM
operator|)
operator|==
name|AF_TMPMEM
condition|)
block|{
name|data
operator|.
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|article
expr_stmt|;
name|data
operator|.
name|dat_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|dat_ptr
operator|=
name|Nullch
expr_stmt|;
name|data
operator|.
name|dat_len
operator|=
name|article_num
argument_list|(
name|article
argument_list|)
expr_stmt|;
block|}
name|hashstore
argument_list|(
name|msgid_hash
argument_list|,
name|article
operator|->
name|msgid
argument_list|,
name|len2
operator|+
name|len
operator|+
literal|2
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|total
operator|.
name|article
operator|+
name|total
operator|.
name|domain
operator|+
operator|!
name|count
condition|)
block|{
comment|/*error("overran id array unpacking domains.\n");*/
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ids
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ids
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|ids
index|[
name|i
index|]
operator|>=
name|total
operator|.
name|article
condition|)
return|return
literal|0
return|;
name|article
operator|=
name|article_array
index|[
name|ids
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
block|}
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ids
argument_list|)
expr_stmt|;
name|safefree
argument_list|(
operator|&
name|strings
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* And finally, turn all the links into real pointers and mark missing ** articles as read. */
specifier|static
name|void
name|tweak_data
parameter_list|()
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|ARTICLE
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|art_ptr
decl_stmt|;
specifier|register
name|SUBJECT
modifier|*
name|sp
decl_stmt|;
specifier|register
name|ART_NUM
name|i
decl_stmt|;
union|union
block|{
name|ARTICLE
modifier|*
name|ap
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
name|uni
union|;
for|for
control|(
name|sp
operator|=
name|first_subject
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
block|{
name|uni
operator|.
name|ap
operator|=
name|sp
operator|->
name|thread
expr_stmt|;
name|sp
operator|->
name|thread
operator|=
name|article_array
index|[
name|uni
operator|.
name|num
index|]
expr_stmt|;
name|sp
operator|->
name|thread
operator|->
name|subj
operator|->
name|flags
operator||=
name|SF_THREAD
expr_stmt|;
block|}
name|art_ptr
operator|=
name|article_array
expr_stmt|;
for|for
control|(
name|count
operator|=
name|total
operator|.
name|article
init|;
name|count
operator|--
condition|;
control|)
block|{
name|ap
operator|=
operator|*
name|art_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|child1
condition|)
block|{
name|uni
operator|.
name|ap
operator|=
name|ap
operator|->
name|child1
expr_stmt|;
name|ap
operator|->
name|child1
operator|=
name|article_array
index|[
name|uni
operator|.
name|num
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|sibling
condition|)
block|{
name|uni
operator|.
name|ap
operator|=
name|ap
operator|->
name|sibling
expr_stmt|;
name|ap
operator|->
name|sibling
operator|=
name|article_array
index|[
name|uni
operator|.
name|num
operator|-
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|flags
operator|&
name|AF_MISSING
operator|)
condition|)
name|cache_article
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
comment|/* Mark any missing articles as read */
for|for
control|(
name|i
operator|=
name|absfirst
operator|,
name|ap
operator|=
name|article_ptr
argument_list|(
name|i
argument_list|)
init|;
name|i
operator|<=
name|total
operator|.
name|last
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
operator|(
name|AF_CACHED
operator||
name|AF_MISSING
operator|)
operator|)
operator|==
name|AF_CACHED
condition|)
name|check_poster
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
name|onemissing
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|safefree
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|article_array
argument_list|)
expr_stmt|;
block|}
comment|/* A shorthand for reading a chunk of the file into a malloc'ed array. */
specifier|static
name|int
name|read_item
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
modifier|*
name|dest
decl_stmt|;
name|MEM_SIZE
name|len
decl_stmt|;
block|{
name|long
name|ret
decl_stmt|;
operator|*
name|dest
operator|=
name|safemalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_XTHREAD
name|ret
operator|=
name|nntp_read
argument_list|(
operator|*
name|dest
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|fread
argument_list|(
operator|*
name|dest
argument_list|,
literal|1
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|!=
name|len
condition|)
block|{
name|free
argument_list|(
operator|*
name|dest
argument_list|)
expr_stmt|;
operator|*
name|dest
operator|=
name|Nullch
expr_stmt|;
return|return
literal|0
return|;
block|}
name|putchar
argument_list|(
literal|'.'
argument_list|)
operator|,
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Free some memory if it hasn't already been freed. */
specifier|static
name|void
name|safefree
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|pp
condition|)
block|{
name|free
argument_list|(
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
comment|/* Determine this machine's byte map for WORDs and LONGs.  A byte map is an ** array of BYTEs (sizeof (WORD) or sizeof (LONG) of them) with the 0th BYTE ** being the byte number of the high-order byte in my<type>, and so forth. */
specifier|static
name|void
name|mybytemap
parameter_list|(
name|map
parameter_list|)
name|BMAP
modifier|*
name|map
decl_stmt|;
block|{
union|union
block|{
name|BYTE
name|b
index|[
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
index|]
decl_stmt|;
name|WORD
name|w
decl_stmt|;
name|LONG
name|l
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|BYTE
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|mp
operator|=
operator|&
name|map
operator|->
name|w
index|[
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
index|]
expr_stmt|;
name|u
operator|.
name|w
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|u
operator|.
name|b
index|[
name|j
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|)
goto|goto
name|bad_news
goto|;
operator|*
operator|--
name|mp
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|u
operator|.
name|b
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|u
operator|.
name|w
condition|)
name|u
operator|.
name|w
operator|<<=
literal|1
expr_stmt|;
block|}
name|mp
operator|=
operator|&
name|map
operator|->
name|l
index|[
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
index|]
expr_stmt|;
name|u
operator|.
name|l
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|u
operator|.
name|b
index|[
name|j
index|]
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
condition|)
block|{
name|bad_news
label|:
comment|/* trouble -- set both to *something* consistent */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|;
name|j
operator|++
control|)
name|map
operator|->
name|w
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
condition|;
name|j
operator|++
control|)
name|map
operator|->
name|l
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
return|return;
block|}
operator|*
operator|--
name|mp
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|u
operator|.
name|b
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|u
operator|.
name|l
condition|)
name|u
operator|.
name|l
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Transform each WORD's byte-ordering in a buffer of the designated length. */
specifier|static
name|void
name|wp_bmap
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|WORD
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
union|union
block|{
name|BYTE
name|b
index|[
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
index|]
decl_stmt|;
name|WORD
name|w
decl_stmt|;
block|}
name|in
union|,
name|out
union|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|word_same
condition|)
return|return;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|in
operator|.
name|w
operator|=
operator|*
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
condition|;
name|i
operator|++
control|)
name|out
operator|.
name|b
index|[
name|my_bmap
operator|.
name|w
index|[
name|i
index|]
index|]
operator|=
name|in
operator|.
name|b
index|[
name|mt_bmap
operator|.
name|w
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|out
operator|.
name|w
expr_stmt|;
block|}
block|}
comment|/* Transform each LONG's byte-ordering in a buffer of the designated length. */
specifier|static
name|void
name|lp_bmap
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|LONG
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
union|union
block|{
name|BYTE
name|b
index|[
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
index|]
decl_stmt|;
name|LONG
name|l
decl_stmt|;
block|}
name|in
union|,
name|out
union|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|long_same
condition|)
return|return;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|in
operator|.
name|l
operator|=
operator|*
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|LONG
argument_list|)
condition|;
name|i
operator|++
control|)
name|out
operator|.
name|b
index|[
name|my_bmap
operator|.
name|l
index|[
name|i
index|]
index|]
operator|=
name|in
operator|.
name|b
index|[
name|mt_bmap
operator|.
name|l
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|out
operator|.
name|l
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_MT */
end_comment

end_unit

