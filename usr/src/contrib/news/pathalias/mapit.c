begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pathalias -- by steve bellovin, as told to peter honeyman */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)mapit.c	9.16 92/08/25"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"def.h"
end_include

begin_define
define|#
directive|define
name|chkheap
parameter_list|(
name|i
parameter_list|)
end_define

begin_comment
comment|/* void */
end_comment

begin_define
define|#
directive|define
name|chkgap
parameter_list|()
end_define

begin_comment
comment|/* int */
end_comment

begin_define
define|#
directive|define
name|trprint
parameter_list|(
name|stream
parameter_list|,
name|n
parameter_list|)
define|\
value|fprintf((stream), (n)->n_flag& NTERMINAL ? "<%s>" : "%s", (n)->n_name)
end_define

begin_comment
comment|/* exports */
end_comment

begin_comment
comment|/* invariant while mapping: Nheap< Hashpart */
end_comment

begin_decl_stmt
name|long
name|Hashpart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of unreached nodes */
end_comment

begin_decl_stmt
name|long
name|Nheap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of heap */
end_comment

begin_decl_stmt
name|long
name|NumNcopy
decl_stmt|,
name|Nlink
decl_stmt|,
name|NumLcopy
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|mapit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* imports */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|Nheap
decl_stmt|,
name|Hashpart
decl_stmt|,
name|Tabsize
decl_stmt|,
name|Tcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Tflag
decl_stmt|,
name|Vflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|node
modifier|*
modifier|*
name|Table
decl_stmt|,
modifier|*
name|Home
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Linkout
decl_stmt|,
modifier|*
name|Graphout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|freelink
argument_list|()
decl_stmt|,
name|resetnodes
argument_list|()
decl_stmt|,
name|printit
argument_list|()
decl_stmt|,
name|dumpgraph
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|showlinks
argument_list|()
decl_stmt|,
name|die
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|pack
argument_list|()
decl_stmt|,
name|allocation
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|link
modifier|*
name|newlink
argument_list|()
decl_stmt|,
modifier|*
name|addlink
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maptrace
argument_list|()
decl_stmt|,
name|tiebreaker
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|node
modifier|*
name|ncopy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* privates */
end_comment

begin_decl_stmt
specifier|static
name|long
name|Heaphighwater
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|link
modifier|*
modifier|*
name|Heap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|insert
argument_list|()
decl_stmt|,
name|heapup
argument_list|()
decl_stmt|,
name|heapdown
argument_list|()
decl_stmt|,
name|heapswap
argument_list|()
decl_stmt|,
name|backlinks
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|void
name|setheapbits
argument_list|()
decl_stmt|,
name|mtracereport
argument_list|()
decl_stmt|,
name|heapchildren
argument_list|()
decl_stmt|,
name|otracereport
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STATIC
name|link
modifier|*
name|min_node
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|STATIC
name|int
name|dehash
argument_list|()
decl_stmt|,
name|skiplink
argument_list|()
decl_stmt|,
name|skipterminalalias
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STATIC
name|Cost
name|costof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|node
modifier|*
name|mappedcopy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* transform the graph to a shortest-path tree by marking tree edges */
end_comment

begin_function
name|void
name|mapit
parameter_list|()
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** mapping\ttcount = %ld\n"
argument_list|,
name|Tcount
argument_list|)
expr_stmt|;
name|Tflag
operator|=
name|Tflag
operator|&&
name|Vflag
expr_stmt|;
comment|/* tracing here only if verbose */
comment|/* re-use the hash table space for the heap */
name|Heap
operator|=
operator|(
name|link
operator|*
operator|*
operator|)
name|Table
expr_stmt|;
name|Hashpart
operator|=
name|pack
argument_list|(
literal|0L
argument_list|,
name|Tabsize
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* expunge penalties from -a option and make circular copy lists */
name|resetnodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|Linkout
operator|&&
operator|*
name|Linkout
condition|)
comment|/* dump cheapest links */
name|showlinks
argument_list|()
expr_stmt|;
if|if
condition|(
name|Graphout
operator|&&
operator|*
name|Graphout
condition|)
comment|/* dump the edge list */
name|dumpgraph
argument_list|()
expr_stmt|;
comment|/* insert Home to get things started */
name|l
operator|=
name|newlink
argument_list|()
expr_stmt|;
comment|/* link to get things started */
name|l
operator|->
name|l_to
operator|=
name|Home
expr_stmt|;
operator|(
name|void
operator|)
name|dehash
argument_list|(
name|Home
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* main mapping loop */
do|do
block|{
name|Heaphighwater
operator|=
name|Nheap
expr_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|min_node
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|l
operator|->
name|l_flag
operator||=
name|LTREE
expr_stmt|;
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_flag
operator|&
name|MAPPED
condition|)
comment|/* sanity check */
name|die
argument_list|(
literal|"mapped node in heap"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tflag
operator|&&
name|maptrace
argument_list|(
name|n
argument_list|,
name|n
argument_list|)
condition|)
name|otracereport
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* tracing */
name|chkheap
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|chkgap
argument_list|()
expr_stmt|;
comment|/* debugging */
name|n
operator|->
name|n_flag
operator||=
name|MAPPED
expr_stmt|;
name|heapchildren
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* add children to heap */
block|}
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"heap hiwat %d\nalloc %ldk, ncopy = %ld, nlink = %ld, lcopy = %ld\n"
argument_list|,
name|Heaphighwater
argument_list|,
name|allocation
argument_list|()
argument_list|,
name|NumNcopy
argument_list|,
name|Nlink
argument_list|,
name|NumLcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nheap
operator|!=
literal|0
condition|)
comment|/* sanity check */
name|die
argument_list|(
literal|"null entry in heap"
argument_list|)
expr_stmt|;
comment|/* 		 * add back links from unreachable hosts to reachable 		 * neighbors, then remap.  asymptotically, this is 		 * quadratic; in practice, this is done once or twice, 		 * when n is small. 		 */
name|backlinks
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|Nheap
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|Hashpart
operator|<
name|Tabsize
condition|)
block|{
name|int
name|foundone
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|Hashpart
operator|<
name|Tabsize
condition|;
name|Hashpart
operator|++
control|)
block|{
if|if
condition|(
name|Table
index|[
name|Hashpart
index|]
operator|->
name|n_flag
operator|&
name|ISPRIVATE
condition|)
continue|continue;
if|if
condition|(
name|foundone
operator|++
operator|==
literal|0
condition|)
name|fputs
argument_list|(
literal|"You can't get there from here:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|trprint
argument_list|(
name|stderr
argument_list|,
name|Table
index|[
name|Hashpart
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|heapchildren
parameter_list|(
name|n
parameter_list|)
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
specifier|register
name|node
modifier|*
name|next
decl_stmt|;
specifier|register
name|int
name|mtrace
decl_stmt|;
specifier|register
name|Cost
name|cost
decl_stmt|;
for|for
control|(
name|l
operator|=
name|n
operator|->
name|n_link
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|l_next
control|)
block|{
name|next
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
comment|/* neighboring node */
name|mtrace
operator|=
name|Tflag
operator|&&
name|maptrace
argument_list|(
name|n
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LTREE
condition|)
continue|continue;
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LTERMINAL
condition|)
name|l
operator|->
name|l_to
operator|=
name|next
operator|=
name|ncopy
argument_list|(
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|n_flag
operator|&
name|NTERMINAL
operator|)
operator|&&
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LALIAS
operator|)
condition|)
if|if
condition|(
name|skipterminalalias
argument_list|(
name|n
argument_list|,
name|next
argument_list|)
condition|)
continue|continue;
else|else
name|l
operator|->
name|l_to
operator|=
name|next
operator|=
name|ncopy
argument_list|(
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|n_flag
operator|&
name|MAPPED
condition|)
block|{
if|if
condition|(
name|mtrace
condition|)
name|mtracereport
argument_list|(
name|n
argument_list|,
name|l
argument_list|,
literal|"-\talready mapped"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cost
operator|=
name|costof
argument_list|(
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|skiplink
argument_list|(
name|l
argument_list|,
name|n
argument_list|,
name|cost
argument_list|,
name|mtrace
argument_list|)
condition|)
continue|continue;
comment|/* 		 * put this link in the heap and restore the 		 * heap property. 		 */
if|if
condition|(
name|mtrace
condition|)
block|{
if|if
condition|(
name|next
operator|->
name|n_parent
condition|)
name|mtracereport
argument_list|(
name|next
operator|->
name|n_parent
argument_list|,
name|l
argument_list|,
literal|"*\tdrop"
argument_list|)
expr_stmt|;
name|mtracereport
argument_list|(
name|n
argument_list|,
name|l
argument_list|,
literal|"+\tadd"
argument_list|)
expr_stmt|;
block|}
name|next
operator|->
name|n_parent
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|dehash
argument_list|(
name|next
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* first time */
name|next
operator|->
name|n_cost
operator|=
name|cost
expr_stmt|;
name|insert
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* insert at end */
name|heapup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* replace inferior path */
name|Heap
index|[
name|next
operator|->
name|n_tloc
index|]
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|next
operator|->
name|n_cost
condition|)
block|{
comment|/* increase cost (gateway) */
name|next
operator|->
name|n_cost
operator|=
name|cost
expr_stmt|;
name|heapdown
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cost
operator|<
name|next
operator|->
name|n_cost
condition|)
block|{
comment|/* cheaper route */
name|next
operator|->
name|n_cost
operator|=
name|cost
expr_stmt|;
name|heapup
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
name|setheapbits
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|chkheap
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * n is a terminal node just sucked out of the heap, next is an alias  * for n.  if n was heaped because of a copy (ALTEREGO) of next, don't  * heap next -- it will happen over and over and over and ...  */
end_comment

begin_function
name|STATIC
name|int
name|skipterminalalias
parameter_list|(
name|n
parameter_list|,
name|next
parameter_list|)
name|node
modifier|*
name|n
decl_stmt|,
decl|*
name|next
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|n
operator|->
name|n_flag
operator|&
name|NALIAS
condition|)
block|{
name|n
operator|=
name|n
operator|->
name|n_parent
expr_stmt|;
if|if
condition|(
name|ALTEREGO
argument_list|(
name|n
argument_list|,
name|next
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * return 1 if we definitely don't want want this link in the  * shortest path tree, 0 if we might want it, i.e., best so far.  *  * if tracing is turned on, report only if this node is being skipped.  */
end_comment

begin_function
name|STATIC
name|int
name|skiplink
parameter_list|(
name|l
parameter_list|,
name|parent
parameter_list|,
name|cost
parameter_list|,
name|trace
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
comment|/* new link to this node */
name|node
modifier|*
name|parent
decl_stmt|;
comment|/* (potential) new parent of this node */
specifier|register
name|Cost
name|cost
decl_stmt|;
comment|/* new cost to this node */
name|int
name|trace
decl_stmt|;
comment|/* trace this link? */
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
comment|/* this node */
specifier|register
name|link
modifier|*
name|lheap
decl_stmt|;
comment|/* old link to this node */
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
comment|/* first time we've reached this node? */
if|if
condition|(
name|n
operator|->
name|n_tloc
operator|>=
name|Hashpart
condition|)
return|return
literal|0
return|;
name|lheap
operator|=
name|Heap
index|[
name|n
operator|->
name|n_tloc
index|]
expr_stmt|;
comment|/* examine links to nets that require gateways */
if|if
condition|(
name|GATEWAYED
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|/* if exactly one is a gateway, use it */
if|if
condition|(
operator|(
name|lheap
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
operator|&&
operator|!
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|mtracereport
argument_list|(
name|parent
argument_list|,
name|l
argument_list|,
literal|"-\told gateway"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* old is gateway */
block|}
if|if
condition|(
operator|!
operator|(
name|lheap
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
operator|&&
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
condition|)
return|return
literal|0
return|;
comment|/* new is gateway */
comment|/* no gateway or both gateways;  resolve in standard way ... */
block|}
comment|/* examine dup link (sanity check) */
if|if
condition|(
name|n
operator|->
name|n_parent
operator|==
name|parent
operator|&&
operator|(
name|DEADLINK
argument_list|(
name|lheap
argument_list|)
operator|||
name|DEADLINK
argument_list|(
name|l
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"dup dead link"
argument_list|)
expr_stmt|;
comment|/*  examine cost */
if|if
condition|(
name|cost
operator|<
name|n
operator|->
name|n_cost
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cost
operator|>
name|n
operator|->
name|n_cost
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|mtracereport
argument_list|(
name|parent
argument_list|,
name|l
argument_list|,
literal|"-\tcheaper"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* all other things being equal, ask the oracle */
if|if
condition|(
name|tiebreaker
argument_list|(
name|n
argument_list|,
name|parent
argument_list|)
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|mtracereport
argument_list|(
name|parent
argument_list|,
name|l
argument_list|,
literal|"-\ttiebreaker"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* compute cost to next (l->l_to) via prev */
end_comment

begin_function
name|STATIC
name|Cost
name|costof
parameter_list|(
name|prev
parameter_list|,
name|l
parameter_list|)
specifier|register
name|node
modifier|*
name|prev
decl_stmt|;
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|next
decl_stmt|;
specifier|register
name|Cost
name|cost
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LALIAS
condition|)
return|return
name|prev
operator|->
name|n_cost
return|;
comment|/* by definition */
name|next
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
name|cost
operator|=
name|prev
operator|->
name|n_cost
operator|+
name|l
operator|->
name|l_cost
expr_stmt|;
comment|/* basic cost */
if|if
condition|(
name|cost
operator|>=
name|INF
condition|)
return|return
name|cost
operator|+
literal|1
return|;
comment|/* 	 * heuristics: 	 *    charge for a dead link. 	 *    charge for getting past a terminal host 	 *    	or getting out of a dead host. 	 *    charge for getting into a gatewayed net (except at a gateway). 	 *    discourage mixing of syntax (when prev is a host). 	 * 	 * life was simpler when pathalias truly computed shortest paths. 	 */
if|if
condition|(
name|DEADLINK
argument_list|(
name|l
argument_list|)
condition|)
name|cost
operator|+=
name|INF
expr_stmt|;
comment|/* dead link */
elseif|else
if|if
condition|(
name|DEADHOST
argument_list|(
name|prev
argument_list|)
condition|)
name|cost
operator|+=
name|INF
expr_stmt|;
comment|/* dead parent */
elseif|else
if|if
condition|(
name|GATEWAYED
argument_list|(
name|next
argument_list|)
operator|&&
operator|!
operator|(
name|l
operator|->
name|l_flag
operator|&
name|LGATEWAY
operator|)
condition|)
name|cost
operator|+=
name|INF
expr_stmt|;
comment|/* not gateway */
elseif|else
if|if
condition|(
operator|!
name|ISANET
argument_list|(
name|prev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LLEFT
operator|&&
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|HASRIGHT
operator|)
operator|)
operator|||
operator|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LRIGHT
operator|&&
operator|(
name|prev
operator|->
name|n_flag
operator|&
name|HASLEFT
operator|)
operator|)
condition|)
name|cost
operator|+=
name|INF
expr_stmt|;
comment|/* mixed syntax */
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* binary heap implementation of priority queue */
end_comment

begin_function
name|STATIC
name|void
name|insert
parameter_list|(
name|l
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_flag
operator|&
name|MAPPED
condition|)
name|die
argument_list|(
literal|"insert mapped node"
argument_list|)
expr_stmt|;
name|Heap
index|[
name|n
operator|->
name|n_tloc
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Heap
index|[
name|Nheap
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"heap error in insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Nheap
operator|++
operator|==
literal|0
condition|)
block|{
name|Heap
index|[
literal|1
index|]
operator|=
name|l
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Vflag
operator|&&
name|Nheap
operator|>
name|Heaphighwater
condition|)
name|Heaphighwater
operator|=
name|Nheap
expr_stmt|;
comment|/* diagnostics */
comment|/* insert at the end.  caller must heapup(l). */
name|Heap
index|[
name|Nheap
index|]
operator|=
name|l
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|Nheap
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "percolate" up the heap by exchanging with the parent.  as in  * min_node(), give tiebreaker() a chance to produce better, stable  * routes by moving nets and domains close to the root, nets closer  * than domains.  *  * i know this seems obscure, but it's harmless and cheap.  trust me.  */
end_comment

begin_function
name|STATIC
name|void
name|heapup
parameter_list|(
name|l
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|long
name|cindx
decl_stmt|,
name|pindx
decl_stmt|;
comment|/* child, parent indices */
specifier|register
name|Cost
name|cost
decl_stmt|;
specifier|register
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|child
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
name|cost
operator|=
name|child
operator|->
name|n_cost
expr_stmt|;
for|for
control|(
name|cindx
operator|=
name|child
operator|->
name|n_tloc
init|;
name|cindx
operator|>
literal|1
condition|;
name|cindx
operator|=
name|pindx
control|)
block|{
name|pindx
operator|=
name|cindx
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|Heap
index|[
name|pindx
index|]
operator|==
literal|0
condition|)
comment|/* sanity check */
name|die
argument_list|(
literal|"impossible error in heapup"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|Heap
index|[
name|pindx
index|]
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
name|cost
operator|>
name|parent
operator|->
name|n_cost
condition|)
return|return;
comment|/* net/domain heuristic */
if|if
condition|(
name|cost
operator|==
name|parent
operator|->
name|n_cost
condition|)
block|{
if|if
condition|(
operator|!
name|ISANET
argument_list|(
name|child
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|ISADOMAIN
argument_list|(
name|parent
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ISADOMAIN
argument_list|(
name|child
argument_list|)
condition|)
return|return;
block|}
name|heapswap
argument_list|(
name|cindx
argument_list|,
name|pindx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* extract min (== Heap[1]) from heap */
end_comment

begin_function
name|STATIC
name|link
modifier|*
name|min_node
parameter_list|()
block|{
name|link
modifier|*
name|rval
decl_stmt|,
modifier|*
name|lastlink
decl_stmt|;
specifier|register
name|link
modifier|*
modifier|*
name|rheap
decl_stmt|;
if|if
condition|(
name|Nheap
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|rheap
operator|=
name|Heap
expr_stmt|;
comment|/* in register -- heavily used */
name|rval
operator|=
name|rheap
index|[
literal|1
index|]
expr_stmt|;
comment|/* return this one */
comment|/* move last entry into root and reheap */
name|lastlink
operator|=
name|rheap
index|[
name|Nheap
index|]
expr_stmt|;
name|rheap
index|[
name|Nheap
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|--
name|Nheap
condition|)
block|{
name|rheap
index|[
literal|1
index|]
operator|=
name|lastlink
expr_stmt|;
name|lastlink
operator|->
name|l_to
operator|->
name|n_tloc
operator|=
literal|1
expr_stmt|;
name|heapdown
argument_list|(
name|lastlink
argument_list|)
expr_stmt|;
comment|/* restore heap property */
block|}
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * swap Heap[i] with smaller child, iteratively down the tree.  *  * given the opportunity, attempt to place nets and domains  * near the root.  this helps tiebreaker() shun domain routes.  */
end_comment

begin_function
name|STATIC
name|void
name|heapdown
parameter_list|(
name|l
parameter_list|)
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|long
name|pindx
decl_stmt|,
name|cindx
decl_stmt|;
specifier|register
name|link
modifier|*
modifier|*
name|rheap
init|=
name|Heap
decl_stmt|;
comment|/* in register -- heavily used */
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|rchild
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|pindx
operator|=
name|l
operator|->
name|l_to
operator|->
name|n_tloc
expr_stmt|;
name|parent
operator|=
name|rheap
index|[
name|pindx
index|]
operator|->
name|l_to
expr_stmt|;
comment|/* invariant */
for|for
control|(
init|;
operator|(
name|cindx
operator|=
name|pindx
operator|*
literal|2
operator|)
operator|<=
name|Nheap
condition|;
name|pindx
operator|=
name|cindx
control|)
block|{
comment|/* pick lhs or rhs child */
name|child
operator|=
name|rheap
index|[
name|cindx
index|]
operator|->
name|l_to
expr_stmt|;
if|if
condition|(
name|cindx
operator|<
name|Nheap
condition|)
block|{
comment|/* compare with rhs child */
name|rchild
operator|=
name|rheap
index|[
name|cindx
operator|+
literal|1
index|]
operator|->
name|l_to
expr_stmt|;
comment|/* 			 * use rhs child if smaller than lhs child. 			 * if equal, use rhs if net or domain. 			 */
if|if
condition|(
name|child
operator|->
name|n_cost
operator|>
name|rchild
operator|->
name|n_cost
condition|)
block|{
name|child
operator|=
name|rchild
expr_stmt|;
name|cindx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|n_cost
operator|==
name|rchild
operator|->
name|n_cost
condition|)
if|if
condition|(
name|ISANET
argument_list|(
name|rchild
argument_list|)
condition|)
block|{
name|child
operator|=
name|rchild
expr_stmt|;
name|cindx
operator|++
expr_stmt|;
block|}
block|}
comment|/* child is the candidate for swapping */
if|if
condition|(
name|parent
operator|->
name|n_cost
operator|<
name|child
operator|->
name|n_cost
condition|)
break|break;
comment|/* 		 * heuristics: 		 *	move nets/domains up 		 *	move nets above domains 		 */
if|if
condition|(
name|parent
operator|->
name|n_cost
operator|==
name|child
operator|->
name|n_cost
condition|)
block|{
if|if
condition|(
operator|!
name|ISANET
argument_list|(
name|child
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ISANET
argument_list|(
name|parent
argument_list|)
operator|&&
name|ISADOMAIN
argument_list|(
name|child
argument_list|)
condition|)
break|break;
block|}
name|heapswap
argument_list|(
name|pindx
argument_list|,
name|cindx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* exchange Heap[i] and Heap[j] pointers */
end_comment

begin_function
name|STATIC
name|void
name|heapswap
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
specifier|register
name|link
modifier|*
name|temp
decl_stmt|,
modifier|*
modifier|*
name|rheap
decl_stmt|;
name|rheap
operator|=
name|Heap
expr_stmt|;
comment|/* heavily used -- put in register */
name|temp
operator|=
name|rheap
index|[
name|i
index|]
expr_stmt|;
name|rheap
index|[
name|i
index|]
operator|=
name|rheap
index|[
name|j
index|]
expr_stmt|;
name|rheap
index|[
name|j
index|]
operator|=
name|temp
expr_stmt|;
name|rheap
index|[
name|j
index|]
operator|->
name|l_to
operator|->
name|n_tloc
operator|=
name|j
expr_stmt|;
name|rheap
index|[
name|i
index|]
operator|->
name|l_to
operator|->
name|n_tloc
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return 1 if n is already de-hashed (n_tloc< Hashpart), 0 o.w. */
end_comment

begin_function
name|STATIC
name|int
name|dehash
parameter_list|(
name|n
parameter_list|)
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|->
name|n_tloc
operator|<
name|Hashpart
condition|)
return|return
literal|1
return|;
comment|/* swap with entry in Table[Hashpart] */
name|Table
index|[
name|Hashpart
index|]
operator|->
name|n_tloc
operator|=
name|n
operator|->
name|n_tloc
expr_stmt|;
name|Table
index|[
name|n
operator|->
name|n_tloc
index|]
operator|=
name|Table
index|[
name|Hashpart
index|]
expr_stmt|;
name|Table
index|[
name|Hashpart
index|]
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|n_tloc
operator|=
name|Hashpart
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * everything reachable has been mapped.  what to do about any  * unreachable hosts?  the sensible thing to do is to dump them on  * stderr and be done with it.  unfortunately, there are hundreds of  * such hosts in the usenet maps.  so we take the low road: for each  * unreachable host, we add a back link from its cheapest mapped child,  * in the faint that a reverse path works.  *  * beats me why people want their error output in their map databases.  */
end_comment

begin_function
name|STATIC
name|void
name|backlinks
parameter_list|()
block|{
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
specifier|register
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|node
modifier|*
name|nomap
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* hosts from Hashpart to Tabsize are unreachable */
for|for
control|(
name|i
operator|=
name|Hashpart
init|;
name|i
operator|<
name|Tabsize
condition|;
name|i
operator|++
control|)
block|{
name|nomap
operator|=
name|Table
index|[
name|i
index|]
expr_stmt|;
comment|/* if a copy has been mapped, we're ok */
if|if
condition|(
name|nomap
operator|->
name|n_copy
operator|!=
name|nomap
condition|)
block|{
name|dehash
argument_list|(
name|nomap
argument_list|)
expr_stmt|;
name|Table
index|[
name|nomap
operator|->
name|n_tloc
index|]
operator|=
literal|0
expr_stmt|;
name|nomap
operator|->
name|n_tloc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* TODO: simplify this */
comment|/* add back link from minimal cost child */
name|child
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|nomap
operator|->
name|n_link
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|l_next
control|)
block|{
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
comment|/* never ever ever crawl out of a domain */
if|if
condition|(
name|ISADOMAIN
argument_list|(
name|n
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|n
operator|=
name|mappedcopy
argument_list|(
name|n
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|child
operator|==
literal|0
condition|)
block|{
name|child
operator|=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|->
name|n_cost
operator|>
name|child
operator|->
name|n_cost
condition|)
continue|continue;
if|if
condition|(
name|n
operator|->
name|n_cost
operator|==
name|child
operator|->
name|n_cost
condition|)
block|{
name|nomap
operator|->
name|n_parent
operator|=
name|child
expr_stmt|;
comment|/* for tiebreaker */
if|if
condition|(
name|tiebreaker
argument_list|(
name|nomap
argument_list|,
name|n
argument_list|)
condition|)
continue|continue;
block|}
name|child
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|dehash
argument_list|(
name|nomap
argument_list|)
expr_stmt|;
name|l
operator|=
name|addlink
argument_list|(
name|child
argument_list|,
name|nomap
argument_list|,
name|INF
argument_list|,
name|DEFNET
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
comment|/* INF cost */
name|nomap
operator|->
name|n_parent
operator|=
name|child
expr_stmt|;
name|nomap
operator|->
name|n_cost
operator|=
name|costof
argument_list|(
name|child
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|insert
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|heapup
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|Vflag
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"backlink: %s<- %s\n"
argument_list|,
name|nomap
operator|->
name|n_name
argument_list|,
name|child
operator|->
name|n_name
argument_list|)
expr_stmt|;
block|}
name|vprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d backlinks\n"
argument_list|,
name|Nheap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* find a mapped copy of n if it exists */
end_comment

begin_function
name|STATIC
name|node
modifier|*
name|mappedcopy
parameter_list|(
name|n
parameter_list|)
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|ncp
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|n_flag
operator|&
name|MAPPED
condition|)
return|return
name|n
return|;
for|for
control|(
name|ncp
operator|=
name|n
operator|->
name|n_copy
init|;
name|ncp
operator|!=
name|n
condition|;
name|ncp
operator|=
name|ncp
operator|->
name|n_copy
control|)
if|if
condition|(
name|ncp
operator|->
name|n_flag
operator|&
name|MAPPED
condition|)
return|return
name|ncp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * l has just been added or changed in the heap,  * so reset the state bits for l->l_to.  */
end_comment

begin_function
name|STATIC
name|void
name|setheapbits
parameter_list|(
name|l
parameter_list|)
specifier|register
name|link
modifier|*
name|l
decl_stmt|;
block|{
specifier|register
name|node
modifier|*
name|n
decl_stmt|;
specifier|register
name|node
modifier|*
name|parent
decl_stmt|;
name|n
operator|=
name|l
operator|->
name|l_to
expr_stmt|;
name|parent
operator|=
name|n
operator|->
name|n_parent
expr_stmt|;
name|n
operator|->
name|n_flag
operator|&=
operator|~
operator|(
name|NALIAS
operator||
name|HASLEFT
operator||
name|HASRIGHT
operator|)
expr_stmt|;
comment|/* reset */
comment|/* record whether link is an alias */
if|if
condition|(
name|l
operator|->
name|l_flag
operator|&
name|LALIAS
condition|)
block|{
name|n
operator|->
name|n_flag
operator||=
name|NALIAS
expr_stmt|;
comment|/* TERMINALity is inherited by the alias */
if|if
condition|(
name|parent
operator|->
name|n_flag
operator|&
name|NTERMINAL
condition|)
name|n
operator|->
name|n_flag
operator||=
name|NTERMINAL
expr_stmt|;
block|}
comment|/* set left/right bits */
if|if
condition|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LLEFT
operator|||
operator|(
name|parent
operator|->
name|n_flag
operator|&
name|HASLEFT
operator|)
condition|)
name|n
operator|->
name|n_flag
operator||=
name|HASLEFT
expr_stmt|;
if|if
condition|(
name|NETDIR
argument_list|(
name|l
argument_list|)
operator|==
name|LRIGHT
operator|||
operator|(
name|parent
operator|->
name|n_flag
operator|&
name|HASRIGHT
operator|)
condition|)
name|n
operator|->
name|n_flag
operator||=
name|HASRIGHT
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|mtracereport
parameter_list|(
name|from
parameter_list|,
name|l
parameter_list|,
name|excuse
parameter_list|)
name|node
modifier|*
name|from
decl_stmt|;
name|link
modifier|*
name|l
decl_stmt|;
name|char
modifier|*
name|excuse
decl_stmt|;
block|{
name|node
modifier|*
name|to
init|=
name|l
operator|->
name|l_to
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-16s "
argument_list|,
name|excuse
argument_list|)
expr_stmt|;
name|trprint
argument_list|(
name|stderr
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" -> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|trprint
argument_list|(
name|stderr
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%ld, %ld, %ld) "
argument_list|,
name|from
operator|->
name|n_cost
argument_list|,
name|l
operator|->
name|l_cost
argument_list|,
name|to
operator|->
name|n_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|n_parent
condition|)
block|{
name|trprint
argument_list|(
name|stderr
argument_list|,
name|to
operator|->
name|n_parent
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (%ld)"
argument_list|,
name|to
operator|->
name|n_parent
operator|->
name|n_cost
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|otracereport
parameter_list|(
name|n
parameter_list|)
name|node
modifier|*
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|->
name|n_parent
condition|)
name|trprint
argument_list|(
name|stderr
argument_list|,
name|n
operator|->
name|n_parent
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"[root]"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" -> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|trprint
argument_list|(
name|stderr
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" mapped\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* extremely time consuming, exhaustive check of heap sanity. */
end_comment

begin_if
unit|chkheap(i) {	int lhs, rhs;  	lhs = i * 2; 	rhs = lhs + 1;  	if (lhs<= Nheap) { 		if (Heap[i]->l_to->n_cost> Heap[lhs]->l_to->n_cost) 			die("chkheap failure on lhs"); 		chkheap(lhs); 	} 	if (rhs<= Nheap) { 		if (Heap[i]->l_to->n_cost> Heap[rhs]->l_to->n_cost) 			die("chkheap failure on rhs"); 		chkheap(rhs); 	}
if|#
directive|if
literal|00
end_if

begin_comment
comment|/* this hasn't been used for years */
end_comment

begin_endif
unit|for (i = 1; i< Nheap; i++) { 		link *l;  		vprintf(stderr, "%5d %-16s", i, Heap[i]->l_to->n_name); 		if ((l = Heap[i]->l_to->n_link) != 0) do { 			vprintf(stderr, "%-16s", l->l_to->n_name); 		} while ((l = l->l_next) != 0); 		vprintf(stderr, "\n"); 	} 	for (i = Hashpart; i< Tabsize; i++) { 		link *l; 		node *n;  		vprintf(stderr, "%5d %-16s", i, Table[i]->n_name); 		if ((l = Table[i]->n_link) != 0) do { 			vprintf(stderr, "%-16s", l->l_to->n_name); 		} while ((l = l->l_next) != 0); 		vprintf(stderr, "\n"); 	}
endif|#
directive|endif
end_endif

begin_comment
comment|/*00*/
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*0*/
end_comment

begin_comment
comment|/* this isn't much use */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|STATIC int chkgap() {	static int gap = -1; 	int newgap;  	newgap = Hashpart - Nheap; 	if (gap == -1 || newgap< gap) 		gap = newgap; 	return gap; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*0*/
end_comment

end_unit

