begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.33 $ ** **  Send an article (prepared by someone on the local site) to the **  master news server. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"nntp.h"
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_define
define|#
directive|define
name|FLUSH_ERROR
parameter_list|(
name|F
parameter_list|)
value|(fflush((F)) == EOF || ferror((F)))
end_define

begin_define
define|#
directive|define
name|LPAREN
value|'('
end_define

begin_comment
comment|/* For vi :-) */
end_comment

begin_define
define|#
directive|define
name|HEADER_DELTA
value|20
end_define

begin_define
define|#
directive|define
name|GECOSTERM
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == ',' || (c) == ';' || (c) == ':' || (c) == LPAREN)
end_define

begin_typedef
typedef|typedef
enum|enum
name|_HEADERTYPE
block|{
name|HTobs
block|,
name|HTreq
block|,
name|HTstd
block|}
name|HEADERTYPE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_HEADER
block|{
name|STRING
name|Name
decl_stmt|;
name|BOOL
name|CanSet
decl_stmt|;
name|HEADERTYPE
name|Type
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
modifier|*
name|Value
decl_stmt|;
block|}
name|HEADER
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|BOOL
name|Dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|Revoked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|Spooling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|SPOOLNEWS
index|[]
init|=
name|_PATH_SPOOLNEWS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
modifier|*
name|OtherHeaders
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|NGSEPS
index|[]
init|=
name|NG_SEPARATOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|SIGSEP
index|[]
init|=
name|SIG_SEPARATOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|FromServer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|ToServer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|OtherCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|OtherSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Exclusions
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|STRING
name|BadDistribs
index|[]
init|=
block|{
name|BAD_DISTRIBS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|HEADER
name|Table
index|[]
init|=
block|{
comment|/* 	Name			Canset	Type	*/
block|{
literal|"Path"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_path
value|0
block|{
literal|"From"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_from
value|1
block|{
literal|"Newsgroups"
block|,
name|TRUE
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_newsgroups
value|2
block|{
literal|"Subject"
block|,
name|TRUE
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_subject
value|3
block|{
literal|"Control"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_control
value|4
block|{
literal|"Supersedes"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_supersedes
value|5
block|{
literal|"Followup-To"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_followupto
value|6
block|{
literal|"Date"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_date
value|7
block|{
literal|"Organization"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_organization
value|8
block|{
literal|"Lines"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_lines
value|9
block|{
literal|"Sender"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_sender
value|10
block|{
literal|"Approved"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_approved
value|11
block|{
literal|"Distribution"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_distribution
value|12
block|{
literal|"Expires"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_expires
value|13
block|{
literal|"Message-ID"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_messageid
value|14
block|{
literal|"References"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_references
value|15
block|{
literal|"Reply-To"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_replyto
value|16
block|{
literal|"Also-Control"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_alsocontrol
value|17
block|{
literal|"Xref"
block|,
name|FALSE
block|,
name|HTstd
block|}
block|,
block|{
literal|"Summary"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
block|{
literal|"Keywords"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
block|{
literal|"Date-Received"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Received"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Posted"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Posting-Version"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Relay-Version"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HDR
parameter_list|(
name|_x
parameter_list|)
value|(Table[(_x)].Value)
end_define

begin_escape
end_escape

begin_comment
comment|/* **  Send the server a quit message, wait for a reply. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|QuitServer
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|char
name|buff
index|[
name|NNTP_STRLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|Spooling
condition|)
name|exit
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Article not posted.)\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"quit\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|ToServer
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't send quit to server, %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning -- server did not reply to quit, %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|buff
argument_list|)
operator|!=
name|NNTP_GOODBYE_ACK_VAL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server didn't reply to quit properly:\n\t%s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FromServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print and error message (with errno) and exit with an error code. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|PerrorExit
parameter_list|(
name|ShouldQuit
parameter_list|,
name|s
parameter_list|)
name|BOOL
name|ShouldQuit
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, %s.\n"
argument_list|,
name|s
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ShouldQuit
condition|)
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Flush a stdio FILE; exit if there are any errors. */
end_comment

begin_function
name|STATIC
name|void
name|SafeFlush
parameter_list|(
name|F
parameter_list|)
name|FILE
modifier|*
name|F
decl_stmt|;
block|{
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|F
argument_list|)
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't send text to server"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Trim trailing spaces, return pointer to first non-space char. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|TrimSpaces
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|start
decl_stmt|;
for|for
control|(
name|start
operator|=
name|p
init|;
name|ISWHITE
argument_list|(
operator|*
name|start
argument_list|)
condition|;
name|start
operator|++
control|)
continue|continue;
for|for
control|(
name|p
operator|=
name|start
operator|+
name|strlen
argument_list|(
name|start
argument_list|)
init|;
name|p
operator|>
name|start
operator|&&
name|CTYPE
argument_list|(
name|isspace
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
control|)
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* **  Mark the end of the header starting at p, and return a pointer **  to the start of the next one.  Handles continuations. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|NextHeader
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article is all headers.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISWHITE
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Strip any headers off the article and dump them into the table. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|StripOffHeaders
parameter_list|(
name|article
parameter_list|)
name|char
modifier|*
name|article
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Set up the other headers list. */
name|OtherSize
operator|=
name|HEADER_DELTA
expr_stmt|;
name|OtherHeaders
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|OtherSize
argument_list|)
expr_stmt|;
name|OtherCount
operator|=
literal|0
expr_stmt|;
comment|/* Scan through buffer, a header at a time. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|article
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No colon in header line \"%.20s...\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
operator|!
name|ISWHITE
argument_list|(
name|q
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* Empty header; ignore this one, get next line. */
name|p
operator|=
name|NextHeader
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISWHITE
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No space after colon in \"%.20s...\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See if it's a known header. */
name|c
operator|=
name|CTYPE
argument_list|(
name|islower
argument_list|,
operator|*
name|p
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
else|:
operator|*
name|p
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|hp
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|p
index|[
name|hp
operator|->
name|Size
index|]
operator|==
literal|':'
operator|&&
name|ISWHITE
argument_list|(
name|p
index|[
name|hp
operator|->
name|Size
operator|+
literal|1
index|]
argument_list|)
operator|&&
name|caseEQn
argument_list|(
name|p
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Size
argument_list|)
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|Type
operator|==
name|HTobs
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Obsolete \"%s\" header.\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Duplicate \"%s\" header.\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|q
operator|=
operator|&
name|p
index|[
name|hp
operator|->
name|Size
operator|+
literal|1
index|]
init|;
name|ISWHITE
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
name|hp
operator|->
name|Value
operator|=
name|q
expr_stmt|;
break|break;
block|}
comment|/* Too many headers? */
if|if
condition|(
operator|++
name|i
operator|>
literal|5
operator|*
name|HEADER_DELTA
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"More than %d lines of header.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* No; add it to the set of other headers. */
if|if
condition|(
name|hp
operator|==
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|)
block|{
if|if
condition|(
name|OtherCount
operator|>=
name|OtherSize
operator|-
literal|1
condition|)
block|{
name|OtherSize
operator|+=
name|HEADER_DELTA
expr_stmt|;
name|RENEW
argument_list|(
name|OtherHeaders
argument_list|,
name|char
operator|*
argument_list|,
name|OtherSize
argument_list|)
expr_stmt|;
block|}
name|OtherHeaders
index|[
name|OtherCount
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
comment|/* Get start of next header; if it's a blank line, we hit the end. */
name|p
operator|=
name|NextHeader
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|p
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  See if the user is allowed to cancel the indicated message.  Assumes **  that the Sender or From line has already been filled in. */
end_comment

begin_function
name|STATIC
name|void
name|CheckCancel
parameter_list|(
name|msgid
parameter_list|,
name|JustReturn
parameter_list|)
name|char
modifier|*
name|msgid
decl_stmt|;
name|BOOL
name|JustReturn
decl_stmt|;
block|{
name|char
name|localfrom
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|remotefrom
index|[
name|SMBUF
index|]
decl_stmt|;
comment|/* Ask the server for the article. */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"head %s\r\n"
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
operator|||
name|atoi
argument_list|(
name|buff
argument_list|)
operator|!=
name|NNTP_HEAD_FOLLOWS_VAL
condition|)
block|{
if|if
condition|(
name|JustReturn
condition|)
return|return;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server has no such article.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Read the headers, looking for the From or Sender. */
name|remotefrom
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buff
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|EQn
argument_list|(
name|buff
argument_list|,
literal|"Sender:"
argument_list|,
literal|7
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|remotefrom
argument_list|,
name|TrimSpaces
argument_list|(
operator|&
name|buff
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|remotefrom
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|EQn
argument_list|(
name|buff
argument_list|,
literal|"From:"
argument_list|,
literal|5
argument_list|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|remotefrom
argument_list|,
name|TrimSpaces
argument_list|(
operator|&
name|buff
index|[
literal|5
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remotefrom
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|JustReturn
condition|)
return|return;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article is garbled.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HeaderCleanFrom
argument_list|(
name|remotefrom
argument_list|)
expr_stmt|;
comment|/* Get the local user. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|localfrom
argument_list|,
name|HDR
argument_list|(
name|_sender
argument_list|)
condition|?
name|HDR
argument_list|(
name|_sender
argument_list|)
else|:
name|HDR
argument_list|(
name|_from
argument_list|)
argument_list|)
expr_stmt|;
name|HeaderCleanFrom
argument_list|(
name|localfrom
argument_list|)
expr_stmt|;
comment|/* Is the right person cancelling? */
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|localfrom
argument_list|,
name|remotefrom
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article was posted by \"%s\" and you are \"%s\".\n"
argument_list|,
name|remotefrom
argument_list|,
name|localfrom
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  See if the user is the news administrator. */
end_comment

begin_function
name|STATIC
name|BOOL
name|AnAdministrator
parameter_list|(
name|name
parameter_list|,
name|group
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|group
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pwp
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|char
modifier|*
modifier|*
name|mem
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|Revoked
condition|)
return|return
name|FALSE
return|;
comment|/* Find out who we are. */
if|if
condition|(
operator|(
name|pwp
operator|=
name|getpwnam
argument_list|(
name|NEWSUSER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* Silent falure; clients might not have the group. */
return|return
name|FALSE
return|;
if|if
condition|(
name|getuid
argument_list|()
operator|==
name|pwp
operator|->
name|pw_uid
condition|)
return|return
name|TRUE
return|;
comment|/* See if the we're in the right group. */
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|NEWSGID
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|mem
operator|=
name|grp
operator|->
name|gr_mem
operator|)
operator|==
name|NULL
condition|)
comment|/* Silent falure; clients might not have the group. */
return|return
name|FALSE
return|;
if|if
condition|(
name|group
operator|==
name|grp
operator|->
name|gr_gid
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|mem
operator|++
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|EQ
argument_list|(
name|name
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Check the control message, and see if it's legit. */
end_comment

begin_function
name|STATIC
name|void
name|CheckControl
parameter_list|(
name|ctrl
parameter_list|,
name|pwp
parameter_list|)
name|char
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|save
decl_stmt|;
name|char
name|name
index|[
name|SMBUF
index|]
decl_stmt|;
comment|/* Snip off the first word. */
for|for
control|(
name|p
operator|=
name|ctrl
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
for|for
control|(
name|ctrl
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
name|p
operator|==
name|ctrl
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Empty control message.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|save
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"cancel"
argument_list|)
condition|)
block|{
for|for
control|(
name|q
operator|=
name|p
operator|+
literal|1
init|;
name|ISWHITE
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Message-ID missing in cancel.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Spooling
condition|)
name|CheckCancel
argument_list|(
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"checkgroups"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"ihave"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"sendme"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"newgroup"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"rmgroup"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"sendsys"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"senduuname"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"version"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|pwp
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AnAdministrator
argument_list|(
name|name
argument_list|,
operator|(
name|int
operator|)
name|pwp
operator|->
name|pw_gid
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ask your news administrator to do the \"%s\" for you.\n"
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" is not a valid control message.\n"
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|save
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Parse the GECOS field to get the user's full name.  This comes Sendmail's **  buildfname routine.  Ignore leading stuff like "23-" "stuff]-" or **  "stuff -" as well as trailing whitespace, or anything that comes after **  a comma, semicolon, or in parentheses.  This seems to strip off most of **  the UCB or ATT stuff people fill out the entries with.  Also, turn& **  into the login name, with perhaps an initial capital.  (Everyone seems **  to hate that, but everyone also supports it.) */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|FormatUserName
parameter_list|(
name|pwp
parameter_list|,
name|node
parameter_list|)
name|struct
name|passwd
modifier|*
name|pwp
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|outbuff
index|[
name|SMBUF
index|]
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DONT_MUNGE_GECOS
argument_list|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|outbuff
argument_list|,
name|pwp
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|pwp
operator|->
name|pw_gecos
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|out
operator|=
name|outbuff
init|;
operator|*
name|p
operator|&&
operator|!
name|GECOSTERM
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|out
argument_list|,
name|pwp
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTYPE
argument_list|(
name|islower
argument_list|,
operator|*
name|out
argument_list|)
operator|&&
operator|(
name|out
operator|==
name|outbuff
operator|||
operator|!
name|isalpha
argument_list|(
name|out
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
operator|*
name|out
operator|=
name|toupper
argument_list|(
operator|*
name|out
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|out
condition|)
name|out
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
operator|>
name|pwp
operator|->
name|pw_gecos
operator|&&
operator|(
name|isdigit
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isspace
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
operator|)
condition|)
name|out
operator|=
name|outbuff
expr_stmt|;
else|else
operator|*
name|out
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DONT_MINGE_GECOS) */
name|out
operator|=
name|TrimSpaces
argument_list|(
name|outbuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s@%s (%s)"
argument_list|,
name|pwp
operator|->
name|pw_name
argument_list|,
name|node
argument_list|,
name|out
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s@%s"
argument_list|,
name|pwp
operator|->
name|pw_name
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
name|COPY
argument_list|(
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Check the Distribution header, and exit on error. */
end_comment

begin_function
name|STATIC
name|void
name|CheckDistribution
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|SEPS
index|[]
init|=
literal|" \t,"
decl_stmt|;
specifier|register
name|STRING
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|p
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't parse Distribution line.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|do
block|{
for|for
control|(
name|dp
operator|=
name|BadDistribs
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|wildmat
argument_list|(
name|p
argument_list|,
operator|*
name|dp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Illegal distribution \"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/* **  Process all the headers.  FYI, they're done in RFC-order. */
end_comment

begin_function
name|STATIC
name|void
name|ProcessHeaders
parameter_list|(
name|AddOrg
parameter_list|,
name|linecount
parameter_list|,
name|pwp
parameter_list|)
name|BOOL
name|AddOrg
decl_stmt|;
name|int
name|linecount
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwp
decl_stmt|;
block|{
specifier|static
name|char
name|MONTHS
index|[]
init|=
literal|"JanFebMarAprMayJunJulAugSepOctNovDec"
decl_stmt|;
specifier|static
name|char
name|PATHFLUFF
index|[]
init|=
name|PATHMASTER
decl_stmt|;
specifier|static
name|char
name|SIGNS
index|[]
init|=
literal|"+-"
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|TIMEINFO
name|Now
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|char
name|from
index|[
name|SMBUF
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|zone
decl_stmt|;
comment|/* Do some preliminary fix-ups. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|CanSet
operator|&&
name|hp
operator|->
name|Value
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't set system \"%s\" header.\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
block|{
name|hp
operator|->
name|Value
operator|=
name|TrimSpaces
argument_list|(
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|Value
operator|==
literal|'\0'
condition|)
name|hp
operator|->
name|Value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Set From or Sender. */
if|if
condition|(
operator|(
name|p
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_FROMHOST
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't get host name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR
argument_list|(
name|_from
argument_list|)
operator|==
name|NULL
condition|)
name|HDR
argument_list|(
name|_from
argument_list|)
operator|=
name|FormatUserName
argument_list|(
name|pwp
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s@%s"
argument_list|,
name|pwp
operator|->
name|pw_name
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|from
argument_list|,
name|HDR
argument_list|(
name|_from
argument_list|)
argument_list|)
expr_stmt|;
name|HeaderCleanFrom
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|from
argument_list|,
name|buff
argument_list|)
condition|)
name|HDR
argument_list|(
name|_sender
argument_list|)
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* Set Date. */
if|if
condition|(
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
operator|<
literal|0
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't get the time"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|Now
operator|.
name|time
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't convert to local time"
argument_list|)
expr_stmt|;
comment|/* The %0n.nd contruct from<kre@munnari.oz.au> is clever.  Modern      * printf's treat it %02 (two digits wide) .2 (zero-fill to at least      * two digits), while old versions treat it as %02 (zero-fill two      * digits wide) .2 (noise).  You might want to check this on your      * system. */
if|if
condition|(
name|Now
operator|.
name|tzone
operator|<
literal|0
condition|)
block|{
name|p
operator|=
operator|&
name|SIGNS
index|[
literal|0
index|]
expr_stmt|;
name|zone
operator|=
operator|-
name|Now
operator|.
name|tzone
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|&
name|SIGNS
index|[
literal|1
index|]
expr_stmt|;
name|zone
operator|=
name|Now
operator|.
name|tzone
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d %3.3s %d %02.2d:%02.2d:%02.2d %c%04.4d"
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
operator|&
name|MONTHS
index|[
literal|3
operator|*
name|tm
operator|->
name|tm_mon
index|]
argument_list|,
literal|1900
operator|+
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|,
operator|*
name|p
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|zone
operator|/
literal|60
operator|)
operator|*
literal|100
operator|+
operator|(
name|zone
operator|%
literal|60
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_date
argument_list|)
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* Newsgroups are checked later. */
comment|/* Set Subject; Control overrides the subject. */
if|if
condition|(
name|HDR
argument_list|(
name|_control
argument_list|)
condition|)
block|{
name|CheckControl
argument_list|(
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|,
name|pwp
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_subject
argument_list|)
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
literal|5
operator|+
name|strlen
argument_list|(
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|HDR
argument_list|(
name|_subject
argument_list|)
argument_list|,
literal|"cmsg %s"
argument_list|,
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|HDR
argument_list|(
name|_subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Required \"Subject\" header is missing or empty.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|EQn
argument_list|(
name|p
argument_list|,
literal|"cmsg "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|HDR
argument_list|(
name|_control
argument_list|)
operator|=
name|p
operator|+
literal|5
expr_stmt|;
name|CheckControl
argument_list|(
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|,
name|pwp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HDR
argument_list|(
name|_alsocontrol
argument_list|)
condition|)
name|CheckControl
argument_list|(
name|HDR
argument_list|(
name|_alsocontrol
argument_list|)
argument_list|,
name|pwp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (EQn(p, "Re: ", 4)&& HDR(_references) == NULL) { 	    (void)fprintf(stderr, 		    "Article starts with \"Re: \" but has no references.\n"); 	    QuitServer(1); 	}
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* Set Message-ID */
if|if
condition|(
name|HDR
argument_list|(
name|_messageid
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|GenerateMessageID
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't generate Message-ID, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|HDR
argument_list|(
name|_messageid
argument_list|)
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|HDR
argument_list|(
name|_messageid
argument_list|)
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|strchr
argument_list|(
operator|++
name|p
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Message-ID must have exactly one '@'\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set Path */
if|if
condition|(
name|HDR
argument_list|(
name|_path
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|Exclusions
argument_list|)
operator|+
name|STRLEN
argument_list|(
name|PATHFLUFF
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_INEWS_PATH
argument_list|)
if|if
condition|(
operator|(
name|p
operator|=
name|GetFileConfigValue
argument_list|(
name|_CONF_PATHHOST
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|i
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|HDR
argument_list|(
name|_path
argument_list|)
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|HDR
argument_list|(
name|_path
argument_list|)
argument_list|,
literal|"%s%s!%s"
argument_list|,
name|Exclusions
argument_list|,
name|p
argument_list|,
name|PATHFLUFF
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|HDR
argument_list|(
name|_path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|Exclusions
argument_list|,
name|PATHFLUFF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GetFileConfigValue
argument_list|(
name|_CONF_SERVER
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|GetFQDN
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get host name, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
name|HDR
argument_list|(
name|_path
argument_list|)
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|HDR
argument_list|(
name|_path
argument_list|)
argument_list|,
literal|"%s%s!%s"
argument_list|,
name|Exclusions
argument_list|,
name|p
argument_list|,
name|PATHFLUFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HDR
argument_list|(
name|_path
argument_list|)
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|HDR
argument_list|(
name|_path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|Exclusions
argument_list|,
name|PATHFLUFF
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|HDR
argument_list|(
name|_path
argument_list|)
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|HDR
argument_list|(
name|_path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|Exclusions
argument_list|,
name|PATHFLUFF
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_INEWS_PATH) */
block|}
comment|/* Reply-To; left alone. */
comment|/* Sender; set above. */
comment|/* Followup-To; checked with Newsgroups. */
comment|/* Check Expires. */
if|if
condition|(
name|HDR
argument_list|(
name|_expires
argument_list|)
operator|&&
name|parsedate
argument_list|(
name|HDR
argument_list|(
name|_expires
argument_list|)
argument_list|,
operator|&
name|Now
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't parse \"%s\" as an expiration date.\n"
argument_list|,
name|HDR
argument_list|(
name|_expires
argument_list|)
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* References; left alone. */
comment|/* Control; checked above. */
comment|/* Distribution. */
if|if
condition|(
operator|(
name|p
operator|=
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|CheckDistribution
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Set Organization. */
if|if
condition|(
name|AddOrg
operator|&&
name|HDR
argument_list|(
name|_organization
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_ORGANIZATION
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|HDR
argument_list|(
name|_organization
argument_list|)
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Keywords; left alone. */
comment|/* Summary; left alone. */
comment|/* Approved; left alone. */
comment|/* Set Lines */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d"
argument_list|,
name|linecount
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_lines
argument_list|)
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* Check Supersedes. */
if|if
condition|(
name|HDR
argument_list|(
name|_supersedes
argument_list|)
condition|)
name|CheckCancel
argument_list|(
name|HDR
argument_list|(
name|_supersedes
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Now make sure everything is there. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Type
operator|==
name|HTreq
operator|&&
name|hp
operator|->
name|Value
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Required \"%s\" header is missing or empty.\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Try to append $HOME/.signature to the article.  When in doubt, exit **  out in order to avoid postings like "Sorry, I forgot my .signature **  -- here's the article again." */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|AppendSignature
parameter_list|(
name|UseMalloc
parameter_list|,
name|article
parameter_list|,
name|homedir
parameter_list|,
name|linesp
parameter_list|)
name|BOOL
name|UseMalloc
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|;
name|int
modifier|*
name|linesp
decl_stmt|;
block|{
specifier|static
name|char
name|NOSIG
index|[]
init|=
literal|"Can't add your .signature (%s), article not posted"
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
comment|/* Open the file. */
operator|*
name|linesp
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/.signature"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|buff
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
name|article
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOSIG
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Read it in. */
name|length
operator|=
name|fread
argument_list|(
operator|(
name|POINTER
operator|)
name|buff
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
sizeof|sizeof
name|buff
operator|-
literal|2
argument_list|,
name|F
argument_list|)
expr_stmt|;
name|i
operator|=
name|feof
argument_list|(
name|F
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOSIG
argument_list|,
literal|"empty file"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOSIG
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
sizeof|sizeof
name|buff
operator|-
literal|2
operator|&&
operator|!
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOSIG
argument_list|,
literal|"too big"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the buffer ends with \n\0. */
if|if
condition|(
name|buff
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|buff
index|[
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buff
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Count the lines. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buff
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|++
name|i
operator|>
name|SIG_MAXLINES
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|NOSIG
argument_list|,
literal|"too many lines"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|linesp
operator|=
literal|1
operator|+
name|i
expr_stmt|;
comment|/* Grow the article to have the signature. */
name|i
operator|=
name|strlen
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|if
condition|(
name|UseMalloc
condition|)
block|{
name|p
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
operator|(
sizeof|sizeof
name|SIGSEP
operator|-
literal|1
operator|)
operator|+
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|article
argument_list|)
expr_stmt|;
name|article
operator|=
name|p
expr_stmt|;
block|}
else|else
name|RENEW
argument_list|(
name|article
argument_list|,
name|char
argument_list|,
name|i
operator|+
operator|(
sizeof|sizeof
name|SIGSEP
operator|-
literal|1
operator|)
operator|+
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|article
index|[
name|i
index|]
argument_list|,
name|SIGSEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|article
index|[
name|i
operator|+
sizeof|sizeof
name|SIGSEP
operator|-
literal|1
index|]
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
name|article
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_CHECK_INCLUDED_TEXT
argument_list|)
end_if

begin_comment
comment|/* **  See if the user has more included text than new text.  Simple-minded, but **  reasonably effective for catching neophyte's mistakes.  A line starting **  with> is included text.  Decrement the count on lines starting with< **  so that we don't reject diff(1) output. */
end_comment

begin_function
name|STATIC
name|void
name|CheckIncludedText
parameter_list|(
name|p
parameter_list|,
name|lines
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|lines
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'>'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|i
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|*
literal|2
operator|>
name|lines
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article not posted -- more included text than new text\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_CHECK_INCLUDED_TEXT) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  Try to mail an article to the moderator of the group. */
end_comment

begin_function
name|STATIC
name|BOOL
name|MailArticle
parameter_list|(
name|group
parameter_list|,
name|article
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
comment|/* Try to get the address first. */
if|if
condition|(
operator|(
name|address
operator|=
name|GetModeratorAddress
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The \"%s\" newsgroup is moderated, but has no address;\n"
argument_list|,
name|group
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ask your news administrator to fix this.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Say what we're going to do. */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"The \"%s\" newsgroup is moderated.  Your article will not be\n"
argument_list|,
name|group
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"posted, but mailed to the moderator for approval.\n"
argument_list|)
expr_stmt|;
comment|/* Now build up the command (ignore format/argument mismatch errors,      * in case %s isn't in _PATH_SENDMAIL) and send the headers. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_PATH_SENDMAIL
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|popen
argument_list|(
name|buff
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't start mailer"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"To: %s\n"
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|F
argument_list|)
expr_stmt|;
comment|/* Write the headers, a blank line, then the article. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s\n"
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|POINTER
operator|)
name|article
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|,
name|F
argument_list|)
operator|!=
name|i
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't send article"
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|F
argument_list|)
expr_stmt|;
name|i
operator|=
name|pclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Mailer exited with status %d;\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article might not have been mailed.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Check the newsgroups, make sure they're all valid, that none are **  moderated, etc. */
end_comment

begin_function
name|STATIC
name|BOOL
name|ValidNewsgroups
parameter_list|(
name|hdr
parameter_list|,
name|F
parameter_list|,
name|article
parameter_list|)
name|char
modifier|*
name|hdr
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|groups
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|BOOL
name|approved
decl_stmt|;
name|BOOL
name|mailed
decl_stmt|;
name|BOOL
name|FoundOne
decl_stmt|;
name|char
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|struct
name|_DDHANDLE
modifier|*
name|h
decl_stmt|;
name|BOOL
name|IsNewgroup
decl_stmt|;
name|p
operator|=
name|HDR
argument_list|(
name|_control
argument_list|)
expr_stmt|;
name|IsNewgroup
operator|=
name|p
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"newgroup"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|groups
operator|=
name|COPY
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|groups
argument_list|,
name|NGSEPS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't parse newsgroups line.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Don't mail article if just checking Followup-To line. */
name|approved
operator|=
name|HDR
argument_list|(
name|_approved
argument_list|)
operator|!=
name|NULL
operator|||
name|article
operator|==
name|NULL
expr_stmt|;
name|FoundOne
operator|=
name|FALSE
expr_stmt|;
name|h
operator|=
name|DDstart
argument_list|(
name|FromServer
argument_list|,
name|ToServer
argument_list|)
expr_stmt|;
do|do
block|{
if|#
directive|if
name|defined
argument_list|(
name|DO_MERGE_TO_GROUPS
argument_list|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
name|p
operator|=
literal|"to"
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_MERGE_TO_GROUPS) */
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|F
argument_list|,
operator|(
name|OFFSET_T
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
operator|*
name|p
operator|&&
name|EQn
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
operator|&&
name|buff
index|[
name|i
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|feof
argument_list|(
name|F
argument_list|)
condition|)
continue|continue;
name|FoundOne
operator|=
name|TRUE
expr_stmt|;
name|DDcheck
argument_list|(
name|h
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Skip past the newsgroup name, the high and low counts, to find 	 * the flags. */
for|for
control|(
name|group
operator|=
name|p
operator|,
name|p
operator|=
operator|&
name|buff
index|[
name|i
index|]
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|NF_FLAG_OK
case|:
break|break;
case|case
name|NF_FLAG_MODERATED
case|:
if|if
condition|(
name|Dump
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s is moderated -- article would be mailed\n"
argument_list|,
name|group
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|approved
condition|)
block|{
name|mailed
operator|=
name|MailArticle
argument_list|(
name|group
argument_list|,
name|article
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|DDend
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
name|mailed
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NF_FLAG_IGNORE
case|:
case|case
name|NF_FLAG_NOLOCAL
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Postings to \"%s\" are not allowed here.\n"
argument_list|,
name|group
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|DDend
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
name|NF_FLAG_EXCLUDED
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning:  \"%s\" is rejected here.\n"
argument_list|,
name|group
argument_list|)
expr_stmt|;
comment|/* Do NOT return false. */
break|break;
case|case
name|NF_FLAG_ALIAS
case|:
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The newsgroup \"%s\" has been renamed to \"%s\".\n"
argument_list|,
name|group
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|DDend
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|NGSEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
operator|!
name|FoundOne
operator|&&
operator|!
name|IsNewgroup
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No such newsgroups as \"%s\".\n"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|DDend
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Set default distribution. */
name|p
operator|=
name|DDend
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|==
name|NULL
operator|&&
operator|*
name|p
condition|)
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|=
name|p
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Read stdin into a string and return it.  Can't use ReadInDescriptor **  since that will fail if stdin is a tty. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|ReadStdin
parameter_list|()
block|{
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|size
operator|=
name|BUFSIZ
expr_stmt|;
name|article
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
name|article
index|[
name|size
operator|-
literal|3
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|article
init|;
operator|(
name|i
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
condition|;
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|i
control|)
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|RENEW
argument_list|(
name|article
argument_list|,
name|char
argument_list|,
name|size
operator|+
name|BUFSIZ
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|article
index|[
name|size
operator|-
literal|3
index|]
expr_stmt|;
name|size
operator|+=
name|BUFSIZ
expr_stmt|;
name|end
operator|=
operator|&
name|article
index|[
name|size
operator|-
literal|3
index|]
expr_stmt|;
block|}
comment|/* Force a \n terminator. */
if|if
condition|(
name|p
operator|>
name|article
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|article
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Offer the article to the server, return its reply. */
end_comment

begin_function
name|STATIC
name|int
name|OfferArticle
parameter_list|(
name|buff
parameter_list|,
name|Authorized
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|BOOL
name|Authorized
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"post\r\n"
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
name|NNTP_STRLEN
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
name|Authorized
condition|?
literal|"Can't offer article to server (authorized)"
else|:
literal|"Can't offer article to server"
argument_list|)
expr_stmt|;
return|return
name|atoi
argument_list|(
name|buff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Make a temporary filename that is unlikely to collide with mktemp **  or cause problems for sites with 14-character filename limits. */
end_comment

begin_function
name|STATIC
name|void
name|TempName
parameter_list|(
name|dir
parameter_list|,
name|buff
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|time_t
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|now
operator|&=
literal|0xFFFFFFFF
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%08.8lxXXXXXX"
argument_list|,
name|dir
argument_list|,
operator|(
name|long
operator|)
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Spool article to temp file. */
end_comment

begin_function
name|STATIC
name|void
name|Spoolit
parameter_list|(
name|article
parameter_list|,
name|Length
parameter_list|,
name|deadfile
parameter_list|)
name|char
modifier|*
name|article
decl_stmt|;
name|SIZE_T
name|Length
decl_stmt|;
name|char
modifier|*
name|deadfile
decl_stmt|;
block|{
specifier|static
name|char
name|SPOOLTEMP
index|[]
init|=
name|_PATH_SPOOLTEMP
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|temp
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
comment|/* Try to write to the spool dir, else the deadfile. */
if|if
condition|(
operator|(
name|stat
argument_list|(
name|SPOOLNEWS
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
operator|)
operator|||
operator|(
name|F
operator|=
name|xfopena
argument_list|(
name|deadfile
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|TempName
argument_list|(
name|SPOOLTEMP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|open
argument_list|(
name|temp
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
name|BATCHFILE_MODE
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|F
operator|=
name|fdopen
argument_list|(
name|i
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|FALSE
argument_list|,
literal|"Can't create spool file"
argument_list|)
expr_stmt|;
name|deadfile
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Write the headers and a blank line. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s\n"
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|stdout
argument_list|)
condition|)
name|PerrorExit
argument_list|(
name|FALSE
argument_list|,
literal|"Can't write headers"
argument_list|)
expr_stmt|;
comment|/* Write the article and exit. */
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|POINTER
operator|)
name|article
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
name|Length
argument_list|,
name|F
argument_list|)
operator|!=
name|Length
condition|)
name|PerrorExit
argument_list|(
name|FALSE
argument_list|,
literal|"Can't write article"
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|F
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
name|PerrorExit
argument_list|(
name|FALSE
argument_list|,
literal|"Can't close spool file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|deadfile
operator|==
name|NULL
condition|)
block|{
comment|/* Put the file in a good place. */
name|TempName
argument_list|(
name|SPOOLNEWS
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|temp
argument_list|,
name|buff
argument_list|)
operator|<
literal|0
condition|)
name|PerrorExit
argument_list|(
name|FALSE
argument_list|,
literal|"Can't rename spool file"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Print usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: inews [-D] [-h] [header_flags] [article]\n"
argument_list|)
expr_stmt|;
comment|/* Don't call QuitServer here -- connection isn't open yet. */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|NOCONNECT
index|[]
init|=
literal|"Can't connect to server"
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|Mode
decl_stmt|;
name|int
name|SigLines
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwp
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
name|char
modifier|*
name|deadfile
decl_stmt|;
name|char
name|buff
index|[
name|NNTP_STRLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|SpoolMessage
index|[
name|NNTP_STRLEN
operator|+
literal|2
index|]
decl_stmt|;
name|BOOL
name|DoSignature
decl_stmt|;
name|BOOL
name|AddOrg
decl_stmt|;
name|SIZE_T
name|Length
decl_stmt|;
comment|/* Find out who we are. */
if|if
condition|(
operator|(
name|i
operator|=
name|geteuid
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't get your user ID"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pwp
operator|=
name|getpwuid
argument_list|(
operator|(
name|UID_T
operator|)
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't get your password entry"
argument_list|)
expr_stmt|;
comment|/* Set defaults. */
name|Mode
operator|=
literal|'\0'
expr_stmt|;
name|Dump
operator|=
name|FALSE
expr_stmt|;
name|DoSignature
operator|=
name|TRUE
expr_stmt|;
name|AddOrg
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"DNAVWORShx:a:c:d:e:f:n:r:t:F:o:w:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'D'
case|:
case|case
literal|'N'
case|:
name|Dump
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
comment|/* Ignore C News options. */
break|break;
case|case
literal|'O'
case|:
name|AddOrg
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|Revoked
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|DoSignature
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|Mode
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|Exclusions
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Exclusions
argument_list|,
literal|"%s!"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* Header lines that can be specified on the command line. */
case|case
literal|'a'
case|:
name|HDR
argument_list|(
name|_approved
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|HDR
argument_list|(
name|_control
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|HDR
argument_list|(
name|_expires
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|HDR
argument_list|(
name|_from
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|HDR
argument_list|(
name|_replyto
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|HDR
argument_list|(
name|_subject
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|HDR
argument_list|(
name|_references
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|HDR
argument_list|(
name|_organization
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|HDR
argument_list|(
name|_followupto
argument_list|)
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
comment|/* Parse positional arguments; at most one, the input file. */
switch|switch
condition|(
name|ac
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
comment|/* Read stdin. */
name|article
operator|=
name|ReadStdin
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Read named file. */
name|article
operator|=
name|ReadInFile
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|article
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|FALSE
argument_list|,
literal|"Can't read input file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Try to open a connection to the server. */
if|if
condition|(
name|NNTPremoteopen
argument_list|(
operator|&
name|FromServer
argument_list|,
operator|&
name|ToServer
argument_list|,
name|buff
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Spooling
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|SpoolMessage
argument_list|,
name|buff
index|[
literal|0
index|]
condition|?
name|buff
else|:
name|NOCONNECT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/dead.article"
argument_list|,
name|pwp
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|deadfile
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we can post. */
name|i
operator|=
name|atoi
argument_list|(
name|buff
argument_list|)
expr_stmt|;
comment|/* Tell the server we're posting. */
name|setbuf
argument_list|(
name|FromServer
argument_list|,
name|NEW
argument_list|(
name|char
argument_list|,
name|BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|ToServer
argument_list|,
name|NEW
argument_list|(
name|char
argument_list|,
name|BUFSIZ
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"mode reader\r\n"
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
name|NNTP_STRLEN
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't tell server we're reading"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|atoi
argument_list|(
name|buff
argument_list|)
operator|)
operator|!=
name|NNTP_BAD_COMMAND_VAL
condition|)
name|i
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|NNTP_POSTOK_VAL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You do not have permission to post.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Basic processing. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
name|hp
operator|->
name|Size
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mode
operator|==
literal|'h'
condition|)
name|article
operator|=
name|StripOffHeaders
argument_list|(
name|article
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|article
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
continue|continue;
if|#
directive|if
name|defined
argument_list|(
name|DO_CHECK_INCLUDED_TEXT
argument_list|)
name|CheckIncludedText
argument_list|(
name|article
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_CHECK_INCLUDED_TEXT) */
if|if
condition|(
name|DoSignature
condition|)
name|article
operator|=
name|AppendSignature
argument_list|(
name|Mode
operator|==
literal|'h'
argument_list|,
name|article
argument_list|,
name|pwp
operator|->
name|pw_dir
argument_list|,
operator|&
name|SigLines
argument_list|)
expr_stmt|;
else|else
name|SigLines
operator|=
literal|0
expr_stmt|;
name|ProcessHeaders
argument_list|(
name|AddOrg
argument_list|,
name|i
operator|+
name|SigLines
argument_list|,
name|pwp
argument_list|)
expr_stmt|;
name|Length
operator|=
name|strlen
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|#
directive|if
name|LOCAL_MAX_ARTSIZE
operator|>
literal|0
if|if
condition|(
name|Length
operator|>
name|LOCAL_MAX_ARTSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article is bigger then local limit of %ld bytes\n"
argument_list|,
name|LOCAL_MAX_ARTSIZE
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCAL_MAX_ARTSIZE> 0 */
comment|/* Do final checks. */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|HDR
argument_list|(
name|_control
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Article is empty.\n"
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|hp
operator|->
name|Value
argument_list|)
operator|+
name|hp
operator|->
name|Size
operator|>
name|NNTP_STRLEN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\" header is too long.\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
operator|>
name|NNTP_STRLEN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Header too long (%d characters max):\n\t%40.40s...\n"
argument_list|,
name|NNTP_STRLEN
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check the newsgroups. */
if|if
condition|(
operator|(
name|F
operator|=
name|CAlistopen
argument_list|(
name|FromServer
argument_list|,
name|ToServer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|ValidNewsgroups
argument_list|(
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
argument_list|,
name|F
argument_list|,
name|article
argument_list|)
condition|)
block|{
name|CAclose
argument_list|()
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|HDR
argument_list|(
name|_followupto
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|EQ
argument_list|(
name|p
argument_list|,
literal|"poster"
argument_list|)
operator|&&
operator|!
name|ValidNewsgroups
argument_list|(
name|p
argument_list|,
name|F
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
condition|)
block|{
name|CAclose
argument_list|()
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CAclose
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|Spooling
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't get list of newsgroups"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dump
condition|)
block|{
comment|/* Write the headers and a blank line. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|stdout
argument_list|)
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't write headers"
argument_list|)
expr_stmt|;
comment|/* Write the article and exit. */
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|POINTER
operator|)
name|article
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
name|Length
argument_list|,
name|stdout
argument_list|)
operator|!=
name|Length
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't write article"
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Spooling
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning %s -- Article will be spooled.\n"
argument_list|,
name|SpoolMessage
argument_list|)
expr_stmt|;
name|Spoolit
argument_list|(
name|article
argument_list|,
name|Length
argument_list|,
name|deadfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Article is prepared, offer it to the server. */
name|i
operator|=
name|OfferArticle
argument_list|(
name|buff
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NNTP_AUTH_NEEDED_VAL
condition|)
block|{
comment|/* Posting not allowed, try to authorize. */
if|if
condition|(
name|NNTPsendpassword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FromServer
argument_list|,
name|ToServer
argument_list|)
operator|<
literal|0
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Authorization error"
argument_list|)
expr_stmt|;
name|i
operator|=
name|OfferArticle
argument_list|(
name|buff
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|NNTP_START_POST_VAL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Server doesn't want the article:\n\t%s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write the headers, a blank line, then the article. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"%s: %s\r\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"%s\r\n"
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NNTPsendarticle
argument_list|(
name|article
argument_list|,
name|ToServer
argument_list|,
name|TRUE
argument_list|)
operator|<
literal|0
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"Can't send article to server"
argument_list|)
expr_stmt|;
name|SafeFlush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
condition|)
name|PerrorExit
argument_list|(
name|TRUE
argument_list|,
literal|"No reply from server after sending the article"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atoi
argument_list|(
name|buff
argument_list|)
operator|!=
name|NNTP_POSTEDOK_VAL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't send article to the server:\n\t%s\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|QuitServer
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Close up. */
name|QuitServer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

