begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.8 $ ** **  Expire news articles. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"dbz.h"
end_include

begin_include
include|#
directive|include
file|"qio.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_comment
comment|/* **  Hashing functions.  See innd for comments. */
end_comment

begin_define
define|#
directive|define
name|NGH_HASH
parameter_list|(
name|Name
parameter_list|,
name|p
parameter_list|,
name|j
parameter_list|)
define|\
value|for (p = Name, j = 0; *p; ) j = (j<< 5) + j + *p++
end_define

begin_define
define|#
directive|define
name|NGH_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|NGH_BUCKET
parameter_list|(
name|j
parameter_list|)
value|&NGHtable[j& (NGH_SIZE - 1)]
end_define

begin_typedef
typedef|typedef
struct|struct
name|_NGHASH
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
name|struct
name|_NEWSGROUP
modifier|*
modifier|*
name|Groups
decl_stmt|;
block|}
name|NGHASH
typedef|;
end_typedef

begin_comment
comment|/* **  A site has a filename, and flag saying if we already sent it here. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_SITE
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|char
modifier|*
modifier|*
name|Exclusions
decl_stmt|;
name|char
modifier|*
name|Patterns
decl_stmt|;
name|char
modifier|*
modifier|*
name|Distributions
decl_stmt|;
name|char
modifier|*
name|Flags
decl_stmt|;
name|BOOL
name|Sent
decl_stmt|;
block|}
name|SITE
typedef|;
end_typedef

begin_comment
comment|/* **  A newsgroup has a name, and a set of sites that get the group. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_NEWSGROUP
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|char
name|Flag
decl_stmt|;
name|int
name|nSites
decl_stmt|;
name|SITE
modifier|*
modifier|*
name|Sites
decl_stmt|;
block|}
name|NEWSGROUP
typedef|;
end_typedef

begin_comment
comment|/* **  Bit array, indexed by character (8bit chars only).  If ARTpathbits['x'] **  is non-zero, then 'x' is a valid character for a host name. */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|ARTpathbits
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARThostchar
parameter_list|(
name|c
parameter_list|)
value|(ARTpathbits[(c)] != '\0')
end_define

begin_comment
comment|/* **  Global variables. */
end_comment

begin_decl_stmt
name|STATIC
name|SITE
modifier|*
name|Sites
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|nSites
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|NEWSGROUP
modifier|*
name|Groups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|nGroups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|Epoch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|NGHASH
name|NGHtable
index|[
name|NGH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **  Get the next filename from the history file. */
end_comment

begin_function
name|STATIC
name|BOOL
name|GetName
parameter_list|(
name|F
parameter_list|,
name|buff
parameter_list|)
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|char
modifier|*
name|buff
decl_stmt|;
block|{
specifier|static
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Skip whitespace before filename. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|F
argument_list|)
operator|)
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
name|FALSE
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|SPOOL
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|buff
index|[
name|STRLEN
argument_list|(
name|SPOOL
argument_list|)
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|F
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|*
name|p
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|c
operator|==
literal|'.'
condition|?
literal|'/'
else|:
name|c
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Find an existing file for the specified Message-ID, and return the **  open file pointer or NULL. */
end_comment

begin_function
name|STATIC
name|FILE
modifier|*
name|FindFile
parameter_list|(
name|F
parameter_list|,
name|id
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|F
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
name|BADLINE
index|[]
init|=
literal|"Bad text line for \"%s\", %s\n"
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|art
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|val
decl_stmt|;
name|OFFSET_T
name|offset
decl_stmt|;
name|char
name|date
index|[
name|SMBUF
index|]
decl_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|id
argument_list|)
operator|+
literal|1
expr_stmt|;
name|key
operator|.
name|dptr
operator|=
name|id
expr_stmt|;
comment|/* Do the lookup. */
name|val
operator|=
name|dbzfetch
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|dptr
operator|==
name|NULL
operator|||
name|val
operator|.
name|dsize
operator|!=
sizeof|sizeof
name|offset
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find \"%s\"\n"
argument_list|,
name|key
operator|.
name|dptr
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Get the seek offset, and seek. */
for|for
control|(
name|p
operator|=
name|val
operator|.
name|dptr
operator|,
name|q
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|offset
operator|,
name|i
operator|=
sizeof|sizeof
name|offset
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|F
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't seek to %ld, %s\n"
argument_list|,
name|offset
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|Epoch
condition|)
block|{
comment|/* Skip forward to the date. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|F
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|HIS_FIELDSEP
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
name|HIS_FIELDSEP
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|BADLINE
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|p
operator|=
name|date
init|;
operator|(
name|c
operator|==
name|getc
argument_list|(
name|F
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
name|c
argument_list|)
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|BADLINE
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|atol
argument_list|(
name|date
argument_list|)
operator|<
name|Epoch
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* Move to the filename fields. */
for|for
control|(
name|i
operator|=
literal|2
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|F
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|;
control|)
if|if
condition|(
name|c
operator|==
name|HIS_FIELDSEP
operator|&&
operator|--
name|i
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
name|HIS_FIELDSEP
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|BADLINE
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* Loop over all possible files. */
while|while
condition|(
name|GetName
argument_list|(
name|F
argument_list|,
name|name
argument_list|)
condition|)
if|if
condition|(
operator|(
name|art
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|art
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Read the active file and fill in the Groups array.  Note that **  NEWSGROUP.Sites is filled in later. */
end_comment

begin_function
name|STATIC
name|void
name|ParseActive
parameter_list|(
name|name
parameter_list|)
name|STRING
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|active
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|j
decl_stmt|;
specifier|register
name|NGHASH
modifier|*
name|htp
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|int
name|NGHbuckets
decl_stmt|;
comment|/* Read the file, count the number of groups. */
if|if
condition|(
operator|(
name|active
operator|=
name|ReadInFile
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read \"%s\", %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|active
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
continue|continue;
name|nGroups
operator|=
name|i
expr_stmt|;
name|Groups
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Set up the default hash buckets. */
name|NGHbuckets
operator|=
name|i
operator|/
name|NGH_SIZE
expr_stmt|;
if|if
condition|(
name|NGHbuckets
operator|==
literal|0
condition|)
name|NGHbuckets
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NGH_SIZE
operator|,
name|htp
operator|=
name|NGHtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
block|{
name|htp
operator|->
name|Size
operator|=
name|NGHbuckets
expr_stmt|;
name|htp
operator|->
name|Groups
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|htp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Fill in the newsgroups array. */
for|for
control|(
name|p
operator|=
name|active
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|=
name|q
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Missing newline near \"%.10s...\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|ngp
operator|->
name|Name
operator|=
name|p
expr_stmt|;
name|ngp
operator|->
name|nSites
operator|=
literal|0
expr_stmt|;
comment|/* Get the first character after the third space. */
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
operator|++
name|j
operator|==
literal|3
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad format near \"%.10s...\"\n"
argument_list|,
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ngp
operator|->
name|Flag
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
comment|/* Find the right bucket for the group, make sure there is room. */
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|p
operator|=
name|strchr
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|NGH_HASH
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|NGH_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|htp
operator|->
name|Used
operator|>=
name|htp
operator|->
name|Size
condition|)
block|{
name|htp
operator|->
name|Size
operator|+=
name|NGHbuckets
expr_stmt|;
name|RENEW
argument_list|(
name|htp
operator|->
name|Groups
argument_list|,
name|NEWSGROUP
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
name|htp
operator|->
name|Groups
index|[
name|htp
operator|->
name|Used
operator|++
index|]
operator|=
name|ngp
expr_stmt|;
block|}
comment|/* Note that we don't bother to sort the buckets. */
block|}
end_function

begin_comment
comment|/* **  Split text into comma-separated fields. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
modifier|*
name|CommaSplit
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|save
decl_stmt|;
comment|/* How much space do we need? */
for|for
control|(
name|i
operator|=
literal|2
operator|,
name|p
operator|=
name|text
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
name|argv
operator|=
name|save
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
argument_list|)
operator|,
operator|*
name|argv
operator|++
operator|=
name|p
operator|=
name|text
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|argv
operator|++
operator|=
name|p
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Read the newsfeeds file and fill in the Sites array.  Finish off the **  Groups array. */
end_comment

begin_function
name|STATIC
name|void
name|ParseNewsfeeds
parameter_list|(
name|name
parameter_list|)
name|STRING
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|char
modifier|*
name|newsfeeds
decl_stmt|;
comment|/* Read in the file, get a gross count of the number of sites. */
if|if
condition|(
operator|(
name|newsfeeds
operator|=
name|ReadInFile
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read \"%s\", %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|newsfeeds
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
continue|continue;
comment|/* Scan the file, parse all multi-line entries. */
for|for
control|(
name|strings
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|,
name|i
operator|=
literal|0
operator|,
name|to
operator|=
name|p
operator|=
name|newsfeeds
init|;
operator|*
name|p
condition|;
control|)
block|{
for|for
control|(
name|save
operator|=
name|to
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
name|p
operator|++
expr_stmt|;
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
while|while
condition|(
operator|*
operator|++
name|p
operator|&&
name|CTYPE
argument_list|(
name|isspace
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|to
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|save
operator|==
name|COMMENT_CHAR
operator|||
operator|*
name|save
operator|==
literal|'\0'
condition|)
continue|continue;
name|strings
index|[
name|i
operator|++
index|]
operator|=
name|COPY
argument_list|(
name|save
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|newsfeeds
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No sites.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get space for the sites. */
name|nSites
operator|=
name|i
expr_stmt|;
name|Sites
operator|=
name|NEW
argument_list|(
name|SITE
argument_list|,
name|nSites
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nGroups
operator|,
name|ngp
operator|=
name|Groups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
name|ngp
operator|->
name|Sites
operator|=
name|NEW
argument_list|(
name|SITE
operator|*
argument_list|,
name|nSites
argument_list|)
expr_stmt|;
comment|/* Do initial processing of the site entries. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sp
operator|=
name|Sites
init|;
name|i
operator|<
name|nSites
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
comment|/* Nip off the first and second fields. */
name|sp
operator|->
name|Name
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Name
argument_list|,
name|NF_FIELD_SEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No separator for site \"%.10s...\"\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Patterns
operator|=
name|p
expr_stmt|;
comment|/* Nip off the third field. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Patterns
argument_list|,
name|NF_FIELD_SEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No flags for site \"%s\"\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Flags
operator|=
name|p
expr_stmt|;
comment|/* Nip off the last field, build the filename. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Flags
argument_list|,
name|NF_FIELD_SEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No last field for site \"%s\"\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Handle the subfields. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Name
argument_list|,
name|NF_SUBFIELD_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Exclusions
operator|=
name|CommaSplit
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|Exclusions
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|sp
operator|->
name|Patterns
argument_list|,
name|NF_SUBFIELD_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|->
name|Distributions
operator|=
name|CommaSplit
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|sp
operator|->
name|Distributions
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Build the subscription list for a site. */
end_comment

begin_function
name|STATIC
name|void
name|BuildSubList
parameter_list|(
name|sp
parameter_list|,
name|subbed
parameter_list|)
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|subbed
decl_stmt|;
block|{
specifier|static
name|char
name|SEPS
index|[]
init|=
literal|","
decl_stmt|;
specifier|register
name|char
name|subvalue
decl_stmt|;
specifier|register
name|char
modifier|*
name|pat
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|BOOL
name|JustModerated
decl_stmt|;
name|BOOL
name|JustUnmoderated
decl_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|sp
operator|->
name|Name
argument_list|,
literal|"ME"
argument_list|)
condition|)
return|return;
comment|/* Fill in the subbed array with the mask of groups. */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
name|subbed
argument_list|,
name|SUB_DEFAULT
argument_list|,
operator|(
name|SIZE_T
operator|)
name|nGroups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pat
operator|=
name|strtok
argument_list|(
name|sp
operator|->
name|Patterns
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|do
block|{
name|subvalue
operator|=
operator|*
name|pat
operator|!=
name|SUB_NEGATE
expr_stmt|;
if|if
condition|(
operator|!
name|subvalue
condition|)
name|pat
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|wildmat
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|pat
argument_list|)
condition|)
operator|*
name|p
operator|=
name|subvalue
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pat
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* Parse the flags.. */
name|JustModerated
operator|=
name|FALSE
expr_stmt|;
name|JustUnmoderated
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|sp
operator|->
name|Flags
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|do
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'W'
case|:
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
literal|"Wnm"
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ignoring \"%s\" flag for \"%s\"\n"
argument_list|,
name|p
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
while|while
condition|(
operator|*
operator|++
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown N%c flag for \"%s\"\n"
argument_list|,
operator|*
name|p
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|JustModerated
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|JustUnmoderated
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'T'
case|:
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* Modify the subscription list based on the flags. */
if|if
condition|(
name|JustModerated
condition|)
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|ngp
operator|->
name|Flag
operator|!=
name|NF_FLAG_MODERATED
condition|)
operator|*
name|p
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|JustUnmoderated
condition|)
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|ngp
operator|->
name|Flag
operator|==
name|NF_FLAG_MODERATED
condition|)
operator|*
name|p
operator|=
name|FALSE
expr_stmt|;
comment|/* Tell the groups that this site gets that they should feed this site. */
for|for
control|(
name|p
operator|=
name|subbed
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|++
condition|)
name|ngp
operator|->
name|Sites
index|[
name|ngp
operator|->
name|nSites
operator|++
index|]
operator|=
name|sp
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|STATIC
name|NEWSGROUP
modifier|*
name|NGfind
parameter_list|(
name|Name
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
modifier|*
name|ngp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|NGHASH
modifier|*
name|htp
decl_stmt|;
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|NGH_HASH
argument_list|(
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|NGH_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|Name
operator|,
name|ngp
operator|=
name|htp
operator|->
name|Groups
operator|,
name|i
operator|=
name|htp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|ngp
index|[
literal|0
index|]
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|EQ
argument_list|(
name|Name
argument_list|,
name|ngp
index|[
literal|0
index|]
operator|->
name|Name
argument_list|)
condition|)
return|return
name|ngp
index|[
literal|0
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Split up the Path line. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
modifier|*
name|ParsePath
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|save
decl_stmt|;
specifier|static
name|int
name|oldlength
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|hosts
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
if|if
condition|(
name|save
condition|)
name|DISPOSE
argument_list|(
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
name|save
operator|=
name|p
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
operator|*
name|nl
operator|=
literal|'\n'
expr_stmt|;
comment|/* Get an array of character pointers. */
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts
operator|==
name|NULL
condition|)
block|{
name|hosts
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oldlength
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldlength
operator|<
name|i
condition|)
block|{
name|RENEW
argument_list|(
name|hosts
argument_list|,
name|char
operator|*
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oldlength
operator|=
name|i
expr_stmt|;
block|}
comment|/* Loop over text. */
for|for
control|(
name|hp
operator|=
name|hosts
init|;
operator|*
name|p
condition|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
control|)
block|{
comment|/* Skip leading separators. */
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|ARThostchar
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Mark the start of the host, move to the end of it. */
for|for
control|(
operator|*
name|hp
operator|++
operator|=
name|p
init|;
operator|*
name|p
operator|&&
name|ARThostchar
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
block|}
operator|*
name|hp
operator|=
name|NULL
expr_stmt|;
return|return
name|hosts
return|;
block|}
end_function

begin_comment
comment|/* **  Has this site or its excludes already been seen? */
end_comment

begin_function
name|STATIC
name|BOOL
name|Seen
parameter_list|(
name|sp
parameter_list|,
name|Path
parameter_list|)
name|SITE
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
modifier|*
name|Path
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|Path
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|(
name|pp
operator|=
name|sp
operator|->
name|Exclusions
operator|)
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
operator|*
name|pp
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
operator|*
name|pp
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Check a single word against a distribution list. */
end_comment

begin_function
name|STATIC
name|BOOL
name|WantThisOne
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|BOOL
name|sawbang
decl_stmt|;
for|for
control|(
name|sawbang
operator|=
name|FALSE
operator|,
name|c
operator|=
operator|*
name|p
init|;
operator|(
name|q
operator|=
operator|*
name|list
operator|)
operator|!=
name|NULL
condition|;
name|list
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'!'
condition|)
block|{
name|sawbang
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
operator|++
name|q
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|*
name|q
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* If we saw any !foo's and didn't match, then assume they are all      * negated distributions and return TRUE, else return false. */
return|return
name|sawbang
return|;
block|}
end_function

begin_comment
comment|/* **  Does the site want this article with this distribution? */
end_comment

begin_function
name|STATIC
name|BOOL
name|Wanted
parameter_list|(
name|site
parameter_list|,
name|article
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|site
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|article
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|article
condition|;
name|article
operator|++
control|)
if|if
condition|(
name|WantThisOne
argument_list|(
name|site
argument_list|,
operator|*
name|article
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Split up the Distribution line. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
modifier|*
name|ParseDistribs
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|SEPS
index|[]
init|=
literal|", \t"
decl_stmt|;
specifier|static
name|char
modifier|*
name|save
decl_stmt|;
specifier|static
name|int
name|Size
decl_stmt|;
specifier|static
name|int
name|Used
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|List
decl_stmt|;
name|char
modifier|*
name|nl
decl_stmt|;
comment|/* Throw out old storage, make sure we have a list. */
if|if
condition|(
name|save
condition|)
name|DISPOSE
argument_list|(
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
name|save
operator|=
name|p
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
operator|*
name|nl
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|List
operator|==
name|NULL
condition|)
block|{
name|Size
operator|=
literal|10
expr_stmt|;
name|List
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
name|Used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|p
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
do|do
block|{
if|if
condition|(
name|Used
operator|==
name|Size
operator|-
literal|2
condition|)
block|{
name|Size
operator|+=
literal|10
expr_stmt|;
name|RENEW
argument_list|(
name|List
argument_list|,
name|char
operator|*
argument_list|,
name|Size
argument_list|)
expr_stmt|;
block|}
name|List
index|[
name|Used
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
name|List
index|[
name|Used
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|List
return|;
block|}
end_function

begin_comment
comment|/* **  Process a single file. */
end_comment

begin_function
name|STATIC
name|void
name|QueueArticle
parameter_list|(
name|name
parameter_list|,
name|id
parameter_list|,
name|art
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|art
decl_stmt|;
block|{
specifier|static
name|char
name|SEPS
index|[]
init|=
literal|","
decl_stmt|;
specifier|static
name|char
name|DISTRIBUTION
index|[]
init|=
literal|"Distribution"
decl_stmt|;
specifier|static
name|char
name|PATH
index|[]
init|=
literal|"Path"
decl_stmt|;
specifier|static
name|char
name|NG
index|[]
init|=
literal|"Newsgroups"
decl_stmt|;
specifier|static
name|char
modifier|*
name|Buffer
decl_stmt|;
specifier|static
name|int
name|Size
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|BOOL
name|Dirty
decl_stmt|;
specifier|register
name|char
modifier|*
name|nl
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|char
modifier|*
modifier|*
name|Path
decl_stmt|;
name|char
modifier|*
modifier|*
name|Distribs
decl_stmt|;
comment|/* Read in the file. */
if|if
condition|(
name|fstat
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|art
argument_list|)
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't fstat \"%s\", %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Buffer
operator|==
name|NULL
condition|)
block|{
name|Size
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
name|Buffer
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Size
operator|<
name|Sb
operator|.
name|st_size
condition|)
block|{
name|Size
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
name|RENEW
argument_list|(
name|Buffer
argument_list|,
name|char
argument_list|,
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fread
argument_list|(
operator|(
name|POINTER
operator|)
name|Buffer
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
name|Sb
operator|.
name|st_size
argument_list|,
name|art
argument_list|)
operator|!=
name|Sb
operator|.
name|st_size
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read \"%s\", %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|Buffer
index|[
name|Sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Clear all sites. */
for|for
control|(
name|Dirty
operator|=
name|FALSE
operator|,
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
name|sp
operator|->
name|Sent
operator|=
name|FALSE
expr_stmt|;
comment|/* Parse the Path and Distribution headers. */
if|if
condition|(
operator|(
name|p
operator|=
name|HeaderFind
argument_list|(
name|Buffer
argument_list|,
name|PATH
argument_list|,
name|STRLEN
argument_list|(
name|PATH
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No \"Path\" header in \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|Path
operator|=
name|ParsePath
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|HeaderFind
argument_list|(
name|Buffer
argument_list|,
name|DISTRIBUTION
argument_list|,
name|STRLEN
argument_list|(
name|DISTRIBUTION
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|Distribs
operator|=
name|NULL
expr_stmt|;
else|else
name|Distribs
operator|=
name|ParseDistribs
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Look at the newsgroups, see who gets the article. */
if|if
condition|(
operator|(
name|p
operator|=
name|HeaderFind
argument_list|(
name|Buffer
argument_list|,
name|NG
argument_list|,
name|STRLEN
argument_list|(
name|NG
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No \"Newsgroups\" header in \"%s\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|nl
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|p
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|do
block|{
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngp
operator|->
name|nSites
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|ngp
operator|->
name|Sites
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|Path
operator|&&
name|Seen
argument_list|(
name|sp
argument_list|,
name|Path
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|Distribs
operator|&&
name|sp
operator|->
name|Distributions
operator|&&
operator|!
name|Wanted
argument_list|(
name|sp
operator|->
name|Distributions
argument_list|,
name|Distribs
argument_list|)
condition|)
continue|continue;
name|sp
operator|->
name|Sent
operator|=
name|TRUE
expr_stmt|;
name|Dirty
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
comment|/* Write the output. */
if|if
condition|(
name|Dirty
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s"
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Sent
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error writing \"%s\", %s\n"
argument_list|,
name|id
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Print a usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage error.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_NNTPLINK_LOG
argument_list|)
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
endif|#
directive|endif
comment|/* defined(DO_NNTPLINK_LOG) */
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|art
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
name|STRING
name|Active
decl_stmt|;
name|STRING
name|History
decl_stmt|;
name|STRING
name|Newsfeeds
decl_stmt|;
name|char
modifier|*
name|subbed
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|BOOL
name|Logfile
decl_stmt|;
name|char
name|name
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* Set defaults. */
name|Active
operator|=
name|_PATH_ACTIVE
expr_stmt|;
name|History
operator|=
name|_PATH_HISTORY
expr_stmt|;
name|Newsfeeds
operator|=
name|_PATH_NEWSFEEDS
expr_stmt|;
name|Logfile
operator|=
name|FALSE
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"a:d:h:ln:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'a'
case|:
name|Active
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|Epoch
operator|=
operator|(
name|long
operator|)
name|t
operator|-
name|atol
argument_list|(
name|optarg
argument_list|)
operator|*
literal|86400L
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|History
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|Logfile
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|Newsfeeds
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|Epoch
operator|&&
name|Logfile
condition|)
name|Usage
argument_list|()
expr_stmt|;
comment|/* Parse positional parameters; at most one, the input file. */
switch|switch
condition|(
name|ac
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|freopen
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open \"%s\" for input, %s\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|qp
operator|=
name|QIOfdopen
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|QIO_BUFFER
argument_list|)
expr_stmt|;
comment|/* Open the history file. */
if|if
condition|(
name|dbminit
argument_list|(
name|History
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't set up \"%s\" database, %s\n"
argument_list|,
name|History
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|History
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open \"%s\" for reading, %s\n"
argument_list|,
name|History
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Logfile
condition|)
block|{
comment|/* Read the control files and build the subscription list. */
name|ParseActive
argument_list|(
name|Active
argument_list|)
expr_stmt|;
name|ParseNewsfeeds
argument_list|(
name|Newsfeeds
argument_list|)
expr_stmt|;
name|subbed
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nSites
condition|;
name|i
operator|++
control|)
name|BuildSubList
argument_list|(
operator|&
name|Sites
index|[
name|i
index|]
argument_list|,
name|subbed
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|subbed
argument_list|)
expr_stmt|;
comment|/* Set up the character class tables. */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
name|ARTpathbits
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ARTpathbits
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-"
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|ARTpathbits
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Now we're ready to start reading input. */
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Read or line-format error? */
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read line %d, %s\n"
argument_list|,
name|i
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d too long\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We hit EOF. */
break|break;
block|}
if|if
condition|(
name|Logfile
condition|)
block|{
comment|/* Check the log character (correct for zero-origin subscripts. */
switch|switch
condition|(
name|line
index|[
name|STRLEN
argument_list|(
literal|"Jan 23 12:52:12.631 +"
argument_list|)
operator|-
literal|1
index|]
condition|)
block|{
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ignoring \"%s\"\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ART_CANC
case|:
case|case
name|ART_REJECT
case|:
continue|continue;
case|case
name|ART_ACCEPT
case|:
case|case
name|ART_JUNK
case|:
break|break;
block|}
block|}
comment|/* Snip off the Message-ID. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No Message-ID in \"%s\"\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|save
operator|=
operator|*
operator|++
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* Open the article. */
if|if
condition|(
operator|(
name|art
operator|=
name|FindFile
argument_list|(
name|F
argument_list|,
name|p
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|Logfile
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DO_NNTPLINK_LOG
argument_list|)
comment|/* Skip the (filename) if it's there. */
if|if
condition|(
name|save
operator|!=
literal|'\0'
operator|&&
operator|(
name|r
operator|=
name|strchr
argument_list|(
name|q
operator|+
literal|1
argument_list|,
literal|')'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s%s\n"
argument_list|,
name|name
argument_list|,
name|p
argument_list|,
name|r
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|q
operator|=
name|save
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|*
name|q
operator|=
name|save
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %s\n"
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_NNTPLINK_LOG) */
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write %s, %s\n"
argument_list|,
name|p
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|QueueArticle
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|art
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|art
argument_list|)
expr_stmt|;
block|}
comment|/* That's all she wrote. */
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbmclose
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

