begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.17 $ ** **  Expire news articles. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"inndcomm.h"
end_include

begin_include
include|#
directive|include
file|"dbz.h"
end_include

begin_include
include|#
directive|include
file|"qio.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_comment
comment|/* **  Stuff that more or less duplicates stuff in innd. */
end_comment

begin_define
define|#
directive|define
name|NGH_HASH
parameter_list|(
name|Name
parameter_list|,
name|p
parameter_list|,
name|j
parameter_list|)
define|\
value|for (p = Name, j = 0; *p; ) j = (j<< 5) + j + *p++
end_define

begin_define
define|#
directive|define
name|NGH_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|NGH_BUCKET
parameter_list|(
name|j
parameter_list|)
value|&NGHtable[j& (NGH_SIZE - 1)]
end_define

begin_typedef
typedef|typedef
struct|struct
name|_BUFFER
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
name|int
name|Left
decl_stmt|;
name|char
modifier|*
name|Data
decl_stmt|;
block|}
name|BUFFER
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_NEWSGROUP
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|char
modifier|*
name|Rest
decl_stmt|;
name|long
name|Last
decl_stmt|;
comment|/* These fields are new. */
name|time_t
name|Keep
decl_stmt|;
name|time_t
name|Default
decl_stmt|;
name|time_t
name|Purge
decl_stmt|;
block|}
name|NEWSGROUP
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_NGHASH
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
name|NEWSGROUP
modifier|*
modifier|*
name|Groups
decl_stmt|;
block|}
name|NGHASH
typedef|;
end_typedef

begin_comment
comment|/* **  Expire-specific stuff. */
end_comment

begin_define
define|#
directive|define
name|MAGIC_TIME
value|49710.
end_define

begin_typedef
typedef|typedef
struct|struct
name|_BADGROUP
block|{
name|struct
name|_BADGROUP
modifier|*
name|Next
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|BOOL
name|HasDirectory
decl_stmt|;
block|}
name|BADGROUP
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|BADGROUP
modifier|*
name|EXPbadgroups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|EXPlinks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|EXPquiet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|EXPsizing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|EXPtracing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|EXPusepost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|EXPnewslib
index|[]
init|=
name|_PATH_NEWSLIB
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|ACTIVE
index|[]
init|=
name|_PATH_ACTIVE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|SPOOL
index|[]
init|=
name|_PATH_SPOOL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|nGroups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|FILE
modifier|*
name|EXPunlinkfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPsaved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|NEWSGROUP
modifier|*
name|Groups
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|NEWSGROUP
name|EXPdefault
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|NGHASH
name|NGHtable
index|[
name|NGH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|STRING
name|EXPreason
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|time_t
name|EXPremember
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|time_t
name|Now
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics; for -v flag. */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|EXPgraph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|EXPverbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPprocessed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPunlinked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPhistdrop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPhistremember
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPallgone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|long
name|EXPstillhere
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STATIC
name|int
name|EXPsplit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **  Hash a newsgroup and see if we get it. */
end_comment

begin_function
name|STATIC
name|NEWSGROUP
modifier|*
name|NGfind
parameter_list|(
name|Name
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
modifier|*
name|ngp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|NGHASH
modifier|*
name|htp
decl_stmt|;
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|NGH_HASH
argument_list|(
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|NGH_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|Name
operator|,
name|ngp
operator|=
name|htp
operator|->
name|Groups
operator|,
name|i
operator|=
name|htp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|ngp
index|[
literal|0
index|]
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|EQ
argument_list|(
name|Name
argument_list|,
name|ngp
index|[
literal|0
index|]
operator|->
name|Name
argument_list|)
condition|)
return|return
name|ngp
index|[
literal|0
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Sorting predicate to put newsgroups in rough order of their activity. */
end_comment

begin_function
name|STATIC
name|int
name|NGcompare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|POINTER
name|p1
decl_stmt|;
name|POINTER
name|p2
decl_stmt|;
block|{
name|NEWSGROUP
modifier|*
modifier|*
name|ng1
decl_stmt|;
name|NEWSGROUP
modifier|*
modifier|*
name|ng2
decl_stmt|;
name|ng1
operator|=
name|CAST
argument_list|(
name|NEWSGROUP
operator|*
operator|*
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|ng2
operator|=
name|CAST
argument_list|(
name|NEWSGROUP
operator|*
operator|*
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|ng1
index|[
literal|0
index|]
operator|->
name|Last
operator|-
name|ng2
index|[
literal|0
index|]
operator|->
name|Last
return|;
block|}
end_function

begin_comment
comment|/* **  Build the newsgroup structures from the active file. */
end_comment

begin_function
name|STATIC
name|void
name|BuildGroups
parameter_list|(
name|active
parameter_list|)
name|char
modifier|*
name|active
decl_stmt|;
block|{
specifier|register
name|NGHASH
modifier|*
name|htp
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|j
decl_stmt|;
specifier|register
name|int
name|lines
decl_stmt|;
name|int
name|NGHbuckets
decl_stmt|;
name|char
modifier|*
name|fields
index|[
literal|5
index|]
decl_stmt|;
comment|/* Count the number of groups. */
for|for
control|(
name|p
operator|=
name|active
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
continue|continue;
name|nGroups
operator|=
name|i
expr_stmt|;
name|Groups
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Set up the default hash buckets. */
name|NGHbuckets
operator|=
name|i
operator|/
name|NGH_SIZE
expr_stmt|;
if|if
condition|(
name|NGHbuckets
operator|==
literal|0
condition|)
name|NGHbuckets
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NGH_SIZE
operator|,
name|htp
operator|=
name|NGHtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
block|{
name|htp
operator|->
name|Size
operator|=
name|NGHbuckets
expr_stmt|;
name|htp
operator|->
name|Groups
operator|=
name|NEW
argument_list|(
name|NEWSGROUP
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|htp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Fill in the array. */
name|lines
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|active
operator|,
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
operator|,
name|p
operator|=
name|q
operator|+
literal|1
control|)
block|{
name|lines
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: line %d missing newline\n"
argument_list|,
name|ACTIVE
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EXPsplit
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|,
name|fields
argument_list|,
name|SIZEOF
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|!=
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: line %d wrong number of fields\n"
argument_list|,
name|ACTIVE
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ngp
operator|->
name|Name
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
name|ngp
operator|->
name|Last
operator|=
name|atol
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|Rest
operator|=
name|fields
index|[
literal|3
index|]
expr_stmt|;
comment|/* Find the right bucket for the group, make sure there is room. */
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|NGH_HASH
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|htp
operator|=
name|NGH_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|htp
operator|->
name|Used
operator|>=
name|htp
operator|->
name|Size
condition|)
block|{
name|htp
operator|->
name|Size
operator|+=
name|NGHbuckets
expr_stmt|;
name|RENEW
argument_list|(
name|htp
operator|->
name|Groups
argument_list|,
name|NEWSGROUP
operator|*
argument_list|,
name|htp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
name|htp
operator|->
name|Groups
index|[
name|htp
operator|->
name|Used
operator|++
index|]
operator|=
name|ngp
expr_stmt|;
block|}
comment|/* Sort each hash bucket. */
for|for
control|(
name|i
operator|=
name|NGH_SIZE
operator|,
name|htp
operator|=
name|NGHtable
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|htp
operator|++
control|)
if|if
condition|(
name|htp
operator|->
name|Used
operator|>
literal|1
condition|)
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|htp
operator|->
name|Groups
argument_list|,
operator|(
name|SIZE_T
operator|)
name|htp
operator|->
name|Used
argument_list|,
sizeof|sizeof
name|htp
operator|->
name|Groups
index|[
literal|0
index|]
argument_list|,
name|NGcompare
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Open a file or give up. */
end_comment

begin_function
name|STATIC
name|FILE
modifier|*
name|EXPfopen
parameter_list|(
name|Remove
parameter_list|,
name|Name
parameter_list|,
name|Mode
parameter_list|)
name|BOOL
name|Remove
decl_stmt|;
name|STRING
name|Name
decl_stmt|;
name|char
modifier|*
name|Mode
decl_stmt|;
block|{
name|FILE
modifier|*
name|F
decl_stmt|;
if|if
condition|(
name|Remove
operator|&&
name|unlink
argument_list|(
name|Name
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning, can't remove %s, %s\n"
argument_list|,
name|Name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|Name
argument_list|,
name|Mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s in %s mode, %s\n"
argument_list|,
name|Name
argument_list|,
name|Mode
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|F
return|;
block|}
end_function

begin_comment
comment|/* **  Split a line at a specified field separator into a vector and return **  the number of fields found, or -1 on error. */
end_comment

begin_function
name|STATIC
name|int
name|EXPsplit
parameter_list|(
name|p
parameter_list|,
name|sep
parameter_list|,
name|argv
parameter_list|,
name|count
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|sep
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
operator|*
name|argv
operator|++
operator|=
name|p
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|sep
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|==
name|count
condition|)
comment|/* Overflow. */
return|return
operator|-
literal|1
return|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
operator|*
name|argv
operator|++
operator|=
name|p
init|;
operator|*
name|p
operator|==
name|sep
condition|;
name|p
operator|++
control|)
continue|continue;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* **  Parse a number field converting it into a "when did this start?". **  This makes the "keep it" tests fast, but inverts the logic of **  just about everything you expect.  Print a message and return FALSE **  on error. */
end_comment

begin_function
name|STATIC
name|BOOL
name|EXPgetnum
parameter_list|(
name|line
parameter_list|,
name|word
parameter_list|,
name|v
parameter_list|,
name|name
parameter_list|)
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
name|time_t
modifier|*
name|v
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|BOOL
name|SawDot
decl_stmt|;
name|double
name|d
decl_stmt|;
if|if
condition|(
name|caseEQ
argument_list|(
name|word
argument_list|,
literal|"never"
argument_list|)
condition|)
block|{
operator|*
name|v
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Check the number.  We don't have strtod yet. */
for|for
control|(
name|p
operator|=
name|word
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|SawDot
operator|=
name|FALSE
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|SawDot
condition|)
break|break;
name|SawDot
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|p
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d, bad `%c' character in %s field\n"
argument_list|,
name|line
argument_list|,
operator|*
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|d
operator|=
name|atof
argument_list|(
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|MAGIC_TIME
condition|)
operator|*
name|v
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
else|else
operator|*
name|v
operator|=
name|Now
operator|-
call|(
name|time_t
call|)
argument_list|(
name|d
operator|*
literal|86400.
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Set the expiration fields for all groups that match this pattern. */
end_comment

begin_function
name|STATIC
name|void
name|EXPmatch
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|,
name|mod
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|v
decl_stmt|;
specifier|register
name|char
name|mod
decl_stmt|;
block|{
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|BOOL
name|negate
decl_stmt|;
name|negate
operator|=
operator|*
name|p
operator|==
literal|'!'
expr_stmt|;
if|if
condition|(
name|negate
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|ngp
operator|=
name|Groups
operator|,
name|i
operator|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
name|negate
condition|?
operator|!
name|wildmat
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|p
argument_list|)
else|:
name|wildmat
argument_list|(
name|ngp
operator|->
name|Name
argument_list|,
name|p
argument_list|)
condition|)
if|if
condition|(
name|mod
operator|==
literal|'a'
operator|||
operator|(
name|mod
operator|==
literal|'m'
operator|&&
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_MODERATED
operator|)
operator|||
operator|(
name|mod
operator|==
literal|'u'
operator|&&
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|!=
name|NF_FLAG_MODERATED
operator|)
condition|)
block|{
name|ngp
operator|->
name|Keep
operator|=
name|v
operator|->
name|Keep
expr_stmt|;
name|ngp
operator|->
name|Default
operator|=
name|v
operator|->
name|Default
expr_stmt|;
name|ngp
operator|->
name|Purge
operator|=
name|v
operator|->
name|Purge
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %13.13s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|v
operator|->
name|Keep
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %13.13s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|v
operator|->
name|Default
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" %13.13s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|v
operator|->
name|Purge
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|" (%s)\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Parse the expiration control file.  Return TRUE if okay. */
end_comment

begin_function
name|STATIC
name|BOOL
name|EXPreadfile
parameter_list|(
name|F
parameter_list|)
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|char
name|mod
decl_stmt|;
name|NEWSGROUP
name|v
decl_stmt|;
name|BOOL
name|SawDefault
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|fields
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|patterns
decl_stmt|;
comment|/* Scan all lines. */
name|EXPremember
operator|=
operator|-
literal|1
expr_stmt|;
name|SawDefault
operator|=
name|FALSE
expr_stmt|;
name|patterns
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d too long\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|buff
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|j
operator|=
name|EXPsplit
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|,
name|fields
argument_list|,
name|SIZEOF
argument_list|(
name|fields
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d too many fields\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Expired-article remember line? */
if|if
condition|(
name|EQ
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|,
literal|"/remember/"
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d bad format\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|EXPremember
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d duplicate /remember/\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|EXPgetnum
argument_list|(
name|i
argument_list|,
name|fields
index|[
literal|1
index|]
argument_list|,
operator|&
name|EXPremember
argument_list|,
literal|"remember"
argument_list|)
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
comment|/* Regular expiration line -- right number of fields? */
if|if
condition|(
name|j
operator|!=
literal|5
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d bad format\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Parse the fields. */
if|if
condition|(
name|strchr
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|,
literal|'M'
argument_list|)
operator|!=
name|NULL
condition|)
name|mod
operator|=
literal|'m'
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|,
literal|'U'
argument_list|)
operator|!=
name|NULL
condition|)
name|mod
operator|=
literal|'u'
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|,
literal|'A'
argument_list|)
operator|!=
name|NULL
condition|)
name|mod
operator|=
literal|'a'
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d bad modflag\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|EXPgetnum
argument_list|(
name|i
argument_list|,
name|fields
index|[
literal|2
index|]
argument_list|,
operator|&
name|v
operator|.
name|Keep
argument_list|,
literal|"keep"
argument_list|)
operator|||
operator|!
name|EXPgetnum
argument_list|(
name|i
argument_list|,
name|fields
index|[
literal|3
index|]
argument_list|,
operator|&
name|v
operator|.
name|Default
argument_list|,
literal|"default"
argument_list|)
operator|||
operator|!
name|EXPgetnum
argument_list|(
name|i
argument_list|,
name|fields
index|[
literal|4
index|]
argument_list|,
operator|&
name|v
operator|.
name|Purge
argument_list|,
literal|"purge"
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* These were turned into offsets, so the test is the opposie 	 * of what you think it should be.  If Purge isn't forever, 	 * make sure it's greater then the other two fields. */
if|if
condition|(
name|v
operator|.
name|Purge
condition|)
block|{
comment|/* Some value not forever; make sure other values are in range. */
if|if
condition|(
name|v
operator|.
name|Keep
operator|&&
name|v
operator|.
name|Keep
operator|<
name|v
operator|.
name|Purge
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d keep>purge\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|v
operator|.
name|Default
operator|&&
name|v
operator|.
name|Default
operator|<
name|v
operator|.
name|Purge
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d default>purge\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Is this the default line? */
if|if
condition|(
name|fields
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|fields
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
name|mod
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|SawDefault
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d duplicate default\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
name|EXPdefault
operator|.
name|Keep
operator|=
name|v
operator|.
name|Keep
expr_stmt|;
name|EXPdefault
operator|.
name|Default
operator|=
name|v
operator|.
name|Default
expr_stmt|;
name|EXPdefault
operator|.
name|Purge
operator|=
name|v
operator|.
name|Purge
expr_stmt|;
name|SawDefault
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Assign to all groups that match the pattern and flags. */
if|if
condition|(
operator|(
name|j
operator|=
name|EXPsplit
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|,
literal|','
argument_list|,
name|patterns
argument_list|,
name|nGroups
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d too many patterns\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
name|EXPmatch
argument_list|(
name|patterns
index|[
name|k
index|]
argument_list|,
operator|&
name|v
argument_list|,
name|mod
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|patterns
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Handle a newsgroup that isn't in the active file. */
end_comment

begin_function
name|STATIC
name|NEWSGROUP
modifier|*
name|EXPnotfound
parameter_list|(
name|Entry
parameter_list|)
name|char
modifier|*
name|Entry
decl_stmt|;
block|{
specifier|static
name|NEWSGROUP
name|Removeit
decl_stmt|;
specifier|register
name|BADGROUP
modifier|*
name|bg
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
comment|/* See if we already know about this group. */
for|for
control|(
name|bg
operator|=
name|EXPbadgroups
init|;
name|bg
condition|;
name|bg
operator|=
name|bg
operator|->
name|Next
control|)
if|if
condition|(
name|EQ
argument_list|(
name|Entry
argument_list|,
name|bg
operator|->
name|Name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|bg
operator|==
name|NULL
condition|)
block|{
name|bg
operator|=
name|NEW
argument_list|(
name|BADGROUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bg
operator|->
name|Name
operator|=
name|COPY
argument_list|(
name|Entry
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|bg
operator|->
name|Name
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|bg
operator|->
name|HasDirectory
operator|=
name|stat
argument_list|(
name|buff
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
expr_stmt|;
name|bg
operator|->
name|Next
operator|=
name|EXPbadgroups
expr_stmt|;
name|EXPbadgroups
operator|=
name|bg
expr_stmt|;
if|if
condition|(
operator|!
name|EXPquiet
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Group not matched (removed?) %s -- %s\n"
argument_list|,
name|Entry
argument_list|,
name|bg
operator|->
name|HasDirectory
condition|?
literal|"Using default expiration"
else|:
literal|"Purging all articles"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Directory still there; use default expiration. */
if|if
condition|(
name|bg
operator|->
name|HasDirectory
condition|)
return|return
operator|&
name|EXPdefault
return|;
comment|/* No directory -- remove it all now. */
if|if
condition|(
name|Removeit
operator|.
name|Keep
operator|==
literal|0
condition|)
block|{
name|Removeit
operator|.
name|Keep
operator|=
name|Now
expr_stmt|;
name|Removeit
operator|.
name|Default
operator|=
name|Now
expr_stmt|;
name|Removeit
operator|.
name|Purge
operator|=
name|Now
expr_stmt|;
block|}
return|return
operator|&
name|Removeit
return|;
block|}
end_function

begin_comment
comment|/* **  Should we keep the specified article? */
end_comment

begin_function
name|STATIC
name|BOOL
name|EXPkeepit
parameter_list|(
name|Entry
parameter_list|,
name|when
parameter_list|,
name|Expires
parameter_list|)
name|char
modifier|*
name|Entry
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|time_t
name|Expires
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|Entry
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad entry, \"%s\"\n"
argument_list|,
name|Entry
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|Entry
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ngp
operator|=
name|EXPnotfound
argument_list|(
name|Entry
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|EXPverbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s age = %0.2f\n"
argument_list|,
name|Entry
argument_list|,
operator|(
name|Now
operator|-
name|when
operator|)
operator|/
literal|86400.
argument_list|)
expr_stmt|;
if|if
condition|(
name|Expires
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|when
operator|<
name|ngp
operator|->
name|Default
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s too old (no exp)\n"
argument_list|,
name|Entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|when
operator|<
name|ngp
operator|->
name|Purge
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s later than purge\n"
argument_list|,
name|Entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|when
operator|>
name|ngp
operator|->
name|Keep
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s earlier than min\n"
argument_list|,
name|Entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|Now
operator|>
name|Expires
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s later than header\n"
argument_list|,
name|Entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If no expiration, make sure it wasn't posted before the default. */
if|if
condition|(
name|Expires
operator|==
literal|0
condition|)
return|return
name|when
operator|>=
name|ngp
operator|->
name|Default
return|;
comment|/* Make sure it's not posted before the purge cut-off and      * that it's not due to expire. */
return|return
name|when
operator|>=
name|ngp
operator|->
name|Purge
operator|&&
operator|(
name|Expires
operator|>=
name|Now
operator|||
name|when
operator|>=
name|ngp
operator|->
name|Keep
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  An article can be removed.  Either print a note, or actually remove it. **  Also fill in the article size. */
end_comment

begin_function
name|STATIC
name|void
name|EXPremove
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|long
modifier|*
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
comment|/* Turn into a filename and get the size if we need it. */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
operator|*
name|q
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|EXPsizing
operator|&&
operator|*
name|size
operator|<
literal|0
operator|&&
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
condition|)
operator|*
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|Sb
operator|.
name|st_size
operator|>>
literal|10
operator|)
operator|+
operator|(
operator|(
operator|(
name|long
operator|)
name|Sb
operator|.
name|st_size
operator|>>
literal|9
operator|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tunlink %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|EXPunlinked
operator|++
expr_stmt|;
if|if
condition|(
name|EXPtracing
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EXPunlinkfile
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|EXPunlinkfile
argument_list|,
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ferror
argument_list|(
name|EXPunlinkfile
argument_list|)
condition|)
return|return;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write to -z file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Will ignore it for rest of run.)\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|EXPunlinkfile
argument_list|)
expr_stmt|;
name|EXPunlinkfile
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|p
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't unlink %s, %s\n"
argument_list|,
name|p
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Do the work of expiring one line. */
end_comment

begin_function
name|STATIC
name|BOOL
name|EXPdoline
parameter_list|(
name|out
parameter_list|,
name|line
parameter_list|,
name|length
parameter_list|,
name|arts
parameter_list|)
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
modifier|*
name|arts
decl_stmt|;
block|{
specifier|static
name|char
name|IGNORING
index|[]
init|=
literal|"Ignoring bad line, \"%.20s...\"\n"
decl_stmt|;
specifier|static
name|long
name|Offset
decl_stmt|;
specifier|static
name|BUFFER
name|New
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|first
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|fields
index|[
literal|4
index|]
decl_stmt|;
name|time_t
name|Arrived
decl_stmt|;
name|time_t
name|Expires
decl_stmt|;
name|time_t
name|Posted
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|long
name|where
decl_stmt|;
name|long
name|size
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|value
decl_stmt|;
name|char
name|date
index|[
literal|20
index|]
decl_stmt|;
comment|/* Split up the major fields. */
name|i
operator|=
name|EXPsplit
argument_list|(
name|line
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|fields
argument_list|,
name|SIZEOF
argument_list|(
name|fields
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|2
operator|&&
name|i
operator|!=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|IGNORING
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Split up the time field, robustly. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* One sub-field:  when the article arrived. */
name|Arrived
operator|=
name|atol
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|Expires
operator|=
literal|0
expr_stmt|;
name|Posted
operator|=
name|Arrived
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|Arrived
operator|=
name|atol
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|HIS_SUBFIELDSEP
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Two sub-fields:  arrival and expiration. */
name|Expires
operator|=
name|EQ
argument_list|(
name|p
argument_list|,
name|HIS_NOEXP
argument_list|)
condition|?
literal|0
else|:
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|Posted
operator|=
name|Arrived
expr_stmt|;
block|}
else|else
block|{
comment|/* All three sub-fields:  arrival, expiration, posted. */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|Expires
operator|=
name|EQ
argument_list|(
name|p
argument_list|,
name|HIS_NOEXP
argument_list|)
condition|?
literal|0
else|:
name|atol
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|HIS_SUBFIELDSEP
expr_stmt|;
name|Posted
operator|=
name|atol
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
comment|/* History line for already-expired article. */
if|if
condition|(
name|Arrived
operator|<
name|EXPremember
condition|)
block|{
if|if
condition|(
name|EXPverbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"forget: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|EXPhistdrop
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Not time to forget about this one yet. */
if|if
condition|(
name|out
condition|)
block|{
name|where
operator|=
name|Offset
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%c%s\n"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|fields
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|Offset
operator|+=
name|strlen
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"remember: %s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|EXPhistremember
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Active article -- split up the file entries. */
name|count
operator|=
name|EXPsplit
argument_list|(
name|fields
index|[
literal|2
index|]
argument_list|,
literal|' '
argument_list|,
name|arts
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|IGNORING
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|EXPprocessed
operator|++
expr_stmt|;
name|when
operator|=
name|EXPusepost
condition|?
name|Posted
else|:
name|Arrived
expr_stmt|;
comment|/* Get space to hold the remaining file name entries. */
if|if
condition|(
name|New
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|New
operator|.
name|Size
operator|=
name|length
expr_stmt|;
name|New
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|New
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|New
operator|.
name|Size
operator|<
name|length
condition|)
block|{
name|New
operator|.
name|Size
operator|=
name|length
expr_stmt|;
name|RENEW
argument_list|(
name|New
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|New
operator|.
name|Size
argument_list|)
expr_stmt|;
block|}
comment|/* The "first" variable tells us if we haven't saved the first 	 * article yet.  This only matters if we're doing link-saving. */
name|first
operator|=
name|EXPlinks
operator|&&
name|count
operator|>
literal|1
condition|?
name|arts
index|[
literal|0
index|]
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Loop over all file entries, see if we should keep each one. */
for|for
control|(
name|size
operator|=
operator|-
literal|1
operator|,
name|q
operator|=
name|New
operator|.
name|Data
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|arts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Shouldn't happen. */
continue|continue;
if|if
condition|(
name|EXPkeepit
argument_list|(
name|p
argument_list|,
name|when
argument_list|,
name|Expires
argument_list|)
condition|)
block|{
if|if
condition|(
name|EXPverbose
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"keep %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
comment|/* Keeping one and haven't kept the first; so save it. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|q
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|q
argument_list|,
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|>
name|New
operator|.
name|Data
condition|)
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
name|q
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Don't delete the file if preserving symbolic links to it. */
if|if
condition|(
name|EXPlinks
operator|&&
name|i
operator|==
literal|0
operator|&&
name|count
operator|>
literal|1
condition|)
continue|continue;
name|EXPremove
argument_list|(
name|arts
index|[
name|i
index|]
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* If saving links and didn't have to save the leader, delete it. */
if|if
condition|(
name|EXPlinks
operator|&&
name|first
operator|!=
name|NULL
condition|)
name|EXPremove
argument_list|(
name|first
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|New
operator|.
name|Data
condition|)
block|{
if|if
condition|(
name|EXPsizing
operator|&&
name|size
operator|>
literal|0
condition|)
name|EXPsaved
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|EXPremember
operator|>
literal|0
operator|&&
name|out
operator|!=
name|NULL
condition|)
block|{
name|where
operator|=
name|Offset
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|date
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|Arrived
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%c%s%c%s\n"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|date
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
name|HIS_NOEXP
argument_list|)
expr_stmt|;
name|Offset
operator|+=
name|strlen
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|date
argument_list|)
operator|+
literal|1
operator|+
name|STRLEN
argument_list|(
name|HIS_NOEXP
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"remember history: %s%c%s%c%s\n"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|date
argument_list|,
name|HIS_SUBFIELDSEP
argument_list|,
name|HIS_NOEXP
argument_list|)
expr_stmt|;
name|EXPallgone
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|out
condition|)
block|{
name|where
operator|=
name|Offset
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s%c%s%c%s\n"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|fields
index|[
literal|1
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|New
operator|.
name|Data
argument_list|)
expr_stmt|;
name|Offset
operator|+=
name|strlen
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|fields
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|New
operator|.
name|Data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"remember article: %s%c%s%c%s\n"
argument_list|,
name|fields
index|[
literal|0
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|fields
index|[
literal|1
index|]
argument_list|,
name|HIS_FIELDSEP
argument_list|,
name|New
operator|.
name|Data
argument_list|)
expr_stmt|;
name|EXPstillhere
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ferror
argument_list|(
name|out
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't write new history, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Set up the DBZ data.  We don't have to sanitize the Message-ID      * since it had to have been clean to get in there. */
name|key
operator|.
name|dptr
operator|=
name|fields
index|[
literal|0
index|]
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|strlen
argument_list|(
name|key
operator|.
name|dptr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|value
operator|.
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|where
expr_stmt|;
name|value
operator|.
name|dsize
operator|=
sizeof|sizeof
name|where
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|4
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\tdbz %s@%ld\n"
argument_list|,
name|key
operator|.
name|dptr
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbzstore
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't store key, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Clean up link with the server and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|CleanupAndExit
parameter_list|(
name|Server
parameter_list|,
name|Paused
parameter_list|,
name|x
parameter_list|)
name|BOOL
name|Server
decl_stmt|;
name|BOOL
name|Paused
decl_stmt|;
name|int
name|x
decl_stmt|;
block|{
name|FILE
modifier|*
name|F
decl_stmt|;
if|if
condition|(
name|Server
condition|)
operator|(
name|void
operator|)
name|ICCreserve
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|Paused
operator|&&
name|ICCgo
argument_list|(
name|EXPreason
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't unpause server, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Server
operator|&&
name|ICCclose
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close communication link, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|EXPunlinkfile
operator|&&
name|fclose
argument_list|(
name|EXPunlinkfile
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close -z file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Report stats. */
if|if
condition|(
name|EXPverbose
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Article lines processed %8ld\n"
argument_list|,
name|EXPprocessed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Articles retained       %8ld\n"
argument_list|,
name|EXPstillhere
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Entries expired         %8ld\n"
argument_list|,
name|EXPallgone
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Files unlinked          %8ld\n"
argument_list|,
name|EXPunlinked
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Old entries dropped     %8ld\n"
argument_list|,
name|EXPhistdrop
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Old entries retained    %8ld\n"
argument_list|,
name|EXPhistremember
argument_list|)
expr_stmt|;
block|}
comment|/* Append statistics to a summary file */
if|if
condition|(
name|EXPgraph
condition|)
block|{
name|F
operator|=
name|EXPfopen
argument_list|(
name|FALSE
argument_list|,
name|EXPgraph
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%ld %ld %ld %ld %ld %ld %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|Now
argument_list|,
name|EXPprocessed
argument_list|,
name|EXPstillhere
argument_list|,
name|EXPallgone
argument_list|,
name|EXPunlinked
argument_list|,
name|EXPhistdrop
argument_list|,
name|EXPhistremember
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print a usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: expire [flags] [expire.ctl]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|CANTCD
index|[]
init|=
literal|"Can't cd to %s, %s\n"
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|char
modifier|*
name|active
decl_stmt|;
name|char
modifier|*
modifier|*
name|arts
decl_stmt|;
name|STRING
name|History
decl_stmt|;
name|STRING
name|HistoryText
decl_stmt|;
name|STRING
name|HistoryPath
decl_stmt|;
name|STRING
name|HistoryDB
decl_stmt|;
name|char
modifier|*
name|Historydir
decl_stmt|;
name|char
modifier|*
name|Historypag
decl_stmt|;
name|char
modifier|*
name|NHistory
decl_stmt|;
name|char
modifier|*
name|NHistorydir
decl_stmt|;
name|char
modifier|*
name|NHistorypag
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|BOOL
name|Server
decl_stmt|;
name|BOOL
name|Paused
decl_stmt|;
name|BOOL
name|Bad
decl_stmt|;
name|BOOL
name|IgnoreOld
decl_stmt|;
name|BOOL
name|Writing
decl_stmt|;
name|BOOL
name|UnlinkFile
decl_stmt|;
name|time_t
name|TimeWarp
decl_stmt|;
comment|/* Set defaults. */
name|Server
operator|=
name|TRUE
expr_stmt|;
name|IgnoreOld
operator|=
name|FALSE
expr_stmt|;
name|History
operator|=
literal|"history"
expr_stmt|;
name|HistoryText
operator|=
name|_PATH_HISTORY
expr_stmt|;
name|HistoryPath
operator|=
name|NULL
expr_stmt|;
name|Writing
operator|=
name|TRUE
expr_stmt|;
name|TimeWarp
operator|=
literal|0
expr_stmt|;
name|UnlinkFile
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"f:h:d:g:ilnpqr:stv:w:xz:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'d'
case|:
name|HistoryPath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|History
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|EXPgraph
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|HistoryText
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|IgnoreOld
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|EXPlinks
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|Server
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|EXPusepost
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|EXPquiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|EXPreason
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|EXPsizing
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|EXPtracing
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|EXPverbose
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|TimeWarp
operator|=
call|(
name|time_t
call|)
argument_list|(
name|atof
argument_list|(
name|optarg
argument_list|)
operator|*
literal|86400.
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|Writing
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|EXPunlinkfile
operator|=
name|EXPfopen
argument_list|(
name|TRUE
argument_list|,
name|optarg
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|UnlinkFile
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|0
operator|&&
name|ac
operator|!=
literal|1
condition|)
name|Usage
argument_list|()
expr_stmt|;
comment|/* Get active file, parse it. */
if|if
condition|(
operator|(
name|active
operator|=
name|ReadInFile
argument_list|(
name|ACTIVE
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read %s, %s\n"
argument_list|,
name|ACTIVE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|BuildGroups
argument_list|(
name|active
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
name|Now
operator|+=
name|TimeWarp
expr_stmt|;
comment|/* Parse the control file. */
if|if
condition|(
name|av
index|[
literal|0
index|]
condition|)
name|F
operator|=
name|EQ
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
condition|?
name|stdin
else|:
name|EXPfopen
argument_list|(
name|FALSE
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|F
operator|=
name|EXPfopen
argument_list|(
name|FALSE
argument_list|,
name|_PATH_EXPIRECTL
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EXPreadfile
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Format error in control file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
comment|/* Set up the link, reserve the lock. */
if|if
condition|(
name|EXPreason
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Expiring process %ld"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|EXPreason
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Server
condition|)
block|{
comment|/* If we fail, leave evidence behind. */
if|if
condition|(
name|ICCopen
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open channel to server, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ICCreserve
argument_list|(
name|EXPreason
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't reserve server\n"
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|FALSE
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make the history filenames. */
name|HistoryDB
operator|=
name|COPY
argument_list|(
name|HistoryText
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.dir"
argument_list|,
name|HistoryDB
argument_list|)
expr_stmt|;
name|Historydir
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.pag"
argument_list|,
name|HistoryDB
argument_list|)
expr_stmt|;
name|Historypag
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|HistoryPath
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s/%s.n"
argument_list|,
name|HistoryPath
argument_list|,
name|History
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.n"
argument_list|,
name|History
argument_list|)
expr_stmt|;
name|NHistory
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.dir"
argument_list|,
name|NHistory
argument_list|)
expr_stmt|;
name|NHistorydir
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.pag"
argument_list|,
name|NHistory
argument_list|)
expr_stmt|;
name|NHistorypag
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Writing
condition|)
name|out
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Open new history files, relative to news lib. */
if|if
condition|(
name|chdir
argument_list|(
name|EXPnewslib
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|CANTCD
argument_list|,
name|EXPnewslib
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
name|EXPfopen
argument_list|(
name|TRUE
argument_list|,
name|NHistory
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|EXPfopen
argument_list|(
name|TRUE
argument_list|,
name|NHistorydir
argument_list|,
literal|"w"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|EXPfopen
argument_list|(
name|TRUE
argument_list|,
name|NHistorypag
argument_list|,
literal|"w"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPverbose
operator|>
literal|3
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"created: %s %s %s\n"
argument_list|,
name|NHistory
argument_list|,
name|NHistorydir
argument_list|,
name|NHistorypag
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbzincore
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IgnoreOld
condition|)
block|{
if|if
condition|(
name|dbzfresh
argument_list|(
name|NHistory
argument_list|,
name|dbzsize
argument_list|(
literal|0L
argument_list|)
argument_list|,
literal|'\t'
argument_list|,
literal|'C'
argument_list|,
literal|0L
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't create database, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dbzagain
argument_list|(
name|NHistory
argument_list|,
name|HistoryDB
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't dbzagain, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|SPOOL
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|CANTCD
argument_list|,
name|SPOOL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Main processing loop. */
name|arts
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|HistoryText
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open history file, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Bad
operator|=
name|FALSE
operator|,
name|line
operator|=
literal|1
operator|,
name|Paused
operator|=
name|FALSE
init|;
condition|;
name|line
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|EXPdoline
argument_list|(
name|out
argument_list|,
name|p
argument_list|,
name|QIOlength
argument_list|(
name|qp
argument_list|)
argument_list|,
name|arts
argument_list|)
condition|)
block|{
name|Bad
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOSPC
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|NHistory
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|NHistorydir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|NHistorypag
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
continue|continue;
block|}
comment|/* Read or line-format error? */
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't read line %d, %s\n"
argument_list|,
name|line
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|Paused
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d too long\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|Paused
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We hit EOF. */
if|if
condition|(
name|Paused
operator|||
operator|!
name|Server
condition|)
comment|/* Already paused or we don't want to pause -- we're done. */
break|break;
if|if
condition|(
name|ICCpause
argument_list|(
name|EXPreason
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't pause server, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|Paused
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|Paused
operator|=
name|TRUE
expr_stmt|;
block|}
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|arts
argument_list|)
expr_stmt|;
if|if
condition|(
name|Writing
condition|)
block|{
comment|/* Close the output files. */
if|if
condition|(
name|ferror
argument_list|(
name|out
argument_list|)
operator|||
name|fflush
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
operator|||
name|fclose
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close %s, %s\n"
argument_list|,
name|NHistory
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Bad
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dbmclose
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't close history, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|Bad
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|UnlinkFile
operator|&&
name|EXPunlinkfile
operator|==
name|NULL
condition|)
comment|/* Got -z but file was closed; oops. */
name|Bad
operator|=
name|TRUE
expr_stmt|;
comment|/* If we're done okay, and we're not tracing, slip in the new files. */
if|if
condition|(
name|EXPverbose
condition|)
block|{
if|if
condition|(
name|Bad
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Expire errors: history files not updated.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPtracing
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Expire tracing: history files not updated.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Bad
operator|&&
operator|!
name|EXPtracing
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|EXPnewslib
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|CANTCD
argument_list|,
name|EXPnewslib
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|Paused
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If user used the -d flag, mark we're done and exit. */
if|if
condition|(
name|HistoryPath
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s.done"
argument_list|,
name|NHistory
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|EXPfopen
argument_list|(
name|FALSE
argument_list|,
name|buff
argument_list|,
literal|"w"
argument_list|)
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rename
argument_list|(
name|NHistory
argument_list|,
name|HistoryText
argument_list|)
operator|<
literal|0
operator|||
name|rename
argument_list|(
name|NHistorydir
argument_list|,
name|Historydir
argument_list|)
operator|<
literal|0
operator|||
name|rename
argument_list|(
name|NHistorypag
argument_list|,
name|Historypag
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't replace history files, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Yes -- leave the server paused. */
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|FALSE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|EXPsizing
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s approximately %ldk\n"
argument_list|,
name|EXPtracing
condition|?
literal|"Would remove"
else|:
literal|"Removed"
argument_list|,
name|EXPsaved
argument_list|)
expr_stmt|;
name|CleanupAndExit
argument_list|(
name|Server
argument_list|,
name|Paused
argument_list|,
name|Bad
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

