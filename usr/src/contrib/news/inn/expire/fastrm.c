begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * delete a list of filenames from stdin  *  * exit(0) if all is OK (files that can't be unlinked because they  *	didn't exist is "OK")  *  * exit(1) in other cases - problems with stdin, no permission, ...  * written by<kre@munnari.oz.au>  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|"mydir.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_define
define|#
directive|define
name|MAX_LINE_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|SHORT_NAME
value|16
end_define

begin_define
define|#
directive|define
name|MAX_DIR_LEN
value|2048
end_define

begin_comment
comment|/* typedef unsigned char chr; */
end_comment

begin_typedef
typedef|typedef
name|char
name|chr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_dnode
block|{
name|struct
name|_dnode
modifier|*
name|next
decl_stmt|;
name|int
name|count
decl_stmt|;
name|chr
modifier|*
name|dir
decl_stmt|;
name|chr
modifier|*
name|longname
decl_stmt|;
name|chr
name|shortname
index|[
name|SHORT_NAME
index|]
decl_stmt|;
block|}
name|dnode
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NODENAME
parameter_list|(
name|d
parameter_list|)
value|((d)->longname ? (d)->longname : (d)->shortname)
end_define

begin_decl_stmt
name|STATIC
name|char
name|DotDot
index|[]
init|=
literal|"../../../../"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|chr
name|base_dir
index|[
name|MAX_DIR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|chr
name|cur_dir
index|[
name|MAX_DIR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|chr
name|prefix_dir
index|[
name|MAX_DIR_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|prefix_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|MyName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|fatals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error counter */
end_comment

begin_decl_stmt
name|STATIC
name|BOOL
name|AmRoot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|Debugging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|dotdot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|sortdirs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|cdval
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_function
name|STATIC
name|void
name|err_exit
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|MyName
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|myexit
parameter_list|()
block|{
name|err_exit
argument_list|(
literal|"Could not allocate memory"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* **  Get the next line from stdin into 'l' which has 'len' bytes available. */
end_comment

begin_function
name|STATIC
name|BOOL
name|get_line
parameter_list|(
name|l
parameter_list|,
name|len
parameter_list|)
specifier|register
name|chr
modifier|*
name|l
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|static
name|int
name|count
decl_stmt|;
specifier|register
name|chr
modifier|*
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get the line. */
if|if
condition|(
name|fgets
argument_list|(
name|l
argument_list|,
name|len
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|count
operator|++
expr_stmt|;
comment|/* See if we got the \n terminator. */
name|p
operator|=
operator|(
name|chr
operator|*
operator|)
name|strchr
argument_list|(
name|l
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* Yes, ok, that's a good line, trash the \n& return. */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* No, this line is longer than our buffer. */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Line %d (%.40s...) too long\n"
argument_list|,
name|MyName
argument_list|,
name|count
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|fatals
operator|++
expr_stmt|;
comment|/* Trash the rest of the long line. */
while|while
condition|(
name|fgets
argument_list|(
name|l
argument_list|,
name|len
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|l
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Go back and get the nest (just ignore the long one). */
block|}
block|}
end_function

begin_comment
comment|/* **  Remember a file name; this is pretty trivial (only fancy bit is not **  malloc'ing mem for short names). */
end_comment

begin_function
name|STATIC
name|dnode
modifier|*
name|build_node
parameter_list|(
name|prev
parameter_list|,
name|dir
parameter_list|,
name|name
parameter_list|)
name|dnode
modifier|*
name|prev
decl_stmt|;
name|chr
modifier|*
name|dir
decl_stmt|;
name|chr
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|dnode
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|n
operator|=
name|NEW
argument_list|(
name|dnode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|dir
operator|=
name|dir
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|SHORT_NAME
condition|)
block|{
name|n
operator|->
name|longname
operator|=
name|COPY
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|->
name|longname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|n
operator|->
name|shortname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* **  Read lines from stdin (including the first that may have been there **  from our last time in) until we reach EOF, or until we get a line that **  names a file not in the same directory as the previous lot remember **  the file names in the directory we're examining, and count them */
end_comment

begin_function
name|STATIC
name|dnode
modifier|*
name|build_dir
parameter_list|(
name|ip
parameter_list|)
name|int
modifier|*
name|ip
decl_stmt|;
block|{
specifier|static
name|chr
name|line
index|[
name|MAX_LINE_SIZE
index|]
decl_stmt|;
specifier|register
name|dnode
modifier|*
name|start
decl_stmt|;
specifier|register
name|dnode
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|dlen
decl_stmt|;
specifier|register
name|chr
modifier|*
name|p
decl_stmt|;
specifier|register
name|chr
modifier|*
name|dir
decl_stmt|;
operator|*
name|ip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|!
name|get_line
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|line
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Build node. */
name|p
operator|=
operator|(
name|chr
operator|*
operator|)
name|strrchr
argument_list|(
name|line
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|dlen
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|dir
operator|=
name|COPY
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|NULL
expr_stmt|;
name|dlen
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
block|}
name|n
operator|=
name|start
operator|=
name|build_node
argument_list|(
operator|(
name|dnode
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|get_line
argument_list|(
name|line
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|dlen
operator|<
literal|0
operator|&&
name|strchr
argument_list|(
name|line
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|||
operator|(
name|dlen
operator|>=
literal|0
operator|&&
operator|(
name|line
index|[
name|dlen
index|]
operator|!=
literal|'/'
operator|||
name|strchr
argument_list|(
name|line
operator|+
name|dlen
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
operator|||
name|strncmp
argument_list|(
name|dir
argument_list|,
name|line
argument_list|,
name|dlen
argument_list|)
operator|)
operator|)
condition|)
return|return
name|start
return|;
name|n
operator|=
name|build_node
argument_list|(
name|n
argument_list|,
name|dir
argument_list|,
name|line
operator|+
name|dlen
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ip
operator|)
operator|++
expr_stmt|;
block|}
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* **  Sorting predicate for qsort to put nodes in alphabetical order. */
end_comment

begin_function
name|STATIC
name|int
name|comp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|POINTER
name|a
decl_stmt|;
name|POINTER
name|b
decl_stmt|;
block|{
name|dnode
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|l1
operator|=
operator|*
name|CAST
argument_list|(
name|dnode
operator|*
operator|*
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|l2
operator|=
operator|*
name|CAST
argument_list|(
name|dnode
operator|*
operator|*
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|NODENAME
argument_list|(
name|l1
argument_list|)
argument_list|,
name|NODENAME
argument_list|(
name|l2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Find a node in the list. */
end_comment

begin_function
name|STATIC
name|dnode
modifier|*
name|inlist
parameter_list|(
name|list
parameter_list|,
name|num
parameter_list|,
name|name
parameter_list|)
specifier|register
name|dnode
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|dnode
modifier|*
modifier|*
name|top
decl_stmt|;
specifier|register
name|dnode
modifier|*
modifier|*
name|cur
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|top
operator|=
name|list
operator|+
name|num
operator|-
literal|1
init|;
name|top
operator|>=
name|list
condition|;
control|)
block|{
name|cur
operator|=
name|list
operator|+
operator|(
name|top
operator|-
name|list
operator|)
operator|/
literal|2
expr_stmt|;
name|i
operator|=
name|strcmp
argument_list|(
name|name
argument_list|,
name|NODENAME
argument_list|(
operator|*
name|cur
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|*
name|cur
return|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|top
operator|=
name|cur
operator|-
literal|1
expr_stmt|;
else|else
name|list
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Free a list of nodes. */
end_comment

begin_function
name|STATIC
name|void
name|freelist
parameter_list|(
name|list
parameter_list|)
specifier|register
name|dnode
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|dnode
modifier|*
name|l
decl_stmt|;
while|while
condition|(
operator|(
name|l
operator|=
name|list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list
operator|=
name|l
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|longname
condition|)
name|DISPOSE
argument_list|(
name|l
operator|->
name|longname
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|unlink_node
parameter_list|(
name|n
parameter_list|)
name|dnode
modifier|*
name|n
decl_stmt|;
block|{
specifier|register
name|chr
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
name|p
operator|=
name|NODENAME
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_len
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prefix_dir
operator|+
name|prefix_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|prefix_dir
expr_stmt|;
block|}
if|if
condition|(
name|AmRoot
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: stat "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in %s: "
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fatals
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Directory "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in %s: "
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|fatals
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|Debugging
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s / %s\n"
argument_list|,
name|cur_dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unlink "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"in %s: "
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fatals
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|STATIC
name|void
name|copynsegs
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|n
parameter_list|)
specifier|register
name|chr
modifier|*
name|from
decl_stmt|;
specifier|register
name|chr
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|chr
name|c
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|to
operator|++
operator|=
name|c
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
operator|--
name|n
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
operator|*
operator|--
name|to
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|int
name|slashcount
parameter_list|(
name|p
parameter_list|)
specifier|register
name|chr
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|p
condition|;
control|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* **  Set our environment (process working cirectory, and global vars) to **  reflect a change to directory 'd' (relative to base_dir if 'd' is not **  an absolute path).   We're likely to want to do different things **  depending on the amount of work to do in 'd' - that's given by 'num'. **  Return FALSE if the directory can be determined not to exist. */
end_comment

begin_function
name|STATIC
name|BOOL
name|setup_dir
parameter_list|(
name|d
parameter_list|,
name|num
parameter_list|)
specifier|register
name|chr
modifier|*
name|d
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
specifier|register
name|chr
modifier|*
name|p
decl_stmt|;
specifier|register
name|chr
modifier|*
name|q
decl_stmt|;
specifier|register
name|chr
modifier|*
name|abs
decl_stmt|;
specifier|register
name|int
name|bsegs
decl_stmt|;
specifier|register
name|int
name|oerrno
decl_stmt|;
name|chr
name|string
index|[
name|MAX_DIR_LEN
index|]
decl_stmt|;
name|bsegs
operator|=
name|slashcount
argument_list|(
name|base_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
name|abs
operator|=
name|base_dir
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'/'
condition|)
name|abs
operator|=
name|d
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'\0'
condition|)
name|abs
operator|=
operator|(
name|chr
operator|*
operator|)
literal|"/"
expr_stmt|;
else|else
block|{
while|while
condition|(
name|d
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
for|for
control|(
name|d
operator|+=
literal|2
init|;
operator|*
name|d
operator|==
literal|'/'
condition|;
control|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|bsegs
operator|>
literal|0
operator|&&
name|d
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|d
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|d
index|[
literal|2
index|]
operator|==
literal|'/'
condition|)
for|for
control|(
name|bsegs
operator|--
operator|,
name|d
operator|+=
literal|3
init|;
operator|*
name|d
operator|==
literal|'/'
condition|;
control|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|bsegs
operator|<=
literal|0
condition|)
name|err_exit
argument_list|(
literal|"Can't handle that many ..'s in path"
argument_list|)
expr_stmt|;
name|abs
operator|=
name|string
expr_stmt|;
name|copynsegs
argument_list|(
name|base_dir
argument_list|,
name|abs
argument_list|,
name|bsegs
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|abs
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|abs
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* Now "abs" is the full path name of the directory we want to      * be at, and "cur_dir" is where we presently are. */
for|for
control|(
name|p
operator|=
name|abs
operator|,
name|q
operator|=
name|cur_dir
init|;
operator|*
name|p
operator|==
operator|*
name|q
condition|;
control|)
block|{
comment|/* If we've reached the end, this is easy, we want to be in 	 * the same place as we were (which is probably really some 	 * kind of error, it shouldn't happen). */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
name|prefix_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|&&
operator|*
name|q
operator|==
literal|'/'
condition|)
block|{
comment|/* Want to go back up the tree, it might be faster to chdir(abs) 	 * or chdir(../../..).  But, since the this case happens rarely if 	 * the user cares about speed (sorted input will usually mean that 	 * we don't simply want to go back up the tree) it's not worth the 	 * bother. */
if|if
condition|(
name|cdval
operator|==
literal|0
operator|||
name|num
operator|<
name|cdval
condition|)
block|{
comment|/* Except if we have just a couple of files in this directory 	     * to deal with, in which case we'll just use their absolute 	     * path names. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prefix_dir
argument_list|,
name|abs
argument_list|)
expr_stmt|;
name|prefix_len
operator|=
name|p
operator|-
name|abs
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|abs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: chdir to "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|abs
argument_list|)
expr_stmt|;
comment|/* If we fail here, something is badly broken, since we're 	     * supposedly further down the tree. */
name|err_exit
argument_list|(
literal|"Chdir failed"
argument_list|)
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
operator|&&
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
comment|/* Want to change into a sub-dir of where we were; easy. */
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cdval
operator|==
literal|0
operator|||
name|num
operator|<
name|cdval
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prefix_dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|prefix_len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: chdir from %s to "
argument_list|,
name|MyName
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|oerrno
operator|==
name|ENOENT
condition|)
return|return
name|FALSE
return|;
name|err_exit
argument_list|(
literal|"Chdir failed"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cur_dir
argument_list|,
name|abs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* If its possible, (promised we have a pure tree), see if its      * worth going up the tree with ".." then down again, or if      * its better to simply start again at the start. */
if|if
condition|(
name|dotdot
condition|)
block|{
name|bsegs
operator|=
name|slashcount
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 1 default "dotdot" here can be 0, 1, 2, or 3, 1 seems 	 * frationally faster than 2, bigger values would require 	 * extending the "../../../" string, but are very unlikely 	 * to be helpful; '0' is the same as not using -u. */
if|if
condition|(
name|bsegs
operator|<=
name|dotdot
condition|)
block|{
comment|/* Looks like its probably worth using "..". */
while|while
condition|(
name|p
operator|>
name|abs
operator|&&
operator|*
operator|--
name|p
operator|!=
literal|'/'
condition|)
continue|continue;
name|p
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prefix_dir
argument_list|,
name|DotDot
operator|+
literal|9
operator|-
name|bsegs
operator|*
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prefix_dir
operator|+
operator|(
name|bsegs
operator|+
literal|1
operator|)
operator|*
literal|3
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdval
operator|==
literal|0
operator|||
name|num
operator|<
name|cdval
condition|)
block|{
name|prefix_len
operator|=
name|strlen
argument_list|(
name|prefix_dir
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|prefix_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: chdir from %s to "
argument_list|,
name|MyName
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|prefix_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|oerrno
operator|==
name|ENOENT
condition|)
return|return
name|FALSE
return|;
name|err_exit
argument_list|(
literal|"Chdir failed"
argument_list|)
expr_stmt|;
block|}
comment|/* Now patch up curdir to reflect where we are. */
while|while
condition|(
name|q
operator|>
name|cur_dir
operator|&&
operator|*
operator|--
name|q
operator|!=
literal|'/'
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|q
operator|+
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
comment|/* Simply use the absolute path. */
if|if
condition|(
name|cdval
operator|==
literal|0
operator|||
name|num
operator|<
name|cdval
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prefix_dir
argument_list|,
name|abs
argument_list|)
expr_stmt|;
name|prefix_len
operator|=
name|strlen
argument_list|(
name|abs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|abs
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: chdir to "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|abs
argument_list|)
expr_stmt|;
if|if
condition|(
name|oerrno
operator|==
name|ENOENT
condition|)
return|return
name|FALSE
return|;
name|err_exit
argument_list|(
literal|"Chdir failed"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cur_dir
argument_list|,
name|abs
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|STATIC
name|void
name|unlink_dir
parameter_list|(
name|list
parameter_list|,
name|num
parameter_list|)
specifier|register
name|dnode
modifier|*
name|list
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
block|{
specifier|static
name|dnode
modifier|*
modifier|*
name|dptrs
decl_stmt|;
specifier|static
name|int
name|ndp
decl_stmt|;
specifier|register
name|dnode
modifier|*
name|l
decl_stmt|;
specifier|register
name|dnode
modifier|*
modifier|*
name|pl
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dfd
decl_stmt|;
specifier|register
name|DIRENTRY
modifier|*
name|d
decl_stmt|;
specifier|register
name|BOOL
name|sorted
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
operator|!
name|setup_dir
argument_list|(
name|list
operator|->
name|dir
argument_list|,
name|num
argument_list|)
condition|)
block|{
comment|/* The directory doesn't exist, no point attempting to 	 * delete anything, just forget it all. */
if|if
condition|(
name|list
operator|->
name|dir
condition|)
name|DISPOSE
argument_list|(
name|list
operator|->
name|dir
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|list
operator|->
name|dir
condition|)
name|DISPOSE
argument_list|(
name|list
operator|->
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortdirs
operator|==
literal|0
operator|||
name|num
operator|<
name|sortdirs
condition|)
block|{
if|if
condition|(
name|prefix_len
operator|!=
literal|0
condition|)
block|{
name|prefix_dir
index|[
name|prefix_len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|prefix_dir
index|[
name|prefix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*  Easier to just unlink the files than worry about the 	 *  order we unlink them in. */
while|while
condition|(
operator|(
name|l
operator|=
name|list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unlink_node
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|list
operator|=
name|l
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|longname
condition|)
name|DISPOSE
argument_list|(
name|l
operator|->
name|longname
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|ndp
operator|==
literal|0
condition|)
block|{
name|ndp
operator|=
name|num
expr_stmt|;
name|dptrs
operator|=
name|NEW
argument_list|(
name|dnode
operator|*
argument_list|,
name|ndp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num
operator|>
name|ndp
condition|)
block|{
name|ndp
operator|=
name|num
operator|+
literal|16
expr_stmt|;
name|RENEW
argument_list|(
name|dptrs
argument_list|,
name|dnode
operator|*
argument_list|,
name|ndp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pl
operator|=
name|dptrs
operator|)
operator|==
name|NULL
condition|)
name|err_exit
argument_list|(
literal|"Out of mem in unlink_dir"
argument_list|)
expr_stmt|;
for|for
control|(
name|sorted
operator|=
name|TRUE
operator|,
operator|*
name|pl
operator|=
name|list
operator|,
name|l
operator|=
name|list
operator|->
name|next
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sorted
operator|&&
name|strcmp
argument_list|(
name|NODENAME
argument_list|(
operator|*
name|pl
argument_list|)
argument_list|,
name|NODENAME
argument_list|(
name|l
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|sorted
operator|=
name|FALSE
expr_stmt|;
operator|*
operator|++
name|pl
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sorted
condition|)
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dptrs
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode
operator|*
argument_list|)
argument_list|,
name|comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dfd
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open \".\" in directory \"%s\"\n"
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
name|fatals
operator|++
expr_stmt|;
name|freelist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|dfd
operator|=
name|opendir
argument_list|(
name|prefix_dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|prefix_dir
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open directory \"%s\"\n"
argument_list|,
name|prefix_dir
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open directory \"%s\" in \"%s\"\n"
argument_list|,
name|prefix_dir
argument_list|,
name|cur_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|prefix_dir
argument_list|,
operator|&
name|sb
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
name|fatals
operator|++
expr_stmt|;
name|freelist
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|prefix_len
operator|!=
literal|0
condition|)
block|{
name|prefix_dir
index|[
name|prefix_len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|prefix_dir
index|[
name|prefix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dfd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|l
operator|=
name|inlist
argument_list|(
name|dptrs
argument_list|,
name|num
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|unlink_node
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dfd
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|BOOL
name|bad_path
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|dnode
modifier|*
name|list
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|oerrno
decl_stmt|;
name|int
name|count
decl_stmt|;
name|BOOL
name|empty_error
decl_stmt|;
name|MyName
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|MyName
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|MyName
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|ONALLLOCFAIL
argument_list|(
name|myexit
argument_list|)
expr_stmt|;
name|AmRoot
operator|=
name|geteuid
argument_list|()
operator|==
literal|0
expr_stmt|;
name|empty_error
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|ac
operator|>
literal|2
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|av
index|[
literal|1
index|]
operator|)
operator|!=
literal|'-'
condition|)
break|break;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [ -u -s ] base_dir\n"
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
name|Debugging
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|dotdot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
continue|continue;
name|dotdot
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dotdot
operator|>=
name|strlen
argument_list|(
name|DotDot
argument_list|)
operator|/
operator|(
name|SIZE_T
operator|)
literal|3
condition|)
name|dotdot
operator|=
name|strlen
argument_list|(
name|DotDot
argument_list|)
operator|/
operator|(
name|SIZE_T
operator|)
literal|3
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sortdirs
operator|=
literal|5
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
continue|continue;
name|sortdirs
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cdval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
continue|continue;
name|cdval
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|empty_error
operator|=
name|TRUE
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
case|case
literal|'r'
case|:
continue|continue;
block|}
break|break;
block|}
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s base_dir\n"
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|||
name|bad_path
argument_list|(
name|p
argument_list|)
operator|||
name|strlen
argument_list|(
name|p
argument_list|)
operator|>=
operator|(
name|SIZE_T
operator|)
name|MAX_DIR_LEN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Bad base path: %s\n"
argument_list|,
name|MyName
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|base_dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cur_dir
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|cur_dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: chdir to base path "
argument_list|,
name|MyName
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
name|perror
argument_list|(
name|cur_dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|list
operator|=
name|build_dir
argument_list|(
operator|&
name|count
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|empty_error
operator|=
name|FALSE
expr_stmt|;
name|unlink_dir
argument_list|(
name|list
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fatals
operator|||
name|empty_error
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

