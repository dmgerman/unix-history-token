begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.12 $ ** **  A C version of Henry Spencer's "subst" script. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|LINESIZE
value|1024
end_define

begin_define
define|#
directive|define
name|FNAMESIZE
value|1024
end_define

begin_define
define|#
directive|define
name|PARAMSIZE
value|128
end_define

begin_define
define|#
directive|define
name|WHITE
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_comment
comment|/* **  AFS doesn't support hard links, so enable this #define. #define USE_RENAME */
end_comment

begin_comment
comment|/* **  If you don't have getopt in your C library, enable this #define. #define NEED_GETOPT */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_PAIR
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Length
decl_stmt|;
name|char
modifier|*
name|Value
decl_stmt|;
block|}
name|PAIR
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|argv0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **  Local implementations of common C library functions. */
end_comment

begin_comment
comment|/* **  Return string represtation of errno. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xstrerror
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
return|return
name|strerror
argument_list|(
name|errno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Return the first occurrence of 'c' in 'p' or NULL if not there. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xstrchr
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
return|return
name|strchr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Return the last occurrence of 'c' in 'p' or NULL if not there. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xstrrchr
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
return|return
name|strrchr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Copy a string to malloc'd memory or exit. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|xstrdup
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't copy \"%s\", %s\n"
argument_list|,
name|argv0
argument_list|,
name|p
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|strcpy
argument_list|(
name|new
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEED_GETOPT
argument_list|)
end_if

begin_define
define|#
directive|define
name|TYPE
value|int
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
define|\
value|if (opterr) {					\ 	char buff[2];					\ 	buff[0] = c; buff[1] = '\n';			\ 	(void)write(2, av[0], (TYPE)strlen(av[0]));	\ 	(void)write(2, s, (TYPE)strlen(s));		\ 	(void)write(2, buff, 2);			\     }
end_define

begin_decl_stmt
name|int
name|opterr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|optind
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|optopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Return options and their values from the command line. **  This comes from the AT&T public-domain getopt published in mod.sources **  (i.e., comp.sources.unix before the great Usenet renaming). */
end_comment

begin_function
name|int
name|getopt
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|,
name|opts
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
name|char
modifier|*
name|opts
decl_stmt|;
block|{
specifier|static
name|int
name|i
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Move to next value from argv? */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|optind
operator|>=
name|ac
operator|||
name|av
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|av
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|av
index|[
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|optind
operator|++
expr_stmt|;
return|return
name|EOF
return|;
block|}
block|}
comment|/* Get next option character. */
if|if
condition|(
operator|(
name|optopt
operator|=
name|av
index|[
name|optind
index|]
index|[
name|i
index|]
operator|)
operator|==
literal|':'
operator|||
operator|(
name|p
operator|=
name|IDX
argument_list|(
name|opts
argument_list|,
name|optopt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ERR
argument_list|(
literal|": illegal option -- "
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
index|[
name|optind
index|]
index|[
operator|++
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|optind
operator|++
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|'?'
return|;
block|}
comment|/* Snarf argument? */
if|if
condition|(
operator|*
operator|++
name|p
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|av
index|[
name|optind
index|]
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|optarg
operator|=
operator|&
name|av
index|[
name|optind
operator|++
index|]
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|++
name|optind
operator|>=
name|ac
condition|)
block|{
name|ERR
argument_list|(
literal|": option requires an argument -- "
argument_list|,
name|optopt
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
return|return
literal|'?'
return|;
block|}
name|optarg
operator|=
name|av
index|[
name|optind
operator|++
index|]
expr_stmt|;
block|}
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|av
index|[
name|optind
index|]
index|[
operator|++
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
name|optarg
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|optopt
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(NEED_GETOPT) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  Simulate "mv $from $to" -- return no useful status.  We know that **  the $from and $to are on the same filesystem. */
end_comment

begin_function
specifier|static
name|void
name|mv
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
if|if
condition|(
name|unlink
argument_list|(
name|to
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't unlink %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|to
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|USE_RENAME
argument_list|)
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't rename %s to %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't link %s to %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't unlink %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|from
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(USE_RENAME) */
block|}
end_function

begin_comment
comment|/* **  Simulate "cmp -s $n1 $n2" -- return 0 if files are the same. */
end_comment

begin_function
specifier|static
name|int
name|cmp
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|)
name|char
modifier|*
name|n1
decl_stmt|;
name|char
modifier|*
name|n2
decl_stmt|;
block|{
name|FILE
modifier|*
name|f1
decl_stmt|;
name|FILE
modifier|*
name|f2
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|f1
operator|=
name|fopen
argument_list|(
name|n1
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|f2
operator|=
name|fopen
argument_list|(
name|n2
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f1
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
name|getc
argument_list|(
name|f2
argument_list|)
operator|!=
name|c
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|getc
argument_list|(
name|f2
argument_list|)
operator|!=
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  If line does not look like a template, return NULL, otherwise modify **  it to delete the trailing gunk and return the start of the template. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|istemplate
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
comment|/* Find "=()<" and remember where it starts. */
for|for
control|(
name|p
operator|=
name|line
init|;
operator|(
name|p
operator|=
name|xstrchr
argument_list|(
name|p
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'('
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|')'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'<'
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|start
operator|=
operator|&
name|p
index|[
literal|4
index|]
expr_stmt|;
comment|/* Now find ">()=" and nip it off. */
for|for
control|(
name|p
operator|=
name|start
init|;
operator|(
name|p
operator|=
name|xstrchr
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'('
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|')'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'='
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|start
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Splice three strings together, returning an allocated copy. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|splice
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
name|char
modifier|*
name|s3
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't splice %s+%s+%s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* **  Substitute all found patterns in the line and print it.  Using the goto **  makes the code more clear than using do/while. */
end_comment

begin_function
specifier|static
name|int
name|doline
parameter_list|(
name|f
parameter_list|,
name|out
parameter_list|,
name|line
parameter_list|,
name|tp
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|PAIR
modifier|*
name|tp
decl_stmt|;
name|PAIR
modifier|*
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|char
name|save
decl_stmt|;
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|line
operator|=
name|xstrdup
argument_list|(
name|line
argument_list|)
init|;
name|tp
operator|<
name|end
condition|;
name|tp
operator|++
control|)
block|{
name|Again
label|:
for|for
control|(
name|p
operator|=
name|line
init|;
operator|(
name|p
operator|=
name|xstrchr
argument_list|(
name|p
argument_list|,
name|tp
operator|->
name|Name
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|tp
operator|->
name|Name
argument_list|,
name|tp
operator|->
name|Length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|save
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|new
operator|=
name|splice
argument_list|(
name|line
argument_list|,
name|tp
operator|->
name|Value
argument_list|,
name|p
operator|+
name|tp
operator|->
name|Length
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|new
argument_list|,
name|line
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  subst loop in %s:\n\t%s\n"
argument_list|,
name|argv0
argument_list|,
name|f
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|new
expr_stmt|;
goto|goto
name|Again
goto|;
block|}
block|}
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|fputs
argument_list|(
name|line
argument_list|,
name|out
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:  can't write %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|f
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* **  Process one file, carefully substituting it in place. */
end_comment

begin_function
specifier|static
name|void
name|Process
parameter_list|(
name|f
parameter_list|,
name|Table
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
name|PAIR
modifier|*
name|Table
decl_stmt|;
name|PAIR
modifier|*
name|end
decl_stmt|;
block|{
name|char
name|new
index|[
name|FNAMESIZE
index|]
decl_stmt|;
name|char
name|old
index|[
name|FNAMESIZE
index|]
decl_stmt|;
name|char
name|line
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|bad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|FILE
modifier|*
name|in
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
name|FILE
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* First, figure out temporary names. */
if|if
condition|(
operator|(
name|p
operator|=
name|xstrrchr
argument_list|(
name|f
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new
argument_list|,
literal|"substtmp.new"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|old
argument_list|,
literal|"substtmp.old"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|new
argument_list|,
literal|"%s/substtmp.new"
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|old
argument_list|,
literal|"%s/substtmp.old"
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
comment|/* Test existences. */
if|if
condition|(
operator|(
name|in
operator|=
name|fopen
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't open %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|f
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|fopen
argument_list|(
name|new
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s exists, cannot proceed\n"
argument_list|,
name|argv0
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|fopen
argument_list|(
name|old
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s exists, cannot proceed\n"
argument_list|,
name|argv0
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|fopen
argument_list|(
name|old
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|out
operator|=
name|fopen
argument_list|(
name|new
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
operator|||
name|temp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: cannot create temporaries %s and %s\n"
argument_list|,
name|argv0
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Generate the new version. */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|bad
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|in
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|xstrchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Line %d of %s is too long (or doesn't end with a newline)\n"
argument_list|,
name|argv0
argument_list|,
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|istemplate
argument_list|(
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|count
operator|=
name|doline
argument_list|(
name|f
argument_list|,
name|out
argument_list|,
name|p
argument_list|,
name|Table
argument_list|,
name|end
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|bad
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s:%d unknown parameter or bad line:\n\t%s"
argument_list|,
name|argv0
argument_list|,
name|f
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
operator|||
name|fclose
argument_list|(
name|out
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't close %s, %s\n"
argument_list|,
name|argv0
argument_list|,
name|f
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
name|bad
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bad
operator|||
name|cmp
argument_list|(
name|new
argument_list|,
name|f
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|old
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: unchanged\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Substitute new for old the only safe way -- ignore signals. */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|mv
argument_list|(
name|f
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|mv
argument_list|(
name|new
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: updated\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print usage message and exit. */
end_comment

begin_function
specifier|static
name|void
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s -f file victims...\n"
argument_list|,
name|argv0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|NIL
index|[]
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|ctlfile
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
name|LINESIZE
index|]
decl_stmt|;
name|char
name|name
index|[
name|PARAMSIZE
index|]
decl_stmt|;
name|PAIR
modifier|*
name|Table
decl_stmt|;
name|PAIR
modifier|*
name|tp
decl_stmt|;
comment|/* Set defaults. */
name|ctlfile
operator|=
name|NULL
expr_stmt|;
name|argv0
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"f:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'f'
case|:
if|if
condition|(
name|ctlfile
operator|!=
name|NULL
condition|)
name|Usage
argument_list|()
expr_stmt|;
name|ctlfile
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
comment|/* Open control file, count lines, allocate table. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|ctlfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open %s to read it, %s\n"
argument_list|,
name|argv0
argument_list|,
name|ctlfile
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
continue|continue;
if|if
condition|(
operator|(
name|Table
operator|=
operator|(
name|PAIR
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|*
sizeof|sizeof
expr|*
name|Table
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't allocate %d table elements, %s\n"
argument_list|,
name|argv0
argument_list|,
name|i
argument_list|,
name|xstrerror
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now parse the table. */
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|F
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|tp
operator|=
name|Table
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|xstrchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Line %d of %s is too long\n"
argument_list|,
name|argv0
argument_list|,
name|i
argument_list|,
name|ctlfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip empty lines, comment lines, and all-blank lines. */
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|buff
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|buff
init|;
name|WHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Find end of first word, copy second word (or empty string) */
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
operator|&&
operator|!
name|WHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|tp
operator|->
name|Value
operator|=
name|NIL
expr_stmt|;
else|else
block|{
for|for
control|(
operator|*
name|p
operator|++
operator|=
literal|'\0'
init|;
operator|*
name|p
operator|&&
name|WHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|tp
operator|->
name|Value
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Turn things like \& into&. */
for|for
control|(
name|p
operator|=
name|dest
operator|=
name|tp
operator|->
name|Value
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
operator|*
name|dest
operator|++
operator|=
operator|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|?
operator|*
operator|++
name|p
else|:
operator|*
name|p
expr_stmt|;
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Turn first word into something directly searchable. */
if|if
condition|(
name|strlen
argument_list|(
name|buff
argument_list|)
operator|>
sizeof|sizeof
name|name
operator|-
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Parameter %s is too long\n"
argument_list|,
name|argv0
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"@<%s>@"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|tp
operator|->
name|Name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|tp
operator|->
name|Length
operator|=
name|strlen
argument_list|(
name|tp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|av
operator|!=
name|NULL
condition|)
name|Process
argument_list|(
operator|*
name|av
operator|++
argument_list|,
name|Table
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

