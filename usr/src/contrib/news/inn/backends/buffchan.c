begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.9 $ ** **  Buffered file exploder for innd. */
end_comment

begin_include
include|#
directive|include
file|"configdata.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"paths.h"
end_include

begin_include
include|#
directive|include
file|"libinn.h"
end_include

begin_include
include|#
directive|include
file|"clibrary.h"
end_include

begin_include
include|#
directive|include
file|"qio.h"
end_include

begin_include
include|#
directive|include
file|"macros.h"
end_include

begin_function_decl
specifier|extern
name|void
name|MAPread
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|MAPname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **  Hash functions for hashing sitenames. */
end_comment

begin_define
define|#
directive|define
name|SITE_HASH
parameter_list|(
name|Name
parameter_list|,
name|p
parameter_list|,
name|j
parameter_list|)
define|\
value|for (p = Name, j = 0; *p; ) j = (j<< 5) + j + *p++
end_define

begin_define
define|#
directive|define
name|SITE_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|SITE_BUCKET
parameter_list|(
name|j
parameter_list|)
value|&SITEtable[j& (SITE_SIZE - 1)]
end_define

begin_comment
comment|/* **  Entry for a single active site. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_SITE
block|{
name|BOOL
name|Dropped
decl_stmt|;
name|STRING
name|Name
decl_stmt|;
name|int
name|CloseLines
decl_stmt|;
name|int
name|FlushLines
decl_stmt|;
name|time_t
name|LastFlushed
decl_stmt|;
name|time_t
name|LastClosed
decl_stmt|;
name|int
name|CloseSeconds
decl_stmt|;
name|int
name|FlushSeconds
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
name|STRING
name|Filename
decl_stmt|;
name|char
modifier|*
name|Buffer
decl_stmt|;
block|}
name|SITE
typedef|;
end_typedef

begin_comment
comment|/* **  Site hashtable bucket. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_SITEHASH
block|{
name|int
name|Size
decl_stmt|;
name|int
name|Used
decl_stmt|;
name|SITE
modifier|*
name|Sites
decl_stmt|;
block|}
name|SITEHASH
typedef|;
end_typedef

begin_comment
comment|/* Global variables. */
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|Format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|STRING
name|Map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|BufferMode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CloseEvery
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|FlushEvery
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|CloseSeconds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|FlushSeconds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SIGVAR
name|GotInterrupt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SITEHASH
name|SITEtable
index|[
name|SITE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|TIMEINFO
name|Now
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DONT_HAVE_FCHMOD
argument_list|)
end_if

begin_comment
comment|/* **  A dummy fchmod. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|fchmod
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DONT_HAVE_FCHMOD) */
end_comment

begin_comment
comment|/* **  Set up the site information.  Basically creating empty buckets. */
end_comment

begin_function
name|STATIC
name|void
name|SITEsetup
parameter_list|()
block|{
specifier|register
name|SITEHASH
modifier|*
name|shp
decl_stmt|;
for|for
control|(
name|shp
operator|=
name|SITEtable
init|;
name|shp
operator|<
name|ENDOF
argument_list|(
name|SITEtable
argument_list|)
condition|;
name|shp
operator|++
control|)
block|{
name|shp
operator|->
name|Size
operator|=
literal|3
expr_stmt|;
name|shp
operator|->
name|Sites
operator|=
name|NEW
argument_list|(
name|SITE
argument_list|,
name|shp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|shp
operator|->
name|Used
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Close a site */
end_comment

begin_function
name|STATIC
name|void
name|SITEclose
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|sp
operator|->
name|F
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|F
argument_list|)
operator|||
name|fchmod
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|F
argument_list|)
argument_list|,
literal|0664
argument_list|)
operator|<
literal|0
operator|||
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant close %s, %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|sp
operator|->
name|Filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|F
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Close all open sites. */
end_comment

begin_function
name|STATIC
name|void
name|SITEcloseall
parameter_list|()
block|{
specifier|register
name|SITEHASH
modifier|*
name|shp
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|shp
operator|=
name|SITEtable
init|;
name|shp
operator|<
name|ENDOF
argument_list|(
name|SITEtable
argument_list|)
condition|;
name|shp
operator|++
control|)
for|for
control|(
name|sp
operator|=
name|shp
operator|->
name|Sites
operator|,
name|i
operator|=
name|shp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
name|SITEclose
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Open the file for a site. */
end_comment

begin_function
name|STATIC
name|void
name|SITEopen
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|F
operator|=
name|xfopena
argument_list|(
name|sp
operator|->
name|Filename
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|e
operator|=
name|errno
operator|)
operator|!=
name|EACCES
operator|||
name|chmod
argument_list|(
name|sp
operator|->
name|Filename
argument_list|,
literal|0644
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|sp
operator|->
name|F
operator|=
name|xfopena
argument_list|(
name|sp
operator|->
name|Filename
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant fopen %s, %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|sp
operator|->
name|Filename
argument_list|,
name|strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|F
operator|=
name|fopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* This really should not happen. */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant fopen %s, %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
literal|"/dev/null"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fchmod
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|sp
operator|->
name|F
argument_list|)
argument_list|,
literal|0444
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant fchmod %s %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|sp
operator|->
name|Filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferMode
operator|!=
literal|'\0'
condition|)
name|setbuf
argument_list|(
name|sp
operator|->
name|F
argument_list|,
name|sp
operator|->
name|Buffer
argument_list|)
expr_stmt|;
comment|/* Reset all counters. */
name|sp
operator|->
name|FlushLines
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|CloseLines
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|LastFlushed
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|sp
operator|->
name|LastClosed
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|sp
operator|->
name|Dropped
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Find a site, possibly create if not found. */
end_comment

begin_function
name|STATIC
name|SITE
modifier|*
name|SITEfind
parameter_list|(
name|Name
parameter_list|,
name|CanCreate
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
name|BOOL
name|CanCreate
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|SITEHASH
modifier|*
name|shp
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
name|buff
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* Look for site in the hash table. */
comment|/* SUPPRESS 6 */
comment|/* Over/underflow from plus expression */
name|SITE_HASH
argument_list|(
name|Name
argument_list|,
name|p
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|shp
operator|=
name|SITE_BUCKET
argument_list|(
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|Name
operator|,
name|sp
operator|=
name|shp
operator|->
name|Sites
operator|,
name|i
operator|=
name|shp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|sp
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|caseEQ
argument_list|(
name|Name
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
condition|)
return|return
name|sp
return|;
if|if
condition|(
operator|!
name|CanCreate
condition|)
return|return
name|NULL
return|;
comment|/* Adding a new site -- grow hash bucket if we need to. */
if|if
condition|(
name|shp
operator|->
name|Used
operator|==
name|shp
operator|->
name|Size
operator|-
literal|1
condition|)
block|{
name|shp
operator|->
name|Size
operator|*=
literal|2
expr_stmt|;
name|RENEW
argument_list|(
name|shp
operator|->
name|Sites
argument_list|,
name|SITE
argument_list|,
name|shp
operator|->
name|Size
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
operator|&
name|shp
operator|->
name|Sites
index|[
name|shp
operator|->
name|Used
operator|++
index|]
expr_stmt|;
comment|/* Fill in the structure for the new site. */
name|sp
operator|->
name|Name
operator|=
name|COPY
argument_list|(
name|Name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
operator|(
name|STRING
operator|)
name|Format
argument_list|,
name|Map
condition|?
name|MAPname
argument_list|(
name|Name
argument_list|)
else|:
name|sp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|Filename
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|BufferMode
operator|==
literal|'u'
condition|)
name|sp
operator|->
name|Buffer
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|BufferMode
operator|==
literal|'b'
condition|)
name|sp
operator|->
name|Buffer
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|SITEopen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* **  Flush a site -- close and re-open the file. */
end_comment

begin_function
name|STATIC
name|void
name|SITEflush
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|sp
operator|->
name|F
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|F
argument_list|)
operator|||
name|fchmod
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|F
argument_list|)
argument_list|,
literal|0664
argument_list|)
operator|<
literal|0
operator|||
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant close %s, %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|sp
operator|->
name|Filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|F
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sp
operator|->
name|Dropped
condition|)
name|SITEopen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Flush all open sites. */
end_comment

begin_function
name|STATIC
name|void
name|SITEflushall
parameter_list|()
block|{
specifier|register
name|SITEHASH
modifier|*
name|shp
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|shp
operator|=
name|SITEtable
init|;
name|shp
operator|<
name|ENDOF
argument_list|(
name|SITEtable
argument_list|)
condition|;
name|shp
operator|++
control|)
for|for
control|(
name|sp
operator|=
name|shp
operator|->
name|Sites
operator|,
name|i
operator|=
name|shp
operator|->
name|Used
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
name|SITEflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Write data to a site. */
end_comment

begin_function
name|STATIC
name|void
name|SITEwrite
parameter_list|(
name|name
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|SITEfind
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|F
operator|==
name|NULL
condition|)
name|SITEopen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|POINTER
operator|)
name|text
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
name|len
argument_list|,
name|sp
operator|->
name|F
argument_list|)
operator|!=
name|len
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant write %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bump line count; see if time to close or flush. */
if|if
condition|(
name|CloseEvery
operator|&&
operator|++
operator|(
name|sp
operator|->
name|CloseLines
operator|)
operator|>=
name|CloseEvery
condition|)
block|{
name|SITEflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CloseSeconds
operator|&&
name|sp
operator|->
name|LastClosed
operator|+
name|CloseSeconds
operator|<
name|Now
operator|.
name|time
condition|)
block|{
name|SITEflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|FlushEvery
operator|&&
operator|++
operator|(
name|sp
operator|->
name|FlushLines
operator|)
operator|>=
name|FlushEvery
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|sp
operator|->
name|F
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|sp
operator|->
name|F
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant flush %s, %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|sp
operator|->
name|Filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|LastFlushed
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|sp
operator|->
name|FlushLines
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FlushSeconds
operator|&&
name|sp
operator|->
name|LastFlushed
operator|+
name|FlushSeconds
operator|<
name|Now
operator|.
name|time
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|sp
operator|->
name|F
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|sp
operator|->
name|F
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan %s cant flush %s, %s\n"
argument_list|,
name|sp
operator|->
name|Name
argument_list|,
name|sp
operator|->
name|Filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|LastFlushed
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|sp
operator|->
name|FlushLines
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Handle a command message. */
end_comment

begin_function
name|STATIC
name|void
name|Process
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"begin"
argument_list|,
literal|5
argument_list|)
condition|)
comment|/* No-op. */
return|return;
if|if
condition|(
operator|*
name|p
operator|==
literal|'f'
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"flush"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|+=
literal|5
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|SITEflushall
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|p
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|SITEflush
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|else
comment|/*(void)fprintf(stderr, "buffchan flush %s unknown site\n", p);*/
empty_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'d'
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"drop"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|+=
literal|4
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|SITEcloseall
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|p
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan drop %s unknown site\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|SITEclose
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|Dropped
operator|=
name|TRUE
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"readmap"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|MAPread
argument_list|(
name|Map
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Other command messages -- ignored. */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan unknown message %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Print usage message and exit. */
end_comment

begin_function
name|STATIC
name|NORETURN
name|Usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage error.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Mark that we got a signal; let two signals kill us. */
end_comment

begin_function
name|STATIC
name|SIGHANDLER
name|CATCHinterrupt
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|GotInterrupt
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|s
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|static
name|char
name|BATCHDIR
index|[]
init|=
name|_PATH_BATCHDIR
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|Fields
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|Directory
decl_stmt|;
name|BOOL
name|Redirect
decl_stmt|;
name|FILE
modifier|*
name|F
decl_stmt|;
comment|/* Set defaults. */
name|Directory
operator|=
name|NULL
expr_stmt|;
name|Fields
operator|=
literal|1
expr_stmt|;
name|Format
operator|=
name|NULL
expr_stmt|;
name|Redirect
operator|=
name|TRUE
expr_stmt|;
name|GotInterrupt
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|NEWSUMASK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|CATCHinterrupt
argument_list|)
expr_stmt|;
comment|/* Parse JCL. */
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"bc:C:d:f:l:L:m:p:rs:u"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
default|default:
name|Usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'b'
case|:
case|case
literal|'u'
case|:
name|BufferMode
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|CloseEvery
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|CloseSeconds
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|Directory
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|Format
operator|==
name|NULL
condition|)
name|Format
operator|=
literal|"%s"
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|Fields
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|FlushEvery
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|FlushSeconds
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|Map
operator|=
name|optarg
expr_stmt|;
name|MAPread
argument_list|(
name|Map
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan cant fopen %s %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|F
argument_list|)
operator|||
name|fclose
argument_list|(
name|F
argument_list|)
operator|==
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan cant fclose %s %s\n"
argument_list|,
name|optarg
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|Redirect
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|Format
operator|=
name|optarg
expr_stmt|;
break|break;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
condition|)
name|Usage
argument_list|()
expr_stmt|;
comment|/* Do some basic set-ups. */
if|if
condition|(
name|Redirect
condition|)
operator|(
name|void
operator|)
name|freopen
argument_list|(
name|_PATH_ERRLOG
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Format
operator|==
name|NULL
condition|)
block|{
name|Format
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|STRLEN
argument_list|(
name|BATCHDIR
argument_list|)
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Format
argument_list|,
literal|"%s/%%s"
argument_list|,
name|BATCHDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Directory
operator|&&
name|chdir
argument_list|(
name|Directory
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan cant chdir %s %s\n"
argument_list|,
name|Directory
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|SITEsetup
argument_list|()
expr_stmt|;
comment|/* Read input. */
for|for
control|(
name|qp
operator|=
name|QIOfdopen
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
literal|0
argument_list|)
init|;
operator|!
name|GotInterrupt
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan cant read %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan long_line"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|QIOread
argument_list|(
name|qp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Normal EOF. */
break|break;
block|}
comment|/* Command? */
if|if
condition|(
operator|*
name|line
operator|==
name|EXP_CONTROL
operator|&&
operator|*
operator|++
name|line
operator|!=
name|EXP_CONTROL
condition|)
block|{
name|Process
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip the right number of leading fields. */
for|for
control|(
name|i
operator|=
name|Fields
operator|,
name|p
operator|=
name|line
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|&&
operator|--
name|i
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Nothing to write.  Probably shouldn't happen. */
continue|continue;
comment|/* Add a newline, get the length of all leading fields. */
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|i
operator|=
name|p
operator|-
name|line
expr_stmt|;
if|if
condition|(
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buffchan cant gettime %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Rest of the line is space-separated list of filenames. */
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|=
name|next
control|)
block|{
comment|/* Skip whitespace, get next word. */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|next
operator|=
name|p
init|;
operator|*
name|next
operator|&&
operator|*
name|next
operator|!=
literal|' '
condition|;
name|next
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|next
condition|)
operator|*
name|next
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|SITEwrite
argument_list|(
name|p
argument_list|,
name|line
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|SITEcloseall
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

