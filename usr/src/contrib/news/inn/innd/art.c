begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.52 $ ** **  Article-processing. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_include
include|#
directive|include
file|"dbz.h"
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|iovec
name|IOVEC
typedef|;
end_typedef

begin_comment
comment|/* **  A way to index into the header table. */
end_comment

begin_define
define|#
directive|define
name|HDR
parameter_list|(
name|_x
parameter_list|)
value|(ARTheaders[(_x)].Value)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|S_IXUSR
argument_list|)
end_if

begin_define
define|#
directive|define
name|EXECUTE_BITS
value|(S_IXUSR | S_IXGRP | S_IXOTH)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EXECUTE_BITS
value|0111
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(S_IXUSR) */
end_comment

begin_comment
comment|/* **  Mark that the site gets this article. */
end_comment

begin_define
define|#
directive|define
name|SITEmark
parameter_list|(
name|sp_
parameter_list|,
name|ngp_
parameter_list|)
define|\
value|do { \ 	SITE	*funnel; \     \ 	sp_->Sendit = TRUE; \ 	if (sp_->ng == NULL) \ 	    sp_->ng = ngp_; \ 	if (sp_->Funnel != NOSITE) { \ 	    funnel =&Sites[sp_->Funnel]; \ 	    if (funnel->ng == NULL) \ 		funnel->ng = ngp_; \ 	} \     } while (JUSTONCE)
end_define

begin_comment
comment|/* **  Header types. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_ARTHEADERTYPE
block|{
name|HTreq
block|,
comment|/* Drop article if this is missing	*/
name|HTobs
block|,
comment|/* Delete this header if found		*/
name|HTstd
comment|/* Standard optional header		*/
block|}
name|ARTHEADERTYPE
typedef|;
end_typedef

begin_comment
comment|/* **  Entry in the header table. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_ARTHEADER
block|{
name|STRING
name|Name
decl_stmt|;
name|ARTHEADERTYPE
name|Type
decl_stmt|;
name|int
name|Size
decl_stmt|;
comment|/* Length of Name	*/
name|char
modifier|*
name|Value
decl_stmt|;
name|int
name|Length
decl_stmt|;
comment|/* Length of Value	*/
name|int
name|Found
decl_stmt|;
name|BOOL
name|Allocated
decl_stmt|;
block|}
name|ARTHEADER
typedef|;
end_typedef

begin_comment
comment|/* **  For speed we build a binary tree of the headers, sorted by their **  name.  We also store the header's Name fields in the tree to avoid **  doing an extra indirection. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_TREE
block|{
name|STRING
name|Name
decl_stmt|;
name|ARTHEADER
modifier|*
name|Header
decl_stmt|;
name|struct
name|_TREE
modifier|*
name|Before
decl_stmt|;
name|struct
name|_TREE
modifier|*
name|After
decl_stmt|;
block|}
name|TREE
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|TREE
modifier|*
name|ARTheadertree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  For doing the overview database, we keep a list of the headers and **  a flag saying if they're written in brief or full format. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_ARTOVERFIELD
block|{
name|ARTHEADER
modifier|*
name|Header
decl_stmt|;
name|BOOL
name|NeedHeader
decl_stmt|;
block|}
name|ARTOVERFIELD
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|ARTOVERFIELD
modifier|*
name|ARTfields
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  General newsgroup we care about, and what we put in the Path line. */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|ARTctl
index|[]
init|=
literal|"control"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|ARTjnk
index|[]
init|=
literal|"junk"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|ARTpathme
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Flag array, indexed by character.  Character classes for Message-ID's. */
end_comment

begin_decl_stmt
name|STATIC
name|char
name|ARTcclass
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CC_MSGID_ATOM
value|01
end_define

begin_define
define|#
directive|define
name|CC_MSGID_NORM
value|02
end_define

begin_define
define|#
directive|define
name|CC_HOSTNAME
value|04
end_define

begin_define
define|#
directive|define
name|ARTnormchar
parameter_list|(
name|c
parameter_list|)
value|((ARTcclass[(c)]& CC_MSGID_NORM) != 0)
end_define

begin_define
define|#
directive|define
name|ARTatomchar
parameter_list|(
name|c
parameter_list|)
value|((ARTcclass[(c)]& CC_MSGID_ATOM) != 0)
end_define

begin_define
define|#
directive|define
name|ARThostchar
parameter_list|(
name|c
parameter_list|)
value|((ARTcclass[(c)]& CC_HOSTNAME) != 0)
end_define

begin_comment
comment|/* **  The header table.  Not necessarily sorted, but the first character **  must be uppercase. */
end_comment

begin_decl_stmt
name|STATIC
name|ARTHEADER
name|ARTheaders
index|[]
init|=
block|{
comment|/*	Name			Type	... */
block|{
literal|"Approved"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_approved
value|0
block|{
literal|"Control"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_control
value|1
block|{
literal|"Date"
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_date
value|2
block|{
literal|"Distribution"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_distribution
value|3
block|{
literal|"Expires"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_expires
value|4
block|{
literal|"From"
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_from
value|5
block|{
literal|"Lines"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_lines
value|6
block|{
literal|"Message-ID"
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_message_id
value|7
block|{
literal|"Newsgroups"
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_newsgroups
value|8
block|{
literal|"Path"
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_path
value|9
block|{
literal|"Reply-To"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_reply_to
value|10
block|{
literal|"Sender"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_sender
value|11
block|{
literal|"Subject"
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_subject
value|12
block|{
literal|"Supersedes"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_supersedes
value|13
block|{
literal|"Bytes"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_bytes
value|14
block|{
literal|"Also-Control"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_alsocontrol
value|15
block|{
literal|"References"
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_references
value|16
block|{
literal|"Xref"
block|,
name|HTobs
block|}
block|,
define|#
directive|define
name|_xref
value|17
block|{
literal|"Date-Received"
block|,
name|HTobs
block|}
block|,
block|{
literal|"Posted"
block|,
name|HTobs
block|}
block|,
block|{
literal|"Posting-Version"
block|,
name|HTobs
block|}
block|,
block|{
literal|"Received"
block|,
name|HTobs
block|}
block|,
block|{
literal|"Relay-Version"
block|,
name|HTobs
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* ** */
end_comment

begin_function
name|BOOL
name|ARTreadschema
parameter_list|()
block|{
specifier|static
name|char
name|SCHEMA
index|[]
init|=
name|_PATH_SCHEMA
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
specifier|register
name|ARTHEADER
modifier|*
name|hp
decl_stmt|;
name|BOOL
name|ok
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
if|if
condition|(
name|ARTfields
operator|!=
name|NULL
condition|)
block|{
name|DISPOSE
argument_list|(
name|ARTfields
argument_list|)
expr_stmt|;
name|ARTfields
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Open file, count lines. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|SCHEMA
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
continue|continue;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|F
argument_list|,
operator|(
name|OFFSET_T
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ARTfields
operator|=
name|NEW
argument_list|(
name|ARTOVERFIELD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Parse each field. */
for|for
control|(
name|ok
operator|=
name|TRUE
operator|,
name|fp
operator|=
name|ARTfields
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
control|)
block|{
comment|/* Ignore blank and comment lines. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
name|COMMENT_CHAR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|->
name|NeedHeader
operator|=
name|EQ
argument_list|(
name|p
argument_list|,
literal|"full"
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|NeedHeader
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|ARTheaders
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|ARTheaders
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|EQ
argument_list|(
name|buff
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
condition|)
block|{
name|fp
operator|->
name|Header
operator|=
name|hp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
operator|==
name|ENDOF
argument_list|(
name|ARTheaders
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_schema unknown header \"%s\""
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|ok
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|fp
operator|++
expr_stmt|;
block|}
name|fp
operator|->
name|Header
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* **  Build a balanced tree for the headers in subscript range [lo..hi). **  This only gets called once, and the tree only has about 20 entries, **  so we don't bother to unroll the recursion. */
end_comment

begin_function
specifier|static
name|TREE
modifier|*
name|ARTbuildtree
parameter_list|(
name|Table
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|)
name|ARTHEADER
modifier|*
modifier|*
name|Table
decl_stmt|;
name|int
name|lo
decl_stmt|;
name|int
name|hi
decl_stmt|;
block|{
name|int
name|mid
decl_stmt|;
name|TREE
modifier|*
name|tp
decl_stmt|;
name|mid
operator|=
name|lo
operator|+
operator|(
name|hi
operator|-
name|lo
operator|)
operator|/
literal|2
expr_stmt|;
name|tp
operator|=
name|NEW
argument_list|(
name|TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|->
name|Header
operator|=
name|Table
index|[
name|mid
index|]
expr_stmt|;
name|tp
operator|->
name|Name
operator|=
name|tp
operator|->
name|Header
operator|->
name|Name
expr_stmt|;
if|if
condition|(
name|mid
operator|==
name|lo
condition|)
name|tp
operator|->
name|Before
operator|=
name|NULL
expr_stmt|;
else|else
name|tp
operator|->
name|Before
operator|=
name|ARTbuildtree
argument_list|(
name|Table
argument_list|,
name|lo
argument_list|,
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
name|hi
operator|-
literal|1
condition|)
name|tp
operator|->
name|After
operator|=
name|NULL
expr_stmt|;
else|else
name|tp
operator|->
name|After
operator|=
name|ARTbuildtree
argument_list|(
name|Table
argument_list|,
name|mid
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
expr_stmt|;
return|return
name|tp
return|;
block|}
end_function

begin_comment
comment|/* **  Sorting predicate for qsort call in ARTsetup. */
end_comment

begin_function
name|STATIC
name|int
name|ARTcompare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|POINTER
name|p1
decl_stmt|;
name|POINTER
name|p2
decl_stmt|;
block|{
name|ARTHEADER
modifier|*
modifier|*
name|h1
decl_stmt|;
name|ARTHEADER
modifier|*
modifier|*
name|h2
decl_stmt|;
name|h1
operator|=
name|CAST
argument_list|(
name|ARTHEADER
operator|*
operator|*
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|h2
operator|=
name|CAST
argument_list|(
name|ARTHEADER
operator|*
operator|*
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
name|strcasecmp
argument_list|(
name|h1
index|[
literal|0
index|]
operator|->
name|Name
argument_list|,
name|h2
index|[
literal|0
index|]
operator|->
name|Name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Setup the article processing. */
end_comment

begin_function
name|void
name|ARTsetup
parameter_list|()
block|{
specifier|register
name|STRING
name|p
decl_stmt|;
specifier|register
name|ARTHEADER
modifier|*
name|hp
decl_stmt|;
name|ARTHEADER
modifier|*
modifier|*
name|table
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Set up the character class tables.  These are written a      * little strangely to work around a GCC2.0 bug. */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|POINTER
operator|)
name|ARTcclass
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ARTcclass
argument_list|)
expr_stmt|;
name|p
operator|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|ARTcclass
index|[
name|i
index|]
operator|=
name|CC_HOSTNAME
operator||
name|CC_MSGID_ATOM
operator||
name|CC_MSGID_NORM
expr_stmt|;
block|}
name|p
operator|=
literal|"!#$%&'*+-/=?^_`{|}~"
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|ARTcclass
index|[
name|i
index|]
operator|=
name|CC_MSGID_ATOM
operator||
name|CC_MSGID_NORM
expr_stmt|;
block|}
name|p
operator|=
literal|"\"(),.:;<@[\\]"
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|ARTcclass
index|[
name|i
index|]
operator|=
name|CC_MSGID_NORM
expr_stmt|;
block|}
comment|/* The RFC's don't require it, but we add underscore to the list of valid      * hostname characters. */
name|ARTcclass
index|[
literal|'.'
index|]
operator||=
name|CC_HOSTNAME
expr_stmt|;
name|ARTcclass
index|[
literal|'-'
index|]
operator||=
name|CC_HOSTNAME
expr_stmt|;
name|ARTcclass
index|[
literal|'_'
index|]
operator||=
name|CC_HOSTNAME
expr_stmt|;
comment|/* Allocate space in the header table. */
for|for
control|(
name|hp
operator|=
name|ARTheaders
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|ARTheaders
argument_list|)
condition|;
name|hp
operator|++
control|)
block|{
name|hp
operator|->
name|Size
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|hp
operator|->
name|Allocated
operator|=
name|hp
operator|->
name|Value
operator|==
name|NULL
operator|&&
name|hp
operator|->
name|Type
operator|!=
name|HTobs
operator|&&
name|hp
operator|!=
operator|&
name|ARTheaders
index|[
name|_bytes
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|Allocated
condition|)
name|hp
operator|->
name|Value
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|MAXHEADERSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Build the header tree. */
name|table
operator|=
name|NEW
argument_list|(
name|ARTHEADER
operator|*
argument_list|,
name|SIZEOF
argument_list|(
name|ARTheaders
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF
argument_list|(
name|ARTheaders
argument_list|)
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
operator|&
name|ARTheaders
index|[
name|i
index|]
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|POINTER
operator|)
name|table
argument_list|,
name|SIZEOF
argument_list|(
name|ARTheaders
argument_list|)
argument_list|,
sizeof|sizeof
expr|*
name|table
argument_list|,
name|ARTcompare
argument_list|)
expr_stmt|;
name|ARTheadertree
operator|=
name|ARTbuildtree
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
name|SIZEOF
argument_list|(
name|ARTheaders
argument_list|)
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|table
argument_list|)
expr_stmt|;
comment|/* Get our Path name, kill trailing !. */
name|ARTpathme
operator|=
name|COPY
argument_list|(
name|Path
operator|.
name|Data
argument_list|)
expr_stmt|;
name|ARTpathme
index|[
name|Path
operator|.
name|Used
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Set up database; ignore errors. */
operator|(
name|void
operator|)
name|ARTreadschema
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|STATIC
name|void
name|ARTfreetree
parameter_list|(
name|tp
parameter_list|)
name|TREE
modifier|*
name|tp
decl_stmt|;
block|{
name|TREE
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|Before
condition|)
name|ARTfreetree
argument_list|(
name|tp
operator|->
name|Before
argument_list|)
expr_stmt|;
name|next
operator|=
name|tp
operator|->
name|After
expr_stmt|;
name|DISPOSE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ARTclose
parameter_list|()
block|{
specifier|register
name|ARTHEADER
modifier|*
name|hp
decl_stmt|;
comment|/* Free space in the header table. */
for|for
control|(
name|hp
operator|=
name|ARTheaders
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|ARTheaders
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Allocated
condition|)
name|DISPOSE
argument_list|(
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARTfields
operator|!=
name|NULL
condition|)
block|{
name|DISPOSE
argument_list|(
name|ARTfields
argument_list|)
expr_stmt|;
name|ARTfields
operator|=
name|NULL
expr_stmt|;
block|}
name|ARTfreetree
argument_list|(
name|ARTheadertree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Read in a file, return a pointer to static space that is reused. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|ARTreadfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|BUFFER
name|File
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|oerrno
decl_stmt|;
comment|/* Open the file, get its size. */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Make sure we have enough space. */
if|if
condition|(
name|File
operator|.
name|Size
operator|==
literal|0
condition|)
block|{
name|File
operator|.
name|Size
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
name|File
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|File
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|File
operator|.
name|Size
operator|<=
name|Sb
operator|.
name|st_size
condition|)
block|{
name|File
operator|.
name|Size
operator|=
name|Sb
operator|.
name|st_size
operator|+
literal|16
expr_stmt|;
name|RENEW
argument_list|(
name|File
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|File
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Read in the file. */
if|if
condition|(
name|xread
argument_list|(
name|fd
argument_list|,
name|File
operator|.
name|Data
argument_list|,
name|Sb
operator|.
name|st_size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|oerrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Clean up and return the data. */
name|File
operator|.
name|Data
index|[
name|Sb
operator|.
name|st_size
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|File
operator|.
name|Data
return|;
block|}
end_function

begin_comment
comment|/* **  Open the article file and return a copy of it.  The files parameter is **  actually a whitespace-separated list of names. */
end_comment

begin_function
name|char
modifier|*
name|ARTreadarticle
parameter_list|(
name|files
parameter_list|)
specifier|register
name|char
modifier|*
name|files
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|BOOL
name|more
decl_stmt|;
name|char
modifier|*
name|art
decl_stmt|;
if|if
condition|(
name|files
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Loop over all filenames until we can open one. */
for|for
control|(
init|;
operator|*
name|files
condition|;
name|files
operator|=
name|p
operator|+
literal|1
control|)
block|{
comment|/* Snip off next name, turn dots to slashes. */
for|for
control|(
name|p
operator|=
name|files
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
for|for
control|(
name|files
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|more
operator|=
operator|*
name|p
operator|==
literal|' '
expr_stmt|;
if|if
condition|(
name|more
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|art
operator|=
name|ARTreadfile
argument_list|(
name|files
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|art
operator|!=
name|NULL
condition|)
return|return
name|art
return|;
if|if
condition|(
operator|!
name|more
condition|)
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Open the article file and return a copy of the headers. */
end_comment

begin_function
name|char
modifier|*
name|ARTreadheader
parameter_list|(
name|files
parameter_list|)
name|char
modifier|*
name|files
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|head
decl_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
name|ARTreadarticle
argument_list|(
name|files
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Find \n\n which means the end of the header. */
for|for
control|(
name|p
operator|=
name|head
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|head
return|;
block|}
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s bad_article %s is all headers"
argument_list|,
name|LogName
argument_list|,
name|files
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Parse a Path line, splitting it up into NULL-terminated array of strings. **  The argument is modified! */
end_comment

begin_function
name|STATIC
name|char
modifier|*
modifier|*
name|ARTparsepath
parameter_list|(
name|p
parameter_list|,
name|countp
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|NULLPATH
index|[
literal|1
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|static
name|int
name|oldlength
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|hosts
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* We can be called with a non-existant or empty path. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
name|NULLPATH
return|;
block|}
comment|/* Get an array of character pointers. */
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hosts
operator|==
name|NULL
condition|)
block|{
name|oldlength
operator|=
name|i
expr_stmt|;
name|hosts
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|oldlength
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldlength
operator|<=
name|i
condition|)
block|{
name|oldlength
operator|=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|hosts
argument_list|,
name|char
operator|*
argument_list|,
name|oldlength
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Loop over text. */
for|for
control|(
name|hp
operator|=
name|hosts
init|;
operator|*
name|p
condition|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
control|)
block|{
comment|/* Skip leading separators. */
for|for
control|(
init|;
operator|*
name|p
operator|&&
operator|!
name|ARThostchar
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Mark the start of the host, move to the end of it. */
for|for
control|(
operator|*
name|hp
operator|++
operator|=
name|p
init|;
operator|*
name|p
operator|&&
name|ARThostchar
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
block|}
operator|*
name|hp
operator|=
name|NULL
expr_stmt|;
operator|*
name|countp
operator|=
name|hp
operator|-
name|hosts
expr_stmt|;
return|return
name|hosts
return|;
block|}
end_function

begin_comment
comment|/* **  Write an article using writev.  The article is split into pieces, **  shown below separated by pipe signs.  The items in square brackets are **  "inserted" by this routine. **	|headers... **	Path: |[Path.Data]|rest of path... **	headers... **	|[Lines header, if needed]| **	|[Xref header]| ** **	Article body. **  Also, the Data->Size field is filled in. */
end_comment

begin_function
name|STATIC
name|int
name|ARTwrite
parameter_list|(
name|name
parameter_list|,
name|Article
parameter_list|,
name|Data
parameter_list|,
name|CrossPosted
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|BUFFER
modifier|*
name|Article
decl_stmt|;
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|BOOL
name|CrossPosted
decl_stmt|;
block|{
specifier|static
name|char
name|WHEN
index|[]
init|=
literal|"article"
decl_stmt|;
specifier|static
name|char
name|NL
index|[]
init|=
literal|"\n"
decl_stmt|;
specifier|static
name|BUFFER
name|Headers
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|IOVEC
modifier|*
name|vp
decl_stmt|;
specifier|register
name|long
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|IOVEC
name|iov
index|[
literal|7
index|]
decl_stmt|;
name|IOVEC
modifier|*
name|end
decl_stmt|;
name|char
name|bytesbuff
index|[
name|SMBUF
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|HeaderFind
argument_list|(
name|Article
operator|->
name|Data
argument_list|,
literal|"Path"
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|==
name|Article
operator|->
name|Data
condition|)
block|{
comment|/* This should not happen. */
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s internal %s no Path header"
argument_list|,
name|Data
operator|->
name|MessageID
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Open the file. */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|ARTFILE_MODE
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Set up the scatter/gather vectors. */
name|vp
operator|=
name|iov
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|Article
operator|->
name|Data
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
name|p
operator|-
name|Article
operator|->
name|Data
expr_stmt|;
name|size
operator|+=
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|Path
operator|.
name|Data
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
name|Path
operator|.
name|Used
expr_stmt|;
name|size
operator|+=
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|p
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
name|Data
operator|->
name|Body
operator|-
name|p
expr_stmt|;
name|size
operator|+=
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|ARTheaders
index|[
name|_lines
index|]
operator|.
name|Found
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Data
operator|->
name|Lines
argument_list|,
literal|"Lines: %d\n"
argument_list|,
name|Data
operator|->
name|LinesValue
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|Data
operator|->
name|Lines
argument_list|)
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|Data
operator|->
name|Lines
expr_stmt|;
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
operator|=
name|i
expr_stmt|;
name|size
operator|+=
name|i
expr_stmt|;
comment|/* Install in header table; STRLEN("Lines: ") == 7. */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ARTheaders
index|[
name|_lines
index|]
operator|.
name|Value
argument_list|,
name|Data
operator|->
name|Lines
operator|+
literal|7
argument_list|)
expr_stmt|;
name|ARTheaders
index|[
name|_lines
index|]
operator|.
name|Length
operator|=
name|i
operator|-
literal|7
expr_stmt|;
name|ARTheaders
index|[
name|_lines
index|]
operator|.
name|Found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CrossPosted
condition|)
block|{
comment|/* Install in header table; STRLEN("Xref: ") == 6. */
name|HDR
argument_list|(
name|_xref
argument_list|)
operator|=
name|Xref
operator|.
name|Data
operator|+
literal|6
expr_stmt|;
name|ARTheaders
index|[
name|_xref
index|]
operator|.
name|Length
operator|=
name|Xref
operator|.
name|Used
operator|-
literal|6
expr_stmt|;
name|ARTheaders
index|[
name|_xref
index|]
operator|.
name|Found
operator|=
literal|1
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|Xref
operator|.
name|Data
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
name|Xref
operator|.
name|Used
expr_stmt|;
name|size
operator|+=
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
expr_stmt|;
block|}
name|end
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|NL
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
literal|1
expr_stmt|;
name|size
operator|+=
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
expr_stmt|;
name|vp
operator|->
name|iov_base
operator|=
name|Data
operator|->
name|Body
expr_stmt|;
name|vp
operator|->
name|iov_len
operator|=
operator|&
name|Article
operator|->
name|Data
index|[
name|Article
operator|->
name|Used
index|]
operator|-
name|Data
operator|->
name|Body
expr_stmt|;
name|size
operator|+=
operator|(
name|vp
operator|++
operator|)
operator|->
name|iov_len
expr_stmt|;
name|Data
operator|->
name|SizeValue
operator|=
name|size
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Data
operator|->
name|Size
argument_list|,
literal|"%ld"
argument_list|,
name|Data
operator|->
name|SizeValue
argument_list|)
expr_stmt|;
name|Data
operator|->
name|SizeLength
operator|=
name|strlen
argument_list|(
name|Data
operator|->
name|Size
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_bytes
argument_list|)
operator|=
name|Data
operator|->
name|Size
expr_stmt|;
name|ARTheaders
index|[
name|_bytes
index|]
operator|.
name|Length
operator|=
name|Data
operator|->
name|SizeLength
expr_stmt|;
name|ARTheaders
index|[
name|_bytes
index|]
operator|.
name|Found
operator|=
literal|1
expr_stmt|;
comment|/* Now do the write. */
if|if
condition|(
name|xwritev
argument_list|(
name|fd
argument_list|,
name|iov
argument_list|,
name|vp
operator|-
name|iov
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close %s %m"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/* Set the owner. */
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Need the header data? */
if|if
condition|(
operator|!
name|NeedHeaders
condition|)
return|return
literal|0
return|;
comment|/* Figure out how much space we'll need and get it. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|bytesbuff
argument_list|,
literal|"Bytes: %ld\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|bytesbuff
argument_list|)
operator|,
name|vp
operator|=
name|iov
init|;
name|vp
operator|<
name|end
condition|;
name|vp
operator|++
control|)
name|i
operator|+=
name|vp
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
operator|!
name|CrossPosted
condition|)
name|i
operator|+=
name|Xref
operator|.
name|Used
expr_stmt|;
if|if
condition|(
name|Headers
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|Headers
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|Headers
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Headers
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Headers
operator|.
name|Size
operator|<=
name|i
condition|)
block|{
name|Headers
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|Headers
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Headers
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Add the data. */
name|BUFFset
argument_list|(
operator|&
name|Headers
argument_list|,
name|bytesbuff
argument_list|,
name|strlen
argument_list|(
name|bytesbuff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CrossPosted
condition|)
name|BUFFappend
argument_list|(
operator|&
name|Headers
argument_list|,
name|Xref
operator|.
name|Data
argument_list|,
name|Xref
operator|.
name|Used
argument_list|)
expr_stmt|;
for|for
control|(
name|vp
operator|=
name|iov
init|;
name|vp
operator|<
name|end
condition|;
name|vp
operator|++
control|)
name|BUFFappend
argument_list|(
operator|&
name|Headers
argument_list|,
name|vp
operator|->
name|iov_base
argument_list|,
name|vp
operator|->
name|iov_len
argument_list|)
expr_stmt|;
name|Data
operator|->
name|Headers
operator|=
operator|&
name|Headers
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  Parse a header that starts at in, copying it to out.  Return pointer to **  the start of the next header and fill in *deltap with what should **  get added to the output pointer.  (This nicely lets us clobber obsolete **  headers by setting it to zero.) */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|ARTparseheader
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|deltap
parameter_list|,
name|errorp
parameter_list|)
specifier|register
name|char
modifier|*
name|in
decl_stmt|;
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
name|int
modifier|*
name|deltap
decl_stmt|;
name|STRING
modifier|*
name|errorp
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|static
name|char
name|COLONSPACE
index|[]
init|=
literal|"No colon-space in \"%s\" header"
decl_stmt|;
specifier|register
name|char
modifier|*
name|start
decl_stmt|;
specifier|register
name|TREE
modifier|*
name|tp
decl_stmt|;
specifier|register
name|ARTHEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|dest
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|colon
decl_stmt|;
comment|/* Find a non-continuation line. */
for|for
control|(
name|colon
operator|=
name|NULL
operator|,
name|start
operator|=
name|out
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|in
condition|)
block|{
case|case
literal|'\0'
case|:
operator|*
name|errorp
operator|=
literal|"EOF in headers"
expr_stmt|;
return|return
name|NULL
return|;
case|case
literal|':'
case|:
if|if
condition|(
name|colon
operator|==
name|NULL
condition|)
name|colon
operator|=
name|out
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
operator|)
operator|==
literal|'\n'
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|in
argument_list|)
condition|)
break|break;
block|}
operator|*
name|deltap
operator|=
name|out
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|colon
operator|==
name|NULL
operator|||
operator|!
name|ISWHITE
argument_list|(
name|colon
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|COLONSPACE
argument_list|,
name|MaxLength
argument_list|(
name|start
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|errorp
operator|=
name|buff
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* See if this is a system header.  A fairly tightly-coded      * binary search. */
name|c
operator|=
name|CTYPE
argument_list|(
name|islower
argument_list|,
operator|*
name|start
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|start
argument_list|)
else|:
operator|*
name|start
expr_stmt|;
for|for
control|(
operator|*
name|colon
operator|=
literal|'\0'
operator|,
name|tp
operator|=
name|ARTheadertree
init|;
name|tp
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|c
operator|-
name|tp
operator|->
name|Name
index|[
literal|0
index|]
operator|)
operator|==
literal|0
operator|&&
operator|(
name|i
operator|=
name|strcasecmp
argument_list|(
name|start
argument_list|,
name|tp
operator|->
name|Name
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|tp
operator|=
name|tp
operator|->
name|Before
expr_stmt|;
else|else
name|tp
operator|=
name|tp
operator|->
name|After
expr_stmt|;
block|}
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
comment|/* Not a system header, make sure we have<word><colon><space>. */
for|for
control|(
name|p
operator|=
name|colon
init|;
operator|--
name|p
operator|!=
name|start
condition|;
control|)
if|if
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Space before colon in \"%s\" header"
argument_list|,
name|MaxLength
argument_list|(
name|start
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|errorp
operator|=
name|buff
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|in
return|;
block|}
comment|/* Found a known header; is it obsolete? */
name|hp
operator|=
name|tp
operator|->
name|Header
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|Type
operator|==
name|HTobs
condition|)
block|{
operator|*
name|deltap
operator|=
literal|0
expr_stmt|;
return|return
name|in
return|;
block|}
comment|/* If body of header is all blanks, drop the header. */
for|for
control|(
name|p
operator|=
name|colon
operator|+
literal|1
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|deltap
operator|=
literal|0
expr_stmt|;
return|return
name|in
return|;
block|}
name|hp
operator|->
name|Found
operator|++
expr_stmt|;
comment|/* Zap in the canonical form of the header, undoing the \0 that      * strcpy put out (strncpy() spec isn't trustable, unfortunately). */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|start
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|start
index|[
name|hp
operator|->
name|Size
index|]
operator|=
literal|':'
expr_stmt|;
comment|/* Copy the header if not too big. */
name|i
operator|=
operator|(
name|out
operator|-
literal|1
operator|)
operator|-
name|p
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAXHEADERSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"\"%s\" header too long"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
operator|*
name|errorp
operator|=
name|buff
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hp
operator|->
name|Length
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|MEMCPY_THRESHOLD
condition|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|POINTER
operator|)
name|hp
operator|->
name|Value
argument_list|,
operator|(
name|POINTER
operator|)
name|p
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|)
expr_stmt|;
name|hp
operator|->
name|Value
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|dest
operator|=
name|hp
operator|->
name|Value
operator|,
name|i
operator|++
init|;
operator|--
name|i
operator|>
literal|0
condition|;
control|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* **  Check Message-ID format based on RFC 822 grammar, except that (as per **  RFC 1036) whitespace, non-printing, and '>' characters are excluded. **  Based on code by Paul Eggert posted to news.software.b on 22-Nov-90 **  in<#*tyo2'~n@twinsun.com>, with additional email discussion. **  Thanks, Paul. */
end_comment

begin_function
name|BOOL
name|ARTidok
parameter_list|(
name|save
parameter_list|)
name|char
modifier|*
name|save
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Scan local-part:  "< atom|quoted [ . atom|quoted]" */
name|p
operator|=
name|save
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'<'
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ARTatomchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
while|while
condition|(
name|ARTatomchar
argument_list|(
operator|*
operator|++
name|p
argument_list|)
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'"'
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|ARTnormchar
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
return|return
name|FALSE
return|;
case|case
literal|'"'
case|:
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
break|break;
block|}
comment|/* Scan domain part:  "@ atom|domain [ . atom|domain]> \0" */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'@'
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ARTatomchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
while|while
condition|(
name|ARTatomchar
argument_list|(
operator|*
operator|++
name|p
argument_list|)
condition|)
continue|continue;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'['
condition|)
return|return
name|FALSE
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|ARTnormchar
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* FALLTHROUGH */
case|case
literal|'['
case|:
return|return
name|FALSE
return|;
case|case
literal|']'
case|:
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
break|break;
block|}
return|return
operator|*
name|p
operator|==
literal|'>'
operator|&&
operator|*
operator|++
name|p
operator|==
literal|'\0'
operator|&&
name|p
operator|-
name|save
operator|<=
name|DBZMAXKEY
return|;
block|}
end_function

begin_comment
comment|/* **  Clean up an article.  This is mainly copying in-place, stripping bad **  headers.  Also fill in the article data block with what we can find. **  Return NULL if the article is okay, or a string describing the error. */
end_comment

begin_function
name|STATIC
name|STRING
name|ARTclean
parameter_list|(
name|Article
parameter_list|,
name|Data
parameter_list|)
name|BUFFER
modifier|*
name|Article
decl_stmt|;
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|ARTHEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|in
decl_stmt|;
specifier|register
name|char
modifier|*
name|out
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|STRING
name|error
decl_stmt|;
name|int
name|delta
decl_stmt|;
comment|/* Read through the headers one at a time. */
name|Data
operator|->
name|Feedsite
operator|=
literal|"?"
expr_stmt|;
name|Data
operator|->
name|Size
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|Data
operator|->
name|Size
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|ARTheaders
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|ARTheaders
argument_list|)
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|Value
operator|&&
name|hp
operator|->
name|Type
operator|!=
name|HTobs
condition|)
operator|*
name|hp
operator|->
name|Value
operator|=
literal|'\0'
expr_stmt|;
name|hp
operator|->
name|Found
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|error
operator|=
name|NULL
operator|,
name|in
operator|=
name|out
operator|=
name|Article
operator|->
name|Data
init|;
condition|;
name|out
operator|+=
name|delta
operator|,
name|in
operator|=
name|p
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|==
literal|'\0'
condition|)
block|{
name|error
operator|=
literal|"No body"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|in
operator|==
literal|'\n'
operator|&&
name|out
operator|>
name|Article
operator|->
name|Data
operator|&&
name|out
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
comment|/* Found a \n after another \n; break out. */
break|break;
comment|/* Check the validity of this header. */
if|if
condition|(
operator|(
name|p
operator|=
name|ARTparseheader
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
name|Data
operator|->
name|Body
operator|=
name|out
expr_stmt|;
name|in
operator|++
expr_stmt|;
comment|/* Try to set this now, so we can report it in errors. */
name|p
operator|=
name|HDR
argument_list|(
name|_message_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|Data
operator|->
name|MessageID
operator|=
name|p
expr_stmt|;
name|Data
operator|->
name|MessageIDLength
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|Data
operator|->
name|MessageIDLength
operator|>
name|DBZMAXKEY
condition|)
name|error
operator|=
literal|"\"Message-ID\" header too long"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ARTidok
argument_list|(
name|p
argument_list|)
condition|)
name|error
operator|=
literal|"Bad \"Message-ID\" header"
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Make sure all the headers we need are there, and no duplicates. */
for|for
control|(
name|hp
operator|=
name|ARTheaders
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|ARTheaders
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Type
operator|==
name|HTreq
condition|)
block|{
if|if
condition|(
operator|*
name|hp
operator|->
name|Value
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Missing \"%s\" header"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
if|if
condition|(
name|hp
operator|->
name|Found
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Duplicate \"%s\" header"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
comment|/* Scan the body, counting lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|in
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|in
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|out
operator|++
operator|=
operator|*
name|in
operator|++
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
name|Article
operator|->
name|Used
operator|=
name|out
operator|-
name|Article
operator|->
name|Data
expr_stmt|;
name|Data
operator|->
name|LinesValue
operator|=
name|i
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_CHECK_LINECOUNT
argument_list|)
name|p
operator|=
name|HDR
argument_list|(
name|_lines
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&&
operator|(
name|delta
operator|=
name|i
operator|-
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|abs
argument_list|(
name|delta
argument_list|)
operator|>
name|LINECOUNT_FUZZ
condition|)
block|{
if|if
condition|(
operator|(
name|in
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|in
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Linecount %s != %d +- %d"
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|,
name|i
argument_list|,
name|LINECOUNT_FUZZ
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
endif|#
directive|endif
comment|/* defined(DO_CHECK_LINECOUNT) */
comment|/* Is article too old? */
name|p
operator|=
name|HDR
argument_list|(
name|_date
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Data
operator|->
name|Posted
operator|=
name|parsedate
argument_list|(
name|p
argument_list|,
operator|&
name|Now
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Bad \"Date\" header -- \"%s\""
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
if|if
condition|(
name|Cutoff
operator|&&
name|Data
operator|->
name|Posted
operator|<
name|Now
operator|.
name|time
operator|-
name|Cutoff
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Too old -- \"%s\""
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
if|if
condition|(
name|Data
operator|->
name|Posted
operator|>
name|Now
operator|.
name|time
operator|+
name|DATE_FUZZ
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Article posted in the future -- \"%s\""
argument_list|,
name|MaxLength
argument_list|(
name|p
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
name|Data
operator|->
name|Arrived
operator|=
name|Now
operator|.
name|time
expr_stmt|;
name|p
operator|=
name|HDR
argument_list|(
name|_expires
argument_list|)
expr_stmt|;
name|Data
operator|->
name|Expires
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|(
name|Data
operator|->
name|Expires
operator|=
name|parsedate
argument_list|(
name|p
argument_list|,
operator|&
name|Now
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
literal|0
block|(void)sprintf(buff, "Bad \"Expires\" header -- \"%s\"", 		MaxLength(p, p)); 	return buff;
endif|#
directive|endif
block|}
comment|/* Whitespace in the Newsgroups header? */
for|for
control|(
name|p
operator|=
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Whitespace in \"Newsgroups\" header -- \"%s\""
argument_list|,
name|MaxLength
argument_list|(
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
comment|/* If there is no control header, see if the article starts with      * "cmsg ". */
name|in
operator|=
name|HDR
argument_list|(
name|_control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|in
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
name|HDR
argument_list|(
name|_subject
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'c'
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"cmsg "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|+=
literal|5
init|;
operator|*
name|p
operator|&&
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|in
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Start a log message about an article. */
end_comment

begin_function
name|STATIC
name|void
name|ARTlog
parameter_list|(
name|Data
parameter_list|,
name|code
parameter_list|,
name|text
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|char
name|code
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|BOOL
name|Done
decl_stmt|;
comment|/* We could be a bit faster by not dividing Now.usec by 1000,      * but who really wants to log at the Microsec level? */
name|Done
operator|=
name|code
operator|==
name|ART_ACCEPT
operator|||
name|code
operator|==
name|ART_JUNK
expr_stmt|;
if|if
condition|(
name|text
condition|)
name|i
operator|=
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"%.15s.%03.3d %c %s %s %s%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|Now
operator|.
name|time
argument_list|)
operator|+
literal|4
argument_list|,
call|(
name|int
call|)
argument_list|(
name|Now
operator|.
name|usec
operator|/
literal|1000
argument_list|)
argument_list|,
name|code
argument_list|,
name|Data
operator|->
name|Feedsite
argument_list|,
name|Data
operator|->
name|MessageID
argument_list|,
name|text
argument_list|,
name|Done
condition|?
literal|""
else|:
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|"%.15s.%03.3d %c %s %s%s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|Now
operator|.
name|time
argument_list|)
operator|+
literal|4
argument_list|,
call|(
name|int
call|)
argument_list|(
name|Now
operator|.
name|usec
operator|/
literal|1000
argument_list|)
argument_list|,
name|code
argument_list|,
name|Data
operator|->
name|Feedsite
argument_list|,
name|Data
operator|->
name|MessageID
argument_list|,
name|Done
condition|?
literal|""
else|:
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|EOF
operator|||
operator|(
name|Done
operator|&&
operator|!
name|BufferedLogs
operator|&&
name|fflush
argument_list|(
name|Log
argument_list|)
operator|)
operator|||
name|ferror
argument_list|(
name|Log
argument_list|)
condition|)
block|{
name|IOError
argument_list|(
literal|"logging article"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write log_start %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|Log
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  We are going to reject an article, record the reason and **  and the article.  For now, this is just a placeholder. */
end_comment

begin_comment
comment|/* ARGSUSED0 */
end_comment

begin_function
name|STATIC
name|void
name|ARTreject
parameter_list|(
name|buff
parameter_list|,
name|article
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|BUFFER
modifier|*
name|article
decl_stmt|;
block|{ }
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_VERIFY_CANCELS
argument_list|)
end_if

begin_comment
comment|/* **  Verify if a cancel message is valid.  If the user posting the cancel **  matches the user who posted the article, return the list of filenames **  otherwise return NULL. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|ARTcancelverify
parameter_list|(
name|Data
parameter_list|,
name|MessageID
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|char
modifier|*
name|MessageID
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|files
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|local
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|files
operator|=
name|HISfilesfor
argument_list|(
name|MessageID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
name|ARTreadheader
argument_list|(
name|files
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Get the author header. */
if|if
condition|(
operator|(
name|local
operator|=
name|HeaderFind
argument_list|(
name|head
argument_list|,
literal|"Sender"
argument_list|,
literal|6
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|local
operator|=
name|HeaderFind
argument_list|(
name|head
argument_list|,
literal|"From"
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_article %s checking cancel"
argument_list|,
name|LogName
argument_list|,
name|MessageID
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|HeaderCleanFrom
argument_list|(
name|local
argument_list|)
expr_stmt|;
comment|/* Compare canonical forms. */
name|p
operator|=
name|COPY
argument_list|(
name|Data
operator|->
name|Poster
argument_list|)
expr_stmt|;
name|HeaderCleanFrom
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQ
argument_list|(
name|local
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|files
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"\"%.50s\" wants to cancel %s by \"%.50s\""
argument_list|,
name|p
argument_list|,
name|MaxLength
argument_list|(
name|MessageID
argument_list|,
name|MessageID
argument_list|)
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|files
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_VERIFY_CANCELS) */
end_comment

begin_comment
comment|/* **  Process a cancel message. */
end_comment

begin_comment
comment|/* ARGSUSED2 */
end_comment

begin_function
name|void
name|ARTcancel
parameter_list|(
name|Data
parameter_list|,
name|MessageID
parameter_list|,
name|Trusted
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|char
modifier|*
name|MessageID
decl_stmt|;
name|BOOL
name|Trusted
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|files
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|BOOL
name|more
decl_stmt|;
name|STRING
name|save
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|HIShavearticle
argument_list|(
name|MessageID
argument_list|)
condition|)
block|{
comment|/* Article hasn't arrived here, so write a fake entry using 	 * most of the information from the cancel message. */
if|#
directive|if
name|defined
argument_list|(
name|DO_VERIFY_CANCELS
argument_list|)
if|if
condition|(
operator|!
name|Trusted
condition|)
return|return;
endif|#
directive|endif
comment|/* defined(DO_VERIFY_CANCELS) */
name|save
operator|=
name|Data
operator|->
name|MessageID
expr_stmt|;
name|Data
operator|->
name|MessageID
operator|=
name|MessageID
expr_stmt|;
operator|(
name|void
operator|)
name|HISwrite
argument_list|(
name|Data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Data
operator|->
name|MessageID
operator|=
name|save
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"Cancelling %s"
argument_list|,
name|MessageID
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
name|Data
argument_list|,
name|ART_CANC
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DO_VERIFY_CANCELS
argument_list|)
name|files
operator|=
name|Trusted
condition|?
name|HISfilesfor
argument_list|(
name|MessageID
argument_list|)
else|:
name|ARTcancelverify
argument_list|(
name|Data
argument_list|,
name|MessageID
argument_list|)
expr_stmt|;
else|#
directive|else
name|files
operator|=
name|HISfilesfor
argument_list|(
name|MessageID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(DO_VERIFY_CANCELS) */
if|if
condition|(
name|files
operator|==
name|NULL
condition|)
return|return;
comment|/* Get the files where the message is stored and and zap them. */
for|for
control|(
init|;
operator|*
name|files
condition|;
name|files
operator|=
name|p
operator|+
literal|1
control|)
block|{
comment|/* Snip off next name, turn dots to slashes. */
for|for
control|(
name|p
operator|=
name|files
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
for|for
control|(
name|files
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|more
operator|=
operator|*
name|p
operator|==
literal|' '
expr_stmt|;
if|if
condition|(
name|more
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove this file, go back for the next one if there's more. */
if|if
condition|(
name|unlink
argument_list|(
name|files
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|files
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* **  Process a control message.  Cancels are handled here, but any others **  are passed out to an external program in a specific directory that **  has the same name as the first word of the control message. */
end_comment

begin_function
name|STATIC
name|void
name|ARTcontrol
parameter_list|(
name|Data
parameter_list|,
name|Control
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|char
modifier|*
name|Control
decl_stmt|;
block|{
specifier|static
name|char
name|CTLBIN
index|[]
init|=
name|_PATH_CONTROLPROGS
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|char
modifier|*
name|av
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
comment|/* See if it's a cancel message. */
name|c
operator|=
operator|*
name|Control
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'c'
operator|&&
name|EQn
argument_list|(
name|Control
argument_list|,
literal|"cancel"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
name|Control
index|[
literal|6
index|]
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
condition|)
name|ARTcancel
argument_list|(
name|Data
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Nip off the first word into lowercase. */
for|for
control|(
name|p
operator|=
name|Control
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|CTYPE
argument_list|(
name|isupper
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Treat the control message as a place to send the article, if      * the name is "safe" -- no slashes in the pathname. */
if|if
condition|(
name|p
operator|-
name|Control
operator|+
name|STRLEN
argument_list|(
name|_PATH_BADCONTROLPROG
argument_list|)
operator|>=
name|SMBUF
operator|-
literal|4
operator|||
name|strchr
argument_list|(
name|Control
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|FileGlue
argument_list|(
name|buff
argument_list|,
name|CTLBIN
argument_list|,
literal|'/'
argument_list|,
name|_PATH_BADCONTROLPROG
argument_list|)
expr_stmt|;
else|else
block|{
name|FileGlue
argument_list|(
name|buff
argument_list|,
name|CTLBIN
argument_list|,
literal|'/'
argument_list|,
name|Control
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buff
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|Sb
operator|.
name|st_mode
operator|&
name|EXECUTE_BITS
operator|)
operator|==
literal|0
condition|)
name|FileGlue
argument_list|(
name|buff
argument_list|,
name|CTLBIN
argument_list|,
literal|'/'
argument_list|,
name|_PATH_BADCONTROLPROG
argument_list|)
expr_stmt|;
block|}
comment|/* If it's an ihave or sendme, check the site named in the message. */
if|if
condition|(
operator|(
name|c
operator|==
literal|'i'
operator|&&
name|EQ
argument_list|(
name|Control
argument_list|,
literal|"ihave"
argument_list|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'s'
operator|&&
name|EQ
argument_list|(
name|Control
argument_list|,
literal|"sendme"
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s malformed %s no site %s"
argument_list|,
name|LogName
argument_list|,
name|Control
argument_list|,
name|Data
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|EQ
argument_list|(
name|p
argument_list|,
name|ARTpathme
argument_list|)
condition|)
block|{
comment|/* Do nothing -- must have come from a replicant. */
name|syslog
argument_list|(
name|L_NOTICE
argument_list|,
literal|"%s %s_from_me %s"
argument_list|,
name|Data
operator|->
name|Feedsite
argument_list|,
name|Control
argument_list|,
name|Data
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|SITEfind
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_ihave in %s"
argument_list|,
name|Data
operator|->
name|Feedsite
argument_list|,
name|Data
operator|->
name|Newsgroups
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_sendme dont feed %s"
argument_list|,
name|Data
operator|->
name|Feedsite
argument_list|,
name|Control
argument_list|,
name|Data
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Build the command vector and execute it. */
name|av
index|[
literal|0
index|]
operator|=
name|buff
expr_stmt|;
name|av
index|[
literal|1
index|]
operator|=
name|COPY
argument_list|(
name|Data
operator|->
name|Poster
argument_list|)
expr_stmt|;
name|av
index|[
literal|2
index|]
operator|=
name|COPY
argument_list|(
name|Data
operator|->
name|Replyto
argument_list|)
expr_stmt|;
name|av
index|[
literal|3
index|]
operator|=
name|Data
operator|->
name|Name
expr_stmt|;
name|av
index|[
literal|4
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|Data
operator|->
name|Feedsite
expr_stmt|;
name|av
index|[
literal|5
index|]
operator|=
name|NULL
expr_stmt|;
name|HeaderCleanFrom
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|HeaderCleanFrom
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Spawn
argument_list|(
name|STDIN
argument_list|,
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|Errlog
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|Errlog
argument_list|)
argument_list|,
name|av
argument_list|)
operator|<
literal|0
condition|)
comment|/* We know the strrchr below can't fail. */
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant spawn %s for %s %m"
argument_list|,
name|LogName
argument_list|,
name|MaxLength
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
name|strrchr
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
argument_list|)
argument_list|,
name|Data
operator|->
name|Name
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Split a Distribution header, making a copy and skipping leading and **  trailing whitespace (which the RFC allows). */
end_comment

begin_function
name|STATIC
name|void
name|DISTparse
parameter_list|(
name|list
parameter_list|,
name|Data
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
block|{
specifier|static
name|BUFFER
name|Dist
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* Get space to store the copy. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|list
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|j
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dist
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|Dist
operator|.
name|Size
operator|=
name|j
expr_stmt|;
name|Dist
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Dist
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Dist
operator|.
name|Size
operator|<=
name|j
condition|)
block|{
name|Dist
operator|.
name|Size
operator|=
name|j
operator|+
literal|16
expr_stmt|;
name|RENEW
argument_list|(
name|Dist
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Dist
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Loop over each element, skip and trim whitespace. */
for|for
control|(
name|q
operator|=
name|Dist
operator|.
name|Data
operator|,
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|list
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|j
condition|)
operator|*
name|q
operator|++
operator|=
literal|','
expr_stmt|;
for|for
control|(
name|list
index|[
name|j
operator|++
index|]
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|list
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|Data
operator|->
name|Distribution
operator|=
name|Dist
operator|.
name|Data
expr_stmt|;
name|Data
operator|->
name|DistributionLength
operator|=
name|q
operator|-
name|Dist
operator|.
name|Data
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  A somewhat similar routine, except that this handles negated entries **  in the list and is used to check the distribution sub-field. */
end_comment

begin_function
name|STATIC
name|BOOL
name|DISTwanted
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|BOOL
name|sawbang
decl_stmt|;
for|for
control|(
name|sawbang
operator|=
name|FALSE
operator|,
name|c
operator|=
operator|*
name|p
init|;
operator|(
name|q
operator|=
operator|*
name|list
operator|)
operator|!=
name|NULL
condition|;
name|list
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'!'
condition|)
block|{
name|sawbang
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
operator|++
name|q
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|*
name|q
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* If we saw any !foo's and didn't match, then assume they are all      * negated distributions and return TRUE, else return false. */
return|return
name|sawbang
return|;
block|}
end_function

begin_comment
comment|/* **  See if any of the distributions in the article are wanted by the site. */
end_comment

begin_function
name|STATIC
name|BOOL
name|DISTwantany
parameter_list|(
name|site
parameter_list|,
name|article
parameter_list|)
name|char
modifier|*
modifier|*
name|site
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|article
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|article
condition|;
name|article
operator|++
control|)
if|if
condition|(
name|DISTwanted
argument_list|(
name|site
argument_list|,
operator|*
name|article
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Sort an array of newsgroups for optimal disk access.  This may be **  of marginal benefit. */
end_comment

begin_function
name|STATIC
name|void
name|ARTsortfordisk
parameter_list|()
block|{
specifier|static
name|NEWSGROUP
modifier|*
name|save
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
modifier|*
name|ngptr
decl_stmt|;
if|if
condition|(
name|save
operator|&&
name|GroupPointers
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* If one of the groups we want to access is the group we last 	 * wrote to, move it to the front of the list. */
for|for
control|(
name|ngptr
operator|=
name|GroupPointers
init|;
operator|*
operator|++
name|ngptr
condition|;
control|)
if|if
condition|(
operator|*
name|ngptr
operator|==
name|save
condition|)
block|{
operator|*
name|ngptr
operator|=
name|GroupPointers
index|[
literal|0
index|]
expr_stmt|;
name|GroupPointers
index|[
literal|0
index|]
operator|=
name|save
expr_stmt|;
return|return;
block|}
block|}
name|save
operator|=
name|GroupPointers
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Send the current article to all sites that would get it if the **  group were created. */
end_comment

begin_function
name|STATIC
name|void
name|ARTsendthegroup
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
for|for
control|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|ARTctl
argument_list|)
operator|,
name|sp
operator|=
name|Sites
operator|,
name|i
operator|=
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Name
operator|!=
name|NULL
operator|&&
name|SITEwantsgroup
argument_list|(
name|sp
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|SITEmark
argument_list|(
name|sp
argument_list|,
name|ngp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** Assign article numbers to the article and create the Xref line. ** If we end up not being able to write the article, we'll get "holes" ** in the directory and active file. */
end_comment

begin_function
name|STATIC
name|void
name|ARTassignnumbers
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|p
operator|=
operator|&
name|Xref
operator|.
name|Data
index|[
name|Xref
operator|.
name|Used
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ngp
operator|=
name|GroupPointers
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* If already went to this group (i.e., multiple groups are aliased 	 * into it), then skip it. */
if|if
condition|(
name|ngp
operator|->
name|PostCount
operator|>
literal|0
condition|)
continue|continue;
comment|/* Bump the number. */
name|ngp
operator|->
name|PostCount
operator|++
expr_stmt|;
name|ngp
operator|->
name|Last
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|FormatLong
argument_list|(
name|ngp
operator|->
name|LastString
argument_list|,
operator|(
name|long
operator|)
name|ngp
operator|->
name|Last
argument_list|,
name|ngp
operator|->
name|Lastwidth
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant update_active %s"
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ngp
operator|->
name|Filenum
operator|=
name|ngp
operator|->
name|Last
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" %s:%lu"
argument_list|,
name|ngp
operator|->
name|Name
argument_list|,
name|ngp
operator|->
name|Filenum
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|Xref
operator|.
name|Used
operator|=
name|p
operator|-
name|Xref
operator|.
name|Data
expr_stmt|;
name|Xref
operator|.
name|Data
index|[
name|Xref
operator|.
name|Used
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Parse the data from the xreplic command and assign the numbers. **  This involves replacing the GroupPointers entries. */
end_comment

begin_function
name|STATIC
name|void
name|ARTreplic
parameter_list|(
name|Replic
parameter_list|,
name|CrossPostedp
parameter_list|)
name|BUFFER
modifier|*
name|Replic
decl_stmt|;
name|BOOL
modifier|*
name|CrossPostedp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|&
name|Xref
operator|.
name|Data
index|[
name|Xref
operator|.
name|Used
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|name
operator|=
name|Replic
operator|->
name|Data
init|;
operator|*
name|name
condition|;
name|name
operator|=
name|next
control|)
block|{
comment|/* Mark end of this entry and where next one starts. */
if|if
condition|(
operator|(
name|next
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|','
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|next
operator|++
operator|=
literal|'\0'
expr_stmt|;
else|else
name|next
operator|=
literal|""
expr_stmt|;
comment|/* Split into news.group/# */
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_format %s"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_newsgroup %s"
argument_list|,
name|LogName
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ngp
operator|->
name|Filenum
operator|=
name|atol
argument_list|(
name|q
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Update active file if we got a new high-water mark. */
if|if
condition|(
name|ngp
operator|->
name|Last
operator|<
name|ngp
operator|->
name|Filenum
condition|)
block|{
name|ngp
operator|->
name|Last
operator|=
name|ngp
operator|->
name|Filenum
expr_stmt|;
if|if
condition|(
operator|!
name|FormatLong
argument_list|(
name|ngp
operator|->
name|LastString
argument_list|,
operator|(
name|long
operator|)
name|ngp
operator|->
name|Last
argument_list|,
name|ngp
operator|->
name|Lastwidth
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant update_active %s"
argument_list|,
name|LogName
argument_list|,
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Mark that this group gets the article. */
name|ngp
operator|->
name|PostCount
operator|++
expr_stmt|;
name|GroupPointers
index|[
name|i
operator|++
index|]
operator|=
name|ngp
expr_stmt|;
comment|/* Turn news.group/# into news.group:#, append to Xref. */
operator|*
name|q
operator|=
literal|':'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|CrossPostedp
operator|=
name|i
operator|>
literal|1
operator|||
name|AlwaysCrosspost
expr_stmt|;
name|Xref
operator|.
name|Used
operator|=
name|p
operator|-
name|Xref
operator|.
name|Data
expr_stmt|;
name|Xref
operator|.
name|Data
index|[
name|Xref
operator|.
name|Used
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Return TRUE if a list of strings has a specific one.  This is a **  generic routine, but is used for seeing if a host is in the Path line. */
end_comment

begin_function
name|STATIC
name|BOOL
name|ListHas
parameter_list|(
name|list
parameter_list|,
name|p
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
operator|*
name|p
init|;
operator|(
name|q
operator|=
operator|*
name|list
operator|)
operator|!=
name|NULL
condition|;
name|list
operator|++
control|)
if|if
condition|(
name|c
operator|==
operator|*
name|q
operator|&&
name|caseEQ
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* **  Propagate an article to the sites have "expressed an interest." */
end_comment

begin_function
name|STATIC
name|void
name|ARTpropagate
parameter_list|(
name|Data
parameter_list|,
name|hops
parameter_list|,
name|hopcount
parameter_list|,
name|list
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
name|char
modifier|*
modifier|*
name|hops
decl_stmt|;
name|int
name|hopcount
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|Groupcount
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|funnel
decl_stmt|;
specifier|register
name|BUFFER
modifier|*
name|bp
decl_stmt|;
comment|/* Work out which sites should really get it. */
name|Groupcount
operator|=
name|Data
operator|->
name|Groupcount
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|Sites
operator|,
name|i
operator|=
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|Seenit
operator|||
operator|!
name|sp
operator|->
name|Sendit
condition|)
continue|continue;
name|sp
operator|->
name|Sendit
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Master
operator|!=
name|NOSITE
operator|&&
name|Sites
index|[
name|sp
operator|->
name|Master
index|]
operator|.
name|Seenit
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|MaxSize
operator|&&
name|sp
operator|->
name|MaxSize
operator|<
name|Data
operator|->
name|SizeValue
condition|)
comment|/* Too big for the site. */
continue|continue;
if|if
condition|(
operator|(
operator|!
name|sp
operator|->
name|IgnorePath
operator|&&
name|ListHas
argument_list|(
name|hops
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
operator|)
operator|||
operator|(
name|sp
operator|->
name|Hops
operator|&&
name|hopcount
operator|>
name|sp
operator|->
name|Hops
operator|)
operator|||
operator|(
name|sp
operator|->
name|Groupcount
operator|&&
name|Groupcount
operator|>
name|sp
operator|->
name|Groupcount
operator|)
condition|)
comment|/* Site already saw the article; path too long; or too much 	     * cross-posting. */
continue|continue;
if|if
condition|(
name|list
operator|&&
name|sp
operator|->
name|Distributions
operator|&&
operator|!
name|DISTwantany
argument_list|(
name|sp
operator|->
name|Distributions
argument_list|,
name|list
argument_list|)
condition|)
comment|/* Not in the site's desired list of distributions. */
continue|continue;
if|if
condition|(
name|sp
operator|->
name|DistRequired
operator|&&
name|list
operator|==
name|NULL
condition|)
comment|/* Site requires Distribution header and there isn't one. */
continue|continue;
if|if
condition|(
name|sp
operator|->
name|Exclusions
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|sp
operator|->
name|Exclusions
index|[
name|j
index|]
operator|)
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|ListHas
argument_list|(
name|hops
argument_list|,
name|p
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
comment|/* A host in the site's exclusion list was in the Path. */
continue|continue;
block|}
comment|/* Write that the site is getting it, and flag to send it. */
if|if
condition|(
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|" %s"
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|Log
argument_list|)
condition|)
block|{
name|IOError
argument_list|(
literal|"logging site"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write log_site %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|Log
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|Sendit
operator|=
name|TRUE
expr_stmt|;
name|sp
operator|->
name|Seenit
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Master
operator|!=
name|NOSITE
condition|)
name|Sites
index|[
name|sp
operator|->
name|Master
index|]
operator|.
name|Seenit
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|Log
argument_list|)
operator|==
name|EOF
operator|||
operator|(
operator|!
name|BufferedLogs
operator|&&
name|fflush
argument_list|(
name|Log
argument_list|)
operator|)
operator|||
name|ferror
argument_list|(
name|Log
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write log_end %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|Log
argument_list|)
expr_stmt|;
block|}
comment|/* Handle funnel sites. */
for|for
control|(
name|sp
operator|=
name|Sites
operator|,
name|i
operator|=
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Sendit
operator|&&
name|sp
operator|->
name|Funnel
operator|!=
name|NOSITE
condition|)
block|{
name|sp
operator|->
name|Sendit
operator|=
name|FALSE
expr_stmt|;
name|funnel
operator|=
operator|&
name|Sites
index|[
name|sp
operator|->
name|Funnel
index|]
expr_stmt|;
name|funnel
operator|->
name|Sendit
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|funnel
operator|->
name|FNLwantsnames
condition|)
block|{
name|bp
operator|=
operator|&
name|funnel
operator|->
name|FNLnames
expr_stmt|;
name|p
operator|=
operator|&
name|bp
operator|->
name|Data
index|[
name|bp
operator|->
name|Used
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Used
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|bp
operator|->
name|Used
operator|++
expr_stmt|;
block|}
name|bp
operator|->
name|Used
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|sp
operator|->
name|Name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Build up the overview data. */
end_comment

begin_function
name|STATIC
name|void
name|ARTmakeoverview
parameter_list|(
name|Data
parameter_list|)
name|ARTDATA
modifier|*
name|Data
decl_stmt|;
block|{
specifier|static
name|char
name|SEP
index|[]
init|=
literal|"\t"
decl_stmt|;
specifier|static
name|char
name|COLONSPACE
index|[]
init|=
literal|": "
decl_stmt|;
specifier|static
name|BUFFER
name|Overview
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
specifier|register
name|ARTHEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Setup. */
if|if
condition|(
name|Overview
operator|.
name|Data
operator|==
name|NULL
condition|)
name|Overview
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Data
operator|->
name|Overview
operator|=
operator|&
name|Overview
expr_stmt|;
name|BUFFset
argument_list|(
operator|&
name|Overview
argument_list|,
name|Xref
operator|.
name|Data
operator|+
name|Xrefbase
operator|+
literal|1
argument_list|,
name|Xref
operator|.
name|Used
operator|-
operator|(
name|Xrefbase
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|Overview
operator|.
name|Left
operator|,
name|p
operator|=
name|Overview
operator|.
name|Data
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
operator|||
operator|*
name|p
operator|==
literal|':'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|ARTfields
operator|==
name|NULL
condition|)
block|{
comment|/* User error. */
return|return;
block|}
comment|/* Write the data, a field at a time. */
for|for
control|(
name|fp
operator|=
name|ARTfields
init|;
name|fp
operator|->
name|Header
condition|;
name|fp
operator|++
control|)
block|{
name|BUFFappend
argument_list|(
operator|&
name|Overview
argument_list|,
name|SEP
argument_list|,
name|STRLEN
argument_list|(
name|SEP
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|=
name|fp
operator|->
name|Header
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|Found
condition|)
continue|continue;
if|if
condition|(
name|fp
operator|->
name|NeedHeader
condition|)
block|{
name|BUFFappend
argument_list|(
operator|&
name|Overview
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Size
argument_list|)
expr_stmt|;
name|BUFFappend
argument_list|(
operator|&
name|Overview
argument_list|,
name|COLONSPACE
argument_list|,
name|STRLEN
argument_list|(
name|COLONSPACE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|Overview
operator|.
name|Left
expr_stmt|;
name|BUFFappend
argument_list|(
operator|&
name|Overview
argument_list|,
name|hp
operator|->
name|Value
argument_list|,
name|hp
operator|->
name|Length
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|Overview
operator|.
name|Data
index|[
name|i
index|]
init|;
name|i
operator|<
name|Overview
operator|.
name|Left
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  This routine is the heart of it all.  Take a full article, parse it, **  file or reject it, feed it to the other sites.  Return the NNTP **  message to send back. */
end_comment

begin_function
name|STRING
name|ARTpost
parameter_list|(
name|cp
parameter_list|,
name|Replic
parameter_list|,
name|ihave
parameter_list|)
name|CHANNEL
modifier|*
name|cp
decl_stmt|;
name|BUFFER
modifier|*
name|Replic
decl_stmt|;
name|char
modifier|*
name|ihave
decl_stmt|;
block|{
specifier|static
name|char
name|errNOSPACE
index|[]
init|=
name|NNTP_RESENDIT_NOSPACE
decl_stmt|;
specifier|static
name|char
name|errNOHIST
index|[]
init|=
name|NNTP_RESENDIT_NOHIST
decl_stmt|;
specifier|static
name|BUFFER
name|Files
decl_stmt|;
specifier|static
name|BUFFER
name|Header
decl_stmt|;
specifier|static
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
modifier|*
name|ngptr
decl_stmt|;
specifier|register
name|int
modifier|*
name|isp
decl_stmt|;
specifier|register
name|SITE
modifier|*
name|sp
decl_stmt|;
name|ARTDATA
name|Data
decl_stmt|;
name|BOOL
name|Approved
decl_stmt|;
name|BOOL
name|Accepted
decl_stmt|;
name|BOOL
name|LikeNewgroup
decl_stmt|;
name|BOOL
name|CrossPosted
decl_stmt|;
name|BOOL
name|ToGroup
decl_stmt|;
name|BOOL
name|GroupMissing
decl_stmt|;
name|BUFFER
modifier|*
name|article
decl_stmt|;
name|char
name|linkname
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|groups
decl_stmt|;
name|char
modifier|*
modifier|*
name|hops
decl_stmt|;
name|int
name|hopcount
decl_stmt|;
name|char
modifier|*
modifier|*
name|distributions
decl_stmt|;
name|STRING
name|error
decl_stmt|;
name|char
name|ControlWord
index|[
name|SMBUF
index|]
decl_stmt|;
name|int
name|ControlHeader
decl_stmt|;
comment|/* Preliminary clean-ups. */
name|article
operator|=
operator|&
name|cp
operator|->
name|In
expr_stmt|;
name|Data
operator|.
name|MessageID
operator|=
name|ihave
expr_stmt|;
name|error
operator|=
name|ARTclean
argument_list|(
name|article
argument_list|,
operator|&
name|Data
argument_list|)
expr_stmt|;
comment|/* Fill in other Data fields. */
name|Data
operator|.
name|Poster
operator|=
name|HDR
argument_list|(
name|_sender
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Data
operator|.
name|Poster
operator|==
literal|'\0'
condition|)
name|Data
operator|.
name|Poster
operator|=
name|HDR
argument_list|(
name|_from
argument_list|)
expr_stmt|;
name|Data
operator|.
name|Replyto
operator|=
name|HDR
argument_list|(
name|_reply_to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Data
operator|.
name|Replyto
operator|==
literal|'\0'
condition|)
name|Data
operator|.
name|Replyto
operator|=
name|HDR
argument_list|(
name|_from
argument_list|)
expr_stmt|;
name|hops
operator|=
name|ARTparsepath
argument_list|(
name|HDR
argument_list|(
name|_path
argument_list|)
argument_list|,
operator|&
name|hopcount
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_IPADDR_LOG
argument_list|)
name|Data
operator|.
name|Feedsite
operator|=
name|RChostname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Data
operator|.
name|Feedsite
operator|==
name|NULL
condition|)
name|Data
operator|.
name|Feedsite
operator|=
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|#
directive|else
name|Data
operator|.
name|Feedsite
operator|=
name|hops
operator|&&
name|hops
index|[
literal|0
index|]
condition|?
name|hops
index|[
literal|0
index|]
else|:
name|CHANname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_IPADDRLOG) */
name|Data
operator|.
name|FeedsiteLength
operator|=
name|strlen
argument_list|(
name|Data
operator|.
name|Feedsite
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Data
operator|.
name|TimeReceived
argument_list|,
literal|"%lu"
argument_list|,
name|Now
operator|.
name|time
argument_list|)
expr_stmt|;
name|Data
operator|.
name|TimeReceivedLength
operator|=
name|strlen
argument_list|(
name|Data
operator|.
name|TimeReceived
argument_list|)
expr_stmt|;
comment|/* A duplicate? */
if|if
condition|(
name|error
operator|==
name|NULL
operator|&&
name|HIShavearticle
argument_list|(
name|Data
operator|.
name|MessageID
argument_list|)
condition|)
name|error
operator|=
literal|"Duplicate article"
expr_stmt|;
comment|/* Now see if we got an error in the article. */
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d %s"
argument_list|,
name|NNTP_REJECTIT_VAL
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
comment|/* Stash a copy of the Newsgroups header. */
name|p
operator|=
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|Header
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|Header
operator|.
name|Size
operator|=
name|i
expr_stmt|;
name|Header
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Header
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Header
operator|.
name|Size
operator|<=
name|i
condition|)
block|{
name|Header
operator|.
name|Size
operator|=
name|i
operator|+
literal|16
expr_stmt|;
name|RENEW
argument_list|(
name|Header
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Header
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Header
operator|.
name|Data
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Data
operator|.
name|Newsgroups
operator|=
name|Header
operator|.
name|Data
expr_stmt|;
name|Data
operator|.
name|NewsgroupsLength
operator|=
name|i
expr_stmt|;
comment|/* If we limit what distributions we get, see if we want this one. */
name|p
operator|=
name|HDR
argument_list|(
name|_distribution
argument_list|)
expr_stmt|;
name|distributions
operator|=
operator|*
name|p
condition|?
name|CommaSplit
argument_list|(
name|p
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|distributions
condition|)
block|{
name|DISTparse
argument_list|(
name|distributions
argument_list|,
operator|&
name|Data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ME
operator|.
name|Distributions
operator|&&
operator|!
name|DISTwantany
argument_list|(
name|ME
operator|.
name|Distributions
argument_list|,
name|distributions
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d Unwanted distribution \"%s\""
argument_list|,
name|NNTP_REJECTIT_VAL
argument_list|,
name|MaxLength
argument_list|(
name|distributions
index|[
literal|0
index|]
argument_list|,
name|distributions
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
block|}
else|else
block|{
name|Data
operator|.
name|Distribution
operator|=
literal|"?"
expr_stmt|;
name|Data
operator|.
name|DistributionLength
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Clear all groups and sites -- assume nobody gets the article. */
for|for
control|(
name|i
operator|=
name|nGroups
operator|,
name|ngp
operator|=
name|Groups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
name|ngp
operator|->
name|PostCount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nSites
operator|,
name|sp
operator|=
name|Sites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
block|{
name|sp
operator|->
name|Sendit
operator|=
name|FALSE
expr_stmt|;
name|sp
operator|->
name|Seenit
operator|=
name|FALSE
expr_stmt|;
name|sp
operator|->
name|FNLnames
operator|.
name|Used
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|ng
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Parse the Control or Also-Control header. */
name|groups
operator|=
name|NGsplit
argument_list|(
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|groups
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
continue|continue;
name|Data
operator|.
name|Groupcount
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|HDR
argument_list|(
name|_control
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ControlHeader
operator|=
name|_control
expr_stmt|;
elseif|else
if|if
condition|(
name|HDR
argument_list|(
name|_alsocontrol
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ControlHeader
operator|=
name|_alsocontrol
expr_stmt|;
else|else
block|{
name|ControlHeader
operator|=
operator|-
literal|1
expr_stmt|;
name|LikeNewgroup
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|ControlHeader
operator|>=
literal|0
condition|)
block|{
comment|/* Nip off the first word into lowercase. */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ControlWord
argument_list|,
name|HDR
argument_list|(
name|ControlHeader
argument_list|)
argument_list|,
sizeof|sizeof
name|ControlWord
argument_list|)
expr_stmt|;
name|ControlWord
index|[
sizeof|sizeof
name|ControlWord
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|ControlWord
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|CTYPE
argument_list|(
name|isupper
argument_list|,
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|LikeNewgroup
operator|=
name|EQ
argument_list|(
name|ControlWord
argument_list|,
literal|"newgroup"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ControlWord
argument_list|,
literal|"rmgroup"
argument_list|)
expr_stmt|;
comment|/* Control messages to "foo.ctl" are treated as if they were 	 * posted to "foo".  I should probably apologize for all the 	 * side-effects in the if. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|groups
index|[
name|i
operator|++
index|]
operator|)
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|(
name|j
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|4
operator|)
operator|>
literal|0
operator|&&
operator|*
operator|(
name|p
operator|+=
name|j
operator|)
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'l'
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Loop over the newsgroups, see which ones we want, and get the      * total space needed for the Xref line.  At the end of this section      * of code, j will have the needed length, the appropriate site      * entries will have their Sendit and ng fields set, and GroupPointers      * will have pointers to the relevant newsgroups. */
name|ToGroup
operator|=
name|FALSE
expr_stmt|;
name|p
operator|=
name|HDR
argument_list|(
name|_approved
argument_list|)
expr_stmt|;
name|Approved
operator|=
operator|*
name|p
operator|!=
literal|'\0'
expr_stmt|;
name|ngptr
operator|=
name|GroupPointers
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|GroupMissing
operator|=
name|Accepted
operator|=
name|FALSE
init|;
operator|(
name|p
operator|=
operator|*
name|groups
operator|)
operator|!=
name|NULL
condition|;
name|groups
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|RCcanpost
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|GroupMissing
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|LikeNewgroup
operator|&&
name|Approved
condition|)
block|{
comment|/* Newgroup/rmgroup being sent to a group that doesn't 		 * exist.  Assume it is being sent to the group being 		 * created or removed, nd send the group to all sites that 		 * would or would have had the group if it were created. */
name|ARTsendthegroup
argument_list|(
operator|*
name|groups
argument_list|)
expr_stmt|;
name|Accepted
operator|=
name|TRUE
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DO_MERGE_TO_GROUPS
argument_list|)
comment|/* Try to collapse all "to" newsgroups. */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'t'
operator|||
operator|*
operator|++
name|p
operator|!=
literal|'o'
operator|||
operator|*
operator|++
name|p
operator|!=
literal|'.'
operator|||
operator|*
operator|++
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
name|ngp
operator|=
name|NGfind
argument_list|(
literal|"to"
argument_list|)
expr_stmt|;
name|ToGroup
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|SITEfind
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SITEmark
argument_list|(
name|sp
argument_list|,
name|ngp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
continue|continue;
endif|#
directive|endif
comment|/* defined(DO_MERGE_TO_GROUPS) */
block|}
comment|/* Ignore this group? */
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_IGNORE
condition|)
continue|continue;
comment|/* Basic validity check. */
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_MODERATED
operator|&&
operator|!
name|Approved
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d Unapproved for \"%s\""
argument_list|,
name|NNTP_REJECTIT_VAL
argument_list|,
name|ngp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|distributions
condition|)
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
comment|/* Valid group, feed it to that group's sites. */
name|Accepted
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|isp
operator|=
name|ngp
operator|->
name|Sites
operator|,
name|i
operator|=
name|ngp
operator|->
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|isp
operator|++
control|)
if|if
condition|(
operator|*
name|isp
operator|>=
literal|0
condition|)
block|{
name|sp
operator|=
operator|&
name|Sites
index|[
operator|*
name|isp
index|]
expr_stmt|;
name|SITEmark
argument_list|(
name|sp
argument_list|,
name|ngp
argument_list|)
expr_stmt|;
block|}
comment|/* If it's excluded, don't file it. */
if|if
condition|(
name|ngp
operator|->
name|Rest
index|[
literal|0
index|]
operator|==
name|NF_FLAG_EXCLUDED
condition|)
continue|continue;
comment|/* Expand aliases, mark the article as getting filed in the group. */
if|if
condition|(
name|ngp
operator|->
name|Alias
operator|!=
name|NULL
condition|)
name|ngp
operator|=
name|ngp
operator|->
name|Alias
expr_stmt|;
operator|*
name|ngptr
operator|++
operator|=
name|ngp
expr_stmt|;
name|ngp
operator|->
name|PostCount
operator|=
literal|0
expr_stmt|;
name|j
operator|+=
name|ngp
operator|->
name|NameLength
operator|+
literal|1
operator|+
name|MAXARTFNAME
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Control messages not filed in "to" get filed only in controlname      * or control. */
if|if
condition|(
name|ControlHeader
operator|>=
literal|0
operator|&&
name|Accepted
operator|&&
operator|!
name|ToGroup
condition|)
block|{
name|FileGlue
argument_list|(
name|buff
argument_list|,
literal|"control"
argument_list|,
literal|'.'
argument_list|,
name|ControlWord
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ngp
operator|=
name|NGfind
argument_list|(
name|buff
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ngp
operator|=
name|NGfind
argument_list|(
name|ARTctl
argument_list|)
expr_stmt|;
name|ngp
operator|->
name|PostCount
operator|=
literal|0
expr_stmt|;
name|ngptr
operator|=
name|GroupPointers
expr_stmt|;
operator|*
name|ngptr
operator|++
operator|=
name|ngp
expr_stmt|;
name|j
operator|=
name|ngp
operator|->
name|NameLength
operator|+
literal|1
operator|+
name|MAXARTFNAME
expr_stmt|;
for|for
control|(
name|isp
operator|=
name|ngp
operator|->
name|Sites
operator|,
name|i
operator|=
name|ngp
operator|->
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|isp
operator|++
control|)
if|if
condition|(
operator|*
name|isp
operator|>=
literal|0
condition|)
block|{
name|sp
operator|=
operator|&
name|Sites
index|[
operator|*
name|isp
index|]
expr_stmt|;
name|SITEmark
argument_list|(
name|sp
argument_list|,
name|ngp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If !Accepted, then none of the article's newgroups exist in our      * active file.  Proper action is to drop the article on the floor.      * If ngp == GroupPointers, then all the new articles newsgroups are      * "j" entries in the active file.  In that case, we have to file it      * under junk so that downstream feeds can get it. */
if|if
condition|(
operator|!
name|Accepted
operator|||
name|ngptr
operator|==
name|GroupPointers
condition|)
block|{
if|if
condition|(
operator|!
name|Accepted
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d Unwanted newsgroup \"%s\""
argument_list|,
name|NNTP_REJECTIT_VAL
argument_list|,
name|MaxLength
argument_list|(
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
argument_list|,
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DONT_WANT_TRASH
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|DO_REMEMBER_TRASH
argument_list|)
if|if
condition|(
name|Mode
operator|==
name|OMrunning
operator|&&
operator|!
name|HISwrite
argument_list|(
operator|&
name|Data
argument_list|,
literal|""
argument_list|)
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write history %s %m"
argument_list|,
name|LogName
argument_list|,
name|Data
operator|.
name|MessageID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_REMEMBER_TRASH) */
if|if
condition|(
name|distributions
condition|)
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
else|#
directive|else
comment|/* if !GroupMissing, then all the groups the article was posted 	     * to have a flag of "x" in our active file, and therefore 	     * we should throw the article away:  if you have define 	     * DO_WANT_TRASH, then you want all trash except that which 	     * you explicitly excluded in your active file. */
if|if
condition|(
operator|!
name|GroupMissing
condition|)
block|{
if|if
condition|(
name|distributions
condition|)
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
endif|#
directive|endif
comment|/* defined(DONT_WANT_TRASH) */
block|}
name|ngp
operator|=
name|NGfind
argument_list|(
name|ARTjnk
argument_list|)
expr_stmt|;
operator|*
name|ngptr
operator|++
operator|=
name|ngp
expr_stmt|;
name|ngp
operator|->
name|PostCount
operator|=
literal|0
expr_stmt|;
name|j
operator|=
name|STRLEN
argument_list|(
name|ARTjnk
argument_list|)
operator|+
literal|1
operator|+
name|MAXARTFNAME
expr_stmt|;
comment|/* Junk can be fed to other sites. */
for|for
control|(
name|isp
operator|=
name|ngp
operator|->
name|Sites
operator|,
name|i
operator|=
name|ngp
operator|->
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|isp
operator|++
control|)
if|if
condition|(
operator|*
name|isp
operator|>=
literal|0
condition|)
block|{
name|sp
operator|=
operator|&
name|Sites
index|[
operator|*
name|isp
index|]
expr_stmt|;
name|SITEmark
argument_list|(
name|sp
argument_list|,
name|ngp
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ngptr
operator|=
name|NULL
expr_stmt|;
name|CrossPosted
operator|=
name|ngptr
operator|>
operator|&
name|GroupPointers
index|[
literal|1
index|]
operator|||
name|AlwaysCrosspost
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|Replic
condition|)
name|j
operator|=
name|Replic
operator|->
name|Used
operator|+
literal|1
expr_stmt|;
comment|/* Make sure the Xref buffer has room. */
name|Xref
operator|.
name|Used
operator|=
name|Xrefbase
expr_stmt|;
if|if
condition|(
name|Xref
operator|.
name|Size
operator|<=
name|j
operator|+
name|Xrefbase
operator|+
literal|2
condition|)
block|{
name|Xref
operator|.
name|Size
operator|=
name|j
operator|+
name|Xrefbase
operator|+
literal|2
expr_stmt|;
name|RENEW
argument_list|(
name|Xref
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Xref
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the filename buffer has room. */
if|if
condition|(
name|Files
operator|.
name|Data
operator|==
name|NULL
condition|)
block|{
name|Files
operator|.
name|Size
operator|=
name|j
expr_stmt|;
name|Files
operator|.
name|Data
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|Files
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Files
operator|.
name|Size
operator|<=
name|j
condition|)
block|{
name|Files
operator|.
name|Size
operator|=
name|j
expr_stmt|;
name|RENEW
argument_list|(
name|Files
operator|.
name|Data
argument_list|,
name|char
argument_list|,
name|Files
operator|.
name|Size
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Assign article numbers, fill in Xref buffer. */
if|if
condition|(
name|Replic
operator|==
name|NULL
condition|)
name|ARTassignnumbers
argument_list|()
expr_stmt|;
else|else
name|ARTreplic
argument_list|(
name|Replic
argument_list|,
operator|&
name|CrossPosted
argument_list|)
expr_stmt|;
comment|/* Optimize how we place the article on the disk. */
name|ARTsortfordisk
argument_list|()
expr_stmt|;
comment|/* Now we can file it. */
if|if
condition|(
operator|++
name|ICDactivedirty
operator|>=
name|ICD_SYNC_COUNT
condition|)
block|{
name|ICDwriteactive
argument_list|()
expr_stmt|;
name|ICDactivedirty
operator|=
literal|0
expr_stmt|;
block|}
name|Data
operator|.
name|Name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|Files
operator|.
name|Data
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ngp
operator|=
name|GroupPointers
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ngp
operator|->
name|PostCount
condition|)
continue|continue;
name|ngp
operator|->
name|PostCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Data
operator|.
name|Name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Write the article the first time. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Data
operator|.
name|Name
argument_list|,
literal|"%s/%lu"
argument_list|,
name|ngp
operator|->
name|Dir
argument_list|,
name|ngp
operator|->
name|Filenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARTwrite
argument_list|(
name|Data
operator|.
name|Name
argument_list|,
name|article
argument_list|,
operator|&
name|Data
argument_list|,
name|CrossPosted
argument_list|)
operator|<
literal|0
operator|&&
operator|(
operator|!
name|MakeSpoolDirectory
argument_list|(
name|ngp
operator|->
name|Dir
argument_list|)
operator|||
name|ARTwrite
argument_list|(
name|Data
operator|.
name|Name
argument_list|,
name|article
argument_list|,
operator|&
name|Data
argument_list|,
name|CrossPosted
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|Data
operator|.
name|Name
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|errNOSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|distributions
condition|)
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|errNOSPACE
return|;
block|}
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|Data
operator|.
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|Data
operator|.
name|NameLength
operator|=
name|strlen
argument_list|(
name|Data
operator|.
name|Name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Link to the main article. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linkname
argument_list|,
literal|"%s/%lu"
argument_list|,
name|ngp
operator|->
name|Dir
argument_list|,
name|ngp
operator|->
name|Filenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|Data
operator|.
name|Name
argument_list|,
name|linkname
argument_list|)
operator|<
literal|0
operator|&&
operator|(
operator|!
name|MakeSpoolDirectory
argument_list|(
name|ngp
operator|->
name|Dir
argument_list|)
operator|||
name|link
argument_list|(
name|Data
operator|.
name|Name
argument_list|,
name|linkname
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DONT_HAVE_SYMLINK
argument_list|)
name|IOError
argument_list|(
literal|"linking article"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant link %s and %s %m"
argument_list|,
name|LogName
argument_list|,
name|Data
operator|.
name|Name
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
continue|continue;
else|#
directive|else
comment|/* Try to make a symbolic link to the full pathname. */
name|FileGlue
argument_list|(
name|buff
argument_list|,
name|SPOOL
argument_list|,
literal|'/'
argument_list|,
name|Data
operator|.
name|Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|buff
argument_list|,
name|linkname
argument_list|)
operator|<
literal|0
operator|&&
operator|(
operator|!
name|MakeSpoolDirectory
argument_list|(
name|ngp
operator|->
name|Dir
argument_list|)
operator|||
name|symlink
argument_list|(
name|buff
argument_list|,
name|linkname
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|IOError
argument_list|(
literal|"symlinking article"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant symlink %s and %s %m"
argument_list|,
name|LogName
argument_list|,
name|buff
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* defined(DONT_HAVE_SYMLINK) */
block|}
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update history if we didn't get too many I/O errors above. */
if|if
condition|(
name|Mode
operator|!=
name|OMrunning
operator|||
operator|!
name|HISwrite
argument_list|(
operator|&
name|Data
argument_list|,
name|Files
operator|.
name|Data
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write history %s %m"
argument_list|,
name|LogName
argument_list|,
name|Data
operator|.
name|MessageID
argument_list|)
expr_stmt|;
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|ART_REJECT
argument_list|,
name|errNOHIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|distributions
condition|)
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
name|ARTreject
argument_list|(
name|buff
argument_list|,
name|article
argument_list|)
expr_stmt|;
return|return
name|errNOHIST
return|;
block|}
comment|/* If we just flushed the active (above), now flush history. */
if|if
condition|(
name|ICDactivedirty
operator|==
literal|0
condition|)
name|HISsync
argument_list|()
expr_stmt|;
comment|/* We wrote the history, so modify it and save it for output. */
for|for
control|(
name|Data
operator|.
name|Replic
operator|=
name|Files
operator|.
name|Data
operator|,
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|Data
operator|.
name|Replic
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|*
name|p
operator|=
literal|','
expr_stmt|;
name|Data
operator|.
name|ReplicLength
operator|=
name|p
operator|-
name|Data
operator|.
name|Replic
expr_stmt|;
comment|/* Start logging, then propagate the article. */
name|ARTlog
argument_list|(
operator|&
name|Data
argument_list|,
name|Accepted
condition|?
name|ART_ACCEPT
else|:
name|ART_JUNK
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DO_NNTPLINK_LOG
argument_list|)
if|if
condition|(
name|fprintf
argument_list|(
name|Log
argument_list|,
literal|" (%s)"
argument_list|,
name|Data
operator|.
name|Name
argument_list|)
operator|==
name|EOF
operator|||
name|ferror
argument_list|(
name|Log
argument_list|)
condition|)
block|{
name|IOError
argument_list|(
literal|"logging nntplink"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write log_nntplink %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|Log
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DO_NNTPLINK_LOG) */
name|ARTpropagate
argument_list|(
operator|&
name|Data
argument_list|,
name|hops
argument_list|,
name|hopcount
argument_list|,
name|distributions
argument_list|)
expr_stmt|;
if|if
condition|(
name|distributions
condition|)
name|DISPOSE
argument_list|(
name|distributions
argument_list|)
expr_stmt|;
comment|/* Now that it's been written, process the control message.  This has      * a small window, if we get a new article before the newgroup message      * has been processed.  We could pause ourselves here, but it doesn't      * seem to be worth it. */
if|if
condition|(
name|Accepted
condition|)
block|{
if|if
condition|(
name|ControlHeader
operator|>=
literal|0
condition|)
name|ARTcontrol
argument_list|(
operator|&
name|Data
argument_list|,
name|HDR
argument_list|(
name|ControlHeader
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|HDR
argument_list|(
name|_supersedes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|ARTcancel
argument_list|(
operator|&
name|Data
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* If we need the overview data, write it. */
if|if
condition|(
name|NeedOverview
condition|)
name|ARTmakeoverview
argument_list|(
operator|&
name|Data
argument_list|)
expr_stmt|;
comment|/* And finally, send to everyone who should get it */
for|for
control|(
name|sp
operator|=
name|Sites
operator|,
name|i
operator|=
name|nSites
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|sp
operator|++
control|)
if|if
condition|(
name|sp
operator|->
name|Sendit
condition|)
name|SITEsend
argument_list|(
name|sp
argument_list|,
operator|&
name|Data
argument_list|)
expr_stmt|;
return|return
name|NNTP_TOOKIT
return|;
block|}
end_function

end_unit

