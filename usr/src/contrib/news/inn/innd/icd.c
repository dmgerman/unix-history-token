begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.26 $ ** **  Routines to read and write the active file. */
end_comment

begin_include
include|#
directive|include
file|"innd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ACT_MMAP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(ACT_MMAP) */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|iovec
name|IOVEC
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|char
name|ICDactpath
index|[]
init|=
name|_PATH_ACTIVE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|ICDactpointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ICDactfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ICDactsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Set and unset (or copy) IOVEC elements.  We make copies to **  avoid problems with mmap. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ACT_MMAP
argument_list|)
end_if

begin_define
define|#
directive|define
name|ICDiovset
parameter_list|(
name|iovp
parameter_list|,
name|base
parameter_list|,
name|len
parameter_list|)
define|\
value|do { \ 	    (iovp)->iov_len = len; \ 	    (iovp)->iov_base = NEW(char, (iovp)->iov_len); \ 	    (void)memcpy((POINTER)(iovp)->iov_base, (POINTER)base, \ 		    (SIZE_T)(iovp)->iov_len); \ 	} while (JUSTONCE)
end_define

begin_define
define|#
directive|define
name|ICDiovrelease
parameter_list|(
name|iovp
parameter_list|)
value|DISPOSE((iovp)->iov_base)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAP_FILE
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAP__ARG
value|(MAP_FILE | MAP_SHARED)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAP__ARG
value|(MAP_SHARED)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(MAP_FILE) */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ICDiovset
parameter_list|(
name|iovp
parameter_list|,
name|base
parameter_list|,
name|len
parameter_list|)
define|\
value|(iovp)->iov_base = base, (iovp)->iov_len = len
end_define

begin_define
define|#
directive|define
name|ICDiovrelease
parameter_list|(
name|iovp
parameter_list|)
end_define

begin_comment
comment|/* NULL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(ACT_MMAP) */
end_comment

begin_comment
comment|/* **  Close the active file, releasing its resources. */
end_comment

begin_function
name|STATIC
name|void
name|ICDcloseactive
parameter_list|()
block|{
if|if
condition|(
name|ICDactpointer
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ACT_MMAP
argument_list|)
if|if
condition|(
name|munmap
argument_list|(
name|ICDactpointer
argument_list|,
name|ICDactsize
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant munmap %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
else|#
directive|else
name|DISPOSE
argument_list|(
name|ICDactpointer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(ACT_MMAP) */
name|ICDactpointer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|ICDactfd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant close %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **  Set up the hash and in-core tables. */
end_comment

begin_function
name|void
name|ICDsetup
parameter_list|(
name|StartSites
parameter_list|)
name|BOOL
name|StartSites
decl_stmt|;
block|{
name|ICDneedsetup
operator|=
name|FALSE
expr_stmt|;
name|ICDcloseactive
argument_list|()
expr_stmt|;
name|NGparsefile
argument_list|()
expr_stmt|;
if|if
condition|(
name|NGfind
argument_list|(
literal|"control"
argument_list|)
operator|==
name|NULL
operator|||
name|NGfind
argument_list|(
literal|"junk"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s internal no control and/or junk group"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DO_MERGE_TO_GROUPS
argument_list|)
if|if
condition|(
name|NGfind
argument_list|(
literal|"to"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s internal no to group"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(DO_MERGE_TO_GROUPS) */
name|SITEparsefile
argument_list|(
name|StartSites
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Write out all in-core data. */
end_comment

begin_function
name|void
name|ICDwrite
parameter_list|()
block|{
name|HISsync
argument_list|()
expr_stmt|;
if|if
condition|(
name|ICDactivedirty
condition|)
block|{
name|ICDwriteactive
argument_list|()
expr_stmt|;
name|ICDactivedirty
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Flush log and error log. */
if|if
condition|(
name|fflush
argument_list|(
name|Log
argument_list|)
operator|==
name|EOF
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fflush log %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|Errlog
argument_list|)
operator|==
name|EOF
condition|)
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fflush errlog %m"
argument_list|,
name|LogName
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Close things down. */
end_comment

begin_function
name|void
name|ICDclose
parameter_list|()
block|{
name|ICDwrite
argument_list|()
expr_stmt|;
name|ICDcloseactive
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Scan the active file, and renumber the min/max counts. */
end_comment

begin_function
name|void
name|ICDrenumberactive
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nGroups
operator|,
name|ngp
operator|=
name|Groups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|ngp
operator|++
control|)
if|if
condition|(
operator|!
name|NGrenumber
argument_list|(
name|ngp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|ICDwrite
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Use writev() to replace the active file. */
end_comment

begin_function
name|STATIC
name|BOOL
name|ICDwritevactive
parameter_list|(
name|vp
parameter_list|,
name|vpcount
parameter_list|)
name|IOVEC
modifier|*
name|vp
decl_stmt|;
name|int
name|vpcount
decl_stmt|;
block|{
specifier|static
name|char
name|BACKUP
index|[]
init|=
name|_PATH_OLDACTIVE
decl_stmt|;
specifier|static
name|char
name|WHEN
index|[]
init|=
literal|"backup active"
decl_stmt|;
specifier|register
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|dummy
decl_stmt|;
comment|/* Write the current file to a backup. */
if|if
condition|(
name|unlink
argument_list|(
name|BACKUP
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant unlink %s %m"
argument_list|,
name|LogName
argument_list|,
name|BACKUP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|BACKUP
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0664
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|LogName
argument_list|,
name|BACKUP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xwrite
argument_list|(
name|fd
argument_list|,
name|ICDactpointer
argument_list|,
name|ICDactsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|BACKUP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant close %s %m"
argument_list|,
name|LogName
argument_list|,
name|BACKUP
argument_list|)
expr_stmt|;
block|}
comment|/* Open the active file. */
name|fd
operator|=
name|open
argument_list|(
name|ICDactpath
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
name|ARTFILE_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Write it. */
if|if
condition|(
name|xwritev
argument_list|(
name|fd
argument_list|,
name|vp
argument_list|,
name|vpcount
argument_list|)
operator|<
literal|0
condition|)
block|{
name|IOError
argument_list|(
name|WHEN
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Close it. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|AmRoot
condition|)
name|xchown
argument_list|(
name|ICDactpath
argument_list|)
expr_stmt|;
comment|/* Invalidate in-core pointers. */
name|ICDcloseactive
argument_list|()
expr_stmt|;
comment|/* Restore in-core pointers. */
if|if
condition|(
name|Mode
operator|!=
name|OMrunning
condition|)
block|{
name|ICDneedsetup
operator|=
name|TRUE
expr_stmt|;
comment|/* Force the active file into memory. */
operator|(
name|void
operator|)
name|ICDreadactive
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
block|}
else|else
name|ICDsetup
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Change the flag on a newsgroup.  Fairly easy. */
end_comment

begin_function
name|BOOL
name|ICDchangegroup
parameter_list|(
name|ngp
parameter_list|,
name|Rest
parameter_list|)
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
name|char
modifier|*
name|Rest
decl_stmt|;
block|{
specifier|static
name|char
name|NEWLINE
index|[]
init|=
literal|"\n"
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|IOVEC
name|iov
index|[
literal|3
index|]
decl_stmt|;
name|BOOL
name|ret
decl_stmt|;
comment|/* Set up the scatter/gather vectors. */
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|,
name|ICDactpointer
argument_list|,
name|ngp
operator|->
name|Rest
operator|-
name|ICDactpointer
argument_list|)
expr_stmt|;
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|1
index|]
argument_list|,
name|Rest
argument_list|,
name|strlen
argument_list|(
name|Rest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ngp
operator|<
operator|&
name|Groups
index|[
name|nGroups
index|]
condition|)
block|{
comment|/* Not the last group, keep the \n from the next line. */
name|i
operator|=
name|ngp
operator|->
name|Start
expr_stmt|;
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|2
index|]
argument_list|,
operator|&
name|ICDactpointer
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|ICDactsize
operator|-
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Last group -- append a newline. */
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|2
index|]
argument_list|,
name|NEWLINE
argument_list|,
name|STRLEN
argument_list|(
name|NEWLINE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|ICDwritevactive
argument_list|(
name|iov
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  Add a newsgroup.  Append a line to the end of the active file and reload. */
end_comment

begin_function
name|BOOL
name|ICDnewgroup
parameter_list|(
name|Name
parameter_list|,
name|Rest
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
name|char
modifier|*
name|Rest
decl_stmt|;
block|{
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|IOVEC
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|BOOL
name|ret
decl_stmt|;
comment|/* Set up the scatter/gather vectors. */
if|if
condition|(
name|strlen
argument_list|(
name|Name
argument_list|)
operator|+
name|strlen
argument_list|(
name|Rest
argument_list|)
operator|>
call|(
name|SIZE_T
call|)
argument_list|(
name|SMBUF
operator|-
literal|24
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s too_long %s"
argument_list|,
name|LogName
argument_list|,
name|MaxLength
argument_list|(
name|Name
argument_list|,
name|Name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s 0000000000 0000000001 %s\n"
argument_list|,
name|Name
argument_list|,
name|Rest
argument_list|)
expr_stmt|;
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|,
name|ICDactpointer
argument_list|,
name|ICDactsize
argument_list|)
expr_stmt|;
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|1
index|]
argument_list|,
name|buff
argument_list|,
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ICDwritevactive
argument_list|(
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* **  Remove a newsgroup.  Splice the line out of the active file and reload. */
end_comment

begin_function
name|BOOL
name|ICDrmgroup
parameter_list|(
name|ngp
parameter_list|)
name|NEWSGROUP
modifier|*
name|ngp
decl_stmt|;
block|{
name|IOVEC
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BOOL
name|ret
decl_stmt|;
comment|/* If this is the first group in the file, write everything after. */
if|if
condition|(
name|ngp
operator|==
operator|&
name|Groups
index|[
literal|0
index|]
condition|)
block|{
name|i
operator|=
name|ngp
index|[
literal|1
index|]
operator|.
name|Start
expr_stmt|;
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|,
operator|&
name|ICDactpointer
index|[
name|i
index|]
argument_list|,
name|ICDactsize
operator|-
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ICDwritevactive
argument_list|(
name|iov
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Write everything up to this group. */
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|,
name|ICDactpointer
argument_list|,
name|ngp
operator|->
name|Start
argument_list|)
expr_stmt|;
comment|/* If this is the last group, that's all we have to write. */
if|if
condition|(
name|ngp
operator|==
operator|&
name|Groups
index|[
name|nGroups
operator|-
literal|1
index|]
condition|)
block|{
name|ret
operator|=
name|ICDwritevactive
argument_list|(
name|iov
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Write everything after this group. */
name|i
operator|=
name|ngp
index|[
literal|1
index|]
operator|.
name|Start
expr_stmt|;
name|ICDiovset
argument_list|(
operator|&
name|iov
index|[
literal|1
index|]
argument_list|,
operator|&
name|ICDactpointer
index|[
name|i
index|]
argument_list|,
name|ICDactsize
operator|-
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ICDwritevactive
argument_list|(
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ICDiovrelease
argument_list|(
operator|&
name|iov
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Open the active file and "map" it into memory. */
end_comment

begin_function
name|char
modifier|*
name|ICDreadactive
parameter_list|(
name|endp
parameter_list|)
name|char
modifier|*
modifier|*
name|endp
decl_stmt|;
block|{
name|struct
name|stat
name|Sb
decl_stmt|;
if|if
condition|(
name|ICDactpointer
condition|)
block|{
operator|*
name|endp
operator|=
name|ICDactpointer
operator|+
name|ICDactsize
expr_stmt|;
return|return
name|ICDactpointer
return|;
block|}
if|if
condition|(
operator|(
name|ICDactfd
operator|=
name|open
argument_list|(
name|ICDactpath
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant open %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|CloseOnExec
argument_list|(
name|ICDactfd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ACT_MMAP
argument_list|)
if|if
condition|(
name|fstat
argument_list|(
name|ICDactfd
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant fstat %d %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactfd
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ICDactsize
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
name|ICDactpointer
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ICDactsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP__ARG
argument_list|,
name|ICDactfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ICDactpointer
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant mmap %d %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactfd
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|ICDactpointer
operator|=
name|ReadInDescriptor
argument_list|(
name|ICDactfd
argument_list|,
operator|&
name|Sb
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant read %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ICDactsize
operator|=
name|Sb
operator|.
name|st_size
expr_stmt|;
endif|#
directive|endif
comment|/* defined(ACT_MMAP) */
operator|*
name|endp
operator|=
name|ICDactpointer
operator|+
name|ICDactsize
expr_stmt|;
return|return
name|ICDactpointer
return|;
block|}
end_function

begin_comment
comment|/* **  Write the active file out. */
end_comment

begin_function
name|void
name|ICDwriteactive
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|ACT_MMAP
argument_list|)
comment|/* No-op. */
else|#
directive|else
if|if
condition|(
name|lseek
argument_list|(
name|ICDactfd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant rewind %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xwrite
argument_list|(
name|ICDactfd
argument_list|,
name|ICDactpointer
argument_list|,
name|ICDactsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_FATAL
argument_list|,
literal|"%s cant write %s %m"
argument_list|,
name|LogName
argument_list|,
name|ICDactpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(ACT_MMAP) */
block|}
end_function

end_unit

