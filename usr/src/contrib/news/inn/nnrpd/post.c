begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.18 $ ** **  Check article, send it to the local server. */
end_comment

begin_include
include|#
directive|include
file|"nnrpd.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|FLUSH_ERROR
parameter_list|(
name|F
parameter_list|)
value|(fflush((F)) == EOF || ferror((F)))
end_define

begin_define
define|#
directive|define
name|HEADER_DELTA
value|20
end_define

begin_typedef
typedef|typedef
enum|enum
name|_HEADERTYPE
block|{
name|HTobs
block|,
name|HTreq
block|,
name|HTstd
block|}
name|HEADERTYPE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_HEADER
block|{
name|STRING
name|Name
decl_stmt|;
name|BOOL
name|CanSet
decl_stmt|;
name|HEADERTYPE
name|Type
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
modifier|*
name|Value
decl_stmt|;
block|}
name|HEADER
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|char
name|Error
index|[
name|SMBUF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|NGSEPS
index|[]
init|=
name|NG_SEPARATOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
modifier|*
modifier|*
name|OtherHeaders
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|OtherCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|OtherSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|BOOL
name|WasMailed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|STRING
name|BadDistribs
index|[]
init|=
block|{
name|BAD_DISTRIBS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|HEADER
name|Table
index|[]
init|=
block|{
comment|/* 	Name			Canset	Type	*/
block|{
literal|"Path"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_path
value|0
block|{
literal|"From"
block|,
name|TRUE
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_from
value|1
block|{
literal|"Newsgroups"
block|,
name|TRUE
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_newsgroups
value|2
block|{
literal|"Subject"
block|,
name|TRUE
block|,
name|HTreq
block|}
block|,
define|#
directive|define
name|_subject
value|3
block|{
literal|"Control"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_control
value|4
block|{
literal|"Supersedes"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_supersedes
value|5
block|{
literal|"Followup-To"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_followupto
value|6
block|{
literal|"Date"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_date
value|7
block|{
literal|"Organization"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_organization
value|8
block|{
literal|"Lines"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_lines
value|9
block|{
literal|"Sender"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_sender
value|10
block|{
literal|"Approved"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_approved
value|11
block|{
literal|"Distribution"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_distribution
value|12
block|{
literal|"Expires"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_expires
value|13
block|{
literal|"Message-ID"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_messageid
value|14
block|{
literal|"References"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_references
value|15
block|{
literal|"Reply-To"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_replyto
value|16
block|{
literal|"NNTP-Posting-Host"
block|,
name|FALSE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_nntpposthost
value|17
block|{
literal|"Mime-Version"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_mimeversion
value|18
block|{
literal|"Content-Type"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_contenttype
value|19
block|{
literal|"Content-Transfer-Encoding"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
define|#
directive|define
name|_contenttransferencoding
value|20
block|{
literal|"Xref"
block|,
name|FALSE
block|,
name|HTstd
block|}
block|,
block|{
literal|"Summary"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
block|{
literal|"Keywords"
block|,
name|TRUE
block|,
name|HTstd
block|}
block|,
block|{
literal|"Date-Received"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Received"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Posted"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Posting-Version"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|,
block|{
literal|"Relay-Version"
block|,
name|FALSE
block|,
name|HTobs
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HDR
parameter_list|(
name|_x
parameter_list|)
value|(Table[(_x)].Value)
end_define

begin_escape
end_escape

begin_comment
comment|/* **  Trim trailing spaces, return pointer to first non-space char. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|TrimSpaces
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|start
decl_stmt|;
for|for
control|(
name|start
operator|=
name|p
init|;
name|ISWHITE
argument_list|(
operator|*
name|start
argument_list|)
condition|;
name|start
operator|++
control|)
continue|continue;
for|for
control|(
name|p
operator|=
name|start
operator|+
name|strlen
argument_list|(
name|start
argument_list|)
init|;
name|p
operator|>
name|start
operator|&&
name|CTYPE
argument_list|(
name|isspace
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|;
control|)
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* **  Mark the end of the header starting at p, and return a pointer **  to the start of the next one or NULL.  Handles continuations. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|NextHeader
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
for|for
control|(
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ISWHITE
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Strip any headers off the article and dump them into the table. **  On error, return NULL and fill in Error. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|StripOffHeaders
parameter_list|(
name|article
parameter_list|)
name|char
modifier|*
name|article
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
comment|/* Scan through buffer, a header at a time. */
for|for
control|(
name|p
operator|=
name|article
init|;
condition|;
control|)
block|{
comment|/* See if it's a known header. */
name|c
operator|=
name|CTYPE
argument_list|(
name|islower
argument_list|,
operator|*
name|p
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
else|:
operator|*
name|p
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|c
operator|==
name|hp
operator|->
name|Name
index|[
literal|0
index|]
operator|&&
name|p
index|[
name|hp
operator|->
name|Size
index|]
operator|==
literal|':'
operator|&&
name|caseEQn
argument_list|(
name|p
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Size
argument_list|)
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|Type
operator|==
name|HTobs
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Obsolete \"%s\" header"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Duplicate \"%s\" header"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|q
operator|=
operator|&
name|p
index|[
name|hp
operator|->
name|Size
operator|+
literal|1
index|]
init|;
name|ISWHITE
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
name|hp
operator|->
name|Value
operator|=
name|q
expr_stmt|;
break|break;
block|}
comment|/* No; add it to the set of other headers. */
if|if
condition|(
name|hp
operator|==
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|)
block|{
if|if
condition|(
name|OtherCount
operator|>=
name|OtherSize
operator|-
literal|1
condition|)
block|{
name|OtherSize
operator|+=
name|HEADER_DELTA
expr_stmt|;
name|RENEW
argument_list|(
name|OtherHeaders
argument_list|,
name|char
operator|*
argument_list|,
name|OtherSize
argument_list|)
expr_stmt|;
block|}
name|OtherHeaders
index|[
name|OtherCount
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
comment|/* Get start of next header; if it's a blank line, we hit the end. */
if|if
condition|(
operator|(
name|p
operator|=
name|NextHeader
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Error
argument_list|,
literal|"Article has no body -- just headers"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
block|}
return|return
name|p
operator|+
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **  Check the control message, and see if it's legit.  Return pointer to **  error message if not. */
end_comment

begin_function
name|STATIC
name|STRING
name|CheckControl
parameter_list|(
name|ctrl
parameter_list|)
name|char
modifier|*
name|ctrl
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* Snip off the first word. */
for|for
control|(
name|p
operator|=
name|ctrl
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
for|for
control|(
name|ctrl
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
name|p
operator|==
name|ctrl
condition|)
return|return
literal|"Empty control message"
return|;
name|save
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"cancel"
argument_list|)
condition|)
block|{
for|for
control|(
name|q
operator|=
name|p
operator|+
literal|1
init|;
name|ISWHITE
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
return|return
literal|"Message-ID missing in cancel"
return|;
block|}
elseif|else
if|if
condition|(
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"sendsys"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"senduuname"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"version"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"checkgroups"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"ihave"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"sendme"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"newgroup"
argument_list|)
operator|||
name|EQ
argument_list|(
name|ctrl
argument_list|,
literal|"rmgroup"
argument_list|)
condition|)
comment|/* SUPPRESS 530 */
comment|/* Empty body for statement */
empty_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"\"%s\" is not a valid control message"
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
operator|*
name|p
operator|=
name|save
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Check the Distribution header, and exit on error. */
end_comment

begin_function
name|STATIC
name|STRING
name|CheckDistribution
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|char
name|SEPS
index|[]
init|=
literal|" \t,"
decl_stmt|;
specifier|register
name|STRING
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|p
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"Can't parse Distribution line."
return|;
do|do
block|{
for|for
control|(
name|dp
operator|=
name|BadDistribs
init|;
operator|*
name|dp
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|wildmat
argument_list|(
name|p
argument_list|,
operator|*
name|dp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Illegal distribution \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|SEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Process all the headers.  FYI, they're done in RFC-order. **  Return NULL if okay, or an error message. */
end_comment

begin_function
name|STATIC
name|STRING
name|ProcessHeaders
parameter_list|(
name|linecount
parameter_list|)
name|int
name|linecount
decl_stmt|;
block|{
specifier|static
name|char
name|MONTHS
index|[]
init|=
literal|"JanFebMarAprMayJunJulAugSepOctNovDec"
decl_stmt|;
specifier|static
name|char
name|subjbuff
index|[
name|NNTP_STRLEN
index|]
decl_stmt|;
specifier|static
name|char
name|datebuff
index|[
literal|40
index|]
decl_stmt|;
specifier|static
name|char
name|orgbuff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|static
name|char
name|linebuff
index|[
literal|40
index|]
decl_stmt|;
specifier|static
name|char
name|mimeversion
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|static
name|char
name|mimetype
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|static
name|char
name|mimeencoding
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|gmt
decl_stmt|;
name|TIMEINFO
name|Now
decl_stmt|;
name|STRING
name|error
decl_stmt|;
comment|/* Do some preliminary fix-ups. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|CanSet
operator|&&
name|hp
operator|->
name|Value
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Can't set system \"%s\" header"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
block|{
name|hp
operator|->
name|Value
operator|=
name|TrimSpaces
argument_list|(
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|hp
operator|->
name|Value
operator|==
literal|'\0'
condition|)
name|hp
operator|->
name|Value
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|DO_NNRP_AUTH_SENDER
argument_list|)
comment|/* Zap the Sender? */
if|if
condition|(
operator|!
name|PERMauthorized
condition|)
name|HDR
argument_list|(
name|_sender
argument_list|)
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_NNRP_AUTH_SENDER) */
comment|/* Set Date. */
if|if
condition|(
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Can't get the time, %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
if|if
condition|(
name|HDR
argument_list|(
name|_date
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|gmt
operator|=
name|gmtime
argument_list|(
operator|&
name|Now
operator|.
name|time
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"Can't get the time"
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|datebuff
argument_list|,
literal|"%d %3.3s %d %02.2d:%02.2d:%02.2d GMT"
argument_list|,
name|gmt
operator|->
name|tm_mday
argument_list|,
operator|&
name|MONTHS
index|[
literal|3
operator|*
name|gmt
operator|->
name|tm_mon
index|]
argument_list|,
literal|1900
operator|+
name|gmt
operator|->
name|tm_year
argument_list|,
name|gmt
operator|->
name|tm_hour
argument_list|,
name|gmt
operator|->
name|tm_min
argument_list|,
name|gmt
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_date
argument_list|)
operator|=
name|datebuff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|parsedate
argument_list|(
name|HDR
argument_list|(
name|_date
argument_list|)
argument_list|,
operator|&
name|Now
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|"Can't parse \"Date\" header"
return|;
if|if
condition|(
name|t
operator|>
name|Now
operator|.
name|time
operator|+
name|DATE_FUZZ
condition|)
return|return
literal|"Article posted in the future"
return|;
block|}
comment|/* Newsgroups are checked later. */
comment|/* Set Subject; Control overrides the subject. */
if|if
condition|(
name|HDR
argument_list|(
name|_control
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|CheckControl
argument_list|(
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|subjbuff
argument_list|,
literal|"cmsg %s"
argument_list|,
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_subject
argument_list|)
operator|=
name|subjbuff
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|HDR
argument_list|(
name|_subject
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
literal|"Required \"Subject\" header is missing"
return|;
if|if
condition|(
name|EQn
argument_list|(
name|p
argument_list|,
literal|"cmsg "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|HDR
argument_list|(
name|_control
argument_list|)
operator|=
name|p
operator|+
literal|5
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|CheckControl
argument_list|(
name|HDR
argument_list|(
name|_control
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
block|}
if|#
directive|if
literal|0
block|if (EQn(p, "Re: ", 4)&& HDR(_references) == NULL) 	    return "Article starts with \"Re: \" but has no references";
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* Set Message-ID */
if|if
condition|(
name|HDR
argument_list|(
name|_messageid
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|GenerateMessageID
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Can't generate Message-ID, %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
name|HDR
argument_list|(
name|_messageid
argument_list|)
operator|=
name|p
expr_stmt|;
block|}
comment|/* Set Path */
if|if
condition|(
name|HDR
argument_list|(
name|_path
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Note that innd will put host name here for us. */
name|HDR
argument_list|(
name|_path
argument_list|)
operator|=
name|NEWSMASTER
expr_stmt|;
block|}
comment|/* Reply-To; left alone. */
comment|/* Sender; set above. */
comment|/* Check Expires. */
if|if
condition|(
name|HDR
argument_list|(
name|_expires
argument_list|)
operator|&&
name|parsedate
argument_list|(
name|HDR
argument_list|(
name|_expires
argument_list|)
argument_list|,
operator|&
name|Now
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|"Can't parse \"Expires\" header"
return|;
comment|/* References; left alone. */
comment|/* Control; checked above. */
comment|/* Distribution. */
if|if
condition|(
operator|(
name|p
operator|=
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|COPY
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|CheckDistribution
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
block|}
comment|/* Set Organization */
if|if
condition|(
name|HDR
argument_list|(
name|_organization
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_ORGANIZATION
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|orgbuff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_organization
argument_list|)
operator|=
name|orgbuff
expr_stmt|;
block|}
comment|/* Keywords; left alone. */
comment|/* Summary; left alone. */
comment|/* Approved; left alone. */
comment|/* MIME headers. */
if|if
condition|(
name|HDR
argument_list|(
name|_mimeversion
argument_list|)
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_MIMEVERSION
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mimeversion
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_mimeversion
argument_list|)
operator|=
name|mimeversion
expr_stmt|;
comment|/* Set Content-Type */
if|if
condition|(
name|HDR
argument_list|(
name|_contenttype
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_CONTENTTYPE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"Can't get \"Content-Type\" header"
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mimetype
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_contenttype
argument_list|)
operator|=
name|mimetype
expr_stmt|;
block|}
comment|/* Set Content-Transfer-Encoding */
if|if
condition|(
name|HDR
argument_list|(
name|_contenttransferencoding
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|GetConfigValue
argument_list|(
name|_CONF_ENCODING
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"Can't get \"Content-Transfer-Encoding\" header"
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|mimeencoding
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_contenttransferencoding
argument_list|)
operator|=
name|mimeencoding
expr_stmt|;
block|}
block|}
comment|/* Set Lines */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|linebuff
argument_list|,
literal|"%d"
argument_list|,
name|linecount
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_lines
argument_list|)
operator|=
name|linebuff
expr_stmt|;
comment|/* Supersedes; left alone. */
comment|/* NNTP-Posting host; set. */
name|HDR
argument_list|(
name|_nntpposthost
argument_list|)
operator|=
name|ClientHost
expr_stmt|;
comment|/* Now make sure everything is there. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Type
operator|==
name|HTreq
operator|&&
name|hp
operator|->
name|Value
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Required \"%s\" header is missing"
argument_list|,
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_CHECK_INCLUDED_TEXT
argument_list|)
end_if

begin_comment
comment|/* **  See if the user has more included text than new text.  Simple-minded, but **  reasonably effective for catching neophyte's mistakes.  A line starting **  with> is included text.  Decrement the count on lines starting with< **  so that we don't reject diff(1) output. */
end_comment

begin_function
name|STATIC
name|STRING
name|CheckIncludedText
parameter_list|(
name|p
parameter_list|,
name|lines
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|lines
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'>'
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|i
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|*
literal|2
operator|>
name|lines
condition|)
return|return
literal|"Article not posted -- more included text than new text"
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_CHECK_INCLUDED_TEXT) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **  Try to mail an article to the moderator of the group. */
end_comment

begin_function
name|STATIC
name|STRING
name|MailArticle
parameter_list|(
name|group
parameter_list|,
name|article
parameter_list|)
name|char
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
block|{
specifier|static
name|char
name|CANTSEND
index|[]
init|=
literal|"Can't send text to mailer"
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
comment|/* Try to get the address first. */
if|if
condition|(
operator|(
name|address
operator|=
name|GetModeratorAddress
argument_list|(
name|group
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"No mailing address for \"%s\" -- %s"
argument_list|,
name|group
argument_list|,
literal|"ask your news administrator to fix this"
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
comment|/* Now build up the command (ignore format/argument mismatch errors,      * in case %s isn't in _PATH_SENDMAIL) and send the headers. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|_PATH_SENDMAIL
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|F
operator|=
name|popen
argument_list|(
name|buff
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"Can't start mailer"
return|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"To: %s\n"
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return
name|CANTSEND
return|;
block|}
comment|/* Write the headers, a blank line, then the article. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return
name|CANTSEND
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"%s\n"
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return
name|CANTSEND
return|;
block|}
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|F
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|article
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|POINTER
operator|)
name|article
argument_list|,
operator|(
name|SIZE_T
operator|)
literal|1
argument_list|,
operator|(
name|SIZE_T
operator|)
name|i
argument_list|,
name|F
argument_list|)
operator|!=
name|i
condition|)
return|return
literal|"Can't send article"
return|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|F
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
return|return
name|CANTSEND
return|;
block|}
name|i
operator|=
name|pclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Mailer exited with status %d -- %s"
argument_list|,
name|i
argument_list|,
literal|"Article might not have been mailed"
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
name|WasMailed
operator|=
name|TRUE
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Check the newsgroups and make sure they're all valid, that none are **  moderated, etc. */
end_comment

begin_function
name|STATIC
name|STRING
name|ValidNewsgroups
parameter_list|(
name|hdr
parameter_list|,
name|article
parameter_list|)
name|char
modifier|*
name|hdr
decl_stmt|;
name|char
modifier|*
name|article
decl_stmt|;
block|{
specifier|static
name|char
name|distbuff
index|[
name|SMBUF
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|groups
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|GROUPENTRY
modifier|*
name|gp
decl_stmt|;
specifier|register
name|BOOL
name|approved
decl_stmt|;
name|struct
name|_DDHANDLE
modifier|*
name|h
decl_stmt|;
name|BOOL
name|IsNewgroup
decl_stmt|;
name|BOOL
name|FoundOne
decl_stmt|;
name|p
operator|=
name|HDR
argument_list|(
name|_control
argument_list|)
expr_stmt|;
name|IsNewgroup
operator|=
name|p
operator|&&
name|EQn
argument_list|(
name|p
argument_list|,
literal|"newgroup"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|groups
operator|=
name|COPY
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|groups
argument_list|,
name|NGSEPS
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|"Can't parse newsgroups line"
return|;
comment|/* Don't mail article if just checking Followup-To line. */
name|approved
operator|=
name|HDR
argument_list|(
name|_approved
argument_list|)
operator|!=
name|NULL
operator|||
name|article
operator|==
name|NULL
expr_stmt|;
name|Error
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|FoundOne
operator|=
name|FALSE
expr_stmt|;
name|h
operator|=
name|DDstart
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|FILE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
if|#
directive|if
name|defined
argument_list|(
name|DO_MERGE_TO_GROUPS
argument_list|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'t'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'.'
condition|)
name|p
operator|=
literal|"to"
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_MERGE_TO_GROUPS) */
if|if
condition|(
operator|(
name|gp
operator|=
name|GRPfind
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|FoundOne
operator|=
name|TRUE
expr_stmt|;
name|DDcheck
argument_list|(
name|h
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gp
operator|->
name|Flag
condition|)
block|{
case|case
name|NF_FLAG_OK
case|:
break|break;
case|case
name|NF_FLAG_MODERATED
case|:
if|if
condition|(
operator|!
name|approved
condition|)
block|{
name|DISPOSE
argument_list|(
name|groups
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|DDend
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MailArticle
argument_list|(
name|gp
operator|->
name|Name
argument_list|,
name|article
argument_list|)
return|;
block|}
break|break;
case|case
name|NF_FLAG_IGNORE
case|:
case|case
name|NF_FLAG_NOLOCAL
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Postings to \"%s\" are not allowed here."
argument_list|,
name|gp
operator|->
name|Name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NF_FLAG_EXCLUDED
case|:
comment|/* Do NOT return an error. */
break|break;
case|case
name|NF_FLAG_ALIAS
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"The newsgroup \"%s\" has been renamed to \"%s\".\n"
argument_list|,
name|p
argument_list|,
name|gp
operator|->
name|Alias
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|NGSEPS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
name|DISPOSE
argument_list|(
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FoundOne
operator|&&
operator|!
name|IsNewgroup
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"No such newsgroup as \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|Error
index|[
literal|0
index|]
condition|)
block|{
name|DISPOSE
argument_list|(
name|DDend
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
name|p
operator|=
name|DDend
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|==
name|NULL
operator|&&
operator|*
name|p
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|distbuff
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|HDR
argument_list|(
name|_distribution
argument_list|)
operator|=
name|distbuff
expr_stmt|;
block|}
name|DISPOSE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Send a quit message to the server, eat its reply. */
end_comment

begin_function
name|STATIC
name|void
name|SendQuit
parameter_list|(
name|FromServer
parameter_list|,
name|ToServer
parameter_list|)
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
block|{
name|char
name|buff
index|[
name|NNTP_STRLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"quit\r\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FromServer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Offer the article to the server, return its reply. */
end_comment

begin_function
name|STATIC
name|int
name|OfferArticle
parameter_list|(
name|buff
parameter_list|,
name|buffsize
parameter_list|,
name|FromServer
parameter_list|,
name|ToServer
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|buffsize
decl_stmt|;
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
block|{
specifier|static
name|char
name|CANTSEND
index|[]
init|=
literal|"Can't send %s to server, %s"
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"ihave %s\r\n"
argument_list|,
name|HDR
argument_list|(
name|_messageid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|ToServer
argument_list|)
operator|||
name|fgets
argument_list|(
name|buff
argument_list|,
name|buffsize
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
name|CANTSEND
argument_list|,
literal|"IHAVE"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|atoi
argument_list|(
name|buff
argument_list|)
return|;
block|}
end_function

begin_function
name|STRING
name|ARTpost
parameter_list|(
name|article
parameter_list|,
name|idbuff
parameter_list|)
name|char
modifier|*
name|article
decl_stmt|;
name|char
modifier|*
name|idbuff
decl_stmt|;
block|{
specifier|static
name|char
name|CANTSEND
index|[]
init|=
literal|"Can't send %s to server, %s"
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|char
name|buff
index|[
name|NNTP_STRLEN
operator|+
literal|2
index|]
decl_stmt|;
name|STRING
name|error
decl_stmt|;
comment|/* Set up the other headers list. */
if|if
condition|(
name|OtherHeaders
operator|==
name|NULL
condition|)
block|{
name|OtherSize
operator|=
name|HEADER_DELTA
expr_stmt|;
name|OtherHeaders
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|OtherSize
argument_list|)
expr_stmt|;
block|}
comment|/* Basic processing. */
name|OtherCount
operator|=
literal|0
expr_stmt|;
name|WasMailed
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
block|{
name|hp
operator|->
name|Size
operator|=
name|strlen
argument_list|(
name|hp
operator|->
name|Name
argument_list|)
expr_stmt|;
name|hp
operator|->
name|Value
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|article
operator|=
name|StripOffHeaders
argument_list|(
name|article
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|Error
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|article
init|;
name|p
condition|;
name|i
operator|++
operator|,
name|p
operator|=
name|next
operator|+
literal|1
control|)
if|if
condition|(
operator|(
name|next
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|DO_CHECK_INCLUDED_TEXT
argument_list|)
if|if
condition|(
operator|(
name|error
operator|=
name|CheckIncludedText
argument_list|(
name|article
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* defined(DO_CHECK_INCLUDED_TEXT) */
if|if
condition|(
operator|(
name|error
operator|=
name|ProcessHeaders
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|HDR
argument_list|(
name|_control
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|"Article is empty"
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|ValidNewsgroups
argument_list|(
name|HDR
argument_list|(
name|_newsgroups
argument_list|)
argument_list|,
name|article
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
name|WasMailed
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|HDR
argument_list|(
name|_followupto
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|EQ
argument_list|(
name|p
argument_list|,
literal|"poster"
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|ValidNewsgroups
argument_list|(
name|p
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
if|#
directive|if
name|LOCAL_MAX_ARTSIZE
operator|>
literal|0
if|if
condition|(
name|strlen
argument_list|(
name|article
argument_list|)
operator|>
name|LOCAL_MAX_ARTSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Article is bigger then local limit of %ld bytes\n"
argument_list|,
name|LOCAL_MAX_ARTSIZE
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
endif|#
directive|endif
comment|/* LOCAL_MAX_ARTSIZE> 0 */
comment|/* Open a local connection to the server. */
if|if
condition|(
name|RemoteMaster
condition|)
name|i
operator|=
name|NNTPconnect
argument_list|(
name|RemoteMaster
argument_list|,
operator|&
name|FromServer
argument_list|,
operator|&
name|ToServer
argument_list|,
name|buff
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|DO_HAVE_UNIX_DOMAIN
argument_list|)
name|i
operator|=
name|NNTPlocalopen
argument_list|(
operator|&
name|FromServer
argument_list|,
operator|&
name|ToServer
argument_list|,
name|buff
argument_list|)
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|NNTPremoteopen
argument_list|(
operator|&
name|FromServer
argument_list|,
operator|&
name|ToServer
argument_list|,
name|buff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(DO_HAVE_UNIX_DOMAIN) */
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|buff
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Error
argument_list|,
name|buff
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
name|CANTSEND
argument_list|,
literal|"connect request"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
if|if
condition|(
name|Tracing
condition|)
name|syslog
argument_list|(
name|L_TRACE
argument_list|,
literal|"%s post_connect %s"
argument_list|,
name|ClientHost
argument_list|,
name|RemoteMaster
argument_list|)
expr_stmt|;
comment|/* The code below has too many (void) casts for my tastes.  At least      * they are all inside cases that are most likely never going to      * happen -- for example, if the server crashes. */
comment|/* Offer article to server. */
name|i
operator|=
name|OfferArticle
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|,
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NNTP_AUTH_NEEDED_VAL
condition|)
block|{
comment|/* Send authorization. */
if|if
condition|(
name|NNTPsendpassword
argument_list|(
name|RemoteMaster
argument_list|,
name|FromServer
argument_list|,
name|ToServer
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
literal|"Can't authorize with %s"
argument_list|,
name|RemoteMaster
condition|?
name|RemoteMaster
else|:
literal|"innd"
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
name|i
operator|=
name|OfferArticle
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|,
name|ToServer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|NNTP_SENDIT_VAL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Error
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|SendQuit
argument_list|(
name|FromServer
argument_list|,
name|ToServer
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
if|if
condition|(
name|Tracing
condition|)
name|syslog
argument_list|(
name|L_TRACE
argument_list|,
literal|"%s post starting"
argument_list|,
name|ClientHost
argument_list|)
expr_stmt|;
comment|/* Write the headers and a blank line. */
for|for
control|(
name|hp
operator|=
name|Table
init|;
name|hp
operator|<
name|ENDOF
argument_list|(
name|Table
argument_list|)
condition|;
name|hp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|Value
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"%s: %s\r\n"
argument_list|,
name|hp
operator|->
name|Name
argument_list|,
name|hp
operator|->
name|Value
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OtherCount
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"%s\r\n"
argument_list|,
name|OtherHeaders
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLUSH_ERROR
argument_list|(
name|ToServer
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
name|CANTSEND
argument_list|,
literal|"headers"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FromServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
comment|/* Send the article, get the server's reply. */
if|if
condition|(
name|NNTPsendarticle
argument_list|(
name|article
argument_list|,
name|ToServer
argument_list|,
name|TRUE
argument_list|)
operator|<
literal|0
operator|||
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Error
argument_list|,
name|CANTSEND
argument_list|,
literal|"article"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FromServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
comment|/* Did the server want the article? */
if|if
condition|(
name|atoi
argument_list|(
name|buff
argument_list|)
operator|!=
name|NNTP_TOOKIT_VAL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Error
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|SendQuit
argument_list|(
name|FromServer
argument_list|,
name|ToServer
argument_list|)
expr_stmt|;
return|return
name|Error
return|;
block|}
comment|/* Send a quit and close down */
name|SendQuit
argument_list|(
name|FromServer
argument_list|,
name|ToServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FromServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|idbuff
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|idbuff
argument_list|,
name|HDR
argument_list|(
name|_messageid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

