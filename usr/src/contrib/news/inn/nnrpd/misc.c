begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.14 $ ** **  Miscellaneous support routines. */
end_comment

begin_include
include|#
directive|include
file|"nnrpd.h"
end_include

begin_include
include|#
directive|include
file|"dbz.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_NEED_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(DO_NEED_TIME) */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|ASCtoNUM
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_define
define|#
directive|define
name|CHARStoINT
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
value|(ASCtoNUM((c1)) * 10 + ASCtoNUM((c2)))
end_define

begin_define
define|#
directive|define
name|DaysInYear
parameter_list|(
name|y
parameter_list|)
value|((y % 4 ? 365 : 366))
end_define

begin_comment
comment|/* **  Parse a string into a NULL-terminated array of words; return number **  of words.  If argvp isn't NULL, it and what it points to will be **  DISPOSE'd. */
end_comment

begin_function
name|int
name|Argify
parameter_list|(
name|line
parameter_list|,
name|argvp
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|argvp
operator|!=
name|NULL
condition|)
block|{
name|DISPOSE
argument_list|(
operator|*
name|argvp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
operator|*
name|argvp
argument_list|)
expr_stmt|;
block|}
comment|/*  Copy the line, which we will split up. */
while|while
condition|(
name|ISWHITE
argument_list|(
operator|*
name|line
argument_list|)
condition|)
name|line
operator|++
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|p
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Allocate worst-case amount of space. */
for|for
control|(
operator|*
name|argvp
operator|=
name|argv
operator|=
name|NEW
argument_list|(
name|char
operator|*
argument_list|,
name|i
operator|+
literal|2
argument_list|)
init|;
operator|*
name|p
condition|;
control|)
block|{
comment|/* Mark start of this word, find its end. */
for|for
control|(
operator|*
name|argv
operator|++
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|!
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Nip off word, skip whitespace. */
for|for
control|(
operator|*
name|p
operator|++
operator|=
literal|'\0'
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
return|return
name|argv
operator|-
operator|*
name|argvp
return|;
block|}
end_function

begin_comment
comment|/* **  Take a vector which Argify made and glue it back together with **  spaces between each element.  Returns a pointer to dynamic space. */
end_comment

begin_function
name|char
modifier|*
name|Glom
parameter_list|(
name|av
parameter_list|)
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|v
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* Get space. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|v
operator|=
name|av
init|;
operator|*
name|v
condition|;
name|v
operator|++
control|)
name|i
operator|+=
name|strlen
argument_list|(
operator|*
name|v
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|save
operator|=
name|p
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|,
name|v
operator|=
name|av
init|;
operator|*
name|v
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|>
name|save
condition|)
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* **  Match a list of newsgroup specifiers against a list of newsgroups. **  func is called to see if there is a match. */
end_comment

begin_function
name|BOOL
name|PERMmatch
parameter_list|(
name|match
parameter_list|,
name|Pats
parameter_list|,
name|list
parameter_list|)
specifier|register
name|BOOL
name|match
decl_stmt|;
name|char
modifier|*
modifier|*
name|Pats
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|Pats
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
name|TRUE
return|;
for|for
control|(
init|;
operator|*
name|list
condition|;
name|list
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|p
operator|=
name|Pats
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|wildmat
argument_list|(
operator|*
name|list
argument_list|,
operator|++
name|p
argument_list|)
condition|)
name|match
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wildmat
argument_list|(
operator|*
name|list
argument_list|,
name|p
argument_list|)
condition|)
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/* **  Check to see if user is allowed to see this article by matching **  Newsgroups line. */
end_comment

begin_function
name|BOOL
name|PERMartok
parameter_list|(
name|qp
parameter_list|)
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|grplist
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|BOOL
name|found
decl_stmt|;
if|if
condition|(
operator|!
name|PERMspecified
condition|)
return|return
name|PERMdefault
return|;
for|for
control|(
name|found
operator|=
name|FALSE
init|;
condition|;
control|)
block|{
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
comment|/* End of header */
break|break;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'N'
operator|&&
operator|*
name|p
operator|!=
literal|'n'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|caseEQ
argument_list|(
name|p
argument_list|,
literal|"newsgroups"
argument_list|)
condition|)
block|{
name|found
operator|=
name|NGgetlist
argument_list|(
operator|&
name|grplist
argument_list|,
name|q
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|QIOrewind
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
comment|/* No newgroups or null entry. */
return|return
literal|1
return|;
return|return
name|PERMmatch
argument_list|(
name|PERMdefault
argument_list|,
name|PERMlist
argument_list|,
name|grplist
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* **  Parse a date like yymmddhhmmss into a long.  Return -1 on error. */
end_comment

begin_function
name|long
name|NNTPtoGMT
parameter_list|(
name|av1
parameter_list|,
name|av2
parameter_list|)
name|char
modifier|*
name|av1
decl_stmt|;
name|char
modifier|*
name|av2
decl_stmt|;
block|{
comment|/* Note that this is origin-one! */
specifier|static
name|int
name|DaysInMonth
index|[
literal|12
index|]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|}
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|year
decl_stmt|;
name|int
name|month
decl_stmt|;
name|int
name|day
decl_stmt|;
name|int
name|hour
decl_stmt|;
name|int
name|mins
decl_stmt|;
name|int
name|secs
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|seconds
decl_stmt|;
name|char
name|buff
index|[
literal|6
operator|+
literal|6
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|av1
argument_list|)
operator|!=
literal|6
operator|||
name|strlen
argument_list|(
name|av2
argument_list|)
operator|!=
literal|6
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s%s"
argument_list|,
name|av1
argument_list|,
name|av2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buff
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|CTYPE
argument_list|(
name|isdigit
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|year
operator|=
name|CHARStoINT
argument_list|(
name|buff
index|[
literal|0
index|]
argument_list|,
name|buff
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|month
operator|=
name|CHARStoINT
argument_list|(
name|buff
index|[
literal|2
index|]
argument_list|,
name|buff
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|day
operator|=
name|CHARStoINT
argument_list|(
name|buff
index|[
literal|4
index|]
argument_list|,
name|buff
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|hour
operator|=
name|CHARStoINT
argument_list|(
name|buff
index|[
literal|6
index|]
argument_list|,
name|buff
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|mins
operator|=
name|CHARStoINT
argument_list|(
name|buff
index|[
literal|8
index|]
argument_list|,
name|buff
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|secs
operator|=
name|CHARStoINT
argument_list|(
name|buff
index|[
literal|10
index|]
argument_list|,
name|buff
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|month
operator|<
literal|1
operator|||
name|month
operator|>
literal|12
operator|||
name|day
operator|<
literal|1
operator|||
name|day
operator|>
literal|31
operator|||
name|mins
operator|<
literal|0
operator|||
name|mins
operator|>
literal|59
operator|||
name|secs
operator|<
literal|0
operator|||
name|secs
operator|>
literal|59
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|hour
operator|==
literal|24
condition|)
block|{
name|hour
operator|=
literal|0
expr_stmt|;
name|day
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hour
operator|<
literal|0
operator|||
name|hour
operator|>
literal|23
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|seconds
operator|=
literal|0
operator|,
name|year
operator|+=
literal|1900
operator|,
name|i
operator|=
literal|1970
init|;
name|i
operator|<
name|year
condition|;
name|i
operator|++
control|)
name|seconds
operator|+=
name|DaysInYear
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|DaysInYear
argument_list|(
name|year
argument_list|)
operator|==
literal|366
operator|&&
name|month
operator|>
literal|2
condition|)
name|seconds
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|month
operator|>
literal|0
condition|)
name|seconds
operator|+=
name|DaysInMonth
index|[
name|month
index|]
expr_stmt|;
name|seconds
operator|+=
name|day
operator|-
literal|1
expr_stmt|;
name|seconds
operator|=
literal|24
operator|*
name|seconds
operator|+
name|hour
expr_stmt|;
name|seconds
operator|=
literal|60
operator|*
name|seconds
operator|+
name|mins
expr_stmt|;
name|seconds
operator|=
literal|60
operator|*
name|seconds
operator|+
name|secs
expr_stmt|;
return|return
name|seconds
return|;
block|}
end_function

begin_comment
comment|/* **  Convert local time (seconds since epoch) to GMT. */
end_comment

begin_function
name|long
name|LOCALtoGMT
parameter_list|(
name|t
parameter_list|)
name|long
name|t
decl_stmt|;
block|{
name|TIMEINFO
name|Now
decl_stmt|;
operator|(
name|void
operator|)
name|GetTimeInfo
argument_list|(
operator|&
name|Now
argument_list|)
expr_stmt|;
name|t
operator|+=
name|Now
operator|.
name|tzone
operator|*
literal|60
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* **  Return the path name of an article if it is in the history file. **  Return a pointer to static data. */
end_comment

begin_function
name|char
modifier|*
name|HISgetent
parameter_list|(
name|msg_id
parameter_list|,
name|fulldata
parameter_list|)
name|char
modifier|*
name|msg_id
decl_stmt|;
name|BOOL
name|fulldata
decl_stmt|;
block|{
specifier|static
name|BOOL
name|setup
decl_stmt|;
if|#
directive|if
name|NNRP_DBZINCORE_DELAY
operator|>
literal|0
specifier|static
name|int
name|count
init|=
name|NNRP_DBZINCORE_DELAY
decl_stmt|;
endif|#
directive|endif
comment|/* NNRP_DBZINCORE_DELAY> 0 */
specifier|static
name|FILE
modifier|*
name|hfp
decl_stmt|;
specifier|static
name|char
name|path
index|[
name|BIG_BUFFER
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|char
name|buff
index|[
name|BIG_BUFFER
index|]
decl_stmt|;
name|OFFSET_T
name|l
decl_stmt|;
name|datum
name|key
decl_stmt|;
name|datum
name|value
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
if|#
directive|if
name|NNRP_DBZINCORE_DELAY
operator|>
literal|0
if|if
condition|(
name|count
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|setup
condition|)
block|{
operator|(
name|void
operator|)
name|dbmclose
argument_list|()
expr_stmt|;
name|setup
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dbzincore
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NNRP_DBZINCORE_DELAY> 0 */
if|if
condition|(
operator|!
name|setup
condition|)
block|{
if|if
condition|(
name|dbminit
argument_list|(
name|HISTORY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant dbminit %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|HISTORY
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|setup
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Set the key value, fetch the entry. */
for|for
control|(
name|p
operator|=
name|key
operator|.
name|dptr
operator|=
name|msg_id
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|HIS_FIELDSEP
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
name|HIS_BADCHAR
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|p
operator|-
name|key
operator|.
name|dptr
operator|+
literal|1
expr_stmt|;
name|value
operator|=
name|dbzfetch
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|dptr
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|q
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l
operator|,
name|p
operator|=
name|value
operator|.
name|dptr
operator|,
name|i
operator|=
sizeof|sizeof
name|l
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Open history file if we need to. */
if|if
condition|(
name|hfp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|hfp
operator|=
name|fopen
argument_list|(
name|HISTORY
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fopen %s %m"
argument_list|,
name|ClientHost
argument_list|,
name|HISTORY
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|CloseOnExec
argument_list|(
operator|(
name|int
operator|)
name|fileno
argument_list|(
name|hfp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Seek and read. */
if|if
condition|(
name|fseek
argument_list|(
name|hfp
argument_list|,
name|l
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fseek to %ld %m"
argument_list|,
name|ClientHost
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|hfp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant fgets from %ld %m"
argument_list|,
name|ClientHost
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Skip first two fields. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s bad_history at %ld for %s"
argument_list|,
name|ClientHost
argument_list|,
name|l
argument_list|,
name|msg_id
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* Article has expired. */
return|return
name|NULL
return|;
name|save
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Want the full data? */
if|if
condition|(
name|fulldata
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|path
argument_list|,
name|save
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/* Want something we can open; loop over all entries. */
for|for
control|(
init|;
condition|;
name|save
operator|=
name|q
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|save
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|save
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_SPOOL
argument_list|,
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|path
return|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Parse a newsgroups line, return TRUE if there were any. */
end_comment

begin_function
name|BOOL
name|NGgetlist
parameter_list|(
name|argvp
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
return|return
name|Argify
argument_list|(
name|list
argument_list|,
name|argvp
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* **  Take an NNTP distribution list<d1,d2,...> and turn it into an array. */
end_comment

begin_function
name|BOOL
name|ParseDistlist
parameter_list|(
name|argvp
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
name|char
modifier|*
name|list
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|list
index|[
literal|0
index|]
operator|!=
literal|'<'
operator|||
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|&
name|list
index|[
literal|1
index|]
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|list
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|Argify
argument_list|(
name|list
operator|+
literal|1
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
operator|*
name|argvp
operator|=
name|argv
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Read a line of input, with timeout. */
end_comment

begin_function
name|READTYPE
name|READline
parameter_list|(
name|start
parameter_list|,
name|size
parameter_list|,
name|timeout
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
specifier|static
name|int
name|count
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|FDSET
name|rmask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|p
operator|=
name|start
operator|,
name|end
operator|=
operator|&
name|start
index|[
name|size
operator|-
literal|1
index|]
init|;
condition|;
control|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* Fill the buffer. */
name|Again
label|:
name|FD_ZERO
argument_list|(
operator|&
name|rmask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|STDIN
argument_list|,
operator|&
name|rmask
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
name|timeout
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|select
argument_list|(
name|STDIN
operator|+
literal|1
argument_list|,
operator|&
name|rmask
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|FDSET
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|Again
goto|;
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant select %m"
argument_list|,
name|ClientHost
argument_list|)
expr_stmt|;
return|return
name|RTtimeout
return|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
operator|!
name|FD_ISSET
argument_list|(
name|STDIN
argument_list|,
operator|&
name|rmask
argument_list|)
condition|)
return|return
name|RTtimeout
return|;
name|count
operator|=
name|read
argument_list|(
name|STDIN
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|L_ERROR
argument_list|,
literal|"%s cant read %m"
argument_list|,
name|ClientHost
argument_list|)
expr_stmt|;
return|return
name|RTtimeout
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|RTeof
return|;
name|bp
operator|=
name|buffer
expr_stmt|;
block|}
comment|/* Process next character. */
name|count
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* If last two characters are \r\n, kill the \r as well as the \n. */
if|if
condition|(
name|p
operator|>
name|start
operator|&&
name|p
operator|<
name|end
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
operator|==
name|end
condition|?
name|RTlong
else|:
name|RTok
return|;
block|}
end_function

end_unit

