begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 1.13 $ ** **  Article-related routines. */
end_comment

begin_include
include|#
directive|include
file|"nnrpd.h"
end_include

begin_comment
comment|/* **  Data structures for use in ARTICLE/HEAD/BODY/STAT common code. */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|_SENDTYPE
block|{
name|STarticle
block|,
name|SThead
block|,
name|STbody
block|,
name|STstat
block|}
name|SENDTYPE
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_SENDDATA
block|{
name|SENDTYPE
name|Type
decl_stmt|;
name|int
name|ReplyCode
decl_stmt|;
name|STRING
name|Item
decl_stmt|;
block|}
name|SENDDATA
typedef|;
end_typedef

begin_comment
comment|/* **  Information about the schema of the news overview files. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_ARTOVERFIELD
block|{
name|char
modifier|*
name|Header
decl_stmt|;
name|int
name|Length
decl_stmt|;
name|BOOL
name|HasHeader
decl_stmt|;
block|}
name|ARTOVERFIELD
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|char
name|ARTnotingroup
index|[]
init|=
name|NNTP_NOTINGROUP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|ARTnoartingroup
index|[]
init|=
name|NNTP_NOARTINGRP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|char
name|ARTnocurrart
index|[]
init|=
name|NNTP_NOCURRART
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|QIOSTATE
modifier|*
name|ARTqp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|ARTOVERFIELD
modifier|*
name|ARTfields
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|ARTfieldsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SENDDATA
name|SENDbody
init|=
block|{
name|STbody
block|,
name|NNTP_BODY_FOLLOWS_VAL
block|,
literal|"body"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SENDDATA
name|SENDarticle
init|=
block|{
name|STarticle
block|,
name|NNTP_ARTICLE_FOLLOWS_VAL
block|,
literal|"article"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SENDDATA
name|SENDstat
init|=
block|{
name|STstat
block|,
name|NNTP_NOTHING_FOLLOWS_VAL
block|,
literal|"status"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|SENDDATA
name|SENDhead
init|=
block|{
name|SThead
block|,
name|NNTP_HEAD_FOLLOWS_VAL
block|,
literal|"head"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **  Overview state information. */
end_comment

begin_decl_stmt
name|STATIC
name|QIOSTATE
modifier|*
name|OVERqp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open overview file	*/
end_comment

begin_decl_stmt
name|STATIC
name|char
modifier|*
name|OVERline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current line		*/
end_comment

begin_decl_stmt
name|STATIC
name|ARTNUM
name|OVERarticle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current article	*/
end_comment

begin_decl_stmt
name|STATIC
name|int
name|OVERopens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of opens done	*/
end_comment

begin_comment
comment|/* **  Read the overview schema. */
end_comment

begin_function
name|void
name|ARTreadschema
parameter_list|()
block|{
specifier|static
name|char
name|SCHEMA
index|[]
init|=
name|_PATH_SCHEMA
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|F
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
comment|/* Open file, count lines. */
if|if
condition|(
operator|(
name|F
operator|=
name|fopen
argument_list|(
name|SCHEMA
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
continue|continue;
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|F
argument_list|,
operator|(
name|OFFSET_T
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|ARTfields
operator|=
name|NEW
argument_list|(
name|ARTOVERFIELD
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Parse each field. */
for|for
control|(
name|fp
operator|=
name|ARTfields
init|;
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|F
argument_list|)
operator|!=
name|NULL
condition|;
control|)
block|{
comment|/* Ignore blank and comment lines. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
name|COMMENT_CHAR
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|->
name|HasHeader
operator|=
name|EQ
argument_list|(
name|p
argument_list|,
literal|"full"
argument_list|)
expr_stmt|;
block|}
else|else
name|fp
operator|->
name|HasHeader
operator|=
name|FALSE
expr_stmt|;
name|fp
operator|->
name|Header
operator|=
name|COPY
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|fp
operator|->
name|Length
operator|=
name|strlen
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|fp
operator|++
expr_stmt|;
block|}
name|ARTfieldsize
operator|=
name|fp
operator|-
name|ARTfields
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|F
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  If we have an article open, close it. */
end_comment

begin_function
name|void
name|ARTclose
parameter_list|()
block|{
if|if
condition|(
name|ARTqp
condition|)
block|{
name|QIOclose
argument_list|(
name|ARTqp
argument_list|)
expr_stmt|;
name|ARTqp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Get the Message-ID from a file. */
end_comment

begin_function
name|STATIC
name|void
name|ARTgetmsgid
parameter_list|(
name|qp
parameter_list|,
name|id
parameter_list|)
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
operator|*
name|id
operator|=
literal|'\0'
init|;
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'M'
operator|&&
operator|*
name|p
operator|!=
literal|'m'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|caseEQ
argument_list|(
name|p
argument_list|,
literal|"Message-ID:"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|id
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|QIOrewind
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  If the article name is valid, open it and stuff in the ID. */
end_comment

begin_function
name|STATIC
name|BOOL
name|ARTopen
parameter_list|(
name|name
parameter_list|,
name|id
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
block|{
specifier|static
name|ARTNUM
name|save_artnum
decl_stmt|;
specifier|static
name|char
name|save_artid
index|[
name|BIG_BUFFER
index|]
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
comment|/* Re-use article if it's the same one. */
if|if
condition|(
name|ARTqp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|save_artnum
operator|==
name|atol
argument_list|(
name|name
argument_list|)
operator|&&
name|QIOrewind
argument_list|(
name|ARTqp
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|id
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|id
argument_list|,
name|save_artid
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|QIOclose
argument_list|(
name|ARTqp
argument_list|)
expr_stmt|;
block|}
comment|/* Open it, make sure it's a regular file. */
if|if
condition|(
operator|(
name|ARTqp
operator|=
name|QIOopen
argument_list|(
name|name
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fstat
argument_list|(
name|QIOfileno
argument_list|(
name|ARTqp
argument_list|)
argument_list|,
operator|&
name|Sb
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|Sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|QIOclose
argument_list|(
name|ARTqp
argument_list|)
expr_stmt|;
name|ARTqp
operator|=
name|NULL
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|CloseOnExec
argument_list|(
name|QIOfileno
argument_list|(
name|ARTqp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|save_artnum
operator|=
name|atol
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ARTgetmsgid
argument_list|(
name|ARTqp
argument_list|,
name|save_artid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|id
argument_list|,
name|save_artid
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Open the article for a given Message-ID. */
end_comment

begin_function
name|STATIC
name|QIOSTATE
modifier|*
name|ARTopenbyid
parameter_list|(
name|msg_id
parameter_list|,
name|ap
parameter_list|)
name|char
modifier|*
name|msg_id
decl_stmt|;
name|ARTNUM
modifier|*
name|ap
decl_stmt|;
block|{
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
operator|*
name|ap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|HISgetent
argument_list|(
name|msg_id
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|p
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|CloseOnExec
argument_list|(
name|QIOfileno
argument_list|(
name|qp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|GRPlast
index|[
literal|0
index|]
operator|&&
name|EQ
argument_list|(
name|p
argument_list|,
name|GRPlast
argument_list|)
condition|)
operator|*
name|ap
operator|=
name|atol
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|qp
return|;
block|}
end_function

begin_comment
comment|/* **  Send a (part of) a file to stdout, doing newline and dot conversion. */
end_comment

begin_function
name|STATIC
name|void
name|ARTsend
parameter_list|(
name|qp
parameter_list|,
name|what
parameter_list|)
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|SENDTYPE
name|what
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|ARTcount
operator|++
expr_stmt|;
name|GRParticles
operator|++
expr_stmt|;
comment|/* Get the headers. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|what
operator|==
name|STbody
condition|)
continue|continue;
name|Printf
argument_list|(
literal|"%s%s\r\n"
argument_list|,
operator|*
name|p
operator|==
literal|'.'
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|what
operator|==
name|SThead
condition|)
block|{
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|what
operator|==
name|STarticle
condition|)
name|Printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
name|Printf
argument_list|(
literal|"%s%s\r\n"
argument_list|,
operator|*
name|p
operator|==
literal|'.'
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Find an article number in the article array via a binary search; **  return -1 if not found.  Cache last hit to make linear lookups **  faster. */
end_comment

begin_function
name|STATIC
name|int
name|ARTfind
parameter_list|(
name|i
parameter_list|)
specifier|register
name|ARTNUM
name|i
decl_stmt|;
block|{
specifier|register
name|ARTNUM
modifier|*
name|bottom
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|middle
decl_stmt|;
specifier|register
name|ARTNUM
modifier|*
name|top
decl_stmt|;
if|if
condition|(
name|ARTsize
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|top
operator|=
operator|&
name|ARTnumbers
index|[
name|ARTsize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ARTcache
operator|&&
operator|++
name|ARTcache
operator|<=
name|top
operator|&&
operator|*
name|ARTcache
operator|<=
name|i
condition|)
block|{
if|if
condition|(
operator|*
name|ARTcache
operator|==
name|i
condition|)
return|return
name|ARTcache
operator|-
name|ARTnumbers
return|;
name|bottom
operator|=
name|ARTcache
expr_stmt|;
block|}
else|else
block|{
name|ARTcache
operator|=
name|NULL
expr_stmt|;
name|bottom
operator|=
name|ARTnumbers
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|<
operator|*
name|bottom
operator|||
name|i
operator|>
operator|*
name|top
condition|)
break|break;
name|middle
operator|=
name|bottom
operator|+
operator|(
name|top
operator|-
name|bottom
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|*
name|middle
condition|)
block|{
comment|/* Found it; update cache. */
name|ARTcache
operator|=
name|middle
expr_stmt|;
return|return
name|middle
operator|-
name|ARTnumbers
return|;
block|}
if|if
condition|(
name|i
operator|>
operator|*
name|middle
condition|)
name|bottom
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
name|top
operator|=
name|middle
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* **  Ask the innd server for the article.  Only called from CMDfetch, **  and only if history file is buffered.  Common case:  "oops, cancel **  that article I just posted." */
end_comment

begin_function
name|STATIC
name|QIOSTATE
modifier|*
name|ARTfromboss
parameter_list|(
name|what
parameter_list|,
name|id
parameter_list|)
name|SENDDATA
modifier|*
name|what
decl_stmt|;
name|char
modifier|*
name|id
decl_stmt|;
block|{
name|FILE
modifier|*
name|FromServer
decl_stmt|;
name|FILE
modifier|*
name|ToServer
decl_stmt|;
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
name|char
name|buff
index|[
name|NNTP_STRLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|BOOL
name|more
decl_stmt|;
comment|/* If we can, open the connection. */
if|if
condition|(
name|NNTPlocalopen
argument_list|(
operator|&
name|FromServer
argument_list|,
operator|&
name|ToServer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Send the query to the server. */
name|qp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"XPATH %s\r\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|ToServer
argument_list|)
condition|)
goto|goto
name|QuitClose
goto|;
comment|/* Get the reply; article exist? */
if|if
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
operator|==
name|NULL
operator|||
name|atoi
argument_list|(
name|buff
argument_list|)
operator|==
name|NNTP_DONTHAVEIT_VAL
condition|)
goto|goto
name|QuitClose
goto|;
comment|/* Yes.  Be quick if just doing a stat. */
if|if
condition|(
name|what
operator|==
operator|&
name|SENDstat
condition|)
block|{
name|qp
operator|=
name|QIOopen
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|QuitClose
goto|;
block|}
comment|/* Clean up response. */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\r'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|buff
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Loop over all filenames until we can open one. */
for|for
control|(
name|name
operator|=
name|buff
init|;
operator|*
name|name
condition|;
name|name
operator|=
name|p
operator|+
literal|1
control|)
block|{
comment|/* Snip off next name, turn dots to slashes. */
for|for
control|(
name|p
operator|=
name|name
init|;
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
for|for
control|(
name|name
operator|=
name|p
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|more
operator|=
operator|*
name|p
operator|==
literal|' '
expr_stmt|;
if|if
condition|(
name|more
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|name
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|!
name|more
condition|)
break|break;
block|}
comment|/* Send quit, read server's reply, close up and return. */
name|QuitClose
label|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ToServer
argument_list|,
literal|"quit\r\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ToServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|,
name|FromServer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|FromServer
argument_list|)
expr_stmt|;
return|return
name|qp
return|;
block|}
end_function

begin_comment
comment|/* **  Fetch part or all of an article and send it to the client. */
end_comment

begin_function
name|FUNCTYPE
name|CMDfetch
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
name|buff
index|[
name|SMBUF
index|]
decl_stmt|;
name|char
name|idbuff
index|[
name|BIG_BUFFER
index|]
decl_stmt|;
name|SENDDATA
modifier|*
name|what
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|BOOL
name|ok
decl_stmt|;
name|ARTNUM
name|art
decl_stmt|;
comment|/* Find what to send; get permissions. */
name|ok
operator|=
name|PERMcanread
expr_stmt|;
switch|switch
condition|(
operator|*
name|av
index|[
literal|0
index|]
condition|)
block|{
default|default:
name|what
operator|=
operator|&
name|SENDbody
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|what
operator|=
operator|&
name|SENDarticle
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|what
operator|=
operator|&
name|SENDstat
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|what
operator|=
operator|&
name|SENDhead
expr_stmt|;
comment|/* Poster might do a "head" command to verify the article. */
name|ok
operator|=
name|PERMcanread
operator|||
name|PERMcanpost
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Requesting by Message-ID? */
if|if
condition|(
name|ac
operator|==
literal|2
operator|&&
name|av
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
operator|(
name|qp
operator|=
name|ARTopenbyid
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|art
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|qp
operator|=
name|ARTfromboss
argument_list|(
name|what
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Reply
argument_list|(
literal|"%d No such article\r\n"
argument_list|,
name|NNTP_DONTHAVEIT_VAL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|PERMartok
argument_list|(
name|qp
argument_list|)
condition|)
block|{
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
name|Reply
argument_list|(
literal|"%d %ld %s %s\r\n"
argument_list|,
name|what
operator|->
name|ReplyCode
argument_list|,
name|art
argument_list|,
name|what
operator|->
name|Item
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|->
name|Type
operator|!=
name|STstat
condition|)
name|ARTsend
argument_list|(
name|qp
argument_list|,
name|what
operator|->
name|Type
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Trying to read. */
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnotingroup
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Default is to get current article, or specified article. */
if|if
condition|(
name|ac
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ARTindex
operator|<
literal|0
operator|||
name|ARTindex
operator|>=
name|ARTsize
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnocurrart
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|ARTnumbers
index|[
name|ARTindex
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strspn
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnoartingroup
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buff
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Move forward until we can find one. */
while|while
condition|(
operator|!
name|ARTopen
argument_list|(
name|buff
argument_list|,
name|idbuff
argument_list|)
condition|)
block|{
if|if
condition|(
name|ac
operator|>
literal|1
operator|||
operator|++
name|ARTindex
operator|>=
name|ARTsize
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnoartingroup
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|ARTnumbers
index|[
name|ARTindex
index|]
argument_list|)
expr_stmt|;
block|}
name|Reply
argument_list|(
literal|"%d %s %s %s\r\n"
argument_list|,
name|what
operator|->
name|ReplyCode
argument_list|,
name|buff
argument_list|,
name|idbuff
argument_list|,
name|what
operator|->
name|Item
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|->
name|Type
operator|!=
name|STstat
condition|)
name|ARTsend
argument_list|(
name|ARTqp
argument_list|,
name|what
operator|->
name|Type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|ARTindex
operator|=
name|ARTfind
argument_list|(
operator|(
name|ARTNUM
operator|)
name|atol
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Go to the next or last (really previous) article in the group. */
end_comment

begin_function
name|FUNCTYPE
name|CMDnextlast
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|char
name|idbuff
index|[
name|SMBUF
index|]
decl_stmt|;
name|int
name|save
decl_stmt|;
name|BOOL
name|next
decl_stmt|;
name|int
name|delta
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|STRING
name|message
decl_stmt|;
if|if
condition|(
operator|!
name|PERMcanread
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnotingroup
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ARTindex
operator|<
literal|0
operator|||
name|ARTindex
operator|>=
name|ARTsize
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnocurrart
argument_list|)
expr_stmt|;
return|return;
block|}
name|next
operator|=
operator|(
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'n'
operator|||
name|av
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|errcode
operator|=
name|NNTP_NONEXT_VAL
expr_stmt|;
name|message
operator|=
literal|"next"
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|errcode
operator|=
name|NNTP_NOPREV_VAL
expr_stmt|;
name|message
operator|=
literal|"previous"
expr_stmt|;
block|}
name|save
operator|=
name|ARTindex
expr_stmt|;
name|ARTindex
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|ARTindex
operator|<
literal|0
operator|||
name|ARTindex
operator|>=
name|ARTsize
condition|)
block|{
name|Reply
argument_list|(
literal|"%d No %s to retrieve.\r\n"
argument_list|,
name|errcode
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|ARTindex
operator|=
name|save
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|ARTnumbers
index|[
name|ARTindex
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|ARTopen
argument_list|(
name|buff
argument_list|,
name|idbuff
argument_list|)
condition|)
block|{
name|ARTindex
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|ARTindex
operator|<
literal|0
operator|||
name|ARTindex
operator|>=
name|ARTsize
condition|)
block|{
name|Reply
argument_list|(
literal|"%d No %s article to retrieve.\r\n"
argument_list|,
name|errcode
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|ARTindex
operator|=
name|save
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|ARTnumbers
index|[
name|ARTindex
index|]
argument_list|)
expr_stmt|;
block|}
name|Reply
argument_list|(
literal|"%d %s %s Article retrieved; request text separately.\r\n"
argument_list|,
name|NNTP_NOTHING_FOLLOWS_VAL
argument_list|,
name|buff
argument_list|,
name|idbuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|ARTindex
operator|=
name|ARTfind
argument_list|(
operator|(
name|ARTNUM
operator|)
name|atol
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  Return the header from the specified file, or NULL if not found. **  We can estimate the Lines header, if that's what's wanted. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|GetHeader
parameter_list|(
name|qp
parameter_list|,
name|header
parameter_list|,
name|IsLines
parameter_list|)
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|header
decl_stmt|;
name|BOOL
name|IsLines
decl_stmt|;
block|{
specifier|static
name|char
name|buff
index|[
literal|40
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* End of headers. */
break|break;
if|if
condition|(
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* Continuation or bogus (shouldn't happen) line; ignore. */
continue|continue;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|caseEQ
argument_list|(
name|header
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|*
operator|++
name|q
condition|?
name|q
operator|+
literal|1
else|:
name|NULL
return|;
block|}
if|if
condition|(
name|IsLines
operator|&&
name|fstat
argument_list|(
name|QIOfileno
argument_list|(
name|qp
argument_list|)
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Lines estimation taken from Tor Lillqvist<tml@tik.vtt.fi>'s 	 * posting<TML.92Jul10031233@hemuli.tik.vtt.fi> in 	 * news.sysadmin. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|6.4e-8
operator|*
name|Sb
operator|.
name|st_size
operator|*
name|Sb
operator|.
name|st_size
operator|+
literal|0.023
operator|*
name|Sb
operator|.
name|st_size
operator|-
literal|12
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|STATIC
name|BOOL
name|CMDgetrange
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|,
name|rp
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
specifier|register
name|ARTRANGE
modifier|*
name|rp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnotingroup
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ac
operator|==
literal|1
condition|)
block|{
comment|/* No argument, do only current article. */
if|if
condition|(
name|ARTindex
operator|<
literal|0
operator|||
name|ARTindex
operator|>=
name|ARTsize
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnocurrart
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rp
operator|->
name|High
operator|=
name|rp
operator|->
name|Low
operator|=
name|ARTnumbers
index|[
name|ARTindex
index|]
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Got just a single number? */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rp
operator|->
name|Low
operator|=
name|rp
operator|->
name|High
operator|=
name|atol
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* Parse range. */
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|rp
operator|->
name|Low
operator|=
name|atol
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARTsize
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
name|rp
operator|->
name|High
operator|=
name|atol
argument_list|(
name|p
argument_list|)
operator|)
operator|<
name|rp
operator|->
name|Low
condition|)
comment|/* "XHDR 234-0 header" gives everything to the end. */
name|rp
operator|->
name|High
operator|=
name|ARTnumbers
index|[
name|ARTsize
operator|-
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|High
operator|>
name|ARTnumbers
index|[
name|ARTsize
operator|-
literal|1
index|]
condition|)
name|rp
operator|->
name|High
operator|=
name|ARTnumbers
index|[
name|ARTsize
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|Low
operator|<
name|ARTnumbers
index|[
literal|0
index|]
condition|)
name|rp
operator|->
name|Low
operator|=
name|ARTnumbers
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
comment|/* No articles; make sure loops don't run. */
name|rp
operator|->
name|High
operator|=
name|rp
operator|->
name|Low
condition|?
name|rp
operator|->
name|Low
operator|-
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* **  Return a field from the overview line or NULL on error.  Return a copy **  since we might be re-using the line later. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|OVERGetHeader
parameter_list|(
name|p
parameter_list|,
name|field
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|field
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buff
decl_stmt|;
specifier|static
name|int
name|buffsize
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Skip leading headers. */
for|for
control|(
name|fp
operator|=
operator|&
name|ARTfields
index|[
name|field
operator|-
literal|1
index|]
init|;
operator|--
name|field
operator|>=
literal|0
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|fp
operator|->
name|HasHeader
condition|)
name|p
operator|+=
name|fp
operator|->
name|Length
operator|+
literal|2
expr_stmt|;
comment|/* Figure out length; get space. */
if|if
condition|(
operator|(
name|next
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\t'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|i
operator|=
name|next
operator|-
name|p
expr_stmt|;
else|else
name|i
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffsize
operator|==
literal|0
condition|)
block|{
name|buffsize
operator|=
name|i
expr_stmt|;
name|buff
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|buffsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffsize
operator|<
name|i
condition|)
block|{
name|buffsize
operator|=
name|i
expr_stmt|;
name|RENEW
argument_list|(
name|buff
argument_list|,
name|char
argument_list|,
name|buffsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buff
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* **  Open an OVERVIEW file. */
end_comment

begin_function
name|STATIC
name|BOOL
name|OVERopen
parameter_list|()
block|{
name|char
name|name
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
comment|/* Already open? */
if|if
condition|(
name|OVERqp
operator|!=
name|NULL
condition|)
comment|/* Don't rewind -- we are probably going forward via repeated 	 * NNTP commands. */
return|return
name|TRUE
return|;
comment|/* Failed here before? */
if|if
condition|(
name|OVERopens
operator|++
condition|)
return|return
name|FALSE
return|;
name|OVERline
operator|=
name|NULL
expr_stmt|;
name|OVERarticle
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|_PATH_OVERVIEWDIR
argument_list|,
name|GRPlast
argument_list|,
name|_PATH_OVERVIEW
argument_list|)
expr_stmt|;
name|OVERqp
operator|=
name|QIOopen
argument_list|(
name|name
argument_list|,
name|QIO_BUFFER
argument_list|)
expr_stmt|;
return|return
name|OVERqp
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Close the OVERVIEW file. */
end_comment

begin_function
name|void
name|OVERclose
parameter_list|()
block|{
if|if
condition|(
name|OVERqp
operator|!=
name|NULL
condition|)
block|{
name|QIOclose
argument_list|(
name|OVERqp
argument_list|)
expr_stmt|;
name|OVERqp
operator|=
name|NULL
expr_stmt|;
name|OVERopens
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **  Return the overview data for an article or NULL on failure. **  Assumes that what we return is never modified. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|OVERfind
parameter_list|(
name|artnum
parameter_list|)
name|ARTNUM
name|artnum
decl_stmt|;
block|{
if|if
condition|(
name|OVERqp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|OVERarticle
operator|>
name|artnum
condition|)
block|{
operator|(
name|void
operator|)
name|QIOrewind
argument_list|(
name|OVERqp
argument_list|)
expr_stmt|;
name|OVERarticle
operator|=
literal|0
expr_stmt|;
name|OVERline
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
init|;
name|OVERarticle
operator|<
name|artnum
condition|;
name|OVERarticle
operator|=
name|atol
argument_list|(
name|OVERline
argument_list|)
control|)
if|if
condition|(
operator|(
name|OVERline
operator|=
name|QIOread
argument_list|(
name|OVERqp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|OVERqp
argument_list|)
condition|)
continue|continue;
comment|/* Don't close file; we may rewind. */
return|return
name|NULL
return|;
block|}
return|return
name|OVERarticle
operator|==
name|artnum
condition|?
name|OVERline
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* **  Read an article and create an overview line without the trailing **  newline.  Returns pointer to static space or NULL on error. */
end_comment

begin_function
name|STATIC
name|char
modifier|*
name|OVERgen
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|ARTOVERFIELD
modifier|*
name|Headers
decl_stmt|;
specifier|static
name|char
modifier|*
name|buff
decl_stmt|;
specifier|static
name|int
name|buffsize
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|fp
decl_stmt|;
specifier|register
name|ARTOVERFIELD
modifier|*
name|hp
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|char
modifier|*
name|colon
decl_stmt|;
specifier|register
name|char
modifier|*
name|line
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|int
name|ov_size
decl_stmt|;
specifier|register
name|long
name|lines
decl_stmt|;
name|struct
name|stat
name|Sb
decl_stmt|;
name|long
name|t
decl_stmt|;
name|char
name|value
index|[
literal|10
index|]
decl_stmt|;
comment|/* Open article. */
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|name
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|name
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Set up place to store headers. */
if|if
condition|(
name|Headers
operator|==
name|NULL
condition|)
block|{
name|Headers
operator|=
name|NEW
argument_list|(
name|ARTOVERFIELD
argument_list|,
name|ARTfieldsize
argument_list|)
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
control|)
name|hp
operator|->
name|Length
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
control|)
name|hp
operator|->
name|HasHeader
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read next line. */
if|if
condition|(
operator|(
name|line
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
comment|/* Error or EOF (in headers!?); shouldn't happen. */
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* End of headers? */
if|if
condition|(
operator|*
name|line
operator|==
literal|'\0'
condition|)
break|break;
comment|/* See if we want this header. */
name|fp
operator|=
name|ARTfields
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
operator|,
name|fp
operator|++
control|)
block|{
name|colon
operator|=
operator|&
name|line
index|[
name|fp
operator|->
name|Length
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|colon
operator|!=
literal|':'
condition|)
continue|continue;
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|caseEQ
argument_list|(
name|line
argument_list|,
name|fp
operator|->
name|Header
argument_list|)
condition|)
block|{
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
continue|continue;
block|}
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|HasHeader
condition|)
name|p
operator|=
name|line
expr_stmt|;
else|else
comment|/* Skip colon and whitespace, store value. */
for|for
control|(
name|p
operator|=
name|colon
init|;
operator|*
operator|++
name|p
operator|&&
name|ISWHITE
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
continue|continue;
name|size
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|Length
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|hp
operator|->
name|Header
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|Length
operator|<
name|size
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|RENEW
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|hp
operator|->
name|Header
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|hp
operator|->
name|HasHeader
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Read body of article, just to get lines. */
for|for
control|(
name|lines
operator|=
literal|0
init|;
condition|;
name|lines
operator|++
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|QIOread
argument_list|(
name|qp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|QIOtoolong
argument_list|(
name|qp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|QIOerror
argument_list|(
name|qp
argument_list|)
condition|)
block|{
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
break|break;
block|}
comment|/* Calculate total size, fix hardwired headers. */
name|ov_size
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|ARTfieldsize
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|fp
operator|=
name|ARTfields
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
operator|,
name|fp
operator|++
control|)
block|{
if|if
condition|(
name|caseEQ
argument_list|(
name|fp
operator|->
name|Header
argument_list|,
literal|"Bytes"
argument_list|)
operator|||
name|caseEQ
argument_list|(
name|fp
operator|->
name|Header
argument_list|,
literal|"Lines"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|Header
index|[
literal|0
index|]
operator|==
literal|'B'
operator|||
name|fp
operator|->
name|Header
index|[
literal|0
index|]
operator|==
literal|'b'
condition|)
name|t
operator|=
name|fstat
argument_list|(
name|QIOfileno
argument_list|(
name|qp
argument_list|)
argument_list|,
operator|&
name|Sb
argument_list|)
operator|>=
literal|0
condition|?
operator|(
name|long
operator|)
name|Sb
operator|.
name|st_size
else|:
literal|0L
expr_stmt|;
else|else
name|t
operator|=
name|lines
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|value
argument_list|,
literal|"%ld"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|Length
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|hp
operator|->
name|Header
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|Length
operator|<
name|size
condition|)
block|{
name|hp
operator|->
name|Length
operator|=
name|size
expr_stmt|;
name|RENEW
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|char
argument_list|,
name|hp
operator|->
name|Length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hp
operator|->
name|Header
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|hp
operator|->
name|HasHeader
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|HasHeader
condition|)
name|ov_size
operator|+=
name|strlen
argument_list|(
name|hp
operator|->
name|Header
argument_list|)
expr_stmt|;
block|}
comment|/* Get space. */
if|if
condition|(
name|buffsize
operator|==
literal|0
condition|)
block|{
name|buffsize
operator|=
name|ov_size
expr_stmt|;
name|buff
operator|=
name|NEW
argument_list|(
name|char
argument_list|,
name|buffsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buffsize
operator|<
name|ov_size
condition|)
block|{
name|buffsize
operator|=
name|ov_size
expr_stmt|;
name|RENEW
argument_list|(
name|buff
argument_list|,
name|char
argument_list|,
name|buffsize
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Glue all the fields together. */
name|p
operator|=
name|buff
operator|+
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|buff
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hp
operator|=
name|Headers
operator|,
name|i
operator|=
name|ARTfieldsize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|hp
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\t'
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|HasHeader
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|p
argument_list|,
name|hp
operator|->
name|Header
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_comment
comment|/* **  XHDR, a common extension.  Retrieve specified header from a **  Message-ID or article range. */
end_comment

begin_function
name|FUNCTYPE
name|CMDxhdr
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|ARTNUM
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|Overview
decl_stmt|;
name|BOOL
name|IsLines
decl_stmt|;
name|ARTRANGE
name|range
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|ARTNUM
name|art
decl_stmt|;
if|if
condition|(
operator|!
name|PERMcanread
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
name|IsLines
operator|=
name|caseEQ
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"lines"
argument_list|)
expr_stmt|;
comment|/* Message-ID specified? */
if|if
condition|(
name|ac
operator|==
literal|3
operator|&&
name|av
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
operator|(
name|qp
operator|=
name|ARTopenbyid
argument_list|(
name|av
index|[
literal|2
index|]
argument_list|,
operator|&
name|art
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Reply
argument_list|(
literal|"%d No such article\r\n"
argument_list|,
name|NNTP_DONTHAVEIT_VAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|Reply
argument_list|(
literal|"%d %ld %s header of article %s.\r\n"
argument_list|,
name|NNTP_HEAD_FOLLOWS_VAL
argument_list|,
name|art
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|GetHeader
argument_list|(
name|qp
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|IsLines
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%s %s\r\n"
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|,
name|p
condition|?
name|p
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Range specified. */
if|if
condition|(
operator|!
name|CMDgetrange
argument_list|(
name|ac
operator|-
literal|1
argument_list|,
name|av
operator|+
literal|1
argument_list|,
operator|&
name|range
argument_list|)
condition|)
return|return;
comment|/* Is this a header in our overview? */
for|for
control|(
name|Overview
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARTfieldsize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|caseEQ
argument_list|(
name|ARTfields
index|[
name|i
index|]
operator|.
name|Header
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|OVERopen
argument_list|()
condition|)
name|Overview
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|Reply
argument_list|(
literal|"%d %s fields follow\r\n"
argument_list|,
name|NNTP_HEAD_FOLLOWS_VAL
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|range
operator|.
name|Low
init|;
name|i
operator|<=
name|range
operator|.
name|High
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ARTfind
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* Get it from the overview? */
if|if
condition|(
name|Overview
operator|&&
operator|(
name|p
operator|=
name|OVERfind
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|OVERGetHeader
argument_list|(
name|p
argument_list|,
name|Overview
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%d %s\r\n"
argument_list|,
name|i
argument_list|,
name|p
operator|&&
operator|*
name|p
condition|?
name|p
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|buff
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|=
name|GetHeader
argument_list|(
name|qp
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|IsLines
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"%d %s\r\n"
argument_list|,
name|i
argument_list|,
name|p
condition|?
name|p
else|:
literal|"(none)"
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  XOVER another extension.  Dump parts of the overview database. */
end_comment

begin_function
name|FUNCTYPE
name|CMDxover
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|ARTNUM
name|i
decl_stmt|;
specifier|register
name|BOOL
name|Opened
decl_stmt|;
name|ARTRANGE
name|range
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|PERMcanread
condition|)
block|{
name|Printf
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Trying to read. */
if|if
condition|(
name|GRPcount
operator|==
literal|0
condition|)
block|{
name|Reply
argument_list|(
literal|"%s\r\n"
argument_list|,
name|ARTnotingroup
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Parse range. */
if|if
condition|(
operator|!
name|CMDgetrange
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
operator|&
name|range
argument_list|)
condition|)
return|return;
name|Reply
argument_list|(
literal|"%d data follows\r\n"
argument_list|,
name|NNTP_OVERVIEW_FOLLOWS_VAL
argument_list|)
expr_stmt|;
for|for
control|(
name|Opened
operator|=
name|OVERopen
argument_list|()
operator|,
name|i
operator|=
name|range
operator|.
name|Low
init|;
name|i
operator|<=
name|range
operator|.
name|High
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ARTfind
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|Opened
operator|&&
operator|(
name|p
operator|=
name|OVERfind
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|Printf
argument_list|(
literal|"%s\r\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|OVERgen
argument_list|(
name|buff
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|Printf
argument_list|(
literal|"%s\r\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **  XPAT, an uncommon extension.  Print only headers that match the pattern. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|FUNCTYPE
name|CMDxpat
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|QIOSTATE
modifier|*
name|qp
decl_stmt|;
specifier|register
name|ARTNUM
name|i
decl_stmt|;
name|ARTRANGE
name|range
decl_stmt|;
name|char
modifier|*
name|header
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|Overview
decl_stmt|;
name|char
name|buff
index|[
name|SPOOLNAMEBUFF
index|]
decl_stmt|;
name|ARTNUM
name|art
decl_stmt|;
if|if
condition|(
operator|!
name|PERMcanread
condition|)
block|{
name|Printf
argument_list|(
literal|"%s\r\n"
argument_list|,
name|NOACCESS
argument_list|)
expr_stmt|;
return|return;
block|}
name|header
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
comment|/* Message-ID specified? */
if|if
condition|(
name|av
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
block|{
name|p
operator|=
name|av
index|[
literal|2
index|]
expr_stmt|;
name|qp
operator|=
name|ARTopenbyid
argument_list|(
name|p
argument_list|,
operator|&
name|art
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
block|{
name|Printf
argument_list|(
literal|"%d No such article.\r\n"
argument_list|,
name|NNTP_DONTHAVEIT_VAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|Printf
argument_list|(
literal|"%d %s matches follow.\r\n"
argument_list|,
name|NNTP_HEAD_FOLLOWS_VAL
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|Glom
argument_list|(
operator|&
name|av
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|text
operator|=
name|GetHeader
argument_list|(
name|qp
argument_list|,
name|header
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|wildmat
argument_list|(
name|text
argument_list|,
name|pattern
argument_list|)
condition|)
name|Printf
argument_list|(
literal|"%s %s\r\n"
argument_list|,
name|p
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Range specified. */
if|if
condition|(
operator|!
name|CMDgetrange
argument_list|(
name|ac
operator|-
literal|1
argument_list|,
name|av
operator|+
literal|1
argument_list|,
operator|&
name|range
argument_list|)
condition|)
return|return;
comment|/* In overview? */
for|for
control|(
name|Overview
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARTfieldsize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|caseEQ
argument_list|(
name|ARTfields
index|[
name|i
index|]
operator|.
name|Header
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|OVERopen
argument_list|()
condition|)
name|Overview
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|Printf
argument_list|(
literal|"%d %s matches follow.\r\n"
argument_list|,
name|NNTP_HEAD_FOLLOWS_VAL
argument_list|,
name|header
argument_list|)
expr_stmt|;
for|for
control|(
name|pattern
operator|=
name|Glom
argument_list|(
operator|&
name|av
index|[
literal|3
index|]
argument_list|)
operator|,
name|i
operator|=
name|range
operator|.
name|Low
init|;
name|i
operator|<
name|range
operator|.
name|High
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ARTfind
argument_list|(
name|i
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
comment|/* Get it from the Overview? */
if|if
condition|(
name|Overview
operator|&&
operator|(
name|p
operator|=
name|OVERfind
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|OVERGetHeader
argument_list|(
name|p
argument_list|,
name|Overview
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wildmat
argument_list|(
name|p
argument_list|,
name|pattern
argument_list|)
condition|)
name|Printf
argument_list|(
literal|"%ld %s\r\n"
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%ld"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|QIOopen
argument_list|(
name|buff
argument_list|,
name|QIO_BUFFER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|GetHeader
argument_list|(
name|qp
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
literal|"(none)"
expr_stmt|;
if|if
condition|(
name|wildmat
argument_list|(
name|p
argument_list|,
name|pattern
argument_list|)
condition|)
name|Printf
argument_list|(
literal|"%ld %s\r\n"
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|QIOclose
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|".\r\n"
argument_list|)
expr_stmt|;
name|DISPOSE
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

