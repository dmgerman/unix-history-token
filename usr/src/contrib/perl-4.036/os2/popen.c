begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* added real/protect mode branch at runtime and real mode version  * names changed for perl  * Kai Uwe Rommel  */
end_comment

begin_comment
comment|/* Several people in the past have asked about having Unix-like pipe calls in OS/2.  The following source file, adapted from 4.3 BSD Unix, uses a #define to give you a pipe(2) call, and contains function definitions for popen(3) and pclose(3).  Anyone with problems should send mail to me; they seem to work fine.  Mark Towfigh Racal Interlan, Inc. ----------------------------------cut-here------------------------------------ */
end_comment

begin_comment
comment|/*  * The following code segment is derived from BSD 4.3 Unix.  See  * copyright below.  Any bugs, questions, improvements, or problems  * should be sent to Mark Towfigh (towfiq@interlan.interlan.com).  *  * Racal InterLan Inc.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|INCL_NOPM
end_define

begin_define
define|#
directive|define
name|INCL_DOS
end_define

begin_include
include|#
directive|include
file|<os2.h>
end_include

begin_function_decl
specifier|static
name|FILE
modifier|*
name|dos_popen
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
specifier|const
name|char
modifier|*
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dos_pclose
parameter_list|(
name|FILE
modifier|*
name|pipe
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * emulate Unix pipe(2) call  */
end_comment

begin_define
define|#
directive|define
name|tst
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*mode == 'r'? (b) : (a))
end_define

begin_define
define|#
directive|define
name|READH
value|0
end_define

begin_define
define|#
directive|define
name|WRITEH
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|popen_pid
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|FILE
modifier|*
name|mypopen
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|myside
operator|,
name|hisside
operator|,
name|save_stream
expr_stmt|;
name|char
modifier|*
name|shell
init|=
name|getenv
argument_list|(
literal|"COMPSPEC"
argument_list|)
decl_stmt|;
if|if
condition|(
name|shell
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|"C:\\OS2\\CMD.EXE"
expr_stmt|;
if|if
condition|(
name|_osmode
operator|==
name|DOS_MODE
condition|)
return|return
name|dos_popen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|_pipe
argument_list|(
name|p
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|myside
operator|=
name|tst
argument_list|(
name|p
index|[
name|WRITEH
index|]
argument_list|,
name|p
index|[
name|READH
index|]
argument_list|)
expr_stmt|;
name|hisside
operator|=
name|tst
argument_list|(
name|p
index|[
name|READH
index|]
argument_list|,
name|p
index|[
name|WRITEH
index|]
argument_list|)
expr_stmt|;
comment|/* set up file descriptors for remote function */
name|save_stream
operator|=
name|dup
argument_list|(
name|tst
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't lose stdin/out! */
if|if
condition|(
name|dup2
argument_list|(
name|hisside
argument_list|,
name|tst
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|close
argument_list|(
name|hisside
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that we can close our side of the pipe, by 	 * preventing it from being inherited! 	 */
comment|/* set no-inheritance flag */
name|DosSetFHandState
argument_list|(
name|myside
argument_list|,
name|OPEN_FLAGS_NOINHERIT
argument_list|)
expr_stmt|;
comment|/* execute the command:  it will inherit our other file descriptors */
name|popen_pid
index|[
name|myside
index|]
operator|=
name|spawnlp
argument_list|(
name|P_NOWAIT
argument_list|,
name|shell
argument_list|,
name|shell
argument_list|,
literal|"/C"
argument_list|,
name|cmd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* now restore our previous file descriptors */
if|if
condition|(
name|dup2
argument_list|(
name|save_stream
argument_list|,
name|tst
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
comment|/* retrieve stdin/out */
block|{
name|perror
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|close
argument_list|(
name|save_stream
argument_list|)
expr_stmt|;
return|return
name|fdopen
argument_list|(
name|myside
argument_list|,
name|mode
argument_list|)
return|;
comment|/* return a FILE pointer */
block|}
end_function

begin_function
name|int
name|mypclose
parameter_list|(
name|FILE
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|f
expr_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|_osmode
operator|==
name|DOS_MODE
condition|)
return|return
name|dos_pclose
argument_list|(
name|ptr
argument_list|)
return|;
name|f
operator|=
name|fileno
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* wait for process to terminate */
name|cwait
argument_list|(
operator|&
name|status
argument_list|,
name|popen_pid
index|[
name|f
index|]
argument_list|,
name|WAIT_GRANDCHILD
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|pipe
parameter_list|(
name|int
modifier|*
name|filedes
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|res
operator|=
name|_pipe
argument_list|(
name|filedes
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|res
return|;
name|DosSetFHandState
argument_list|(
name|filedes
index|[
literal|0
index|]
argument_list|,
name|OPEN_FLAGS_NOINHERIT
argument_list|)
expr_stmt|;
name|DosSetFHandState
argument_list|(
name|filedes
index|[
literal|1
index|]
argument_list|,
name|OPEN_FLAGS_NOINHERIT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* this is the MS-DOS version */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|unopened
init|=
literal|0
block|,
name|reading
block|,
name|writing
block|}
name|pipemode
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|pipemode
name|pmode
decl_stmt|;
block|}
name|pipes
index|[
name|_NFILE
index|]
struct|;
end_struct

begin_function
specifier|static
name|FILE
modifier|*
name|dos_popen
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|current
decl_stmt|;
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|pipemode
name|curmode
decl_stmt|;
comment|/*     ** decide on mode.     */
if|if
condition|(
name|strchr
argument_list|(
name|mode
argument_list|,
literal|'r'
argument_list|)
operator|!=
name|NULL
condition|)
name|curmode
operator|=
name|reading
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|mode
argument_list|,
literal|'w'
argument_list|)
operator|!=
name|NULL
condition|)
name|curmode
operator|=
name|writing
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/*     ** get a name to use.     */
name|strcpy
argument_list|(
name|name
argument_list|,
name|tmp
condition|?
name|tmp
else|:
literal|"\\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
literal|"piXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*     ** If we're reading, just call system to get a file filled with     ** output.     */
if|if
condition|(
name|curmode
operator|==
name|reading
condition|)
block|{
name|char
name|cmd
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s> %s"
argument_list|,
name|command
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|current
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|cur
operator|=
name|fileno
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|command
operator|=
name|strdup
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|=
name|curmode
expr_stmt|;
return|return
name|current
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_pclose
parameter_list|(
name|FILE
modifier|*
name|current
parameter_list|)
block|{
name|int
name|cur
init|=
name|fileno
argument_list|(
name|current
argument_list|)
decl_stmt|,
name|rval
decl_stmt|;
name|char
name|command
index|[
literal|256
index|]
decl_stmt|;
comment|/*     ** check for an open file.     */
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|==
name|unopened
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|==
name|reading
condition|)
block|{
comment|/*         ** input pipes are just files we're done with.         */
name|rval
operator|=
name|fclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*         ** output pipes are temporary files we have         ** to cram down the throats of programs.         */
name|fclose
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s< %s"
argument_list|,
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|,
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|rval
operator|=
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*     ** clean up current pipe.     */
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pipes
index|[
name|cur
index|]
operator|.
name|command
argument_list|)
expr_stmt|;
name|pipes
index|[
name|cur
index|]
operator|.
name|pmode
operator|=
name|unopened
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

end_unit

