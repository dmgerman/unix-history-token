begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  $Revision: 4.0.1.1 $ ** **  Do shell-style pattern matching for ?, \, [], and * characters. **  Might not be robust in face of malformed patterns; e.g., "foo[a-" **  could cause a segmentation violation.  It is 8bit clean. ** **  Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986. **  Rich $alz is now<rsalz@bbn.com>. **  April, 1991:  Replaced mutually-recursive calls with in-line code **  for the star character. ** **  Special thanks to Lars Mathiesen<thorinn@diku.dk> for the ABORT code. **  This can greatly speed up failing wildcard patterns.  For example: **	pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-* **	text 1:	 -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1 **	text 2:	 -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1 **  Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without **  the ABORT, then it takes 22310 calls to fail.  Ugh.  The following **  explanation is from Lars: **  The precondition that must be fulfilled is that DoMatch will consume **  at least one character in text.  This is true if *p is neither '*' nor **  '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic **  behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With **  FALSE, each star-loop has to run to the end of the text; with ABORT **  only the last one does. ** **  Once the control of one instance of DoMatch enters the star-loop, that **  instance will return either TRUE or ABORT, and any calling instance **  will therefore return immediately after (without calling recursively **  again).  In effect, only one star-loop is ever active.  It would be **  possible to modify the code to maintain this context explicitly, **  eliminating all recursive calls at the cost of some complication and **  loss of clarity (and the ABORT stuff seems to be unclear enough by **  itself).  I think it would be unwise to try to get this into a **  released version unless you have a good test data base to try it out **  on. */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|ABORT
value|-1
end_define

begin_comment
comment|/* What character marks an inverted character class? */
end_comment

begin_define
define|#
directive|define
name|NEGATE_CLASS
value|'^'
end_define

begin_comment
comment|/* Is "*" a common pattern? */
end_comment

begin_define
define|#
directive|define
name|OPTIMIZE_JUST_STAR
end_define

begin_comment
comment|/* Do tar(1) matching rules, which ignore a trailing slash? */
end_comment

begin_undef
undef|#
directive|undef
name|MATCH_TAR_PATTERN
end_undef

begin_comment
comment|/* **  Match text and p, return TRUE, FALSE, or ABORT. */
end_comment

begin_function
specifier|static
name|int
name|DoMatch
parameter_list|(
name|text
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|last
decl_stmt|;
name|int
name|matched
decl_stmt|;
name|int
name|reverse
decl_stmt|;
for|for
control|(
init|;
operator|*
name|p
condition|;
name|text
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|text
operator|==
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
condition|)
return|return
name|ABORT
return|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\\'
case|:
comment|/* Literal match with following character. */
name|p
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
operator|*
name|text
operator|!=
operator|*
name|p
condition|)
return|return
name|FALSE
return|;
continue|continue;
case|case
literal|'?'
case|:
comment|/* Match anything. */
continue|continue;
case|case
literal|'*'
case|:
while|while
condition|(
operator|*
operator|++
name|p
operator|==
literal|'*'
condition|)
comment|/* Consecutive stars act just like one. */
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* Trailing star matches everything. */
return|return
name|TRUE
return|;
while|while
condition|(
operator|*
name|text
condition|)
if|if
condition|(
operator|(
name|matched
operator|=
name|DoMatch
argument_list|(
name|text
operator|++
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|FALSE
condition|)
return|return
name|matched
return|;
return|return
name|ABORT
return|;
case|case
literal|'['
case|:
name|reverse
operator|=
name|p
index|[
literal|1
index|]
operator|==
name|NEGATE_CLASS
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
comment|/* Inverted character class. */
name|p
operator|++
expr_stmt|;
for|for
control|(
name|last
operator|=
literal|0400
operator|,
name|matched
operator|=
name|FALSE
init|;
operator|*
operator|++
name|p
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|;
name|last
operator|=
operator|*
name|p
control|)
comment|/* This next line requires a good C compiler. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|?
operator|*
name|text
operator|<=
operator|*
operator|++
name|p
operator|&&
operator|*
name|text
operator|>=
name|last
else|:
operator|*
name|text
operator|==
operator|*
name|p
condition|)
name|matched
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|matched
operator|==
name|reverse
condition|)
return|return
name|FALSE
return|;
continue|continue;
block|}
block|}
ifdef|#
directive|ifdef
name|MATCH_TAR_PATTERN
if|if
condition|(
operator|*
name|text
operator|==
literal|'/'
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* MATCH_TAR_ATTERN */
return|return
operator|*
name|text
operator|==
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/* **  User-level routine.  Returns TRUE or FALSE. */
end_comment

begin_function
name|int
name|wildmat
parameter_list|(
name|text
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|OPTIMIZE_JUST_STAR
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* OPTIMIZE_JUST_STAR */
return|return
name|DoMatch
argument_list|(
name|text
argument_list|,
name|p
argument_list|)
operator|==
name|TRUE
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|unix
end_ifdef

begin_define
define|#
directive|define
name|_SIZE_T
end_define

begin_comment
comment|/* unix defines size_t in sys/types.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_COMPILER_H
end_ifndef

begin_include
include|#
directive|include
file|<compiler.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|rindex
argument_list|()
decl_stmt|,
modifier|*
name|strdup
argument_list|()
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__PROTO
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|MAX_DIR
value|32
end_define

begin_comment
comment|/* max depth of dir recursion */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|patt
decl_stmt|;
block|}
name|dir_stack
index|[
name|MAX_DIR
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|stack_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nmatches
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|ck_memalloc
name|__PROTO
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ck_strdup
parameter_list|(
name|p
parameter_list|)
value|ck_memalloc(strdup(p))
end_define

begin_define
define|#
directive|define
name|ck_malloc
parameter_list|(
name|s
parameter_list|)
value|ck_memalloc(malloc(s))
end_define

begin_define
define|#
directive|define
name|ck_realloc
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
value|ck_memalloc(realloc(p, s))
end_define

begin_define
define|#
directive|define
name|DEBUGX
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/*  * return true if patt contains a wildcard char  */
end_comment

begin_function
name|int
name|contains_wild
parameter_list|(
name|patt
parameter_list|)
name|char
modifier|*
name|patt
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* only check for wilds in the basename part of the pathname only */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|patt
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|rindex
argument_list|(
name|patt
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|patt
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
if|if
condition|(
operator|(
name|c
operator|==
literal|'*'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'?'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'['
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ZOO
end_ifndef

begin_function
name|void
name|free_all
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|matches
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|matches
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|push
parameter_list|(
name|dir
parameter_list|,
name|patt
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|patt
decl_stmt|;
block|{
if|if
condition|(
name|stack_p
operator|<
operator|(
name|MAX_DIR
operator|-
literal|2
operator|)
condition|)
name|stack_p
operator|++
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"directory stack overflow\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|99
argument_list|)
expr_stmt|;
block|}
name|dir_stack
index|[
name|stack_p
index|]
operator|.
name|dir
operator|=
name|dir
expr_stmt|;
name|dir_stack
index|[
name|stack_p
index|]
operator|.
name|patt
operator|=
name|patt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * glob patt  * if decend_dir is true, recursively decend any directories encountered.  * returns pointer to all matches encountered.  * if the initial patt is a directory, and decend_dir is true, it is  * equivalent to specifying the pattern "patt\*"  *  * Restrictions:  *  - handles wildcards only in the base part of a pathname  *    ie: will not handle \foo\*\bar\ (wildcard in the middle of pathname)  *  *  - max dir recursion is MAX_DIR  *  *  - on certain failures it will just skip potential matches as if they  *    were not present.  *  *  ++jrb	bammi@cadence.com  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|do_match
name|__PROTO
argument_list|(
operator|(
name|int
name|decend_dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
modifier|*
name|glob
parameter_list|(
name|patt
parameter_list|,
name|decend_dir
parameter_list|)
name|char
modifier|*
name|patt
decl_stmt|;
name|int
name|decend_dir
decl_stmt|;
block|{
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|basepatt
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"glob(%s, %d)\n"
argument_list|,
name|patt
argument_list|,
name|decend_dir
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matches
operator|=
name|NULL
expr_stmt|;
name|nmatches
operator|=
literal|0
expr_stmt|;
name|stack_p
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* first check for wildcards */
if|if
condition|(
name|contains_wild
argument_list|(
name|patt
argument_list|)
condition|)
block|{
comment|/* break it up into dir and base patt, do_matches and return */
name|p
operator|=
name|ck_strdup
argument_list|(
name|patt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|basepatt
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|basepatt
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|basepatt
condition|)
block|{
name|dir
operator|=
name|p
expr_stmt|;
operator|*
name|basepatt
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|basepatt
operator|=
name|ck_strdup
argument_list|(
name|basepatt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
name|ck_strdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|basepatt
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|basepatt
argument_list|,
literal|"*.*"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* the desktop, and other braindead shells strike again */
name|basepatt
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|push
argument_list|(
name|dir
argument_list|,
name|basepatt
argument_list|)
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"calling %s, %s\n"
argument_list|,
name|dir
argument_list|,
name|basepatt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|do_match
argument_list|(
name|decend_dir
argument_list|)
return|;
block|}
comment|/* if no wilds, check for dir */
if|if
condition|(
name|decend_dir
operator|&&
operator|(
operator|!
name|stat
argument_list|(
name|patt
argument_list|,
operator|&
name|s
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
comment|/* is a dir */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|patt
argument_list|)
decl_stmt|;
name|dir
operator|=
name|ck_strdup
argument_list|(
name|patt
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|&&
operator|(
operator|(
name|dir
index|[
name|len
index|]
operator|==
literal|'/'
operator|)
ifdef|#
directive|ifdef
name|atarist
operator|||
operator|(
name|dir
index|[
name|len
index|]
operator|==
literal|'\\'
operator|)
endif|#
directive|endif
operator|)
condition|)
name|dir
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|basepatt
operator|=
name|ck_strdup
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|dir
argument_list|,
name|basepatt
argument_list|)
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"calling %s, %s\n"
argument_list|,
name|dir
argument_list|,
name|basepatt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|do_match
argument_list|(
name|decend_dir
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|do_match
parameter_list|(
name|decend_dir
parameter_list|)
name|int
name|decend_dir
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|d
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|basepatt
decl_stmt|;
while|while
condition|(
name|stack_p
operator|>=
literal|0
condition|)
block|{
name|dir
operator|=
name|ck_strdup
argument_list|(
name|dir_stack
index|[
name|stack_p
index|]
operator|.
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir_stack
index|[
name|stack_p
index|]
operator|.
name|dir
argument_list|)
expr_stmt|;
name|basepatt
operator|=
name|ck_strdup
argument_list|(
name|dir_stack
index|[
name|stack_p
index|]
operator|.
name|patt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir_stack
index|[
name|stack_p
operator|--
index|]
operator|.
name|patt
argument_list|)
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dir %s patt %s stack %d\n"
argument_list|,
name|dir
argument_list|,
name|basepatt
argument_list|,
name|stack_p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirp
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no dir\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|ck_malloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|d
operator|->
name|d_name
argument_list|)
operator|+
literal|2L
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
condition|)
comment|/* If we have a full pathname then */
block|{
comment|/* let's append the directory info */
name|strcpy
argument_list|(
name|p
argument_list|,
name|dir
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|unix
name|strcat
argument_list|(
name|p
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|p
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Otherwise, the name is just fine, */
name|strcpy
argument_list|(
name|p
argument_list|,
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* there's no need for './' -- bjsjr */
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Testing %s\n"
argument_list|,
name|p
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|s
argument_list|)
condition|)
comment|/* if stat fails, ignore it */
block|{
if|if
condition|(
operator|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|)
operator|||
operator|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
operator|)
condition|)
block|{
comment|/* it is a file/symbolic link */
if|if
condition|(
name|wildmat
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
name|basepatt
argument_list|)
condition|)
block|{
comment|/* it matches pattern */
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File Matched\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
name|NULL
condition|)
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ck_realloc
argument_list|(
name|matches
argument_list|,
operator|(
name|nmatches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
index|[
name|nmatches
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
comment|/* no match */
else|else
block|{
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No File Match\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decend_dir
operator|&&
operator|(
operator|(
name|s
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
ifdef|#
directive|ifdef
name|atarist
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|d
operator|->
name|d_name
argument_list|,
literal|".dir"
argument_list|)
operator|)
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|push_p
init|=
name|ck_strdup
argument_list|(
literal|"*"
argument_list|)
decl_stmt|;
name|push
argument_list|(
name|p
argument_list|,
name|push_p
argument_list|)
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Dir pushed\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DIR skipped\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not a dir/no decend\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* stat */
else|else
block|{
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Stat failed\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while readdir */
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basepatt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Dir done\n\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* while dirs in stack */
if|if
condition|(
operator|!
name|nmatches
condition|)
block|{
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No matches\n"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|matches
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|matches
argument_list|,
operator|(
name|nmatches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|matches
index|[
name|nmatches
index|]
operator|=
name|NULL
expr_stmt|;
name|DEBUGX
argument_list|(
operator|(
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d matches\n"
argument_list|,
name|nmatches
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|matches
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZOO
end_ifdef

begin_include
include|#
directive|include
file|"errors.i"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
modifier|*
name|ck_memalloc
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
ifndef|#
directive|ifndef
name|ZOO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|98
argument_list|)
expr_stmt|;
else|#
directive|else
name|prterror
argument_list|(
literal|'f'
argument_list|,
name|no_memory
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|p
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_GLOB
end_ifdef

begin_function
name|void
name|test
parameter_list|(
name|path
parameter_list|,
name|dec
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|dec
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
modifier|*
name|matches
decl_stmt|;
name|printf
argument_list|(
literal|"Testing %s %d\n"
argument_list|,
name|path
argument_list|,
name|dec
argument_list|)
expr_stmt|;
name|matches
operator|=
name|glob
argument_list|(
name|path
argument_list|,
name|dec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|matches
condition|)
block|{
name|printf
argument_list|(
literal|"No matches\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|m
operator|=
name|matches
init|;
operator|*
name|m
condition|;
name|m
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|free_all
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|unix
name|test
argument_list|(
literal|"e:\\lib\\*.olb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test
argument_list|(
literal|"e:\\lib"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test
argument_list|(
literal|"e:\\lib\\"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|test
argument_list|(
literal|"/net/acae127/home/bammi/News/comp.sources.misc/*.c"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test
argument_list|(
literal|"/net/acae127/home/bammi/News/comp.sources.misc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test
argument_list|(
literal|"/net/acae127/home/bammi/News/comp.sources.misc"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|test
argument_list|(
literal|"/net/acae127/home/bammi/atari/cross-gcc"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_WILDMAT
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Yes, we use gets not fgets.  Sue me. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|gets
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|()
block|{
name|char
name|pattern
index|[
literal|80
index|]
decl_stmt|;
name|char
name|text
index|[
literal|80
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"Wildmat tester.  Enter pattern, then strings to test.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"A blank line gets prompts for a new pattern; a blank pattern\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"exits the program.\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"Enter pattern:  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|pattern
argument_list|)
operator|==
name|NULL
condition|)
break|break;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"Enter text:  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|text
argument_list|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* Blank line; go back and get a new pattern. */
break|break;
name|printf
argument_list|(
literal|"      %s\n"
argument_list|,
name|wildmat
argument_list|(
name|text
argument_list|,
name|pattern
argument_list|)
condition|?
literal|"YES"
else|:
literal|"NO"
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_WILDMAT */
end_comment

end_unit

